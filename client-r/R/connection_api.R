#' Sirqul IoT Platform
#'
#' Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
#'
#' The version of the OpenAPI document: 3.16
#' Contact: info@sirqul.com
#' Generated by: https://openapi-generator.tech
#'
#' @docType class
#' @title Connection operations
#' @description ConnectionApi
#' @format An \code{R6Class} generator object
#' @field api_client Handles the client-server communication.
#'
#' @examples
#' \dontrun{
#' ####################  AddConnectionToGroup  ####################
#'
#' library(openapi)
#' var_return_nulls <- "return_nulls_example" # character | whether to return nulls or not
#' var_group_id <- 56 # integer | the group id
#' var_device_id <- "device_id_example" # character | the device id (deviceId or accountId required) (Optional)
#' var_account_id <- 56 # integer | the account id of the user (deviceId or accountId required) (Optional)
#' var_connection_id <- 56 # integer | the connection id (Optional)
#' var_connection_account_id <- 56 # integer | the connection account id (Optional)
#' var_pending_id <- 56 # integer | the pending id (Optional)
#' var_latitude <- 3.4 # numeric | the current latitude of the user (Optional)
#' var_longitude <- 3.4 # numeric | the current longitude of the user (Optional)
#'
#' #Add Connection
#' api_instance <- ConnectionApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$AddConnectionToGroup(var_return_nulls, var_group_id, device_id = var_device_id, account_id = var_account_id, connection_id = var_connection_id, connection_account_id = var_connection_account_id, pending_id = var_pending_id, latitude = var_latitude, longitude = var_longitudedata_file = "result.txt")
#' result <- api_instance$AddConnectionToGroup(var_return_nulls, var_group_id, device_id = var_device_id, account_id = var_account_id, connection_id = var_connection_id, connection_account_id = var_connection_account_id, pending_id = var_pending_id, latitude = var_latitude, longitude = var_longitude)
#' dput(result)
#'
#'
#' ####################  AddConnectionsToGroup  ####################
#'
#' library(openapi)
#' var_connection_group_id <- 56 # integer | the connection group ID
#' var_device_id <- "device_id_example" # character | the device id (deviceId or accountId required) (Optional)
#' var_account_id <- 56 # integer | the account id of the user (deviceId or accountId required) (Optional)
#' var_connection_ids <- "connection_ids_example" # character | comma separated list of connection ids (Optional)
#' var_connection_account_ids <- "connection_account_ids_example" # character | comma separated list of connection account ids (Optional)
#' var_latitude <- 3.4 # numeric | the current latitude of the user (Optional)
#' var_longitude <- 3.4 # numeric | the current longitude of the user (Optional)
#'
#' #Add Connections
#' api_instance <- ConnectionApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$AddConnectionsToGroup(var_connection_group_id, device_id = var_device_id, account_id = var_account_id, connection_ids = var_connection_ids, connection_account_ids = var_connection_account_ids, latitude = var_latitude, longitude = var_longitudedata_file = "result.txt")
#' result <- api_instance$AddConnectionsToGroup(var_connection_group_id, device_id = var_device_id, account_id = var_account_id, connection_ids = var_connection_ids, connection_account_ids = var_connection_account_ids, latitude = var_latitude, longitude = var_longitude)
#' dput(result)
#'
#'
#' ####################  AddSubGroups  ####################
#'
#' library(openapi)
#' var_return_nulls <- "return_nulls_example" # character | whether to return nulls or not
#' var_group_id <- 56 # integer | the parent group id
#' var_sub_group_ids <- "sub_group_ids_example" # character | comma separated list of group IDs to add to the parent group
#' var_device_id <- "device_id_example" # character | the device id (deviceId or accountId required) (Optional)
#' var_account_id <- 56 # integer | the account id of the user (deviceId or accountId required) (Optional)
#' var_latitude <- 3.4 # numeric | the current latitude of the user (Optional)
#' var_longitude <- 3.4 # numeric | the current longitude of the user (Optional)
#'
#' #Add Connection Groups
#' api_instance <- ConnectionApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$AddSubGroups(var_return_nulls, var_group_id, var_sub_group_ids, device_id = var_device_id, account_id = var_account_id, latitude = var_latitude, longitude = var_longitudedata_file = "result.txt")
#' result <- api_instance$AddSubGroups(var_return_nulls, var_group_id, var_sub_group_ids, device_id = var_device_id, account_id = var_account_id, latitude = var_latitude, longitude = var_longitude)
#' dput(result)
#'
#'
#' ####################  CreateOrUpdateConnection  ####################
#'
#' library(openapi)
#' var_device_id <- "device_id_example" # character | the device id (deviceId or accountId required) (Optional)
#' var_account_id <- 56 # integer | the account id of the user (deviceId or accountId required) (Optional)
#' var_connection_id <- 56 # integer | the connection id for editing (Optional)
#' var_connection_account_id <- 56 # integer | the connection account id (i.e. the account id of another user) (Optional)
#' var_pending_id <- 56 # integer | the pending id (usually for people who do not have a Sirqul account but are already friends via other third party apps) (Optional)
#' var_group_id <- 56 # integer | optional group id if the user wants to add this person into a group (Optional)
#' var_game_type <- "game_type_example" # character | This parameter is deprecated. (Optional)
#' var_app_key <- "app_key_example" # character | the application key (Optional)
#' var_is_trusted <- "is_trusted_example" # character | determines whether the user is trusting this account (Optional)
#' var_ignore_friend_request <- "ignore_friend_request_example" # character | determines whether the user has set to ignore the user's friend request (Optional)
#' var_is_contact <- "is_contact_example" # character | determines whether the user is a contact of this account (Optional)
#' var_is_blocked <- "is_blocked_example" # character | determines whether the user is blocking this account (Optional)
#' var_is_following <- "is_following_example" # character | determines whether the user is following this account (Optional)
#' var_connection_response <- "connection_response_example" # character | whether to return the connection response or not (Optional)
#'
#' #Create or Update Connection
#' api_instance <- ConnectionApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$CreateOrUpdateConnection(device_id = var_device_id, account_id = var_account_id, connection_id = var_connection_id, connection_account_id = var_connection_account_id, pending_id = var_pending_id, group_id = var_group_id, game_type = var_game_type, app_key = var_app_key, is_trusted = var_is_trusted, ignore_friend_request = var_ignore_friend_request, is_contact = var_is_contact, is_blocked = var_is_blocked, is_following = var_is_following, connection_response = var_connection_responsedata_file = "result.txt")
#' result <- api_instance$CreateOrUpdateConnection(device_id = var_device_id, account_id = var_account_id, connection_id = var_connection_id, connection_account_id = var_connection_account_id, pending_id = var_pending_id, group_id = var_group_id, game_type = var_game_type, app_key = var_app_key, is_trusted = var_is_trusted, ignore_friend_request = var_ignore_friend_request, is_contact = var_is_contact, is_blocked = var_is_blocked, is_following = var_is_following, connection_response = var_connection_response)
#' dput(result)
#'
#'
#' ####################  CreateOrUpdateGroup  ####################
#'
#' library(openapi)
#' var_return_nulls <- "return_nulls_example" # character | whether to return nulls or not
#' var_device_id <- "device_id_example" # character | the device id (deviceId or accountId required) (Optional)
#' var_account_id <- 56 # integer | the account id of the user (deviceId or accountId required) (Optional)
#' var_name <- "name_example" # character | the name of the group (Optional)
#' var_group_id <- 56 # integer | the group id to update a group (don't pass anything in if you want to create a new group) (Optional)
#' var_asset_id <- 56 # integer | the asset to attach to the group (Optional)
#' var_connections <- "connections_example" # character | comma separated list of connection IDs (Optional)
#' var_description <- "description_example" # character | the description of the group (Optional)
#' var_can_view_profile_info <- "can_view_profile_info_example" # character | determines whether the connections in the group can see the user's profile info (Optional)
#' var_can_view_game_info <- "can_view_game_info_example" # character | determines whether the connections in the group can see the user's game info (Optional)
#' var_can_view_friend_info <- "can_view_friend_info_example" # character | determines whether the connections in the group can see the user's friends/connections (Optional)
#' var_active <- "active_example" # character | Sets whether the connection group is active or inactive (Optional)
#' var_latitude <- 3.4 # numeric | the latitude of the group (Optional)
#' var_longitude <- 3.4 # numeric | the longitude of the group (Optional)
#'
#' #Create or Update Connection Group
#' api_instance <- ConnectionApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$CreateOrUpdateGroup(var_return_nulls, device_id = var_device_id, account_id = var_account_id, name = var_name, group_id = var_group_id, asset_id = var_asset_id, connections = var_connections, description = var_description, can_view_profile_info = var_can_view_profile_info, can_view_game_info = var_can_view_game_info, can_view_friend_info = var_can_view_friend_info, active = var_active, latitude = var_latitude, longitude = var_longitudedata_file = "result.txt")
#' result <- api_instance$CreateOrUpdateGroup(var_return_nulls, device_id = var_device_id, account_id = var_account_id, name = var_name, group_id = var_group_id, asset_id = var_asset_id, connections = var_connections, description = var_description, can_view_profile_info = var_can_view_profile_info, can_view_game_info = var_can_view_game_info, can_view_friend_info = var_can_view_friend_info, active = var_active, latitude = var_latitude, longitude = var_longitude)
#' dput(result)
#'
#'
#' ####################  FollowAccept  ####################
#'
#' library(openapi)
#' var_account_id <- 56 # integer | the account id of the user
#' var_connection_account_id <- 56 # integer | the account ID of the user who initiated the follow
#' var_app_key <- "app_key_example" # character | the application key for sending notifications
#'
#' #Accept Follow Request
#' api_instance <- ConnectionApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$FollowAccept(var_account_id, var_connection_account_id, var_app_keydata_file = "result.txt")
#' result <- api_instance$FollowAccept(var_account_id, var_connection_account_id, var_app_key)
#' dput(result)
#'
#'
#' ####################  FollowReject  ####################
#'
#' library(openapi)
#' var_account_id <- 56 # integer | the account id of the user
#' var_connection_account_id <- 56 # integer | the account ID of the user who initiated the follow
#' var_app_key <- "app_key_example" # character | the application key for sending notifications
#'
#' #Reject Follow Request
#' api_instance <- ConnectionApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$FollowReject(var_account_id, var_connection_account_id, var_app_keydata_file = "result.txt")
#' result <- api_instance$FollowReject(var_account_id, var_connection_account_id, var_app_key)
#' dput(result)
#'
#'
#' ####################  FollowRemove  ####################
#'
#' library(openapi)
#' var_account_id <- 56 # integer | the account id of the user
#' var_connection_account_id <- 56 # integer | the account ID of the user who you want to unfollow
#' var_app_key <- "app_key_example" # character | the application key for sending notifications
#'
#' #Remove Follower / Unfollow
#' api_instance <- ConnectionApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$FollowRemove(var_account_id, var_connection_account_id, var_app_keydata_file = "result.txt")
#' result <- api_instance$FollowRemove(var_account_id, var_connection_account_id, var_app_key)
#' dput(result)
#'
#'
#' ####################  FollowRequest  ####################
#'
#' library(openapi)
#' var_account_id <- 56 # integer | the account id of the user
#' var_connection_account_id <- 56 # integer | the account ID of the user who you want to follow
#' var_app_key <- "app_key_example" # character | the application key for sending notifications
#' var_approval_needed <- TRUE # character | determines if the other user needs to confirm the follow request (Optional)
#'
#' #Send Follow Request
#' api_instance <- ConnectionApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$FollowRequest(var_account_id, var_connection_account_id, var_app_key, approval_needed = var_approval_neededdata_file = "result.txt")
#' result <- api_instance$FollowRequest(var_account_id, var_connection_account_id, var_app_key, approval_needed = var_approval_needed)
#' dput(result)
#'
#'
#' ####################  FriendAccept  ####################
#'
#' library(openapi)
#' var_friend_account_id <- 56 # integer | the friend's account id
#' var_notify_friend <- "notify_friend_example" # character | determines whether to send a notification to the afflicting party
#' var_device_id <- "device_id_example" # character | the device id (deviceId or accountId required) (Optional)
#' var_account_id <- 56 # integer | the account id of the user (deviceId or accountId required) (Optional)
#' var_game_type <- "game_type_example" # character | This parameter is deprecated. (Optional)
#' var_app_key <- "app_key_example" # character | the application key (Optional)
#' var_notification_message <- "notification_message_example" # character | optional message to send in a notification (Optional)
#'
#' #Accept Friend
#' api_instance <- ConnectionApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$FriendAccept(var_friend_account_id, var_notify_friend, device_id = var_device_id, account_id = var_account_id, game_type = var_game_type, app_key = var_app_key, notification_message = var_notification_messagedata_file = "result.txt")
#' result <- api_instance$FriendAccept(var_friend_account_id, var_notify_friend, device_id = var_device_id, account_id = var_account_id, game_type = var_game_type, app_key = var_app_key, notification_message = var_notification_message)
#' dput(result)
#'
#'
#' ####################  FriendReject  ####################
#'
#' library(openapi)
#' var_friend_account_id <- 56 # integer | the friend's account id
#' var_device_id <- "device_id_example" # character | the device id (deviceId or accountId required) (Optional)
#' var_account_id <- 56 # integer | the account id of the user (deviceId or accountId required) (Optional)
#' var_game_type <- "game_type_example" # character | This parameter is deprecated. (Optional)
#' var_app_key <- "app_key_example" # character | the application key (Optional)
#' var_notify_friend <- "notify_friend_example" # character | determines whether to send a notification to the afflicting party (Optional)
#' var_notification_message <- "notification_message_example" # character | optional message to send in a notification (Optional)
#'
#' #Decline Friend
#' api_instance <- ConnectionApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$FriendReject(var_friend_account_id, device_id = var_device_id, account_id = var_account_id, game_type = var_game_type, app_key = var_app_key, notify_friend = var_notify_friend, notification_message = var_notification_messagedata_file = "result.txt")
#' result <- api_instance$FriendReject(var_friend_account_id, device_id = var_device_id, account_id = var_account_id, game_type = var_game_type, app_key = var_app_key, notify_friend = var_notify_friend, notification_message = var_notification_message)
#' dput(result)
#'
#'
#' ####################  FriendRemove  ####################
#'
#' library(openapi)
#' var_friend_account_id <- 56 # integer | the account ID of the friend to remove
#' var_device_id <- "device_id_example" # character | the device id (deviceId or accountId required) (Optional)
#' var_account_id <- 56 # integer | the account id of the user (deviceId or accountId required) (Optional)
#' var_notify_friend <- "notify_friend_example" # character | optionally notifies the connection that they have been removed as a friend (Optional)
#' var_remove_from_groups <- "remove_from_groups_example" # character | optionally removes the connection from the user's groups (Optional)
#'
#' #Delete Friend
#' api_instance <- ConnectionApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$FriendRemove(var_friend_account_id, device_id = var_device_id, account_id = var_account_id, notify_friend = var_notify_friend, remove_from_groups = var_remove_from_groupsdata_file = "result.txt")
#' result <- api_instance$FriendRemove(var_friend_account_id, device_id = var_device_id, account_id = var_account_id, notify_friend = var_notify_friend, remove_from_groups = var_remove_from_groups)
#' dput(result)
#'
#'
#' ####################  FriendRequest  ####################
#'
#' library(openapi)
#' var_friend_account_id <- 56 # integer | the friend's account id
#' var_device_id <- "device_id_example" # character | the device id (deviceId or accountId required) (Optional)
#' var_account_id <- 56 # integer | the account id of the user (deviceId or accountId required) (Optional)
#' var_game_type <- "game_type_example" # character | This parameter is deprecated. (Optional)
#' var_app_key <- "app_key_example" # character | the application key (Optional)
#' var_notification_message <- "notification_message_example" # character | optional message to send in a notification (Optional)
#'
#' #Request Friend
#' api_instance <- ConnectionApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$FriendRequest(var_friend_account_id, device_id = var_device_id, account_id = var_account_id, game_type = var_game_type, app_key = var_app_key, notification_message = var_notification_messagedata_file = "result.txt")
#' result <- api_instance$FriendRequest(var_friend_account_id, device_id = var_device_id, account_id = var_account_id, game_type = var_game_type, app_key = var_app_key, notification_message = var_notification_message)
#' dput(result)
#'
#'
#' ####################  GetConnectionSentFriendRequests  ####################
#'
#' library(openapi)
#' var_device_id <- "device_id_example" # character | the ID of the device (Optional)
#' var_account_id <- 56 # integer | the id of the account (Optional)
#'
#' #Get Sent Friend Requests
#' api_instance <- ConnectionApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$GetConnectionSentFriendRequests(device_id = var_device_id, account_id = var_account_iddata_file = "result.txt")
#' result <- api_instance$GetConnectionSentFriendRequests(device_id = var_device_id, account_id = var_account_id)
#' dput(result)
#'
#'
#' ####################  GetConnections  ####################
#'
#' library(openapi)
#' var_return_nulls <- "return_nulls_example" # character | whether to return nulls or not
#' var_filter <- "filter_example" # character | a comma separated list of ConnectionApiMap. (NOTE on FOLLOWER vs FOLLOWING: FOLLOWER will get me a list of followers, FOLLOWING will get me a list of people I am following)
#' var_sort_field <- "sort_field_example" # character | sorts the response list by ConnectionApiMap
#' var_descending <- "descending_example" # character | sorts the response list by descending order if true
#' var_start <- 56 # integer | start index of the pagination
#' var_limit <- 56 # integer | limit of the pagination
#' var_device_id <- "device_id_example" # character | the device id (deviceId or accountId required) (Optional)
#' var_account_id <- 56 # integer | the account id (deviceId or accountId required) (Optional)
#' var_connection_account_id <- 56 # integer | optional parameter to search on other account's connections (Optional)
#' var_q <- "q_example" # character | This parameter is deprecated. (Optional)
#' var_keyword <- "keyword_example" # character | an optional keyword to search on, this parameter is ignored if empty (Optional)
#' var__i <- 56 # integer | This parameter is deprecated. (Optional)
#' var__l <- 56 # integer | This parameter is deprecated. (Optional)
#' var_latitude <- 3.4 # numeric | the current latitude of the user (Optional)
#' var_longitude <- 3.4 # numeric | the current longitude of the user (Optional)
#'
#' #Search Connections
#' api_instance <- ConnectionApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$GetConnections(var_return_nulls, var_filter, var_sort_field, var_descending, var_start, var_limit, device_id = var_device_id, account_id = var_account_id, connection_account_id = var_connection_account_id, q = var_q, keyword = var_keyword, _i = var__i, _l = var__l, latitude = var_latitude, longitude = var_longitudedata_file = "result.txt")
#' result <- api_instance$GetConnections(var_return_nulls, var_filter, var_sort_field, var_descending, var_start, var_limit, device_id = var_device_id, account_id = var_account_id, connection_account_id = var_connection_account_id, q = var_q, keyword = var_keyword, _i = var__i, _l = var__l, latitude = var_latitude, longitude = var_longitude)
#' dput(result)
#'
#'
#' ####################  GetGroupDetails  ####################
#'
#' library(openapi)
#' var_combine_connections <- "combine_connections_example" # character | whether to combine connections or not
#' var_device_id <- "device_id_example" # character | the device id (deviceId or accountId required) (Optional)
#' var_account_id <- 56 # integer | the account id of the user (deviceId or accountId required) (Optional)
#' var_group_id <- 56 # integer | the group id (Optional)
#' var_latitude <- 3.4 # numeric | the current latitude of the user (Optional)
#' var_longitude <- 3.4 # numeric | the current longitude of the user (Optional)
#'
#' #Get Connection Group
#' api_instance <- ConnectionApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$GetGroupDetails(var_combine_connections, device_id = var_device_id, account_id = var_account_id, group_id = var_group_id, latitude = var_latitude, longitude = var_longitudedata_file = "result.txt")
#' result <- api_instance$GetGroupDetails(var_combine_connections, device_id = var_device_id, account_id = var_account_id, group_id = var_group_id, latitude = var_latitude, longitude = var_longitude)
#' dput(result)
#'
#'
#' ####################  GroupSearch  ####################
#'
#' library(openapi)
#' var_sort_field <- "sort_field_example" # character | the field to sort by
#' var_descending <- "descending_example" # character | whether to return results in descending or ascending order
#' var_active_only <- "active_only_example" # character | to search on active only or not
#' var_start <- 56 # integer | The start of the pagination
#' var_limit <- 56 # integer | the limit of the pagination
#' var_device_id <- "device_id_example" # character | the device id (deviceId or accountId required) (Optional)
#' var_account_id <- 56 # integer | the account id of the user (deviceId or accountId required) (Optional)
#' var_latitude <- 3.4 # numeric | the current latitude of the user (Optional)
#' var_longitude <- 3.4 # numeric | the current longitude of the user (Optional)
#' var_keyword <- "keyword_example" # character | keyword search string (Optional)
#'
#' #Search Connection Groups
#' api_instance <- ConnectionApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$GroupSearch(var_sort_field, var_descending, var_active_only, var_start, var_limit, device_id = var_device_id, account_id = var_account_id, latitude = var_latitude, longitude = var_longitude, keyword = var_keyworddata_file = "result.txt")
#' result <- api_instance$GroupSearch(var_sort_field, var_descending, var_active_only, var_start, var_limit, device_id = var_device_id, account_id = var_account_id, latitude = var_latitude, longitude = var_longitude, keyword = var_keyword)
#' dput(result)
#'
#'
#' ####################  RemoveConnectionFromGroup  ####################
#'
#' library(openapi)
#' var_return_nulls <- "return_nulls_example" # character | whether to return nulls or not
#' var_group_id <- 56 # integer | the group id
#' var_device_id <- "device_id_example" # character | the device id (deviceId or accountId required) (Optional)
#' var_account_id <- 56 # integer | the account id of the user (deviceId or accountId required) (Optional)
#' var_connection_id <- 56 # integer | the connection id (Optional)
#' var_connection_account_id <- 56 # integer | the connection account id (Optional)
#' var_pending_id <- 56 # integer | the pending id (Optional)
#' var_latitude <- 3.4 # numeric | the current latitude of the user (Optional)
#' var_longitude <- 3.4 # numeric | the current longitude of the user (Optional)
#'
#' #Delete Connection
#' api_instance <- ConnectionApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$RemoveConnectionFromGroup(var_return_nulls, var_group_id, device_id = var_device_id, account_id = var_account_id, connection_id = var_connection_id, connection_account_id = var_connection_account_id, pending_id = var_pending_id, latitude = var_latitude, longitude = var_longitudedata_file = "result.txt")
#' result <- api_instance$RemoveConnectionFromGroup(var_return_nulls, var_group_id, device_id = var_device_id, account_id = var_account_id, connection_id = var_connection_id, connection_account_id = var_connection_account_id, pending_id = var_pending_id, latitude = var_latitude, longitude = var_longitude)
#' dput(result)
#'
#'
#' ####################  RemoveConnectionsFromGroup  ####################
#'
#' library(openapi)
#' var_connection_group_id <- 56 # integer | connection group id
#' var_device_id <- "device_id_example" # character | the device id (deviceId or accountId required) (Optional)
#' var_account_id <- 56 # integer | the account id of the user (deviceId or accountId required) (Optional)
#' var_connection_ids <- "connection_ids_example" # character | comma separated list of connection ids (Optional)
#' var_connection_account_ids <- "connection_account_ids_example" # character | comma separated list of connection account ids (Optional)
#' var_latitude <- 3.4 # numeric | the current latitude of the user (Optional)
#' var_longitude <- 3.4 # numeric | the current longitude of the user (Optional)
#'
#' #Remove Connections
#' api_instance <- ConnectionApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$RemoveConnectionsFromGroup(var_connection_group_id, device_id = var_device_id, account_id = var_account_id, connection_ids = var_connection_ids, connection_account_ids = var_connection_account_ids, latitude = var_latitude, longitude = var_longitudedata_file = "result.txt")
#' result <- api_instance$RemoveConnectionsFromGroup(var_connection_group_id, device_id = var_device_id, account_id = var_account_id, connection_ids = var_connection_ids, connection_account_ids = var_connection_account_ids, latitude = var_latitude, longitude = var_longitude)
#' dput(result)
#'
#'
#' ####################  RemoveGroup  ####################
#'
#' library(openapi)
#' var_return_nulls <- "return_nulls_example" # character | whether to return nulls or not
#' var_group_id <- 56 # integer | the group id
#' var_device_id <- "device_id_example" # character | the device id (deviceId or accountId required) (Optional)
#' var_account_id <- 56 # integer | the account id of the user (deviceId or accountId required) (Optional)
#' var_latitude <- 3.4 # numeric | the current latitude of the user (Optional)
#' var_longitude <- 3.4 # numeric | the current longitude of the user (Optional)
#'
#' #Delete Connection Group
#' api_instance <- ConnectionApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$RemoveGroup(var_return_nulls, var_group_id, device_id = var_device_id, account_id = var_account_id, latitude = var_latitude, longitude = var_longitudedata_file = "result.txt")
#' result <- api_instance$RemoveGroup(var_return_nulls, var_group_id, device_id = var_device_id, account_id = var_account_id, latitude = var_latitude, longitude = var_longitude)
#' dput(result)
#'
#'
#' ####################  RemoveSubGroups  ####################
#'
#' library(openapi)
#' var_return_nulls <- "return_nulls_example" # character | whether to return nulls or not
#' var_group_id <- 56 # integer | the parent group id
#' var_sub_group_ids <- "sub_group_ids_example" # character | comma separated list of group IDs to remove from the parent group
#' var_device_id <- "device_id_example" # character | the device id (deviceId or accountId required) (Optional)
#' var_account_id <- 56 # integer | the account id of the user (deviceId or accountId required) (Optional)
#' var_latitude <- 3.4 # numeric | the current latitude of the user (Optional)
#' var_longitude <- 3.4 # numeric | the current longitude of the user (Optional)
#'
#' #Remove Connection Groups
#' api_instance <- ConnectionApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$RemoveSubGroups(var_return_nulls, var_group_id, var_sub_group_ids, device_id = var_device_id, account_id = var_account_id, latitude = var_latitude, longitude = var_longitudedata_file = "result.txt")
#' result <- api_instance$RemoveSubGroups(var_return_nulls, var_group_id, var_sub_group_ids, device_id = var_device_id, account_id = var_account_id, latitude = var_latitude, longitude = var_longitude)
#' dput(result)
#'
#'
#' ####################  SearchConnections  ####################
#'
#' library(openapi)
#' var_return_nulls <- "return_nulls_example" # character | return all json attributes if true. defualt is true.
#' var_start <- 56 # integer | start index of the pagination
#' var_limit <- 56 # integer | limit of the pagination
#' var_device_id <- "device_id_example" # character | the device id (deviceId or accountId required) (Optional)
#' var_account_id <- 56 # integer | the account id (deviceId or accountId required) (Optional)
#' var_q <- "q_example" # character | This parameter is deprecated. (Optional)
#' var_keyword <- "keyword_example" # character | keyword to search on, optional and this parameter is ignored if empt (Optional)
#' var_latitude <- 3.4 # numeric | the current latitude of the user (Optional)
#' var_longitude <- 3.4 # numeric | the current longitude of the user (Optional)
#' var_game_type <- "game_type_example" # character | This parameter is deprecated. (Optional)
#' var_app_key <- "app_key_example" # character | the public application key, if provided only looks for users of that application (Optional)
#' var__i <- 56 # integer | This parameter is deprecated. (Optional)
#' var__l <- 56 # integer | This parameter is deprecated. (Optional)
#' var_sort_field <- "sort_field_example" # character | the field to sort on (Optional)
#' var_has_location <- "has_location_example" # character | whether the search has location or not (Optional)
#'
#' #Search Possible Connections
#' api_instance <- ConnectionApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$SearchConnections(var_return_nulls, var_start, var_limit, device_id = var_device_id, account_id = var_account_id, q = var_q, keyword = var_keyword, latitude = var_latitude, longitude = var_longitude, game_type = var_game_type, app_key = var_app_key, _i = var__i, _l = var__l, sort_field = var_sort_field, has_location = var_has_locationdata_file = "result.txt")
#' result <- api_instance$SearchConnections(var_return_nulls, var_start, var_limit, device_id = var_device_id, account_id = var_account_id, q = var_q, keyword = var_keyword, latitude = var_latitude, longitude = var_longitude, game_type = var_game_type, app_key = var_app_key, _i = var__i, _l = var__l, sort_field = var_sort_field, has_location = var_has_location)
#' dput(result)
#'
#'
#' }
#' @importFrom R6 R6Class
#' @importFrom base64enc base64encode
#' @export
ConnectionApi <- R6::R6Class(
  "ConnectionApi",
  public = list(
    api_client = NULL,

    #' @description
    #' Initialize a new ConnectionApi.
    #'
    #' @param api_client An instance of API client.
    initialize = function(api_client) {
      if (!missing(api_client)) {
        self$api_client <- api_client
      } else {
        self$api_client <- ApiClient$new()
      }
    },

    #' @description
    #' Add Connection
    #'
    #' @param return_nulls whether to return nulls or not
    #' @param group_id the group id
    #' @param device_id (optional) the device id (deviceId or accountId required)
    #' @param account_id (optional) the account id of the user (deviceId or accountId required)
    #' @param connection_id (optional) the connection id
    #' @param connection_account_id (optional) the connection account id
    #' @param pending_id (optional) the pending id
    #' @param latitude (optional) the current latitude of the user
    #' @param longitude (optional) the current longitude of the user
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return SirqulResponse
    AddConnectionToGroup = function(return_nulls, group_id, device_id = NULL, account_id = NULL, connection_id = NULL, connection_account_id = NULL, pending_id = NULL, latitude = NULL, longitude = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$AddConnectionToGroupWithHttpInfo(return_nulls, group_id, device_id, account_id, connection_id, connection_account_id, pending_id, latitude, longitude, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Add Connection
    #'
    #' @param return_nulls whether to return nulls or not
    #' @param group_id the group id
    #' @param device_id (optional) the device id (deviceId or accountId required)
    #' @param account_id (optional) the account id of the user (deviceId or accountId required)
    #' @param connection_id (optional) the connection id
    #' @param connection_account_id (optional) the connection account id
    #' @param pending_id (optional) the pending id
    #' @param latitude (optional) the current latitude of the user
    #' @param longitude (optional) the current longitude of the user
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (SirqulResponse) with additional information such as HTTP status code, headers
    AddConnectionToGroupWithHttpInfo = function(return_nulls, group_id, device_id = NULL, account_id = NULL, connection_id = NULL, connection_account_id = NULL, pending_id = NULL, latitude = NULL, longitude = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`return_nulls`)) {
        stop("Missing required parameter `return_nulls`.")
      }

      if (missing(`group_id`)) {
        stop("Missing required parameter `group_id`.")
      }

      if (!missing(`return_nulls`) && is.null(`return_nulls`)) {
        stop("Invalid value for `return_nulls` when calling ConnectionApi$AddConnectionToGroup, `return_nulls` is not nullable")
      }

      if (!missing(`group_id`) && is.null(`group_id`)) {
        stop("Invalid value for `group_id` when calling ConnectionApi$AddConnectionToGroup, `group_id` is not nullable")
      }

      if (!missing(`device_id`) && is.null(`device_id`)) {
        stop("Invalid value for `device_id` when calling ConnectionApi$AddConnectionToGroup, `device_id` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling ConnectionApi$AddConnectionToGroup, `account_id` is not nullable")
      }

      if (!missing(`connection_id`) && is.null(`connection_id`)) {
        stop("Invalid value for `connection_id` when calling ConnectionApi$AddConnectionToGroup, `connection_id` is not nullable")
      }

      if (!missing(`connection_account_id`) && is.null(`connection_account_id`)) {
        stop("Invalid value for `connection_account_id` when calling ConnectionApi$AddConnectionToGroup, `connection_account_id` is not nullable")
      }

      if (!missing(`pending_id`) && is.null(`pending_id`)) {
        stop("Invalid value for `pending_id` when calling ConnectionApi$AddConnectionToGroup, `pending_id` is not nullable")
      }

      if (!missing(`latitude`) && is.null(`latitude`)) {
        stop("Invalid value for `latitude` when calling ConnectionApi$AddConnectionToGroup, `latitude` is not nullable")
      }

      if (!missing(`longitude`) && is.null(`longitude`)) {
        stop("Invalid value for `longitude` when calling ConnectionApi$AddConnectionToGroup, `longitude` is not nullable")
      }

      query_params[["returnNulls"]] <- `return_nulls`

      query_params[["deviceId"]] <- `device_id`

      query_params[["accountId"]] <- `account_id`

      query_params[["connectionId"]] <- `connection_id`

      query_params[["connectionAccountId"]] <- `connection_account_id`

      query_params[["pendingId"]] <- `pending_id`

      query_params[["groupId"]] <- `group_id`

      query_params[["latitude"]] <- `latitude`

      query_params[["longitude"]] <- `longitude`

      local_var_url_path <- "/consumer/connection/group/addConnection"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "SirqulResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Add Connections
    #'
    #' @param connection_group_id the connection group ID
    #' @param device_id (optional) the device id (deviceId or accountId required)
    #' @param account_id (optional) the account id of the user (deviceId or accountId required)
    #' @param connection_ids (optional) comma separated list of connection ids
    #' @param connection_account_ids (optional) comma separated list of connection account ids
    #' @param latitude (optional) the current latitude of the user
    #' @param longitude (optional) the current longitude of the user
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return SirqulResponse
    AddConnectionsToGroup = function(connection_group_id, device_id = NULL, account_id = NULL, connection_ids = NULL, connection_account_ids = NULL, latitude = NULL, longitude = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$AddConnectionsToGroupWithHttpInfo(connection_group_id, device_id, account_id, connection_ids, connection_account_ids, latitude, longitude, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Add Connections
    #'
    #' @param connection_group_id the connection group ID
    #' @param device_id (optional) the device id (deviceId or accountId required)
    #' @param account_id (optional) the account id of the user (deviceId or accountId required)
    #' @param connection_ids (optional) comma separated list of connection ids
    #' @param connection_account_ids (optional) comma separated list of connection account ids
    #' @param latitude (optional) the current latitude of the user
    #' @param longitude (optional) the current longitude of the user
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (SirqulResponse) with additional information such as HTTP status code, headers
    AddConnectionsToGroupWithHttpInfo = function(connection_group_id, device_id = NULL, account_id = NULL, connection_ids = NULL, connection_account_ids = NULL, latitude = NULL, longitude = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`connection_group_id`)) {
        stop("Missing required parameter `connection_group_id`.")
      }

      if (!missing(`connection_group_id`) && is.null(`connection_group_id`)) {
        stop("Invalid value for `connection_group_id` when calling ConnectionApi$AddConnectionsToGroup, `connection_group_id` is not nullable")
      }

      if (!missing(`device_id`) && is.null(`device_id`)) {
        stop("Invalid value for `device_id` when calling ConnectionApi$AddConnectionsToGroup, `device_id` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling ConnectionApi$AddConnectionsToGroup, `account_id` is not nullable")
      }

      if (!missing(`connection_ids`) && is.null(`connection_ids`)) {
        stop("Invalid value for `connection_ids` when calling ConnectionApi$AddConnectionsToGroup, `connection_ids` is not nullable")
      }

      if (!missing(`connection_account_ids`) && is.null(`connection_account_ids`)) {
        stop("Invalid value for `connection_account_ids` when calling ConnectionApi$AddConnectionsToGroup, `connection_account_ids` is not nullable")
      }

      if (!missing(`latitude`) && is.null(`latitude`)) {
        stop("Invalid value for `latitude` when calling ConnectionApi$AddConnectionsToGroup, `latitude` is not nullable")
      }

      if (!missing(`longitude`) && is.null(`longitude`)) {
        stop("Invalid value for `longitude` when calling ConnectionApi$AddConnectionsToGroup, `longitude` is not nullable")
      }

      query_params[["deviceId"]] <- `device_id`

      query_params[["accountId"]] <- `account_id`

      query_params[["connectionIds"]] <- `connection_ids`

      query_params[["connectionAccountIds"]] <- `connection_account_ids`

      query_params[["connectionGroupId"]] <- `connection_group_id`

      query_params[["latitude"]] <- `latitude`

      query_params[["longitude"]] <- `longitude`

      local_var_url_path <- "/connection/group/addConnections"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "SirqulResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Add Connection Groups
    #'
    #' @param return_nulls whether to return nulls or not
    #' @param group_id the parent group id
    #' @param sub_group_ids comma separated list of group IDs to add to the parent group
    #' @param device_id (optional) the device id (deviceId or accountId required)
    #' @param account_id (optional) the account id of the user (deviceId or accountId required)
    #' @param latitude (optional) the current latitude of the user
    #' @param longitude (optional) the current longitude of the user
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return ConnectionGroupResponse
    AddSubGroups = function(return_nulls, group_id, sub_group_ids, device_id = NULL, account_id = NULL, latitude = NULL, longitude = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$AddSubGroupsWithHttpInfo(return_nulls, group_id, sub_group_ids, device_id, account_id, latitude, longitude, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Add Connection Groups
    #'
    #' @param return_nulls whether to return nulls or not
    #' @param group_id the parent group id
    #' @param sub_group_ids comma separated list of group IDs to add to the parent group
    #' @param device_id (optional) the device id (deviceId or accountId required)
    #' @param account_id (optional) the account id of the user (deviceId or accountId required)
    #' @param latitude (optional) the current latitude of the user
    #' @param longitude (optional) the current longitude of the user
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (ConnectionGroupResponse) with additional information such as HTTP status code, headers
    AddSubGroupsWithHttpInfo = function(return_nulls, group_id, sub_group_ids, device_id = NULL, account_id = NULL, latitude = NULL, longitude = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`return_nulls`)) {
        stop("Missing required parameter `return_nulls`.")
      }

      if (missing(`group_id`)) {
        stop("Missing required parameter `group_id`.")
      }

      if (missing(`sub_group_ids`)) {
        stop("Missing required parameter `sub_group_ids`.")
      }

      if (!missing(`return_nulls`) && is.null(`return_nulls`)) {
        stop("Invalid value for `return_nulls` when calling ConnectionApi$AddSubGroups, `return_nulls` is not nullable")
      }

      if (!missing(`group_id`) && is.null(`group_id`)) {
        stop("Invalid value for `group_id` when calling ConnectionApi$AddSubGroups, `group_id` is not nullable")
      }

      if (!missing(`sub_group_ids`) && is.null(`sub_group_ids`)) {
        stop("Invalid value for `sub_group_ids` when calling ConnectionApi$AddSubGroups, `sub_group_ids` is not nullable")
      }

      if (!missing(`device_id`) && is.null(`device_id`)) {
        stop("Invalid value for `device_id` when calling ConnectionApi$AddSubGroups, `device_id` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling ConnectionApi$AddSubGroups, `account_id` is not nullable")
      }

      if (!missing(`latitude`) && is.null(`latitude`)) {
        stop("Invalid value for `latitude` when calling ConnectionApi$AddSubGroups, `latitude` is not nullable")
      }

      if (!missing(`longitude`) && is.null(`longitude`)) {
        stop("Invalid value for `longitude` when calling ConnectionApi$AddSubGroups, `longitude` is not nullable")
      }

      query_params[["returnNulls"]] <- `return_nulls`

      query_params[["deviceId"]] <- `device_id`

      query_params[["accountId"]] <- `account_id`

      query_params[["groupId"]] <- `group_id`

      query_params[["subGroupIds"]] <- `sub_group_ids`

      query_params[["latitude"]] <- `latitude`

      query_params[["longitude"]] <- `longitude`

      local_var_url_path <- "/consumer/connection/group/addSubGroup"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "ConnectionGroupResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Create or Update Connection
    #'
    #' @param device_id (optional) the device id (deviceId or accountId required)
    #' @param account_id (optional) the account id of the user (deviceId or accountId required)
    #' @param connection_id (optional) the connection id for editing
    #' @param connection_account_id (optional) the connection account id (i.e. the account id of another user)
    #' @param pending_id (optional) the pending id (usually for people who do not have a Sirqul account but are already friends via other third party apps)
    #' @param group_id (optional) optional group id if the user wants to add this person into a group
    #' @param game_type (optional) This parameter is deprecated.
    #' @param app_key (optional) the application key
    #' @param is_trusted (optional) determines whether the user is trusting this account
    #' @param ignore_friend_request (optional) determines whether the user has set to ignore the user's friend request
    #' @param is_contact (optional) determines whether the user is a contact of this account
    #' @param is_blocked (optional) determines whether the user is blocking this account
    #' @param is_following (optional) determines whether the user is following this account
    #' @param connection_response (optional) whether to return the connection response or not
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return ConnectionResponse
    CreateOrUpdateConnection = function(device_id = NULL, account_id = NULL, connection_id = NULL, connection_account_id = NULL, pending_id = NULL, group_id = NULL, game_type = NULL, app_key = NULL, is_trusted = NULL, ignore_friend_request = NULL, is_contact = NULL, is_blocked = NULL, is_following = NULL, connection_response = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$CreateOrUpdateConnectionWithHttpInfo(device_id, account_id, connection_id, connection_account_id, pending_id, group_id, game_type, app_key, is_trusted, ignore_friend_request, is_contact, is_blocked, is_following, connection_response, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Create or Update Connection
    #'
    #' @param device_id (optional) the device id (deviceId or accountId required)
    #' @param account_id (optional) the account id of the user (deviceId or accountId required)
    #' @param connection_id (optional) the connection id for editing
    #' @param connection_account_id (optional) the connection account id (i.e. the account id of another user)
    #' @param pending_id (optional) the pending id (usually for people who do not have a Sirqul account but are already friends via other third party apps)
    #' @param group_id (optional) optional group id if the user wants to add this person into a group
    #' @param game_type (optional) This parameter is deprecated.
    #' @param app_key (optional) the application key
    #' @param is_trusted (optional) determines whether the user is trusting this account
    #' @param ignore_friend_request (optional) determines whether the user has set to ignore the user's friend request
    #' @param is_contact (optional) determines whether the user is a contact of this account
    #' @param is_blocked (optional) determines whether the user is blocking this account
    #' @param is_following (optional) determines whether the user is following this account
    #' @param connection_response (optional) whether to return the connection response or not
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (ConnectionResponse) with additional information such as HTTP status code, headers
    CreateOrUpdateConnectionWithHttpInfo = function(device_id = NULL, account_id = NULL, connection_id = NULL, connection_account_id = NULL, pending_id = NULL, group_id = NULL, game_type = NULL, app_key = NULL, is_trusted = NULL, ignore_friend_request = NULL, is_contact = NULL, is_blocked = NULL, is_following = NULL, connection_response = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (!missing(`device_id`) && is.null(`device_id`)) {
        stop("Invalid value for `device_id` when calling ConnectionApi$CreateOrUpdateConnection, `device_id` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling ConnectionApi$CreateOrUpdateConnection, `account_id` is not nullable")
      }

      if (!missing(`connection_id`) && is.null(`connection_id`)) {
        stop("Invalid value for `connection_id` when calling ConnectionApi$CreateOrUpdateConnection, `connection_id` is not nullable")
      }

      if (!missing(`connection_account_id`) && is.null(`connection_account_id`)) {
        stop("Invalid value for `connection_account_id` when calling ConnectionApi$CreateOrUpdateConnection, `connection_account_id` is not nullable")
      }

      if (!missing(`pending_id`) && is.null(`pending_id`)) {
        stop("Invalid value for `pending_id` when calling ConnectionApi$CreateOrUpdateConnection, `pending_id` is not nullable")
      }

      if (!missing(`group_id`) && is.null(`group_id`)) {
        stop("Invalid value for `group_id` when calling ConnectionApi$CreateOrUpdateConnection, `group_id` is not nullable")
      }

      if (!missing(`game_type`) && is.null(`game_type`)) {
        stop("Invalid value for `game_type` when calling ConnectionApi$CreateOrUpdateConnection, `game_type` is not nullable")
      }

      if (!missing(`app_key`) && is.null(`app_key`)) {
        stop("Invalid value for `app_key` when calling ConnectionApi$CreateOrUpdateConnection, `app_key` is not nullable")
      }

      if (!missing(`is_trusted`) && is.null(`is_trusted`)) {
        stop("Invalid value for `is_trusted` when calling ConnectionApi$CreateOrUpdateConnection, `is_trusted` is not nullable")
      }

      if (!missing(`ignore_friend_request`) && is.null(`ignore_friend_request`)) {
        stop("Invalid value for `ignore_friend_request` when calling ConnectionApi$CreateOrUpdateConnection, `ignore_friend_request` is not nullable")
      }

      if (!missing(`is_contact`) && is.null(`is_contact`)) {
        stop("Invalid value for `is_contact` when calling ConnectionApi$CreateOrUpdateConnection, `is_contact` is not nullable")
      }

      if (!missing(`is_blocked`) && is.null(`is_blocked`)) {
        stop("Invalid value for `is_blocked` when calling ConnectionApi$CreateOrUpdateConnection, `is_blocked` is not nullable")
      }

      if (!missing(`is_following`) && is.null(`is_following`)) {
        stop("Invalid value for `is_following` when calling ConnectionApi$CreateOrUpdateConnection, `is_following` is not nullable")
      }

      if (!missing(`connection_response`) && is.null(`connection_response`)) {
        stop("Invalid value for `connection_response` when calling ConnectionApi$CreateOrUpdateConnection, `connection_response` is not nullable")
      }

      query_params[["deviceId"]] <- `device_id`

      query_params[["accountId"]] <- `account_id`

      query_params[["connectionId"]] <- `connection_id`

      query_params[["connectionAccountId"]] <- `connection_account_id`

      query_params[["pendingId"]] <- `pending_id`

      query_params[["groupId"]] <- `group_id`

      query_params[["gameType"]] <- `game_type`

      query_params[["appKey"]] <- `app_key`

      query_params[["isTrusted"]] <- `is_trusted`

      query_params[["ignoreFriendRequest"]] <- `ignore_friend_request`

      query_params[["isContact"]] <- `is_contact`

      query_params[["isBlocked"]] <- `is_blocked`

      query_params[["isFollowing"]] <- `is_following`

      query_params[["connectionResponse"]] <- `connection_response`

      local_var_url_path <- "/consumer/connection/add"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "ConnectionResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Create or Update Connection Group
    #'
    #' @param return_nulls whether to return nulls or not
    #' @param device_id (optional) the device id (deviceId or accountId required)
    #' @param account_id (optional) the account id of the user (deviceId or accountId required)
    #' @param name (optional) the name of the group
    #' @param group_id (optional) the group id to update a group (don't pass anything in if you want to create a new group)
    #' @param asset_id (optional) the asset to attach to the group
    #' @param connections (optional) comma separated list of connection IDs
    #' @param description (optional) the description of the group
    #' @param can_view_profile_info (optional) determines whether the connections in the group can see the user's profile info
    #' @param can_view_game_info (optional) determines whether the connections in the group can see the user's game info
    #' @param can_view_friend_info (optional) determines whether the connections in the group can see the user's friends/connections
    #' @param active (optional) Sets whether the connection group is active or inactive
    #' @param latitude (optional) the latitude of the group
    #' @param longitude (optional) the longitude of the group
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return SirqulResponse
    CreateOrUpdateGroup = function(return_nulls, device_id = NULL, account_id = NULL, name = NULL, group_id = NULL, asset_id = NULL, connections = NULL, description = NULL, can_view_profile_info = NULL, can_view_game_info = NULL, can_view_friend_info = NULL, active = NULL, latitude = NULL, longitude = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$CreateOrUpdateGroupWithHttpInfo(return_nulls, device_id, account_id, name, group_id, asset_id, connections, description, can_view_profile_info, can_view_game_info, can_view_friend_info, active, latitude, longitude, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Create or Update Connection Group
    #'
    #' @param return_nulls whether to return nulls or not
    #' @param device_id (optional) the device id (deviceId or accountId required)
    #' @param account_id (optional) the account id of the user (deviceId or accountId required)
    #' @param name (optional) the name of the group
    #' @param group_id (optional) the group id to update a group (don't pass anything in if you want to create a new group)
    #' @param asset_id (optional) the asset to attach to the group
    #' @param connections (optional) comma separated list of connection IDs
    #' @param description (optional) the description of the group
    #' @param can_view_profile_info (optional) determines whether the connections in the group can see the user's profile info
    #' @param can_view_game_info (optional) determines whether the connections in the group can see the user's game info
    #' @param can_view_friend_info (optional) determines whether the connections in the group can see the user's friends/connections
    #' @param active (optional) Sets whether the connection group is active or inactive
    #' @param latitude (optional) the latitude of the group
    #' @param longitude (optional) the longitude of the group
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (SirqulResponse) with additional information such as HTTP status code, headers
    CreateOrUpdateGroupWithHttpInfo = function(return_nulls, device_id = NULL, account_id = NULL, name = NULL, group_id = NULL, asset_id = NULL, connections = NULL, description = NULL, can_view_profile_info = NULL, can_view_game_info = NULL, can_view_friend_info = NULL, active = NULL, latitude = NULL, longitude = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`return_nulls`)) {
        stop("Missing required parameter `return_nulls`.")
      }

      if (!missing(`return_nulls`) && is.null(`return_nulls`)) {
        stop("Invalid value for `return_nulls` when calling ConnectionApi$CreateOrUpdateGroup, `return_nulls` is not nullable")
      }

      if (!missing(`device_id`) && is.null(`device_id`)) {
        stop("Invalid value for `device_id` when calling ConnectionApi$CreateOrUpdateGroup, `device_id` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling ConnectionApi$CreateOrUpdateGroup, `account_id` is not nullable")
      }

      if (!missing(`name`) && is.null(`name`)) {
        stop("Invalid value for `name` when calling ConnectionApi$CreateOrUpdateGroup, `name` is not nullable")
      }

      if (!missing(`group_id`) && is.null(`group_id`)) {
        stop("Invalid value for `group_id` when calling ConnectionApi$CreateOrUpdateGroup, `group_id` is not nullable")
      }

      if (!missing(`asset_id`) && is.null(`asset_id`)) {
        stop("Invalid value for `asset_id` when calling ConnectionApi$CreateOrUpdateGroup, `asset_id` is not nullable")
      }

      if (!missing(`connections`) && is.null(`connections`)) {
        stop("Invalid value for `connections` when calling ConnectionApi$CreateOrUpdateGroup, `connections` is not nullable")
      }

      if (!missing(`description`) && is.null(`description`)) {
        stop("Invalid value for `description` when calling ConnectionApi$CreateOrUpdateGroup, `description` is not nullable")
      }

      if (!missing(`can_view_profile_info`) && is.null(`can_view_profile_info`)) {
        stop("Invalid value for `can_view_profile_info` when calling ConnectionApi$CreateOrUpdateGroup, `can_view_profile_info` is not nullable")
      }

      if (!missing(`can_view_game_info`) && is.null(`can_view_game_info`)) {
        stop("Invalid value for `can_view_game_info` when calling ConnectionApi$CreateOrUpdateGroup, `can_view_game_info` is not nullable")
      }

      if (!missing(`can_view_friend_info`) && is.null(`can_view_friend_info`)) {
        stop("Invalid value for `can_view_friend_info` when calling ConnectionApi$CreateOrUpdateGroup, `can_view_friend_info` is not nullable")
      }

      if (!missing(`active`) && is.null(`active`)) {
        stop("Invalid value for `active` when calling ConnectionApi$CreateOrUpdateGroup, `active` is not nullable")
      }

      if (!missing(`latitude`) && is.null(`latitude`)) {
        stop("Invalid value for `latitude` when calling ConnectionApi$CreateOrUpdateGroup, `latitude` is not nullable")
      }

      if (!missing(`longitude`) && is.null(`longitude`)) {
        stop("Invalid value for `longitude` when calling ConnectionApi$CreateOrUpdateGroup, `longitude` is not nullable")
      }

      query_params[["returnNulls"]] <- `return_nulls`

      query_params[["deviceId"]] <- `device_id`

      query_params[["accountId"]] <- `account_id`

      query_params[["name"]] <- `name`

      query_params[["groupId"]] <- `group_id`

      query_params[["assetId"]] <- `asset_id`

      query_params[["connections"]] <- `connections`

      query_params[["description"]] <- `description`

      query_params[["canViewProfileInfo"]] <- `can_view_profile_info`

      query_params[["canViewGameInfo"]] <- `can_view_game_info`

      query_params[["canViewFriendInfo"]] <- `can_view_friend_info`

      query_params[["active"]] <- `active`

      query_params[["latitude"]] <- `latitude`

      query_params[["longitude"]] <- `longitude`

      local_var_url_path <- "/consumer/connection/group"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "SirqulResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Accept Follow Request
    #'
    #' @param account_id the account id of the user
    #' @param connection_account_id the account ID of the user who initiated the follow
    #' @param app_key the application key for sending notifications
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return SirqulResponse
    FollowAccept = function(account_id, connection_account_id, app_key, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$FollowAcceptWithHttpInfo(account_id, connection_account_id, app_key, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Accept Follow Request
    #'
    #' @param account_id the account id of the user
    #' @param connection_account_id the account ID of the user who initiated the follow
    #' @param app_key the application key for sending notifications
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (SirqulResponse) with additional information such as HTTP status code, headers
    FollowAcceptWithHttpInfo = function(account_id, connection_account_id, app_key, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (missing(`connection_account_id`)) {
        stop("Missing required parameter `connection_account_id`.")
      }

      if (missing(`app_key`)) {
        stop("Missing required parameter `app_key`.")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling ConnectionApi$FollowAccept, `account_id` is not nullable")
      }

      if (!missing(`connection_account_id`) && is.null(`connection_account_id`)) {
        stop("Invalid value for `connection_account_id` when calling ConnectionApi$FollowAccept, `connection_account_id` is not nullable")
      }

      if (!missing(`app_key`) && is.null(`app_key`)) {
        stop("Invalid value for `app_key` when calling ConnectionApi$FollowAccept, `app_key` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["connectionAccountId"]] <- `connection_account_id`

      query_params[["appKey"]] <- `app_key`

      local_var_url_path <- "/consumer/follow/accept"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "SirqulResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Reject Follow Request
    #'
    #' @param account_id the account id of the user
    #' @param connection_account_id the account ID of the user who initiated the follow
    #' @param app_key the application key for sending notifications
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return SirqulResponse
    FollowReject = function(account_id, connection_account_id, app_key, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$FollowRejectWithHttpInfo(account_id, connection_account_id, app_key, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Reject Follow Request
    #'
    #' @param account_id the account id of the user
    #' @param connection_account_id the account ID of the user who initiated the follow
    #' @param app_key the application key for sending notifications
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (SirqulResponse) with additional information such as HTTP status code, headers
    FollowRejectWithHttpInfo = function(account_id, connection_account_id, app_key, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (missing(`connection_account_id`)) {
        stop("Missing required parameter `connection_account_id`.")
      }

      if (missing(`app_key`)) {
        stop("Missing required parameter `app_key`.")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling ConnectionApi$FollowReject, `account_id` is not nullable")
      }

      if (!missing(`connection_account_id`) && is.null(`connection_account_id`)) {
        stop("Invalid value for `connection_account_id` when calling ConnectionApi$FollowReject, `connection_account_id` is not nullable")
      }

      if (!missing(`app_key`) && is.null(`app_key`)) {
        stop("Invalid value for `app_key` when calling ConnectionApi$FollowReject, `app_key` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["connectionAccountId"]] <- `connection_account_id`

      query_params[["appKey"]] <- `app_key`

      local_var_url_path <- "/consumer/follow/reject"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "SirqulResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Remove Follower / Unfollow
    #'
    #' @param account_id the account id of the user
    #' @param connection_account_id the account ID of the user who you want to unfollow
    #' @param app_key the application key for sending notifications
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return SirqulResponse
    FollowRemove = function(account_id, connection_account_id, app_key, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$FollowRemoveWithHttpInfo(account_id, connection_account_id, app_key, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Remove Follower / Unfollow
    #'
    #' @param account_id the account id of the user
    #' @param connection_account_id the account ID of the user who you want to unfollow
    #' @param app_key the application key for sending notifications
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (SirqulResponse) with additional information such as HTTP status code, headers
    FollowRemoveWithHttpInfo = function(account_id, connection_account_id, app_key, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (missing(`connection_account_id`)) {
        stop("Missing required parameter `connection_account_id`.")
      }

      if (missing(`app_key`)) {
        stop("Missing required parameter `app_key`.")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling ConnectionApi$FollowRemove, `account_id` is not nullable")
      }

      if (!missing(`connection_account_id`) && is.null(`connection_account_id`)) {
        stop("Invalid value for `connection_account_id` when calling ConnectionApi$FollowRemove, `connection_account_id` is not nullable")
      }

      if (!missing(`app_key`) && is.null(`app_key`)) {
        stop("Invalid value for `app_key` when calling ConnectionApi$FollowRemove, `app_key` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["connectionAccountId"]] <- `connection_account_id`

      query_params[["appKey"]] <- `app_key`

      local_var_url_path <- "/consumer/follow/remove"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "SirqulResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Send Follow Request
    #'
    #' @param account_id the account id of the user
    #' @param connection_account_id the account ID of the user who you want to follow
    #' @param app_key the application key for sending notifications
    #' @param approval_needed (optional) determines if the other user needs to confirm the follow request (default value: TRUE)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return SirqulResponse
    FollowRequest = function(account_id, connection_account_id, app_key, approval_needed = TRUE, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$FollowRequestWithHttpInfo(account_id, connection_account_id, app_key, approval_needed, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Send Follow Request
    #'
    #' @param account_id the account id of the user
    #' @param connection_account_id the account ID of the user who you want to follow
    #' @param app_key the application key for sending notifications
    #' @param approval_needed (optional) determines if the other user needs to confirm the follow request (default value: TRUE)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (SirqulResponse) with additional information such as HTTP status code, headers
    FollowRequestWithHttpInfo = function(account_id, connection_account_id, app_key, approval_needed = TRUE, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (missing(`connection_account_id`)) {
        stop("Missing required parameter `connection_account_id`.")
      }

      if (missing(`app_key`)) {
        stop("Missing required parameter `app_key`.")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling ConnectionApi$FollowRequest, `account_id` is not nullable")
      }

      if (!missing(`connection_account_id`) && is.null(`connection_account_id`)) {
        stop("Invalid value for `connection_account_id` when calling ConnectionApi$FollowRequest, `connection_account_id` is not nullable")
      }

      if (!missing(`app_key`) && is.null(`app_key`)) {
        stop("Invalid value for `app_key` when calling ConnectionApi$FollowRequest, `app_key` is not nullable")
      }

      if (!missing(`approval_needed`) && is.null(`approval_needed`)) {
        stop("Invalid value for `approval_needed` when calling ConnectionApi$FollowRequest, `approval_needed` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["connectionAccountId"]] <- `connection_account_id`

      query_params[["appKey"]] <- `app_key`

      query_params[["approvalNeeded"]] <- `approval_needed`

      local_var_url_path <- "/consumer/follow/request"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "SirqulResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Accept Friend
    #'
    #' @param friend_account_id the friend's account id
    #' @param notify_friend determines whether to send a notification to the afflicting party
    #' @param device_id (optional) the device id (deviceId or accountId required)
    #' @param account_id (optional) the account id of the user (deviceId or accountId required)
    #' @param game_type (optional) This parameter is deprecated.
    #' @param app_key (optional) the application key
    #' @param notification_message (optional) optional message to send in a notification
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return SirqulResponse
    FriendAccept = function(friend_account_id, notify_friend, device_id = NULL, account_id = NULL, game_type = NULL, app_key = NULL, notification_message = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$FriendAcceptWithHttpInfo(friend_account_id, notify_friend, device_id, account_id, game_type, app_key, notification_message, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Accept Friend
    #'
    #' @param friend_account_id the friend's account id
    #' @param notify_friend determines whether to send a notification to the afflicting party
    #' @param device_id (optional) the device id (deviceId or accountId required)
    #' @param account_id (optional) the account id of the user (deviceId or accountId required)
    #' @param game_type (optional) This parameter is deprecated.
    #' @param app_key (optional) the application key
    #' @param notification_message (optional) optional message to send in a notification
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (SirqulResponse) with additional information such as HTTP status code, headers
    FriendAcceptWithHttpInfo = function(friend_account_id, notify_friend, device_id = NULL, account_id = NULL, game_type = NULL, app_key = NULL, notification_message = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`friend_account_id`)) {
        stop("Missing required parameter `friend_account_id`.")
      }

      if (missing(`notify_friend`)) {
        stop("Missing required parameter `notify_friend`.")
      }

      if (!missing(`friend_account_id`) && is.null(`friend_account_id`)) {
        stop("Invalid value for `friend_account_id` when calling ConnectionApi$FriendAccept, `friend_account_id` is not nullable")
      }

      if (!missing(`notify_friend`) && is.null(`notify_friend`)) {
        stop("Invalid value for `notify_friend` when calling ConnectionApi$FriendAccept, `notify_friend` is not nullable")
      }

      if (!missing(`device_id`) && is.null(`device_id`)) {
        stop("Invalid value for `device_id` when calling ConnectionApi$FriendAccept, `device_id` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling ConnectionApi$FriendAccept, `account_id` is not nullable")
      }

      if (!missing(`game_type`) && is.null(`game_type`)) {
        stop("Invalid value for `game_type` when calling ConnectionApi$FriendAccept, `game_type` is not nullable")
      }

      if (!missing(`app_key`) && is.null(`app_key`)) {
        stop("Invalid value for `app_key` when calling ConnectionApi$FriendAccept, `app_key` is not nullable")
      }

      if (!missing(`notification_message`) && is.null(`notification_message`)) {
        stop("Invalid value for `notification_message` when calling ConnectionApi$FriendAccept, `notification_message` is not nullable")
      }

      query_params[["deviceId"]] <- `device_id`

      query_params[["accountId"]] <- `account_id`

      query_params[["friendAccountId"]] <- `friend_account_id`

      query_params[["gameType"]] <- `game_type`

      query_params[["appKey"]] <- `app_key`

      query_params[["notifyFriend"]] <- `notify_friend`

      query_params[["notificationMessage"]] <- `notification_message`

      local_var_url_path <- "/consumer/friend/accept"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "SirqulResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Decline Friend
    #'
    #' @param friend_account_id the friend's account id
    #' @param device_id (optional) the device id (deviceId or accountId required)
    #' @param account_id (optional) the account id of the user (deviceId or accountId required)
    #' @param game_type (optional) This parameter is deprecated.
    #' @param app_key (optional) the application key
    #' @param notify_friend (optional) determines whether to send a notification to the afflicting party
    #' @param notification_message (optional) optional message to send in a notification
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return SirqulResponse
    FriendReject = function(friend_account_id, device_id = NULL, account_id = NULL, game_type = NULL, app_key = NULL, notify_friend = NULL, notification_message = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$FriendRejectWithHttpInfo(friend_account_id, device_id, account_id, game_type, app_key, notify_friend, notification_message, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Decline Friend
    #'
    #' @param friend_account_id the friend's account id
    #' @param device_id (optional) the device id (deviceId or accountId required)
    #' @param account_id (optional) the account id of the user (deviceId or accountId required)
    #' @param game_type (optional) This parameter is deprecated.
    #' @param app_key (optional) the application key
    #' @param notify_friend (optional) determines whether to send a notification to the afflicting party
    #' @param notification_message (optional) optional message to send in a notification
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (SirqulResponse) with additional information such as HTTP status code, headers
    FriendRejectWithHttpInfo = function(friend_account_id, device_id = NULL, account_id = NULL, game_type = NULL, app_key = NULL, notify_friend = NULL, notification_message = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`friend_account_id`)) {
        stop("Missing required parameter `friend_account_id`.")
      }

      if (!missing(`friend_account_id`) && is.null(`friend_account_id`)) {
        stop("Invalid value for `friend_account_id` when calling ConnectionApi$FriendReject, `friend_account_id` is not nullable")
      }

      if (!missing(`device_id`) && is.null(`device_id`)) {
        stop("Invalid value for `device_id` when calling ConnectionApi$FriendReject, `device_id` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling ConnectionApi$FriendReject, `account_id` is not nullable")
      }

      if (!missing(`game_type`) && is.null(`game_type`)) {
        stop("Invalid value for `game_type` when calling ConnectionApi$FriendReject, `game_type` is not nullable")
      }

      if (!missing(`app_key`) && is.null(`app_key`)) {
        stop("Invalid value for `app_key` when calling ConnectionApi$FriendReject, `app_key` is not nullable")
      }

      if (!missing(`notify_friend`) && is.null(`notify_friend`)) {
        stop("Invalid value for `notify_friend` when calling ConnectionApi$FriendReject, `notify_friend` is not nullable")
      }

      if (!missing(`notification_message`) && is.null(`notification_message`)) {
        stop("Invalid value for `notification_message` when calling ConnectionApi$FriendReject, `notification_message` is not nullable")
      }

      query_params[["deviceId"]] <- `device_id`

      query_params[["accountId"]] <- `account_id`

      query_params[["friendAccountId"]] <- `friend_account_id`

      query_params[["gameType"]] <- `game_type`

      query_params[["appKey"]] <- `app_key`

      query_params[["notifyFriend"]] <- `notify_friend`

      query_params[["notificationMessage"]] <- `notification_message`

      local_var_url_path <- "/consumer/friend/reject"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "SirqulResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Delete Friend
    #'
    #' @param friend_account_id the account ID of the friend to remove
    #' @param device_id (optional) the device id (deviceId or accountId required)
    #' @param account_id (optional) the account id of the user (deviceId or accountId required)
    #' @param notify_friend (optional) optionally notifies the connection that they have been removed as a friend
    #' @param remove_from_groups (optional) optionally removes the connection from the user's groups
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return SirqulResponse
    FriendRemove = function(friend_account_id, device_id = NULL, account_id = NULL, notify_friend = NULL, remove_from_groups = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$FriendRemoveWithHttpInfo(friend_account_id, device_id, account_id, notify_friend, remove_from_groups, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Delete Friend
    #'
    #' @param friend_account_id the account ID of the friend to remove
    #' @param device_id (optional) the device id (deviceId or accountId required)
    #' @param account_id (optional) the account id of the user (deviceId or accountId required)
    #' @param notify_friend (optional) optionally notifies the connection that they have been removed as a friend
    #' @param remove_from_groups (optional) optionally removes the connection from the user's groups
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (SirqulResponse) with additional information such as HTTP status code, headers
    FriendRemoveWithHttpInfo = function(friend_account_id, device_id = NULL, account_id = NULL, notify_friend = NULL, remove_from_groups = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`friend_account_id`)) {
        stop("Missing required parameter `friend_account_id`.")
      }

      if (!missing(`friend_account_id`) && is.null(`friend_account_id`)) {
        stop("Invalid value for `friend_account_id` when calling ConnectionApi$FriendRemove, `friend_account_id` is not nullable")
      }

      if (!missing(`device_id`) && is.null(`device_id`)) {
        stop("Invalid value for `device_id` when calling ConnectionApi$FriendRemove, `device_id` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling ConnectionApi$FriendRemove, `account_id` is not nullable")
      }

      if (!missing(`notify_friend`) && is.null(`notify_friend`)) {
        stop("Invalid value for `notify_friend` when calling ConnectionApi$FriendRemove, `notify_friend` is not nullable")
      }

      if (!missing(`remove_from_groups`) && is.null(`remove_from_groups`)) {
        stop("Invalid value for `remove_from_groups` when calling ConnectionApi$FriendRemove, `remove_from_groups` is not nullable")
      }

      query_params[["deviceId"]] <- `device_id`

      query_params[["accountId"]] <- `account_id`

      query_params[["friendAccountId"]] <- `friend_account_id`

      query_params[["notifyFriend"]] <- `notify_friend`

      query_params[["removeFromGroups"]] <- `remove_from_groups`

      local_var_url_path <- "/consumer/friend/remove"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "SirqulResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Request Friend
    #'
    #' @param friend_account_id the friend's account id
    #' @param device_id (optional) the device id (deviceId or accountId required)
    #' @param account_id (optional) the account id of the user (deviceId or accountId required)
    #' @param game_type (optional) This parameter is deprecated.
    #' @param app_key (optional) the application key
    #' @param notification_message (optional) optional message to send in a notification
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return SirqulResponse
    FriendRequest = function(friend_account_id, device_id = NULL, account_id = NULL, game_type = NULL, app_key = NULL, notification_message = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$FriendRequestWithHttpInfo(friend_account_id, device_id, account_id, game_type, app_key, notification_message, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Request Friend
    #'
    #' @param friend_account_id the friend's account id
    #' @param device_id (optional) the device id (deviceId or accountId required)
    #' @param account_id (optional) the account id of the user (deviceId or accountId required)
    #' @param game_type (optional) This parameter is deprecated.
    #' @param app_key (optional) the application key
    #' @param notification_message (optional) optional message to send in a notification
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (SirqulResponse) with additional information such as HTTP status code, headers
    FriendRequestWithHttpInfo = function(friend_account_id, device_id = NULL, account_id = NULL, game_type = NULL, app_key = NULL, notification_message = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`friend_account_id`)) {
        stop("Missing required parameter `friend_account_id`.")
      }

      if (!missing(`friend_account_id`) && is.null(`friend_account_id`)) {
        stop("Invalid value for `friend_account_id` when calling ConnectionApi$FriendRequest, `friend_account_id` is not nullable")
      }

      if (!missing(`device_id`) && is.null(`device_id`)) {
        stop("Invalid value for `device_id` when calling ConnectionApi$FriendRequest, `device_id` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling ConnectionApi$FriendRequest, `account_id` is not nullable")
      }

      if (!missing(`game_type`) && is.null(`game_type`)) {
        stop("Invalid value for `game_type` when calling ConnectionApi$FriendRequest, `game_type` is not nullable")
      }

      if (!missing(`app_key`) && is.null(`app_key`)) {
        stop("Invalid value for `app_key` when calling ConnectionApi$FriendRequest, `app_key` is not nullable")
      }

      if (!missing(`notification_message`) && is.null(`notification_message`)) {
        stop("Invalid value for `notification_message` when calling ConnectionApi$FriendRequest, `notification_message` is not nullable")
      }

      query_params[["deviceId"]] <- `device_id`

      query_params[["accountId"]] <- `account_id`

      query_params[["friendAccountId"]] <- `friend_account_id`

      query_params[["gameType"]] <- `game_type`

      query_params[["appKey"]] <- `app_key`

      query_params[["notificationMessage"]] <- `notification_message`

      local_var_url_path <- "/consumer/friend/request"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "SirqulResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Get Sent Friend Requests
    #'
    #' @param device_id (optional) the ID of the device
    #' @param account_id (optional) the id of the account
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return ConnectionListResponse
    GetConnectionSentFriendRequests = function(device_id = NULL, account_id = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$GetConnectionSentFriendRequestsWithHttpInfo(device_id, account_id, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Get Sent Friend Requests
    #'
    #' @param device_id (optional) the ID of the device
    #' @param account_id (optional) the id of the account
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (ConnectionListResponse) with additional information such as HTTP status code, headers
    GetConnectionSentFriendRequestsWithHttpInfo = function(device_id = NULL, account_id = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (!missing(`device_id`) && is.null(`device_id`)) {
        stop("Invalid value for `device_id` when calling ConnectionApi$GetConnectionSentFriendRequests, `device_id` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling ConnectionApi$GetConnectionSentFriendRequests, `account_id` is not nullable")
      }

      query_params[["deviceId"]] <- `device_id`

      query_params[["accountId"]] <- `account_id`

      local_var_url_path <- "/consumer/connection/getRequested"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "ConnectionListResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Search Connections
    #'
    #' @param return_nulls whether to return nulls or not
    #' @param filter a comma separated list of ConnectionApiMap. (NOTE on FOLLOWER vs FOLLOWING: FOLLOWER will get me a list of followers, FOLLOWING will get me a list of people I am following)
    #' @param sort_field sorts the response list by ConnectionApiMap
    #' @param descending sorts the response list by descending order if true
    #' @param start start index of the pagination
    #' @param limit limit of the pagination
    #' @param device_id (optional) the device id (deviceId or accountId required)
    #' @param account_id (optional) the account id (deviceId or accountId required)
    #' @param connection_account_id (optional) optional parameter to search on other account's connections
    #' @param q (optional) This parameter is deprecated.
    #' @param keyword (optional) an optional keyword to search on, this parameter is ignored if empty
    #' @param _i (optional) This parameter is deprecated.
    #' @param _l (optional) This parameter is deprecated.
    #' @param latitude (optional) the current latitude of the user
    #' @param longitude (optional) the current longitude of the user
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return ConnectionListResponse
    GetConnections = function(return_nulls, filter, sort_field, descending, start, limit, device_id = NULL, account_id = NULL, connection_account_id = NULL, q = NULL, keyword = NULL, _i = NULL, _l = NULL, latitude = NULL, longitude = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$GetConnectionsWithHttpInfo(return_nulls, filter, sort_field, descending, start, limit, device_id, account_id, connection_account_id, q, keyword, _i, _l, latitude, longitude, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Search Connections
    #'
    #' @param return_nulls whether to return nulls or not
    #' @param filter a comma separated list of ConnectionApiMap. (NOTE on FOLLOWER vs FOLLOWING: FOLLOWER will get me a list of followers, FOLLOWING will get me a list of people I am following)
    #' @param sort_field sorts the response list by ConnectionApiMap
    #' @param descending sorts the response list by descending order if true
    #' @param start start index of the pagination
    #' @param limit limit of the pagination
    #' @param device_id (optional) the device id (deviceId or accountId required)
    #' @param account_id (optional) the account id (deviceId or accountId required)
    #' @param connection_account_id (optional) optional parameter to search on other account's connections
    #' @param q (optional) This parameter is deprecated.
    #' @param keyword (optional) an optional keyword to search on, this parameter is ignored if empty
    #' @param _i (optional) This parameter is deprecated.
    #' @param _l (optional) This parameter is deprecated.
    #' @param latitude (optional) the current latitude of the user
    #' @param longitude (optional) the current longitude of the user
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (ConnectionListResponse) with additional information such as HTTP status code, headers
    GetConnectionsWithHttpInfo = function(return_nulls, filter, sort_field, descending, start, limit, device_id = NULL, account_id = NULL, connection_account_id = NULL, q = NULL, keyword = NULL, _i = NULL, _l = NULL, latitude = NULL, longitude = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`return_nulls`)) {
        stop("Missing required parameter `return_nulls`.")
      }

      if (missing(`filter`)) {
        stop("Missing required parameter `filter`.")
      }

      if (missing(`sort_field`)) {
        stop("Missing required parameter `sort_field`.")
      }

      if (missing(`descending`)) {
        stop("Missing required parameter `descending`.")
      }

      if (missing(`start`)) {
        stop("Missing required parameter `start`.")
      }

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      if (!missing(`return_nulls`) && is.null(`return_nulls`)) {
        stop("Invalid value for `return_nulls` when calling ConnectionApi$GetConnections, `return_nulls` is not nullable")
      }

      if (!missing(`filter`) && is.null(`filter`)) {
        stop("Invalid value for `filter` when calling ConnectionApi$GetConnections, `filter` is not nullable")
      }

      if (!missing(`sort_field`) && is.null(`sort_field`)) {
        stop("Invalid value for `sort_field` when calling ConnectionApi$GetConnections, `sort_field` is not nullable")
      }

      if (!missing(`descending`) && is.null(`descending`)) {
        stop("Invalid value for `descending` when calling ConnectionApi$GetConnections, `descending` is not nullable")
      }

      if (!missing(`start`) && is.null(`start`)) {
        stop("Invalid value for `start` when calling ConnectionApi$GetConnections, `start` is not nullable")
      }

      if (!missing(`limit`) && is.null(`limit`)) {
        stop("Invalid value for `limit` when calling ConnectionApi$GetConnections, `limit` is not nullable")
      }

      if (!missing(`device_id`) && is.null(`device_id`)) {
        stop("Invalid value for `device_id` when calling ConnectionApi$GetConnections, `device_id` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling ConnectionApi$GetConnections, `account_id` is not nullable")
      }

      if (!missing(`connection_account_id`) && is.null(`connection_account_id`)) {
        stop("Invalid value for `connection_account_id` when calling ConnectionApi$GetConnections, `connection_account_id` is not nullable")
      }

      if (!missing(`q`) && is.null(`q`)) {
        stop("Invalid value for `q` when calling ConnectionApi$GetConnections, `q` is not nullable")
      }

      if (!missing(`keyword`) && is.null(`keyword`)) {
        stop("Invalid value for `keyword` when calling ConnectionApi$GetConnections, `keyword` is not nullable")
      }

      if (!missing(`_i`) && is.null(`_i`)) {
        stop("Invalid value for `_i` when calling ConnectionApi$GetConnections, `_i` is not nullable")
      }

      if (!missing(`_l`) && is.null(`_l`)) {
        stop("Invalid value for `_l` when calling ConnectionApi$GetConnections, `_l` is not nullable")
      }

      if (!missing(`latitude`) && is.null(`latitude`)) {
        stop("Invalid value for `latitude` when calling ConnectionApi$GetConnections, `latitude` is not nullable")
      }

      if (!missing(`longitude`) && is.null(`longitude`)) {
        stop("Invalid value for `longitude` when calling ConnectionApi$GetConnections, `longitude` is not nullable")
      }

      query_params[["returnNulls"]] <- `return_nulls`

      query_params[["deviceId"]] <- `device_id`

      query_params[["accountId"]] <- `account_id`

      query_params[["connectionAccountId"]] <- `connection_account_id`

      query_params[["filter"]] <- `filter`

      query_params[["q"]] <- `q`

      query_params[["keyword"]] <- `keyword`

      query_params[["sortField"]] <- `sort_field`

      query_params[["descending"]] <- `descending`

      query_params[["_i"]] <- `_i`

      query_params[["start"]] <- `start`

      query_params[["_l"]] <- `_l`

      query_params[["limit"]] <- `limit`

      query_params[["latitude"]] <- `latitude`

      query_params[["longitude"]] <- `longitude`

      local_var_url_path <- "/consumer/connection/get"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "ConnectionListResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Get Connection Group
    #'
    #' @param combine_connections whether to combine connections or not
    #' @param device_id (optional) the device id (deviceId or accountId required)
    #' @param account_id (optional) the account id of the user (deviceId or accountId required)
    #' @param group_id (optional) the group id
    #' @param latitude (optional) the current latitude of the user
    #' @param longitude (optional) the current longitude of the user
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return ConnectionGroupResponse
    GetGroupDetails = function(combine_connections, device_id = NULL, account_id = NULL, group_id = NULL, latitude = NULL, longitude = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$GetGroupDetailsWithHttpInfo(combine_connections, device_id, account_id, group_id, latitude, longitude, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Get Connection Group
    #'
    #' @param combine_connections whether to combine connections or not
    #' @param device_id (optional) the device id (deviceId or accountId required)
    #' @param account_id (optional) the account id of the user (deviceId or accountId required)
    #' @param group_id (optional) the group id
    #' @param latitude (optional) the current latitude of the user
    #' @param longitude (optional) the current longitude of the user
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (ConnectionGroupResponse) with additional information such as HTTP status code, headers
    GetGroupDetailsWithHttpInfo = function(combine_connections, device_id = NULL, account_id = NULL, group_id = NULL, latitude = NULL, longitude = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`combine_connections`)) {
        stop("Missing required parameter `combine_connections`.")
      }

      if (!missing(`combine_connections`) && is.null(`combine_connections`)) {
        stop("Invalid value for `combine_connections` when calling ConnectionApi$GetGroupDetails, `combine_connections` is not nullable")
      }

      if (!missing(`device_id`) && is.null(`device_id`)) {
        stop("Invalid value for `device_id` when calling ConnectionApi$GetGroupDetails, `device_id` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling ConnectionApi$GetGroupDetails, `account_id` is not nullable")
      }

      if (!missing(`group_id`) && is.null(`group_id`)) {
        stop("Invalid value for `group_id` when calling ConnectionApi$GetGroupDetails, `group_id` is not nullable")
      }

      if (!missing(`latitude`) && is.null(`latitude`)) {
        stop("Invalid value for `latitude` when calling ConnectionApi$GetGroupDetails, `latitude` is not nullable")
      }

      if (!missing(`longitude`) && is.null(`longitude`)) {
        stop("Invalid value for `longitude` when calling ConnectionApi$GetGroupDetails, `longitude` is not nullable")
      }

      query_params[["deviceId"]] <- `device_id`

      query_params[["accountId"]] <- `account_id`

      query_params[["groupId"]] <- `group_id`

      query_params[["combineConnections"]] <- `combine_connections`

      query_params[["latitude"]] <- `latitude`

      query_params[["longitude"]] <- `longitude`

      local_var_url_path <- "/consumer/connection/group/details/get"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "ConnectionGroupResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Search Connection Groups
    #'
    #' @param sort_field the field to sort by
    #' @param descending whether to return results in descending or ascending order
    #' @param active_only to search on active only or not
    #' @param start The start of the pagination
    #' @param limit the limit of the pagination
    #' @param device_id (optional) the device id (deviceId or accountId required)
    #' @param account_id (optional) the account id of the user (deviceId or accountId required)
    #' @param latitude (optional) the current latitude of the user
    #' @param longitude (optional) the current longitude of the user
    #' @param keyword (optional) keyword search string
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return array[ConnectionInfoResponse]
    GroupSearch = function(sort_field, descending, active_only, start, limit, device_id = NULL, account_id = NULL, latitude = NULL, longitude = NULL, keyword = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$GroupSearchWithHttpInfo(sort_field, descending, active_only, start, limit, device_id, account_id, latitude, longitude, keyword, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Search Connection Groups
    #'
    #' @param sort_field the field to sort by
    #' @param descending whether to return results in descending or ascending order
    #' @param active_only to search on active only or not
    #' @param start The start of the pagination
    #' @param limit the limit of the pagination
    #' @param device_id (optional) the device id (deviceId or accountId required)
    #' @param account_id (optional) the account id of the user (deviceId or accountId required)
    #' @param latitude (optional) the current latitude of the user
    #' @param longitude (optional) the current longitude of the user
    #' @param keyword (optional) keyword search string
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (array[ConnectionInfoResponse]) with additional information such as HTTP status code, headers
    GroupSearchWithHttpInfo = function(sort_field, descending, active_only, start, limit, device_id = NULL, account_id = NULL, latitude = NULL, longitude = NULL, keyword = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`sort_field`)) {
        stop("Missing required parameter `sort_field`.")
      }

      if (missing(`descending`)) {
        stop("Missing required parameter `descending`.")
      }

      if (missing(`active_only`)) {
        stop("Missing required parameter `active_only`.")
      }

      if (missing(`start`)) {
        stop("Missing required parameter `start`.")
      }

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      if (!missing(`sort_field`) && is.null(`sort_field`)) {
        stop("Invalid value for `sort_field` when calling ConnectionApi$GroupSearch, `sort_field` is not nullable")
      }

      if (!missing(`descending`) && is.null(`descending`)) {
        stop("Invalid value for `descending` when calling ConnectionApi$GroupSearch, `descending` is not nullable")
      }

      if (!missing(`active_only`) && is.null(`active_only`)) {
        stop("Invalid value for `active_only` when calling ConnectionApi$GroupSearch, `active_only` is not nullable")
      }

      if (!missing(`start`) && is.null(`start`)) {
        stop("Invalid value for `start` when calling ConnectionApi$GroupSearch, `start` is not nullable")
      }

      if (!missing(`limit`) && is.null(`limit`)) {
        stop("Invalid value for `limit` when calling ConnectionApi$GroupSearch, `limit` is not nullable")
      }

      if (!missing(`device_id`) && is.null(`device_id`)) {
        stop("Invalid value for `device_id` when calling ConnectionApi$GroupSearch, `device_id` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling ConnectionApi$GroupSearch, `account_id` is not nullable")
      }

      if (!missing(`latitude`) && is.null(`latitude`)) {
        stop("Invalid value for `latitude` when calling ConnectionApi$GroupSearch, `latitude` is not nullable")
      }

      if (!missing(`longitude`) && is.null(`longitude`)) {
        stop("Invalid value for `longitude` when calling ConnectionApi$GroupSearch, `longitude` is not nullable")
      }

      if (!missing(`keyword`) && is.null(`keyword`)) {
        stop("Invalid value for `keyword` when calling ConnectionApi$GroupSearch, `keyword` is not nullable")
      }

      query_params[["deviceId"]] <- `device_id`

      query_params[["accountId"]] <- `account_id`

      query_params[["latitude"]] <- `latitude`

      query_params[["longitude"]] <- `longitude`

      query_params[["keyword"]] <- `keyword`

      if (!is.null(`sort_field`) && !(`sort_field` %in% c("CREATED", "UPDATED", "ACTIVE", "NAME", "DESCRIPTION", "CAN_VIEW_PROFILE_INFO", "CAN_VIEW_GAME_INFO", "CAN_VIEW_FRIEND_INFO", "INVITE_CODE", "OWNER_DISPLAY", "OWNER_USERNAME"))) {
        stop("Invalid value for sort_field when calling ConnectionApi$GroupSearch. Must be [CREATED, UPDATED, ACTIVE, NAME, DESCRIPTION, CAN_VIEW_PROFILE_INFO, CAN_VIEW_GAME_INFO, CAN_VIEW_FRIEND_INFO, INVITE_CODE, OWNER_DISPLAY, OWNER_USERNAME].")
      }
      query_params[["sortField"]] <- `sort_field`

      query_params[["descending"]] <- `descending`

      query_params[["activeOnly"]] <- `active_only`

      query_params[["start"]] <- `start`

      query_params[["limit"]] <- `limit`

      local_var_url_path <- "/connection/group/search"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "array[ConnectionInfoResponse]"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Delete Connection
    #'
    #' @param return_nulls whether to return nulls or not
    #' @param group_id the group id
    #' @param device_id (optional) the device id (deviceId or accountId required)
    #' @param account_id (optional) the account id of the user (deviceId or accountId required)
    #' @param connection_id (optional) the connection id
    #' @param connection_account_id (optional) the connection account id
    #' @param pending_id (optional) the pending id
    #' @param latitude (optional) the current latitude of the user
    #' @param longitude (optional) the current longitude of the user
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return SirqulResponse
    RemoveConnectionFromGroup = function(return_nulls, group_id, device_id = NULL, account_id = NULL, connection_id = NULL, connection_account_id = NULL, pending_id = NULL, latitude = NULL, longitude = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$RemoveConnectionFromGroupWithHttpInfo(return_nulls, group_id, device_id, account_id, connection_id, connection_account_id, pending_id, latitude, longitude, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Delete Connection
    #'
    #' @param return_nulls whether to return nulls or not
    #' @param group_id the group id
    #' @param device_id (optional) the device id (deviceId or accountId required)
    #' @param account_id (optional) the account id of the user (deviceId or accountId required)
    #' @param connection_id (optional) the connection id
    #' @param connection_account_id (optional) the connection account id
    #' @param pending_id (optional) the pending id
    #' @param latitude (optional) the current latitude of the user
    #' @param longitude (optional) the current longitude of the user
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (SirqulResponse) with additional information such as HTTP status code, headers
    RemoveConnectionFromGroupWithHttpInfo = function(return_nulls, group_id, device_id = NULL, account_id = NULL, connection_id = NULL, connection_account_id = NULL, pending_id = NULL, latitude = NULL, longitude = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`return_nulls`)) {
        stop("Missing required parameter `return_nulls`.")
      }

      if (missing(`group_id`)) {
        stop("Missing required parameter `group_id`.")
      }

      if (!missing(`return_nulls`) && is.null(`return_nulls`)) {
        stop("Invalid value for `return_nulls` when calling ConnectionApi$RemoveConnectionFromGroup, `return_nulls` is not nullable")
      }

      if (!missing(`group_id`) && is.null(`group_id`)) {
        stop("Invalid value for `group_id` when calling ConnectionApi$RemoveConnectionFromGroup, `group_id` is not nullable")
      }

      if (!missing(`device_id`) && is.null(`device_id`)) {
        stop("Invalid value for `device_id` when calling ConnectionApi$RemoveConnectionFromGroup, `device_id` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling ConnectionApi$RemoveConnectionFromGroup, `account_id` is not nullable")
      }

      if (!missing(`connection_id`) && is.null(`connection_id`)) {
        stop("Invalid value for `connection_id` when calling ConnectionApi$RemoveConnectionFromGroup, `connection_id` is not nullable")
      }

      if (!missing(`connection_account_id`) && is.null(`connection_account_id`)) {
        stop("Invalid value for `connection_account_id` when calling ConnectionApi$RemoveConnectionFromGroup, `connection_account_id` is not nullable")
      }

      if (!missing(`pending_id`) && is.null(`pending_id`)) {
        stop("Invalid value for `pending_id` when calling ConnectionApi$RemoveConnectionFromGroup, `pending_id` is not nullable")
      }

      if (!missing(`latitude`) && is.null(`latitude`)) {
        stop("Invalid value for `latitude` when calling ConnectionApi$RemoveConnectionFromGroup, `latitude` is not nullable")
      }

      if (!missing(`longitude`) && is.null(`longitude`)) {
        stop("Invalid value for `longitude` when calling ConnectionApi$RemoveConnectionFromGroup, `longitude` is not nullable")
      }

      query_params[["returnNulls"]] <- `return_nulls`

      query_params[["deviceId"]] <- `device_id`

      query_params[["accountId"]] <- `account_id`

      query_params[["connectionId"]] <- `connection_id`

      query_params[["connectionAccountId"]] <- `connection_account_id`

      query_params[["pendingId"]] <- `pending_id`

      query_params[["groupId"]] <- `group_id`

      query_params[["latitude"]] <- `latitude`

      query_params[["longitude"]] <- `longitude`

      local_var_url_path <- "/consumer/connection/group/removeConnection"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "SirqulResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Remove Connections
    #'
    #' @param connection_group_id connection group id
    #' @param device_id (optional) the device id (deviceId or accountId required)
    #' @param account_id (optional) the account id of the user (deviceId or accountId required)
    #' @param connection_ids (optional) comma separated list of connection ids
    #' @param connection_account_ids (optional) comma separated list of connection account ids
    #' @param latitude (optional) the current latitude of the user
    #' @param longitude (optional) the current longitude of the user
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return SirqulResponse
    RemoveConnectionsFromGroup = function(connection_group_id, device_id = NULL, account_id = NULL, connection_ids = NULL, connection_account_ids = NULL, latitude = NULL, longitude = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$RemoveConnectionsFromGroupWithHttpInfo(connection_group_id, device_id, account_id, connection_ids, connection_account_ids, latitude, longitude, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Remove Connections
    #'
    #' @param connection_group_id connection group id
    #' @param device_id (optional) the device id (deviceId or accountId required)
    #' @param account_id (optional) the account id of the user (deviceId or accountId required)
    #' @param connection_ids (optional) comma separated list of connection ids
    #' @param connection_account_ids (optional) comma separated list of connection account ids
    #' @param latitude (optional) the current latitude of the user
    #' @param longitude (optional) the current longitude of the user
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (SirqulResponse) with additional information such as HTTP status code, headers
    RemoveConnectionsFromGroupWithHttpInfo = function(connection_group_id, device_id = NULL, account_id = NULL, connection_ids = NULL, connection_account_ids = NULL, latitude = NULL, longitude = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`connection_group_id`)) {
        stop("Missing required parameter `connection_group_id`.")
      }

      if (!missing(`connection_group_id`) && is.null(`connection_group_id`)) {
        stop("Invalid value for `connection_group_id` when calling ConnectionApi$RemoveConnectionsFromGroup, `connection_group_id` is not nullable")
      }

      if (!missing(`device_id`) && is.null(`device_id`)) {
        stop("Invalid value for `device_id` when calling ConnectionApi$RemoveConnectionsFromGroup, `device_id` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling ConnectionApi$RemoveConnectionsFromGroup, `account_id` is not nullable")
      }

      if (!missing(`connection_ids`) && is.null(`connection_ids`)) {
        stop("Invalid value for `connection_ids` when calling ConnectionApi$RemoveConnectionsFromGroup, `connection_ids` is not nullable")
      }

      if (!missing(`connection_account_ids`) && is.null(`connection_account_ids`)) {
        stop("Invalid value for `connection_account_ids` when calling ConnectionApi$RemoveConnectionsFromGroup, `connection_account_ids` is not nullable")
      }

      if (!missing(`latitude`) && is.null(`latitude`)) {
        stop("Invalid value for `latitude` when calling ConnectionApi$RemoveConnectionsFromGroup, `latitude` is not nullable")
      }

      if (!missing(`longitude`) && is.null(`longitude`)) {
        stop("Invalid value for `longitude` when calling ConnectionApi$RemoveConnectionsFromGroup, `longitude` is not nullable")
      }

      query_params[["deviceId"]] <- `device_id`

      query_params[["accountId"]] <- `account_id`

      query_params[["connectionIds"]] <- `connection_ids`

      query_params[["connectionAccountIds"]] <- `connection_account_ids`

      query_params[["connectionGroupId"]] <- `connection_group_id`

      query_params[["latitude"]] <- `latitude`

      query_params[["longitude"]] <- `longitude`

      local_var_url_path <- "/connection/group/removeConnections"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "SirqulResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Delete Connection Group
    #'
    #' @param return_nulls whether to return nulls or not
    #' @param group_id the group id
    #' @param device_id (optional) the device id (deviceId or accountId required)
    #' @param account_id (optional) the account id of the user (deviceId or accountId required)
    #' @param latitude (optional) the current latitude of the user
    #' @param longitude (optional) the current longitude of the user
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return SirqulResponse
    RemoveGroup = function(return_nulls, group_id, device_id = NULL, account_id = NULL, latitude = NULL, longitude = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$RemoveGroupWithHttpInfo(return_nulls, group_id, device_id, account_id, latitude, longitude, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Delete Connection Group
    #'
    #' @param return_nulls whether to return nulls or not
    #' @param group_id the group id
    #' @param device_id (optional) the device id (deviceId or accountId required)
    #' @param account_id (optional) the account id of the user (deviceId or accountId required)
    #' @param latitude (optional) the current latitude of the user
    #' @param longitude (optional) the current longitude of the user
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (SirqulResponse) with additional information such as HTTP status code, headers
    RemoveGroupWithHttpInfo = function(return_nulls, group_id, device_id = NULL, account_id = NULL, latitude = NULL, longitude = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`return_nulls`)) {
        stop("Missing required parameter `return_nulls`.")
      }

      if (missing(`group_id`)) {
        stop("Missing required parameter `group_id`.")
      }

      if (!missing(`return_nulls`) && is.null(`return_nulls`)) {
        stop("Invalid value for `return_nulls` when calling ConnectionApi$RemoveGroup, `return_nulls` is not nullable")
      }

      if (!missing(`group_id`) && is.null(`group_id`)) {
        stop("Invalid value for `group_id` when calling ConnectionApi$RemoveGroup, `group_id` is not nullable")
      }

      if (!missing(`device_id`) && is.null(`device_id`)) {
        stop("Invalid value for `device_id` when calling ConnectionApi$RemoveGroup, `device_id` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling ConnectionApi$RemoveGroup, `account_id` is not nullable")
      }

      if (!missing(`latitude`) && is.null(`latitude`)) {
        stop("Invalid value for `latitude` when calling ConnectionApi$RemoveGroup, `latitude` is not nullable")
      }

      if (!missing(`longitude`) && is.null(`longitude`)) {
        stop("Invalid value for `longitude` when calling ConnectionApi$RemoveGroup, `longitude` is not nullable")
      }

      query_params[["returnNulls"]] <- `return_nulls`

      query_params[["deviceId"]] <- `device_id`

      query_params[["accountId"]] <- `account_id`

      query_params[["groupId"]] <- `group_id`

      query_params[["latitude"]] <- `latitude`

      query_params[["longitude"]] <- `longitude`

      local_var_url_path <- "/consumer/connection/group/remove"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "SirqulResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Remove Connection Groups
    #'
    #' @param return_nulls whether to return nulls or not
    #' @param group_id the parent group id
    #' @param sub_group_ids comma separated list of group IDs to remove from the parent group
    #' @param device_id (optional) the device id (deviceId or accountId required)
    #' @param account_id (optional) the account id of the user (deviceId or accountId required)
    #' @param latitude (optional) the current latitude of the user
    #' @param longitude (optional) the current longitude of the user
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return SirqulResponse
    RemoveSubGroups = function(return_nulls, group_id, sub_group_ids, device_id = NULL, account_id = NULL, latitude = NULL, longitude = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$RemoveSubGroupsWithHttpInfo(return_nulls, group_id, sub_group_ids, device_id, account_id, latitude, longitude, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Remove Connection Groups
    #'
    #' @param return_nulls whether to return nulls or not
    #' @param group_id the parent group id
    #' @param sub_group_ids comma separated list of group IDs to remove from the parent group
    #' @param device_id (optional) the device id (deviceId or accountId required)
    #' @param account_id (optional) the account id of the user (deviceId or accountId required)
    #' @param latitude (optional) the current latitude of the user
    #' @param longitude (optional) the current longitude of the user
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (SirqulResponse) with additional information such as HTTP status code, headers
    RemoveSubGroupsWithHttpInfo = function(return_nulls, group_id, sub_group_ids, device_id = NULL, account_id = NULL, latitude = NULL, longitude = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`return_nulls`)) {
        stop("Missing required parameter `return_nulls`.")
      }

      if (missing(`group_id`)) {
        stop("Missing required parameter `group_id`.")
      }

      if (missing(`sub_group_ids`)) {
        stop("Missing required parameter `sub_group_ids`.")
      }

      if (!missing(`return_nulls`) && is.null(`return_nulls`)) {
        stop("Invalid value for `return_nulls` when calling ConnectionApi$RemoveSubGroups, `return_nulls` is not nullable")
      }

      if (!missing(`group_id`) && is.null(`group_id`)) {
        stop("Invalid value for `group_id` when calling ConnectionApi$RemoveSubGroups, `group_id` is not nullable")
      }

      if (!missing(`sub_group_ids`) && is.null(`sub_group_ids`)) {
        stop("Invalid value for `sub_group_ids` when calling ConnectionApi$RemoveSubGroups, `sub_group_ids` is not nullable")
      }

      if (!missing(`device_id`) && is.null(`device_id`)) {
        stop("Invalid value for `device_id` when calling ConnectionApi$RemoveSubGroups, `device_id` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling ConnectionApi$RemoveSubGroups, `account_id` is not nullable")
      }

      if (!missing(`latitude`) && is.null(`latitude`)) {
        stop("Invalid value for `latitude` when calling ConnectionApi$RemoveSubGroups, `latitude` is not nullable")
      }

      if (!missing(`longitude`) && is.null(`longitude`)) {
        stop("Invalid value for `longitude` when calling ConnectionApi$RemoveSubGroups, `longitude` is not nullable")
      }

      query_params[["returnNulls"]] <- `return_nulls`

      query_params[["deviceId"]] <- `device_id`

      query_params[["accountId"]] <- `account_id`

      query_params[["groupId"]] <- `group_id`

      query_params[["subGroupIds"]] <- `sub_group_ids`

      query_params[["latitude"]] <- `latitude`

      query_params[["longitude"]] <- `longitude`

      local_var_url_path <- "/consumer/connection/group/removeSubGroup"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "SirqulResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Search Possible Connections
    #'
    #' @param return_nulls return all json attributes if true. defualt is true.
    #' @param start start index of the pagination
    #' @param limit limit of the pagination
    #' @param device_id (optional) the device id (deviceId or accountId required)
    #' @param account_id (optional) the account id (deviceId or accountId required)
    #' @param q (optional) This parameter is deprecated.
    #' @param keyword (optional) keyword to search on, optional and this parameter is ignored if empt
    #' @param latitude (optional) the current latitude of the user
    #' @param longitude (optional) the current longitude of the user
    #' @param game_type (optional) This parameter is deprecated.
    #' @param app_key (optional) the public application key, if provided only looks for users of that application
    #' @param _i (optional) This parameter is deprecated.
    #' @param _l (optional) This parameter is deprecated.
    #' @param sort_field (optional) the field to sort on
    #' @param has_location (optional) whether the search has location or not
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return ConnectionListResponse
    SearchConnections = function(return_nulls, start, limit, device_id = NULL, account_id = NULL, q = NULL, keyword = NULL, latitude = NULL, longitude = NULL, game_type = NULL, app_key = NULL, _i = NULL, _l = NULL, sort_field = NULL, has_location = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$SearchConnectionsWithHttpInfo(return_nulls, start, limit, device_id, account_id, q, keyword, latitude, longitude, game_type, app_key, _i, _l, sort_field, has_location, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Search Possible Connections
    #'
    #' @param return_nulls return all json attributes if true. defualt is true.
    #' @param start start index of the pagination
    #' @param limit limit of the pagination
    #' @param device_id (optional) the device id (deviceId or accountId required)
    #' @param account_id (optional) the account id (deviceId or accountId required)
    #' @param q (optional) This parameter is deprecated.
    #' @param keyword (optional) keyword to search on, optional and this parameter is ignored if empt
    #' @param latitude (optional) the current latitude of the user
    #' @param longitude (optional) the current longitude of the user
    #' @param game_type (optional) This parameter is deprecated.
    #' @param app_key (optional) the public application key, if provided only looks for users of that application
    #' @param _i (optional) This parameter is deprecated.
    #' @param _l (optional) This parameter is deprecated.
    #' @param sort_field (optional) the field to sort on
    #' @param has_location (optional) whether the search has location or not
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (ConnectionListResponse) with additional information such as HTTP status code, headers
    SearchConnectionsWithHttpInfo = function(return_nulls, start, limit, device_id = NULL, account_id = NULL, q = NULL, keyword = NULL, latitude = NULL, longitude = NULL, game_type = NULL, app_key = NULL, _i = NULL, _l = NULL, sort_field = NULL, has_location = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`return_nulls`)) {
        stop("Missing required parameter `return_nulls`.")
      }

      if (missing(`start`)) {
        stop("Missing required parameter `start`.")
      }

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      if (!missing(`return_nulls`) && is.null(`return_nulls`)) {
        stop("Invalid value for `return_nulls` when calling ConnectionApi$SearchConnections, `return_nulls` is not nullable")
      }

      if (!missing(`start`) && is.null(`start`)) {
        stop("Invalid value for `start` when calling ConnectionApi$SearchConnections, `start` is not nullable")
      }

      if (!missing(`limit`) && is.null(`limit`)) {
        stop("Invalid value for `limit` when calling ConnectionApi$SearchConnections, `limit` is not nullable")
      }

      if (!missing(`device_id`) && is.null(`device_id`)) {
        stop("Invalid value for `device_id` when calling ConnectionApi$SearchConnections, `device_id` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling ConnectionApi$SearchConnections, `account_id` is not nullable")
      }

      if (!missing(`q`) && is.null(`q`)) {
        stop("Invalid value for `q` when calling ConnectionApi$SearchConnections, `q` is not nullable")
      }

      if (!missing(`keyword`) && is.null(`keyword`)) {
        stop("Invalid value for `keyword` when calling ConnectionApi$SearchConnections, `keyword` is not nullable")
      }

      if (!missing(`latitude`) && is.null(`latitude`)) {
        stop("Invalid value for `latitude` when calling ConnectionApi$SearchConnections, `latitude` is not nullable")
      }

      if (!missing(`longitude`) && is.null(`longitude`)) {
        stop("Invalid value for `longitude` when calling ConnectionApi$SearchConnections, `longitude` is not nullable")
      }

      if (!missing(`game_type`) && is.null(`game_type`)) {
        stop("Invalid value for `game_type` when calling ConnectionApi$SearchConnections, `game_type` is not nullable")
      }

      if (!missing(`app_key`) && is.null(`app_key`)) {
        stop("Invalid value for `app_key` when calling ConnectionApi$SearchConnections, `app_key` is not nullable")
      }

      if (!missing(`_i`) && is.null(`_i`)) {
        stop("Invalid value for `_i` when calling ConnectionApi$SearchConnections, `_i` is not nullable")
      }

      if (!missing(`_l`) && is.null(`_l`)) {
        stop("Invalid value for `_l` when calling ConnectionApi$SearchConnections, `_l` is not nullable")
      }

      if (!missing(`sort_field`) && is.null(`sort_field`)) {
        stop("Invalid value for `sort_field` when calling ConnectionApi$SearchConnections, `sort_field` is not nullable")
      }

      if (!missing(`has_location`) && is.null(`has_location`)) {
        stop("Invalid value for `has_location` when calling ConnectionApi$SearchConnections, `has_location` is not nullable")
      }

      query_params[["returnNulls"]] <- `return_nulls`

      query_params[["deviceId"]] <- `device_id`

      query_params[["accountId"]] <- `account_id`

      query_params[["q"]] <- `q`

      query_params[["keyword"]] <- `keyword`

      query_params[["latitude"]] <- `latitude`

      query_params[["longitude"]] <- `longitude`

      query_params[["gameType"]] <- `game_type`

      query_params[["appKey"]] <- `app_key`

      query_params[["_i"]] <- `_i`

      query_params[["start"]] <- `start`

      query_params[["_l"]] <- `_l`

      query_params[["limit"]] <- `limit`

      query_params[["sortField"]] <- `sort_field`

      query_params[["hasLocation"]] <- `has_location`

      local_var_url_path <- "/connection/search"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "ConnectionListResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    }
  )
)
