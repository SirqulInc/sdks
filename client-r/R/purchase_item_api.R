#' Sirqul IoT Platform
#'
#' Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
#'
#' The version of the OpenAPI document: 3.16
#' Contact: info@sirqul.com
#' Generated by: https://openapi-generator.tech
#'
#' @docType class
#' @title PurchaseItem operations
#' @description PurchaseItemApi
#' @format An \code{R6Class} generator object
#' @field api_client Handles the client-server communication.
#'
#' @examples
#' \dontrun{
#' ####################  CreatePurchaseItem  ####################
#'
#' library(openapi)
#' var_app_key <- "app_key_example" # character | The application key that the purchase can be used in
#' var_name <- "name_example" # character | The name of the purchase item
#' var_purchase_type <- "purchase_type_example" # character | The purchase provider <ul> <li>SIRQUL - the Sirqul store to make purchases using tickets</li> <li>IOS - the iTunes store for iPhone, iPod, iPod Touch</li> <li>GOOGLE - the Google Play store</li> <li>AMAZON - the Amazon Android store</li> <li>MAC - the iTunes store for OSX</li> <li>WP8 - the Windows Phone 8 store</li> <li>FREE - used for purchase items that are free (can be used for development/testing purposes)</li> </ul>
#' var_device_id <- "device_id_example" # character | The device id (deviceId or accountId required) (Optional)
#' var_account_id <- 56 # integer | The account id of the user (deviceId or accountId required) (Optional)
#' var_description <- "description_example" # character | The description of the purchase item (Optional)
#' var_tickets <- 56 # integer | How much the purchase item is worth in tickets (Optional)
#' var_price <- 3.4 # numeric | How much the purchase item will cost in real money (Optional)
#' var_purchase_code <- "purchase_code_example" # character | The unique identifier used by purchase providers to identify in-app-purchases (Optional)
#' var_secret_key <- "secret_key_example" # character | A secret key from purchase providers that would be used for validation (Optional)
#' var_purchase_limit <- 0 # integer | How many times a user acquire the same purchase item (Optional)
#' var_service_action <- "service_action_example" # character | Determines whether the purchase item will enable certain features <ul> <li>DAY_PREMIUM - subscribes a user for a day of membership</li> <li>WEEK_PREMIUM - subscribes a user for a week of membership</li> <li>MONTH_PREMIUM - subscribes a user for a month of membership</li> <li>ADD_TICKET - allows a user to add more tickets to their account</li> <li>ADD_GIFT - allows a user to send/recieve the purchase item as a gift</li> </ul> (Optional)
#' var_cover_asset_id <- 56 # integer | The cover image of the purchase item (Optional)
#' var_promo_asset_id <- 56 # integer | An application specific asset that can be used to store/provide additional data (Optional)
#' var_giftable <- "giftable_example" # character | Determines whether the purchase item can be gifted to other users (Optional)
#' var_assetable <- "assetable_example" # character | Determines whether users can attach their own media/asset to the purchase item (Optional)
#' var_allocate_tickets <- FALSE # character | Flag to indicate owner should receive tickets for completed missions (Optional)
#' var_ticket_type <- "ticket_type_example" # character | The type of ticket to reward, null means default type (Optional)
#' var_points <- 56 # integer | The number of points to award for completing a mission (Optional)
#' var_offer_location_id <- 56 # integer | The offer location that will get added to the user's wallet after purchase. (Optional)
#'
#' #Create Purchase
#' api_instance <- PurchaseItemApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$CreatePurchaseItem(var_app_key, var_name, var_purchase_type, device_id = var_device_id, account_id = var_account_id, description = var_description, tickets = var_tickets, price = var_price, purchase_code = var_purchase_code, secret_key = var_secret_key, purchase_limit = var_purchase_limit, service_action = var_service_action, cover_asset_id = var_cover_asset_id, promo_asset_id = var_promo_asset_id, giftable = var_giftable, assetable = var_assetable, allocate_tickets = var_allocate_tickets, ticket_type = var_ticket_type, points = var_points, offer_location_id = var_offer_location_iddata_file = "result.txt")
#' result <- api_instance$CreatePurchaseItem(var_app_key, var_name, var_purchase_type, device_id = var_device_id, account_id = var_account_id, description = var_description, tickets = var_tickets, price = var_price, purchase_code = var_purchase_code, secret_key = var_secret_key, purchase_limit = var_purchase_limit, service_action = var_service_action, cover_asset_id = var_cover_asset_id, promo_asset_id = var_promo_asset_id, giftable = var_giftable, assetable = var_assetable, allocate_tickets = var_allocate_tickets, ticket_type = var_ticket_type, points = var_points, offer_location_id = var_offer_location_id)
#' dput(result)
#'
#'
#' ####################  DeletePurchaseItem  ####################
#'
#' library(openapi)
#' var_purchase_item_id <- 56 # integer | The purchase item id
#' var_device_id <- "device_id_example" # character | The device id (deviceId or accountId required) (Optional)
#' var_account_id <- 56 # integer | The account id of the user (deviceId or accountId required) (Optional)
#'
#' #Delete Purchase
#' api_instance <- PurchaseItemApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$DeletePurchaseItem(var_purchase_item_id, device_id = var_device_id, account_id = var_account_iddata_file = "result.txt")
#' result <- api_instance$DeletePurchaseItem(var_purchase_item_id, device_id = var_device_id, account_id = var_account_id)
#' dput(result)
#'
#'
#' ####################  GetPurchaseItem  ####################
#'
#' library(openapi)
#' var_purchase_item_id <- 56 # integer | The purchase item id
#' var_device_id <- "device_id_example" # character | The device id (deviceId or accountId required) (Optional)
#' var_account_id <- 56 # integer | The account id of the user (deviceId or accountId required) (Optional)
#'
#' #Get Purchase
#' api_instance <- PurchaseItemApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$GetPurchaseItem(var_purchase_item_id, device_id = var_device_id, account_id = var_account_iddata_file = "result.txt")
#' result <- api_instance$GetPurchaseItem(var_purchase_item_id, device_id = var_device_id, account_id = var_account_id)
#' dput(result)
#'
#'
#' ####################  SearchPurchaseItems  ####################
#'
#' library(openapi)
#' var_device_id <- "device_id_example" # character | The device id (deviceId or accountId required) (Optional)
#' var_account_id <- 56 # integer | The account id of the user (deviceId or accountId required) (Optional)
#' var_app_key <- "app_key_example" # character | The application key to filter results by application (Optional)
#' var_filter_by_billable <- FALSE # character | Determines whether to filter results by the user's billable entity (Optional)
#' var_purchase_type <- "purchase_type_example" # character | A comma separated list of purchase providers to filter by. Possible values include: <ul> <li>SIRQUL - purchases from the Sirqul store using tickets</li> <li>IOS - purchases from the iTunes store for iPhone, iPod, iPod Touch</li> <li>GOOGLE - purchases from the Google Play store</li> <li>AMAZON - purchases from the Amazon Android store</li> <li>MAC - purchases from the iTunes store for OSX</li> <li>WP8 - purchases from the Windows Phone 8 store</li> <li>FREE - purchases that are free (can be used for development/testing purposes)</li> </ul> (Optional)
#' var_service_action <- "service_action_example" # character | A comma separated list of service actions to filter results by. Possible values include: <ul> <li>DAY_PREMIUM - purchases that subscribes a user for a day of membership</li> <li>WEEK_PREMIUM - purchases that subscribes a user for a week of membership</li> <li>MONTH_PREMIUM - purchases that subscribes a user for a month of membership</li> <li>ADD_TICKET - purchases that allow users to add more tickets</li> <li>ADD_GIFT - purchases that allow users to recieve gifts</li> </ul> (Optional)
#' var_keyword <- "keyword_example" # character | The keyword used to search (Optional)
#' var_sort_field <- "NAME" # character | The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, DETAILS, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, ESTIMATED_VALUE, VOUCHER_PRICE, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY (Optional)
#' var_descending <- FALSE # character | The order to return the search results (Optional)
#' var_start <- 0 # integer | The record to begin the return set on (Optional)
#' var_limit <- 20 # integer | The number of records to return (Optional)
#' var_active_only <- FALSE # character | Return only active results (Optional)
#'
#' #Search Purchases
#' api_instance <- PurchaseItemApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$SearchPurchaseItems(device_id = var_device_id, account_id = var_account_id, app_key = var_app_key, filter_by_billable = var_filter_by_billable, purchase_type = var_purchase_type, service_action = var_service_action, keyword = var_keyword, sort_field = var_sort_field, descending = var_descending, start = var_start, limit = var_limit, active_only = var_active_onlydata_file = "result.txt")
#' result <- api_instance$SearchPurchaseItems(device_id = var_device_id, account_id = var_account_id, app_key = var_app_key, filter_by_billable = var_filter_by_billable, purchase_type = var_purchase_type, service_action = var_service_action, keyword = var_keyword, sort_field = var_sort_field, descending = var_descending, start = var_start, limit = var_limit, active_only = var_active_only)
#' dput(result)
#'
#'
#' ####################  UpdatePurchaseItem  ####################
#'
#' library(openapi)
#' var_purchase_item_id <- 56 # integer | The purchase item id
#' var_device_id <- "device_id_example" # character | The device id (deviceId or accountId required) (Optional)
#' var_account_id <- 56 # integer | The account id of the user (deviceId or accountId required) (Optional)
#' var_name <- "name_example" # character | The name of the purchase item (Optional)
#' var_description <- "description_example" # character | The description of the purchase item (Optional)
#' var_tickets <- 56 # integer | How much the purchase item is worth in tickets (Optional)
#' var_price <- 3.4 # numeric | How much the purchase item will cost in real money (Optional)
#' var_purchase_type <- "purchase_type_example" # character | The purchase provider <ul> <li>SIRQUL - the Sirqul store to make purchases using tickets</li> <li>IOS - the iTunes store for iPhone, iPod, iPod Touch</li> <li>GOOGLE - the Google Play store</li> <li>AMAZON - the Amazon Android store</li> <li>MAC - the iTunes store for OSX</li> <li>WP8 - the Windows Phone 8 store</li> <li>FREE - used for purchase items that are free (can be used for development/testing purposes)</li> </ul> (Optional)
#' var_purchase_code <- "purchase_code_example" # character | The unique identifier used by purchase providers to identify in-app-purchases (Optional)
#' var_secret_key <- "secret_key_example" # character | A secret key from purchase providers that would be used for validation (Optional)
#' var_purchase_limit <- 56 # integer | How many times a user acquire the same purchase item (Optional)
#' var_service_action <- "service_action_example" # character | Determines whether the purchase item will enable certain features <ul> <li>DAY_PREMIUM - subscribes a user for a day of membership</li> <li>WEEK_PREMIUM - subscribes a user for a week of membership</li> <li>MONTH_PREMIUM - subscribes a user for a month of membership</li> <li>ADD_TICKET - allows a user to add more tickets to their account</li> <li>ADD_GIFT - allows a user to send/recieve the purchase item as a gift</li> </ul> (Optional)
#' var_cover_asset_id <- 56 # integer | The cover image of the purchase item (Optional)
#' var_promo_asset_id <- 56 # integer | An application specific asset that can be used to store/provide additional data (Optional)
#' var_giftable <- "giftable_example" # character | Determines whether the purchase item can be gifted to other users (Optional)
#' var_assetable <- "assetable_example" # character | Determines whether users can attach their own media/asset to the purchase item (Optional)
#' var_active <- "active_example" # character | Sets whether the purchase item is active or inactive (hidden from consumers) (Optional)
#' var_allocate_tickets <- FALSE # character | Flag to indicate owner should receive tickets for completed missions (Optional)
#' var_ticket_type <- "ticket_type_example" # character | The type of ticket to reward, null means default type (Optional)
#' var_points <- 56 # integer | The number of points to award for completing a mission (Optional)
#' var_offer_location_id <- 56 # integer | The offer location that will get added to the user's wallet after purchase. (Optional)
#'
#' #Update Purchase
#' api_instance <- PurchaseItemApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$UpdatePurchaseItem(var_purchase_item_id, device_id = var_device_id, account_id = var_account_id, name = var_name, description = var_description, tickets = var_tickets, price = var_price, purchase_type = var_purchase_type, purchase_code = var_purchase_code, secret_key = var_secret_key, purchase_limit = var_purchase_limit, service_action = var_service_action, cover_asset_id = var_cover_asset_id, promo_asset_id = var_promo_asset_id, giftable = var_giftable, assetable = var_assetable, active = var_active, allocate_tickets = var_allocate_tickets, ticket_type = var_ticket_type, points = var_points, offer_location_id = var_offer_location_iddata_file = "result.txt")
#' result <- api_instance$UpdatePurchaseItem(var_purchase_item_id, device_id = var_device_id, account_id = var_account_id, name = var_name, description = var_description, tickets = var_tickets, price = var_price, purchase_type = var_purchase_type, purchase_code = var_purchase_code, secret_key = var_secret_key, purchase_limit = var_purchase_limit, service_action = var_service_action, cover_asset_id = var_cover_asset_id, promo_asset_id = var_promo_asset_id, giftable = var_giftable, assetable = var_assetable, active = var_active, allocate_tickets = var_allocate_tickets, ticket_type = var_ticket_type, points = var_points, offer_location_id = var_offer_location_id)
#' dput(result)
#'
#'
#' }
#' @importFrom R6 R6Class
#' @importFrom base64enc base64encode
#' @export
PurchaseItemApi <- R6::R6Class(
  "PurchaseItemApi",
  public = list(
    api_client = NULL,

    #' @description
    #' Initialize a new PurchaseItemApi.
    #'
    #' @param api_client An instance of API client.
    initialize = function(api_client) {
      if (!missing(api_client)) {
        self$api_client <- api_client
      } else {
        self$api_client <- ApiClient$new()
      }
    },

    #' @description
    #' Create Purchase
    #'
    #' @param app_key The application key that the purchase can be used in
    #' @param name The name of the purchase item
    #' @param purchase_type The purchase provider <ul> <li>SIRQUL - the Sirqul store to make purchases using tickets</li> <li>IOS - the iTunes store for iPhone, iPod, iPod Touch</li> <li>GOOGLE - the Google Play store</li> <li>AMAZON - the Amazon Android store</li> <li>MAC - the iTunes store for OSX</li> <li>WP8 - the Windows Phone 8 store</li> <li>FREE - used for purchase items that are free (can be used for development/testing purposes)</li> </ul>
    #' @param device_id (optional) The device id (deviceId or accountId required)
    #' @param account_id (optional) The account id of the user (deviceId or accountId required)
    #' @param description (optional) The description of the purchase item
    #' @param tickets (optional) How much the purchase item is worth in tickets
    #' @param price (optional) How much the purchase item will cost in real money
    #' @param purchase_code (optional) The unique identifier used by purchase providers to identify in-app-purchases
    #' @param secret_key (optional) A secret key from purchase providers that would be used for validation
    #' @param purchase_limit (optional) How many times a user acquire the same purchase item (default value: 0)
    #' @param service_action (optional) Determines whether the purchase item will enable certain features <ul> <li>DAY_PREMIUM - subscribes a user for a day of membership</li> <li>WEEK_PREMIUM - subscribes a user for a week of membership</li> <li>MONTH_PREMIUM - subscribes a user for a month of membership</li> <li>ADD_TICKET - allows a user to add more tickets to their account</li> <li>ADD_GIFT - allows a user to send/recieve the purchase item as a gift</li> </ul>
    #' @param cover_asset_id (optional) The cover image of the purchase item
    #' @param promo_asset_id (optional) An application specific asset that can be used to store/provide additional data
    #' @param giftable (optional) Determines whether the purchase item can be gifted to other users
    #' @param assetable (optional) Determines whether users can attach their own media/asset to the purchase item
    #' @param allocate_tickets (optional) Flag to indicate owner should receive tickets for completed missions (default value: FALSE)
    #' @param ticket_type (optional) The type of ticket to reward, null means default type
    #' @param points (optional) The number of points to award for completing a mission
    #' @param offer_location_id (optional) The offer location that will get added to the user's wallet after purchase.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return PurchaseItemFullResponse
    CreatePurchaseItem = function(app_key, name, purchase_type, device_id = NULL, account_id = NULL, description = NULL, tickets = NULL, price = NULL, purchase_code = NULL, secret_key = NULL, purchase_limit = 0, service_action = NULL, cover_asset_id = NULL, promo_asset_id = NULL, giftable = NULL, assetable = NULL, allocate_tickets = FALSE, ticket_type = NULL, points = NULL, offer_location_id = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$CreatePurchaseItemWithHttpInfo(app_key, name, purchase_type, device_id, account_id, description, tickets, price, purchase_code, secret_key, purchase_limit, service_action, cover_asset_id, promo_asset_id, giftable, assetable, allocate_tickets, ticket_type, points, offer_location_id, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Create Purchase
    #'
    #' @param app_key The application key that the purchase can be used in
    #' @param name The name of the purchase item
    #' @param purchase_type The purchase provider <ul> <li>SIRQUL - the Sirqul store to make purchases using tickets</li> <li>IOS - the iTunes store for iPhone, iPod, iPod Touch</li> <li>GOOGLE - the Google Play store</li> <li>AMAZON - the Amazon Android store</li> <li>MAC - the iTunes store for OSX</li> <li>WP8 - the Windows Phone 8 store</li> <li>FREE - used for purchase items that are free (can be used for development/testing purposes)</li> </ul>
    #' @param device_id (optional) The device id (deviceId or accountId required)
    #' @param account_id (optional) The account id of the user (deviceId or accountId required)
    #' @param description (optional) The description of the purchase item
    #' @param tickets (optional) How much the purchase item is worth in tickets
    #' @param price (optional) How much the purchase item will cost in real money
    #' @param purchase_code (optional) The unique identifier used by purchase providers to identify in-app-purchases
    #' @param secret_key (optional) A secret key from purchase providers that would be used for validation
    #' @param purchase_limit (optional) How many times a user acquire the same purchase item (default value: 0)
    #' @param service_action (optional) Determines whether the purchase item will enable certain features <ul> <li>DAY_PREMIUM - subscribes a user for a day of membership</li> <li>WEEK_PREMIUM - subscribes a user for a week of membership</li> <li>MONTH_PREMIUM - subscribes a user for a month of membership</li> <li>ADD_TICKET - allows a user to add more tickets to their account</li> <li>ADD_GIFT - allows a user to send/recieve the purchase item as a gift</li> </ul>
    #' @param cover_asset_id (optional) The cover image of the purchase item
    #' @param promo_asset_id (optional) An application specific asset that can be used to store/provide additional data
    #' @param giftable (optional) Determines whether the purchase item can be gifted to other users
    #' @param assetable (optional) Determines whether users can attach their own media/asset to the purchase item
    #' @param allocate_tickets (optional) Flag to indicate owner should receive tickets for completed missions (default value: FALSE)
    #' @param ticket_type (optional) The type of ticket to reward, null means default type
    #' @param points (optional) The number of points to award for completing a mission
    #' @param offer_location_id (optional) The offer location that will get added to the user's wallet after purchase.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (PurchaseItemFullResponse) with additional information such as HTTP status code, headers
    CreatePurchaseItemWithHttpInfo = function(app_key, name, purchase_type, device_id = NULL, account_id = NULL, description = NULL, tickets = NULL, price = NULL, purchase_code = NULL, secret_key = NULL, purchase_limit = 0, service_action = NULL, cover_asset_id = NULL, promo_asset_id = NULL, giftable = NULL, assetable = NULL, allocate_tickets = FALSE, ticket_type = NULL, points = NULL, offer_location_id = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`app_key`)) {
        stop("Missing required parameter `app_key`.")
      }

      if (missing(`name`)) {
        stop("Missing required parameter `name`.")
      }

      if (missing(`purchase_type`)) {
        stop("Missing required parameter `purchase_type`.")
      }

      if (!missing(`app_key`) && is.null(`app_key`)) {
        stop("Invalid value for `app_key` when calling PurchaseItemApi$CreatePurchaseItem, `app_key` is not nullable")
      }

      if (!missing(`name`) && is.null(`name`)) {
        stop("Invalid value for `name` when calling PurchaseItemApi$CreatePurchaseItem, `name` is not nullable")
      }

      if (!missing(`purchase_type`) && is.null(`purchase_type`)) {
        stop("Invalid value for `purchase_type` when calling PurchaseItemApi$CreatePurchaseItem, `purchase_type` is not nullable")
      }

      if (!missing(`device_id`) && is.null(`device_id`)) {
        stop("Invalid value for `device_id` when calling PurchaseItemApi$CreatePurchaseItem, `device_id` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling PurchaseItemApi$CreatePurchaseItem, `account_id` is not nullable")
      }

      if (!missing(`description`) && is.null(`description`)) {
        stop("Invalid value for `description` when calling PurchaseItemApi$CreatePurchaseItem, `description` is not nullable")
      }

      if (!missing(`tickets`) && is.null(`tickets`)) {
        stop("Invalid value for `tickets` when calling PurchaseItemApi$CreatePurchaseItem, `tickets` is not nullable")
      }

      if (!missing(`price`) && is.null(`price`)) {
        stop("Invalid value for `price` when calling PurchaseItemApi$CreatePurchaseItem, `price` is not nullable")
      }

      if (!missing(`purchase_code`) && is.null(`purchase_code`)) {
        stop("Invalid value for `purchase_code` when calling PurchaseItemApi$CreatePurchaseItem, `purchase_code` is not nullable")
      }

      if (!missing(`secret_key`) && is.null(`secret_key`)) {
        stop("Invalid value for `secret_key` when calling PurchaseItemApi$CreatePurchaseItem, `secret_key` is not nullable")
      }

      if (!missing(`purchase_limit`) && is.null(`purchase_limit`)) {
        stop("Invalid value for `purchase_limit` when calling PurchaseItemApi$CreatePurchaseItem, `purchase_limit` is not nullable")
      }

      if (!missing(`service_action`) && is.null(`service_action`)) {
        stop("Invalid value for `service_action` when calling PurchaseItemApi$CreatePurchaseItem, `service_action` is not nullable")
      }

      if (!missing(`cover_asset_id`) && is.null(`cover_asset_id`)) {
        stop("Invalid value for `cover_asset_id` when calling PurchaseItemApi$CreatePurchaseItem, `cover_asset_id` is not nullable")
      }

      if (!missing(`promo_asset_id`) && is.null(`promo_asset_id`)) {
        stop("Invalid value for `promo_asset_id` when calling PurchaseItemApi$CreatePurchaseItem, `promo_asset_id` is not nullable")
      }

      if (!missing(`giftable`) && is.null(`giftable`)) {
        stop("Invalid value for `giftable` when calling PurchaseItemApi$CreatePurchaseItem, `giftable` is not nullable")
      }

      if (!missing(`assetable`) && is.null(`assetable`)) {
        stop("Invalid value for `assetable` when calling PurchaseItemApi$CreatePurchaseItem, `assetable` is not nullable")
      }

      if (!missing(`allocate_tickets`) && is.null(`allocate_tickets`)) {
        stop("Invalid value for `allocate_tickets` when calling PurchaseItemApi$CreatePurchaseItem, `allocate_tickets` is not nullable")
      }

      if (!missing(`ticket_type`) && is.null(`ticket_type`)) {
        stop("Invalid value for `ticket_type` when calling PurchaseItemApi$CreatePurchaseItem, `ticket_type` is not nullable")
      }

      if (!missing(`points`) && is.null(`points`)) {
        stop("Invalid value for `points` when calling PurchaseItemApi$CreatePurchaseItem, `points` is not nullable")
      }

      if (!missing(`offer_location_id`) && is.null(`offer_location_id`)) {
        stop("Invalid value for `offer_location_id` when calling PurchaseItemApi$CreatePurchaseItem, `offer_location_id` is not nullable")
      }

      query_params[["deviceId"]] <- `device_id`

      query_params[["accountId"]] <- `account_id`

      query_params[["appKey"]] <- `app_key`

      query_params[["name"]] <- `name`

      query_params[["description"]] <- `description`

      query_params[["tickets"]] <- `tickets`

      query_params[["price"]] <- `price`

      if (!is.null(`purchase_type`) && !(`purchase_type` %in% c("SIRQUL", "IOS", "GOOGLE", "AMAZON", "MAC", "WP8", "FREE"))) {
        stop("Invalid value for purchase_type when calling PurchaseItemApi$CreatePurchaseItem. Must be [SIRQUL, IOS, GOOGLE, AMAZON, MAC, WP8, FREE].")
      }
      query_params[["purchaseType"]] <- `purchase_type`

      query_params[["purchaseCode"]] <- `purchase_code`

      query_params[["secretKey"]] <- `secret_key`

      query_params[["purchaseLimit"]] <- `purchase_limit`

      if (!is.null(`service_action`) && !(`service_action` %in% c("DAY_PREMIUM", "WEEK_PREMIUM", "MONTH_PREMIUM", "YEAR_PREMIUM", "LIFETIME_PREMIUM", "ADD_TICKET", "ADD_GIFT", "ADD_POINTS"))) {
        stop("Invalid value for service_action when calling PurchaseItemApi$CreatePurchaseItem. Must be [DAY_PREMIUM, WEEK_PREMIUM, MONTH_PREMIUM, YEAR_PREMIUM, LIFETIME_PREMIUM, ADD_TICKET, ADD_GIFT, ADD_POINTS].")
      }
      query_params[["serviceAction"]] <- `service_action`

      query_params[["coverAssetId"]] <- `cover_asset_id`

      query_params[["promoAssetId"]] <- `promo_asset_id`

      query_params[["giftable"]] <- `giftable`

      query_params[["assetable"]] <- `assetable`

      query_params[["allocateTickets"]] <- `allocate_tickets`

      query_params[["ticketType"]] <- `ticket_type`

      query_params[["points"]] <- `points`

      query_params[["offerLocationId"]] <- `offer_location_id`

      local_var_url_path <- "/purchase/create"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "PurchaseItemFullResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Delete Purchase
    #'
    #' @param purchase_item_id The purchase item id
    #' @param device_id (optional) The device id (deviceId or accountId required)
    #' @param account_id (optional) The account id of the user (deviceId or accountId required)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return SirqulResponse
    DeletePurchaseItem = function(purchase_item_id, device_id = NULL, account_id = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$DeletePurchaseItemWithHttpInfo(purchase_item_id, device_id, account_id, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Delete Purchase
    #'
    #' @param purchase_item_id The purchase item id
    #' @param device_id (optional) The device id (deviceId or accountId required)
    #' @param account_id (optional) The account id of the user (deviceId or accountId required)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (SirqulResponse) with additional information such as HTTP status code, headers
    DeletePurchaseItemWithHttpInfo = function(purchase_item_id, device_id = NULL, account_id = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`purchase_item_id`)) {
        stop("Missing required parameter `purchase_item_id`.")
      }

      if (!missing(`purchase_item_id`) && is.null(`purchase_item_id`)) {
        stop("Invalid value for `purchase_item_id` when calling PurchaseItemApi$DeletePurchaseItem, `purchase_item_id` is not nullable")
      }

      if (!missing(`device_id`) && is.null(`device_id`)) {
        stop("Invalid value for `device_id` when calling PurchaseItemApi$DeletePurchaseItem, `device_id` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling PurchaseItemApi$DeletePurchaseItem, `account_id` is not nullable")
      }

      query_params[["deviceId"]] <- `device_id`

      query_params[["accountId"]] <- `account_id`

      query_params[["purchaseItemId"]] <- `purchase_item_id`

      local_var_url_path <- "/purchase/delete"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "SirqulResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Get Purchase
    #'
    #' @param purchase_item_id The purchase item id
    #' @param device_id (optional) The device id (deviceId or accountId required)
    #' @param account_id (optional) The account id of the user (deviceId or accountId required)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return PurchaseItemFullResponse
    GetPurchaseItem = function(purchase_item_id, device_id = NULL, account_id = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$GetPurchaseItemWithHttpInfo(purchase_item_id, device_id, account_id, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Get Purchase
    #'
    #' @param purchase_item_id The purchase item id
    #' @param device_id (optional) The device id (deviceId or accountId required)
    #' @param account_id (optional) The account id of the user (deviceId or accountId required)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (PurchaseItemFullResponse) with additional information such as HTTP status code, headers
    GetPurchaseItemWithHttpInfo = function(purchase_item_id, device_id = NULL, account_id = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`purchase_item_id`)) {
        stop("Missing required parameter `purchase_item_id`.")
      }

      if (!missing(`purchase_item_id`) && is.null(`purchase_item_id`)) {
        stop("Invalid value for `purchase_item_id` when calling PurchaseItemApi$GetPurchaseItem, `purchase_item_id` is not nullable")
      }

      if (!missing(`device_id`) && is.null(`device_id`)) {
        stop("Invalid value for `device_id` when calling PurchaseItemApi$GetPurchaseItem, `device_id` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling PurchaseItemApi$GetPurchaseItem, `account_id` is not nullable")
      }

      query_params[["deviceId"]] <- `device_id`

      query_params[["accountId"]] <- `account_id`

      query_params[["purchaseItemId"]] <- `purchase_item_id`

      local_var_url_path <- "/purchase/get"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "PurchaseItemFullResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Search Purchases
    #'
    #' @param device_id (optional) The device id (deviceId or accountId required)
    #' @param account_id (optional) The account id of the user (deviceId or accountId required)
    #' @param app_key (optional) The application key to filter results by application
    #' @param filter_by_billable (optional) Determines whether to filter results by the user's billable entity (default value: FALSE)
    #' @param purchase_type (optional) A comma separated list of purchase providers to filter by. Possible values include: <ul> <li>SIRQUL - purchases from the Sirqul store using tickets</li> <li>IOS - purchases from the iTunes store for iPhone, iPod, iPod Touch</li> <li>GOOGLE - purchases from the Google Play store</li> <li>AMAZON - purchases from the Amazon Android store</li> <li>MAC - purchases from the iTunes store for OSX</li> <li>WP8 - purchases from the Windows Phone 8 store</li> <li>FREE - purchases that are free (can be used for development/testing purposes)</li> </ul>
    #' @param service_action (optional) A comma separated list of service actions to filter results by. Possible values include: <ul> <li>DAY_PREMIUM - purchases that subscribes a user for a day of membership</li> <li>WEEK_PREMIUM - purchases that subscribes a user for a week of membership</li> <li>MONTH_PREMIUM - purchases that subscribes a user for a month of membership</li> <li>ADD_TICKET - purchases that allow users to add more tickets</li> <li>ADD_GIFT - purchases that allow users to recieve gifts</li> </ul>
    #' @param keyword (optional) The keyword used to search
    #' @param sort_field (optional) The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, DETAILS, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, ESTIMATED_VALUE, VOUCHER_PRICE, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY (default value: "NAME")
    #' @param descending (optional) The order to return the search results (default value: FALSE)
    #' @param start (optional) The record to begin the return set on (default value: 0)
    #' @param limit (optional) The number of records to return (default value: 20)
    #' @param active_only (optional) Return only active results (default value: FALSE)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return array[PurchaseItemResponse]
    SearchPurchaseItems = function(device_id = NULL, account_id = NULL, app_key = NULL, filter_by_billable = FALSE, purchase_type = NULL, service_action = NULL, keyword = NULL, sort_field = "NAME", descending = FALSE, start = 0, limit = 20, active_only = FALSE, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$SearchPurchaseItemsWithHttpInfo(device_id, account_id, app_key, filter_by_billable, purchase_type, service_action, keyword, sort_field, descending, start, limit, active_only, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Search Purchases
    #'
    #' @param device_id (optional) The device id (deviceId or accountId required)
    #' @param account_id (optional) The account id of the user (deviceId or accountId required)
    #' @param app_key (optional) The application key to filter results by application
    #' @param filter_by_billable (optional) Determines whether to filter results by the user's billable entity (default value: FALSE)
    #' @param purchase_type (optional) A comma separated list of purchase providers to filter by. Possible values include: <ul> <li>SIRQUL - purchases from the Sirqul store using tickets</li> <li>IOS - purchases from the iTunes store for iPhone, iPod, iPod Touch</li> <li>GOOGLE - purchases from the Google Play store</li> <li>AMAZON - purchases from the Amazon Android store</li> <li>MAC - purchases from the iTunes store for OSX</li> <li>WP8 - purchases from the Windows Phone 8 store</li> <li>FREE - purchases that are free (can be used for development/testing purposes)</li> </ul>
    #' @param service_action (optional) A comma separated list of service actions to filter results by. Possible values include: <ul> <li>DAY_PREMIUM - purchases that subscribes a user for a day of membership</li> <li>WEEK_PREMIUM - purchases that subscribes a user for a week of membership</li> <li>MONTH_PREMIUM - purchases that subscribes a user for a month of membership</li> <li>ADD_TICKET - purchases that allow users to add more tickets</li> <li>ADD_GIFT - purchases that allow users to recieve gifts</li> </ul>
    #' @param keyword (optional) The keyword used to search
    #' @param sort_field (optional) The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, DETAILS, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, ESTIMATED_VALUE, VOUCHER_PRICE, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY (default value: "NAME")
    #' @param descending (optional) The order to return the search results (default value: FALSE)
    #' @param start (optional) The record to begin the return set on (default value: 0)
    #' @param limit (optional) The number of records to return (default value: 20)
    #' @param active_only (optional) Return only active results (default value: FALSE)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (array[PurchaseItemResponse]) with additional information such as HTTP status code, headers
    SearchPurchaseItemsWithHttpInfo = function(device_id = NULL, account_id = NULL, app_key = NULL, filter_by_billable = FALSE, purchase_type = NULL, service_action = NULL, keyword = NULL, sort_field = "NAME", descending = FALSE, start = 0, limit = 20, active_only = FALSE, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (!missing(`device_id`) && is.null(`device_id`)) {
        stop("Invalid value for `device_id` when calling PurchaseItemApi$SearchPurchaseItems, `device_id` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling PurchaseItemApi$SearchPurchaseItems, `account_id` is not nullable")
      }

      if (!missing(`app_key`) && is.null(`app_key`)) {
        stop("Invalid value for `app_key` when calling PurchaseItemApi$SearchPurchaseItems, `app_key` is not nullable")
      }

      if (!missing(`filter_by_billable`) && is.null(`filter_by_billable`)) {
        stop("Invalid value for `filter_by_billable` when calling PurchaseItemApi$SearchPurchaseItems, `filter_by_billable` is not nullable")
      }

      if (!missing(`purchase_type`) && is.null(`purchase_type`)) {
        stop("Invalid value for `purchase_type` when calling PurchaseItemApi$SearchPurchaseItems, `purchase_type` is not nullable")
      }

      if (!missing(`service_action`) && is.null(`service_action`)) {
        stop("Invalid value for `service_action` when calling PurchaseItemApi$SearchPurchaseItems, `service_action` is not nullable")
      }

      if (!missing(`keyword`) && is.null(`keyword`)) {
        stop("Invalid value for `keyword` when calling PurchaseItemApi$SearchPurchaseItems, `keyword` is not nullable")
      }

      if (!missing(`sort_field`) && is.null(`sort_field`)) {
        stop("Invalid value for `sort_field` when calling PurchaseItemApi$SearchPurchaseItems, `sort_field` is not nullable")
      }

      if (!missing(`descending`) && is.null(`descending`)) {
        stop("Invalid value for `descending` when calling PurchaseItemApi$SearchPurchaseItems, `descending` is not nullable")
      }

      if (!missing(`start`) && is.null(`start`)) {
        stop("Invalid value for `start` when calling PurchaseItemApi$SearchPurchaseItems, `start` is not nullable")
      }

      if (!missing(`limit`) && is.null(`limit`)) {
        stop("Invalid value for `limit` when calling PurchaseItemApi$SearchPurchaseItems, `limit` is not nullable")
      }

      if (!missing(`active_only`) && is.null(`active_only`)) {
        stop("Invalid value for `active_only` when calling PurchaseItemApi$SearchPurchaseItems, `active_only` is not nullable")
      }

      query_params[["deviceId"]] <- `device_id`

      query_params[["accountId"]] <- `account_id`

      query_params[["appKey"]] <- `app_key`

      query_params[["filterByBillable"]] <- `filter_by_billable`

      query_params[["purchaseType"]] <- `purchase_type`

      query_params[["serviceAction"]] <- `service_action`

      query_params[["keyword"]] <- `keyword`

      if (!is.null(`sort_field`) && !(`sort_field` %in% c("ID", "CREATED", "UPDATED", "DELETED", "SEARCH_TAGS", "ACTIVE", "NAME", "DESCRIPTION", "TICKETS", "PRICE", "PURCHASE_TYPE", "PURCHASE_CODE", "PURCHASE_LIMIT", "SERIVCE_ACTION", "GIFTABLE", "ASSETABLE", "APPLICATION_ID", "APPLICATION_NAME"))) {
        stop("Invalid value for sort_field when calling PurchaseItemApi$SearchPurchaseItems. Must be [ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, NAME, DESCRIPTION, TICKETS, PRICE, PURCHASE_TYPE, PURCHASE_CODE, PURCHASE_LIMIT, SERIVCE_ACTION, GIFTABLE, ASSETABLE, APPLICATION_ID, APPLICATION_NAME].")
      }
      query_params[["sortField"]] <- `sort_field`

      query_params[["descending"]] <- `descending`

      query_params[["start"]] <- `start`

      query_params[["limit"]] <- `limit`

      query_params[["activeOnly"]] <- `active_only`

      local_var_url_path <- "/purchase/search"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "array[PurchaseItemResponse]"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Update Purchase
    #'
    #' @param purchase_item_id The purchase item id
    #' @param device_id (optional) The device id (deviceId or accountId required)
    #' @param account_id (optional) The account id of the user (deviceId or accountId required)
    #' @param name (optional) The name of the purchase item
    #' @param description (optional) The description of the purchase item
    #' @param tickets (optional) How much the purchase item is worth in tickets
    #' @param price (optional) How much the purchase item will cost in real money
    #' @param purchase_type (optional) The purchase provider <ul> <li>SIRQUL - the Sirqul store to make purchases using tickets</li> <li>IOS - the iTunes store for iPhone, iPod, iPod Touch</li> <li>GOOGLE - the Google Play store</li> <li>AMAZON - the Amazon Android store</li> <li>MAC - the iTunes store for OSX</li> <li>WP8 - the Windows Phone 8 store</li> <li>FREE - used for purchase items that are free (can be used for development/testing purposes)</li> </ul>
    #' @param purchase_code (optional) The unique identifier used by purchase providers to identify in-app-purchases
    #' @param secret_key (optional) A secret key from purchase providers that would be used for validation
    #' @param purchase_limit (optional) How many times a user acquire the same purchase item
    #' @param service_action (optional) Determines whether the purchase item will enable certain features <ul> <li>DAY_PREMIUM - subscribes a user for a day of membership</li> <li>WEEK_PREMIUM - subscribes a user for a week of membership</li> <li>MONTH_PREMIUM - subscribes a user for a month of membership</li> <li>ADD_TICKET - allows a user to add more tickets to their account</li> <li>ADD_GIFT - allows a user to send/recieve the purchase item as a gift</li> </ul>
    #' @param cover_asset_id (optional) The cover image of the purchase item
    #' @param promo_asset_id (optional) An application specific asset that can be used to store/provide additional data
    #' @param giftable (optional) Determines whether the purchase item can be gifted to other users
    #' @param assetable (optional) Determines whether users can attach their own media/asset to the purchase item
    #' @param active (optional) Sets whether the purchase item is active or inactive (hidden from consumers)
    #' @param allocate_tickets (optional) Flag to indicate owner should receive tickets for completed missions (default value: FALSE)
    #' @param ticket_type (optional) The type of ticket to reward, null means default type
    #' @param points (optional) The number of points to award for completing a mission
    #' @param offer_location_id (optional) The offer location that will get added to the user's wallet after purchase.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return PurchaseItemFullResponse
    UpdatePurchaseItem = function(purchase_item_id, device_id = NULL, account_id = NULL, name = NULL, description = NULL, tickets = NULL, price = NULL, purchase_type = NULL, purchase_code = NULL, secret_key = NULL, purchase_limit = NULL, service_action = NULL, cover_asset_id = NULL, promo_asset_id = NULL, giftable = NULL, assetable = NULL, active = NULL, allocate_tickets = FALSE, ticket_type = NULL, points = NULL, offer_location_id = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$UpdatePurchaseItemWithHttpInfo(purchase_item_id, device_id, account_id, name, description, tickets, price, purchase_type, purchase_code, secret_key, purchase_limit, service_action, cover_asset_id, promo_asset_id, giftable, assetable, active, allocate_tickets, ticket_type, points, offer_location_id, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Update Purchase
    #'
    #' @param purchase_item_id The purchase item id
    #' @param device_id (optional) The device id (deviceId or accountId required)
    #' @param account_id (optional) The account id of the user (deviceId or accountId required)
    #' @param name (optional) The name of the purchase item
    #' @param description (optional) The description of the purchase item
    #' @param tickets (optional) How much the purchase item is worth in tickets
    #' @param price (optional) How much the purchase item will cost in real money
    #' @param purchase_type (optional) The purchase provider <ul> <li>SIRQUL - the Sirqul store to make purchases using tickets</li> <li>IOS - the iTunes store for iPhone, iPod, iPod Touch</li> <li>GOOGLE - the Google Play store</li> <li>AMAZON - the Amazon Android store</li> <li>MAC - the iTunes store for OSX</li> <li>WP8 - the Windows Phone 8 store</li> <li>FREE - used for purchase items that are free (can be used for development/testing purposes)</li> </ul>
    #' @param purchase_code (optional) The unique identifier used by purchase providers to identify in-app-purchases
    #' @param secret_key (optional) A secret key from purchase providers that would be used for validation
    #' @param purchase_limit (optional) How many times a user acquire the same purchase item
    #' @param service_action (optional) Determines whether the purchase item will enable certain features <ul> <li>DAY_PREMIUM - subscribes a user for a day of membership</li> <li>WEEK_PREMIUM - subscribes a user for a week of membership</li> <li>MONTH_PREMIUM - subscribes a user for a month of membership</li> <li>ADD_TICKET - allows a user to add more tickets to their account</li> <li>ADD_GIFT - allows a user to send/recieve the purchase item as a gift</li> </ul>
    #' @param cover_asset_id (optional) The cover image of the purchase item
    #' @param promo_asset_id (optional) An application specific asset that can be used to store/provide additional data
    #' @param giftable (optional) Determines whether the purchase item can be gifted to other users
    #' @param assetable (optional) Determines whether users can attach their own media/asset to the purchase item
    #' @param active (optional) Sets whether the purchase item is active or inactive (hidden from consumers)
    #' @param allocate_tickets (optional) Flag to indicate owner should receive tickets for completed missions (default value: FALSE)
    #' @param ticket_type (optional) The type of ticket to reward, null means default type
    #' @param points (optional) The number of points to award for completing a mission
    #' @param offer_location_id (optional) The offer location that will get added to the user's wallet after purchase.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (PurchaseItemFullResponse) with additional information such as HTTP status code, headers
    UpdatePurchaseItemWithHttpInfo = function(purchase_item_id, device_id = NULL, account_id = NULL, name = NULL, description = NULL, tickets = NULL, price = NULL, purchase_type = NULL, purchase_code = NULL, secret_key = NULL, purchase_limit = NULL, service_action = NULL, cover_asset_id = NULL, promo_asset_id = NULL, giftable = NULL, assetable = NULL, active = NULL, allocate_tickets = FALSE, ticket_type = NULL, points = NULL, offer_location_id = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`purchase_item_id`)) {
        stop("Missing required parameter `purchase_item_id`.")
      }

      if (!missing(`purchase_item_id`) && is.null(`purchase_item_id`)) {
        stop("Invalid value for `purchase_item_id` when calling PurchaseItemApi$UpdatePurchaseItem, `purchase_item_id` is not nullable")
      }

      if (!missing(`device_id`) && is.null(`device_id`)) {
        stop("Invalid value for `device_id` when calling PurchaseItemApi$UpdatePurchaseItem, `device_id` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling PurchaseItemApi$UpdatePurchaseItem, `account_id` is not nullable")
      }

      if (!missing(`name`) && is.null(`name`)) {
        stop("Invalid value for `name` when calling PurchaseItemApi$UpdatePurchaseItem, `name` is not nullable")
      }

      if (!missing(`description`) && is.null(`description`)) {
        stop("Invalid value for `description` when calling PurchaseItemApi$UpdatePurchaseItem, `description` is not nullable")
      }

      if (!missing(`tickets`) && is.null(`tickets`)) {
        stop("Invalid value for `tickets` when calling PurchaseItemApi$UpdatePurchaseItem, `tickets` is not nullable")
      }

      if (!missing(`price`) && is.null(`price`)) {
        stop("Invalid value for `price` when calling PurchaseItemApi$UpdatePurchaseItem, `price` is not nullable")
      }

      if (!missing(`purchase_type`) && is.null(`purchase_type`)) {
        stop("Invalid value for `purchase_type` when calling PurchaseItemApi$UpdatePurchaseItem, `purchase_type` is not nullable")
      }

      if (!missing(`purchase_code`) && is.null(`purchase_code`)) {
        stop("Invalid value for `purchase_code` when calling PurchaseItemApi$UpdatePurchaseItem, `purchase_code` is not nullable")
      }

      if (!missing(`secret_key`) && is.null(`secret_key`)) {
        stop("Invalid value for `secret_key` when calling PurchaseItemApi$UpdatePurchaseItem, `secret_key` is not nullable")
      }

      if (!missing(`purchase_limit`) && is.null(`purchase_limit`)) {
        stop("Invalid value for `purchase_limit` when calling PurchaseItemApi$UpdatePurchaseItem, `purchase_limit` is not nullable")
      }

      if (!missing(`service_action`) && is.null(`service_action`)) {
        stop("Invalid value for `service_action` when calling PurchaseItemApi$UpdatePurchaseItem, `service_action` is not nullable")
      }

      if (!missing(`cover_asset_id`) && is.null(`cover_asset_id`)) {
        stop("Invalid value for `cover_asset_id` when calling PurchaseItemApi$UpdatePurchaseItem, `cover_asset_id` is not nullable")
      }

      if (!missing(`promo_asset_id`) && is.null(`promo_asset_id`)) {
        stop("Invalid value for `promo_asset_id` when calling PurchaseItemApi$UpdatePurchaseItem, `promo_asset_id` is not nullable")
      }

      if (!missing(`giftable`) && is.null(`giftable`)) {
        stop("Invalid value for `giftable` when calling PurchaseItemApi$UpdatePurchaseItem, `giftable` is not nullable")
      }

      if (!missing(`assetable`) && is.null(`assetable`)) {
        stop("Invalid value for `assetable` when calling PurchaseItemApi$UpdatePurchaseItem, `assetable` is not nullable")
      }

      if (!missing(`active`) && is.null(`active`)) {
        stop("Invalid value for `active` when calling PurchaseItemApi$UpdatePurchaseItem, `active` is not nullable")
      }

      if (!missing(`allocate_tickets`) && is.null(`allocate_tickets`)) {
        stop("Invalid value for `allocate_tickets` when calling PurchaseItemApi$UpdatePurchaseItem, `allocate_tickets` is not nullable")
      }

      if (!missing(`ticket_type`) && is.null(`ticket_type`)) {
        stop("Invalid value for `ticket_type` when calling PurchaseItemApi$UpdatePurchaseItem, `ticket_type` is not nullable")
      }

      if (!missing(`points`) && is.null(`points`)) {
        stop("Invalid value for `points` when calling PurchaseItemApi$UpdatePurchaseItem, `points` is not nullable")
      }

      if (!missing(`offer_location_id`) && is.null(`offer_location_id`)) {
        stop("Invalid value for `offer_location_id` when calling PurchaseItemApi$UpdatePurchaseItem, `offer_location_id` is not nullable")
      }

      query_params[["deviceId"]] <- `device_id`

      query_params[["accountId"]] <- `account_id`

      query_params[["purchaseItemId"]] <- `purchase_item_id`

      query_params[["name"]] <- `name`

      query_params[["description"]] <- `description`

      query_params[["tickets"]] <- `tickets`

      query_params[["price"]] <- `price`

      if (!is.null(`purchase_type`) && !(`purchase_type` %in% c("SIRQUL", "IOS", "GOOGLE", "AMAZON", "MAC", "WP8", "FREE"))) {
        stop("Invalid value for purchase_type when calling PurchaseItemApi$UpdatePurchaseItem. Must be [SIRQUL, IOS, GOOGLE, AMAZON, MAC, WP8, FREE].")
      }
      query_params[["purchaseType"]] <- `purchase_type`

      query_params[["purchaseCode"]] <- `purchase_code`

      query_params[["secretKey"]] <- `secret_key`

      query_params[["purchaseLimit"]] <- `purchase_limit`

      if (!is.null(`service_action`) && !(`service_action` %in% c("DAY_PREMIUM", "WEEK_PREMIUM", "MONTH_PREMIUM", "YEAR_PREMIUM", "LIFETIME_PREMIUM", "ADD_TICKET", "ADD_GIFT", "ADD_POINTS"))) {
        stop("Invalid value for service_action when calling PurchaseItemApi$UpdatePurchaseItem. Must be [DAY_PREMIUM, WEEK_PREMIUM, MONTH_PREMIUM, YEAR_PREMIUM, LIFETIME_PREMIUM, ADD_TICKET, ADD_GIFT, ADD_POINTS].")
      }
      query_params[["serviceAction"]] <- `service_action`

      query_params[["coverAssetId"]] <- `cover_asset_id`

      query_params[["promoAssetId"]] <- `promo_asset_id`

      query_params[["giftable"]] <- `giftable`

      query_params[["assetable"]] <- `assetable`

      query_params[["active"]] <- `active`

      query_params[["allocateTickets"]] <- `allocate_tickets`

      query_params[["ticketType"]] <- `ticket_type`

      query_params[["points"]] <- `points`

      query_params[["offerLocationId"]] <- `offer_location_id`

      local_var_url_path <- "/purchase/update"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "PurchaseItemFullResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    }
  )
)
