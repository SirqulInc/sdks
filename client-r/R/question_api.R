#' Sirqul IoT Platform
#'
#' Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
#'
#' The version of the OpenAPI document: 3.16
#' Contact: info@sirqul.com
#' Generated by: https://openapi-generator.tech
#'
#' @docType class
#' @title Question operations
#' @description QuestionApi
#' @format An \code{R6Class} generator object
#' @field api_client Handles the client-server communication.
#'
#' @examples
#' \dontrun{
#' ####################  CreateQuestion  ####################
#'
#' library(openapi)
#' var_account_id <- 56 # integer | the id of the logged in user
#' var_question <- "question_example" # character | the text of the question
#' var_answers <- "answers_example" # character | ```json [   {     \"text\": \"1942\",     \"image\": 123,     \"videoURL\": \"http://www.here.com\",     \"correct\": true   },   {     \"text\": \"1943\",     \"image\": 124,     \"videoURL\": \"http://www.there.com\",     \"correct\": false   } ] ``` 
#' var_active <- "active_example" # character | If true set the question to active. Default to false.
#' var_allocate_tickets <- "allocate_tickets_example" # character | If true then scoring will give tickets. Default to false.
#' var_ticket_count <- 56 # integer | The number of tickets to reward
#' var_tags <- "tags_example" # character | The tags of the question for search. (Optional)
#' var_video_url <- "video_url_example" # character | The video link for the question. (Optional)
#' var_asset_id <- 56 # integer | The asset id of the question. (Optional)
#' var_ticket_type <- "ticket_type_example" # character | The type of ticket to reward, null means default type (Optional)
#' var_points <- 56 # integer | The number of points to award for completing a mission (Optional)
#'
#' #Create Question
#' api_instance <- QuestionApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$CreateQuestion(var_account_id, var_question, var_answers, var_active, var_allocate_tickets, var_ticket_count, tags = var_tags, video_url = var_video_url, asset_id = var_asset_id, ticket_type = var_ticket_type, points = var_pointsdata_file = "result.txt")
#' result <- api_instance$CreateQuestion(var_account_id, var_question, var_answers, var_active, var_allocate_tickets, var_ticket_count, tags = var_tags, video_url = var_video_url, asset_id = var_asset_id, ticket_type = var_ticket_type, points = var_points)
#' dput(result)
#'
#'
#' ####################  DeleteQuestion  ####################
#'
#' library(openapi)
#' var_question_id <- 56 # integer | the id of the question to delete
#' var_account_id <- 56 # integer | the id of the account that can execute this request
#'
#' #Delete Question
#' api_instance <- QuestionApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$DeleteQuestion(var_question_id, var_account_iddata_file = "result.txt")
#' result <- api_instance$DeleteQuestion(var_question_id, var_account_id)
#' dput(result)
#'
#'
#' ####################  GetQuestion  ####################
#'
#' library(openapi)
#' var_question_id <- 56 # integer | the id of the question to get
#' var_account_id <- 56 # integer | the id of the account that can make this request
#'
#' #Get Question
#' api_instance <- QuestionApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$GetQuestion(var_question_id, var_account_iddata_file = "result.txt")
#' result <- api_instance$GetQuestion(var_question_id, var_account_id)
#' dput(result)
#'
#'
#' ####################  SearchQuestions  ####################
#'
#' library(openapi)
#' var_account_id <- 56 # integer | The logged in user.
#' var_sort_field <- "sort_field_example" # character | The column to sort the search on
#' var_descending <- "descending_example" # character | The order to return the search results
#' var_active_only <- "active_only_example" # character | Return only active results if set to true.
#' var_start <- 56 # integer | The record to begin the return set on.
#' var_limit <- 56 # integer | The number of records to return.
#' var_keyword <- "keyword_example" # character | The keyword for searching questions with matching tags or question text. (Optional)
#'
#' #Search Questions
#' api_instance <- QuestionApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$SearchQuestions(var_account_id, var_sort_field, var_descending, var_active_only, var_start, var_limit, keyword = var_keyworddata_file = "result.txt")
#' result <- api_instance$SearchQuestions(var_account_id, var_sort_field, var_descending, var_active_only, var_start, var_limit, keyword = var_keyword)
#' dput(result)
#'
#'
#' ####################  UpdateQuestion  ####################
#'
#' library(openapi)
#' var_question_id <- 56 # integer | The id of the question to update.
#' var_account_id <- 56 # integer | The logged in user.
#' var_ticket_count <- 56 # integer | The number of tickets to reward
#' var_question <- "question_example" # character | The text of the question. (Optional)
#' var_answers <- "answers_example" # character | The json representations of answers for the question. (Optional)
#' var_tags <- "tags_example" # character | The tags of the question for search. (Optional)
#' var_video_url <- "video_url_example" # character | The video link for the question. (Optional)
#' var_asset_id <- 56 # integer | The asset id of the question. (Optional)
#' var_active <- "active_example" # character | If true set the question to active. (Optional)
#' var_allocate_tickets <- "allocate_tickets_example" # character | If true then scoring will give tickets. (Optional)
#' var_ticket_type <- "ticket_type_example" # character | The type of ticket to reward, null means default type (Optional)
#' var_points <- 56 # integer | The number of points to award for completing a mission (Optional)
#'
#' #Update Question
#' api_instance <- QuestionApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$UpdateQuestion(var_question_id, var_account_id, var_ticket_count, question = var_question, answers = var_answers, tags = var_tags, video_url = var_video_url, asset_id = var_asset_id, active = var_active, allocate_tickets = var_allocate_tickets, ticket_type = var_ticket_type, points = var_pointsdata_file = "result.txt")
#' result <- api_instance$UpdateQuestion(var_question_id, var_account_id, var_ticket_count, question = var_question, answers = var_answers, tags = var_tags, video_url = var_video_url, asset_id = var_asset_id, active = var_active, allocate_tickets = var_allocate_tickets, ticket_type = var_ticket_type, points = var_points)
#' dput(result)
#'
#'
#' }
#' @importFrom R6 R6Class
#' @importFrom base64enc base64encode
#' @export
QuestionApi <- R6::R6Class(
  "QuestionApi",
  public = list(
    api_client = NULL,

    #' @description
    #' Initialize a new QuestionApi.
    #'
    #' @param api_client An instance of API client.
    initialize = function(api_client) {
      if (!missing(api_client)) {
        self$api_client <- api_client
      } else {
        self$api_client <- ApiClient$new()
      }
    },

    #' @description
    #' Create Question
    #'
    #' @param account_id the id of the logged in user
    #' @param question the text of the question
    #' @param answers ```json [   {     \"text\": \"1942\",     \"image\": 123,     \"videoURL\": \"http://www.here.com\",     \"correct\": true   },   {     \"text\": \"1943\",     \"image\": 124,     \"videoURL\": \"http://www.there.com\",     \"correct\": false   } ] ``` 
    #' @param active If true set the question to active. Default to false.
    #' @param allocate_tickets If true then scoring will give tickets. Default to false.
    #' @param ticket_count The number of tickets to reward
    #' @param tags (optional) The tags of the question for search.
    #' @param video_url (optional) The video link for the question.
    #' @param asset_id (optional) The asset id of the question.
    #' @param ticket_type (optional) The type of ticket to reward, null means default type
    #' @param points (optional) The number of points to award for completing a mission
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return QuestionResponse
    CreateQuestion = function(account_id, question, answers, active, allocate_tickets, ticket_count, tags = NULL, video_url = NULL, asset_id = NULL, ticket_type = NULL, points = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$CreateQuestionWithHttpInfo(account_id, question, answers, active, allocate_tickets, ticket_count, tags, video_url, asset_id, ticket_type, points, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Create Question
    #'
    #' @param account_id the id of the logged in user
    #' @param question the text of the question
    #' @param answers ```json [   {     \"text\": \"1942\",     \"image\": 123,     \"videoURL\": \"http://www.here.com\",     \"correct\": true   },   {     \"text\": \"1943\",     \"image\": 124,     \"videoURL\": \"http://www.there.com\",     \"correct\": false   } ] ``` 
    #' @param active If true set the question to active. Default to false.
    #' @param allocate_tickets If true then scoring will give tickets. Default to false.
    #' @param ticket_count The number of tickets to reward
    #' @param tags (optional) The tags of the question for search.
    #' @param video_url (optional) The video link for the question.
    #' @param asset_id (optional) The asset id of the question.
    #' @param ticket_type (optional) The type of ticket to reward, null means default type
    #' @param points (optional) The number of points to award for completing a mission
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (QuestionResponse) with additional information such as HTTP status code, headers
    CreateQuestionWithHttpInfo = function(account_id, question, answers, active, allocate_tickets, ticket_count, tags = NULL, video_url = NULL, asset_id = NULL, ticket_type = NULL, points = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (missing(`question`)) {
        stop("Missing required parameter `question`.")
      }

      if (missing(`answers`)) {
        stop("Missing required parameter `answers`.")
      }

      if (missing(`active`)) {
        stop("Missing required parameter `active`.")
      }

      if (missing(`allocate_tickets`)) {
        stop("Missing required parameter `allocate_tickets`.")
      }

      if (missing(`ticket_count`)) {
        stop("Missing required parameter `ticket_count`.")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling QuestionApi$CreateQuestion, `account_id` is not nullable")
      }

      if (!missing(`question`) && is.null(`question`)) {
        stop("Invalid value for `question` when calling QuestionApi$CreateQuestion, `question` is not nullable")
      }

      if (!missing(`answers`) && is.null(`answers`)) {
        stop("Invalid value for `answers` when calling QuestionApi$CreateQuestion, `answers` is not nullable")
      }

      if (!missing(`active`) && is.null(`active`)) {
        stop("Invalid value for `active` when calling QuestionApi$CreateQuestion, `active` is not nullable")
      }

      if (!missing(`allocate_tickets`) && is.null(`allocate_tickets`)) {
        stop("Invalid value for `allocate_tickets` when calling QuestionApi$CreateQuestion, `allocate_tickets` is not nullable")
      }

      if (!missing(`ticket_count`) && is.null(`ticket_count`)) {
        stop("Invalid value for `ticket_count` when calling QuestionApi$CreateQuestion, `ticket_count` is not nullable")
      }

      if (!missing(`tags`) && is.null(`tags`)) {
        stop("Invalid value for `tags` when calling QuestionApi$CreateQuestion, `tags` is not nullable")
      }

      if (!missing(`video_url`) && is.null(`video_url`)) {
        stop("Invalid value for `video_url` when calling QuestionApi$CreateQuestion, `video_url` is not nullable")
      }

      if (!missing(`asset_id`) && is.null(`asset_id`)) {
        stop("Invalid value for `asset_id` when calling QuestionApi$CreateQuestion, `asset_id` is not nullable")
      }

      if (!missing(`ticket_type`) && is.null(`ticket_type`)) {
        stop("Invalid value for `ticket_type` when calling QuestionApi$CreateQuestion, `ticket_type` is not nullable")
      }

      if (!missing(`points`) && is.null(`points`)) {
        stop("Invalid value for `points` when calling QuestionApi$CreateQuestion, `points` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["question"]] <- `question`

      query_params[["answers"]] <- `answers`

      query_params[["tags"]] <- `tags`

      query_params[["videoURL"]] <- `video_url`

      query_params[["assetId"]] <- `asset_id`

      query_params[["active"]] <- `active`

      query_params[["allocateTickets"]] <- `allocate_tickets`

      query_params[["ticketCount"]] <- `ticket_count`

      query_params[["ticketType"]] <- `ticket_type`

      query_params[["points"]] <- `points`

      local_var_url_path <- "/game/question/create"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "QuestionResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Delete Question
    #'
    #' @param question_id the id of the question to delete
    #' @param account_id the id of the account that can execute this request
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return SirqulResponse
    DeleteQuestion = function(question_id, account_id, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$DeleteQuestionWithHttpInfo(question_id, account_id, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Delete Question
    #'
    #' @param question_id the id of the question to delete
    #' @param account_id the id of the account that can execute this request
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (SirqulResponse) with additional information such as HTTP status code, headers
    DeleteQuestionWithHttpInfo = function(question_id, account_id, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`question_id`)) {
        stop("Missing required parameter `question_id`.")
      }

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (!missing(`question_id`) && is.null(`question_id`)) {
        stop("Invalid value for `question_id` when calling QuestionApi$DeleteQuestion, `question_id` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling QuestionApi$DeleteQuestion, `account_id` is not nullable")
      }

      query_params[["questionId"]] <- `question_id`

      query_params[["accountId"]] <- `account_id`

      local_var_url_path <- "/game/question/delete"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "SirqulResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Get Question
    #'
    #' @param question_id the id of the question to get
    #' @param account_id the id of the account that can make this request
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return QuestionResponse
    GetQuestion = function(question_id, account_id, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$GetQuestionWithHttpInfo(question_id, account_id, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Get Question
    #'
    #' @param question_id the id of the question to get
    #' @param account_id the id of the account that can make this request
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (QuestionResponse) with additional information such as HTTP status code, headers
    GetQuestionWithHttpInfo = function(question_id, account_id, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`question_id`)) {
        stop("Missing required parameter `question_id`.")
      }

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (!missing(`question_id`) && is.null(`question_id`)) {
        stop("Invalid value for `question_id` when calling QuestionApi$GetQuestion, `question_id` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling QuestionApi$GetQuestion, `account_id` is not nullable")
      }

      query_params[["questionId"]] <- `question_id`

      query_params[["accountId"]] <- `account_id`

      local_var_url_path <- "/game/question/get"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "QuestionResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Search Questions
    #'
    #' @param account_id The logged in user.
    #' @param sort_field The column to sort the search on
    #' @param descending The order to return the search results
    #' @param active_only Return only active results if set to true.
    #' @param start The record to begin the return set on.
    #' @param limit The number of records to return.
    #' @param keyword (optional) The keyword for searching questions with matching tags or question text.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return array[QuestionResponse]
    SearchQuestions = function(account_id, sort_field, descending, active_only, start, limit, keyword = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$SearchQuestionsWithHttpInfo(account_id, sort_field, descending, active_only, start, limit, keyword, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Search Questions
    #'
    #' @param account_id The logged in user.
    #' @param sort_field The column to sort the search on
    #' @param descending The order to return the search results
    #' @param active_only Return only active results if set to true.
    #' @param start The record to begin the return set on.
    #' @param limit The number of records to return.
    #' @param keyword (optional) The keyword for searching questions with matching tags or question text.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (array[QuestionResponse]) with additional information such as HTTP status code, headers
    SearchQuestionsWithHttpInfo = function(account_id, sort_field, descending, active_only, start, limit, keyword = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (missing(`sort_field`)) {
        stop("Missing required parameter `sort_field`.")
      }

      if (missing(`descending`)) {
        stop("Missing required parameter `descending`.")
      }

      if (missing(`active_only`)) {
        stop("Missing required parameter `active_only`.")
      }

      if (missing(`start`)) {
        stop("Missing required parameter `start`.")
      }

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling QuestionApi$SearchQuestions, `account_id` is not nullable")
      }

      if (!missing(`sort_field`) && is.null(`sort_field`)) {
        stop("Invalid value for `sort_field` when calling QuestionApi$SearchQuestions, `sort_field` is not nullable")
      }

      if (!missing(`descending`) && is.null(`descending`)) {
        stop("Invalid value for `descending` when calling QuestionApi$SearchQuestions, `descending` is not nullable")
      }

      if (!missing(`active_only`) && is.null(`active_only`)) {
        stop("Invalid value for `active_only` when calling QuestionApi$SearchQuestions, `active_only` is not nullable")
      }

      if (!missing(`start`) && is.null(`start`)) {
        stop("Invalid value for `start` when calling QuestionApi$SearchQuestions, `start` is not nullable")
      }

      if (!missing(`limit`) && is.null(`limit`)) {
        stop("Invalid value for `limit` when calling QuestionApi$SearchQuestions, `limit` is not nullable")
      }

      if (!missing(`keyword`) && is.null(`keyword`)) {
        stop("Invalid value for `keyword` when calling QuestionApi$SearchQuestions, `keyword` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["keyword"]] <- `keyword`

      query_params[["sortField"]] <- `sort_field`

      query_params[["descending"]] <- `descending`

      query_params[["activeOnly"]] <- `active_only`

      query_params[["start"]] <- `start`

      query_params[["limit"]] <- `limit`

      local_var_url_path <- "/game/question/search"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "array[QuestionResponse]"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Update Question
    #'
    #' @param question_id The id of the question to update.
    #' @param account_id The logged in user.
    #' @param ticket_count The number of tickets to reward
    #' @param question (optional) The text of the question.
    #' @param answers (optional) The json representations of answers for the question.
    #' @param tags (optional) The tags of the question for search.
    #' @param video_url (optional) The video link for the question.
    #' @param asset_id (optional) The asset id of the question.
    #' @param active (optional) If true set the question to active.
    #' @param allocate_tickets (optional) If true then scoring will give tickets.
    #' @param ticket_type (optional) The type of ticket to reward, null means default type
    #' @param points (optional) The number of points to award for completing a mission
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return QuestionResponse
    UpdateQuestion = function(question_id, account_id, ticket_count, question = NULL, answers = NULL, tags = NULL, video_url = NULL, asset_id = NULL, active = NULL, allocate_tickets = NULL, ticket_type = NULL, points = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$UpdateQuestionWithHttpInfo(question_id, account_id, ticket_count, question, answers, tags, video_url, asset_id, active, allocate_tickets, ticket_type, points, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Update Question
    #'
    #' @param question_id The id of the question to update.
    #' @param account_id The logged in user.
    #' @param ticket_count The number of tickets to reward
    #' @param question (optional) The text of the question.
    #' @param answers (optional) The json representations of answers for the question.
    #' @param tags (optional) The tags of the question for search.
    #' @param video_url (optional) The video link for the question.
    #' @param asset_id (optional) The asset id of the question.
    #' @param active (optional) If true set the question to active.
    #' @param allocate_tickets (optional) If true then scoring will give tickets.
    #' @param ticket_type (optional) The type of ticket to reward, null means default type
    #' @param points (optional) The number of points to award for completing a mission
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (QuestionResponse) with additional information such as HTTP status code, headers
    UpdateQuestionWithHttpInfo = function(question_id, account_id, ticket_count, question = NULL, answers = NULL, tags = NULL, video_url = NULL, asset_id = NULL, active = NULL, allocate_tickets = NULL, ticket_type = NULL, points = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`question_id`)) {
        stop("Missing required parameter `question_id`.")
      }

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (missing(`ticket_count`)) {
        stop("Missing required parameter `ticket_count`.")
      }

      if (!missing(`question_id`) && is.null(`question_id`)) {
        stop("Invalid value for `question_id` when calling QuestionApi$UpdateQuestion, `question_id` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling QuestionApi$UpdateQuestion, `account_id` is not nullable")
      }

      if (!missing(`ticket_count`) && is.null(`ticket_count`)) {
        stop("Invalid value for `ticket_count` when calling QuestionApi$UpdateQuestion, `ticket_count` is not nullable")
      }

      if (!missing(`question`) && is.null(`question`)) {
        stop("Invalid value for `question` when calling QuestionApi$UpdateQuestion, `question` is not nullable")
      }

      if (!missing(`answers`) && is.null(`answers`)) {
        stop("Invalid value for `answers` when calling QuestionApi$UpdateQuestion, `answers` is not nullable")
      }

      if (!missing(`tags`) && is.null(`tags`)) {
        stop("Invalid value for `tags` when calling QuestionApi$UpdateQuestion, `tags` is not nullable")
      }

      if (!missing(`video_url`) && is.null(`video_url`)) {
        stop("Invalid value for `video_url` when calling QuestionApi$UpdateQuestion, `video_url` is not nullable")
      }

      if (!missing(`asset_id`) && is.null(`asset_id`)) {
        stop("Invalid value for `asset_id` when calling QuestionApi$UpdateQuestion, `asset_id` is not nullable")
      }

      if (!missing(`active`) && is.null(`active`)) {
        stop("Invalid value for `active` when calling QuestionApi$UpdateQuestion, `active` is not nullable")
      }

      if (!missing(`allocate_tickets`) && is.null(`allocate_tickets`)) {
        stop("Invalid value for `allocate_tickets` when calling QuestionApi$UpdateQuestion, `allocate_tickets` is not nullable")
      }

      if (!missing(`ticket_type`) && is.null(`ticket_type`)) {
        stop("Invalid value for `ticket_type` when calling QuestionApi$UpdateQuestion, `ticket_type` is not nullable")
      }

      if (!missing(`points`) && is.null(`points`)) {
        stop("Invalid value for `points` when calling QuestionApi$UpdateQuestion, `points` is not nullable")
      }

      query_params[["questionId"]] <- `question_id`

      query_params[["accountId"]] <- `account_id`

      query_params[["question"]] <- `question`

      query_params[["answers"]] <- `answers`

      query_params[["tags"]] <- `tags`

      query_params[["videoURL"]] <- `video_url`

      query_params[["assetId"]] <- `asset_id`

      query_params[["active"]] <- `active`

      query_params[["allocateTickets"]] <- `allocate_tickets`

      query_params[["ticketCount"]] <- `ticket_count`

      query_params[["ticketType"]] <- `ticket_type`

      query_params[["points"]] <- `points`

      local_var_url_path <- "/game/question/update"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "QuestionResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    }
  )
)
