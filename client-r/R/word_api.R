#' Sirqul IoT Platform
#'
#' Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
#'
#' The version of the OpenAPI document: 3.16
#' Contact: info@sirqul.com
#' Generated by: https://openapi-generator.tech
#'
#' @docType class
#' @title Word operations
#' @description WordApi
#' @format An \code{R6Class} generator object
#' @field api_client Handles the client-server communication.
#'
#' @examples
#' \dontrun{
#' ####################  CreateWord  ####################
#'
#' library(openapi)
#' var_account_id <- 56 # integer | The logged in user.
#' var_word <- "word_example" # character | The text of the word.
#' var_definition <- "definition_example" # character | The definition of the word.
#' var_active <- FALSE # character | If true set the word to active. Default to false.
#' var_allocate_tickets <- FALSE # character | If true then scoring will give tickets. Default to false.
#' var_ticket_count <- 0 # integer | The number of tickets to reward
#' var_asset_id <- 56 # integer | The asset id of the word. (Optional)
#' var_ticket_type <- "ticket_type_example" # character | The type of ticket to reward, null means default type (Optional)
#' var_points <- 56 # integer | The number of points to award for completing a mission (Optional)
#'
#' #Create Word
#' api_instance <- WordApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$CreateWord(var_account_id, var_word, var_definition, var_active, var_allocate_tickets, var_ticket_count, asset_id = var_asset_id, ticket_type = var_ticket_type, points = var_pointsdata_file = "result.txt")
#' result <- api_instance$CreateWord(var_account_id, var_word, var_definition, var_active, var_allocate_tickets, var_ticket_count, asset_id = var_asset_id, ticket_type = var_ticket_type, points = var_points)
#' dput(result)
#'
#'
#' ####################  DeleteWord  ####################
#'
#' library(openapi)
#' var_word_id <- 56 # integer | The id of the word to delete.
#' var_account_id <- 56 # integer | The account vor validating permission
#'
#' #Delete Word
#' api_instance <- WordApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$DeleteWord(var_word_id, var_account_iddata_file = "result.txt")
#' result <- api_instance$DeleteWord(var_word_id, var_account_id)
#' dput(result)
#'
#'
#' ####################  GetWord  ####################
#'
#' library(openapi)
#' var_word_id <- 56 # integer | The id of the word to get.
#' var_account_id <- 56 # integer | The logged in user.
#'
#' #Get Word
#' api_instance <- WordApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$GetWord(var_word_id, var_account_iddata_file = "result.txt")
#' result <- api_instance$GetWord(var_word_id, var_account_id)
#' dput(result)
#'
#'
#' ####################  GetWords  ####################
#'
#' library(openapi)
#' var_account_id <- 56 # integer | The logged in user.
#' var_sort_field <- "id" # character | The column to sort the search on
#' var_descending <- FALSE # character | The order to return the search results
#' var_active_only <- FALSE # character | Return only active results if set to true.
#' var_start <- 0 # integer | The record to begin the return set on.
#' var_limit <- 20 # integer | The number of records to return.
#' var_keyword <- "keyword_example" # character | The keyword for searching words with matching definition or word text. (Optional)
#'
#' #Search Words
#' api_instance <- WordApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$GetWords(var_account_id, var_sort_field, var_descending, var_active_only, var_start, var_limit, keyword = var_keyworddata_file = "result.txt")
#' result <- api_instance$GetWords(var_account_id, var_sort_field, var_descending, var_active_only, var_start, var_limit, keyword = var_keyword)
#' dput(result)
#'
#'
#' ####################  UpdateWord  ####################
#'
#' library(openapi)
#' var_word_id <- 56 # integer | The id of the word to update.
#' var_account_id <- 56 # integer | The logged in user.
#' var_ticket_count <- 0 # integer | The number of tickets to reward
#' var_word_text <- "word_text_example" # character | The text for the word (Optional)
#' var_definition <- "definition_example" # character | The definition of the word. (Optional)
#' var_asset_id <- 56 # integer | The asset id of the word. (Optional)
#' var_active <- "active_example" # character | If true set the word to active. (Optional)
#' var_allocate_tickets <- "allocate_tickets_example" # character | If true then scoring will give tickets. (Optional)
#' var_ticket_type <- "ticket_type_example" # character | The type of ticket to reward, null means default type (Optional)
#' var_points <- 56 # integer | The number of points to award for completing a mission (Optional)
#'
#' #Update Word
#' api_instance <- WordApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$UpdateWord(var_word_id, var_account_id, var_ticket_count, word_text = var_word_text, definition = var_definition, asset_id = var_asset_id, active = var_active, allocate_tickets = var_allocate_tickets, ticket_type = var_ticket_type, points = var_pointsdata_file = "result.txt")
#' result <- api_instance$UpdateWord(var_word_id, var_account_id, var_ticket_count, word_text = var_word_text, definition = var_definition, asset_id = var_asset_id, active = var_active, allocate_tickets = var_allocate_tickets, ticket_type = var_ticket_type, points = var_points)
#' dput(result)
#'
#'
#' }
#' @importFrom R6 R6Class
#' @importFrom base64enc base64encode
#' @export
WordApi <- R6::R6Class(
  "WordApi",
  public = list(
    api_client = NULL,

    #' @description
    #' Initialize a new WordApi.
    #'
    #' @param api_client An instance of API client.
    initialize = function(api_client) {
      if (!missing(api_client)) {
        self$api_client <- api_client
      } else {
        self$api_client <- ApiClient$new()
      }
    },

    #' @description
    #' Create Word
    #'
    #' @param account_id The logged in user.
    #' @param word The text of the word.
    #' @param definition The definition of the word.
    #' @param active If true set the word to active. Default to false.
    #' @param allocate_tickets If true then scoring will give tickets. Default to false.
    #' @param ticket_count The number of tickets to reward
    #' @param asset_id (optional) The asset id of the word.
    #' @param ticket_type (optional) The type of ticket to reward, null means default type
    #' @param points (optional) The number of points to award for completing a mission
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return WordzWordResponse
    CreateWord = function(account_id, word, definition, active, allocate_tickets, ticket_count, asset_id = NULL, ticket_type = NULL, points = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$CreateWordWithHttpInfo(account_id, word, definition, active, allocate_tickets, ticket_count, asset_id, ticket_type, points, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Create Word
    #'
    #' @param account_id The logged in user.
    #' @param word The text of the word.
    #' @param definition The definition of the word.
    #' @param active If true set the word to active. Default to false.
    #' @param allocate_tickets If true then scoring will give tickets. Default to false.
    #' @param ticket_count The number of tickets to reward
    #' @param asset_id (optional) The asset id of the word.
    #' @param ticket_type (optional) The type of ticket to reward, null means default type
    #' @param points (optional) The number of points to award for completing a mission
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (WordzWordResponse) with additional information such as HTTP status code, headers
    CreateWordWithHttpInfo = function(account_id, word, definition, active, allocate_tickets, ticket_count, asset_id = NULL, ticket_type = NULL, points = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (missing(`word`)) {
        stop("Missing required parameter `word`.")
      }

      if (missing(`definition`)) {
        stop("Missing required parameter `definition`.")
      }

      if (missing(`active`)) {
        stop("Missing required parameter `active`.")
      }

      if (missing(`allocate_tickets`)) {
        stop("Missing required parameter `allocate_tickets`.")
      }

      if (missing(`ticket_count`)) {
        stop("Missing required parameter `ticket_count`.")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling WordApi$CreateWord, `account_id` is not nullable")
      }

      if (!missing(`word`) && is.null(`word`)) {
        stop("Invalid value for `word` when calling WordApi$CreateWord, `word` is not nullable")
      }

      if (!missing(`definition`) && is.null(`definition`)) {
        stop("Invalid value for `definition` when calling WordApi$CreateWord, `definition` is not nullable")
      }

      if (!missing(`active`) && is.null(`active`)) {
        stop("Invalid value for `active` when calling WordApi$CreateWord, `active` is not nullable")
      }

      if (!missing(`allocate_tickets`) && is.null(`allocate_tickets`)) {
        stop("Invalid value for `allocate_tickets` when calling WordApi$CreateWord, `allocate_tickets` is not nullable")
      }

      if (!missing(`ticket_count`) && is.null(`ticket_count`)) {
        stop("Invalid value for `ticket_count` when calling WordApi$CreateWord, `ticket_count` is not nullable")
      }

      if (!missing(`asset_id`) && is.null(`asset_id`)) {
        stop("Invalid value for `asset_id` when calling WordApi$CreateWord, `asset_id` is not nullable")
      }

      if (!missing(`ticket_type`) && is.null(`ticket_type`)) {
        stop("Invalid value for `ticket_type` when calling WordApi$CreateWord, `ticket_type` is not nullable")
      }

      if (!missing(`points`) && is.null(`points`)) {
        stop("Invalid value for `points` when calling WordApi$CreateWord, `points` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["word"]] <- `word`

      query_params[["definition"]] <- `definition`

      query_params[["assetId"]] <- `asset_id`

      query_params[["active"]] <- `active`

      query_params[["allocateTickets"]] <- `allocate_tickets`

      query_params[["ticketCount"]] <- `ticket_count`

      query_params[["ticketType"]] <- `ticket_type`

      query_params[["points"]] <- `points`

      local_var_url_path <- "/game/word/create"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "WordzWordResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Delete Word
    #'
    #' @param word_id The id of the word to delete.
    #' @param account_id The account vor validating permission
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return SirqulResponse
    DeleteWord = function(word_id, account_id, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$DeleteWordWithHttpInfo(word_id, account_id, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Delete Word
    #'
    #' @param word_id The id of the word to delete.
    #' @param account_id The account vor validating permission
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (SirqulResponse) with additional information such as HTTP status code, headers
    DeleteWordWithHttpInfo = function(word_id, account_id, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`word_id`)) {
        stop("Missing required parameter `word_id`.")
      }

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (!missing(`word_id`) && is.null(`word_id`)) {
        stop("Invalid value for `word_id` when calling WordApi$DeleteWord, `word_id` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling WordApi$DeleteWord, `account_id` is not nullable")
      }

      query_params[["wordId"]] <- `word_id`

      query_params[["accountId"]] <- `account_id`

      local_var_url_path <- "/game/word/delete"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "DELETE",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "SirqulResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Get Word
    #'
    #' @param word_id The id of the word to get.
    #' @param account_id The logged in user.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return WordzWordResponse
    GetWord = function(word_id, account_id, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$GetWordWithHttpInfo(word_id, account_id, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Get Word
    #'
    #' @param word_id The id of the word to get.
    #' @param account_id The logged in user.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (WordzWordResponse) with additional information such as HTTP status code, headers
    GetWordWithHttpInfo = function(word_id, account_id, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`word_id`)) {
        stop("Missing required parameter `word_id`.")
      }

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (!missing(`word_id`) && is.null(`word_id`)) {
        stop("Invalid value for `word_id` when calling WordApi$GetWord, `word_id` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling WordApi$GetWord, `account_id` is not nullable")
      }

      query_params[["wordId"]] <- `word_id`

      query_params[["accountId"]] <- `account_id`

      local_var_url_path <- "/game/word/get"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "WordzWordResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Search Words
    #'
    #' @param account_id The logged in user.
    #' @param sort_field The column to sort the search on
    #' @param descending The order to return the search results
    #' @param active_only Return only active results if set to true.
    #' @param start The record to begin the return set on.
    #' @param limit The number of records to return.
    #' @param keyword (optional) The keyword for searching words with matching definition or word text.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return array[WordzWordResponse]
    GetWords = function(account_id, sort_field, descending, active_only, start, limit, keyword = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$GetWordsWithHttpInfo(account_id, sort_field, descending, active_only, start, limit, keyword, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Search Words
    #'
    #' @param account_id The logged in user.
    #' @param sort_field The column to sort the search on
    #' @param descending The order to return the search results
    #' @param active_only Return only active results if set to true.
    #' @param start The record to begin the return set on.
    #' @param limit The number of records to return.
    #' @param keyword (optional) The keyword for searching words with matching definition or word text.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (array[WordzWordResponse]) with additional information such as HTTP status code, headers
    GetWordsWithHttpInfo = function(account_id, sort_field, descending, active_only, start, limit, keyword = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (missing(`sort_field`)) {
        stop("Missing required parameter `sort_field`.")
      }

      if (missing(`descending`)) {
        stop("Missing required parameter `descending`.")
      }

      if (missing(`active_only`)) {
        stop("Missing required parameter `active_only`.")
      }

      if (missing(`start`)) {
        stop("Missing required parameter `start`.")
      }

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling WordApi$GetWords, `account_id` is not nullable")
      }

      if (!missing(`sort_field`) && is.null(`sort_field`)) {
        stop("Invalid value for `sort_field` when calling WordApi$GetWords, `sort_field` is not nullable")
      }

      if (!missing(`descending`) && is.null(`descending`)) {
        stop("Invalid value for `descending` when calling WordApi$GetWords, `descending` is not nullable")
      }

      if (!missing(`active_only`) && is.null(`active_only`)) {
        stop("Invalid value for `active_only` when calling WordApi$GetWords, `active_only` is not nullable")
      }

      if (!missing(`start`) && is.null(`start`)) {
        stop("Invalid value for `start` when calling WordApi$GetWords, `start` is not nullable")
      }

      if (!missing(`limit`) && is.null(`limit`)) {
        stop("Invalid value for `limit` when calling WordApi$GetWords, `limit` is not nullable")
      }

      if (!missing(`keyword`) && is.null(`keyword`)) {
        stop("Invalid value for `keyword` when calling WordApi$GetWords, `keyword` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["keyword"]] <- `keyword`

      query_params[["sortField"]] <- `sort_field`

      query_params[["descending"]] <- `descending`

      query_params[["activeOnly"]] <- `active_only`

      query_params[["start"]] <- `start`

      query_params[["limit"]] <- `limit`

      local_var_url_path <- "/game/word/search"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "array[WordzWordResponse]"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Update Word
    #'
    #' @param word_id The id of the word to update.
    #' @param account_id The logged in user.
    #' @param ticket_count The number of tickets to reward
    #' @param word_text (optional) The text for the word
    #' @param definition (optional) The definition of the word.
    #' @param asset_id (optional) The asset id of the word.
    #' @param active (optional) If true set the word to active.
    #' @param allocate_tickets (optional) If true then scoring will give tickets.
    #' @param ticket_type (optional) The type of ticket to reward, null means default type
    #' @param points (optional) The number of points to award for completing a mission
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return WordzWordResponse
    UpdateWord = function(word_id, account_id, ticket_count, word_text = NULL, definition = NULL, asset_id = NULL, active = NULL, allocate_tickets = NULL, ticket_type = NULL, points = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$UpdateWordWithHttpInfo(word_id, account_id, ticket_count, word_text, definition, asset_id, active, allocate_tickets, ticket_type, points, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Update Word
    #'
    #' @param word_id The id of the word to update.
    #' @param account_id The logged in user.
    #' @param ticket_count The number of tickets to reward
    #' @param word_text (optional) The text for the word
    #' @param definition (optional) The definition of the word.
    #' @param asset_id (optional) The asset id of the word.
    #' @param active (optional) If true set the word to active.
    #' @param allocate_tickets (optional) If true then scoring will give tickets.
    #' @param ticket_type (optional) The type of ticket to reward, null means default type
    #' @param points (optional) The number of points to award for completing a mission
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (WordzWordResponse) with additional information such as HTTP status code, headers
    UpdateWordWithHttpInfo = function(word_id, account_id, ticket_count, word_text = NULL, definition = NULL, asset_id = NULL, active = NULL, allocate_tickets = NULL, ticket_type = NULL, points = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`word_id`)) {
        stop("Missing required parameter `word_id`.")
      }

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (missing(`ticket_count`)) {
        stop("Missing required parameter `ticket_count`.")
      }

      if (!missing(`word_id`) && is.null(`word_id`)) {
        stop("Invalid value for `word_id` when calling WordApi$UpdateWord, `word_id` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling WordApi$UpdateWord, `account_id` is not nullable")
      }

      if (!missing(`ticket_count`) && is.null(`ticket_count`)) {
        stop("Invalid value for `ticket_count` when calling WordApi$UpdateWord, `ticket_count` is not nullable")
      }

      if (!missing(`word_text`) && is.null(`word_text`)) {
        stop("Invalid value for `word_text` when calling WordApi$UpdateWord, `word_text` is not nullable")
      }

      if (!missing(`definition`) && is.null(`definition`)) {
        stop("Invalid value for `definition` when calling WordApi$UpdateWord, `definition` is not nullable")
      }

      if (!missing(`asset_id`) && is.null(`asset_id`)) {
        stop("Invalid value for `asset_id` when calling WordApi$UpdateWord, `asset_id` is not nullable")
      }

      if (!missing(`active`) && is.null(`active`)) {
        stop("Invalid value for `active` when calling WordApi$UpdateWord, `active` is not nullable")
      }

      if (!missing(`allocate_tickets`) && is.null(`allocate_tickets`)) {
        stop("Invalid value for `allocate_tickets` when calling WordApi$UpdateWord, `allocate_tickets` is not nullable")
      }

      if (!missing(`ticket_type`) && is.null(`ticket_type`)) {
        stop("Invalid value for `ticket_type` when calling WordApi$UpdateWord, `ticket_type` is not nullable")
      }

      if (!missing(`points`) && is.null(`points`)) {
        stop("Invalid value for `points` when calling WordApi$UpdateWord, `points` is not nullable")
      }

      query_params[["wordId"]] <- `word_id`

      query_params[["accountId"]] <- `account_id`

      query_params[["wordText"]] <- `word_text`

      query_params[["definition"]] <- `definition`

      query_params[["assetId"]] <- `asset_id`

      query_params[["active"]] <- `active`

      query_params[["allocateTickets"]] <- `allocate_tickets`

      query_params[["ticketCount"]] <- `ticket_count`

      query_params[["ticketType"]] <- `ticket_type`

      query_params[["points"]] <- `points`

      local_var_url_path <- "/game/word/update"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "WordzWordResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    }
  )
)
