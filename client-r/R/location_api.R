#' Sirqul IoT Platform
#'
#' Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
#'
#' The version of the OpenAPI document: 3.16
#' Contact: info@sirqul.com
#' Generated by: https://openapi-generator.tech
#'
#' @docType class
#' @title Location operations
#' @description LocationApi
#' @format An \code{R6Class} generator object
#' @field api_client Handles the client-server communication.
#'
#' @examples
#' \dontrun{
#' ####################  CacheTrilaterationData  ####################
#'
#' library(openapi)
#' var_udid <- "udid_example" # character | The unique identifier of the source device
#' var_source_time <- 56 # integer | The current timestamp of the source device (Optional)
#' var_minimum_sample_size <- 56 # integer | the minimum number of Edysen devices that must be used to be able to trilaterate a device (Optional)
#' var_data <- "data_example" # character | The json formated sample data:  ```json {    \"count\": 2,   \"timespan\": 10,    \"samples\": [     {       \"deviceId\": \"device1\",       \"randomizedId\": true,        \"deviceSignature\": \"probe:xyz...\",        \"alternativeId\":\"adc123\",        \"rssi\": [-63, -75]     },      {       \"deviceId\": \"device2\",       \"randomizedId\": true,        \"deviceSignature\": \"probe:xyz...\",        \"alternativeId\": \"adc123\",        \"rssi\": [-83, -79]     }   ] } ```  (Optional)
#' var_var_data_file <- File.new('/path/to/file') # data.frame | Binary file containing data (multipart upload) (Optional)
#'
#' #Create Trilateration Data with File
#' api_instance <- LocationApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$CacheTrilaterationData(var_udid, source_time = var_source_time, minimum_sample_size = var_minimum_sample_size, data = var_data, var_data_file = var_var_data_filedata_file = "result.txt")
#' result <- api_instance$CacheTrilaterationData(var_udid, source_time = var_source_time, minimum_sample_size = var_minimum_sample_size, data = var_data, var_data_file = var_var_data_file)
#' dput(result)
#'
#'
#' ####################  CacheTrilaterationDataGzip  ####################
#'
#' library(openapi)
#' var_body <- TrilatCacheRequest$new("udid_example", 123, 123, c(TrilatCacheSample$new("avatarId_example", "deviceId_example", c(123), 123, 123, "networkName_example", "randomizedId_example", "deviceSignature_example", "alternateId_example", "type_example", "WIFI_PROBE_REQUEST", 123))) # TrilatCacheRequest |  (Optional)
#'
#' #Create Trilateration Data with Rest
#' api_instance <- LocationApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$CacheTrilaterationDataGzip(body = var_bodydata_file = "result.txt")
#' result <- api_instance$CacheTrilaterationDataGzip(body = var_body)
#' dput(result)
#'
#'
#' ####################  GetLocationByIp  ####################
#'
#' library(openapi)
#' var_ip <- "ip_example" # character | the ip address of the client device (Optional)
#'
#' #Get Location by IP
#' api_instance <- LocationApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$GetLocationByIp(ip = var_ipdata_file = "result.txt")
#' result <- api_instance$GetLocationByIp(ip = var_ip)
#' dput(result)
#'
#'
#' ####################  GetLocationByTrilateration  ####################
#'
#' library(openapi)
#' var_account_id <- 56 # integer | The account making the request, if provided the last know location will be updated (Optional)
#' var_latitude <- 3.4 # numeric | The known GPS latitude to compare to the calculated version (Optional)
#' var_longitude <- 3.4 # numeric | The known GPS longitude to compare to the calculated version (Optional)
#' var_data <- "data_example" # character | The json formated sample data:  ```json {    \"count\": 2,   \"timespan\": 10,    \"samples\": [     {       \"deviceId\": \"device1\",       \"rssi\": [-63, -75]     },      {       \"deviceId\": \"device2\",       \"rssi\": [-83, -79]     }   ] } ```  (Optional)
#' var_response_filters <- "response_filters_example" # character | Optional response filters (not used currently) (Optional)
#'
#' #Get Location by Trilateration
#' api_instance <- LocationApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$GetLocationByTrilateration(account_id = var_account_id, latitude = var_latitude, longitude = var_longitude, data = var_data, response_filters = var_response_filtersdata_file = "result.txt")
#' result <- api_instance$GetLocationByTrilateration(account_id = var_account_id, latitude = var_latitude, longitude = var_longitude, data = var_data, response_filters = var_response_filters)
#' dput(result)
#'
#'
#' ####################  GetLocations  ####################
#'
#' library(openapi)
#' var_device_id <- "device_id_example" # character | the device id (Optional)
#' var_account_id <- 56 # integer | the account id (Optional)
#' var_currentlatitude <- 3.4 # numeric | This parameter is deprecated. (Optional)
#' var_currentlongitude <- 3.4 # numeric | This parameter is deprecated. (Optional)
#' var_current_latitude <- 3.4 # numeric | the current latitude of the user (Optional)
#' var_current_longitude <- 3.4 # numeric | the current longitude of the user (Optional)
#' var_query <- "query_example" # character | the query results by keyword or address (Optional)
#' var_zipcode <- "zipcode_example" # character | This parameter is deprecated. (Optional)
#' var_zip_code <- "zip_code_example" # character | the zip code to filter results (Optional)
#' var_selected_maplatitude <- 3.4 # numeric | This parameter is deprecated. (Optional)
#' var_selected_maplongitude <- 3.4 # numeric | This parameter is deprecated. (Optional)
#' var_selected_map_latitude <- 3.4 # numeric | the latitude of where the search should originate from (Optional)
#' var_selected_map_longitude <- 3.4 # numeric | the longitude of where the search should originate from (Optional)
#' var_search_range <- 5 # numeric | the search range of the search in miles (Optional)
#' var_use_geocode <- FALSE # character | determines whether to allow searches via address (Optional)
#' var__i <- 56 # integer | This parameter is deprecated. (Optional)
#' var_start <- 0 # integer | the start index for pagination (Optional)
#' var__l <- 56 # integer | This parameter is deprecated. (Optional)
#' var_limit <- 20 # integer | the limit for pagination (Optional)
#'
#' #Search Regions or Postal Codes
#' api_instance <- LocationApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$GetLocations(device_id = var_device_id, account_id = var_account_id, currentlatitude = var_currentlatitude, currentlongitude = var_currentlongitude, current_latitude = var_current_latitude, current_longitude = var_current_longitude, query = var_query, zipcode = var_zipcode, zip_code = var_zip_code, selected_maplatitude = var_selected_maplatitude, selected_maplongitude = var_selected_maplongitude, selected_map_latitude = var_selected_map_latitude, selected_map_longitude = var_selected_map_longitude, search_range = var_search_range, use_geocode = var_use_geocode, _i = var__i, start = var_start, _l = var__l, limit = var_limitdata_file = "result.txt")
#' result <- api_instance$GetLocations(device_id = var_device_id, account_id = var_account_id, currentlatitude = var_currentlatitude, currentlongitude = var_currentlongitude, current_latitude = var_current_latitude, current_longitude = var_current_longitude, query = var_query, zipcode = var_zipcode, zip_code = var_zip_code, selected_maplatitude = var_selected_maplatitude, selected_maplongitude = var_selected_maplongitude, selected_map_latitude = var_selected_map_latitude, selected_map_longitude = var_selected_map_longitude, search_range = var_search_range, use_geocode = var_use_geocode, _i = var__i, start = var_start, _l = var__l, limit = var_limit)
#' dput(result)
#'
#'
#' }
#' @importFrom R6 R6Class
#' @importFrom base64enc base64encode
#' @export
LocationApi <- R6::R6Class(
  "LocationApi",
  public = list(
    api_client = NULL,

    #' @description
    #' Initialize a new LocationApi.
    #'
    #' @param api_client An instance of API client.
    initialize = function(api_client) {
      if (!missing(api_client)) {
        self$api_client <- api_client
      } else {
        self$api_client <- ApiClient$new()
      }
    },

    #' @description
    #' Create Trilateration Data with File
    #'
    #' @param udid The unique identifier of the source device
    #' @param source_time (optional) The current timestamp of the source device
    #' @param minimum_sample_size (optional) the minimum number of Edysen devices that must be used to be able to trilaterate a device
    #' @param data (optional) The json formated sample data:  ```json {    \"count\": 2,   \"timespan\": 10,    \"samples\": [     {       \"deviceId\": \"device1\",       \"randomizedId\": true,        \"deviceSignature\": \"probe:xyz...\",        \"alternativeId\":\"adc123\",        \"rssi\": [-63, -75]     },      {       \"deviceId\": \"device2\",       \"randomizedId\": true,        \"deviceSignature\": \"probe:xyz...\",        \"alternativeId\": \"adc123\",        \"rssi\": [-83, -79]     }   ] } ``` 
    #' @param var_data_file (optional) Binary file containing data (multipart upload)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return SirqulResponse
    CacheTrilaterationData = function(udid, source_time = NULL, minimum_sample_size = NULL, data = NULL, var_data_file = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$CacheTrilaterationDataWithHttpInfo(udid, source_time, minimum_sample_size, data, var_data_file, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Create Trilateration Data with File
    #'
    #' @param udid The unique identifier of the source device
    #' @param source_time (optional) The current timestamp of the source device
    #' @param minimum_sample_size (optional) the minimum number of Edysen devices that must be used to be able to trilaterate a device
    #' @param data (optional) The json formated sample data:  ```json {    \"count\": 2,   \"timespan\": 10,    \"samples\": [     {       \"deviceId\": \"device1\",       \"randomizedId\": true,        \"deviceSignature\": \"probe:xyz...\",        \"alternativeId\":\"adc123\",        \"rssi\": [-63, -75]     },      {       \"deviceId\": \"device2\",       \"randomizedId\": true,        \"deviceSignature\": \"probe:xyz...\",        \"alternativeId\": \"adc123\",        \"rssi\": [-83, -79]     }   ] } ``` 
    #' @param var_data_file (optional) Binary file containing data (multipart upload)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (SirqulResponse) with additional information such as HTTP status code, headers
    CacheTrilaterationDataWithHttpInfo = function(udid, source_time = NULL, minimum_sample_size = NULL, data = NULL, var_data_file = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`udid`)) {
        stop("Missing required parameter `udid`.")
      }

      if (!missing(`udid`) && is.null(`udid`)) {
        stop("Invalid value for `udid` when calling LocationApi$CacheTrilaterationData, `udid` is not nullable")
      }

      if (!missing(`source_time`) && is.null(`source_time`)) {
        stop("Invalid value for `source_time` when calling LocationApi$CacheTrilaterationData, `source_time` is not nullable")
      }

      if (!missing(`minimum_sample_size`) && is.null(`minimum_sample_size`)) {
        stop("Invalid value for `minimum_sample_size` when calling LocationApi$CacheTrilaterationData, `minimum_sample_size` is not nullable")
      }

      if (!missing(`data`) && is.null(`data`)) {
        stop("Invalid value for `data` when calling LocationApi$CacheTrilaterationData, `data` is not nullable")
      }

      if (!missing(`var_data_file`) && is.null(`var_data_file`)) {
        stop("Invalid value for `var_data_file` when calling LocationApi$CacheTrilaterationData, `var_data_file` is not nullable")
      }

      query_params[["udid"]] <- `udid`

      query_params[["sourceTime"]] <- `source_time`

      query_params[["minimumSampleSize"]] <- `minimum_sample_size`

      query_params[["data"]] <- `data`

      query_params[["dataFile"]] <- `var_data_file`

      local_var_url_path <- "/location/trilaterate/cache"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "SirqulResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Create Trilateration Data with Rest
    #'
    #' @param body (optional) No description
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return SirqulResponse
    CacheTrilaterationDataGzip = function(body = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$CacheTrilaterationDataGzipWithHttpInfo(body, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Create Trilateration Data with Rest
    #'
    #' @param body (optional) No description
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (SirqulResponse) with additional information such as HTTP status code, headers
    CacheTrilaterationDataGzipWithHttpInfo = function(body = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (!missing(`body`) && is.null(`body`)) {
        stop("Invalid value for `body` when calling LocationApi$CacheTrilaterationDataGzip, `body` is not nullable")
      }

      if (!is.null(`body`)) {
        local_var_body <- `body`$toJSONString()
      } else {
        local_var_body <- NULL
      }

      local_var_url_path <- "/location/trilaterate/cache/submit"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "SirqulResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Get Location by IP
    #'
    #' @param ip (optional) the ip address of the client device
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return CoordsResponse
    GetLocationByIp = function(ip = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$GetLocationByIpWithHttpInfo(ip, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Get Location by IP
    #'
    #' @param ip (optional) the ip address of the client device
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (CoordsResponse) with additional information such as HTTP status code, headers
    GetLocationByIpWithHttpInfo = function(ip = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (!missing(`ip`) && is.null(`ip`)) {
        stop("Invalid value for `ip` when calling LocationApi$GetLocationByIp, `ip` is not nullable")
      }

      query_params[["ip"]] <- `ip`

      local_var_url_path <- "/location/ip"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "CoordsResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Get Location by Trilateration
    #'
    #' @param account_id (optional) The account making the request, if provided the last know location will be updated
    #' @param latitude (optional) The known GPS latitude to compare to the calculated version
    #' @param longitude (optional) The known GPS longitude to compare to the calculated version
    #' @param data (optional) The json formated sample data:  ```json {    \"count\": 2,   \"timespan\": 10,    \"samples\": [     {       \"deviceId\": \"device1\",       \"rssi\": [-63, -75]     },      {       \"deviceId\": \"device2\",       \"rssi\": [-83, -79]     }   ] } ``` 
    #' @param response_filters (optional) Optional response filters (not used currently)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return GeoPointResponse
    GetLocationByTrilateration = function(account_id = NULL, latitude = NULL, longitude = NULL, data = NULL, response_filters = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$GetLocationByTrilaterationWithHttpInfo(account_id, latitude, longitude, data, response_filters, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Get Location by Trilateration
    #'
    #' @param account_id (optional) The account making the request, if provided the last know location will be updated
    #' @param latitude (optional) The known GPS latitude to compare to the calculated version
    #' @param longitude (optional) The known GPS longitude to compare to the calculated version
    #' @param data (optional) The json formated sample data:  ```json {    \"count\": 2,   \"timespan\": 10,    \"samples\": [     {       \"deviceId\": \"device1\",       \"rssi\": [-63, -75]     },      {       \"deviceId\": \"device2\",       \"rssi\": [-83, -79]     }   ] } ``` 
    #' @param response_filters (optional) Optional response filters (not used currently)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (GeoPointResponse) with additional information such as HTTP status code, headers
    GetLocationByTrilaterationWithHttpInfo = function(account_id = NULL, latitude = NULL, longitude = NULL, data = NULL, response_filters = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling LocationApi$GetLocationByTrilateration, `account_id` is not nullable")
      }

      if (!missing(`latitude`) && is.null(`latitude`)) {
        stop("Invalid value for `latitude` when calling LocationApi$GetLocationByTrilateration, `latitude` is not nullable")
      }

      if (!missing(`longitude`) && is.null(`longitude`)) {
        stop("Invalid value for `longitude` when calling LocationApi$GetLocationByTrilateration, `longitude` is not nullable")
      }

      if (!missing(`data`) && is.null(`data`)) {
        stop("Invalid value for `data` when calling LocationApi$GetLocationByTrilateration, `data` is not nullable")
      }

      if (!missing(`response_filters`) && is.null(`response_filters`)) {
        stop("Invalid value for `response_filters` when calling LocationApi$GetLocationByTrilateration, `response_filters` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["latitude"]] <- `latitude`

      query_params[["longitude"]] <- `longitude`

      query_params[["data"]] <- `data`

      query_params[["responseFilters"]] <- `response_filters`

      local_var_url_path <- "/account/location/trilaterate"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "GeoPointResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Search Regions or Postal Codes
    #'
    #' @param device_id (optional) the device id
    #' @param account_id (optional) the account id
    #' @param currentlatitude (optional) This parameter is deprecated.
    #' @param currentlongitude (optional) This parameter is deprecated.
    #' @param current_latitude (optional) the current latitude of the user
    #' @param current_longitude (optional) the current longitude of the user
    #' @param query (optional) the query results by keyword or address
    #' @param zipcode (optional) This parameter is deprecated.
    #' @param zip_code (optional) the zip code to filter results
    #' @param selected_maplatitude (optional) This parameter is deprecated.
    #' @param selected_maplongitude (optional) This parameter is deprecated.
    #' @param selected_map_latitude (optional) the latitude of where the search should originate from
    #' @param selected_map_longitude (optional) the longitude of where the search should originate from
    #' @param search_range (optional) the search range of the search in miles (default value: 5)
    #' @param use_geocode (optional) determines whether to allow searches via address (default value: FALSE)
    #' @param _i (optional) This parameter is deprecated.
    #' @param start (optional) the start index for pagination (default value: 0)
    #' @param _l (optional) This parameter is deprecated.
    #' @param limit (optional) the limit for pagination (default value: 20)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return LocationSearchResponse
    GetLocations = function(device_id = NULL, account_id = NULL, currentlatitude = NULL, currentlongitude = NULL, current_latitude = NULL, current_longitude = NULL, query = NULL, zipcode = NULL, zip_code = NULL, selected_maplatitude = NULL, selected_maplongitude = NULL, selected_map_latitude = NULL, selected_map_longitude = NULL, search_range = 5, use_geocode = FALSE, _i = NULL, start = 0, _l = NULL, limit = 20, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$GetLocationsWithHttpInfo(device_id, account_id, currentlatitude, currentlongitude, current_latitude, current_longitude, query, zipcode, zip_code, selected_maplatitude, selected_maplongitude, selected_map_latitude, selected_map_longitude, search_range, use_geocode, _i, start, _l, limit, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Search Regions or Postal Codes
    #'
    #' @param device_id (optional) the device id
    #' @param account_id (optional) the account id
    #' @param currentlatitude (optional) This parameter is deprecated.
    #' @param currentlongitude (optional) This parameter is deprecated.
    #' @param current_latitude (optional) the current latitude of the user
    #' @param current_longitude (optional) the current longitude of the user
    #' @param query (optional) the query results by keyword or address
    #' @param zipcode (optional) This parameter is deprecated.
    #' @param zip_code (optional) the zip code to filter results
    #' @param selected_maplatitude (optional) This parameter is deprecated.
    #' @param selected_maplongitude (optional) This parameter is deprecated.
    #' @param selected_map_latitude (optional) the latitude of where the search should originate from
    #' @param selected_map_longitude (optional) the longitude of where the search should originate from
    #' @param search_range (optional) the search range of the search in miles (default value: 5)
    #' @param use_geocode (optional) determines whether to allow searches via address (default value: FALSE)
    #' @param _i (optional) This parameter is deprecated.
    #' @param start (optional) the start index for pagination (default value: 0)
    #' @param _l (optional) This parameter is deprecated.
    #' @param limit (optional) the limit for pagination (default value: 20)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (LocationSearchResponse) with additional information such as HTTP status code, headers
    GetLocationsWithHttpInfo = function(device_id = NULL, account_id = NULL, currentlatitude = NULL, currentlongitude = NULL, current_latitude = NULL, current_longitude = NULL, query = NULL, zipcode = NULL, zip_code = NULL, selected_maplatitude = NULL, selected_maplongitude = NULL, selected_map_latitude = NULL, selected_map_longitude = NULL, search_range = 5, use_geocode = FALSE, _i = NULL, start = 0, _l = NULL, limit = 20, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (!missing(`device_id`) && is.null(`device_id`)) {
        stop("Invalid value for `device_id` when calling LocationApi$GetLocations, `device_id` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling LocationApi$GetLocations, `account_id` is not nullable")
      }

      if (!missing(`currentlatitude`) && is.null(`currentlatitude`)) {
        stop("Invalid value for `currentlatitude` when calling LocationApi$GetLocations, `currentlatitude` is not nullable")
      }

      if (!missing(`currentlongitude`) && is.null(`currentlongitude`)) {
        stop("Invalid value for `currentlongitude` when calling LocationApi$GetLocations, `currentlongitude` is not nullable")
      }

      if (!missing(`current_latitude`) && is.null(`current_latitude`)) {
        stop("Invalid value for `current_latitude` when calling LocationApi$GetLocations, `current_latitude` is not nullable")
      }

      if (!missing(`current_longitude`) && is.null(`current_longitude`)) {
        stop("Invalid value for `current_longitude` when calling LocationApi$GetLocations, `current_longitude` is not nullable")
      }

      if (!missing(`query`) && is.null(`query`)) {
        stop("Invalid value for `query` when calling LocationApi$GetLocations, `query` is not nullable")
      }

      if (!missing(`zipcode`) && is.null(`zipcode`)) {
        stop("Invalid value for `zipcode` when calling LocationApi$GetLocations, `zipcode` is not nullable")
      }

      if (!missing(`zip_code`) && is.null(`zip_code`)) {
        stop("Invalid value for `zip_code` when calling LocationApi$GetLocations, `zip_code` is not nullable")
      }

      if (!missing(`selected_maplatitude`) && is.null(`selected_maplatitude`)) {
        stop("Invalid value for `selected_maplatitude` when calling LocationApi$GetLocations, `selected_maplatitude` is not nullable")
      }

      if (!missing(`selected_maplongitude`) && is.null(`selected_maplongitude`)) {
        stop("Invalid value for `selected_maplongitude` when calling LocationApi$GetLocations, `selected_maplongitude` is not nullable")
      }

      if (!missing(`selected_map_latitude`) && is.null(`selected_map_latitude`)) {
        stop("Invalid value for `selected_map_latitude` when calling LocationApi$GetLocations, `selected_map_latitude` is not nullable")
      }

      if (!missing(`selected_map_longitude`) && is.null(`selected_map_longitude`)) {
        stop("Invalid value for `selected_map_longitude` when calling LocationApi$GetLocations, `selected_map_longitude` is not nullable")
      }

      if (!missing(`search_range`) && is.null(`search_range`)) {
        stop("Invalid value for `search_range` when calling LocationApi$GetLocations, `search_range` is not nullable")
      }

      if (!missing(`use_geocode`) && is.null(`use_geocode`)) {
        stop("Invalid value for `use_geocode` when calling LocationApi$GetLocations, `use_geocode` is not nullable")
      }

      if (!missing(`_i`) && is.null(`_i`)) {
        stop("Invalid value for `_i` when calling LocationApi$GetLocations, `_i` is not nullable")
      }

      if (!missing(`start`) && is.null(`start`)) {
        stop("Invalid value for `start` when calling LocationApi$GetLocations, `start` is not nullable")
      }

      if (!missing(`_l`) && is.null(`_l`)) {
        stop("Invalid value for `_l` when calling LocationApi$GetLocations, `_l` is not nullable")
      }

      if (!missing(`limit`) && is.null(`limit`)) {
        stop("Invalid value for `limit` when calling LocationApi$GetLocations, `limit` is not nullable")
      }

      query_params[["deviceId"]] <- `device_id`

      query_params[["accountId"]] <- `account_id`

      query_params[["currentlatitude"]] <- `currentlatitude`

      query_params[["currentlongitude"]] <- `currentlongitude`

      query_params[["currentLatitude"]] <- `current_latitude`

      query_params[["currentLongitude"]] <- `current_longitude`

      query_params[["query"]] <- `query`

      query_params[["zipcode"]] <- `zipcode`

      query_params[["zipCode"]] <- `zip_code`

      query_params[["selectedMaplatitude"]] <- `selected_maplatitude`

      query_params[["selectedMaplongitude"]] <- `selected_maplongitude`

      query_params[["selectedMapLatitude"]] <- `selected_map_latitude`

      query_params[["selectedMapLongitude"]] <- `selected_map_longitude`

      query_params[["searchRange"]] <- `search_range`

      query_params[["useGeocode"]] <- `use_geocode`

      query_params[["_i"]] <- `_i`

      query_params[["start"]] <- `start`

      query_params[["_l"]] <- `_l`

      query_params[["limit"]] <- `limit`

      local_var_url_path <- "/location/search"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "LocationSearchResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    }
  )
)
