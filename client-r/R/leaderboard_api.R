#' Sirqul IoT Platform
#'
#' Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
#'
#' The version of the OpenAPI document: 3.16
#' Contact: info@sirqul.com
#' Generated by: https://openapi-generator.tech
#'
#' @docType class
#' @title Leaderboard operations
#' @description LeaderboardApi
#' @format An \code{R6Class} generator object
#' @field api_client Handles the client-server communication.
#'
#' @examples
#' \dontrun{
#' ####################  CreateLeaderboard  ####################
#'
#' library(openapi)
#' var_account_id <- 56 # integer | The account id of the user creating the leaderboard. (Optional)
#' var_app_key <- "app_key_example" # character | The application key (Optional)
#' var_rank_type <- "rank_type_example" # character | a unique label for identifying the ranking. This can be any alphanumeric string with a maximum length of 64 characters. There are also default rank types to use which include: POINTS, DOWNLOADS, INVITATIONS, CREATIONS, VOTES, REDEEMED, ACTIONS (Optional)
#' var_leaderboard_mode <- "leaderboard_mode_example" # character | the type of search to perform. Possible values include: GLOBAL - searches scores globally (all users in the system are included in the ranking); LOCAL - filters results by select users and on users that have logged into the same device; SEARCH - does a GLOBAL search by keyword; CUSTOM - does a LOCAL search by keyword (Optional)
#' var_icon_media <- File.new('/path/to/file') # data.frame | a MultipartFile containing the icon image of the leaderboard (this will only be used if \"iconAssetId\" is empty) (Optional)
#' var_icon_asset_id <- 56 # integer | The asset ID to set the leaderboard icon (Optional)
#' var_banner_media <- File.new('/path/to/file') # data.frame | a MultipartFile containing the icon banner of the leaderboard (this will only be used if \"bannerAssetId\" is empty) (Optional)
#' var_banner_asset_id <- 56 # integer | The asset ID to set the leaderboard banner (Optional)
#' var_limitation <- 56 # integer | limit number of rankings for each leaderboard (Optional)
#' var_sort_field <- "sort_field_example" # character | determines how to order and rank the results. Possible values include: TOTAL, WEEKLY, DAILY, TOP, LOWEST (Optional)
#' var_title <- "title_example" # character | leaderboard's title (Optional)
#' var_description <- "description_example" # character | leaderboard's description (Optional)
#' var_meta_data <- "meta_data_example" # character | custom meta data for the leaderboard (Optional)
#'
#' #Create a leaderboard based on the rankingType, rankMode(leaderboardMode), sortField and limitation
#' api_instance <- LeaderboardApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$CreateLeaderboard(account_id = var_account_id, app_key = var_app_key, rank_type = var_rank_type, leaderboard_mode = var_leaderboard_mode, icon_media = var_icon_media, icon_asset_id = var_icon_asset_id, banner_media = var_banner_media, banner_asset_id = var_banner_asset_id, limitation = var_limitation, sort_field = var_sort_field, title = var_title, description = var_description, meta_data = var_meta_datadata_file = "result.txt")
#' result <- api_instance$CreateLeaderboard(account_id = var_account_id, app_key = var_app_key, rank_type = var_rank_type, leaderboard_mode = var_leaderboard_mode, icon_media = var_icon_media, icon_asset_id = var_icon_asset_id, banner_media = var_banner_media, banner_asset_id = var_banner_asset_id, limitation = var_limitation, sort_field = var_sort_field, title = var_title, description = var_description, meta_data = var_meta_data)
#' dput(result)
#'
#'
#' ####################  DeleteLeaderboard  ####################
#'
#' library(openapi)
#' var_leaderboard_id <- 56 # integer | The leaderboard id to delete.
#' var_account_id <- 56 # integer | The account id of the user making the request. (Optional)
#'
#' #Delete the Leader Board
#' api_instance <- LeaderboardApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$DeleteLeaderboard(var_leaderboard_id, account_id = var_account_iddata_file = "result.txt")
#' result <- api_instance$DeleteLeaderboard(var_leaderboard_id, account_id = var_account_id)
#' dput(result)
#'
#'
#' ####################  GetLeaderboard  ####################
#'
#' library(openapi)
#' var_leaderboard_id <- 56 # integer | The leaderboard id.
#' var_account_id <- 56 # integer | A valid account. (Optional)
#' var_include_full_ranking_list <- "include_full_ranking_list_example" # character | set to true if need to return the leaderboard's full ranking list (Optional)
#'
#' #Read a leaderboard by id and retrieve the matching ranking list
#' api_instance <- LeaderboardApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$GetLeaderboard(var_leaderboard_id, account_id = var_account_id, include_full_ranking_list = var_include_full_ranking_listdata_file = "result.txt")
#' result <- api_instance$GetLeaderboard(var_leaderboard_id, account_id = var_account_id, include_full_ranking_list = var_include_full_ranking_list)
#' dput(result)
#'
#'
#' ####################  SearchLeaderboards  ####################
#'
#' library(openapi)
#' var_account_id <- 56 # integer | The account id of the user requesting the search. (Optional)
#' var_app_key <- "app_key_example" # character | The application key. (Optional)
#' var_global_only <- "global_only_example" # character | only include global leaderboards (this overrides the appKey filter) (Optional)
#' var_keyword <- "keyword_example" # character | keyword to search by title (Optional)
#' var_leaderboard_ids <- "leaderboard_ids_example" # character | comma separated list of leaderboard ids to filter results with (Optional)
#' var_rank_types <- "rank_types_example" # character | comma separated list of rankType to filter results with (Optional)
#' var_sort_field <- "sort_field_example" # character | sortField of the result, from LeaderboardApiMap (TITLE, DESCRIPTION, CREATED, UPDATED, RANK_TYPE, RANK_MODE) (Optional)
#' var_descending <- "descending_example" # character | Determines whether the sorted list is in descending or ascending order (Optional)
#' var_include_inactive <- "include_inactive_example" # character | include inactive in the result (Optional)
#' var_include_app_response <- "include_app_response_example" # character | determines whether to include the application response for each leaderboard (Optional)
#' var_start <- 56 # integer | Start the result set at some index. (Optional)
#' var_limit <- 56 # integer | Limit the result to some number. (Optional)
#'
#' #Search leaderboard and retrieve the matching ranking list
#' api_instance <- LeaderboardApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$SearchLeaderboards(account_id = var_account_id, app_key = var_app_key, global_only = var_global_only, keyword = var_keyword, leaderboard_ids = var_leaderboard_ids, rank_types = var_rank_types, sort_field = var_sort_field, descending = var_descending, include_inactive = var_include_inactive, include_app_response = var_include_app_response, start = var_start, limit = var_limitdata_file = "result.txt")
#' result <- api_instance$SearchLeaderboards(account_id = var_account_id, app_key = var_app_key, global_only = var_global_only, keyword = var_keyword, leaderboard_ids = var_leaderboard_ids, rank_types = var_rank_types, sort_field = var_sort_field, descending = var_descending, include_inactive = var_include_inactive, include_app_response = var_include_app_response, start = var_start, limit = var_limit)
#' dput(result)
#'
#'
#' ####################  UpdateLeaderboard  ####################
#'
#' library(openapi)
#' var_leaderboard_id <- 56 # integer | The leaderboard id to update.
#' var_account_id <- 56 # integer | The account id of the user updating the leaderboard. (Optional)
#' var_app_key <- "app_key_example" # character | The application key (Optional)
#' var_rank_type <- "rank_type_example" # character | a unique label for identifying the ranking. This can be any alphanumeric string with a maximum length of 64 characters. (Optional)
#' var_leaderboard_mode <- "leaderboard_mode_example" # character | the type of search to perform. Possible values include: GLOBAL, LOCAL, SEARCH, CUSTOM (Optional)
#' var_sort_field <- "sort_field_example" # character | determines how to order and rank the results. Possible values include: TOTAL, WEEKLY, DAILY, TOP, LOWEST (Optional)
#' var_icon_media <- File.new('/path/to/file') # data.frame | a MultipartFile containing the icon image of the leaderboard (this will only be used if \"iconAssetId\" is empty) (Optional)
#' var_icon_asset_id <- 56 # integer | The asset ID to set the leaderboard icon (Optional)
#' var_banner_media <- File.new('/path/to/file') # data.frame | a MultipartFile containing the icon banner of the leaderboard (this will only be used if \"bannerAssetId\" is empty) (Optional)
#' var_banner_asset_id <- 56 # integer | The asset ID to set the leaderboard banner (Optional)
#' var_limitation <- 56 # integer | limit number of rankings for each leaderboard (Optional)
#' var_active <- "active_example" # character | Whether the leaderboard is active (Optional)
#' var_title <- "title_example" # character | leaderboard's title (Optional)
#' var_description <- "description_example" # character | leaderboard's description (Optional)
#' var_meta_data <- "meta_data_example" # character | custom meta data for the leaderboard (Optional)
#'
#' #Update a leaderboard based on the rankingType, rankMode(leaderboardMode), sortField and limitation
#' api_instance <- LeaderboardApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$UpdateLeaderboard(var_leaderboard_id, account_id = var_account_id, app_key = var_app_key, rank_type = var_rank_type, leaderboard_mode = var_leaderboard_mode, sort_field = var_sort_field, icon_media = var_icon_media, icon_asset_id = var_icon_asset_id, banner_media = var_banner_media, banner_asset_id = var_banner_asset_id, limitation = var_limitation, active = var_active, title = var_title, description = var_description, meta_data = var_meta_datadata_file = "result.txt")
#' result <- api_instance$UpdateLeaderboard(var_leaderboard_id, account_id = var_account_id, app_key = var_app_key, rank_type = var_rank_type, leaderboard_mode = var_leaderboard_mode, sort_field = var_sort_field, icon_media = var_icon_media, icon_asset_id = var_icon_asset_id, banner_media = var_banner_media, banner_asset_id = var_banner_asset_id, limitation = var_limitation, active = var_active, title = var_title, description = var_description, meta_data = var_meta_data)
#' dput(result)
#'
#'
#' }
#' @importFrom R6 R6Class
#' @importFrom base64enc base64encode
#' @export
LeaderboardApi <- R6::R6Class(
  "LeaderboardApi",
  public = list(
    api_client = NULL,

    #' @description
    #' Initialize a new LeaderboardApi.
    #'
    #' @param api_client An instance of API client.
    initialize = function(api_client) {
      if (!missing(api_client)) {
        self$api_client <- api_client
      } else {
        self$api_client <- ApiClient$new()
      }
    },

    #' @description
    #' Create a leaderboard based on the rankingType, rankMode(leaderboardMode), sortField and limitation
    #'
    #' @param account_id (optional) The account id of the user creating the leaderboard.
    #' @param app_key (optional) The application key
    #' @param rank_type (optional) a unique label for identifying the ranking. This can be any alphanumeric string with a maximum length of 64 characters. There are also default rank types to use which include: POINTS, DOWNLOADS, INVITATIONS, CREATIONS, VOTES, REDEEMED, ACTIONS
    #' @param leaderboard_mode (optional) the type of search to perform. Possible values include: GLOBAL - searches scores globally (all users in the system are included in the ranking); LOCAL - filters results by select users and on users that have logged into the same device; SEARCH - does a GLOBAL search by keyword; CUSTOM - does a LOCAL search by keyword
    #' @param icon_media (optional) a MultipartFile containing the icon image of the leaderboard (this will only be used if \"iconAssetId\" is empty)
    #' @param icon_asset_id (optional) The asset ID to set the leaderboard icon
    #' @param banner_media (optional) a MultipartFile containing the icon banner of the leaderboard (this will only be used if \"bannerAssetId\" is empty)
    #' @param banner_asset_id (optional) The asset ID to set the leaderboard banner
    #' @param limitation (optional) limit number of rankings for each leaderboard
    #' @param sort_field (optional) determines how to order and rank the results. Possible values include: TOTAL, WEEKLY, DAILY, TOP, LOWEST
    #' @param title (optional) leaderboard's title
    #' @param description (optional) leaderboard's description
    #' @param meta_data (optional) custom meta data for the leaderboard
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return LeaderboardResponse
    CreateLeaderboard = function(account_id = NULL, app_key = NULL, rank_type = NULL, leaderboard_mode = NULL, icon_media = NULL, icon_asset_id = NULL, banner_media = NULL, banner_asset_id = NULL, limitation = NULL, sort_field = NULL, title = NULL, description = NULL, meta_data = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$CreateLeaderboardWithHttpInfo(account_id, app_key, rank_type, leaderboard_mode, icon_media, icon_asset_id, banner_media, banner_asset_id, limitation, sort_field, title, description, meta_data, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Create a leaderboard based on the rankingType, rankMode(leaderboardMode), sortField and limitation
    #'
    #' @param account_id (optional) The account id of the user creating the leaderboard.
    #' @param app_key (optional) The application key
    #' @param rank_type (optional) a unique label for identifying the ranking. This can be any alphanumeric string with a maximum length of 64 characters. There are also default rank types to use which include: POINTS, DOWNLOADS, INVITATIONS, CREATIONS, VOTES, REDEEMED, ACTIONS
    #' @param leaderboard_mode (optional) the type of search to perform. Possible values include: GLOBAL - searches scores globally (all users in the system are included in the ranking); LOCAL - filters results by select users and on users that have logged into the same device; SEARCH - does a GLOBAL search by keyword; CUSTOM - does a LOCAL search by keyword
    #' @param icon_media (optional) a MultipartFile containing the icon image of the leaderboard (this will only be used if \"iconAssetId\" is empty)
    #' @param icon_asset_id (optional) The asset ID to set the leaderboard icon
    #' @param banner_media (optional) a MultipartFile containing the icon banner of the leaderboard (this will only be used if \"bannerAssetId\" is empty)
    #' @param banner_asset_id (optional) The asset ID to set the leaderboard banner
    #' @param limitation (optional) limit number of rankings for each leaderboard
    #' @param sort_field (optional) determines how to order and rank the results. Possible values include: TOTAL, WEEKLY, DAILY, TOP, LOWEST
    #' @param title (optional) leaderboard's title
    #' @param description (optional) leaderboard's description
    #' @param meta_data (optional) custom meta data for the leaderboard
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (LeaderboardResponse) with additional information such as HTTP status code, headers
    CreateLeaderboardWithHttpInfo = function(account_id = NULL, app_key = NULL, rank_type = NULL, leaderboard_mode = NULL, icon_media = NULL, icon_asset_id = NULL, banner_media = NULL, banner_asset_id = NULL, limitation = NULL, sort_field = NULL, title = NULL, description = NULL, meta_data = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling LeaderboardApi$CreateLeaderboard, `account_id` is not nullable")
      }

      if (!missing(`app_key`) && is.null(`app_key`)) {
        stop("Invalid value for `app_key` when calling LeaderboardApi$CreateLeaderboard, `app_key` is not nullable")
      }

      if (!missing(`rank_type`) && is.null(`rank_type`)) {
        stop("Invalid value for `rank_type` when calling LeaderboardApi$CreateLeaderboard, `rank_type` is not nullable")
      }

      if (!missing(`leaderboard_mode`) && is.null(`leaderboard_mode`)) {
        stop("Invalid value for `leaderboard_mode` when calling LeaderboardApi$CreateLeaderboard, `leaderboard_mode` is not nullable")
      }

      if (!missing(`icon_media`) && is.null(`icon_media`)) {
        stop("Invalid value for `icon_media` when calling LeaderboardApi$CreateLeaderboard, `icon_media` is not nullable")
      }

      if (!missing(`icon_asset_id`) && is.null(`icon_asset_id`)) {
        stop("Invalid value for `icon_asset_id` when calling LeaderboardApi$CreateLeaderboard, `icon_asset_id` is not nullable")
      }

      if (!missing(`banner_media`) && is.null(`banner_media`)) {
        stop("Invalid value for `banner_media` when calling LeaderboardApi$CreateLeaderboard, `banner_media` is not nullable")
      }

      if (!missing(`banner_asset_id`) && is.null(`banner_asset_id`)) {
        stop("Invalid value for `banner_asset_id` when calling LeaderboardApi$CreateLeaderboard, `banner_asset_id` is not nullable")
      }

      if (!missing(`limitation`) && is.null(`limitation`)) {
        stop("Invalid value for `limitation` when calling LeaderboardApi$CreateLeaderboard, `limitation` is not nullable")
      }

      if (!missing(`sort_field`) && is.null(`sort_field`)) {
        stop("Invalid value for `sort_field` when calling LeaderboardApi$CreateLeaderboard, `sort_field` is not nullable")
      }

      if (!missing(`title`) && is.null(`title`)) {
        stop("Invalid value for `title` when calling LeaderboardApi$CreateLeaderboard, `title` is not nullable")
      }

      if (!missing(`description`) && is.null(`description`)) {
        stop("Invalid value for `description` when calling LeaderboardApi$CreateLeaderboard, `description` is not nullable")
      }

      if (!missing(`meta_data`) && is.null(`meta_data`)) {
        stop("Invalid value for `meta_data` when calling LeaderboardApi$CreateLeaderboard, `meta_data` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["appKey"]] <- `app_key`

      query_params[["rankType"]] <- `rank_type`

      query_params[["leaderboardMode"]] <- `leaderboard_mode`

      query_params[["iconMedia"]] <- `icon_media`

      query_params[["iconAssetId"]] <- `icon_asset_id`

      query_params[["bannerMedia"]] <- `banner_media`

      query_params[["bannerAssetId"]] <- `banner_asset_id`

      query_params[["limitation"]] <- `limitation`

      query_params[["sortField"]] <- `sort_field`

      query_params[["title"]] <- `title`

      query_params[["description"]] <- `description`

      query_params[["metaData"]] <- `meta_data`

      local_var_url_path <- "/leaderboard/create"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "LeaderboardResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Delete the Leader Board
    #'
    #' @param leaderboard_id The leaderboard id to delete.
    #' @param account_id (optional) The account id of the user making the request.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return SirqulResponse
    DeleteLeaderboard = function(leaderboard_id, account_id = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$DeleteLeaderboardWithHttpInfo(leaderboard_id, account_id, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Delete the Leader Board
    #'
    #' @param leaderboard_id The leaderboard id to delete.
    #' @param account_id (optional) The account id of the user making the request.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (SirqulResponse) with additional information such as HTTP status code, headers
    DeleteLeaderboardWithHttpInfo = function(leaderboard_id, account_id = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`leaderboard_id`)) {
        stop("Missing required parameter `leaderboard_id`.")
      }

      if (!missing(`leaderboard_id`) && is.null(`leaderboard_id`)) {
        stop("Invalid value for `leaderboard_id` when calling LeaderboardApi$DeleteLeaderboard, `leaderboard_id` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling LeaderboardApi$DeleteLeaderboard, `account_id` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["leaderboardId"]] <- `leaderboard_id`

      local_var_url_path <- "/leaderboard/delete"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "SirqulResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Read a leaderboard by id and retrieve the matching ranking list
    #'
    #' @param leaderboard_id The leaderboard id.
    #' @param account_id (optional) A valid account.
    #' @param include_full_ranking_list (optional) set to true if need to return the leaderboard's full ranking list
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return LeaderboardResponse
    GetLeaderboard = function(leaderboard_id, account_id = NULL, include_full_ranking_list = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$GetLeaderboardWithHttpInfo(leaderboard_id, account_id, include_full_ranking_list, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Read a leaderboard by id and retrieve the matching ranking list
    #'
    #' @param leaderboard_id The leaderboard id.
    #' @param account_id (optional) A valid account.
    #' @param include_full_ranking_list (optional) set to true if need to return the leaderboard's full ranking list
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (LeaderboardResponse) with additional information such as HTTP status code, headers
    GetLeaderboardWithHttpInfo = function(leaderboard_id, account_id = NULL, include_full_ranking_list = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`leaderboard_id`)) {
        stop("Missing required parameter `leaderboard_id`.")
      }

      if (!missing(`leaderboard_id`) && is.null(`leaderboard_id`)) {
        stop("Invalid value for `leaderboard_id` when calling LeaderboardApi$GetLeaderboard, `leaderboard_id` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling LeaderboardApi$GetLeaderboard, `account_id` is not nullable")
      }

      if (!missing(`include_full_ranking_list`) && is.null(`include_full_ranking_list`)) {
        stop("Invalid value for `include_full_ranking_list` when calling LeaderboardApi$GetLeaderboard, `include_full_ranking_list` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["leaderboardId"]] <- `leaderboard_id`

      query_params[["includeFullRankingList"]] <- `include_full_ranking_list`

      local_var_url_path <- "/leaderboard/get"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "LeaderboardResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Search leaderboard and retrieve the matching ranking list
    #'
    #' @param account_id (optional) The account id of the user requesting the search.
    #' @param app_key (optional) The application key.
    #' @param global_only (optional) only include global leaderboards (this overrides the appKey filter)
    #' @param keyword (optional) keyword to search by title
    #' @param leaderboard_ids (optional) comma separated list of leaderboard ids to filter results with
    #' @param rank_types (optional) comma separated list of rankType to filter results with
    #' @param sort_field (optional) sortField of the result, from LeaderboardApiMap (TITLE, DESCRIPTION, CREATED, UPDATED, RANK_TYPE, RANK_MODE)
    #' @param descending (optional) Determines whether the sorted list is in descending or ascending order
    #' @param include_inactive (optional) include inactive in the result
    #' @param include_app_response (optional) determines whether to include the application response for each leaderboard
    #' @param start (optional) Start the result set at some index.
    #' @param limit (optional) Limit the result to some number.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return LeaderboardResponse
    SearchLeaderboards = function(account_id = NULL, app_key = NULL, global_only = NULL, keyword = NULL, leaderboard_ids = NULL, rank_types = NULL, sort_field = NULL, descending = NULL, include_inactive = NULL, include_app_response = NULL, start = NULL, limit = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$SearchLeaderboardsWithHttpInfo(account_id, app_key, global_only, keyword, leaderboard_ids, rank_types, sort_field, descending, include_inactive, include_app_response, start, limit, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Search leaderboard and retrieve the matching ranking list
    #'
    #' @param account_id (optional) The account id of the user requesting the search.
    #' @param app_key (optional) The application key.
    #' @param global_only (optional) only include global leaderboards (this overrides the appKey filter)
    #' @param keyword (optional) keyword to search by title
    #' @param leaderboard_ids (optional) comma separated list of leaderboard ids to filter results with
    #' @param rank_types (optional) comma separated list of rankType to filter results with
    #' @param sort_field (optional) sortField of the result, from LeaderboardApiMap (TITLE, DESCRIPTION, CREATED, UPDATED, RANK_TYPE, RANK_MODE)
    #' @param descending (optional) Determines whether the sorted list is in descending or ascending order
    #' @param include_inactive (optional) include inactive in the result
    #' @param include_app_response (optional) determines whether to include the application response for each leaderboard
    #' @param start (optional) Start the result set at some index.
    #' @param limit (optional) Limit the result to some number.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (LeaderboardResponse) with additional information such as HTTP status code, headers
    SearchLeaderboardsWithHttpInfo = function(account_id = NULL, app_key = NULL, global_only = NULL, keyword = NULL, leaderboard_ids = NULL, rank_types = NULL, sort_field = NULL, descending = NULL, include_inactive = NULL, include_app_response = NULL, start = NULL, limit = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling LeaderboardApi$SearchLeaderboards, `account_id` is not nullable")
      }

      if (!missing(`app_key`) && is.null(`app_key`)) {
        stop("Invalid value for `app_key` when calling LeaderboardApi$SearchLeaderboards, `app_key` is not nullable")
      }

      if (!missing(`global_only`) && is.null(`global_only`)) {
        stop("Invalid value for `global_only` when calling LeaderboardApi$SearchLeaderboards, `global_only` is not nullable")
      }

      if (!missing(`keyword`) && is.null(`keyword`)) {
        stop("Invalid value for `keyword` when calling LeaderboardApi$SearchLeaderboards, `keyword` is not nullable")
      }

      if (!missing(`leaderboard_ids`) && is.null(`leaderboard_ids`)) {
        stop("Invalid value for `leaderboard_ids` when calling LeaderboardApi$SearchLeaderboards, `leaderboard_ids` is not nullable")
      }

      if (!missing(`rank_types`) && is.null(`rank_types`)) {
        stop("Invalid value for `rank_types` when calling LeaderboardApi$SearchLeaderboards, `rank_types` is not nullable")
      }

      if (!missing(`sort_field`) && is.null(`sort_field`)) {
        stop("Invalid value for `sort_field` when calling LeaderboardApi$SearchLeaderboards, `sort_field` is not nullable")
      }

      if (!missing(`descending`) && is.null(`descending`)) {
        stop("Invalid value for `descending` when calling LeaderboardApi$SearchLeaderboards, `descending` is not nullable")
      }

      if (!missing(`include_inactive`) && is.null(`include_inactive`)) {
        stop("Invalid value for `include_inactive` when calling LeaderboardApi$SearchLeaderboards, `include_inactive` is not nullable")
      }

      if (!missing(`include_app_response`) && is.null(`include_app_response`)) {
        stop("Invalid value for `include_app_response` when calling LeaderboardApi$SearchLeaderboards, `include_app_response` is not nullable")
      }

      if (!missing(`start`) && is.null(`start`)) {
        stop("Invalid value for `start` when calling LeaderboardApi$SearchLeaderboards, `start` is not nullable")
      }

      if (!missing(`limit`) && is.null(`limit`)) {
        stop("Invalid value for `limit` when calling LeaderboardApi$SearchLeaderboards, `limit` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["appKey"]] <- `app_key`

      query_params[["globalOnly"]] <- `global_only`

      query_params[["keyword"]] <- `keyword`

      query_params[["leaderboardIds"]] <- `leaderboard_ids`

      query_params[["rankTypes"]] <- `rank_types`

      query_params[["sortField"]] <- `sort_field`

      query_params[["descending"]] <- `descending`

      query_params[["includeInactive"]] <- `include_inactive`

      query_params[["includeAppResponse"]] <- `include_app_response`

      query_params[["start"]] <- `start`

      query_params[["limit"]] <- `limit`

      local_var_url_path <- "/leaderboard/search"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "LeaderboardResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Update a leaderboard based on the rankingType, rankMode(leaderboardMode), sortField and limitation
    #'
    #' @param leaderboard_id The leaderboard id to update.
    #' @param account_id (optional) The account id of the user updating the leaderboard.
    #' @param app_key (optional) The application key
    #' @param rank_type (optional) a unique label for identifying the ranking. This can be any alphanumeric string with a maximum length of 64 characters.
    #' @param leaderboard_mode (optional) the type of search to perform. Possible values include: GLOBAL, LOCAL, SEARCH, CUSTOM
    #' @param sort_field (optional) determines how to order and rank the results. Possible values include: TOTAL, WEEKLY, DAILY, TOP, LOWEST
    #' @param icon_media (optional) a MultipartFile containing the icon image of the leaderboard (this will only be used if \"iconAssetId\" is empty)
    #' @param icon_asset_id (optional) The asset ID to set the leaderboard icon
    #' @param banner_media (optional) a MultipartFile containing the icon banner of the leaderboard (this will only be used if \"bannerAssetId\" is empty)
    #' @param banner_asset_id (optional) The asset ID to set the leaderboard banner
    #' @param limitation (optional) limit number of rankings for each leaderboard
    #' @param active (optional) Whether the leaderboard is active
    #' @param title (optional) leaderboard's title
    #' @param description (optional) leaderboard's description
    #' @param meta_data (optional) custom meta data for the leaderboard
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return LeaderboardResponse
    UpdateLeaderboard = function(leaderboard_id, account_id = NULL, app_key = NULL, rank_type = NULL, leaderboard_mode = NULL, sort_field = NULL, icon_media = NULL, icon_asset_id = NULL, banner_media = NULL, banner_asset_id = NULL, limitation = NULL, active = NULL, title = NULL, description = NULL, meta_data = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$UpdateLeaderboardWithHttpInfo(leaderboard_id, account_id, app_key, rank_type, leaderboard_mode, sort_field, icon_media, icon_asset_id, banner_media, banner_asset_id, limitation, active, title, description, meta_data, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Update a leaderboard based on the rankingType, rankMode(leaderboardMode), sortField and limitation
    #'
    #' @param leaderboard_id The leaderboard id to update.
    #' @param account_id (optional) The account id of the user updating the leaderboard.
    #' @param app_key (optional) The application key
    #' @param rank_type (optional) a unique label for identifying the ranking. This can be any alphanumeric string with a maximum length of 64 characters.
    #' @param leaderboard_mode (optional) the type of search to perform. Possible values include: GLOBAL, LOCAL, SEARCH, CUSTOM
    #' @param sort_field (optional) determines how to order and rank the results. Possible values include: TOTAL, WEEKLY, DAILY, TOP, LOWEST
    #' @param icon_media (optional) a MultipartFile containing the icon image of the leaderboard (this will only be used if \"iconAssetId\" is empty)
    #' @param icon_asset_id (optional) The asset ID to set the leaderboard icon
    #' @param banner_media (optional) a MultipartFile containing the icon banner of the leaderboard (this will only be used if \"bannerAssetId\" is empty)
    #' @param banner_asset_id (optional) The asset ID to set the leaderboard banner
    #' @param limitation (optional) limit number of rankings for each leaderboard
    #' @param active (optional) Whether the leaderboard is active
    #' @param title (optional) leaderboard's title
    #' @param description (optional) leaderboard's description
    #' @param meta_data (optional) custom meta data for the leaderboard
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (LeaderboardResponse) with additional information such as HTTP status code, headers
    UpdateLeaderboardWithHttpInfo = function(leaderboard_id, account_id = NULL, app_key = NULL, rank_type = NULL, leaderboard_mode = NULL, sort_field = NULL, icon_media = NULL, icon_asset_id = NULL, banner_media = NULL, banner_asset_id = NULL, limitation = NULL, active = NULL, title = NULL, description = NULL, meta_data = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`leaderboard_id`)) {
        stop("Missing required parameter `leaderboard_id`.")
      }

      if (!missing(`leaderboard_id`) && is.null(`leaderboard_id`)) {
        stop("Invalid value for `leaderboard_id` when calling LeaderboardApi$UpdateLeaderboard, `leaderboard_id` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling LeaderboardApi$UpdateLeaderboard, `account_id` is not nullable")
      }

      if (!missing(`app_key`) && is.null(`app_key`)) {
        stop("Invalid value for `app_key` when calling LeaderboardApi$UpdateLeaderboard, `app_key` is not nullable")
      }

      if (!missing(`rank_type`) && is.null(`rank_type`)) {
        stop("Invalid value for `rank_type` when calling LeaderboardApi$UpdateLeaderboard, `rank_type` is not nullable")
      }

      if (!missing(`leaderboard_mode`) && is.null(`leaderboard_mode`)) {
        stop("Invalid value for `leaderboard_mode` when calling LeaderboardApi$UpdateLeaderboard, `leaderboard_mode` is not nullable")
      }

      if (!missing(`sort_field`) && is.null(`sort_field`)) {
        stop("Invalid value for `sort_field` when calling LeaderboardApi$UpdateLeaderboard, `sort_field` is not nullable")
      }

      if (!missing(`icon_media`) && is.null(`icon_media`)) {
        stop("Invalid value for `icon_media` when calling LeaderboardApi$UpdateLeaderboard, `icon_media` is not nullable")
      }

      if (!missing(`icon_asset_id`) && is.null(`icon_asset_id`)) {
        stop("Invalid value for `icon_asset_id` when calling LeaderboardApi$UpdateLeaderboard, `icon_asset_id` is not nullable")
      }

      if (!missing(`banner_media`) && is.null(`banner_media`)) {
        stop("Invalid value for `banner_media` when calling LeaderboardApi$UpdateLeaderboard, `banner_media` is not nullable")
      }

      if (!missing(`banner_asset_id`) && is.null(`banner_asset_id`)) {
        stop("Invalid value for `banner_asset_id` when calling LeaderboardApi$UpdateLeaderboard, `banner_asset_id` is not nullable")
      }

      if (!missing(`limitation`) && is.null(`limitation`)) {
        stop("Invalid value for `limitation` when calling LeaderboardApi$UpdateLeaderboard, `limitation` is not nullable")
      }

      if (!missing(`active`) && is.null(`active`)) {
        stop("Invalid value for `active` when calling LeaderboardApi$UpdateLeaderboard, `active` is not nullable")
      }

      if (!missing(`title`) && is.null(`title`)) {
        stop("Invalid value for `title` when calling LeaderboardApi$UpdateLeaderboard, `title` is not nullable")
      }

      if (!missing(`description`) && is.null(`description`)) {
        stop("Invalid value for `description` when calling LeaderboardApi$UpdateLeaderboard, `description` is not nullable")
      }

      if (!missing(`meta_data`) && is.null(`meta_data`)) {
        stop("Invalid value for `meta_data` when calling LeaderboardApi$UpdateLeaderboard, `meta_data` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["appKey"]] <- `app_key`

      query_params[["leaderboardId"]] <- `leaderboard_id`

      query_params[["rankType"]] <- `rank_type`

      query_params[["leaderboardMode"]] <- `leaderboard_mode`

      query_params[["sortField"]] <- `sort_field`

      query_params[["iconMedia"]] <- `icon_media`

      query_params[["iconAssetId"]] <- `icon_asset_id`

      query_params[["bannerMedia"]] <- `banner_media`

      query_params[["bannerAssetId"]] <- `banner_asset_id`

      query_params[["limitation"]] <- `limitation`

      query_params[["active"]] <- `active`

      query_params[["title"]] <- `title`

      query_params[["description"]] <- `description`

      query_params[["metaData"]] <- `meta_data`

      local_var_url_path <- "/leaderboard/update"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "LeaderboardResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    }
  )
)
