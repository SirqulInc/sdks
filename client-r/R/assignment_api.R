#' Sirqul IoT Platform
#'
#' Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
#'
#' The version of the OpenAPI document: 3.16
#' Contact: info@sirqul.com
#' Generated by: https://openapi-generator.tech
#'
#' @docType class
#' @title Assignment operations
#' @description AssignmentApi
#' @format An \code{R6Class} generator object
#' @field api_client Handles the client-server communication.
#'
#' @examples
#' \dontrun{
#' ####################  AssigmentAssigneeAccountSearch  ####################
#'
#' library(openapi)
#' var_account_id <- 56 # integer | The account id sending the request
#' var_keyword <- "keyword_example" # character | The keyword to filter the returned results (Optional)
#'
#' #Search Assignment Assignees
#' api_instance <- AssignmentApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$AssigmentAssigneeAccountSearch(var_account_id, keyword = var_keyworddata_file = "result.txt")
#' result <- api_instance$AssigmentAssigneeAccountSearch(var_account_id, keyword = var_keyword)
#' dput(result)
#'
#'
#' ####################  AssignmentCreate  ####################
#'
#' library(openapi)
#' var_account_id <- 56 # integer | the user account id
#' var_name <- "name_example" # character | the name for the assignment
#' var_assignee_account_id <- 56 # integer | the account id to assign to
#' var_description <- "description_example" # character | the desciprtion for the assignment (Optional)
#' var_retailer_location_id <- 56 # integer | the retailer location id (Optional)
#' var_tags <- "tags_example" # character | the tags (Optional)
#' var_active <- "active_example" # character | determines whether the assignment is active or inactive (Optional)
#'
#' #Create Assignment
#' api_instance <- AssignmentApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$AssignmentCreate(var_account_id, var_name, var_assignee_account_id, description = var_description, retailer_location_id = var_retailer_location_id, tags = var_tags, active = var_activedata_file = "result.txt")
#' result <- api_instance$AssignmentCreate(var_account_id, var_name, var_assignee_account_id, description = var_description, retailer_location_id = var_retailer_location_id, tags = var_tags, active = var_active)
#' dput(result)
#'
#'
#' ####################  AssignmentDelete  ####################
#'
#' library(openapi)
#' var_account_id <- 56 # integer | the user account id
#' var_assignment_id <- 56 # integer | the assignment id
#'
#' #Delete Assignment
#' api_instance <- AssignmentApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$AssignmentDelete(var_account_id, var_assignment_iddata_file = "result.txt")
#' result <- api_instance$AssignmentDelete(var_account_id, var_assignment_id)
#' dput(result)
#'
#'
#' ####################  AssignmentGet  ####################
#'
#' library(openapi)
#' var_account_id <- 56 # integer | the user account id
#' var_assignment_id <- 56 # integer | the assignment id
#'
#' #Get Assignment
#' api_instance <- AssignmentApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$AssignmentGet(var_account_id, var_assignment_iddata_file = "result.txt")
#' result <- api_instance$AssignmentGet(var_account_id, var_assignment_id)
#' dput(result)
#'
#'
#' ####################  AssignmentSearch  ####################
#'
#' library(openapi)
#' var_account_id <- 56 # integer | the account sending the request
#' var_sort_field <- "sort_field_example" # character | sort by table field
#' var_descending <- "descending_example" # character | return results in descending order or not
#' var_active_only <- "active_only_example" # character | return active results only or not
#' var_start <- 56 # integer | The record to begin the return set on
#' var_limit <- 56 # integer | The number of records to return
#' var_creator_account_id <- 56 # integer | the creator of the assignment (Optional)
#' var_assignee_account_ids <- "assignee_account_ids_example" # character | filter results by assignee accounts. If not provided, all assignments that are assigned to accounts that are managed by the requested account will be returned. (Optional)
#' var_retailer_location_ids <- "retailer_location_ids_example" # character | filter results by retailer locations (Optional)
#' var_current_status_type <- "current_status_type_example" # character | filter results by assignment status (Optional)
#' var_keyword <- "keyword_example" # character | filter results by keyword search that matches the assignee, creator, or retailer location name (Optional)
#'
#' #Search Assignments
#' api_instance <- AssignmentApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$AssignmentSearch(var_account_id, var_sort_field, var_descending, var_active_only, var_start, var_limit, creator_account_id = var_creator_account_id, assignee_account_ids = var_assignee_account_ids, retailer_location_ids = var_retailer_location_ids, current_status_type = var_current_status_type, keyword = var_keyworddata_file = "result.txt")
#' result <- api_instance$AssignmentSearch(var_account_id, var_sort_field, var_descending, var_active_only, var_start, var_limit, creator_account_id = var_creator_account_id, assignee_account_ids = var_assignee_account_ids, retailer_location_ids = var_retailer_location_ids, current_status_type = var_current_status_type, keyword = var_keyword)
#' dput(result)
#'
#'
#' ####################  AssignmentStatusCreate  ####################
#'
#' library(openapi)
#' var_account_id <- 56 # integer | the user account id
#' var_assignment_id <- 56 # integer | the assignment id
#' var_scheduled_notification_id <- 56 # integer | the scheduled notification id for reminders (Optional)
#' var_to_do <- "to_do_example" # character | the type of to do. Possible values include: SITE_VISIT, PHONE, RECONTACT, RENEWAL, CREDIT (Optional)
#' var_connection <- "connection_example" # character | the connection type. Possible values include: INITIAL, FOLLOW_UP, DECLINED (Optional)
#' var_method <- "method_example" # character | the communication method type. Possible values include: PHONE, SITE_VISIT, EMAIL (Optional)
#' var_status <- "status_example" # character | the status type. Possible values include: ARCHIVED, SUBSCRIBED, UNSUBSCRIBED, CONTACTED, DECLINED, NOT_CONTACTED (Optional)
#' var_closure <- "closure_example" # character | the closure type. Possible values include: PHONE, SITE_VISIT, PHONE_SITE, WEB (Optional)
#' var_message <- "message_example" # character | the message from the assignee (Optional)
#' var_follow_up <- 56 # integer | the date to follow up by (Optional)
#' var_active <- "active_example" # character | determines whether the assignment status is active or inactive (Optional)
#'
#' #Create Assignment Status
#' api_instance <- AssignmentApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$AssignmentStatusCreate(var_account_id, var_assignment_id, scheduled_notification_id = var_scheduled_notification_id, to_do = var_to_do, connection = var_connection, method = var_method, status = var_status, closure = var_closure, message = var_message, follow_up = var_follow_up, active = var_activedata_file = "result.txt")
#' result <- api_instance$AssignmentStatusCreate(var_account_id, var_assignment_id, scheduled_notification_id = var_scheduled_notification_id, to_do = var_to_do, connection = var_connection, method = var_method, status = var_status, closure = var_closure, message = var_message, follow_up = var_follow_up, active = var_active)
#' dput(result)
#'
#'
#' ####################  AssignmentStatusDelete  ####################
#'
#' library(openapi)
#' var_account_id <- 56 # integer | the user account id
#' var_assignment_status_id <- 56 # integer | the assignment status id
#'
#' #Deletes Assignment Status
#' api_instance <- AssignmentApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$AssignmentStatusDelete(var_account_id, var_assignment_status_iddata_file = "result.txt")
#' result <- api_instance$AssignmentStatusDelete(var_account_id, var_assignment_status_id)
#' dput(result)
#'
#'
#' ####################  AssignmentStatusGet  ####################
#'
#' library(openapi)
#' var_account_id <- 56 # integer | the user account id
#' var_assignment_status_id <- 56 # integer | the assignment status id
#'
#' #Get Assignment Status
#' api_instance <- AssignmentApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$AssignmentStatusGet(var_account_id, var_assignment_status_iddata_file = "result.txt")
#' result <- api_instance$AssignmentStatusGet(var_account_id, var_assignment_status_id)
#' dput(result)
#'
#'
#' ####################  AssignmentStatusSearch  ####################
#'
#' library(openapi)
#' var_account_id <- 56 # integer | the user account id
#' var_sort_field <- "sort_field_example" # character | the field to sort by. Possible values include: ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, CURRENT_STATUS, TODO, CONNECTION, METHOD, STATUS, CLOSURE, MESSAGE, FOLLOW_UP
#' var_descending <- "descending_example" # character | determines whether the sorted list is in descending or ascending order
#' var_active_only <- "active_only_example" # character | determines whether to only return active results
#' var_start <- 56 # integer | the start index for pagination
#' var_limit <- 56 # integer | the limit for pagination
#' var_assignment_id <- 56 # integer | the assignment id (Optional)
#' var_creator_account_id <- 56 # integer | filter results by the account who created the status (Optional)
#' var_assignee_account_id <- 56 # integer | filter results by the assignee account (Optional)
#' var_retailer_location_id <- 56 # integer | filter results by by retailer location (Optional)
#' var_status_type <- "status_type_example" # character | filter results by the status type (Optional)
#' var_keyword <- "keyword_example" # character | filter results by keyword search (Optional)
#'
#' #Search Assignment Statuses
#' api_instance <- AssignmentApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$AssignmentStatusSearch(var_account_id, var_sort_field, var_descending, var_active_only, var_start, var_limit, assignment_id = var_assignment_id, creator_account_id = var_creator_account_id, assignee_account_id = var_assignee_account_id, retailer_location_id = var_retailer_location_id, status_type = var_status_type, keyword = var_keyworddata_file = "result.txt")
#' result <- api_instance$AssignmentStatusSearch(var_account_id, var_sort_field, var_descending, var_active_only, var_start, var_limit, assignment_id = var_assignment_id, creator_account_id = var_creator_account_id, assignee_account_id = var_assignee_account_id, retailer_location_id = var_retailer_location_id, status_type = var_status_type, keyword = var_keyword)
#' dput(result)
#'
#'
#' ####################  AssignmentStatusUpdate  ####################
#'
#' library(openapi)
#' var_account_id <- 56 # integer | the user account id
#' var_assignment_status_id <- 56 # integer | the assignment status id
#' var_scheduled_notification_id <- 56 # integer | the scheduled notification id for reminders (Optional)
#' var_to_do <- "to_do_example" # character | the type of to do. Possible values include: SITE_VISIT, PHONE, RECONTACT, RENEWAL, CREDIT (Optional)
#' var_connection <- "connection_example" # character | the connection type. Possible values include: INITIAL, FOLLOW_UP, DECLINED (Optional)
#' var_method <- "method_example" # character | the communication method type. Possible values include: PHONE, SITE_VISIT, EMAIL (Optional)
#' var_status <- "status_example" # character | the status type. Possible values include: ARCHIVED, SUBSCRIBED, UNSUBSCRIBED, CONTACTED, DECLINED, NOT_CONTACTED (Optional)
#' var_closure <- "closure_example" # character | the closure type. Possible values include: PHONE, SITE_VISIT, PHONE_SITE, WEB (Optional)
#' var_message <- "message_example" # character | the message from the assignee (Optional)
#' var_follow_up <- 56 # integer | the date to follow up by (Optional)
#' var_active <- "active_example" # character | determines whether the assignment status is active or inactive (Optional)
#'
#' #Update Assignment Status
#' api_instance <- AssignmentApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$AssignmentStatusUpdate(var_account_id, var_assignment_status_id, scheduled_notification_id = var_scheduled_notification_id, to_do = var_to_do, connection = var_connection, method = var_method, status = var_status, closure = var_closure, message = var_message, follow_up = var_follow_up, active = var_activedata_file = "result.txt")
#' result <- api_instance$AssignmentStatusUpdate(var_account_id, var_assignment_status_id, scheduled_notification_id = var_scheduled_notification_id, to_do = var_to_do, connection = var_connection, method = var_method, status = var_status, closure = var_closure, message = var_message, follow_up = var_follow_up, active = var_active)
#' dput(result)
#'
#'
#' ####################  AssignmentUpdate  ####################
#'
#' library(openapi)
#' var_account_id <- 56 # integer | the user account id
#' var_assignment_id <- 56 # integer | the assignment id
#' var_name <- "name_example" # character | the name of the assignment (Optional)
#' var_description <- "description_example" # character | the description of the assignment (Optional)
#' var_assignee_account_id <- 56 # integer | the account id to assign to (Optional)
#' var_retailer_location_id <- 56 # integer | the retailer location id (Optional)
#' var_tags <- "tags_example" # character | the tags (Optional)
#' var_active <- "active_example" # character | determines whether the assignment is active or inactive (Optional)
#'
#' #Update Assignment
#' api_instance <- AssignmentApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$AssignmentUpdate(var_account_id, var_assignment_id, name = var_name, description = var_description, assignee_account_id = var_assignee_account_id, retailer_location_id = var_retailer_location_id, tags = var_tags, active = var_activedata_file = "result.txt")
#' result <- api_instance$AssignmentUpdate(var_account_id, var_assignment_id, name = var_name, description = var_description, assignee_account_id = var_assignee_account_id, retailer_location_id = var_retailer_location_id, tags = var_tags, active = var_active)
#' dput(result)
#'
#'
#' }
#' @importFrom R6 R6Class
#' @importFrom base64enc base64encode
#' @export
AssignmentApi <- R6::R6Class(
  "AssignmentApi",
  public = list(
    api_client = NULL,

    #' @description
    #' Initialize a new AssignmentApi.
    #'
    #' @param api_client An instance of API client.
    initialize = function(api_client) {
      if (!missing(api_client)) {
        self$api_client <- api_client
      } else {
        self$api_client <- ApiClient$new()
      }
    },

    #' @description
    #' Search Assignment Assignees
    #'
    #' @param account_id The account id sending the request
    #' @param keyword (optional) The keyword to filter the returned results
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return array[AccountMiniResponse]
    AssigmentAssigneeAccountSearch = function(account_id, keyword = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$AssigmentAssigneeAccountSearchWithHttpInfo(account_id, keyword, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Search Assignment Assignees
    #'
    #' @param account_id The account id sending the request
    #' @param keyword (optional) The keyword to filter the returned results
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (array[AccountMiniResponse]) with additional information such as HTTP status code, headers
    AssigmentAssigneeAccountSearchWithHttpInfo = function(account_id, keyword = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling AssignmentApi$AssigmentAssigneeAccountSearch, `account_id` is not nullable")
      }

      if (!missing(`keyword`) && is.null(`keyword`)) {
        stop("Invalid value for `keyword` when calling AssignmentApi$AssigmentAssigneeAccountSearch, `keyword` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["keyword"]] <- `keyword`

      local_var_url_path <- "/assignment/assignee/search"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "array[AccountMiniResponse]"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Create Assignment
    #'
    #' @param account_id the user account id
    #' @param name the name for the assignment
    #' @param assignee_account_id the account id to assign to
    #' @param description (optional) the desciprtion for the assignment
    #' @param retailer_location_id (optional) the retailer location id
    #' @param tags (optional) the tags
    #' @param active (optional) determines whether the assignment is active or inactive
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return AssignmentResponse
    AssignmentCreate = function(account_id, name, assignee_account_id, description = NULL, retailer_location_id = NULL, tags = NULL, active = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$AssignmentCreateWithHttpInfo(account_id, name, assignee_account_id, description, retailer_location_id, tags, active, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Create Assignment
    #'
    #' @param account_id the user account id
    #' @param name the name for the assignment
    #' @param assignee_account_id the account id to assign to
    #' @param description (optional) the desciprtion for the assignment
    #' @param retailer_location_id (optional) the retailer location id
    #' @param tags (optional) the tags
    #' @param active (optional) determines whether the assignment is active or inactive
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (AssignmentResponse) with additional information such as HTTP status code, headers
    AssignmentCreateWithHttpInfo = function(account_id, name, assignee_account_id, description = NULL, retailer_location_id = NULL, tags = NULL, active = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (missing(`name`)) {
        stop("Missing required parameter `name`.")
      }

      if (missing(`assignee_account_id`)) {
        stop("Missing required parameter `assignee_account_id`.")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling AssignmentApi$AssignmentCreate, `account_id` is not nullable")
      }

      if (!missing(`name`) && is.null(`name`)) {
        stop("Invalid value for `name` when calling AssignmentApi$AssignmentCreate, `name` is not nullable")
      }

      if (!missing(`assignee_account_id`) && is.null(`assignee_account_id`)) {
        stop("Invalid value for `assignee_account_id` when calling AssignmentApi$AssignmentCreate, `assignee_account_id` is not nullable")
      }

      if (!missing(`description`) && is.null(`description`)) {
        stop("Invalid value for `description` when calling AssignmentApi$AssignmentCreate, `description` is not nullable")
      }

      if (!missing(`retailer_location_id`) && is.null(`retailer_location_id`)) {
        stop("Invalid value for `retailer_location_id` when calling AssignmentApi$AssignmentCreate, `retailer_location_id` is not nullable")
      }

      if (!missing(`tags`) && is.null(`tags`)) {
        stop("Invalid value for `tags` when calling AssignmentApi$AssignmentCreate, `tags` is not nullable")
      }

      if (!missing(`active`) && is.null(`active`)) {
        stop("Invalid value for `active` when calling AssignmentApi$AssignmentCreate, `active` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["name"]] <- `name`

      query_params[["description"]] <- `description`

      query_params[["assigneeAccountId"]] <- `assignee_account_id`

      query_params[["retailerLocationId"]] <- `retailer_location_id`

      query_params[["tags"]] <- `tags`

      query_params[["active"]] <- `active`

      local_var_url_path <- "/assignment/create"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "AssignmentResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Delete Assignment
    #'
    #' @param account_id the user account id
    #' @param assignment_id the assignment id
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return SirqulResponse
    AssignmentDelete = function(account_id, assignment_id, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$AssignmentDeleteWithHttpInfo(account_id, assignment_id, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Delete Assignment
    #'
    #' @param account_id the user account id
    #' @param assignment_id the assignment id
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (SirqulResponse) with additional information such as HTTP status code, headers
    AssignmentDeleteWithHttpInfo = function(account_id, assignment_id, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (missing(`assignment_id`)) {
        stop("Missing required parameter `assignment_id`.")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling AssignmentApi$AssignmentDelete, `account_id` is not nullable")
      }

      if (!missing(`assignment_id`) && is.null(`assignment_id`)) {
        stop("Invalid value for `assignment_id` when calling AssignmentApi$AssignmentDelete, `assignment_id` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["assignmentId"]] <- `assignment_id`

      local_var_url_path <- "/assignment/delete"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "SirqulResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Get Assignment
    #'
    #' @param account_id the user account id
    #' @param assignment_id the assignment id
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return AssignmentResponse
    AssignmentGet = function(account_id, assignment_id, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$AssignmentGetWithHttpInfo(account_id, assignment_id, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Get Assignment
    #'
    #' @param account_id the user account id
    #' @param assignment_id the assignment id
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (AssignmentResponse) with additional information such as HTTP status code, headers
    AssignmentGetWithHttpInfo = function(account_id, assignment_id, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (missing(`assignment_id`)) {
        stop("Missing required parameter `assignment_id`.")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling AssignmentApi$AssignmentGet, `account_id` is not nullable")
      }

      if (!missing(`assignment_id`) && is.null(`assignment_id`)) {
        stop("Invalid value for `assignment_id` when calling AssignmentApi$AssignmentGet, `assignment_id` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["assignmentId"]] <- `assignment_id`

      local_var_url_path <- "/assignment/get"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "AssignmentResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Search Assignments
    #'
    #' @param account_id the account sending the request
    #' @param sort_field sort by table field
    #' @param descending return results in descending order or not
    #' @param active_only return active results only or not
    #' @param start The record to begin the return set on
    #' @param limit The number of records to return
    #' @param creator_account_id (optional) the creator of the assignment
    #' @param assignee_account_ids (optional) filter results by assignee accounts. If not provided, all assignments that are assigned to accounts that are managed by the requested account will be returned.
    #' @param retailer_location_ids (optional) filter results by retailer locations
    #' @param current_status_type (optional) filter results by assignment status
    #' @param keyword (optional) filter results by keyword search that matches the assignee, creator, or retailer location name
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return array[AssignmentResponse]
    AssignmentSearch = function(account_id, sort_field, descending, active_only, start, limit, creator_account_id = NULL, assignee_account_ids = NULL, retailer_location_ids = NULL, current_status_type = NULL, keyword = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$AssignmentSearchWithHttpInfo(account_id, sort_field, descending, active_only, start, limit, creator_account_id, assignee_account_ids, retailer_location_ids, current_status_type, keyword, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Search Assignments
    #'
    #' @param account_id the account sending the request
    #' @param sort_field sort by table field
    #' @param descending return results in descending order or not
    #' @param active_only return active results only or not
    #' @param start The record to begin the return set on
    #' @param limit The number of records to return
    #' @param creator_account_id (optional) the creator of the assignment
    #' @param assignee_account_ids (optional) filter results by assignee accounts. If not provided, all assignments that are assigned to accounts that are managed by the requested account will be returned.
    #' @param retailer_location_ids (optional) filter results by retailer locations
    #' @param current_status_type (optional) filter results by assignment status
    #' @param keyword (optional) filter results by keyword search that matches the assignee, creator, or retailer location name
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (array[AssignmentResponse]) with additional information such as HTTP status code, headers
    AssignmentSearchWithHttpInfo = function(account_id, sort_field, descending, active_only, start, limit, creator_account_id = NULL, assignee_account_ids = NULL, retailer_location_ids = NULL, current_status_type = NULL, keyword = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (missing(`sort_field`)) {
        stop("Missing required parameter `sort_field`.")
      }

      if (missing(`descending`)) {
        stop("Missing required parameter `descending`.")
      }

      if (missing(`active_only`)) {
        stop("Missing required parameter `active_only`.")
      }

      if (missing(`start`)) {
        stop("Missing required parameter `start`.")
      }

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling AssignmentApi$AssignmentSearch, `account_id` is not nullable")
      }

      if (!missing(`sort_field`) && is.null(`sort_field`)) {
        stop("Invalid value for `sort_field` when calling AssignmentApi$AssignmentSearch, `sort_field` is not nullable")
      }

      if (!missing(`descending`) && is.null(`descending`)) {
        stop("Invalid value for `descending` when calling AssignmentApi$AssignmentSearch, `descending` is not nullable")
      }

      if (!missing(`active_only`) && is.null(`active_only`)) {
        stop("Invalid value for `active_only` when calling AssignmentApi$AssignmentSearch, `active_only` is not nullable")
      }

      if (!missing(`start`) && is.null(`start`)) {
        stop("Invalid value for `start` when calling AssignmentApi$AssignmentSearch, `start` is not nullable")
      }

      if (!missing(`limit`) && is.null(`limit`)) {
        stop("Invalid value for `limit` when calling AssignmentApi$AssignmentSearch, `limit` is not nullable")
      }

      if (!missing(`creator_account_id`) && is.null(`creator_account_id`)) {
        stop("Invalid value for `creator_account_id` when calling AssignmentApi$AssignmentSearch, `creator_account_id` is not nullable")
      }

      if (!missing(`assignee_account_ids`) && is.null(`assignee_account_ids`)) {
        stop("Invalid value for `assignee_account_ids` when calling AssignmentApi$AssignmentSearch, `assignee_account_ids` is not nullable")
      }

      if (!missing(`retailer_location_ids`) && is.null(`retailer_location_ids`)) {
        stop("Invalid value for `retailer_location_ids` when calling AssignmentApi$AssignmentSearch, `retailer_location_ids` is not nullable")
      }

      if (!missing(`current_status_type`) && is.null(`current_status_type`)) {
        stop("Invalid value for `current_status_type` when calling AssignmentApi$AssignmentSearch, `current_status_type` is not nullable")
      }

      if (!missing(`keyword`) && is.null(`keyword`)) {
        stop("Invalid value for `keyword` when calling AssignmentApi$AssignmentSearch, `keyword` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["creatorAccountId"]] <- `creator_account_id`

      query_params[["assigneeAccountIds"]] <- `assignee_account_ids`

      query_params[["retailerLocationIds"]] <- `retailer_location_ids`

      if (!is.null(`current_status_type`) && !(`current_status_type` %in% c("NEW", "IN_PROGRESS", "SUBSCRIBED", "ARCHIVED"))) {
        stop("Invalid value for current_status_type when calling AssignmentApi$AssignmentSearch. Must be [NEW, IN_PROGRESS, SUBSCRIBED, ARCHIVED].")
      }
      query_params[["currentStatusType"]] <- `current_status_type`

      query_params[["keyword"]] <- `keyword`

      if (!is.null(`sort_field`) && !(`sort_field` %in% c("ID", "CREATED", "UPDATED", "DELETED", "SEARCH_TAGS", "ACTIVE", "ASSIGNEE_ID", "CREATOR_ID", "LOCATION_ID", "LOCATION_NAME", "CURRENT_STATUS", "CURRENT_STATUS_TYPE", "STATUSES"))) {
        stop("Invalid value for sort_field when calling AssignmentApi$AssignmentSearch. Must be [ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, ASSIGNEE_ID, CREATOR_ID, LOCATION_ID, LOCATION_NAME, CURRENT_STATUS, CURRENT_STATUS_TYPE, STATUSES].")
      }
      query_params[["sortField"]] <- `sort_field`

      query_params[["descending"]] <- `descending`

      query_params[["activeOnly"]] <- `active_only`

      query_params[["start"]] <- `start`

      query_params[["limit"]] <- `limit`

      local_var_url_path <- "/assignment/search"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "array[AssignmentResponse]"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Create Assignment Status
    #'
    #' @param account_id the user account id
    #' @param assignment_id the assignment id
    #' @param scheduled_notification_id (optional) the scheduled notification id for reminders
    #' @param to_do (optional) the type of to do. Possible values include: SITE_VISIT, PHONE, RECONTACT, RENEWAL, CREDIT
    #' @param connection (optional) the connection type. Possible values include: INITIAL, FOLLOW_UP, DECLINED
    #' @param method (optional) the communication method type. Possible values include: PHONE, SITE_VISIT, EMAIL
    #' @param status (optional) the status type. Possible values include: ARCHIVED, SUBSCRIBED, UNSUBSCRIBED, CONTACTED, DECLINED, NOT_CONTACTED
    #' @param closure (optional) the closure type. Possible values include: PHONE, SITE_VISIT, PHONE_SITE, WEB
    #' @param message (optional) the message from the assignee
    #' @param follow_up (optional) the date to follow up by
    #' @param active (optional) determines whether the assignment status is active or inactive
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return AssignmentStatusResponse
    AssignmentStatusCreate = function(account_id, assignment_id, scheduled_notification_id = NULL, to_do = NULL, connection = NULL, method = NULL, status = NULL, closure = NULL, message = NULL, follow_up = NULL, active = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$AssignmentStatusCreateWithHttpInfo(account_id, assignment_id, scheduled_notification_id, to_do, connection, method, status, closure, message, follow_up, active, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Create Assignment Status
    #'
    #' @param account_id the user account id
    #' @param assignment_id the assignment id
    #' @param scheduled_notification_id (optional) the scheduled notification id for reminders
    #' @param to_do (optional) the type of to do. Possible values include: SITE_VISIT, PHONE, RECONTACT, RENEWAL, CREDIT
    #' @param connection (optional) the connection type. Possible values include: INITIAL, FOLLOW_UP, DECLINED
    #' @param method (optional) the communication method type. Possible values include: PHONE, SITE_VISIT, EMAIL
    #' @param status (optional) the status type. Possible values include: ARCHIVED, SUBSCRIBED, UNSUBSCRIBED, CONTACTED, DECLINED, NOT_CONTACTED
    #' @param closure (optional) the closure type. Possible values include: PHONE, SITE_VISIT, PHONE_SITE, WEB
    #' @param message (optional) the message from the assignee
    #' @param follow_up (optional) the date to follow up by
    #' @param active (optional) determines whether the assignment status is active or inactive
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (AssignmentStatusResponse) with additional information such as HTTP status code, headers
    AssignmentStatusCreateWithHttpInfo = function(account_id, assignment_id, scheduled_notification_id = NULL, to_do = NULL, connection = NULL, method = NULL, status = NULL, closure = NULL, message = NULL, follow_up = NULL, active = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (missing(`assignment_id`)) {
        stop("Missing required parameter `assignment_id`.")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling AssignmentApi$AssignmentStatusCreate, `account_id` is not nullable")
      }

      if (!missing(`assignment_id`) && is.null(`assignment_id`)) {
        stop("Invalid value for `assignment_id` when calling AssignmentApi$AssignmentStatusCreate, `assignment_id` is not nullable")
      }

      if (!missing(`scheduled_notification_id`) && is.null(`scheduled_notification_id`)) {
        stop("Invalid value for `scheduled_notification_id` when calling AssignmentApi$AssignmentStatusCreate, `scheduled_notification_id` is not nullable")
      }

      if (!missing(`to_do`) && is.null(`to_do`)) {
        stop("Invalid value for `to_do` when calling AssignmentApi$AssignmentStatusCreate, `to_do` is not nullable")
      }

      if (!missing(`connection`) && is.null(`connection`)) {
        stop("Invalid value for `connection` when calling AssignmentApi$AssignmentStatusCreate, `connection` is not nullable")
      }

      if (!missing(`method`) && is.null(`method`)) {
        stop("Invalid value for `method` when calling AssignmentApi$AssignmentStatusCreate, `method` is not nullable")
      }

      if (!missing(`status`) && is.null(`status`)) {
        stop("Invalid value for `status` when calling AssignmentApi$AssignmentStatusCreate, `status` is not nullable")
      }

      if (!missing(`closure`) && is.null(`closure`)) {
        stop("Invalid value for `closure` when calling AssignmentApi$AssignmentStatusCreate, `closure` is not nullable")
      }

      if (!missing(`message`) && is.null(`message`)) {
        stop("Invalid value for `message` when calling AssignmentApi$AssignmentStatusCreate, `message` is not nullable")
      }

      if (!missing(`follow_up`) && is.null(`follow_up`)) {
        stop("Invalid value for `follow_up` when calling AssignmentApi$AssignmentStatusCreate, `follow_up` is not nullable")
      }

      if (!missing(`active`) && is.null(`active`)) {
        stop("Invalid value for `active` when calling AssignmentApi$AssignmentStatusCreate, `active` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["assignmentId"]] <- `assignment_id`

      query_params[["scheduledNotificationId"]] <- `scheduled_notification_id`

      if (!is.null(`to_do`) && !(`to_do` %in% c("SITE_VISIT", "PHONE", "RECONTACT", "RENEWAL", "CREDIT"))) {
        stop("Invalid value for to_do when calling AssignmentApi$AssignmentStatusCreate. Must be [SITE_VISIT, PHONE, RECONTACT, RENEWAL, CREDIT].")
      }
      query_params[["toDo"]] <- `to_do`

      if (!is.null(`connection`) && !(`connection` %in% c("INITIAL", "FOLLOW_UP", "DECLINED"))) {
        stop("Invalid value for connection when calling AssignmentApi$AssignmentStatusCreate. Must be [INITIAL, FOLLOW_UP, DECLINED].")
      }
      query_params[["connection"]] <- `connection`

      if (!is.null(`method`) && !(`method` %in% c("PHONE", "SITE_VISIT", "EMAIL"))) {
        stop("Invalid value for method when calling AssignmentApi$AssignmentStatusCreate. Must be [PHONE, SITE_VISIT, EMAIL].")
      }
      query_params[["method"]] <- `method`

      if (!is.null(`status`) && !(`status` %in% c("ARCHIVED", "SUBSCRIBED", "UNSUBSCRIBED", "CONTACTED", "DECLINED", "NOT_CONTACTED"))) {
        stop("Invalid value for status when calling AssignmentApi$AssignmentStatusCreate. Must be [ARCHIVED, SUBSCRIBED, UNSUBSCRIBED, CONTACTED, DECLINED, NOT_CONTACTED].")
      }
      query_params[["status"]] <- `status`

      if (!is.null(`closure`) && !(`closure` %in% c("PHONE", "SITE_VISIT", "PHONE_SITE", "WEB"))) {
        stop("Invalid value for closure when calling AssignmentApi$AssignmentStatusCreate. Must be [PHONE, SITE_VISIT, PHONE_SITE, WEB].")
      }
      query_params[["closure"]] <- `closure`

      query_params[["message"]] <- `message`

      query_params[["followUp"]] <- `follow_up`

      query_params[["active"]] <- `active`

      local_var_url_path <- "/assignment/status/create"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "AssignmentStatusResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Deletes Assignment Status
    #'
    #' @param account_id the user account id
    #' @param assignment_status_id the assignment status id
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return SirqulResponse
    AssignmentStatusDelete = function(account_id, assignment_status_id, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$AssignmentStatusDeleteWithHttpInfo(account_id, assignment_status_id, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Deletes Assignment Status
    #'
    #' @param account_id the user account id
    #' @param assignment_status_id the assignment status id
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (SirqulResponse) with additional information such as HTTP status code, headers
    AssignmentStatusDeleteWithHttpInfo = function(account_id, assignment_status_id, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (missing(`assignment_status_id`)) {
        stop("Missing required parameter `assignment_status_id`.")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling AssignmentApi$AssignmentStatusDelete, `account_id` is not nullable")
      }

      if (!missing(`assignment_status_id`) && is.null(`assignment_status_id`)) {
        stop("Invalid value for `assignment_status_id` when calling AssignmentApi$AssignmentStatusDelete, `assignment_status_id` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["assignmentStatusId"]] <- `assignment_status_id`

      local_var_url_path <- "/assignment/status/delete"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "SirqulResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Get Assignment Status
    #'
    #' @param account_id the user account id
    #' @param assignment_status_id the assignment status id
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return AssignmentStatusResponse
    AssignmentStatusGet = function(account_id, assignment_status_id, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$AssignmentStatusGetWithHttpInfo(account_id, assignment_status_id, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Get Assignment Status
    #'
    #' @param account_id the user account id
    #' @param assignment_status_id the assignment status id
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (AssignmentStatusResponse) with additional information such as HTTP status code, headers
    AssignmentStatusGetWithHttpInfo = function(account_id, assignment_status_id, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (missing(`assignment_status_id`)) {
        stop("Missing required parameter `assignment_status_id`.")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling AssignmentApi$AssignmentStatusGet, `account_id` is not nullable")
      }

      if (!missing(`assignment_status_id`) && is.null(`assignment_status_id`)) {
        stop("Invalid value for `assignment_status_id` when calling AssignmentApi$AssignmentStatusGet, `assignment_status_id` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["assignmentStatusId"]] <- `assignment_status_id`

      local_var_url_path <- "/assignment/status/get"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "AssignmentStatusResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Search Assignment Statuses
    #'
    #' @param account_id the user account id
    #' @param sort_field the field to sort by. Possible values include: ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, CURRENT_STATUS, TODO, CONNECTION, METHOD, STATUS, CLOSURE, MESSAGE, FOLLOW_UP
    #' @param descending determines whether the sorted list is in descending or ascending order
    #' @param active_only determines whether to only return active results
    #' @param start the start index for pagination
    #' @param limit the limit for pagination
    #' @param assignment_id (optional) the assignment id
    #' @param creator_account_id (optional) filter results by the account who created the status
    #' @param assignee_account_id (optional) filter results by the assignee account
    #' @param retailer_location_id (optional) filter results by by retailer location
    #' @param status_type (optional) filter results by the status type
    #' @param keyword (optional) filter results by keyword search
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return array[AssignmentStatusResponse]
    AssignmentStatusSearch = function(account_id, sort_field, descending, active_only, start, limit, assignment_id = NULL, creator_account_id = NULL, assignee_account_id = NULL, retailer_location_id = NULL, status_type = NULL, keyword = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$AssignmentStatusSearchWithHttpInfo(account_id, sort_field, descending, active_only, start, limit, assignment_id, creator_account_id, assignee_account_id, retailer_location_id, status_type, keyword, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Search Assignment Statuses
    #'
    #' @param account_id the user account id
    #' @param sort_field the field to sort by. Possible values include: ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, CURRENT_STATUS, TODO, CONNECTION, METHOD, STATUS, CLOSURE, MESSAGE, FOLLOW_UP
    #' @param descending determines whether the sorted list is in descending or ascending order
    #' @param active_only determines whether to only return active results
    #' @param start the start index for pagination
    #' @param limit the limit for pagination
    #' @param assignment_id (optional) the assignment id
    #' @param creator_account_id (optional) filter results by the account who created the status
    #' @param assignee_account_id (optional) filter results by the assignee account
    #' @param retailer_location_id (optional) filter results by by retailer location
    #' @param status_type (optional) filter results by the status type
    #' @param keyword (optional) filter results by keyword search
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (array[AssignmentStatusResponse]) with additional information such as HTTP status code, headers
    AssignmentStatusSearchWithHttpInfo = function(account_id, sort_field, descending, active_only, start, limit, assignment_id = NULL, creator_account_id = NULL, assignee_account_id = NULL, retailer_location_id = NULL, status_type = NULL, keyword = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (missing(`sort_field`)) {
        stop("Missing required parameter `sort_field`.")
      }

      if (missing(`descending`)) {
        stop("Missing required parameter `descending`.")
      }

      if (missing(`active_only`)) {
        stop("Missing required parameter `active_only`.")
      }

      if (missing(`start`)) {
        stop("Missing required parameter `start`.")
      }

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling AssignmentApi$AssignmentStatusSearch, `account_id` is not nullable")
      }

      if (!missing(`sort_field`) && is.null(`sort_field`)) {
        stop("Invalid value for `sort_field` when calling AssignmentApi$AssignmentStatusSearch, `sort_field` is not nullable")
      }

      if (!missing(`descending`) && is.null(`descending`)) {
        stop("Invalid value for `descending` when calling AssignmentApi$AssignmentStatusSearch, `descending` is not nullable")
      }

      if (!missing(`active_only`) && is.null(`active_only`)) {
        stop("Invalid value for `active_only` when calling AssignmentApi$AssignmentStatusSearch, `active_only` is not nullable")
      }

      if (!missing(`start`) && is.null(`start`)) {
        stop("Invalid value for `start` when calling AssignmentApi$AssignmentStatusSearch, `start` is not nullable")
      }

      if (!missing(`limit`) && is.null(`limit`)) {
        stop("Invalid value for `limit` when calling AssignmentApi$AssignmentStatusSearch, `limit` is not nullable")
      }

      if (!missing(`assignment_id`) && is.null(`assignment_id`)) {
        stop("Invalid value for `assignment_id` when calling AssignmentApi$AssignmentStatusSearch, `assignment_id` is not nullable")
      }

      if (!missing(`creator_account_id`) && is.null(`creator_account_id`)) {
        stop("Invalid value for `creator_account_id` when calling AssignmentApi$AssignmentStatusSearch, `creator_account_id` is not nullable")
      }

      if (!missing(`assignee_account_id`) && is.null(`assignee_account_id`)) {
        stop("Invalid value for `assignee_account_id` when calling AssignmentApi$AssignmentStatusSearch, `assignee_account_id` is not nullable")
      }

      if (!missing(`retailer_location_id`) && is.null(`retailer_location_id`)) {
        stop("Invalid value for `retailer_location_id` when calling AssignmentApi$AssignmentStatusSearch, `retailer_location_id` is not nullable")
      }

      if (!missing(`status_type`) && is.null(`status_type`)) {
        stop("Invalid value for `status_type` when calling AssignmentApi$AssignmentStatusSearch, `status_type` is not nullable")
      }

      if (!missing(`keyword`) && is.null(`keyword`)) {
        stop("Invalid value for `keyword` when calling AssignmentApi$AssignmentStatusSearch, `keyword` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["assignmentId"]] <- `assignment_id`

      query_params[["creatorAccountId"]] <- `creator_account_id`

      query_params[["assigneeAccountId"]] <- `assignee_account_id`

      query_params[["retailerLocationId"]] <- `retailer_location_id`

      if (!is.null(`status_type`) && !(`status_type` %in% c("ARCHIVED", "SUBSCRIBED", "UNSUBSCRIBED", "CONTACTED", "DECLINED", "NOT_CONTACTED"))) {
        stop("Invalid value for status_type when calling AssignmentApi$AssignmentStatusSearch. Must be [ARCHIVED, SUBSCRIBED, UNSUBSCRIBED, CONTACTED, DECLINED, NOT_CONTACTED].")
      }
      query_params[["statusType"]] <- `status_type`

      query_params[["keyword"]] <- `keyword`

      if (!is.null(`sort_field`) && !(`sort_field` %in% c("ID", "CREATED", "UPDATED", "DELETED", "SEARCH_TAGS", "ACTIVE", "ASSIGNEE_ID", "CREATOR_ID", "LOCATION_ID", "LOCATION_NAME", "CURRENT_STATUS", "CURRENT_STATUS_TYPE", "TODO", "CONNECTION", "METHOD", "STATUS", "CLOSURE", "MESSAGE", "FOLLOW_UP"))) {
        stop("Invalid value for sort_field when calling AssignmentApi$AssignmentStatusSearch. Must be [ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, ASSIGNEE_ID, CREATOR_ID, LOCATION_ID, LOCATION_NAME, CURRENT_STATUS, CURRENT_STATUS_TYPE, TODO, CONNECTION, METHOD, STATUS, CLOSURE, MESSAGE, FOLLOW_UP].")
      }
      query_params[["sortField"]] <- `sort_field`

      query_params[["descending"]] <- `descending`

      query_params[["activeOnly"]] <- `active_only`

      query_params[["start"]] <- `start`

      query_params[["limit"]] <- `limit`

      local_var_url_path <- "/assignment/status/search"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "array[AssignmentStatusResponse]"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Update Assignment Status
    #'
    #' @param account_id the user account id
    #' @param assignment_status_id the assignment status id
    #' @param scheduled_notification_id (optional) the scheduled notification id for reminders
    #' @param to_do (optional) the type of to do. Possible values include: SITE_VISIT, PHONE, RECONTACT, RENEWAL, CREDIT
    #' @param connection (optional) the connection type. Possible values include: INITIAL, FOLLOW_UP, DECLINED
    #' @param method (optional) the communication method type. Possible values include: PHONE, SITE_VISIT, EMAIL
    #' @param status (optional) the status type. Possible values include: ARCHIVED, SUBSCRIBED, UNSUBSCRIBED, CONTACTED, DECLINED, NOT_CONTACTED
    #' @param closure (optional) the closure type. Possible values include: PHONE, SITE_VISIT, PHONE_SITE, WEB
    #' @param message (optional) the message from the assignee
    #' @param follow_up (optional) the date to follow up by
    #' @param active (optional) determines whether the assignment status is active or inactive
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return AssignmentStatusResponse
    AssignmentStatusUpdate = function(account_id, assignment_status_id, scheduled_notification_id = NULL, to_do = NULL, connection = NULL, method = NULL, status = NULL, closure = NULL, message = NULL, follow_up = NULL, active = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$AssignmentStatusUpdateWithHttpInfo(account_id, assignment_status_id, scheduled_notification_id, to_do, connection, method, status, closure, message, follow_up, active, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Update Assignment Status
    #'
    #' @param account_id the user account id
    #' @param assignment_status_id the assignment status id
    #' @param scheduled_notification_id (optional) the scheduled notification id for reminders
    #' @param to_do (optional) the type of to do. Possible values include: SITE_VISIT, PHONE, RECONTACT, RENEWAL, CREDIT
    #' @param connection (optional) the connection type. Possible values include: INITIAL, FOLLOW_UP, DECLINED
    #' @param method (optional) the communication method type. Possible values include: PHONE, SITE_VISIT, EMAIL
    #' @param status (optional) the status type. Possible values include: ARCHIVED, SUBSCRIBED, UNSUBSCRIBED, CONTACTED, DECLINED, NOT_CONTACTED
    #' @param closure (optional) the closure type. Possible values include: PHONE, SITE_VISIT, PHONE_SITE, WEB
    #' @param message (optional) the message from the assignee
    #' @param follow_up (optional) the date to follow up by
    #' @param active (optional) determines whether the assignment status is active or inactive
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (AssignmentStatusResponse) with additional information such as HTTP status code, headers
    AssignmentStatusUpdateWithHttpInfo = function(account_id, assignment_status_id, scheduled_notification_id = NULL, to_do = NULL, connection = NULL, method = NULL, status = NULL, closure = NULL, message = NULL, follow_up = NULL, active = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (missing(`assignment_status_id`)) {
        stop("Missing required parameter `assignment_status_id`.")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling AssignmentApi$AssignmentStatusUpdate, `account_id` is not nullable")
      }

      if (!missing(`assignment_status_id`) && is.null(`assignment_status_id`)) {
        stop("Invalid value for `assignment_status_id` when calling AssignmentApi$AssignmentStatusUpdate, `assignment_status_id` is not nullable")
      }

      if (!missing(`scheduled_notification_id`) && is.null(`scheduled_notification_id`)) {
        stop("Invalid value for `scheduled_notification_id` when calling AssignmentApi$AssignmentStatusUpdate, `scheduled_notification_id` is not nullable")
      }

      if (!missing(`to_do`) && is.null(`to_do`)) {
        stop("Invalid value for `to_do` when calling AssignmentApi$AssignmentStatusUpdate, `to_do` is not nullable")
      }

      if (!missing(`connection`) && is.null(`connection`)) {
        stop("Invalid value for `connection` when calling AssignmentApi$AssignmentStatusUpdate, `connection` is not nullable")
      }

      if (!missing(`method`) && is.null(`method`)) {
        stop("Invalid value for `method` when calling AssignmentApi$AssignmentStatusUpdate, `method` is not nullable")
      }

      if (!missing(`status`) && is.null(`status`)) {
        stop("Invalid value for `status` when calling AssignmentApi$AssignmentStatusUpdate, `status` is not nullable")
      }

      if (!missing(`closure`) && is.null(`closure`)) {
        stop("Invalid value for `closure` when calling AssignmentApi$AssignmentStatusUpdate, `closure` is not nullable")
      }

      if (!missing(`message`) && is.null(`message`)) {
        stop("Invalid value for `message` when calling AssignmentApi$AssignmentStatusUpdate, `message` is not nullable")
      }

      if (!missing(`follow_up`) && is.null(`follow_up`)) {
        stop("Invalid value for `follow_up` when calling AssignmentApi$AssignmentStatusUpdate, `follow_up` is not nullable")
      }

      if (!missing(`active`) && is.null(`active`)) {
        stop("Invalid value for `active` when calling AssignmentApi$AssignmentStatusUpdate, `active` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["assignmentStatusId"]] <- `assignment_status_id`

      query_params[["scheduledNotificationId"]] <- `scheduled_notification_id`

      if (!is.null(`to_do`) && !(`to_do` %in% c("SITE_VISIT", "PHONE", "RECONTACT", "RENEWAL", "CREDIT"))) {
        stop("Invalid value for to_do when calling AssignmentApi$AssignmentStatusUpdate. Must be [SITE_VISIT, PHONE, RECONTACT, RENEWAL, CREDIT].")
      }
      query_params[["toDo"]] <- `to_do`

      if (!is.null(`connection`) && !(`connection` %in% c("INITIAL", "FOLLOW_UP", "DECLINED"))) {
        stop("Invalid value for connection when calling AssignmentApi$AssignmentStatusUpdate. Must be [INITIAL, FOLLOW_UP, DECLINED].")
      }
      query_params[["connection"]] <- `connection`

      if (!is.null(`method`) && !(`method` %in% c("PHONE", "SITE_VISIT", "EMAIL"))) {
        stop("Invalid value for method when calling AssignmentApi$AssignmentStatusUpdate. Must be [PHONE, SITE_VISIT, EMAIL].")
      }
      query_params[["method"]] <- `method`

      if (!is.null(`status`) && !(`status` %in% c("ARCHIVED", "SUBSCRIBED", "UNSUBSCRIBED", "CONTACTED", "DECLINED", "NOT_CONTACTED"))) {
        stop("Invalid value for status when calling AssignmentApi$AssignmentStatusUpdate. Must be [ARCHIVED, SUBSCRIBED, UNSUBSCRIBED, CONTACTED, DECLINED, NOT_CONTACTED].")
      }
      query_params[["status"]] <- `status`

      if (!is.null(`closure`) && !(`closure` %in% c("PHONE", "SITE_VISIT", "PHONE_SITE", "WEB"))) {
        stop("Invalid value for closure when calling AssignmentApi$AssignmentStatusUpdate. Must be [PHONE, SITE_VISIT, PHONE_SITE, WEB].")
      }
      query_params[["closure"]] <- `closure`

      query_params[["message"]] <- `message`

      query_params[["followUp"]] <- `follow_up`

      query_params[["active"]] <- `active`

      local_var_url_path <- "/assignment/status/update"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "AssignmentStatusResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Update Assignment
    #'
    #' @param account_id the user account id
    #' @param assignment_id the assignment id
    #' @param name (optional) the name of the assignment
    #' @param description (optional) the description of the assignment
    #' @param assignee_account_id (optional) the account id to assign to
    #' @param retailer_location_id (optional) the retailer location id
    #' @param tags (optional) the tags
    #' @param active (optional) determines whether the assignment is active or inactive
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return AssignmentResponse
    AssignmentUpdate = function(account_id, assignment_id, name = NULL, description = NULL, assignee_account_id = NULL, retailer_location_id = NULL, tags = NULL, active = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$AssignmentUpdateWithHttpInfo(account_id, assignment_id, name, description, assignee_account_id, retailer_location_id, tags, active, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Update Assignment
    #'
    #' @param account_id the user account id
    #' @param assignment_id the assignment id
    #' @param name (optional) the name of the assignment
    #' @param description (optional) the description of the assignment
    #' @param assignee_account_id (optional) the account id to assign to
    #' @param retailer_location_id (optional) the retailer location id
    #' @param tags (optional) the tags
    #' @param active (optional) determines whether the assignment is active or inactive
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (AssignmentResponse) with additional information such as HTTP status code, headers
    AssignmentUpdateWithHttpInfo = function(account_id, assignment_id, name = NULL, description = NULL, assignee_account_id = NULL, retailer_location_id = NULL, tags = NULL, active = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (missing(`assignment_id`)) {
        stop("Missing required parameter `assignment_id`.")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling AssignmentApi$AssignmentUpdate, `account_id` is not nullable")
      }

      if (!missing(`assignment_id`) && is.null(`assignment_id`)) {
        stop("Invalid value for `assignment_id` when calling AssignmentApi$AssignmentUpdate, `assignment_id` is not nullable")
      }

      if (!missing(`name`) && is.null(`name`)) {
        stop("Invalid value for `name` when calling AssignmentApi$AssignmentUpdate, `name` is not nullable")
      }

      if (!missing(`description`) && is.null(`description`)) {
        stop("Invalid value for `description` when calling AssignmentApi$AssignmentUpdate, `description` is not nullable")
      }

      if (!missing(`assignee_account_id`) && is.null(`assignee_account_id`)) {
        stop("Invalid value for `assignee_account_id` when calling AssignmentApi$AssignmentUpdate, `assignee_account_id` is not nullable")
      }

      if (!missing(`retailer_location_id`) && is.null(`retailer_location_id`)) {
        stop("Invalid value for `retailer_location_id` when calling AssignmentApi$AssignmentUpdate, `retailer_location_id` is not nullable")
      }

      if (!missing(`tags`) && is.null(`tags`)) {
        stop("Invalid value for `tags` when calling AssignmentApi$AssignmentUpdate, `tags` is not nullable")
      }

      if (!missing(`active`) && is.null(`active`)) {
        stop("Invalid value for `active` when calling AssignmentApi$AssignmentUpdate, `active` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["assignmentId"]] <- `assignment_id`

      query_params[["name"]] <- `name`

      query_params[["description"]] <- `description`

      query_params[["assigneeAccountId"]] <- `assignee_account_id`

      query_params[["retailerLocationId"]] <- `retailer_location_id`

      query_params[["tags"]] <- `tags`

      query_params[["active"]] <- `active`

      local_var_url_path <- "/assignment/update"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "AssignmentResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    }
  )
)
