#' Sirqul IoT Platform
#'
#' Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
#'
#' The version of the OpenAPI document: 3.16
#' Contact: info@sirqul.com
#' Generated by: https://openapi-generator.tech
#'
#' @docType class
#' @title Tracking operations
#' @description TrackingApi
#' @format An \code{R6Class} generator object
#' @field api_client Handles the client-server communication.
#'
#' @examples
#' \dontrun{
#' ####################  BatchSaveTracking  ####################
#'
#' library(openapi)
#' var_data <- "data_example" # character | JSON array of tracking legs ```json [   \"distance\": \"0.08\",   \"duration\": \"10000\",   \"startLatitude\": \"47.614603\",   \"startLongitude\": \"-122.350518\",   \"endLatitude\": \"47.614384\",   \"endLongitude\": \"-122.349161\",   \"startDate\": \"1361924010000\",   \"endDate\": \"1361924020000\",   \"steps\": [     {       \"distance\": \"0.03\",       \"duration\": \"5000\",       \"startLat\": \"47.614603\",       \"startLng\": \"-122.350518\",       \"startDate\": \"1361924010000\",       \"endLat\": \"47.614941\",       \"endLng\": \"-122.350062\",       \"endDate\": \"1361924015000\"     },{       \"distance\": \"0.05\",       \"duration\": \"5000\",       \"startLat\": \"47.614941\",       \"startLng\": \"-122.350062\",       \"startDate\": \"1361924015000\",       \"endLat\": \"47.614384\",       \"endLng\": \"-122.349161\",       \"endDate\": \"1361924020000\"     }   ] ] ``` 
#' var_device_id <- "device_id_example" # character | the device id (deviceId or accountId required) (Optional)
#' var_account_id <- 56 # integer | the account id of the user (deviceId or accountId required) (Optional)
#' var_generate_accounts <- "generate_accounts_example" # character | Whether to generate accounts for tracking entries when the owner does not exist (Optional)
#' var_update_account_locations <- "update_account_locations_example" # character | Whether to update the account's current location from the incoming tracking data (Optional)
#' var_default_tag <- "PASSIVE" # character | The default tag to apply to incoming legs when no tag is provided (Optional)
#' var_slave_uid <- "slave_uid_example" # character |  (Optional)
#'
#' #Create Batch Tracking
#' api_instance <- TrackingApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$BatchSaveTracking(var_data, device_id = var_device_id, account_id = var_account_id, generate_accounts = var_generate_accounts, update_account_locations = var_update_account_locations, default_tag = var_default_tag, slave_uid = var_slave_uiddata_file = "result.txt")
#' result <- api_instance$BatchSaveTracking(var_data, device_id = var_device_id, account_id = var_account_id, generate_accounts = var_generate_accounts, update_account_locations = var_update_account_locations, default_tag = var_default_tag, slave_uid = var_slave_uid)
#' dput(result)
#'
#'
#' ####################  GetPredictedLocations  ####################
#'
#' library(openapi)
#' var_account_id <- 56 # integer | The account id of the customer
#' var_latitude <- 3.4 # numeric | latitude to return a more likely result set based on the user's current location (Optional)
#' var_longitude <- 3.4 # numeric | longitude to return a more likely result set based on the user's current location (Optional)
#' var_date_check <- 56 # integer | Used to specify which day to get predicted locations for. So if you want to look at where they might be tomorrow, pass in tomorrow's date (timestamp in milliseconds). If no value is passed in, the current date will be used. (Optional)
#' var_hour_check <- "hour_check_example" # character | Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see predicted locations for the mornings and evening you can pass in \"8,9,10,11,17,18,19,20\". (Optional)
#' var_threshold <- 1 # integer | The minimum number matches in 1 hour to be considered a likely location. (Optional)
#' var_distance_unit <- "MILES" # character | Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS} (Optional)
#' var_search_range <- 0 # numeric | Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \"0\" (zero) will ignore the radius restriction. (Optional)
#' var_sort_order <- "MATCHES" # character | The ordering algorithm for sorting the returned results: {MATCHES, DISTANCE, WEIGHTED} (Optional)
#'
#' #Get Predicted Locations
#' api_instance <- TrackingApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$GetPredictedLocations(var_account_id, latitude = var_latitude, longitude = var_longitude, date_check = var_date_check, hour_check = var_hour_check, threshold = var_threshold, distance_unit = var_distance_unit, search_range = var_search_range, sort_order = var_sort_orderdata_file = "result.txt")
#' result <- api_instance$GetPredictedLocations(var_account_id, latitude = var_latitude, longitude = var_longitude, date_check = var_date_check, hour_check = var_hour_check, threshold = var_threshold, distance_unit = var_distance_unit, search_range = var_search_range, sort_order = var_sort_order)
#' dput(result)
#'
#'
#' ####################  GetPredictedPath  ####################
#'
#' library(openapi)
#' var_account_id <- 56 # integer | The account id of the customer
#' var_start_step_id <- 56 # integer | The stepId to begin from
#' var_end_step_id <- 56 # integer | The stepId to end with
#'
#' #Get Tracking Path
#' api_instance <- TrackingApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$GetPredictedPath(var_account_id, var_start_step_id, var_end_step_iddata_file = "result.txt")
#' result <- api_instance$GetPredictedPath(var_account_id, var_start_step_id, var_end_step_id)
#' dput(result)
#'
#'
#' ####################  GetPreferredLocations  ####################
#'
#' library(openapi)
#' var_account_id <- 56 # integer | The account id of the customer
#' var_latitude <- 3.4 # numeric | latitude to return a more likely result set based on the user's current location (Optional)
#' var_longitude <- 3.4 # numeric | longitude to return a more likely result set based on the user's current location (Optional)
#' var_date_check <- 56 # integer | Used to specify which day to get preferred locations for. So if you want to look at where they might be tomorrow, pass in tomorrow's date (timestamp in milliseconds). If no value is passed in, results from all time will be returned. (Optional)
#' var_hour_check <- "hour_check_example" # character | Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see preferred locations for the mornings and evening you can pass in \"8,9,10,11,17,18,19,20\". (Optional)
#' var_sort_field <- "PREFERRED_DATE" # character | Specifies how the results will be ordered. Supported values include: CREATED - the time of when the preferred location data was processed. PREFERRED_DATE - the time of when the user sent in the tracking data. HOUR - the hour of when the user sent in the tracking data. DURATION - the duration of the preferred location (Optional)
#' var_descending <- TRUE # character | Determines whether the sorted list is in descending or ascending order (Optional)
#' var_start <- 0 # integer | The start index for pagination (Optional)
#' var_limit <- 20 # integer | The limit for pagination (Optional)
#' var_search_range <- 0 # numeric | Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \"0\" (zero) will ignore the radius restriction. (Optional)
#' var_distance_unit <- "MILES" # character | Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS} (Optional)
#'
#' #Search Preferred Locations
#' api_instance <- TrackingApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$GetPreferredLocations(var_account_id, latitude = var_latitude, longitude = var_longitude, date_check = var_date_check, hour_check = var_hour_check, sort_field = var_sort_field, descending = var_descending, start = var_start, limit = var_limit, search_range = var_search_range, distance_unit = var_distance_unitdata_file = "result.txt")
#' result <- api_instance$GetPreferredLocations(var_account_id, latitude = var_latitude, longitude = var_longitude, date_check = var_date_check, hour_check = var_hour_check, sort_field = var_sort_field, descending = var_descending, start = var_start, limit = var_limit, search_range = var_search_range, distance_unit = var_distance_unit)
#' dput(result)
#'
#'
#' ####################  GetTrackingLegs  ####################
#'
#' library(openapi)
#' var_device_id <- "device_id_example" # character | the device id (deviceId or accountId required) (Optional)
#' var_account_id <- 56 # integer | the account id of the user (deviceId or accountId required) (Optional)
#' var_owner_id <- 56 # integer | the account id of the person the user wants to tracking data for (Optional)
#' var_tracking_device_id <- "tracking_device_id_example" # character | the id of the tracking device (Optional)
#' var_start_date <- 56 # integer | the start date in (UTC milliseconds) to filter the tracking results. If no startDate is passed in, the last 30 days will be returned. (Optional)
#' var_end_date <- 56 # integer | the end date in (UTC milliseconds) to filter the tracking results (Optional)
#' var_tags <- "tags_example" # character | filter results by tag (Optional)
#' var_get_last_point <- FALSE # character | gets the last known location of the user (Optional)
#'
#' #Search Tracking
#' api_instance <- TrackingApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$GetTrackingLegs(device_id = var_device_id, account_id = var_account_id, owner_id = var_owner_id, tracking_device_id = var_tracking_device_id, start_date = var_start_date, end_date = var_end_date, tags = var_tags, get_last_point = var_get_last_pointdata_file = "result.txt")
#' result <- api_instance$GetTrackingLegs(device_id = var_device_id, account_id = var_account_id, owner_id = var_owner_id, tracking_device_id = var_tracking_device_id, start_date = var_start_date, end_date = var_end_date, tags = var_tags, get_last_point = var_get_last_point)
#' dput(result)
#'
#'
#' ####################  SaveTrackingLeg  ####################
#'
#' library(openapi)
#' var_start_lat <- 3.4 # numeric | the latitude of the first point
#' var_start_lng <- 3.4 # numeric | the longitude of the first point
#' var_start_date <- 56 # integer | the start date (in UTC milliseconds) of the first point
#' var_end_lat <- 3.4 # numeric | the latitude of the last point
#' var_end_lng <- 3.4 # numeric | the longitude of the last point
#' var_end_date <- 56 # integer | the end date (in UTC milliseconds) of the last point
#' var_device_id <- "device_id_example" # character | the device id (deviceId or accountId required) (Optional)
#' var_account_id <- 56 # integer | the account id of the user (deviceId or accountId required) (Optional)
#' var_distance <- 3.4 # numeric | the total distance (Optional)
#' var_duration <- 56 # integer | the total duration (Optional)
#' var_steps <- "steps_example" # character | JSON array of tracking vectors used for smoother pathing data. If null then the leg data will be used to generate a single step, if an empty array then no steps will be generated. ```json [{   \"distance\": \"0.03\",   \"duration\": \"5000\",   \"startLat\": \"47.614603\",   \"startLng\": \"-122.350518\",   \"startDate\": \"1361924010000\",   \"endLat\": \"47.614941\",   \"endLng\": \"-122.350062\",   \"endDate\": \"1361924015000\" }] ```  (Optional)
#' var_tags <- "tags_example" # character | name the leg for searching (Optional)
#'
#' #Create Tracking Leg
#' api_instance <- TrackingApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$SaveTrackingLeg(var_start_lat, var_start_lng, var_start_date, var_end_lat, var_end_lng, var_end_date, device_id = var_device_id, account_id = var_account_id, distance = var_distance, duration = var_duration, steps = var_steps, tags = var_tagsdata_file = "result.txt")
#' result <- api_instance$SaveTrackingLeg(var_start_lat, var_start_lng, var_start_date, var_end_lat, var_end_lng, var_end_date, device_id = var_device_id, account_id = var_account_id, distance = var_distance, duration = var_duration, steps = var_steps, tags = var_tags)
#' dput(result)
#'
#'
#' ####################  SaveTrackingStep  ####################
#'
#' library(openapi)
#' var_leg_id <- 56 # integer | the leg to add the step to
#' var_start_lat <- 3.4 # numeric | the latitude of the first point
#' var_start_lng <- 3.4 # numeric | the longitude of the first point
#' var_start_date <- 56 # integer | the start date (in UTC milliseconds) of the first point
#' var_end_lat <- 3.4 # numeric | the latitude of the last point
#' var_end_lng <- 3.4 # numeric | the longitude of the last point
#' var_end_date <- 56 # integer | the end date (in UTC milliseconds) of the last point
#' var_device_id <- "device_id_example" # character | the device id (deviceId or accountId required) (Optional)
#' var_account_id <- 56 # integer | the account id of the user (deviceId or accountId required) (Optional)
#' var_distance <- 3.4 # numeric | the total distance (Optional)
#' var_duration <- 56 # integer | the total duration (Optional)
#'
#' #Create Tracking Step
#' api_instance <- TrackingApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$SaveTrackingStep(var_leg_id, var_start_lat, var_start_lng, var_start_date, var_end_lat, var_end_lng, var_end_date, device_id = var_device_id, account_id = var_account_id, distance = var_distance, duration = var_durationdata_file = "result.txt")
#' result <- api_instance$SaveTrackingStep(var_leg_id, var_start_lat, var_start_lng, var_start_date, var_end_lat, var_end_lng, var_end_date, device_id = var_device_id, account_id = var_account_id, distance = var_distance, duration = var_duration)
#' dput(result)
#'
#'
#' ####################  SearchAccountsWithTrackingLegs  ####################
#'
#' library(openapi)
#' var_account_id <- 56 # integer | The account id of the user
#' var_keyword <- "keyword_example" # character | Used for LIKE search of first or last name on the acocunt (Optional)
#' var_start_date <- 56 # integer | Range to begin in UTC milliseconds (Optional)
#' var_end_date <- 56 # integer | Range to end in UTC milliseconds (Optional)
#' var_tags <- "tags_example" # character | Exact match on tag field of Legs's searchTag (Optional)
#' var_audience_ids <- "audience_ids_example" # character |  (Optional)
#' var_latitude <- 3.4 # numeric | Origin latitude to perform searching constraints with given range (Optional)
#' var_longitude <- 3.4 # numeric | Origin longitude to perform searching constraints with given range (Optional)
#' var_range <- 5 # numeric | The radius, in miles, to perform the search for (Optional)
#' var_sort_field <- "LEG_START_DATE" # character | The column to sort the search on. Possible values include: {LEG_START_DATE, ACCOUNT_DISPLAY} (Optional)
#' var_descending <- TRUE # character | The order to return the results. Default is false, which will return the results in ascending order. (Optional)
#' var_start <- 0 # integer | The index into the record set to start with. Default is 0. (Optional)
#' var_limit <- 20 # integer | The total number of records to return. Default is 20. (Optional)
#' var_active_only <- FALSE # character | Determines whether to return only active results. Default is false. (Optional)
#'
#' #List Tracking
#' api_instance <- TrackingApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$SearchAccountsWithTrackingLegs(var_account_id, keyword = var_keyword, start_date = var_start_date, end_date = var_end_date, tags = var_tags, audience_ids = var_audience_ids, latitude = var_latitude, longitude = var_longitude, range = var_range, sort_field = var_sort_field, descending = var_descending, start = var_start, limit = var_limit, active_only = var_active_onlydata_file = "result.txt")
#' result <- api_instance$SearchAccountsWithTrackingLegs(var_account_id, keyword = var_keyword, start_date = var_start_date, end_date = var_end_date, tags = var_tags, audience_ids = var_audience_ids, latitude = var_latitude, longitude = var_longitude, range = var_range, sort_field = var_sort_field, descending = var_descending, start = var_start, limit = var_limit, active_only = var_active_only)
#' dput(result)
#'
#'
#' ####################  SearchTrackingLegs  ####################
#'
#' library(openapi)
#' var_account_id <- 56 # integer | The account id to search tracking for
#' var_app_key <- "app_key_example" # character | The application key
#' var_tracking_device_id <- "tracking_device_id_example" # character | The id of the tracking device (Optional)
#' var_start_date <- 56 # integer | The start date in (UTC milliseconds) to filter the tracking results (Optional)
#' var_end_date <- 56 # integer | The end date in (UTC milliseconds) to filter the tracking results (Optional)
#' var_tags <- "tags_example" # character | Filter results by tag (Optional)
#' var_start <- 0 # integer | The start index for pagination (Optional)
#' var_limit <- 100 # integer | The limit for pagination (Optional)
#'
#' #Search Tracking (Billable)
#' api_instance <- TrackingApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$SearchTrackingLegs(var_account_id, var_app_key, tracking_device_id = var_tracking_device_id, start_date = var_start_date, end_date = var_end_date, tags = var_tags, start = var_start, limit = var_limitdata_file = "result.txt")
#' result <- api_instance$SearchTrackingLegs(var_account_id, var_app_key, tracking_device_id = var_tracking_device_id, start_date = var_start_date, end_date = var_end_date, tags = var_tags, start = var_start, limit = var_limit)
#' dput(result)
#'
#'
#' }
#' @importFrom R6 R6Class
#' @importFrom base64enc base64encode
#' @export
TrackingApi <- R6::R6Class(
  "TrackingApi",
  public = list(
    api_client = NULL,

    #' @description
    #' Initialize a new TrackingApi.
    #'
    #' @param api_client An instance of API client.
    initialize = function(api_client) {
      if (!missing(api_client)) {
        self$api_client <- api_client
      } else {
        self$api_client <- ApiClient$new()
      }
    },

    #' @description
    #' Create Batch Tracking
    #'
    #' @param data JSON array of tracking legs ```json [   \"distance\": \"0.08\",   \"duration\": \"10000\",   \"startLatitude\": \"47.614603\",   \"startLongitude\": \"-122.350518\",   \"endLatitude\": \"47.614384\",   \"endLongitude\": \"-122.349161\",   \"startDate\": \"1361924010000\",   \"endDate\": \"1361924020000\",   \"steps\": [     {       \"distance\": \"0.03\",       \"duration\": \"5000\",       \"startLat\": \"47.614603\",       \"startLng\": \"-122.350518\",       \"startDate\": \"1361924010000\",       \"endLat\": \"47.614941\",       \"endLng\": \"-122.350062\",       \"endDate\": \"1361924015000\"     },{       \"distance\": \"0.05\",       \"duration\": \"5000\",       \"startLat\": \"47.614941\",       \"startLng\": \"-122.350062\",       \"startDate\": \"1361924015000\",       \"endLat\": \"47.614384\",       \"endLng\": \"-122.349161\",       \"endDate\": \"1361924020000\"     }   ] ] ``` 
    #' @param device_id (optional) the device id (deviceId or accountId required)
    #' @param account_id (optional) the account id of the user (deviceId or accountId required)
    #' @param generate_accounts (optional) Whether to generate accounts for tracking entries when the owner does not exist
    #' @param update_account_locations (optional) Whether to update the account's current location from the incoming tracking data
    #' @param default_tag (optional) The default tag to apply to incoming legs when no tag is provided (default value: "PASSIVE")
    #' @param slave_uid (optional) 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return array[Leg]
    BatchSaveTracking = function(data, device_id = NULL, account_id = NULL, generate_accounts = NULL, update_account_locations = NULL, default_tag = "PASSIVE", slave_uid = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$BatchSaveTrackingWithHttpInfo(data, device_id, account_id, generate_accounts, update_account_locations, default_tag, slave_uid, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Create Batch Tracking
    #'
    #' @param data JSON array of tracking legs ```json [   \"distance\": \"0.08\",   \"duration\": \"10000\",   \"startLatitude\": \"47.614603\",   \"startLongitude\": \"-122.350518\",   \"endLatitude\": \"47.614384\",   \"endLongitude\": \"-122.349161\",   \"startDate\": \"1361924010000\",   \"endDate\": \"1361924020000\",   \"steps\": [     {       \"distance\": \"0.03\",       \"duration\": \"5000\",       \"startLat\": \"47.614603\",       \"startLng\": \"-122.350518\",       \"startDate\": \"1361924010000\",       \"endLat\": \"47.614941\",       \"endLng\": \"-122.350062\",       \"endDate\": \"1361924015000\"     },{       \"distance\": \"0.05\",       \"duration\": \"5000\",       \"startLat\": \"47.614941\",       \"startLng\": \"-122.350062\",       \"startDate\": \"1361924015000\",       \"endLat\": \"47.614384\",       \"endLng\": \"-122.349161\",       \"endDate\": \"1361924020000\"     }   ] ] ``` 
    #' @param device_id (optional) the device id (deviceId or accountId required)
    #' @param account_id (optional) the account id of the user (deviceId or accountId required)
    #' @param generate_accounts (optional) Whether to generate accounts for tracking entries when the owner does not exist
    #' @param update_account_locations (optional) Whether to update the account's current location from the incoming tracking data
    #' @param default_tag (optional) The default tag to apply to incoming legs when no tag is provided (default value: "PASSIVE")
    #' @param slave_uid (optional) 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (array[Leg]) with additional information such as HTTP status code, headers
    BatchSaveTrackingWithHttpInfo = function(data, device_id = NULL, account_id = NULL, generate_accounts = NULL, update_account_locations = NULL, default_tag = "PASSIVE", slave_uid = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`data`)) {
        stop("Missing required parameter `data`.")
      }

      if (!missing(`data`) && is.null(`data`)) {
        stop("Invalid value for `data` when calling TrackingApi$BatchSaveTracking, `data` is not nullable")
      }

      if (!missing(`device_id`) && is.null(`device_id`)) {
        stop("Invalid value for `device_id` when calling TrackingApi$BatchSaveTracking, `device_id` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling TrackingApi$BatchSaveTracking, `account_id` is not nullable")
      }

      if (!missing(`generate_accounts`) && is.null(`generate_accounts`)) {
        stop("Invalid value for `generate_accounts` when calling TrackingApi$BatchSaveTracking, `generate_accounts` is not nullable")
      }

      if (!missing(`update_account_locations`) && is.null(`update_account_locations`)) {
        stop("Invalid value for `update_account_locations` when calling TrackingApi$BatchSaveTracking, `update_account_locations` is not nullable")
      }

      if (!missing(`default_tag`) && is.null(`default_tag`)) {
        stop("Invalid value for `default_tag` when calling TrackingApi$BatchSaveTracking, `default_tag` is not nullable")
      }

      if (!missing(`slave_uid`) && is.null(`slave_uid`)) {
        stop("Invalid value for `slave_uid` when calling TrackingApi$BatchSaveTracking, `slave_uid` is not nullable")
      }

      query_params[["deviceId"]] <- `device_id`

      query_params[["accountId"]] <- `account_id`

      query_params[["data"]] <- `data`

      query_params[["generateAccounts"]] <- `generate_accounts`

      query_params[["updateAccountLocations"]] <- `update_account_locations`

      query_params[["defaultTag"]] <- `default_tag`

      query_params[["slaveUID"]] <- `slave_uid`

      local_var_url_path <- "/tracking/batch/create"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "array[Leg]"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Get Predicted Locations
    #'
    #' @param account_id The account id of the customer
    #' @param latitude (optional) latitude to return a more likely result set based on the user's current location
    #' @param longitude (optional) longitude to return a more likely result set based on the user's current location
    #' @param date_check (optional) Used to specify which day to get predicted locations for. So if you want to look at where they might be tomorrow, pass in tomorrow's date (timestamp in milliseconds). If no value is passed in, the current date will be used.
    #' @param hour_check (optional) Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see predicted locations for the mornings and evening you can pass in \"8,9,10,11,17,18,19,20\".
    #' @param threshold (optional) The minimum number matches in 1 hour to be considered a likely location. (default value: 1)
    #' @param distance_unit (optional) Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS} (default value: "MILES")
    #' @param search_range (optional) Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \"0\" (zero) will ignore the radius restriction. (default value: 0)
    #' @param sort_order (optional) The ordering algorithm for sorting the returned results: {MATCHES, DISTANCE, WEIGHTED} (default value: "MATCHES")
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return PredictedLocationResponse
    GetPredictedLocations = function(account_id, latitude = NULL, longitude = NULL, date_check = NULL, hour_check = NULL, threshold = 1, distance_unit = "MILES", search_range = 0, sort_order = "MATCHES", data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$GetPredictedLocationsWithHttpInfo(account_id, latitude, longitude, date_check, hour_check, threshold, distance_unit, search_range, sort_order, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Get Predicted Locations
    #'
    #' @param account_id The account id of the customer
    #' @param latitude (optional) latitude to return a more likely result set based on the user's current location
    #' @param longitude (optional) longitude to return a more likely result set based on the user's current location
    #' @param date_check (optional) Used to specify which day to get predicted locations for. So if you want to look at where they might be tomorrow, pass in tomorrow's date (timestamp in milliseconds). If no value is passed in, the current date will be used.
    #' @param hour_check (optional) Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see predicted locations for the mornings and evening you can pass in \"8,9,10,11,17,18,19,20\".
    #' @param threshold (optional) The minimum number matches in 1 hour to be considered a likely location. (default value: 1)
    #' @param distance_unit (optional) Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS} (default value: "MILES")
    #' @param search_range (optional) Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \"0\" (zero) will ignore the radius restriction. (default value: 0)
    #' @param sort_order (optional) The ordering algorithm for sorting the returned results: {MATCHES, DISTANCE, WEIGHTED} (default value: "MATCHES")
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (PredictedLocationResponse) with additional information such as HTTP status code, headers
    GetPredictedLocationsWithHttpInfo = function(account_id, latitude = NULL, longitude = NULL, date_check = NULL, hour_check = NULL, threshold = 1, distance_unit = "MILES", search_range = 0, sort_order = "MATCHES", data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling TrackingApi$GetPredictedLocations, `account_id` is not nullable")
      }

      if (!missing(`latitude`) && is.null(`latitude`)) {
        stop("Invalid value for `latitude` when calling TrackingApi$GetPredictedLocations, `latitude` is not nullable")
      }

      if (!missing(`longitude`) && is.null(`longitude`)) {
        stop("Invalid value for `longitude` when calling TrackingApi$GetPredictedLocations, `longitude` is not nullable")
      }

      if (!missing(`date_check`) && is.null(`date_check`)) {
        stop("Invalid value for `date_check` when calling TrackingApi$GetPredictedLocations, `date_check` is not nullable")
      }

      if (!missing(`hour_check`) && is.null(`hour_check`)) {
        stop("Invalid value for `hour_check` when calling TrackingApi$GetPredictedLocations, `hour_check` is not nullable")
      }

      if (!missing(`threshold`) && is.null(`threshold`)) {
        stop("Invalid value for `threshold` when calling TrackingApi$GetPredictedLocations, `threshold` is not nullable")
      }

      if (!missing(`distance_unit`) && is.null(`distance_unit`)) {
        stop("Invalid value for `distance_unit` when calling TrackingApi$GetPredictedLocations, `distance_unit` is not nullable")
      }

      if (!missing(`search_range`) && is.null(`search_range`)) {
        stop("Invalid value for `search_range` when calling TrackingApi$GetPredictedLocations, `search_range` is not nullable")
      }

      if (!missing(`sort_order`) && is.null(`sort_order`)) {
        stop("Invalid value for `sort_order` when calling TrackingApi$GetPredictedLocations, `sort_order` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["latitude"]] <- `latitude`

      query_params[["longitude"]] <- `longitude`

      query_params[["dateCheck"]] <- `date_check`

      query_params[["hourCheck"]] <- `hour_check`

      query_params[["threshold"]] <- `threshold`

      if (!is.null(`distance_unit`) && !(`distance_unit` %in% c("MILES", "KILOMETERS"))) {
        stop("Invalid value for distance_unit when calling TrackingApi$GetPredictedLocations. Must be [MILES, KILOMETERS].")
      }
      query_params[["distanceUnit"]] <- `distance_unit`

      query_params[["searchRange"]] <- `search_range`

      if (!is.null(`sort_order`) && !(`sort_order` %in% c("MATCHES", "DISTANCE", "WEIGHTED"))) {
        stop("Invalid value for sort_order when calling TrackingApi$GetPredictedLocations. Must be [MATCHES, DISTANCE, WEIGHTED].")
      }
      query_params[["sortOrder"]] <- `sort_order`

      local_var_url_path <- "/tracking/predicted/get"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "PredictedLocationResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Get Tracking Path
    #'
    #' @param account_id The account id of the customer
    #' @param start_step_id The stepId to begin from
    #' @param end_step_id The stepId to end with
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return array[StepResponse]
    GetPredictedPath = function(account_id, start_step_id, end_step_id, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$GetPredictedPathWithHttpInfo(account_id, start_step_id, end_step_id, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Get Tracking Path
    #'
    #' @param account_id The account id of the customer
    #' @param start_step_id The stepId to begin from
    #' @param end_step_id The stepId to end with
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (array[StepResponse]) with additional information such as HTTP status code, headers
    GetPredictedPathWithHttpInfo = function(account_id, start_step_id, end_step_id, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (missing(`start_step_id`)) {
        stop("Missing required parameter `start_step_id`.")
      }

      if (missing(`end_step_id`)) {
        stop("Missing required parameter `end_step_id`.")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling TrackingApi$GetPredictedPath, `account_id` is not nullable")
      }

      if (!missing(`start_step_id`) && is.null(`start_step_id`)) {
        stop("Invalid value for `start_step_id` when calling TrackingApi$GetPredictedPath, `start_step_id` is not nullable")
      }

      if (!missing(`end_step_id`) && is.null(`end_step_id`)) {
        stop("Invalid value for `end_step_id` when calling TrackingApi$GetPredictedPath, `end_step_id` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["startStepId"]] <- `start_step_id`

      query_params[["endStepId"]] <- `end_step_id`

      local_var_url_path <- "/tracking/path/get"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "array[StepResponse]"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Search Preferred Locations
    #'
    #' @param account_id The account id of the customer
    #' @param latitude (optional) latitude to return a more likely result set based on the user's current location
    #' @param longitude (optional) longitude to return a more likely result set based on the user's current location
    #' @param date_check (optional) Used to specify which day to get preferred locations for. So if you want to look at where they might be tomorrow, pass in tomorrow's date (timestamp in milliseconds). If no value is passed in, results from all time will be returned.
    #' @param hour_check (optional) Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see preferred locations for the mornings and evening you can pass in \"8,9,10,11,17,18,19,20\".
    #' @param sort_field (optional) Specifies how the results will be ordered. Supported values include: CREATED - the time of when the preferred location data was processed. PREFERRED_DATE - the time of when the user sent in the tracking data. HOUR - the hour of when the user sent in the tracking data. DURATION - the duration of the preferred location (default value: "PREFERRED_DATE")
    #' @param descending (optional) Determines whether the sorted list is in descending or ascending order (default value: TRUE)
    #' @param start (optional) The start index for pagination (default value: 0)
    #' @param limit (optional) The limit for pagination (default value: 20)
    #' @param search_range (optional) Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \"0\" (zero) will ignore the radius restriction. (default value: 0)
    #' @param distance_unit (optional) Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS} (default value: "MILES")
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return array[PreferredLocationResponse]
    GetPreferredLocations = function(account_id, latitude = NULL, longitude = NULL, date_check = NULL, hour_check = NULL, sort_field = "PREFERRED_DATE", descending = TRUE, start = 0, limit = 20, search_range = 0, distance_unit = "MILES", data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$GetPreferredLocationsWithHttpInfo(account_id, latitude, longitude, date_check, hour_check, sort_field, descending, start, limit, search_range, distance_unit, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Search Preferred Locations
    #'
    #' @param account_id The account id of the customer
    #' @param latitude (optional) latitude to return a more likely result set based on the user's current location
    #' @param longitude (optional) longitude to return a more likely result set based on the user's current location
    #' @param date_check (optional) Used to specify which day to get preferred locations for. So if you want to look at where they might be tomorrow, pass in tomorrow's date (timestamp in milliseconds). If no value is passed in, results from all time will be returned.
    #' @param hour_check (optional) Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see preferred locations for the mornings and evening you can pass in \"8,9,10,11,17,18,19,20\".
    #' @param sort_field (optional) Specifies how the results will be ordered. Supported values include: CREATED - the time of when the preferred location data was processed. PREFERRED_DATE - the time of when the user sent in the tracking data. HOUR - the hour of when the user sent in the tracking data. DURATION - the duration of the preferred location (default value: "PREFERRED_DATE")
    #' @param descending (optional) Determines whether the sorted list is in descending or ascending order (default value: TRUE)
    #' @param start (optional) The start index for pagination (default value: 0)
    #' @param limit (optional) The limit for pagination (default value: 20)
    #' @param search_range (optional) Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \"0\" (zero) will ignore the radius restriction. (default value: 0)
    #' @param distance_unit (optional) Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS} (default value: "MILES")
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (array[PreferredLocationResponse]) with additional information such as HTTP status code, headers
    GetPreferredLocationsWithHttpInfo = function(account_id, latitude = NULL, longitude = NULL, date_check = NULL, hour_check = NULL, sort_field = "PREFERRED_DATE", descending = TRUE, start = 0, limit = 20, search_range = 0, distance_unit = "MILES", data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling TrackingApi$GetPreferredLocations, `account_id` is not nullable")
      }

      if (!missing(`latitude`) && is.null(`latitude`)) {
        stop("Invalid value for `latitude` when calling TrackingApi$GetPreferredLocations, `latitude` is not nullable")
      }

      if (!missing(`longitude`) && is.null(`longitude`)) {
        stop("Invalid value for `longitude` when calling TrackingApi$GetPreferredLocations, `longitude` is not nullable")
      }

      if (!missing(`date_check`) && is.null(`date_check`)) {
        stop("Invalid value for `date_check` when calling TrackingApi$GetPreferredLocations, `date_check` is not nullable")
      }

      if (!missing(`hour_check`) && is.null(`hour_check`)) {
        stop("Invalid value for `hour_check` when calling TrackingApi$GetPreferredLocations, `hour_check` is not nullable")
      }

      if (!missing(`sort_field`) && is.null(`sort_field`)) {
        stop("Invalid value for `sort_field` when calling TrackingApi$GetPreferredLocations, `sort_field` is not nullable")
      }

      if (!missing(`descending`) && is.null(`descending`)) {
        stop("Invalid value for `descending` when calling TrackingApi$GetPreferredLocations, `descending` is not nullable")
      }

      if (!missing(`start`) && is.null(`start`)) {
        stop("Invalid value for `start` when calling TrackingApi$GetPreferredLocations, `start` is not nullable")
      }

      if (!missing(`limit`) && is.null(`limit`)) {
        stop("Invalid value for `limit` when calling TrackingApi$GetPreferredLocations, `limit` is not nullable")
      }

      if (!missing(`search_range`) && is.null(`search_range`)) {
        stop("Invalid value for `search_range` when calling TrackingApi$GetPreferredLocations, `search_range` is not nullable")
      }

      if (!missing(`distance_unit`) && is.null(`distance_unit`)) {
        stop("Invalid value for `distance_unit` when calling TrackingApi$GetPreferredLocations, `distance_unit` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["latitude"]] <- `latitude`

      query_params[["longitude"]] <- `longitude`

      query_params[["dateCheck"]] <- `date_check`

      query_params[["hourCheck"]] <- `hour_check`

      query_params[["sortField"]] <- `sort_field`

      query_params[["descending"]] <- `descending`

      query_params[["start"]] <- `start`

      query_params[["limit"]] <- `limit`

      query_params[["searchRange"]] <- `search_range`

      if (!is.null(`distance_unit`) && !(`distance_unit` %in% c("MILES", "KILOMETERS"))) {
        stop("Invalid value for distance_unit when calling TrackingApi$GetPreferredLocations. Must be [MILES, KILOMETERS].")
      }
      query_params[["distanceUnit"]] <- `distance_unit`

      local_var_url_path <- "/tracking/preferred/search"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "array[PreferredLocationResponse]"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Search Tracking
    #'
    #' @param device_id (optional) the device id (deviceId or accountId required)
    #' @param account_id (optional) the account id of the user (deviceId or accountId required)
    #' @param owner_id (optional) the account id of the person the user wants to tracking data for
    #' @param tracking_device_id (optional) the id of the tracking device
    #' @param start_date (optional) the start date in (UTC milliseconds) to filter the tracking results. If no startDate is passed in, the last 30 days will be returned.
    #' @param end_date (optional) the end date in (UTC milliseconds) to filter the tracking results
    #' @param tags (optional) filter results by tag
    #' @param get_last_point (optional) gets the last known location of the user (default value: FALSE)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return array[LegResponse]
    GetTrackingLegs = function(device_id = NULL, account_id = NULL, owner_id = NULL, tracking_device_id = NULL, start_date = NULL, end_date = NULL, tags = NULL, get_last_point = FALSE, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$GetTrackingLegsWithHttpInfo(device_id, account_id, owner_id, tracking_device_id, start_date, end_date, tags, get_last_point, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Search Tracking
    #'
    #' @param device_id (optional) the device id (deviceId or accountId required)
    #' @param account_id (optional) the account id of the user (deviceId or accountId required)
    #' @param owner_id (optional) the account id of the person the user wants to tracking data for
    #' @param tracking_device_id (optional) the id of the tracking device
    #' @param start_date (optional) the start date in (UTC milliseconds) to filter the tracking results. If no startDate is passed in, the last 30 days will be returned.
    #' @param end_date (optional) the end date in (UTC milliseconds) to filter the tracking results
    #' @param tags (optional) filter results by tag
    #' @param get_last_point (optional) gets the last known location of the user (default value: FALSE)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (array[LegResponse]) with additional information such as HTTP status code, headers
    GetTrackingLegsWithHttpInfo = function(device_id = NULL, account_id = NULL, owner_id = NULL, tracking_device_id = NULL, start_date = NULL, end_date = NULL, tags = NULL, get_last_point = FALSE, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (!missing(`device_id`) && is.null(`device_id`)) {
        stop("Invalid value for `device_id` when calling TrackingApi$GetTrackingLegs, `device_id` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling TrackingApi$GetTrackingLegs, `account_id` is not nullable")
      }

      if (!missing(`owner_id`) && is.null(`owner_id`)) {
        stop("Invalid value for `owner_id` when calling TrackingApi$GetTrackingLegs, `owner_id` is not nullable")
      }

      if (!missing(`tracking_device_id`) && is.null(`tracking_device_id`)) {
        stop("Invalid value for `tracking_device_id` when calling TrackingApi$GetTrackingLegs, `tracking_device_id` is not nullable")
      }

      if (!missing(`start_date`) && is.null(`start_date`)) {
        stop("Invalid value for `start_date` when calling TrackingApi$GetTrackingLegs, `start_date` is not nullable")
      }

      if (!missing(`end_date`) && is.null(`end_date`)) {
        stop("Invalid value for `end_date` when calling TrackingApi$GetTrackingLegs, `end_date` is not nullable")
      }

      if (!missing(`tags`) && is.null(`tags`)) {
        stop("Invalid value for `tags` when calling TrackingApi$GetTrackingLegs, `tags` is not nullable")
      }

      if (!missing(`get_last_point`) && is.null(`get_last_point`)) {
        stop("Invalid value for `get_last_point` when calling TrackingApi$GetTrackingLegs, `get_last_point` is not nullable")
      }

      query_params[["deviceId"]] <- `device_id`

      query_params[["accountId"]] <- `account_id`

      query_params[["ownerId"]] <- `owner_id`

      query_params[["trackingDeviceId"]] <- `tracking_device_id`

      query_params[["startDate"]] <- `start_date`

      query_params[["endDate"]] <- `end_date`

      query_params[["tags"]] <- `tags`

      query_params[["getLastPoint"]] <- `get_last_point`

      local_var_url_path <- "/tracking/search"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "array[LegResponse]"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Create Tracking Leg
    #'
    #' @param start_lat the latitude of the first point
    #' @param start_lng the longitude of the first point
    #' @param start_date the start date (in UTC milliseconds) of the first point
    #' @param end_lat the latitude of the last point
    #' @param end_lng the longitude of the last point
    #' @param end_date the end date (in UTC milliseconds) of the last point
    #' @param device_id (optional) the device id (deviceId or accountId required)
    #' @param account_id (optional) the account id of the user (deviceId or accountId required)
    #' @param distance (optional) the total distance
    #' @param duration (optional) the total duration
    #' @param steps (optional) JSON array of tracking vectors used for smoother pathing data. If null then the leg data will be used to generate a single step, if an empty array then no steps will be generated. ```json [{   \"distance\": \"0.03\",   \"duration\": \"5000\",   \"startLat\": \"47.614603\",   \"startLng\": \"-122.350518\",   \"startDate\": \"1361924010000\",   \"endLat\": \"47.614941\",   \"endLng\": \"-122.350062\",   \"endDate\": \"1361924015000\" }] ``` 
    #' @param tags (optional) name the leg for searching
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return SirqulResponse
    SaveTrackingLeg = function(start_lat, start_lng, start_date, end_lat, end_lng, end_date, device_id = NULL, account_id = NULL, distance = NULL, duration = NULL, steps = NULL, tags = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$SaveTrackingLegWithHttpInfo(start_lat, start_lng, start_date, end_lat, end_lng, end_date, device_id, account_id, distance, duration, steps, tags, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Create Tracking Leg
    #'
    #' @param start_lat the latitude of the first point
    #' @param start_lng the longitude of the first point
    #' @param start_date the start date (in UTC milliseconds) of the first point
    #' @param end_lat the latitude of the last point
    #' @param end_lng the longitude of the last point
    #' @param end_date the end date (in UTC milliseconds) of the last point
    #' @param device_id (optional) the device id (deviceId or accountId required)
    #' @param account_id (optional) the account id of the user (deviceId or accountId required)
    #' @param distance (optional) the total distance
    #' @param duration (optional) the total duration
    #' @param steps (optional) JSON array of tracking vectors used for smoother pathing data. If null then the leg data will be used to generate a single step, if an empty array then no steps will be generated. ```json [{   \"distance\": \"0.03\",   \"duration\": \"5000\",   \"startLat\": \"47.614603\",   \"startLng\": \"-122.350518\",   \"startDate\": \"1361924010000\",   \"endLat\": \"47.614941\",   \"endLng\": \"-122.350062\",   \"endDate\": \"1361924015000\" }] ``` 
    #' @param tags (optional) name the leg for searching
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (SirqulResponse) with additional information such as HTTP status code, headers
    SaveTrackingLegWithHttpInfo = function(start_lat, start_lng, start_date, end_lat, end_lng, end_date, device_id = NULL, account_id = NULL, distance = NULL, duration = NULL, steps = NULL, tags = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`start_lat`)) {
        stop("Missing required parameter `start_lat`.")
      }

      if (missing(`start_lng`)) {
        stop("Missing required parameter `start_lng`.")
      }

      if (missing(`start_date`)) {
        stop("Missing required parameter `start_date`.")
      }

      if (missing(`end_lat`)) {
        stop("Missing required parameter `end_lat`.")
      }

      if (missing(`end_lng`)) {
        stop("Missing required parameter `end_lng`.")
      }

      if (missing(`end_date`)) {
        stop("Missing required parameter `end_date`.")
      }

      if (!missing(`start_lat`) && is.null(`start_lat`)) {
        stop("Invalid value for `start_lat` when calling TrackingApi$SaveTrackingLeg, `start_lat` is not nullable")
      }

      if (!missing(`start_lng`) && is.null(`start_lng`)) {
        stop("Invalid value for `start_lng` when calling TrackingApi$SaveTrackingLeg, `start_lng` is not nullable")
      }

      if (!missing(`start_date`) && is.null(`start_date`)) {
        stop("Invalid value for `start_date` when calling TrackingApi$SaveTrackingLeg, `start_date` is not nullable")
      }

      if (!missing(`end_lat`) && is.null(`end_lat`)) {
        stop("Invalid value for `end_lat` when calling TrackingApi$SaveTrackingLeg, `end_lat` is not nullable")
      }

      if (!missing(`end_lng`) && is.null(`end_lng`)) {
        stop("Invalid value for `end_lng` when calling TrackingApi$SaveTrackingLeg, `end_lng` is not nullable")
      }

      if (!missing(`end_date`) && is.null(`end_date`)) {
        stop("Invalid value for `end_date` when calling TrackingApi$SaveTrackingLeg, `end_date` is not nullable")
      }

      if (!missing(`device_id`) && is.null(`device_id`)) {
        stop("Invalid value for `device_id` when calling TrackingApi$SaveTrackingLeg, `device_id` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling TrackingApi$SaveTrackingLeg, `account_id` is not nullable")
      }

      if (!missing(`distance`) && is.null(`distance`)) {
        stop("Invalid value for `distance` when calling TrackingApi$SaveTrackingLeg, `distance` is not nullable")
      }

      if (!missing(`duration`) && is.null(`duration`)) {
        stop("Invalid value for `duration` when calling TrackingApi$SaveTrackingLeg, `duration` is not nullable")
      }

      if (!missing(`steps`) && is.null(`steps`)) {
        stop("Invalid value for `steps` when calling TrackingApi$SaveTrackingLeg, `steps` is not nullable")
      }

      if (!missing(`tags`) && is.null(`tags`)) {
        stop("Invalid value for `tags` when calling TrackingApi$SaveTrackingLeg, `tags` is not nullable")
      }

      query_params[["deviceId"]] <- `device_id`

      query_params[["accountId"]] <- `account_id`

      query_params[["distance"]] <- `distance`

      query_params[["duration"]] <- `duration`

      query_params[["startLat"]] <- `start_lat`

      query_params[["startLng"]] <- `start_lng`

      query_params[["startDate"]] <- `start_date`

      query_params[["endLat"]] <- `end_lat`

      query_params[["endLng"]] <- `end_lng`

      query_params[["endDate"]] <- `end_date`

      query_params[["steps"]] <- `steps`

      query_params[["tags"]] <- `tags`

      local_var_url_path <- "/tracking/leg/create"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "SirqulResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Create Tracking Step
    #'
    #' @param leg_id the leg to add the step to
    #' @param start_lat the latitude of the first point
    #' @param start_lng the longitude of the first point
    #' @param start_date the start date (in UTC milliseconds) of the first point
    #' @param end_lat the latitude of the last point
    #' @param end_lng the longitude of the last point
    #' @param end_date the end date (in UTC milliseconds) of the last point
    #' @param device_id (optional) the device id (deviceId or accountId required)
    #' @param account_id (optional) the account id of the user (deviceId or accountId required)
    #' @param distance (optional) the total distance
    #' @param duration (optional) the total duration
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return SirqulResponse
    SaveTrackingStep = function(leg_id, start_lat, start_lng, start_date, end_lat, end_lng, end_date, device_id = NULL, account_id = NULL, distance = NULL, duration = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$SaveTrackingStepWithHttpInfo(leg_id, start_lat, start_lng, start_date, end_lat, end_lng, end_date, device_id, account_id, distance, duration, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Create Tracking Step
    #'
    #' @param leg_id the leg to add the step to
    #' @param start_lat the latitude of the first point
    #' @param start_lng the longitude of the first point
    #' @param start_date the start date (in UTC milliseconds) of the first point
    #' @param end_lat the latitude of the last point
    #' @param end_lng the longitude of the last point
    #' @param end_date the end date (in UTC milliseconds) of the last point
    #' @param device_id (optional) the device id (deviceId or accountId required)
    #' @param account_id (optional) the account id of the user (deviceId or accountId required)
    #' @param distance (optional) the total distance
    #' @param duration (optional) the total duration
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (SirqulResponse) with additional information such as HTTP status code, headers
    SaveTrackingStepWithHttpInfo = function(leg_id, start_lat, start_lng, start_date, end_lat, end_lng, end_date, device_id = NULL, account_id = NULL, distance = NULL, duration = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`leg_id`)) {
        stop("Missing required parameter `leg_id`.")
      }

      if (missing(`start_lat`)) {
        stop("Missing required parameter `start_lat`.")
      }

      if (missing(`start_lng`)) {
        stop("Missing required parameter `start_lng`.")
      }

      if (missing(`start_date`)) {
        stop("Missing required parameter `start_date`.")
      }

      if (missing(`end_lat`)) {
        stop("Missing required parameter `end_lat`.")
      }

      if (missing(`end_lng`)) {
        stop("Missing required parameter `end_lng`.")
      }

      if (missing(`end_date`)) {
        stop("Missing required parameter `end_date`.")
      }

      if (!missing(`leg_id`) && is.null(`leg_id`)) {
        stop("Invalid value for `leg_id` when calling TrackingApi$SaveTrackingStep, `leg_id` is not nullable")
      }

      if (!missing(`start_lat`) && is.null(`start_lat`)) {
        stop("Invalid value for `start_lat` when calling TrackingApi$SaveTrackingStep, `start_lat` is not nullable")
      }

      if (!missing(`start_lng`) && is.null(`start_lng`)) {
        stop("Invalid value for `start_lng` when calling TrackingApi$SaveTrackingStep, `start_lng` is not nullable")
      }

      if (!missing(`start_date`) && is.null(`start_date`)) {
        stop("Invalid value for `start_date` when calling TrackingApi$SaveTrackingStep, `start_date` is not nullable")
      }

      if (!missing(`end_lat`) && is.null(`end_lat`)) {
        stop("Invalid value for `end_lat` when calling TrackingApi$SaveTrackingStep, `end_lat` is not nullable")
      }

      if (!missing(`end_lng`) && is.null(`end_lng`)) {
        stop("Invalid value for `end_lng` when calling TrackingApi$SaveTrackingStep, `end_lng` is not nullable")
      }

      if (!missing(`end_date`) && is.null(`end_date`)) {
        stop("Invalid value for `end_date` when calling TrackingApi$SaveTrackingStep, `end_date` is not nullable")
      }

      if (!missing(`device_id`) && is.null(`device_id`)) {
        stop("Invalid value for `device_id` when calling TrackingApi$SaveTrackingStep, `device_id` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling TrackingApi$SaveTrackingStep, `account_id` is not nullable")
      }

      if (!missing(`distance`) && is.null(`distance`)) {
        stop("Invalid value for `distance` when calling TrackingApi$SaveTrackingStep, `distance` is not nullable")
      }

      if (!missing(`duration`) && is.null(`duration`)) {
        stop("Invalid value for `duration` when calling TrackingApi$SaveTrackingStep, `duration` is not nullable")
      }

      query_params[["deviceId"]] <- `device_id`

      query_params[["accountId"]] <- `account_id`

      query_params[["legId"]] <- `leg_id`

      query_params[["distance"]] <- `distance`

      query_params[["duration"]] <- `duration`

      query_params[["startLat"]] <- `start_lat`

      query_params[["startLng"]] <- `start_lng`

      query_params[["startDate"]] <- `start_date`

      query_params[["endLat"]] <- `end_lat`

      query_params[["endLng"]] <- `end_lng`

      query_params[["endDate"]] <- `end_date`

      local_var_url_path <- "/tracking/step/create"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "SirqulResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' List Tracking
    #'
    #' @param account_id The account id of the user
    #' @param keyword (optional) Used for LIKE search of first or last name on the acocunt
    #' @param start_date (optional) Range to begin in UTC milliseconds
    #' @param end_date (optional) Range to end in UTC milliseconds
    #' @param tags (optional) Exact match on tag field of Legs's searchTag
    #' @param audience_ids (optional) 
    #' @param latitude (optional) Origin latitude to perform searching constraints with given range
    #' @param longitude (optional) Origin longitude to perform searching constraints with given range
    #' @param range (optional) The radius, in miles, to perform the search for (default value: 5)
    #' @param sort_field (optional) The column to sort the search on. Possible values include: {LEG_START_DATE, ACCOUNT_DISPLAY} (default value: "LEG_START_DATE")
    #' @param descending (optional) The order to return the results. Default is false, which will return the results in ascending order. (default value: TRUE)
    #' @param start (optional) The index into the record set to start with. Default is 0. (default value: 0)
    #' @param limit (optional) The total number of records to return. Default is 20. (default value: 20)
    #' @param active_only (optional) Determines whether to return only active results. Default is false. (default value: FALSE)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return array[AccountMiniResponse]
    SearchAccountsWithTrackingLegs = function(account_id, keyword = NULL, start_date = NULL, end_date = NULL, tags = NULL, audience_ids = NULL, latitude = NULL, longitude = NULL, range = 5, sort_field = "LEG_START_DATE", descending = TRUE, start = 0, limit = 20, active_only = FALSE, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$SearchAccountsWithTrackingLegsWithHttpInfo(account_id, keyword, start_date, end_date, tags, audience_ids, latitude, longitude, range, sort_field, descending, start, limit, active_only, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' List Tracking
    #'
    #' @param account_id The account id of the user
    #' @param keyword (optional) Used for LIKE search of first or last name on the acocunt
    #' @param start_date (optional) Range to begin in UTC milliseconds
    #' @param end_date (optional) Range to end in UTC milliseconds
    #' @param tags (optional) Exact match on tag field of Legs's searchTag
    #' @param audience_ids (optional) 
    #' @param latitude (optional) Origin latitude to perform searching constraints with given range
    #' @param longitude (optional) Origin longitude to perform searching constraints with given range
    #' @param range (optional) The radius, in miles, to perform the search for (default value: 5)
    #' @param sort_field (optional) The column to sort the search on. Possible values include: {LEG_START_DATE, ACCOUNT_DISPLAY} (default value: "LEG_START_DATE")
    #' @param descending (optional) The order to return the results. Default is false, which will return the results in ascending order. (default value: TRUE)
    #' @param start (optional) The index into the record set to start with. Default is 0. (default value: 0)
    #' @param limit (optional) The total number of records to return. Default is 20. (default value: 20)
    #' @param active_only (optional) Determines whether to return only active results. Default is false. (default value: FALSE)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (array[AccountMiniResponse]) with additional information such as HTTP status code, headers
    SearchAccountsWithTrackingLegsWithHttpInfo = function(account_id, keyword = NULL, start_date = NULL, end_date = NULL, tags = NULL, audience_ids = NULL, latitude = NULL, longitude = NULL, range = 5, sort_field = "LEG_START_DATE", descending = TRUE, start = 0, limit = 20, active_only = FALSE, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling TrackingApi$SearchAccountsWithTrackingLegs, `account_id` is not nullable")
      }

      if (!missing(`keyword`) && is.null(`keyword`)) {
        stop("Invalid value for `keyword` when calling TrackingApi$SearchAccountsWithTrackingLegs, `keyword` is not nullable")
      }

      if (!missing(`start_date`) && is.null(`start_date`)) {
        stop("Invalid value for `start_date` when calling TrackingApi$SearchAccountsWithTrackingLegs, `start_date` is not nullable")
      }

      if (!missing(`end_date`) && is.null(`end_date`)) {
        stop("Invalid value for `end_date` when calling TrackingApi$SearchAccountsWithTrackingLegs, `end_date` is not nullable")
      }

      if (!missing(`tags`) && is.null(`tags`)) {
        stop("Invalid value for `tags` when calling TrackingApi$SearchAccountsWithTrackingLegs, `tags` is not nullable")
      }

      if (!missing(`audience_ids`) && is.null(`audience_ids`)) {
        stop("Invalid value for `audience_ids` when calling TrackingApi$SearchAccountsWithTrackingLegs, `audience_ids` is not nullable")
      }

      if (!missing(`latitude`) && is.null(`latitude`)) {
        stop("Invalid value for `latitude` when calling TrackingApi$SearchAccountsWithTrackingLegs, `latitude` is not nullable")
      }

      if (!missing(`longitude`) && is.null(`longitude`)) {
        stop("Invalid value for `longitude` when calling TrackingApi$SearchAccountsWithTrackingLegs, `longitude` is not nullable")
      }

      if (!missing(`range`) && is.null(`range`)) {
        stop("Invalid value for `range` when calling TrackingApi$SearchAccountsWithTrackingLegs, `range` is not nullable")
      }

      if (!missing(`sort_field`) && is.null(`sort_field`)) {
        stop("Invalid value for `sort_field` when calling TrackingApi$SearchAccountsWithTrackingLegs, `sort_field` is not nullable")
      }

      if (!missing(`descending`) && is.null(`descending`)) {
        stop("Invalid value for `descending` when calling TrackingApi$SearchAccountsWithTrackingLegs, `descending` is not nullable")
      }

      if (!missing(`start`) && is.null(`start`)) {
        stop("Invalid value for `start` when calling TrackingApi$SearchAccountsWithTrackingLegs, `start` is not nullable")
      }

      if (!missing(`limit`) && is.null(`limit`)) {
        stop("Invalid value for `limit` when calling TrackingApi$SearchAccountsWithTrackingLegs, `limit` is not nullable")
      }

      if (!missing(`active_only`) && is.null(`active_only`)) {
        stop("Invalid value for `active_only` when calling TrackingApi$SearchAccountsWithTrackingLegs, `active_only` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["keyword"]] <- `keyword`

      query_params[["startDate"]] <- `start_date`

      query_params[["endDate"]] <- `end_date`

      query_params[["tags"]] <- `tags`

      query_params[["audienceIds"]] <- `audience_ids`

      query_params[["latitude"]] <- `latitude`

      query_params[["longitude"]] <- `longitude`

      query_params[["range"]] <- `range`

      query_params[["sortField"]] <- `sort_field`

      query_params[["descending"]] <- `descending`

      query_params[["start"]] <- `start`

      query_params[["limit"]] <- `limit`

      query_params[["activeOnly"]] <- `active_only`

      local_var_url_path <- "/tracking/list"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "array[AccountMiniResponse]"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Search Tracking (Billable)
    #'
    #' @param account_id The account id to search tracking for
    #' @param app_key The application key
    #' @param tracking_device_id (optional) The id of the tracking device
    #' @param start_date (optional) The start date in (UTC milliseconds) to filter the tracking results
    #' @param end_date (optional) The end date in (UTC milliseconds) to filter the tracking results
    #' @param tags (optional) Filter results by tag
    #' @param start (optional) The start index for pagination (default value: 0)
    #' @param limit (optional) The limit for pagination (default value: 100)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return array[LegResponse]
    SearchTrackingLegs = function(account_id, app_key, tracking_device_id = NULL, start_date = NULL, end_date = NULL, tags = NULL, start = 0, limit = 100, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$SearchTrackingLegsWithHttpInfo(account_id, app_key, tracking_device_id, start_date, end_date, tags, start, limit, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Search Tracking (Billable)
    #'
    #' @param account_id The account id to search tracking for
    #' @param app_key The application key
    #' @param tracking_device_id (optional) The id of the tracking device
    #' @param start_date (optional) The start date in (UTC milliseconds) to filter the tracking results
    #' @param end_date (optional) The end date in (UTC milliseconds) to filter the tracking results
    #' @param tags (optional) Filter results by tag
    #' @param start (optional) The start index for pagination (default value: 0)
    #' @param limit (optional) The limit for pagination (default value: 100)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (array[LegResponse]) with additional information such as HTTP status code, headers
    SearchTrackingLegsWithHttpInfo = function(account_id, app_key, tracking_device_id = NULL, start_date = NULL, end_date = NULL, tags = NULL, start = 0, limit = 100, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (missing(`app_key`)) {
        stop("Missing required parameter `app_key`.")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling TrackingApi$SearchTrackingLegs, `account_id` is not nullable")
      }

      if (!missing(`app_key`) && is.null(`app_key`)) {
        stop("Invalid value for `app_key` when calling TrackingApi$SearchTrackingLegs, `app_key` is not nullable")
      }

      if (!missing(`tracking_device_id`) && is.null(`tracking_device_id`)) {
        stop("Invalid value for `tracking_device_id` when calling TrackingApi$SearchTrackingLegs, `tracking_device_id` is not nullable")
      }

      if (!missing(`start_date`) && is.null(`start_date`)) {
        stop("Invalid value for `start_date` when calling TrackingApi$SearchTrackingLegs, `start_date` is not nullable")
      }

      if (!missing(`end_date`) && is.null(`end_date`)) {
        stop("Invalid value for `end_date` when calling TrackingApi$SearchTrackingLegs, `end_date` is not nullable")
      }

      if (!missing(`tags`) && is.null(`tags`)) {
        stop("Invalid value for `tags` when calling TrackingApi$SearchTrackingLegs, `tags` is not nullable")
      }

      if (!missing(`start`) && is.null(`start`)) {
        stop("Invalid value for `start` when calling TrackingApi$SearchTrackingLegs, `start` is not nullable")
      }

      if (!missing(`limit`) && is.null(`limit`)) {
        stop("Invalid value for `limit` when calling TrackingApi$SearchTrackingLegs, `limit` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["appKey"]] <- `app_key`

      query_params[["trackingDeviceId"]] <- `tracking_device_id`

      query_params[["startDate"]] <- `start_date`

      query_params[["endDate"]] <- `end_date`

      query_params[["tags"]] <- `tags`

      query_params[["start"]] <- `start`

      query_params[["limit"]] <- `limit`

      local_var_url_path <- "/tracking/searchByBillable"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "array[LegResponse]"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    }
  )
)
