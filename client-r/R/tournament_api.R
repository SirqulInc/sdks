#' Sirqul IoT Platform
#'
#' Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
#'
#' The version of the OpenAPI document: 3.16
#' Contact: info@sirqul.com
#' Generated by: https://openapi-generator.tech
#'
#' @docType class
#' @title Tournament operations
#' @description TournamentApi
#' @format An \code{R6Class} generator object
#' @field api_client Handles the client-server communication.
#'
#' @examples
#' \dontrun{
#' ####################  CreateTournament  ####################
#'
#' library(openapi)
#' var_account_id <- 56 # integer | The logged in user.
#' var_app_key <- "app_key_example" # character | The appKey the tournament is created for.
#' var_title <- "title_example" # character | The title of the tournament
#' var_cost_to_play <- 56 # integer | The number of tickets required to pay to enter the tournament
#' var_start_date <- 56 # integer | The date/time to start the tournament
#' var_sub_type <- "sub_type_example" # character | Custom string client apps can use for searching/filtering tournaments (Optional)
#' var_image_asset_id <- 56 # integer | The asset ID to attach to the tournament (Optional)
#' var_seconds_between_levels <- 600 # integer | The number of seconds in between the start of each tournament game/group (Optional)
#' var_seconds_for_tie_breaker <- 600 # integer | The number of seconds to extend the round end time in the case of a tie breaker (Optional)
#' var_seconds_between_packs <- 86400 # integer | The number of seconds in between the start of each tournament round (Optional)
#' var_maximum_level_length <- 1800 # integer | The maximum number of seconds the match is expected to end at, which gets used to determine when a match should end when there is no activity (Optional)
#' var_cost_to_play_type <- "cost_to_play_type_example" # character | The type of ticket required to pay (Optional)
#' var_minimum_to_play <- 1 # integer | The minimum number of players required to sign up for the tournament to be played (Optional)
#' var_starting_limit <- 56 # integer | The starting number of players for a tournament (filled with AI's) (Optional)
#' var_available_limit <- 56 # integer | The maximum number of players for a tournament (currently 128 but not enforced) (Optional)
#' var_description <- "description_example" # character | The description of the tournament (Optional)
#' var_meta_data <- "meta_data_example" # character | External custom client defined data (Optional)
#' var_audience_ids <- "audience_ids_example" # character | The audiences associated with the tournament (Optional)
#' var_active <- "active_example" # character | Activate/deactivate the tournament (Optional)
#' var_enable_buy_back <- FALSE # character | Determines whether to allow players to buy back into a tournament (Optional)
#' var_offer_ids <- "offer_ids_example" # character | The list of offers to give as a reward beyond the tickets (Optional)
#' var_offer_asset_id <- 56 # integer | The artwork ID to attach to the reward tickets offers (Optional)
#' var_fixed_reward <- FALSE # character | If set then do not update the ticket reward, auto set to true if offerIds provided (Optional)
#' var_split_reward <- "ALL" # character | Set the rules for handling the reward in case of a tie, values: EVEN split the reward evenly ALL everyone gets the full reward value FIRST first score submitted RANDOM random player who scored (Optional)
#' var_allocate_tickets <- "allocate_tickets_example" # character | Flag to indicate owner should receive tickets for completed missions (Optional)
#' var_tournament_data <- "tournament_data_example" # character | A text based string that will be passed into each tournament setup to populate the content (Optional)
#' var_mission_type <- "MULTISTAGE" # character | The style of tournament to build, options are: TOURNAMENT, POOLPLAY (Optional)
#' var_visibility <- "PUBLIC" # character | Sets the visibility flag for the tournament (Optional)
#' var_preliminary_groups <- 1 # integer | The number of initial preliminary groups in a multi-stage tournament (this is expected to be a power of two number) (Optional)
#' var_preliminary_group_advancements <- "1" # character | This determines how many people can advance per round in a preliminary group (this is a comma separated list of integers) (Optional)
#' var_enable_multiple_entries <- FALSE # character | This determines if multiple submissions/entries are allowed in a multi-stage album tournament (Optional)
#' var_enable_multiple_votes <- FALSE # character | This determines if users are allowed to vote multiple times per group in a multi-stage album tournament (Optional)
#' var_featured <- FALSE # character | This determines whether the tournament is \"featured\" or not (Optional)
#' var_winner_tag <- "winner_tag_example" # character | This sets what analytic tag is used when a winner is determined (Optional)
#' var_tie_tag <- "tie_tag_example" # character | This sets what analytic tag is used when a tie has occurred (Optional)
#'
#' #Create Tournament
#' api_instance <- TournamentApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$CreateTournament(var_account_id, var_app_key, var_title, var_cost_to_play, var_start_date, sub_type = var_sub_type, image_asset_id = var_image_asset_id, seconds_between_levels = var_seconds_between_levels, seconds_for_tie_breaker = var_seconds_for_tie_breaker, seconds_between_packs = var_seconds_between_packs, maximum_level_length = var_maximum_level_length, cost_to_play_type = var_cost_to_play_type, minimum_to_play = var_minimum_to_play, starting_limit = var_starting_limit, available_limit = var_available_limit, description = var_description, meta_data = var_meta_data, audience_ids = var_audience_ids, active = var_active, enable_buy_back = var_enable_buy_back, offer_ids = var_offer_ids, offer_asset_id = var_offer_asset_id, fixed_reward = var_fixed_reward, split_reward = var_split_reward, allocate_tickets = var_allocate_tickets, tournament_data = var_tournament_data, mission_type = var_mission_type, visibility = var_visibility, preliminary_groups = var_preliminary_groups, preliminary_group_advancements = var_preliminary_group_advancements, enable_multiple_entries = var_enable_multiple_entries, enable_multiple_votes = var_enable_multiple_votes, featured = var_featured, winner_tag = var_winner_tag, tie_tag = var_tie_tagdata_file = "result.txt")
#' result <- api_instance$CreateTournament(var_account_id, var_app_key, var_title, var_cost_to_play, var_start_date, sub_type = var_sub_type, image_asset_id = var_image_asset_id, seconds_between_levels = var_seconds_between_levels, seconds_for_tie_breaker = var_seconds_for_tie_breaker, seconds_between_packs = var_seconds_between_packs, maximum_level_length = var_maximum_level_length, cost_to_play_type = var_cost_to_play_type, minimum_to_play = var_minimum_to_play, starting_limit = var_starting_limit, available_limit = var_available_limit, description = var_description, meta_data = var_meta_data, audience_ids = var_audience_ids, active = var_active, enable_buy_back = var_enable_buy_back, offer_ids = var_offer_ids, offer_asset_id = var_offer_asset_id, fixed_reward = var_fixed_reward, split_reward = var_split_reward, allocate_tickets = var_allocate_tickets, tournament_data = var_tournament_data, mission_type = var_mission_type, visibility = var_visibility, preliminary_groups = var_preliminary_groups, preliminary_group_advancements = var_preliminary_group_advancements, enable_multiple_entries = var_enable_multiple_entries, enable_multiple_votes = var_enable_multiple_votes, featured = var_featured, winner_tag = var_winner_tag, tie_tag = var_tie_tag)
#' dput(result)
#'
#'
#' ####################  DeleteTournament  ####################
#'
#' library(openapi)
#' var_account_id <- 56 # integer | the id of the logged in user
#' var_mission_id <- 56 # integer | the id of the mission to delete
#'
#' #Delete Tournament
#' api_instance <- TournamentApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$DeleteTournament(var_account_id, var_mission_iddata_file = "result.txt")
#' result <- api_instance$DeleteTournament(var_account_id, var_mission_id)
#' dput(result)
#'
#'
#' ####################  GetTournament  ####################
#'
#' library(openapi)
#' var_account_id <- 56 # integer | The id of the logged in user
#' var_mission_id <- 56 # integer | The id of the mission to return (either missionId or joinCode is required) (Optional)
#' var_join_code <- "join_code_example" # character | Optional identifier for getting the tournament (either missionId or joinCode is required) (Optional)
#' var_include_scores <- "include_scores_example" # character | Determines which type of scores are returned. Possible values include: ALL, MINE (Optional)
#' var_object_preview_size <- 50 # integer | Determines the max number of game objects that will get returned for each game level response (Optional)
#'
#' #Get Tournament
#' api_instance <- TournamentApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$GetTournament(var_account_id, mission_id = var_mission_id, join_code = var_join_code, include_scores = var_include_scores, object_preview_size = var_object_preview_sizedata_file = "result.txt")
#' result <- api_instance$GetTournament(var_account_id, mission_id = var_mission_id, join_code = var_join_code, include_scores = var_include_scores, object_preview_size = var_object_preview_size)
#' dput(result)
#'
#'
#' ####################  SearchObjects  ####################
#'
#' library(openapi)
#' var_account_id <- 56 # integer | the account ID
#' var_game_level_id <- 56 # integer | the game level id to filter results by
#' var_sort_field <- "PLAYER_SCORE_COUNT" # character | the field to sort by (Optional)
#' var_descending <- TRUE # character | determines whether the sorted list is in descending or ascending order (Optional)
#' var_start <- 0 # integer | the start index for pagination (Optional)
#' var_limit <- 20 # integer | the limit for pagination (Optional)
#'
#' #Search Tournament Objects
#' api_instance <- TournamentApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$SearchObjects(var_account_id, var_game_level_id, sort_field = var_sort_field, descending = var_descending, start = var_start, limit = var_limitdata_file = "result.txt")
#' result <- api_instance$SearchObjects(var_account_id, var_game_level_id, sort_field = var_sort_field, descending = var_descending, start = var_start, limit = var_limit)
#' dput(result)
#'
#'
#' ####################  SearchRounds  ####################
#'
#' library(openapi)
#' var_account_id <- 56 # integer | the account ID
#' var_app_key <- "app_key_example" # character | the application key
#' var_status <- "ACCEPTED,ACTIVE" # character | comma separated list of statuses to filter results by (Optional)
#' var_mission_type <- "mission_type_example" # character | The style of tournament to search for, options are: TOURNAMENT, POOLPLAY (Optional)
#' var_current_only <- TRUE # character | search for games that are flagged current only (Optional)
#' var_visibilities <- "PUBLIC" # character | Filter tournament rounds by the mission visibility flag (Optional)
#' var_start <- 0 # integer | the start index for pagination (Optional)
#' var_limit <- 20 # integer | the limit for pagination (Optional)
#'
#' #Search Tournament Rounds
#' api_instance <- TournamentApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$SearchRounds(var_account_id, var_app_key, status = var_status, mission_type = var_mission_type, current_only = var_current_only, visibilities = var_visibilities, start = var_start, limit = var_limitdata_file = "result.txt")
#' result <- api_instance$SearchRounds(var_account_id, var_app_key, status = var_status, mission_type = var_mission_type, current_only = var_current_only, visibilities = var_visibilities, start = var_start, limit = var_limit)
#' dput(result)
#'
#'
#' ####################  SearchTournaments  ####################
#'
#' library(openapi)
#' var_account_id <- 56 # integer | The logged in user.
#' var_app_key <- "app_key_example" # character | The application key
#' var_keyword <- "keyword_example" # character | the keyword to search tournament on (Optional)
#' var_sub_type <- "sub_type_example" # character | filter results by subType (Optional)
#' var_include_inactive <- FALSE # character | whether to include inactives in the search or not (Optional)
#' var_mission_types <- "MULTISTAGE,TOURNAMENT,POOLPLAY" # character | comma separated list of mission types to filter results, possbile values include: TOURNAMENT, POOLPLAY, MULTISTAGE (Optional)
#' var_filter <- "UPCOMING" # character | filter tournaments by the tournament's current state (Optional)
#' var_sort_field <- "START_DATE" # character | which field to sort on (Optional)
#' var_descending <- "descending_example" # character | Determines whether to return results in descending order. The default value will be true if the filter is \"PAST\", otherwise the default value will be false. (Optional)
#' var_visibility <- "PUBLIC" # character | Comma separated list of visibility flags for search for, possible values include: PUBLIC, LISTABLE, REWARDABLE, TRIGGERABLE, PRIVATE (Optional)
#' var_start <- 0 # integer | Start the result set at some index. (Optional)
#' var_limit <- 20 # integer | Limit the result to some number (Optional)
#'
#' #Search Tournaments
#' api_instance <- TournamentApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$SearchTournaments(var_account_id, var_app_key, keyword = var_keyword, sub_type = var_sub_type, include_inactive = var_include_inactive, mission_types = var_mission_types, filter = var_filter, sort_field = var_sort_field, descending = var_descending, visibility = var_visibility, start = var_start, limit = var_limitdata_file = "result.txt")
#' result <- api_instance$SearchTournaments(var_account_id, var_app_key, keyword = var_keyword, sub_type = var_sub_type, include_inactive = var_include_inactive, mission_types = var_mission_types, filter = var_filter, sort_field = var_sort_field, descending = var_descending, visibility = var_visibility, start = var_start, limit = var_limit)
#' dput(result)
#'
#'
#' ####################  SubmitTournamentScore  ####################
#'
#' library(openapi)
#' var_account_id <- 56 # integer | The logged in user account ID.
#' var_app_key <- "app_key_example" # character | The application key.
#' var_mission_id <- 56 # integer | The missionId to score for
#' var_game_id <- 56 # integer | The gameId to score for
#' var_pack_id <- 56 # integer | The packId to score for
#' var_scores <- "scores_example" # character | a JSON Array of scores to submit for a tournament match ```json [   {     \"accountId\": 2,     \"points\": 3   },   {     \"accountId\": 1777662,     \"points\": 7   } ] ``` 
#' var_game_level_id <- 56 # integer | The gameLevelId to score for (Optional)
#'
#' #Submit Tournament Score
#' api_instance <- TournamentApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$SubmitTournamentScore(var_account_id, var_app_key, var_mission_id, var_game_id, var_pack_id, var_scores, game_level_id = var_game_level_iddata_file = "result.txt")
#' result <- api_instance$SubmitTournamentScore(var_account_id, var_app_key, var_mission_id, var_game_id, var_pack_id, var_scores, game_level_id = var_game_level_id)
#' dput(result)
#'
#'
#' ####################  SubmitTournamentVote  ####################
#'
#' library(openapi)
#' var_account_id <- 56 # integer | The logged in user.
#' var_app_key <- "app_key_example" # character | The application to target
#' var_mission_id <- 56 # integer | The tournament's primary id
#' var_game_object_id <- 56 # integer | The tournament game object the user wants to vote on
#' var_device_id <- "device_id_example" # character | The unique id of the device making the request (optional) (Optional)
#' var_check_if_device_already_voted <- FALSE # character | When true, check if the device already voted to prevent duplicate votes from the same device (Optional)
#'
#' #Submit a vote for a multi-stage album tournament.
#' api_instance <- TournamentApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$SubmitTournamentVote(var_account_id, var_app_key, var_mission_id, var_game_object_id, device_id = var_device_id, check_if_device_already_voted = var_check_if_device_already_voteddata_file = "result.txt")
#' result <- api_instance$SubmitTournamentVote(var_account_id, var_app_key, var_mission_id, var_game_object_id, device_id = var_device_id, check_if_device_already_voted = var_check_if_device_already_voted)
#' dput(result)
#'
#'
#' ####################  SubstituteTournamentPlayer  ####################
#'
#' library(openapi)
#' var_account_id <- 56 # integer | the id of the logged in user
#' var_mission_id <- 56 # integer | the id of the mission
#' var_pack_id <- 56 # integer | the id of the pack
#' var_game_level_id <- 56 # integer | the id of the game level
#'
#' #Substitute Tournament Player
#' api_instance <- TournamentApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$SubstituteTournamentPlayer(var_account_id, var_mission_id, var_pack_id, var_game_level_iddata_file = "result.txt")
#' result <- api_instance$SubstituteTournamentPlayer(var_account_id, var_mission_id, var_pack_id, var_game_level_id)
#' dput(result)
#'
#'
#' ####################  UpdateTournament  ####################
#'
#' library(openapi)
#' var_account_id <- 56 # integer | The logged in user.
#' var_mission_id <- 56 # integer | The mission/tournament to update
#' var_title <- "title_example" # character | The title of the tournament (Optional)
#' var_sub_type <- "sub_type_example" # character | Custom string client apps can use for searching/filtering missions (Optional)
#' var_image_asset_id <- 56 # integer | The asset ID to attach to the tournament (Optional)
#' var_seconds_between_levels <- 56 # integer | The number of seconds in between the start of each tournament game (Optional)
#' var_seconds_for_tie_breaker <- 56 # integer | The number of seconds to extend the round end time in the case of a tie breaker (Optional)
#' var_seconds_between_packs <- 56 # integer | The number of seconds in between the start of each tournament round (Optional)
#' var_maximum_level_length <- 56 # integer | The maximum number of seconds the match is expected to end at, which gets used to determine when a match should end when there is no activity (Optional)
#' var_cost_to_play <- 56 # integer | The number of tickets required to pay to enter the tournament (Optional)
#' var_cost_to_play_type <- "cost_to_play_type_example" # character | The type of ticket required to pay (Optional)
#' var_minimum_to_play <- 56 # integer | The minimum number of players required to sign up for the tournament to be played (Optional)
#' var_starting_limit <- 56 # integer | The starting number of players for a tournament (filled with AI's) (Optional)
#' var_available_limit <- 56 # integer | The maximum number of players for a tournament (currently 128 but not enforced) (Optional)
#' var_description <- "description_example" # character | The description of the tournament (Optional)
#' var_meta_data <- "meta_data_example" # character | External custom client defined data (Optional)
#' var_start_date <- 56 # integer | The date/time to start the tournament (Optional)
#' var_audience_ids <- "audience_ids_example" # character | The audiences associated with the tournament (Optional)
#' var_active <- "active_example" # character | Activate/deactivate the mission (Optional)
#' var_enable_buy_back <- "enable_buy_back_example" # character | Determines whether to allow players to buy back into a tournament (Optional)
#' var_offer_ids <- "offer_ids_example" # character | The list of offers to give as a reward beyond the tickets (Optional)
#' var_offer_asset_id <- 56 # integer | The artwork ID to attach to the reward offer (Optional)
#' var_fixed_reward <- "fixed_reward_example" # character | If set then do not update the ticket reward, auto set to true if offerIds provided (Optional)
#' var_split_reward <- "split_reward_example" # character | Set the rules for handling the reward in case of a tie, values: EVEN split the reward evenly ALL everyone gets the full reward value FIRST first score submitted RANDOM random player who scored (Optional)
#' var_allocate_tickets <- "allocate_tickets_example" # character | Flag to indicate owner should receive tickets for completed missions (Optional)
#' var_tournament_data <- "tournament_data_example" # character | A text based string that will be passed into each tournament setup to populate the content (Optional)
#' var_visibility <- "visibility_example" # character | Sets the visibility flag for the tournament (Optional)
#' var_preliminary_groups <- 56 # integer | The number of initial preliminary groups in a multi-stage tournament (this is expected to be a power of two number) (Optional)
#' var_preliminary_group_advancements <- "preliminary_group_advancements_example" # character | This determines how many people can advance per round in a preliminary group (this is a comma separated list of integers) (Optional)
#' var_enable_multiple_entries <- "enable_multiple_entries_example" # character | This determines if multiple submissions/entries are allowed in a multi-stage album tournament (Optional)
#' var_enable_multiple_votes <- "enable_multiple_votes_example" # character | This determines if users are allowed to vote multiple times per group in a multi-stage album tournament (Optional)
#' var_featured <- "featured_example" # character | This determines whether the tournament is \"featured\" or not (Optional)
#' var_winner_tag <- "winner_tag_example" # character | This sets what analytic tag is used when a winner is determined (Optional)
#' var_tie_tag <- "tie_tag_example" # character | This sets what analytic tag is used when a winner is determined (Optional)
#'
#' #Update Tournament
#' api_instance <- TournamentApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$UpdateTournament(var_account_id, var_mission_id, title = var_title, sub_type = var_sub_type, image_asset_id = var_image_asset_id, seconds_between_levels = var_seconds_between_levels, seconds_for_tie_breaker = var_seconds_for_tie_breaker, seconds_between_packs = var_seconds_between_packs, maximum_level_length = var_maximum_level_length, cost_to_play = var_cost_to_play, cost_to_play_type = var_cost_to_play_type, minimum_to_play = var_minimum_to_play, starting_limit = var_starting_limit, available_limit = var_available_limit, description = var_description, meta_data = var_meta_data, start_date = var_start_date, audience_ids = var_audience_ids, active = var_active, enable_buy_back = var_enable_buy_back, offer_ids = var_offer_ids, offer_asset_id = var_offer_asset_id, fixed_reward = var_fixed_reward, split_reward = var_split_reward, allocate_tickets = var_allocate_tickets, tournament_data = var_tournament_data, visibility = var_visibility, preliminary_groups = var_preliminary_groups, preliminary_group_advancements = var_preliminary_group_advancements, enable_multiple_entries = var_enable_multiple_entries, enable_multiple_votes = var_enable_multiple_votes, featured = var_featured, winner_tag = var_winner_tag, tie_tag = var_tie_tagdata_file = "result.txt")
#' result <- api_instance$UpdateTournament(var_account_id, var_mission_id, title = var_title, sub_type = var_sub_type, image_asset_id = var_image_asset_id, seconds_between_levels = var_seconds_between_levels, seconds_for_tie_breaker = var_seconds_for_tie_breaker, seconds_between_packs = var_seconds_between_packs, maximum_level_length = var_maximum_level_length, cost_to_play = var_cost_to_play, cost_to_play_type = var_cost_to_play_type, minimum_to_play = var_minimum_to_play, starting_limit = var_starting_limit, available_limit = var_available_limit, description = var_description, meta_data = var_meta_data, start_date = var_start_date, audience_ids = var_audience_ids, active = var_active, enable_buy_back = var_enable_buy_back, offer_ids = var_offer_ids, offer_asset_id = var_offer_asset_id, fixed_reward = var_fixed_reward, split_reward = var_split_reward, allocate_tickets = var_allocate_tickets, tournament_data = var_tournament_data, visibility = var_visibility, preliminary_groups = var_preliminary_groups, preliminary_group_advancements = var_preliminary_group_advancements, enable_multiple_entries = var_enable_multiple_entries, enable_multiple_votes = var_enable_multiple_votes, featured = var_featured, winner_tag = var_winner_tag, tie_tag = var_tie_tag)
#' dput(result)
#'
#'
#' }
#' @importFrom R6 R6Class
#' @importFrom base64enc base64encode
#' @export
TournamentApi <- R6::R6Class(
  "TournamentApi",
  public = list(
    api_client = NULL,

    #' @description
    #' Initialize a new TournamentApi.
    #'
    #' @param api_client An instance of API client.
    initialize = function(api_client) {
      if (!missing(api_client)) {
        self$api_client <- api_client
      } else {
        self$api_client <- ApiClient$new()
      }
    },

    #' @description
    #' Create Tournament
    #'
    #' @param account_id The logged in user.
    #' @param app_key The appKey the tournament is created for.
    #' @param title The title of the tournament
    #' @param cost_to_play The number of tickets required to pay to enter the tournament
    #' @param start_date The date/time to start the tournament
    #' @param sub_type (optional) Custom string client apps can use for searching/filtering tournaments
    #' @param image_asset_id (optional) The asset ID to attach to the tournament
    #' @param seconds_between_levels (optional) The number of seconds in between the start of each tournament game/group (default value: 600)
    #' @param seconds_for_tie_breaker (optional) The number of seconds to extend the round end time in the case of a tie breaker (default value: 600)
    #' @param seconds_between_packs (optional) The number of seconds in between the start of each tournament round (default value: 86400)
    #' @param maximum_level_length (optional) The maximum number of seconds the match is expected to end at, which gets used to determine when a match should end when there is no activity (default value: 1800)
    #' @param cost_to_play_type (optional) The type of ticket required to pay
    #' @param minimum_to_play (optional) The minimum number of players required to sign up for the tournament to be played (default value: 1)
    #' @param starting_limit (optional) The starting number of players for a tournament (filled with AI's)
    #' @param available_limit (optional) The maximum number of players for a tournament (currently 128 but not enforced)
    #' @param description (optional) The description of the tournament
    #' @param meta_data (optional) External custom client defined data
    #' @param audience_ids (optional) The audiences associated with the tournament
    #' @param active (optional) Activate/deactivate the tournament
    #' @param enable_buy_back (optional) Determines whether to allow players to buy back into a tournament (default value: FALSE)
    #' @param offer_ids (optional) The list of offers to give as a reward beyond the tickets
    #' @param offer_asset_id (optional) The artwork ID to attach to the reward tickets offers
    #' @param fixed_reward (optional) If set then do not update the ticket reward, auto set to true if offerIds provided (default value: FALSE)
    #' @param split_reward (optional) Set the rules for handling the reward in case of a tie, values: EVEN split the reward evenly ALL everyone gets the full reward value FIRST first score submitted RANDOM random player who scored (default value: "ALL")
    #' @param allocate_tickets (optional) Flag to indicate owner should receive tickets for completed missions
    #' @param tournament_data (optional) A text based string that will be passed into each tournament setup to populate the content
    #' @param mission_type (optional) The style of tournament to build, options are: TOURNAMENT, POOLPLAY (default value: "MULTISTAGE")
    #' @param visibility (optional) Sets the visibility flag for the tournament (default value: "PUBLIC")
    #' @param preliminary_groups (optional) The number of initial preliminary groups in a multi-stage tournament (this is expected to be a power of two number) (default value: 1)
    #' @param preliminary_group_advancements (optional) This determines how many people can advance per round in a preliminary group (this is a comma separated list of integers) (default value: "1")
    #' @param enable_multiple_entries (optional) This determines if multiple submissions/entries are allowed in a multi-stage album tournament (default value: FALSE)
    #' @param enable_multiple_votes (optional) This determines if users are allowed to vote multiple times per group in a multi-stage album tournament (default value: FALSE)
    #' @param featured (optional) This determines whether the tournament is \"featured\" or not (default value: FALSE)
    #' @param winner_tag (optional) This sets what analytic tag is used when a winner is determined
    #' @param tie_tag (optional) This sets what analytic tag is used when a tie has occurred
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return TournamentResponse
    CreateTournament = function(account_id, app_key, title, cost_to_play, start_date, sub_type = NULL, image_asset_id = NULL, seconds_between_levels = 600, seconds_for_tie_breaker = 600, seconds_between_packs = 86400, maximum_level_length = 1800, cost_to_play_type = NULL, minimum_to_play = 1, starting_limit = NULL, available_limit = NULL, description = NULL, meta_data = NULL, audience_ids = NULL, active = NULL, enable_buy_back = FALSE, offer_ids = NULL, offer_asset_id = NULL, fixed_reward = FALSE, split_reward = "ALL", allocate_tickets = NULL, tournament_data = NULL, mission_type = "MULTISTAGE", visibility = "PUBLIC", preliminary_groups = 1, preliminary_group_advancements = "1", enable_multiple_entries = FALSE, enable_multiple_votes = FALSE, featured = FALSE, winner_tag = NULL, tie_tag = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$CreateTournamentWithHttpInfo(account_id, app_key, title, cost_to_play, start_date, sub_type, image_asset_id, seconds_between_levels, seconds_for_tie_breaker, seconds_between_packs, maximum_level_length, cost_to_play_type, minimum_to_play, starting_limit, available_limit, description, meta_data, audience_ids, active, enable_buy_back, offer_ids, offer_asset_id, fixed_reward, split_reward, allocate_tickets, tournament_data, mission_type, visibility, preliminary_groups, preliminary_group_advancements, enable_multiple_entries, enable_multiple_votes, featured, winner_tag, tie_tag, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Create Tournament
    #'
    #' @param account_id The logged in user.
    #' @param app_key The appKey the tournament is created for.
    #' @param title The title of the tournament
    #' @param cost_to_play The number of tickets required to pay to enter the tournament
    #' @param start_date The date/time to start the tournament
    #' @param sub_type (optional) Custom string client apps can use for searching/filtering tournaments
    #' @param image_asset_id (optional) The asset ID to attach to the tournament
    #' @param seconds_between_levels (optional) The number of seconds in between the start of each tournament game/group (default value: 600)
    #' @param seconds_for_tie_breaker (optional) The number of seconds to extend the round end time in the case of a tie breaker (default value: 600)
    #' @param seconds_between_packs (optional) The number of seconds in between the start of each tournament round (default value: 86400)
    #' @param maximum_level_length (optional) The maximum number of seconds the match is expected to end at, which gets used to determine when a match should end when there is no activity (default value: 1800)
    #' @param cost_to_play_type (optional) The type of ticket required to pay
    #' @param minimum_to_play (optional) The minimum number of players required to sign up for the tournament to be played (default value: 1)
    #' @param starting_limit (optional) The starting number of players for a tournament (filled with AI's)
    #' @param available_limit (optional) The maximum number of players for a tournament (currently 128 but not enforced)
    #' @param description (optional) The description of the tournament
    #' @param meta_data (optional) External custom client defined data
    #' @param audience_ids (optional) The audiences associated with the tournament
    #' @param active (optional) Activate/deactivate the tournament
    #' @param enable_buy_back (optional) Determines whether to allow players to buy back into a tournament (default value: FALSE)
    #' @param offer_ids (optional) The list of offers to give as a reward beyond the tickets
    #' @param offer_asset_id (optional) The artwork ID to attach to the reward tickets offers
    #' @param fixed_reward (optional) If set then do not update the ticket reward, auto set to true if offerIds provided (default value: FALSE)
    #' @param split_reward (optional) Set the rules for handling the reward in case of a tie, values: EVEN split the reward evenly ALL everyone gets the full reward value FIRST first score submitted RANDOM random player who scored (default value: "ALL")
    #' @param allocate_tickets (optional) Flag to indicate owner should receive tickets for completed missions
    #' @param tournament_data (optional) A text based string that will be passed into each tournament setup to populate the content
    #' @param mission_type (optional) The style of tournament to build, options are: TOURNAMENT, POOLPLAY (default value: "MULTISTAGE")
    #' @param visibility (optional) Sets the visibility flag for the tournament (default value: "PUBLIC")
    #' @param preliminary_groups (optional) The number of initial preliminary groups in a multi-stage tournament (this is expected to be a power of two number) (default value: 1)
    #' @param preliminary_group_advancements (optional) This determines how many people can advance per round in a preliminary group (this is a comma separated list of integers) (default value: "1")
    #' @param enable_multiple_entries (optional) This determines if multiple submissions/entries are allowed in a multi-stage album tournament (default value: FALSE)
    #' @param enable_multiple_votes (optional) This determines if users are allowed to vote multiple times per group in a multi-stage album tournament (default value: FALSE)
    #' @param featured (optional) This determines whether the tournament is \"featured\" or not (default value: FALSE)
    #' @param winner_tag (optional) This sets what analytic tag is used when a winner is determined
    #' @param tie_tag (optional) This sets what analytic tag is used when a tie has occurred
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (TournamentResponse) with additional information such as HTTP status code, headers
    CreateTournamentWithHttpInfo = function(account_id, app_key, title, cost_to_play, start_date, sub_type = NULL, image_asset_id = NULL, seconds_between_levels = 600, seconds_for_tie_breaker = 600, seconds_between_packs = 86400, maximum_level_length = 1800, cost_to_play_type = NULL, minimum_to_play = 1, starting_limit = NULL, available_limit = NULL, description = NULL, meta_data = NULL, audience_ids = NULL, active = NULL, enable_buy_back = FALSE, offer_ids = NULL, offer_asset_id = NULL, fixed_reward = FALSE, split_reward = "ALL", allocate_tickets = NULL, tournament_data = NULL, mission_type = "MULTISTAGE", visibility = "PUBLIC", preliminary_groups = 1, preliminary_group_advancements = "1", enable_multiple_entries = FALSE, enable_multiple_votes = FALSE, featured = FALSE, winner_tag = NULL, tie_tag = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (missing(`app_key`)) {
        stop("Missing required parameter `app_key`.")
      }

      if (missing(`title`)) {
        stop("Missing required parameter `title`.")
      }

      if (missing(`cost_to_play`)) {
        stop("Missing required parameter `cost_to_play`.")
      }

      if (missing(`start_date`)) {
        stop("Missing required parameter `start_date`.")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling TournamentApi$CreateTournament, `account_id` is not nullable")
      }

      if (!missing(`app_key`) && is.null(`app_key`)) {
        stop("Invalid value for `app_key` when calling TournamentApi$CreateTournament, `app_key` is not nullable")
      }

      if (!missing(`title`) && is.null(`title`)) {
        stop("Invalid value for `title` when calling TournamentApi$CreateTournament, `title` is not nullable")
      }

      if (!missing(`cost_to_play`) && is.null(`cost_to_play`)) {
        stop("Invalid value for `cost_to_play` when calling TournamentApi$CreateTournament, `cost_to_play` is not nullable")
      }

      if (!missing(`start_date`) && is.null(`start_date`)) {
        stop("Invalid value for `start_date` when calling TournamentApi$CreateTournament, `start_date` is not nullable")
      }

      if (!missing(`sub_type`) && is.null(`sub_type`)) {
        stop("Invalid value for `sub_type` when calling TournamentApi$CreateTournament, `sub_type` is not nullable")
      }

      if (!missing(`image_asset_id`) && is.null(`image_asset_id`)) {
        stop("Invalid value for `image_asset_id` when calling TournamentApi$CreateTournament, `image_asset_id` is not nullable")
      }

      if (!missing(`seconds_between_levels`) && is.null(`seconds_between_levels`)) {
        stop("Invalid value for `seconds_between_levels` when calling TournamentApi$CreateTournament, `seconds_between_levels` is not nullable")
      }

      if (!missing(`seconds_for_tie_breaker`) && is.null(`seconds_for_tie_breaker`)) {
        stop("Invalid value for `seconds_for_tie_breaker` when calling TournamentApi$CreateTournament, `seconds_for_tie_breaker` is not nullable")
      }

      if (!missing(`seconds_between_packs`) && is.null(`seconds_between_packs`)) {
        stop("Invalid value for `seconds_between_packs` when calling TournamentApi$CreateTournament, `seconds_between_packs` is not nullable")
      }

      if (!missing(`maximum_level_length`) && is.null(`maximum_level_length`)) {
        stop("Invalid value for `maximum_level_length` when calling TournamentApi$CreateTournament, `maximum_level_length` is not nullable")
      }

      if (!missing(`cost_to_play_type`) && is.null(`cost_to_play_type`)) {
        stop("Invalid value for `cost_to_play_type` when calling TournamentApi$CreateTournament, `cost_to_play_type` is not nullable")
      }

      if (!missing(`minimum_to_play`) && is.null(`minimum_to_play`)) {
        stop("Invalid value for `minimum_to_play` when calling TournamentApi$CreateTournament, `minimum_to_play` is not nullable")
      }

      if (!missing(`starting_limit`) && is.null(`starting_limit`)) {
        stop("Invalid value for `starting_limit` when calling TournamentApi$CreateTournament, `starting_limit` is not nullable")
      }

      if (!missing(`available_limit`) && is.null(`available_limit`)) {
        stop("Invalid value for `available_limit` when calling TournamentApi$CreateTournament, `available_limit` is not nullable")
      }

      if (!missing(`description`) && is.null(`description`)) {
        stop("Invalid value for `description` when calling TournamentApi$CreateTournament, `description` is not nullable")
      }

      if (!missing(`meta_data`) && is.null(`meta_data`)) {
        stop("Invalid value for `meta_data` when calling TournamentApi$CreateTournament, `meta_data` is not nullable")
      }

      if (!missing(`audience_ids`) && is.null(`audience_ids`)) {
        stop("Invalid value for `audience_ids` when calling TournamentApi$CreateTournament, `audience_ids` is not nullable")
      }

      if (!missing(`active`) && is.null(`active`)) {
        stop("Invalid value for `active` when calling TournamentApi$CreateTournament, `active` is not nullable")
      }

      if (!missing(`enable_buy_back`) && is.null(`enable_buy_back`)) {
        stop("Invalid value for `enable_buy_back` when calling TournamentApi$CreateTournament, `enable_buy_back` is not nullable")
      }

      if (!missing(`offer_ids`) && is.null(`offer_ids`)) {
        stop("Invalid value for `offer_ids` when calling TournamentApi$CreateTournament, `offer_ids` is not nullable")
      }

      if (!missing(`offer_asset_id`) && is.null(`offer_asset_id`)) {
        stop("Invalid value for `offer_asset_id` when calling TournamentApi$CreateTournament, `offer_asset_id` is not nullable")
      }

      if (!missing(`fixed_reward`) && is.null(`fixed_reward`)) {
        stop("Invalid value for `fixed_reward` when calling TournamentApi$CreateTournament, `fixed_reward` is not nullable")
      }

      if (!missing(`split_reward`) && is.null(`split_reward`)) {
        stop("Invalid value for `split_reward` when calling TournamentApi$CreateTournament, `split_reward` is not nullable")
      }

      if (!missing(`allocate_tickets`) && is.null(`allocate_tickets`)) {
        stop("Invalid value for `allocate_tickets` when calling TournamentApi$CreateTournament, `allocate_tickets` is not nullable")
      }

      if (!missing(`tournament_data`) && is.null(`tournament_data`)) {
        stop("Invalid value for `tournament_data` when calling TournamentApi$CreateTournament, `tournament_data` is not nullable")
      }

      if (!missing(`mission_type`) && is.null(`mission_type`)) {
        stop("Invalid value for `mission_type` when calling TournamentApi$CreateTournament, `mission_type` is not nullable")
      }

      if (!missing(`visibility`) && is.null(`visibility`)) {
        stop("Invalid value for `visibility` when calling TournamentApi$CreateTournament, `visibility` is not nullable")
      }

      if (!missing(`preliminary_groups`) && is.null(`preliminary_groups`)) {
        stop("Invalid value for `preliminary_groups` when calling TournamentApi$CreateTournament, `preliminary_groups` is not nullable")
      }

      if (!missing(`preliminary_group_advancements`) && is.null(`preliminary_group_advancements`)) {
        stop("Invalid value for `preliminary_group_advancements` when calling TournamentApi$CreateTournament, `preliminary_group_advancements` is not nullable")
      }

      if (!missing(`enable_multiple_entries`) && is.null(`enable_multiple_entries`)) {
        stop("Invalid value for `enable_multiple_entries` when calling TournamentApi$CreateTournament, `enable_multiple_entries` is not nullable")
      }

      if (!missing(`enable_multiple_votes`) && is.null(`enable_multiple_votes`)) {
        stop("Invalid value for `enable_multiple_votes` when calling TournamentApi$CreateTournament, `enable_multiple_votes` is not nullable")
      }

      if (!missing(`featured`) && is.null(`featured`)) {
        stop("Invalid value for `featured` when calling TournamentApi$CreateTournament, `featured` is not nullable")
      }

      if (!missing(`winner_tag`) && is.null(`winner_tag`)) {
        stop("Invalid value for `winner_tag` when calling TournamentApi$CreateTournament, `winner_tag` is not nullable")
      }

      if (!missing(`tie_tag`) && is.null(`tie_tag`)) {
        stop("Invalid value for `tie_tag` when calling TournamentApi$CreateTournament, `tie_tag` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["appKey"]] <- `app_key`

      query_params[["title"]] <- `title`

      query_params[["subType"]] <- `sub_type`

      query_params[["imageAssetId"]] <- `image_asset_id`

      query_params[["secondsBetweenLevels"]] <- `seconds_between_levels`

      query_params[["secondsForTieBreaker"]] <- `seconds_for_tie_breaker`

      query_params[["secondsBetweenPacks"]] <- `seconds_between_packs`

      query_params[["maximumLevelLength"]] <- `maximum_level_length`

      query_params[["costToPlay"]] <- `cost_to_play`

      query_params[["costToPlayType"]] <- `cost_to_play_type`

      query_params[["minimumToPlay"]] <- `minimum_to_play`

      query_params[["startingLimit"]] <- `starting_limit`

      query_params[["availableLimit"]] <- `available_limit`

      query_params[["description"]] <- `description`

      query_params[["metaData"]] <- `meta_data`

      query_params[["startDate"]] <- `start_date`

      query_params[["audienceIds"]] <- `audience_ids`

      query_params[["active"]] <- `active`

      query_params[["enableBuyBack"]] <- `enable_buy_back`

      query_params[["offerIds"]] <- `offer_ids`

      query_params[["offerAssetId"]] <- `offer_asset_id`

      query_params[["fixedReward"]] <- `fixed_reward`

      if (!is.null(`split_reward`) && !(`split_reward` %in% c("EVEN", "ALL", "FIRST", "RANDOM"))) {
        stop("Invalid value for split_reward when calling TournamentApi$CreateTournament. Must be [EVEN, ALL, FIRST, RANDOM].")
      }
      query_params[["splitReward"]] <- `split_reward`

      query_params[["allocateTickets"]] <- `allocate_tickets`

      query_params[["tournamentData"]] <- `tournament_data`

      if (!is.null(`mission_type`) && !(`mission_type` %in% c("TOURNAMENT", "POOLPLAY", "MULTISTAGE"))) {
        stop("Invalid value for mission_type when calling TournamentApi$CreateTournament. Must be [TOURNAMENT, POOLPLAY, MULTISTAGE].")
      }
      query_params[["missionType"]] <- `mission_type`

      if (!is.null(`visibility`) && !(`visibility` %in% c("PUBLIC", "LISTABLE", "REWARDABLE", "TRIGGERABLE", "PRIVATE"))) {
        stop("Invalid value for visibility when calling TournamentApi$CreateTournament. Must be [PUBLIC, LISTABLE, REWARDABLE, TRIGGERABLE, PRIVATE].")
      }
      query_params[["visibility"]] <- `visibility`

      query_params[["preliminaryGroups"]] <- `preliminary_groups`

      query_params[["preliminaryGroupAdvancements"]] <- `preliminary_group_advancements`

      query_params[["enableMultipleEntries"]] <- `enable_multiple_entries`

      query_params[["enableMultipleVotes"]] <- `enable_multiple_votes`

      query_params[["featured"]] <- `featured`

      query_params[["winnerTag"]] <- `winner_tag`

      query_params[["tieTag"]] <- `tie_tag`

      local_var_url_path <- "/tournament/create"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "TournamentResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Delete Tournament
    #'
    #' @param account_id the id of the logged in user
    #' @param mission_id the id of the mission to delete
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return SirqulResponse
    DeleteTournament = function(account_id, mission_id, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$DeleteTournamentWithHttpInfo(account_id, mission_id, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Delete Tournament
    #'
    #' @param account_id the id of the logged in user
    #' @param mission_id the id of the mission to delete
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (SirqulResponse) with additional information such as HTTP status code, headers
    DeleteTournamentWithHttpInfo = function(account_id, mission_id, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (missing(`mission_id`)) {
        stop("Missing required parameter `mission_id`.")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling TournamentApi$DeleteTournament, `account_id` is not nullable")
      }

      if (!missing(`mission_id`) && is.null(`mission_id`)) {
        stop("Invalid value for `mission_id` when calling TournamentApi$DeleteTournament, `mission_id` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["missionId"]] <- `mission_id`

      local_var_url_path <- "/tournament/delete"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "SirqulResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Get Tournament
    #'
    #' @param account_id The id of the logged in user
    #' @param mission_id (optional) The id of the mission to return (either missionId or joinCode is required)
    #' @param join_code (optional) Optional identifier for getting the tournament (either missionId or joinCode is required)
    #' @param include_scores (optional) Determines which type of scores are returned. Possible values include: ALL, MINE
    #' @param object_preview_size (optional) Determines the max number of game objects that will get returned for each game level response (default value: 50)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return TournamentResponse
    GetTournament = function(account_id, mission_id = NULL, join_code = NULL, include_scores = NULL, object_preview_size = 50, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$GetTournamentWithHttpInfo(account_id, mission_id, join_code, include_scores, object_preview_size, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Get Tournament
    #'
    #' @param account_id The id of the logged in user
    #' @param mission_id (optional) The id of the mission to return (either missionId or joinCode is required)
    #' @param join_code (optional) Optional identifier for getting the tournament (either missionId or joinCode is required)
    #' @param include_scores (optional) Determines which type of scores are returned. Possible values include: ALL, MINE
    #' @param object_preview_size (optional) Determines the max number of game objects that will get returned for each game level response (default value: 50)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (TournamentResponse) with additional information such as HTTP status code, headers
    GetTournamentWithHttpInfo = function(account_id, mission_id = NULL, join_code = NULL, include_scores = NULL, object_preview_size = 50, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling TournamentApi$GetTournament, `account_id` is not nullable")
      }

      if (!missing(`mission_id`) && is.null(`mission_id`)) {
        stop("Invalid value for `mission_id` when calling TournamentApi$GetTournament, `mission_id` is not nullable")
      }

      if (!missing(`join_code`) && is.null(`join_code`)) {
        stop("Invalid value for `join_code` when calling TournamentApi$GetTournament, `join_code` is not nullable")
      }

      if (!missing(`include_scores`) && is.null(`include_scores`)) {
        stop("Invalid value for `include_scores` when calling TournamentApi$GetTournament, `include_scores` is not nullable")
      }

      if (!missing(`object_preview_size`) && is.null(`object_preview_size`)) {
        stop("Invalid value for `object_preview_size` when calling TournamentApi$GetTournament, `object_preview_size` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["missionId"]] <- `mission_id`

      query_params[["joinCode"]] <- `join_code`

      if (!is.null(`include_scores`) && !(`include_scores` %in% c("ALL", "MINE"))) {
        stop("Invalid value for include_scores when calling TournamentApi$GetTournament. Must be [ALL, MINE].")
      }
      query_params[["includeScores"]] <- `include_scores`

      query_params[["objectPreviewSize"]] <- `object_preview_size`

      local_var_url_path <- "/tournament/get"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "TournamentResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Search Tournament Objects
    #'
    #' @param account_id the account ID
    #' @param game_level_id the game level id to filter results by
    #' @param sort_field (optional) the field to sort by (default value: "PLAYER_SCORE_COUNT")
    #' @param descending (optional) determines whether the sorted list is in descending or ascending order (default value: TRUE)
    #' @param start (optional) the start index for pagination (default value: 0)
    #' @param limit (optional) the limit for pagination (default value: 20)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return SirqulResponse
    SearchObjects = function(account_id, game_level_id, sort_field = "PLAYER_SCORE_COUNT", descending = TRUE, start = 0, limit = 20, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$SearchObjectsWithHttpInfo(account_id, game_level_id, sort_field, descending, start, limit, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Search Tournament Objects
    #'
    #' @param account_id the account ID
    #' @param game_level_id the game level id to filter results by
    #' @param sort_field (optional) the field to sort by (default value: "PLAYER_SCORE_COUNT")
    #' @param descending (optional) determines whether the sorted list is in descending or ascending order (default value: TRUE)
    #' @param start (optional) the start index for pagination (default value: 0)
    #' @param limit (optional) the limit for pagination (default value: 20)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (SirqulResponse) with additional information such as HTTP status code, headers
    SearchObjectsWithHttpInfo = function(account_id, game_level_id, sort_field = "PLAYER_SCORE_COUNT", descending = TRUE, start = 0, limit = 20, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (missing(`game_level_id`)) {
        stop("Missing required parameter `game_level_id`.")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling TournamentApi$SearchObjects, `account_id` is not nullable")
      }

      if (!missing(`game_level_id`) && is.null(`game_level_id`)) {
        stop("Invalid value for `game_level_id` when calling TournamentApi$SearchObjects, `game_level_id` is not nullable")
      }

      if (!missing(`sort_field`) && is.null(`sort_field`)) {
        stop("Invalid value for `sort_field` when calling TournamentApi$SearchObjects, `sort_field` is not nullable")
      }

      if (!missing(`descending`) && is.null(`descending`)) {
        stop("Invalid value for `descending` when calling TournamentApi$SearchObjects, `descending` is not nullable")
      }

      if (!missing(`start`) && is.null(`start`)) {
        stop("Invalid value for `start` when calling TournamentApi$SearchObjects, `start` is not nullable")
      }

      if (!missing(`limit`) && is.null(`limit`)) {
        stop("Invalid value for `limit` when calling TournamentApi$SearchObjects, `limit` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["gameLevelId"]] <- `game_level_id`

      if (!is.null(`sort_field`) && !(`sort_field` %in% c("ID", "PLAYER_SCORE_COUNT"))) {
        stop("Invalid value for sort_field when calling TournamentApi$SearchObjects. Must be [ID, PLAYER_SCORE_COUNT].")
      }
      query_params[["sortField"]] <- `sort_field`

      query_params[["descending"]] <- `descending`

      query_params[["start"]] <- `start`

      query_params[["limit"]] <- `limit`

      local_var_url_path <- "/tournament/object/search"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "SirqulResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Search Tournament Rounds
    #'
    #' @param account_id the account ID
    #' @param app_key the application key
    #' @param status (optional) comma separated list of statuses to filter results by (default value: "ACCEPTED,ACTIVE")
    #' @param mission_type (optional) The style of tournament to search for, options are: TOURNAMENT, POOLPLAY
    #' @param current_only (optional) search for games that are flagged current only (default value: TRUE)
    #' @param visibilities (optional) Filter tournament rounds by the mission visibility flag (default value: "PUBLIC")
    #' @param start (optional) the start index for pagination (default value: 0)
    #' @param limit (optional) the limit for pagination (default value: 20)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return SirqulResponse
    SearchRounds = function(account_id, app_key, status = "ACCEPTED,ACTIVE", mission_type = NULL, current_only = TRUE, visibilities = "PUBLIC", start = 0, limit = 20, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$SearchRoundsWithHttpInfo(account_id, app_key, status, mission_type, current_only, visibilities, start, limit, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Search Tournament Rounds
    #'
    #' @param account_id the account ID
    #' @param app_key the application key
    #' @param status (optional) comma separated list of statuses to filter results by (default value: "ACCEPTED,ACTIVE")
    #' @param mission_type (optional) The style of tournament to search for, options are: TOURNAMENT, POOLPLAY
    #' @param current_only (optional) search for games that are flagged current only (default value: TRUE)
    #' @param visibilities (optional) Filter tournament rounds by the mission visibility flag (default value: "PUBLIC")
    #' @param start (optional) the start index for pagination (default value: 0)
    #' @param limit (optional) the limit for pagination (default value: 20)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (SirqulResponse) with additional information such as HTTP status code, headers
    SearchRoundsWithHttpInfo = function(account_id, app_key, status = "ACCEPTED,ACTIVE", mission_type = NULL, current_only = TRUE, visibilities = "PUBLIC", start = 0, limit = 20, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (missing(`app_key`)) {
        stop("Missing required parameter `app_key`.")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling TournamentApi$SearchRounds, `account_id` is not nullable")
      }

      if (!missing(`app_key`) && is.null(`app_key`)) {
        stop("Invalid value for `app_key` when calling TournamentApi$SearchRounds, `app_key` is not nullable")
      }

      if (!missing(`status`) && is.null(`status`)) {
        stop("Invalid value for `status` when calling TournamentApi$SearchRounds, `status` is not nullable")
      }

      if (!missing(`mission_type`) && is.null(`mission_type`)) {
        stop("Invalid value for `mission_type` when calling TournamentApi$SearchRounds, `mission_type` is not nullable")
      }

      if (!missing(`current_only`) && is.null(`current_only`)) {
        stop("Invalid value for `current_only` when calling TournamentApi$SearchRounds, `current_only` is not nullable")
      }

      if (!missing(`visibilities`) && is.null(`visibilities`)) {
        stop("Invalid value for `visibilities` when calling TournamentApi$SearchRounds, `visibilities` is not nullable")
      }

      if (!missing(`start`) && is.null(`start`)) {
        stop("Invalid value for `start` when calling TournamentApi$SearchRounds, `start` is not nullable")
      }

      if (!missing(`limit`) && is.null(`limit`)) {
        stop("Invalid value for `limit` when calling TournamentApi$SearchRounds, `limit` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["appKey"]] <- `app_key`

      query_params[["status"]] <- `status`

      if (!is.null(`mission_type`) && !(`mission_type` %in% c("TOURNAMENT", "POOLPLAY"))) {
        stop("Invalid value for mission_type when calling TournamentApi$SearchRounds. Must be [TOURNAMENT, POOLPLAY].")
      }
      query_params[["missionType"]] <- `mission_type`

      query_params[["currentOnly"]] <- `current_only`

      query_params[["visibilities"]] <- `visibilities`

      query_params[["start"]] <- `start`

      query_params[["limit"]] <- `limit`

      local_var_url_path <- "/tournament/round/search"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "SirqulResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Search Tournaments
    #'
    #' @param account_id The logged in user.
    #' @param app_key The application key
    #' @param keyword (optional) the keyword to search tournament on
    #' @param sub_type (optional) filter results by subType
    #' @param include_inactive (optional) whether to include inactives in the search or not (default value: FALSE)
    #' @param mission_types (optional) comma separated list of mission types to filter results, possbile values include: TOURNAMENT, POOLPLAY, MULTISTAGE (default value: "MULTISTAGE,TOURNAMENT,POOLPLAY")
    #' @param filter (optional) filter tournaments by the tournament's current state (default value: "UPCOMING")
    #' @param sort_field (optional) which field to sort on (default value: "START_DATE")
    #' @param descending (optional) Determines whether to return results in descending order. The default value will be true if the filter is \"PAST\", otherwise the default value will be false.
    #' @param visibility (optional) Comma separated list of visibility flags for search for, possible values include: PUBLIC, LISTABLE, REWARDABLE, TRIGGERABLE, PRIVATE (default value: "PUBLIC")
    #' @param start (optional) Start the result set at some index. (default value: 0)
    #' @param limit (optional) Limit the result to some number (default value: 20)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return MissionShortResponse
    SearchTournaments = function(account_id, app_key, keyword = NULL, sub_type = NULL, include_inactive = FALSE, mission_types = "MULTISTAGE,TOURNAMENT,POOLPLAY", filter = "UPCOMING", sort_field = "START_DATE", descending = NULL, visibility = "PUBLIC", start = 0, limit = 20, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$SearchTournamentsWithHttpInfo(account_id, app_key, keyword, sub_type, include_inactive, mission_types, filter, sort_field, descending, visibility, start, limit, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Search Tournaments
    #'
    #' @param account_id The logged in user.
    #' @param app_key The application key
    #' @param keyword (optional) the keyword to search tournament on
    #' @param sub_type (optional) filter results by subType
    #' @param include_inactive (optional) whether to include inactives in the search or not (default value: FALSE)
    #' @param mission_types (optional) comma separated list of mission types to filter results, possbile values include: TOURNAMENT, POOLPLAY, MULTISTAGE (default value: "MULTISTAGE,TOURNAMENT,POOLPLAY")
    #' @param filter (optional) filter tournaments by the tournament's current state (default value: "UPCOMING")
    #' @param sort_field (optional) which field to sort on (default value: "START_DATE")
    #' @param descending (optional) Determines whether to return results in descending order. The default value will be true if the filter is \"PAST\", otherwise the default value will be false.
    #' @param visibility (optional) Comma separated list of visibility flags for search for, possible values include: PUBLIC, LISTABLE, REWARDABLE, TRIGGERABLE, PRIVATE (default value: "PUBLIC")
    #' @param start (optional) Start the result set at some index. (default value: 0)
    #' @param limit (optional) Limit the result to some number (default value: 20)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (MissionShortResponse) with additional information such as HTTP status code, headers
    SearchTournamentsWithHttpInfo = function(account_id, app_key, keyword = NULL, sub_type = NULL, include_inactive = FALSE, mission_types = "MULTISTAGE,TOURNAMENT,POOLPLAY", filter = "UPCOMING", sort_field = "START_DATE", descending = NULL, visibility = "PUBLIC", start = 0, limit = 20, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (missing(`app_key`)) {
        stop("Missing required parameter `app_key`.")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling TournamentApi$SearchTournaments, `account_id` is not nullable")
      }

      if (!missing(`app_key`) && is.null(`app_key`)) {
        stop("Invalid value for `app_key` when calling TournamentApi$SearchTournaments, `app_key` is not nullable")
      }

      if (!missing(`keyword`) && is.null(`keyword`)) {
        stop("Invalid value for `keyword` when calling TournamentApi$SearchTournaments, `keyword` is not nullable")
      }

      if (!missing(`sub_type`) && is.null(`sub_type`)) {
        stop("Invalid value for `sub_type` when calling TournamentApi$SearchTournaments, `sub_type` is not nullable")
      }

      if (!missing(`include_inactive`) && is.null(`include_inactive`)) {
        stop("Invalid value for `include_inactive` when calling TournamentApi$SearchTournaments, `include_inactive` is not nullable")
      }

      if (!missing(`mission_types`) && is.null(`mission_types`)) {
        stop("Invalid value for `mission_types` when calling TournamentApi$SearchTournaments, `mission_types` is not nullable")
      }

      if (!missing(`filter`) && is.null(`filter`)) {
        stop("Invalid value for `filter` when calling TournamentApi$SearchTournaments, `filter` is not nullable")
      }

      if (!missing(`sort_field`) && is.null(`sort_field`)) {
        stop("Invalid value for `sort_field` when calling TournamentApi$SearchTournaments, `sort_field` is not nullable")
      }

      if (!missing(`descending`) && is.null(`descending`)) {
        stop("Invalid value for `descending` when calling TournamentApi$SearchTournaments, `descending` is not nullable")
      }

      if (!missing(`visibility`) && is.null(`visibility`)) {
        stop("Invalid value for `visibility` when calling TournamentApi$SearchTournaments, `visibility` is not nullable")
      }

      if (!missing(`start`) && is.null(`start`)) {
        stop("Invalid value for `start` when calling TournamentApi$SearchTournaments, `start` is not nullable")
      }

      if (!missing(`limit`) && is.null(`limit`)) {
        stop("Invalid value for `limit` when calling TournamentApi$SearchTournaments, `limit` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["appKey"]] <- `app_key`

      query_params[["keyword"]] <- `keyword`

      query_params[["subType"]] <- `sub_type`

      query_params[["includeInactive"]] <- `include_inactive`

      query_params[["missionTypes"]] <- `mission_types`

      if (!is.null(`filter`) && !(`filter` %in% c("ALL", "UPCOMING", "PAST", "PRESENT", "ACTIVE"))) {
        stop("Invalid value for filter when calling TournamentApi$SearchTournaments. Must be [ALL, UPCOMING, PAST, PRESENT, ACTIVE].")
      }
      query_params[["filter"]] <- `filter`

      if (!is.null(`sort_field`) && !(`sort_field` %in% c("ACTIVE", "TITLE", "DESCRIPTION", "CREATED", "UPDATED", "MISSION_TYPE", "OWNER_DISPLAY", "START_DATE", "END_DATE", "STARTING_LIMIT", "AVAILABLE_LIMIT", "INVITE_COUNT", "ACCEPTED_COUNT"))) {
        stop("Invalid value for sort_field when calling TournamentApi$SearchTournaments. Must be [ACTIVE, TITLE, DESCRIPTION, CREATED, UPDATED, MISSION_TYPE, OWNER_DISPLAY, START_DATE, END_DATE, STARTING_LIMIT, AVAILABLE_LIMIT, INVITE_COUNT, ACCEPTED_COUNT].")
      }
      query_params[["sortField"]] <- `sort_field`

      query_params[["descending"]] <- `descending`

      query_params[["visibility"]] <- `visibility`

      query_params[["start"]] <- `start`

      query_params[["limit"]] <- `limit`

      local_var_url_path <- "/tournament/search"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "MissionShortResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Submit Tournament Score
    #'
    #' @param account_id The logged in user account ID.
    #' @param app_key The application key.
    #' @param mission_id The missionId to score for
    #' @param game_id The gameId to score for
    #' @param pack_id The packId to score for
    #' @param scores a JSON Array of scores to submit for a tournament match ```json [   {     \"accountId\": 2,     \"points\": 3   },   {     \"accountId\": 1777662,     \"points\": 7   } ] ``` 
    #' @param game_level_id (optional) The gameLevelId to score for
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return SirqulResponse
    SubmitTournamentScore = function(account_id, app_key, mission_id, game_id, pack_id, scores, game_level_id = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$SubmitTournamentScoreWithHttpInfo(account_id, app_key, mission_id, game_id, pack_id, scores, game_level_id, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Submit Tournament Score
    #'
    #' @param account_id The logged in user account ID.
    #' @param app_key The application key.
    #' @param mission_id The missionId to score for
    #' @param game_id The gameId to score for
    #' @param pack_id The packId to score for
    #' @param scores a JSON Array of scores to submit for a tournament match ```json [   {     \"accountId\": 2,     \"points\": 3   },   {     \"accountId\": 1777662,     \"points\": 7   } ] ``` 
    #' @param game_level_id (optional) The gameLevelId to score for
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (SirqulResponse) with additional information such as HTTP status code, headers
    SubmitTournamentScoreWithHttpInfo = function(account_id, app_key, mission_id, game_id, pack_id, scores, game_level_id = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (missing(`app_key`)) {
        stop("Missing required parameter `app_key`.")
      }

      if (missing(`mission_id`)) {
        stop("Missing required parameter `mission_id`.")
      }

      if (missing(`game_id`)) {
        stop("Missing required parameter `game_id`.")
      }

      if (missing(`pack_id`)) {
        stop("Missing required parameter `pack_id`.")
      }

      if (missing(`scores`)) {
        stop("Missing required parameter `scores`.")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling TournamentApi$SubmitTournamentScore, `account_id` is not nullable")
      }

      if (!missing(`app_key`) && is.null(`app_key`)) {
        stop("Invalid value for `app_key` when calling TournamentApi$SubmitTournamentScore, `app_key` is not nullable")
      }

      if (!missing(`mission_id`) && is.null(`mission_id`)) {
        stop("Invalid value for `mission_id` when calling TournamentApi$SubmitTournamentScore, `mission_id` is not nullable")
      }

      if (!missing(`game_id`) && is.null(`game_id`)) {
        stop("Invalid value for `game_id` when calling TournamentApi$SubmitTournamentScore, `game_id` is not nullable")
      }

      if (!missing(`pack_id`) && is.null(`pack_id`)) {
        stop("Invalid value for `pack_id` when calling TournamentApi$SubmitTournamentScore, `pack_id` is not nullable")
      }

      if (!missing(`scores`) && is.null(`scores`)) {
        stop("Invalid value for `scores` when calling TournamentApi$SubmitTournamentScore, `scores` is not nullable")
      }

      if (!missing(`game_level_id`) && is.null(`game_level_id`)) {
        stop("Invalid value for `game_level_id` when calling TournamentApi$SubmitTournamentScore, `game_level_id` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["appKey"]] <- `app_key`

      query_params[["missionId"]] <- `mission_id`

      query_params[["gameId"]] <- `game_id`

      query_params[["packId"]] <- `pack_id`

      query_params[["gameLevelId"]] <- `game_level_id`

      query_params[["scores"]] <- `scores`

      local_var_url_path <- "/tournament/score"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "SirqulResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Submit a vote for a multi-stage album tournament.
    #'
    #' @param account_id The logged in user.
    #' @param app_key The application to target
    #' @param mission_id The tournament's primary id
    #' @param game_object_id The tournament game object the user wants to vote on
    #' @param device_id (optional) The unique id of the device making the request (optional)
    #' @param check_if_device_already_voted (optional) When true, check if the device already voted to prevent duplicate votes from the same device (default value: FALSE)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return SirqulResponse
    SubmitTournamentVote = function(account_id, app_key, mission_id, game_object_id, device_id = NULL, check_if_device_already_voted = FALSE, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$SubmitTournamentVoteWithHttpInfo(account_id, app_key, mission_id, game_object_id, device_id, check_if_device_already_voted, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Submit a vote for a multi-stage album tournament.
    #'
    #' @param account_id The logged in user.
    #' @param app_key The application to target
    #' @param mission_id The tournament's primary id
    #' @param game_object_id The tournament game object the user wants to vote on
    #' @param device_id (optional) The unique id of the device making the request (optional)
    #' @param check_if_device_already_voted (optional) When true, check if the device already voted to prevent duplicate votes from the same device (default value: FALSE)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (SirqulResponse) with additional information such as HTTP status code, headers
    SubmitTournamentVoteWithHttpInfo = function(account_id, app_key, mission_id, game_object_id, device_id = NULL, check_if_device_already_voted = FALSE, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (missing(`app_key`)) {
        stop("Missing required parameter `app_key`.")
      }

      if (missing(`mission_id`)) {
        stop("Missing required parameter `mission_id`.")
      }

      if (missing(`game_object_id`)) {
        stop("Missing required parameter `game_object_id`.")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling TournamentApi$SubmitTournamentVote, `account_id` is not nullable")
      }

      if (!missing(`app_key`) && is.null(`app_key`)) {
        stop("Invalid value for `app_key` when calling TournamentApi$SubmitTournamentVote, `app_key` is not nullable")
      }

      if (!missing(`mission_id`) && is.null(`mission_id`)) {
        stop("Invalid value for `mission_id` when calling TournamentApi$SubmitTournamentVote, `mission_id` is not nullable")
      }

      if (!missing(`game_object_id`) && is.null(`game_object_id`)) {
        stop("Invalid value for `game_object_id` when calling TournamentApi$SubmitTournamentVote, `game_object_id` is not nullable")
      }

      if (!missing(`device_id`) && is.null(`device_id`)) {
        stop("Invalid value for `device_id` when calling TournamentApi$SubmitTournamentVote, `device_id` is not nullable")
      }

      if (!missing(`check_if_device_already_voted`) && is.null(`check_if_device_already_voted`)) {
        stop("Invalid value for `check_if_device_already_voted` when calling TournamentApi$SubmitTournamentVote, `check_if_device_already_voted` is not nullable")
      }

      query_params[["deviceId"]] <- `device_id`

      query_params[["accountId"]] <- `account_id`

      query_params[["appKey"]] <- `app_key`

      query_params[["missionId"]] <- `mission_id`

      query_params[["gameObjectId"]] <- `game_object_id`

      query_params[["checkIfDeviceAlreadyVoted"]] <- `check_if_device_already_voted`

      local_var_url_path <- "/tournament/vote"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "SirqulResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Substitute Tournament Player
    #'
    #' @param account_id the id of the logged in user
    #' @param mission_id the id of the mission
    #' @param pack_id the id of the pack
    #' @param game_level_id the id of the game level
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return SirqulResponse
    SubstituteTournamentPlayer = function(account_id, mission_id, pack_id, game_level_id, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$SubstituteTournamentPlayerWithHttpInfo(account_id, mission_id, pack_id, game_level_id, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Substitute Tournament Player
    #'
    #' @param account_id the id of the logged in user
    #' @param mission_id the id of the mission
    #' @param pack_id the id of the pack
    #' @param game_level_id the id of the game level
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (SirqulResponse) with additional information such as HTTP status code, headers
    SubstituteTournamentPlayerWithHttpInfo = function(account_id, mission_id, pack_id, game_level_id, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (missing(`mission_id`)) {
        stop("Missing required parameter `mission_id`.")
      }

      if (missing(`pack_id`)) {
        stop("Missing required parameter `pack_id`.")
      }

      if (missing(`game_level_id`)) {
        stop("Missing required parameter `game_level_id`.")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling TournamentApi$SubstituteTournamentPlayer, `account_id` is not nullable")
      }

      if (!missing(`mission_id`) && is.null(`mission_id`)) {
        stop("Invalid value for `mission_id` when calling TournamentApi$SubstituteTournamentPlayer, `mission_id` is not nullable")
      }

      if (!missing(`pack_id`) && is.null(`pack_id`)) {
        stop("Invalid value for `pack_id` when calling TournamentApi$SubstituteTournamentPlayer, `pack_id` is not nullable")
      }

      if (!missing(`game_level_id`) && is.null(`game_level_id`)) {
        stop("Invalid value for `game_level_id` when calling TournamentApi$SubstituteTournamentPlayer, `game_level_id` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["missionId"]] <- `mission_id`

      query_params[["packId"]] <- `pack_id`

      query_params[["gameLevelId"]] <- `game_level_id`

      local_var_url_path <- "/tournament/substitute"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "SirqulResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Update Tournament
    #'
    #' @param account_id The logged in user.
    #' @param mission_id The mission/tournament to update
    #' @param title (optional) The title of the tournament
    #' @param sub_type (optional) Custom string client apps can use for searching/filtering missions
    #' @param image_asset_id (optional) The asset ID to attach to the tournament
    #' @param seconds_between_levels (optional) The number of seconds in between the start of each tournament game
    #' @param seconds_for_tie_breaker (optional) The number of seconds to extend the round end time in the case of a tie breaker
    #' @param seconds_between_packs (optional) The number of seconds in between the start of each tournament round
    #' @param maximum_level_length (optional) The maximum number of seconds the match is expected to end at, which gets used to determine when a match should end when there is no activity
    #' @param cost_to_play (optional) The number of tickets required to pay to enter the tournament
    #' @param cost_to_play_type (optional) The type of ticket required to pay
    #' @param minimum_to_play (optional) The minimum number of players required to sign up for the tournament to be played
    #' @param starting_limit (optional) The starting number of players for a tournament (filled with AI's)
    #' @param available_limit (optional) The maximum number of players for a tournament (currently 128 but not enforced)
    #' @param description (optional) The description of the tournament
    #' @param meta_data (optional) External custom client defined data
    #' @param start_date (optional) The date/time to start the tournament
    #' @param audience_ids (optional) The audiences associated with the tournament
    #' @param active (optional) Activate/deactivate the mission
    #' @param enable_buy_back (optional) Determines whether to allow players to buy back into a tournament
    #' @param offer_ids (optional) The list of offers to give as a reward beyond the tickets
    #' @param offer_asset_id (optional) The artwork ID to attach to the reward offer
    #' @param fixed_reward (optional) If set then do not update the ticket reward, auto set to true if offerIds provided
    #' @param split_reward (optional) Set the rules for handling the reward in case of a tie, values: EVEN split the reward evenly ALL everyone gets the full reward value FIRST first score submitted RANDOM random player who scored
    #' @param allocate_tickets (optional) Flag to indicate owner should receive tickets for completed missions
    #' @param tournament_data (optional) A text based string that will be passed into each tournament setup to populate the content
    #' @param visibility (optional) Sets the visibility flag for the tournament
    #' @param preliminary_groups (optional) The number of initial preliminary groups in a multi-stage tournament (this is expected to be a power of two number)
    #' @param preliminary_group_advancements (optional) This determines how many people can advance per round in a preliminary group (this is a comma separated list of integers)
    #' @param enable_multiple_entries (optional) This determines if multiple submissions/entries are allowed in a multi-stage album tournament
    #' @param enable_multiple_votes (optional) This determines if users are allowed to vote multiple times per group in a multi-stage album tournament
    #' @param featured (optional) This determines whether the tournament is \"featured\" or not
    #' @param winner_tag (optional) This sets what analytic tag is used when a winner is determined
    #' @param tie_tag (optional) This sets what analytic tag is used when a winner is determined
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return TournamentResponse
    UpdateTournament = function(account_id, mission_id, title = NULL, sub_type = NULL, image_asset_id = NULL, seconds_between_levels = NULL, seconds_for_tie_breaker = NULL, seconds_between_packs = NULL, maximum_level_length = NULL, cost_to_play = NULL, cost_to_play_type = NULL, minimum_to_play = NULL, starting_limit = NULL, available_limit = NULL, description = NULL, meta_data = NULL, start_date = NULL, audience_ids = NULL, active = NULL, enable_buy_back = NULL, offer_ids = NULL, offer_asset_id = NULL, fixed_reward = NULL, split_reward = NULL, allocate_tickets = NULL, tournament_data = NULL, visibility = NULL, preliminary_groups = NULL, preliminary_group_advancements = NULL, enable_multiple_entries = NULL, enable_multiple_votes = NULL, featured = NULL, winner_tag = NULL, tie_tag = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$UpdateTournamentWithHttpInfo(account_id, mission_id, title, sub_type, image_asset_id, seconds_between_levels, seconds_for_tie_breaker, seconds_between_packs, maximum_level_length, cost_to_play, cost_to_play_type, minimum_to_play, starting_limit, available_limit, description, meta_data, start_date, audience_ids, active, enable_buy_back, offer_ids, offer_asset_id, fixed_reward, split_reward, allocate_tickets, tournament_data, visibility, preliminary_groups, preliminary_group_advancements, enable_multiple_entries, enable_multiple_votes, featured, winner_tag, tie_tag, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Update Tournament
    #'
    #' @param account_id The logged in user.
    #' @param mission_id The mission/tournament to update
    #' @param title (optional) The title of the tournament
    #' @param sub_type (optional) Custom string client apps can use for searching/filtering missions
    #' @param image_asset_id (optional) The asset ID to attach to the tournament
    #' @param seconds_between_levels (optional) The number of seconds in between the start of each tournament game
    #' @param seconds_for_tie_breaker (optional) The number of seconds to extend the round end time in the case of a tie breaker
    #' @param seconds_between_packs (optional) The number of seconds in between the start of each tournament round
    #' @param maximum_level_length (optional) The maximum number of seconds the match is expected to end at, which gets used to determine when a match should end when there is no activity
    #' @param cost_to_play (optional) The number of tickets required to pay to enter the tournament
    #' @param cost_to_play_type (optional) The type of ticket required to pay
    #' @param minimum_to_play (optional) The minimum number of players required to sign up for the tournament to be played
    #' @param starting_limit (optional) The starting number of players for a tournament (filled with AI's)
    #' @param available_limit (optional) The maximum number of players for a tournament (currently 128 but not enforced)
    #' @param description (optional) The description of the tournament
    #' @param meta_data (optional) External custom client defined data
    #' @param start_date (optional) The date/time to start the tournament
    #' @param audience_ids (optional) The audiences associated with the tournament
    #' @param active (optional) Activate/deactivate the mission
    #' @param enable_buy_back (optional) Determines whether to allow players to buy back into a tournament
    #' @param offer_ids (optional) The list of offers to give as a reward beyond the tickets
    #' @param offer_asset_id (optional) The artwork ID to attach to the reward offer
    #' @param fixed_reward (optional) If set then do not update the ticket reward, auto set to true if offerIds provided
    #' @param split_reward (optional) Set the rules for handling the reward in case of a tie, values: EVEN split the reward evenly ALL everyone gets the full reward value FIRST first score submitted RANDOM random player who scored
    #' @param allocate_tickets (optional) Flag to indicate owner should receive tickets for completed missions
    #' @param tournament_data (optional) A text based string that will be passed into each tournament setup to populate the content
    #' @param visibility (optional) Sets the visibility flag for the tournament
    #' @param preliminary_groups (optional) The number of initial preliminary groups in a multi-stage tournament (this is expected to be a power of two number)
    #' @param preliminary_group_advancements (optional) This determines how many people can advance per round in a preliminary group (this is a comma separated list of integers)
    #' @param enable_multiple_entries (optional) This determines if multiple submissions/entries are allowed in a multi-stage album tournament
    #' @param enable_multiple_votes (optional) This determines if users are allowed to vote multiple times per group in a multi-stage album tournament
    #' @param featured (optional) This determines whether the tournament is \"featured\" or not
    #' @param winner_tag (optional) This sets what analytic tag is used when a winner is determined
    #' @param tie_tag (optional) This sets what analytic tag is used when a winner is determined
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (TournamentResponse) with additional information such as HTTP status code, headers
    UpdateTournamentWithHttpInfo = function(account_id, mission_id, title = NULL, sub_type = NULL, image_asset_id = NULL, seconds_between_levels = NULL, seconds_for_tie_breaker = NULL, seconds_between_packs = NULL, maximum_level_length = NULL, cost_to_play = NULL, cost_to_play_type = NULL, minimum_to_play = NULL, starting_limit = NULL, available_limit = NULL, description = NULL, meta_data = NULL, start_date = NULL, audience_ids = NULL, active = NULL, enable_buy_back = NULL, offer_ids = NULL, offer_asset_id = NULL, fixed_reward = NULL, split_reward = NULL, allocate_tickets = NULL, tournament_data = NULL, visibility = NULL, preliminary_groups = NULL, preliminary_group_advancements = NULL, enable_multiple_entries = NULL, enable_multiple_votes = NULL, featured = NULL, winner_tag = NULL, tie_tag = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (missing(`mission_id`)) {
        stop("Missing required parameter `mission_id`.")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling TournamentApi$UpdateTournament, `account_id` is not nullable")
      }

      if (!missing(`mission_id`) && is.null(`mission_id`)) {
        stop("Invalid value for `mission_id` when calling TournamentApi$UpdateTournament, `mission_id` is not nullable")
      }

      if (!missing(`title`) && is.null(`title`)) {
        stop("Invalid value for `title` when calling TournamentApi$UpdateTournament, `title` is not nullable")
      }

      if (!missing(`sub_type`) && is.null(`sub_type`)) {
        stop("Invalid value for `sub_type` when calling TournamentApi$UpdateTournament, `sub_type` is not nullable")
      }

      if (!missing(`image_asset_id`) && is.null(`image_asset_id`)) {
        stop("Invalid value for `image_asset_id` when calling TournamentApi$UpdateTournament, `image_asset_id` is not nullable")
      }

      if (!missing(`seconds_between_levels`) && is.null(`seconds_between_levels`)) {
        stop("Invalid value for `seconds_between_levels` when calling TournamentApi$UpdateTournament, `seconds_between_levels` is not nullable")
      }

      if (!missing(`seconds_for_tie_breaker`) && is.null(`seconds_for_tie_breaker`)) {
        stop("Invalid value for `seconds_for_tie_breaker` when calling TournamentApi$UpdateTournament, `seconds_for_tie_breaker` is not nullable")
      }

      if (!missing(`seconds_between_packs`) && is.null(`seconds_between_packs`)) {
        stop("Invalid value for `seconds_between_packs` when calling TournamentApi$UpdateTournament, `seconds_between_packs` is not nullable")
      }

      if (!missing(`maximum_level_length`) && is.null(`maximum_level_length`)) {
        stop("Invalid value for `maximum_level_length` when calling TournamentApi$UpdateTournament, `maximum_level_length` is not nullable")
      }

      if (!missing(`cost_to_play`) && is.null(`cost_to_play`)) {
        stop("Invalid value for `cost_to_play` when calling TournamentApi$UpdateTournament, `cost_to_play` is not nullable")
      }

      if (!missing(`cost_to_play_type`) && is.null(`cost_to_play_type`)) {
        stop("Invalid value for `cost_to_play_type` when calling TournamentApi$UpdateTournament, `cost_to_play_type` is not nullable")
      }

      if (!missing(`minimum_to_play`) && is.null(`minimum_to_play`)) {
        stop("Invalid value for `minimum_to_play` when calling TournamentApi$UpdateTournament, `minimum_to_play` is not nullable")
      }

      if (!missing(`starting_limit`) && is.null(`starting_limit`)) {
        stop("Invalid value for `starting_limit` when calling TournamentApi$UpdateTournament, `starting_limit` is not nullable")
      }

      if (!missing(`available_limit`) && is.null(`available_limit`)) {
        stop("Invalid value for `available_limit` when calling TournamentApi$UpdateTournament, `available_limit` is not nullable")
      }

      if (!missing(`description`) && is.null(`description`)) {
        stop("Invalid value for `description` when calling TournamentApi$UpdateTournament, `description` is not nullable")
      }

      if (!missing(`meta_data`) && is.null(`meta_data`)) {
        stop("Invalid value for `meta_data` when calling TournamentApi$UpdateTournament, `meta_data` is not nullable")
      }

      if (!missing(`start_date`) && is.null(`start_date`)) {
        stop("Invalid value for `start_date` when calling TournamentApi$UpdateTournament, `start_date` is not nullable")
      }

      if (!missing(`audience_ids`) && is.null(`audience_ids`)) {
        stop("Invalid value for `audience_ids` when calling TournamentApi$UpdateTournament, `audience_ids` is not nullable")
      }

      if (!missing(`active`) && is.null(`active`)) {
        stop("Invalid value for `active` when calling TournamentApi$UpdateTournament, `active` is not nullable")
      }

      if (!missing(`enable_buy_back`) && is.null(`enable_buy_back`)) {
        stop("Invalid value for `enable_buy_back` when calling TournamentApi$UpdateTournament, `enable_buy_back` is not nullable")
      }

      if (!missing(`offer_ids`) && is.null(`offer_ids`)) {
        stop("Invalid value for `offer_ids` when calling TournamentApi$UpdateTournament, `offer_ids` is not nullable")
      }

      if (!missing(`offer_asset_id`) && is.null(`offer_asset_id`)) {
        stop("Invalid value for `offer_asset_id` when calling TournamentApi$UpdateTournament, `offer_asset_id` is not nullable")
      }

      if (!missing(`fixed_reward`) && is.null(`fixed_reward`)) {
        stop("Invalid value for `fixed_reward` when calling TournamentApi$UpdateTournament, `fixed_reward` is not nullable")
      }

      if (!missing(`split_reward`) && is.null(`split_reward`)) {
        stop("Invalid value for `split_reward` when calling TournamentApi$UpdateTournament, `split_reward` is not nullable")
      }

      if (!missing(`allocate_tickets`) && is.null(`allocate_tickets`)) {
        stop("Invalid value for `allocate_tickets` when calling TournamentApi$UpdateTournament, `allocate_tickets` is not nullable")
      }

      if (!missing(`tournament_data`) && is.null(`tournament_data`)) {
        stop("Invalid value for `tournament_data` when calling TournamentApi$UpdateTournament, `tournament_data` is not nullable")
      }

      if (!missing(`visibility`) && is.null(`visibility`)) {
        stop("Invalid value for `visibility` when calling TournamentApi$UpdateTournament, `visibility` is not nullable")
      }

      if (!missing(`preliminary_groups`) && is.null(`preliminary_groups`)) {
        stop("Invalid value for `preliminary_groups` when calling TournamentApi$UpdateTournament, `preliminary_groups` is not nullable")
      }

      if (!missing(`preliminary_group_advancements`) && is.null(`preliminary_group_advancements`)) {
        stop("Invalid value for `preliminary_group_advancements` when calling TournamentApi$UpdateTournament, `preliminary_group_advancements` is not nullable")
      }

      if (!missing(`enable_multiple_entries`) && is.null(`enable_multiple_entries`)) {
        stop("Invalid value for `enable_multiple_entries` when calling TournamentApi$UpdateTournament, `enable_multiple_entries` is not nullable")
      }

      if (!missing(`enable_multiple_votes`) && is.null(`enable_multiple_votes`)) {
        stop("Invalid value for `enable_multiple_votes` when calling TournamentApi$UpdateTournament, `enable_multiple_votes` is not nullable")
      }

      if (!missing(`featured`) && is.null(`featured`)) {
        stop("Invalid value for `featured` when calling TournamentApi$UpdateTournament, `featured` is not nullable")
      }

      if (!missing(`winner_tag`) && is.null(`winner_tag`)) {
        stop("Invalid value for `winner_tag` when calling TournamentApi$UpdateTournament, `winner_tag` is not nullable")
      }

      if (!missing(`tie_tag`) && is.null(`tie_tag`)) {
        stop("Invalid value for `tie_tag` when calling TournamentApi$UpdateTournament, `tie_tag` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["missionId"]] <- `mission_id`

      query_params[["title"]] <- `title`

      query_params[["subType"]] <- `sub_type`

      query_params[["imageAssetId"]] <- `image_asset_id`

      query_params[["secondsBetweenLevels"]] <- `seconds_between_levels`

      query_params[["secondsForTieBreaker"]] <- `seconds_for_tie_breaker`

      query_params[["secondsBetweenPacks"]] <- `seconds_between_packs`

      query_params[["maximumLevelLength"]] <- `maximum_level_length`

      query_params[["costToPlay"]] <- `cost_to_play`

      query_params[["costToPlayType"]] <- `cost_to_play_type`

      query_params[["minimumToPlay"]] <- `minimum_to_play`

      query_params[["startingLimit"]] <- `starting_limit`

      query_params[["availableLimit"]] <- `available_limit`

      query_params[["description"]] <- `description`

      query_params[["metaData"]] <- `meta_data`

      query_params[["startDate"]] <- `start_date`

      query_params[["audienceIds"]] <- `audience_ids`

      query_params[["active"]] <- `active`

      query_params[["enableBuyBack"]] <- `enable_buy_back`

      query_params[["offerIds"]] <- `offer_ids`

      query_params[["offerAssetId"]] <- `offer_asset_id`

      query_params[["fixedReward"]] <- `fixed_reward`

      if (!is.null(`split_reward`) && !(`split_reward` %in% c("EVEN", "ALL", "FIRST", "RANDOM"))) {
        stop("Invalid value for split_reward when calling TournamentApi$UpdateTournament. Must be [EVEN, ALL, FIRST, RANDOM].")
      }
      query_params[["splitReward"]] <- `split_reward`

      query_params[["allocateTickets"]] <- `allocate_tickets`

      query_params[["tournamentData"]] <- `tournament_data`

      if (!is.null(`visibility`) && !(`visibility` %in% c("PUBLIC", "LISTABLE", "REWARDABLE", "TRIGGERABLE", "PRIVATE"))) {
        stop("Invalid value for visibility when calling TournamentApi$UpdateTournament. Must be [PUBLIC, LISTABLE, REWARDABLE, TRIGGERABLE, PRIVATE].")
      }
      query_params[["visibility"]] <- `visibility`

      query_params[["preliminaryGroups"]] <- `preliminary_groups`

      query_params[["preliminaryGroupAdvancements"]] <- `preliminary_group_advancements`

      query_params[["enableMultipleEntries"]] <- `enable_multiple_entries`

      query_params[["enableMultipleVotes"]] <- `enable_multiple_votes`

      query_params[["featured"]] <- `featured`

      query_params[["winnerTag"]] <- `winner_tag`

      query_params[["tieTag"]] <- `tie_tag`

      local_var_url_path <- "/tournament/update"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "TournamentResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    }
  )
)
