#' Sirqul IoT Platform
#'
#' Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
#'
#' The version of the OpenAPI document: 3.16
#' Contact: info@sirqul.com
#' Generated by: https://openapi-generator.tech
#'
#' @docType class
#' @title Orson operations
#' @description OrsonApi
#' @format An \code{R6Class} generator object
#' @field api_client Handles the client-server communication.
#'
#' @examples
#' \dontrun{
#' ####################  AddMovie  ####################
#'
#' library(openapi)
#' var_version <- 3.16 # numeric | 
#' var_account_id <- 56 # integer | Sirqul Account Id
#' var_movie_name <- "movie_name_example" # character | Movie Name
#' var_third_party_account_id <- "third_party_account_id_example" # character | A third-party account id that is meaningful to your systems (Optional)
#' var_tags <- "tags_example" # character | A user defined list (comma-delimited) of tags associated with the movie (Optional)
#' var_file <- File.new('/path/to/file') # data.frame | An uploaded recording to analyze (Currently limited to 10MB) (Optional)
#' var_url <- "url_example" # character | A recording file to download and analyze (Size limit: 1GB) (Optional)
#' var_callback <- "callback_example" # character | When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (Optional)
#'
#' #Add Movie
#' api_instance <- OrsonApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$AddMovie(var_version, var_account_id, var_movie_name, third_party_account_id = var_third_party_account_id, tags = var_tags, file = var_file, url = var_url, callback = var_callbackdata_file = "result.txt")
#' result <- api_instance$AddMovie(var_version, var_account_id, var_movie_name, third_party_account_id = var_third_party_account_id, tags = var_tags, file = var_file, url = var_url, callback = var_callback)
#' dput(result)
#'
#'
#' ####################  AiDocs  ####################
#'
#' library(openapi)
#' var_version <- 3.16 # numeric | 
#' var_account_id <- 56 # integer | Sirqul Account Id
#' var_doc <- "doc_example" # character | Doc
#' var_return_topics <- "return_topics_example" # character | Return Topics (Optional)
#' var_limit <- 56 # integer | Limit (Optional)
#' var_offset <- 56 # integer | Offset (Optional)
#'
#' #Search Docs
#' api_instance <- OrsonApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$AiDocs(var_version, var_account_id, var_doc, return_topics = var_return_topics, limit = var_limit, offset = var_offsetdata_file = "result.txt")
#' result <- api_instance$AiDocs(var_version, var_account_id, var_doc, return_topics = var_return_topics, limit = var_limit, offset = var_offset)
#' dput(result)
#'
#'
#' ####################  AiFindImages  ####################
#'
#' library(openapi)
#' var_version <- 3.16 # numeric | 
#' var_account_id <- 56 # integer | Sirqul Account Id
#' var_text <- "text_example" # character | Text
#' var_parse_flag <- "parse_flag_example" # character | Parse Flag (Optional)
#' var_fetch_flag <- "fetch_flag_example" # character | Fetch Flag (Optional)
#' var_size <- "size_example" # character | Size (Optional)
#'
#' #Find images
#' api_instance <- OrsonApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$AiFindImages(var_version, var_account_id, var_text, parse_flag = var_parse_flag, fetch_flag = var_fetch_flag, size = var_sizedata_file = "result.txt")
#' result <- api_instance$AiFindImages(var_version, var_account_id, var_text, parse_flag = var_parse_flag, fetch_flag = var_fetch_flag, size = var_size)
#' dput(result)
#'
#'
#' ####################  AiTags  ####################
#'
#' library(openapi)
#' var_version <- 3.16 # numeric | 
#' var_account_id <- 56 # integer | Sirqul Account Id
#' var_tags <- "tags_example" # character | Tags
#' var_conditional <- "conditional_example" # character | Conditional (Optional)
#' var_limit <- 56 # integer | Limit (Optional)
#' var_offset <- 56 # integer | Offset (Optional)
#'
#' #Search Tags
#' api_instance <- OrsonApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$AiTags(var_version, var_account_id, var_tags, conditional = var_conditional, limit = var_limit, offset = var_offsetdata_file = "result.txt")
#' result <- api_instance$AiTags(var_version, var_account_id, var_tags, conditional = var_conditional, limit = var_limit, offset = var_offset)
#' dput(result)
#'
#'
#' ####################  AiText  ####################
#'
#' library(openapi)
#' var_version <- 3.16 # numeric | 
#' var_account_id <- 56 # integer | Sirqul Account Id
#' var_terms <- "terms_example" # character | Terms
#' var_conditional <- "conditional_example" # character | Conditional (Optional)
#' var_limit <- 56 # integer | Limit (Optional)
#' var_offset <- 56 # integer | Offset (Optional)
#'
#' #Search Text
#' api_instance <- OrsonApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$AiText(var_version, var_account_id, var_terms, conditional = var_conditional, limit = var_limit, offset = var_offsetdata_file = "result.txt")
#' result <- api_instance$AiText(var_version, var_account_id, var_terms, conditional = var_conditional, limit = var_limit, offset = var_offset)
#' dput(result)
#'
#'
#' ####################  Batch  ####################
#'
#' library(openapi)
#' var_version <- 3.16 # numeric | 
#' var_account_id <- 56 # integer | Sirqul Account Id
#' var_third_party_account_id <- "third_party_account_id_example" # character | A third-party account id that is meaningful to your systems (Optional)
#' var_limit <- 56 # integer | The number of topics to return (Optional)
#' var_operations <- "operations_example" # character | The comma-delimited list of A/V batch analysis operations to run on this file. Possible values: Transcript,Topics,Emotions (Optional)
#' var_file <- File.new('/path/to/file') # data.frame | An uploaded recording to analyze (Currently limited to 10MB) (Optional)
#' var_url <- "url_example" # character | A recording file to download and analyze (Size limit: 1GB) (Optional)
#' var_callback <- "callback_example" # character | When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (Optional)
#'
#' #Batch Analysis
#' api_instance <- OrsonApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$Batch(var_version, var_account_id, third_party_account_id = var_third_party_account_id, limit = var_limit, operations = var_operations, file = var_file, url = var_url, callback = var_callbackdata_file = "result.txt")
#' result <- api_instance$Batch(var_version, var_account_id, third_party_account_id = var_third_party_account_id, limit = var_limit, operations = var_operations, file = var_file, url = var_url, callback = var_callback)
#' dput(result)
#'
#'
#' ####################  CreateInstantEpisode  ####################
#'
#' library(openapi)
#' var_version <- 3.16 # numeric | 
#' var_account_id <- 56 # integer | Sirqul Account Id
#' var_data <- "data_example" # character | Request Data String
#'
#' #Creates an instant episode
#' api_instance <- OrsonApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$CreateInstantEpisode(var_version, var_account_id, var_datadata_file = "result.txt")
#' result <- api_instance$CreateInstantEpisode(var_version, var_account_id, var_data)
#' dput(result)
#'
#'
#' ####################  CreateVoiceCanvas  ####################
#'
#' library(openapi)
#' var_version <- 3.16 # numeric | 
#' var_account_id <- 56 # integer | Sirqul Account Id
#' var_dimensions <- "dimensions_example" # character | Enum: \"256x256\" \"512x512\" \"1024x1024\"
#' var_third_party_account_id <- "third_party_account_id_example" # character | A third-party account id that is meaningful to your systems (Optional)
#' var_text <- "text_example" # character | Provide a transcript or previously extracted topics for image generation (Optional)
#' var_file <- File.new('/path/to/file') # data.frame | An uploaded recording to analyze (Currently limited to 10MB) (Optional)
#' var_url <- "url_example" # character | A recording file to download and analyze (Size limit: 1GB) (Optional)
#' var_parse_flag <- "parse_flag_example" # character | When false, uses the raw value from text instead of identifying topics to fetch/generate from (Optional)
#' var_fetch_flag <- "fetch_flag_example" # character | When true, fetches images instead of generating them (Optional)
#' var_callback <- "callback_example" # character | When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (Optional)
#'
#' #Create VoiceCanvas images
#' api_instance <- OrsonApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$CreateVoiceCanvas(var_version, var_account_id, var_dimensions, third_party_account_id = var_third_party_account_id, text = var_text, file = var_file, url = var_url, parse_flag = var_parse_flag, fetch_flag = var_fetch_flag, callback = var_callbackdata_file = "result.txt")
#' result <- api_instance$CreateVoiceCanvas(var_version, var_account_id, var_dimensions, third_party_account_id = var_third_party_account_id, text = var_text, file = var_file, url = var_url, parse_flag = var_parse_flag, fetch_flag = var_fetch_flag, callback = var_callback)
#' dput(result)
#'
#'
#' ####################  Emotion  ####################
#'
#' library(openapi)
#' var_version <- 3.16 # numeric | 
#' var_account_id <- 56 # integer | Sirqul Account Id
#' var_third_party_account_id <- "third_party_account_id_example" # character | A third-party account id that is meaningful to your systems (Optional)
#' var_file <- File.new('/path/to/file') # data.frame | An uploaded recording to analyze (Currently limited to 10MB) (Optional)
#' var_url <- "url_example" # character | A recording file to download and analyze (Size limit: 1GB) (Optional)
#' var_callback <- "callback_example" # character | When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (Optional)
#'
#' #Detect emotions
#' api_instance <- OrsonApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$Emotion(var_version, var_account_id, third_party_account_id = var_third_party_account_id, file = var_file, url = var_url, callback = var_callbackdata_file = "result.txt")
#' result <- api_instance$Emotion(var_version, var_account_id, third_party_account_id = var_third_party_account_id, file = var_file, url = var_url, callback = var_callback)
#' dput(result)
#'
#'
#' ####################  GetAddMovieResult  ####################
#'
#' library(openapi)
#' var_version <- 3.16 # numeric | 
#' var_request_id <- "request_id_example" # character | Orson Request Id
#' var_account_id <- 56 # integer | Sirqul Account Id
#'
#' #Get Add Movie Result
#' api_instance <- OrsonApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$GetAddMovieResult(var_version, var_request_id, var_account_iddata_file = "result.txt")
#' result <- api_instance$GetAddMovieResult(var_version, var_request_id, var_account_id)
#' dput(result)
#'
#'
#' ####################  GetBatch  ####################
#'
#' library(openapi)
#' var_version <- 3.16 # numeric | 
#' var_request_id <- "request_id_example" # character | Orson Request Id
#' var_account_id <- 56 # integer | Sirqul Account Id
#'
#' #Get Batch Analysis Results
#' api_instance <- OrsonApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$GetBatch(var_version, var_request_id, var_account_iddata_file = "result.txt")
#' result <- api_instance$GetBatch(var_version, var_request_id, var_account_id)
#' dput(result)
#'
#'
#' ####################  GetEmotion  ####################
#'
#' library(openapi)
#' var_version <- 3.16 # numeric | 
#' var_request_id <- "request_id_example" # character | Orson Request Id
#' var_account_id <- 56 # integer | Sirqul Account Id
#'
#' #Get Emotion Results
#' api_instance <- OrsonApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$GetEmotion(var_version, var_request_id, var_account_iddata_file = "result.txt")
#' result <- api_instance$GetEmotion(var_version, var_request_id, var_account_id)
#' dput(result)
#'
#'
#' ####################  GetEpisodeStatus  ####################
#'
#' library(openapi)
#' var_version <- 3.16 # numeric | 
#' var_episode_id <- 56 # integer | Episode ID
#' var_account_id <- 56 # integer | Sirqul Account Id
#'
#' #Check episode status
#' api_instance <- OrsonApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$GetEpisodeStatus(var_version, var_episode_id, var_account_iddata_file = "result.txt")
#' result <- api_instance$GetEpisodeStatus(var_version, var_episode_id, var_account_id)
#' dput(result)
#'
#'
#' ####################  GetRenderStatus  ####################
#'
#' library(openapi)
#' var_version <- 3.16 # numeric | 
#' var_render_id <- "render_id_example" # character | Render ID
#' var_account_id <- 56 # integer | Sirqul Account Id
#'
#' #Check episode status
#' api_instance <- OrsonApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$GetRenderStatus(var_version, var_render_id, var_account_iddata_file = "result.txt")
#' result <- api_instance$GetRenderStatus(var_version, var_render_id, var_account_id)
#' dput(result)
#'
#'
#' ####################  GetSTT  ####################
#'
#' library(openapi)
#' var_version <- 3.16 # numeric | 
#' var_request_id <- "request_id_example" # character | Orson Request Id
#' var_account_id <- 56 # integer | Sirqul Account Id
#'
#' #Get Speach to Text Result
#' api_instance <- OrsonApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$GetSTT(var_version, var_request_id, var_account_iddata_file = "result.txt")
#' result <- api_instance$GetSTT(var_version, var_request_id, var_account_id)
#' dput(result)
#'
#'
#' ####################  GetTTS  ####################
#'
#' library(openapi)
#' var_version <- 3.16 # numeric | 
#' var_request_id <- "request_id_example" # character | Orson Request Id
#' var_account_id <- 56 # integer | Sirqul Account Id
#'
#' #Get Text to Speach Result
#' api_instance <- OrsonApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$GetTTS(var_version, var_request_id, var_account_iddata_file = "result.txt")
#' result <- api_instance$GetTTS(var_version, var_request_id, var_account_id)
#' dput(result)
#'
#'
#' ####################  GetTechTune  ####################
#'
#' library(openapi)
#' var_version <- 3.16 # numeric | 
#' var_request_id <- "request_id_example" # character | Orson Request Id
#' var_account_id <- 56 # integer | Sirqul Account Id
#'
#' #Get TechTune Results
#' api_instance <- OrsonApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$GetTechTune(var_version, var_request_id, var_account_iddata_file = "result.txt")
#' result <- api_instance$GetTechTune(var_version, var_request_id, var_account_id)
#' dput(result)
#'
#'
#' ####################  GetTopics  ####################
#'
#' library(openapi)
#' var_version <- 3.16 # numeric | 
#' var_request_id <- "request_id_example" # character | Orson Request Id
#' var_account_id <- 56 # integer | Sirqul Account Id
#'
#' #Get Topics
#' api_instance <- OrsonApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$GetTopics(var_version, var_request_id, var_account_iddata_file = "result.txt")
#' result <- api_instance$GetTopics(var_version, var_request_id, var_account_id)
#' dput(result)
#'
#'
#' ####################  GetVoiceCanvas  ####################
#'
#' library(openapi)
#' var_version <- 3.16 # numeric | 
#' var_request_id <- "request_id_example" # character | Orson Request Id
#' var_account_id <- 56 # integer | Sirqul Account Id
#'
#' #Get VoiceCanvas images
#' api_instance <- OrsonApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$GetVoiceCanvas(var_version, var_request_id, var_account_iddata_file = "result.txt")
#' result <- api_instance$GetVoiceCanvas(var_version, var_request_id, var_account_id)
#' dput(result)
#'
#'
#' ####################  StartVideoRender  ####################
#'
#' library(openapi)
#' var_version <- 3.16 # numeric | 
#' var_account_id <- 56 # integer | Sirqul Account Id
#' var_data <- "data_example" # character | Request Data String
#'
#' #Starts a StoryStitch video render
#' api_instance <- OrsonApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$StartVideoRender(var_version, var_account_id, var_datadata_file = "result.txt")
#' result <- api_instance$StartVideoRender(var_version, var_account_id, var_data)
#' dput(result)
#'
#'
#' ####################  Stt  ####################
#'
#' library(openapi)
#' var_version <- 3.16 # numeric | 
#' var_account_id <- 56 # integer | Sirqul Account Id
#' var_third_party_account_id <- "third_party_account_id_example" # character | A third-party account id that is meaningful to your systems (Optional)
#' var_source_language <- "source_language_example" # character | Source Language (Optional)
#' var_target_language <- "target_language_example" # character | Target Language (Optional)
#' var_file <- File.new('/path/to/file') # data.frame | An uploaded recording to analyze (Currently limited to 10MB) (Optional)
#' var_url <- "url_example" # character | A recording file to download and analyze (Size limit: 1GB) (Optional)
#' var_callback <- "callback_example" # character | When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (Optional)
#'
#' #Speach to Text
#' api_instance <- OrsonApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$Stt(var_version, var_account_id, third_party_account_id = var_third_party_account_id, source_language = var_source_language, target_language = var_target_language, file = var_file, url = var_url, callback = var_callbackdata_file = "result.txt")
#' result <- api_instance$Stt(var_version, var_account_id, third_party_account_id = var_third_party_account_id, source_language = var_source_language, target_language = var_target_language, file = var_file, url = var_url, callback = var_callback)
#' dput(result)
#'
#'
#' ####################  SummarizeTopics  ####################
#'
#' library(openapi)
#' var_version <- 3.16 # numeric | 
#' var_account_id <- 56 # integer | Sirqul Account Id
#' var_third_party_account_id <- "third_party_account_id_example" # character | A third-party account id that is meaningful to your systems (Optional)
#' var_doc <- "doc_example" # character | The text to get topics for. (Optional)
#' var_file <- File.new('/path/to/file') # data.frame | An uploaded recording to analyze (Currently limited to 10MB) (Optional)
#' var_url <- "url_example" # character | A recording file to download and analyze (Size limit: 1GB) (Optional)
#' var_limit <- 56 # integer | The number of results to return (Optional)
#' var_offset <- 56 # integer | The starting offset into the total result set to start from (Optional)
#' var_callback <- "callback_example" # character | When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (Optional)
#'
#' #Summarize Topics
#' api_instance <- OrsonApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$SummarizeTopics(var_version, var_account_id, third_party_account_id = var_third_party_account_id, doc = var_doc, file = var_file, url = var_url, limit = var_limit, offset = var_offset, callback = var_callbackdata_file = "result.txt")
#' result <- api_instance$SummarizeTopics(var_version, var_account_id, third_party_account_id = var_third_party_account_id, doc = var_doc, file = var_file, url = var_url, limit = var_limit, offset = var_offset, callback = var_callback)
#' dput(result)
#'
#'
#' ####################  TechTune  ####################
#'
#' library(openapi)
#' var_version <- 3.16 # numeric | 
#' var_account_id <- 56 # integer | Sirqul Account Id
#' var_num_faces_expected <- 56 # integer | Number of expected faces
#' var_third_party_account_id <- "third_party_account_id_example" # character | A third-party account id that is meaningful to your systems (Optional)
#' var_file <- File.new('/path/to/file') # data.frame | An uploaded recording to analyze (Currently limited to 10MB) (Optional)
#' var_url <- "url_example" # character | A recording file to download and analyze (Size limit: 1GB) (Optional)
#' var_callback <- "callback_example" # character | When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (Optional)
#'
#' #Detect Technical Issues
#' api_instance <- OrsonApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$TechTune(var_version, var_account_id, var_num_faces_expected, third_party_account_id = var_third_party_account_id, file = var_file, url = var_url, callback = var_callbackdata_file = "result.txt")
#' result <- api_instance$TechTune(var_version, var_account_id, var_num_faces_expected, third_party_account_id = var_third_party_account_id, file = var_file, url = var_url, callback = var_callback)
#' dput(result)
#'
#'
#' ####################  Tts  ####################
#'
#' library(openapi)
#' var_version <- 3.16 # numeric | 
#' var_account_id <- 56 # integer | Sirqul Account Id
#' var_text <- "text_example" # character | Text
#' var_third_party_account_id <- "third_party_account_id_example" # character | A third-party account id that is meaningful to your systems (Optional)
#' var_language <- "language_example" # character | The language to use for the speaker and incoming text (Optional)
#' var_voice <- "voice_example" # character | A language-specific voice to use, or picks the language default if not provided (Optional)
#' var_callback <- "callback_example" # character | When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (Optional)
#'
#' #Text to Speach
#' api_instance <- OrsonApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$Tts(var_version, var_account_id, var_text, third_party_account_id = var_third_party_account_id, language = var_language, voice = var_voice, callback = var_callbackdata_file = "result.txt")
#' result <- api_instance$Tts(var_version, var_account_id, var_text, third_party_account_id = var_third_party_account_id, language = var_language, voice = var_voice, callback = var_callback)
#' dput(result)
#'
#'
#' }
#' @importFrom R6 R6Class
#' @importFrom base64enc base64encode
#' @export
OrsonApi <- R6::R6Class(
  "OrsonApi",
  public = list(
    api_client = NULL,

    #' @description
    #' Initialize a new OrsonApi.
    #'
    #' @param api_client An instance of API client.
    initialize = function(api_client) {
      if (!missing(api_client)) {
        self$api_client <- api_client
      } else {
        self$api_client <- ApiClient$new()
      }
    },

    #' @description
    #' Add Movie
    #'
    #' @param version 
    #' @param account_id Sirqul Account Id
    #' @param movie_name Movie Name
    #' @param third_party_account_id (optional) A third-party account id that is meaningful to your systems
    #' @param tags (optional) A user defined list (comma-delimited) of tags associated with the movie
    #' @param file (optional) An uploaded recording to analyze (Currently limited to 10MB)
    #' @param url (optional) A recording file to download and analyze (Size limit: 1GB)
    #' @param callback (optional) When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return OrsonAiAddMovieResponse
    AddMovie = function(version, account_id, movie_name, third_party_account_id = NULL, tags = NULL, file = NULL, url = NULL, callback = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$AddMovieWithHttpInfo(version, account_id, movie_name, third_party_account_id, tags, file, url, callback, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Add Movie
    #'
    #' @param version 
    #' @param account_id Sirqul Account Id
    #' @param movie_name Movie Name
    #' @param third_party_account_id (optional) A third-party account id that is meaningful to your systems
    #' @param tags (optional) A user defined list (comma-delimited) of tags associated with the movie
    #' @param file (optional) An uploaded recording to analyze (Currently limited to 10MB)
    #' @param url (optional) A recording file to download and analyze (Size limit: 1GB)
    #' @param callback (optional) When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (OrsonAiAddMovieResponse) with additional information such as HTTP status code, headers
    AddMovieWithHttpInfo = function(version, account_id, movie_name, third_party_account_id = NULL, tags = NULL, file = NULL, url = NULL, callback = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`version`)) {
        stop("Missing required parameter `version`.")
      }

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (missing(`movie_name`)) {
        stop("Missing required parameter `movie_name`.")
      }

      if (!missing(`version`) && is.null(`version`)) {
        stop("Invalid value for `version` when calling OrsonApi$AddMovie, `version` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling OrsonApi$AddMovie, `account_id` is not nullable")
      }

      if (!missing(`movie_name`) && is.null(`movie_name`)) {
        stop("Invalid value for `movie_name` when calling OrsonApi$AddMovie, `movie_name` is not nullable")
      }

      if (!missing(`third_party_account_id`) && is.null(`third_party_account_id`)) {
        stop("Invalid value for `third_party_account_id` when calling OrsonApi$AddMovie, `third_party_account_id` is not nullable")
      }

      if (!missing(`tags`) && is.null(`tags`)) {
        stop("Invalid value for `tags` when calling OrsonApi$AddMovie, `tags` is not nullable")
      }

      if (!missing(`file`) && is.null(`file`)) {
        stop("Invalid value for `file` when calling OrsonApi$AddMovie, `file` is not nullable")
      }

      if (!missing(`url`) && is.null(`url`)) {
        stop("Invalid value for `url` when calling OrsonApi$AddMovie, `url` is not nullable")
      }

      if (!missing(`callback`) && is.null(`callback`)) {
        stop("Invalid value for `callback` when calling OrsonApi$AddMovie, `callback` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["thirdPartyAccountId"]] <- `third_party_account_id`

      query_params[["tags"]] <- `tags`

      query_params[["movieName"]] <- `movie_name`

      query_params[["file"]] <- `file`

      query_params[["url"]] <- `url`

      query_params[["callback"]] <- `callback`

      local_var_url_path <- "/api/{version}/orson/ai/addMovie"
      if (!missing(`version`)) {
        local_var_url_path <- gsub("\\{version\\}", URLencode(as.character(`version`), reserved = TRUE), local_var_url_path)
      }


      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "OrsonAiAddMovieResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Search Docs
    #'
    #' @param version 
    #' @param account_id Sirqul Account Id
    #' @param doc Doc
    #' @param return_topics (optional) Return Topics
    #' @param limit (optional) Limit
    #' @param offset (optional) Offset
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return OrsonAiProtoResponse
    AiDocs = function(version, account_id, doc, return_topics = NULL, limit = NULL, offset = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$AiDocsWithHttpInfo(version, account_id, doc, return_topics, limit, offset, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Search Docs
    #'
    #' @param version 
    #' @param account_id Sirqul Account Id
    #' @param doc Doc
    #' @param return_topics (optional) Return Topics
    #' @param limit (optional) Limit
    #' @param offset (optional) Offset
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (OrsonAiProtoResponse) with additional information such as HTTP status code, headers
    AiDocsWithHttpInfo = function(version, account_id, doc, return_topics = NULL, limit = NULL, offset = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`version`)) {
        stop("Missing required parameter `version`.")
      }

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (missing(`doc`)) {
        stop("Missing required parameter `doc`.")
      }

      if (!missing(`version`) && is.null(`version`)) {
        stop("Invalid value for `version` when calling OrsonApi$AiDocs, `version` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling OrsonApi$AiDocs, `account_id` is not nullable")
      }

      if (!missing(`doc`) && is.null(`doc`)) {
        stop("Invalid value for `doc` when calling OrsonApi$AiDocs, `doc` is not nullable")
      }

      if (!missing(`return_topics`) && is.null(`return_topics`)) {
        stop("Invalid value for `return_topics` when calling OrsonApi$AiDocs, `return_topics` is not nullable")
      }

      if (!missing(`limit`) && is.null(`limit`)) {
        stop("Invalid value for `limit` when calling OrsonApi$AiDocs, `limit` is not nullable")
      }

      if (!missing(`offset`) && is.null(`offset`)) {
        stop("Invalid value for `offset` when calling OrsonApi$AiDocs, `offset` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["doc"]] <- `doc`

      query_params[["return_topics"]] <- `return_topics`

      query_params[["limit"]] <- `limit`

      query_params[["offset"]] <- `offset`

      local_var_url_path <- "/api/{version}/orson/ai/docs"
      if (!missing(`version`)) {
        local_var_url_path <- gsub("\\{version\\}", URLencode(as.character(`version`), reserved = TRUE), local_var_url_path)
      }


      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "OrsonAiProtoResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Find images
    #'
    #' @param version 
    #' @param account_id Sirqul Account Id
    #' @param text Text
    #' @param parse_flag (optional) Parse Flag
    #' @param fetch_flag (optional) Fetch Flag
    #' @param size (optional) Size
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return OrsonAiProtoResponse
    AiFindImages = function(version, account_id, text, parse_flag = NULL, fetch_flag = NULL, size = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$AiFindImagesWithHttpInfo(version, account_id, text, parse_flag, fetch_flag, size, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Find images
    #'
    #' @param version 
    #' @param account_id Sirqul Account Id
    #' @param text Text
    #' @param parse_flag (optional) Parse Flag
    #' @param fetch_flag (optional) Fetch Flag
    #' @param size (optional) Size
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (OrsonAiProtoResponse) with additional information such as HTTP status code, headers
    AiFindImagesWithHttpInfo = function(version, account_id, text, parse_flag = NULL, fetch_flag = NULL, size = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`version`)) {
        stop("Missing required parameter `version`.")
      }

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (missing(`text`)) {
        stop("Missing required parameter `text`.")
      }

      if (!missing(`version`) && is.null(`version`)) {
        stop("Invalid value for `version` when calling OrsonApi$AiFindImages, `version` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling OrsonApi$AiFindImages, `account_id` is not nullable")
      }

      if (!missing(`text`) && is.null(`text`)) {
        stop("Invalid value for `text` when calling OrsonApi$AiFindImages, `text` is not nullable")
      }

      if (!missing(`parse_flag`) && is.null(`parse_flag`)) {
        stop("Invalid value for `parse_flag` when calling OrsonApi$AiFindImages, `parse_flag` is not nullable")
      }

      if (!missing(`fetch_flag`) && is.null(`fetch_flag`)) {
        stop("Invalid value for `fetch_flag` when calling OrsonApi$AiFindImages, `fetch_flag` is not nullable")
      }

      if (!missing(`size`) && is.null(`size`)) {
        stop("Invalid value for `size` when calling OrsonApi$AiFindImages, `size` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["text"]] <- `text`

      query_params[["parse_flag"]] <- `parse_flag`

      query_params[["fetch_flag"]] <- `fetch_flag`

      query_params[["size"]] <- `size`

      local_var_url_path <- "/api/{version}/orson/ai/img"
      if (!missing(`version`)) {
        local_var_url_path <- gsub("\\{version\\}", URLencode(as.character(`version`), reserved = TRUE), local_var_url_path)
      }


      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "OrsonAiProtoResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Search Tags
    #'
    #' @param version 
    #' @param account_id Sirqul Account Id
    #' @param tags Tags
    #' @param conditional (optional) Conditional
    #' @param limit (optional) Limit
    #' @param offset (optional) Offset
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return OrsonAiProtoResponse
    AiTags = function(version, account_id, tags, conditional = NULL, limit = NULL, offset = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$AiTagsWithHttpInfo(version, account_id, tags, conditional, limit, offset, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Search Tags
    #'
    #' @param version 
    #' @param account_id Sirqul Account Id
    #' @param tags Tags
    #' @param conditional (optional) Conditional
    #' @param limit (optional) Limit
    #' @param offset (optional) Offset
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (OrsonAiProtoResponse) with additional information such as HTTP status code, headers
    AiTagsWithHttpInfo = function(version, account_id, tags, conditional = NULL, limit = NULL, offset = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`version`)) {
        stop("Missing required parameter `version`.")
      }

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (missing(`tags`)) {
        stop("Missing required parameter `tags`.")
      }

      if (!missing(`version`) && is.null(`version`)) {
        stop("Invalid value for `version` when calling OrsonApi$AiTags, `version` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling OrsonApi$AiTags, `account_id` is not nullable")
      }

      if (!missing(`tags`) && is.null(`tags`)) {
        stop("Invalid value for `tags` when calling OrsonApi$AiTags, `tags` is not nullable")
      }

      if (!missing(`conditional`) && is.null(`conditional`)) {
        stop("Invalid value for `conditional` when calling OrsonApi$AiTags, `conditional` is not nullable")
      }

      if (!missing(`limit`) && is.null(`limit`)) {
        stop("Invalid value for `limit` when calling OrsonApi$AiTags, `limit` is not nullable")
      }

      if (!missing(`offset`) && is.null(`offset`)) {
        stop("Invalid value for `offset` when calling OrsonApi$AiTags, `offset` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["tags"]] <- `tags`

      query_params[["conditional"]] <- `conditional`

      query_params[["limit"]] <- `limit`

      query_params[["offset"]] <- `offset`

      local_var_url_path <- "/api/{version}/orson/ai/tags"
      if (!missing(`version`)) {
        local_var_url_path <- gsub("\\{version\\}", URLencode(as.character(`version`), reserved = TRUE), local_var_url_path)
      }


      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "OrsonAiProtoResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Search Text
    #'
    #' @param version 
    #' @param account_id Sirqul Account Id
    #' @param terms Terms
    #' @param conditional (optional) Conditional
    #' @param limit (optional) Limit
    #' @param offset (optional) Offset
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return OrsonAiProtoResponse
    AiText = function(version, account_id, terms, conditional = NULL, limit = NULL, offset = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$AiTextWithHttpInfo(version, account_id, terms, conditional, limit, offset, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Search Text
    #'
    #' @param version 
    #' @param account_id Sirqul Account Id
    #' @param terms Terms
    #' @param conditional (optional) Conditional
    #' @param limit (optional) Limit
    #' @param offset (optional) Offset
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (OrsonAiProtoResponse) with additional information such as HTTP status code, headers
    AiTextWithHttpInfo = function(version, account_id, terms, conditional = NULL, limit = NULL, offset = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`version`)) {
        stop("Missing required parameter `version`.")
      }

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (missing(`terms`)) {
        stop("Missing required parameter `terms`.")
      }

      if (!missing(`version`) && is.null(`version`)) {
        stop("Invalid value for `version` when calling OrsonApi$AiText, `version` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling OrsonApi$AiText, `account_id` is not nullable")
      }

      if (!missing(`terms`) && is.null(`terms`)) {
        stop("Invalid value for `terms` when calling OrsonApi$AiText, `terms` is not nullable")
      }

      if (!missing(`conditional`) && is.null(`conditional`)) {
        stop("Invalid value for `conditional` when calling OrsonApi$AiText, `conditional` is not nullable")
      }

      if (!missing(`limit`) && is.null(`limit`)) {
        stop("Invalid value for `limit` when calling OrsonApi$AiText, `limit` is not nullable")
      }

      if (!missing(`offset`) && is.null(`offset`)) {
        stop("Invalid value for `offset` when calling OrsonApi$AiText, `offset` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["terms"]] <- `terms`

      query_params[["conditional"]] <- `conditional`

      query_params[["limit"]] <- `limit`

      query_params[["offset"]] <- `offset`

      local_var_url_path <- "/api/{version}/orson/ai/text"
      if (!missing(`version`)) {
        local_var_url_path <- gsub("\\{version\\}", URLencode(as.character(`version`), reserved = TRUE), local_var_url_path)
      }


      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "OrsonAiProtoResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Batch Analysis
    #'
    #' @param version 
    #' @param account_id Sirqul Account Id
    #' @param third_party_account_id (optional) A third-party account id that is meaningful to your systems
    #' @param limit (optional) The number of topics to return
    #' @param operations (optional) The comma-delimited list of A/V batch analysis operations to run on this file. Possible values: Transcript,Topics,Emotions
    #' @param file (optional) An uploaded recording to analyze (Currently limited to 10MB)
    #' @param url (optional) A recording file to download and analyze (Size limit: 1GB)
    #' @param callback (optional) When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return OrsonAiBatchResponse
    Batch = function(version, account_id, third_party_account_id = NULL, limit = NULL, operations = NULL, file = NULL, url = NULL, callback = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$BatchWithHttpInfo(version, account_id, third_party_account_id, limit, operations, file, url, callback, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Batch Analysis
    #'
    #' @param version 
    #' @param account_id Sirqul Account Id
    #' @param third_party_account_id (optional) A third-party account id that is meaningful to your systems
    #' @param limit (optional) The number of topics to return
    #' @param operations (optional) The comma-delimited list of A/V batch analysis operations to run on this file. Possible values: Transcript,Topics,Emotions
    #' @param file (optional) An uploaded recording to analyze (Currently limited to 10MB)
    #' @param url (optional) A recording file to download and analyze (Size limit: 1GB)
    #' @param callback (optional) When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (OrsonAiBatchResponse) with additional information such as HTTP status code, headers
    BatchWithHttpInfo = function(version, account_id, third_party_account_id = NULL, limit = NULL, operations = NULL, file = NULL, url = NULL, callback = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`version`)) {
        stop("Missing required parameter `version`.")
      }

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (!missing(`version`) && is.null(`version`)) {
        stop("Invalid value for `version` when calling OrsonApi$Batch, `version` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling OrsonApi$Batch, `account_id` is not nullable")
      }

      if (!missing(`third_party_account_id`) && is.null(`third_party_account_id`)) {
        stop("Invalid value for `third_party_account_id` when calling OrsonApi$Batch, `third_party_account_id` is not nullable")
      }

      if (!missing(`limit`) && is.null(`limit`)) {
        stop("Invalid value for `limit` when calling OrsonApi$Batch, `limit` is not nullable")
      }

      if (!missing(`operations`) && is.null(`operations`)) {
        stop("Invalid value for `operations` when calling OrsonApi$Batch, `operations` is not nullable")
      }

      if (!missing(`file`) && is.null(`file`)) {
        stop("Invalid value for `file` when calling OrsonApi$Batch, `file` is not nullable")
      }

      if (!missing(`url`) && is.null(`url`)) {
        stop("Invalid value for `url` when calling OrsonApi$Batch, `url` is not nullable")
      }

      if (!missing(`callback`) && is.null(`callback`)) {
        stop("Invalid value for `callback` when calling OrsonApi$Batch, `callback` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["thirdPartyAccountId"]] <- `third_party_account_id`

      query_params[["limit"]] <- `limit`

      query_params[["operations"]] <- `operations`

      query_params[["file"]] <- `file`

      query_params[["url"]] <- `url`

      query_params[["callback"]] <- `callback`

      local_var_url_path <- "/api/{version}/orson/ai/batch"
      if (!missing(`version`)) {
        local_var_url_path <- gsub("\\{version\\}", URLencode(as.character(`version`), reserved = TRUE), local_var_url_path)
      }


      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "OrsonAiBatchResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Creates an instant episode
    #'
    #' @param version 
    #' @param account_id Sirqul Account Id
    #' @param data Request Data String
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return OrsonEpisodeResponse
    CreateInstantEpisode = function(version, account_id, data, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$CreateInstantEpisodeWithHttpInfo(version, account_id, data, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Creates an instant episode
    #'
    #' @param version 
    #' @param account_id Sirqul Account Id
    #' @param data Request Data String
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (OrsonEpisodeResponse) with additional information such as HTTP status code, headers
    CreateInstantEpisodeWithHttpInfo = function(version, account_id, data, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`version`)) {
        stop("Missing required parameter `version`.")
      }

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (missing(`data`)) {
        stop("Missing required parameter `data`.")
      }

      if (!missing(`version`) && is.null(`version`)) {
        stop("Invalid value for `version` when calling OrsonApi$CreateInstantEpisode, `version` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling OrsonApi$CreateInstantEpisode, `account_id` is not nullable")
      }

      if (!missing(`data`) && is.null(`data`)) {
        stop("Invalid value for `data` when calling OrsonApi$CreateInstantEpisode, `data` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["data"]] <- `data`

      local_var_url_path <- "/api/{version}/orson/stories/episodes/instant"
      if (!missing(`version`)) {
        local_var_url_path <- gsub("\\{version\\}", URLencode(as.character(`version`), reserved = TRUE), local_var_url_path)
      }


      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "OrsonEpisodeResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Create VoiceCanvas images
    #'
    #' @param version 
    #' @param account_id Sirqul Account Id
    #' @param dimensions Enum: \"256x256\" \"512x512\" \"1024x1024\"
    #' @param third_party_account_id (optional) A third-party account id that is meaningful to your systems
    #' @param text (optional) Provide a transcript or previously extracted topics for image generation
    #' @param file (optional) An uploaded recording to analyze (Currently limited to 10MB)
    #' @param url (optional) A recording file to download and analyze (Size limit: 1GB)
    #' @param parse_flag (optional) When false, uses the raw value from text instead of identifying topics to fetch/generate from
    #' @param fetch_flag (optional) When true, fetches images instead of generating them
    #' @param callback (optional) When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return OrsonAiVoiceCanvasResponse
    CreateVoiceCanvas = function(version, account_id, dimensions, third_party_account_id = NULL, text = NULL, file = NULL, url = NULL, parse_flag = NULL, fetch_flag = NULL, callback = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$CreateVoiceCanvasWithHttpInfo(version, account_id, dimensions, third_party_account_id, text, file, url, parse_flag, fetch_flag, callback, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Create VoiceCanvas images
    #'
    #' @param version 
    #' @param account_id Sirqul Account Id
    #' @param dimensions Enum: \"256x256\" \"512x512\" \"1024x1024\"
    #' @param third_party_account_id (optional) A third-party account id that is meaningful to your systems
    #' @param text (optional) Provide a transcript or previously extracted topics for image generation
    #' @param file (optional) An uploaded recording to analyze (Currently limited to 10MB)
    #' @param url (optional) A recording file to download and analyze (Size limit: 1GB)
    #' @param parse_flag (optional) When false, uses the raw value from text instead of identifying topics to fetch/generate from
    #' @param fetch_flag (optional) When true, fetches images instead of generating them
    #' @param callback (optional) When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (OrsonAiVoiceCanvasResponse) with additional information such as HTTP status code, headers
    CreateVoiceCanvasWithHttpInfo = function(version, account_id, dimensions, third_party_account_id = NULL, text = NULL, file = NULL, url = NULL, parse_flag = NULL, fetch_flag = NULL, callback = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`version`)) {
        stop("Missing required parameter `version`.")
      }

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (missing(`dimensions`)) {
        stop("Missing required parameter `dimensions`.")
      }

      if (!missing(`version`) && is.null(`version`)) {
        stop("Invalid value for `version` when calling OrsonApi$CreateVoiceCanvas, `version` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling OrsonApi$CreateVoiceCanvas, `account_id` is not nullable")
      }

      if (!missing(`dimensions`) && is.null(`dimensions`)) {
        stop("Invalid value for `dimensions` when calling OrsonApi$CreateVoiceCanvas, `dimensions` is not nullable")
      }

      if (!missing(`third_party_account_id`) && is.null(`third_party_account_id`)) {
        stop("Invalid value for `third_party_account_id` when calling OrsonApi$CreateVoiceCanvas, `third_party_account_id` is not nullable")
      }

      if (!missing(`text`) && is.null(`text`)) {
        stop("Invalid value for `text` when calling OrsonApi$CreateVoiceCanvas, `text` is not nullable")
      }

      if (!missing(`file`) && is.null(`file`)) {
        stop("Invalid value for `file` when calling OrsonApi$CreateVoiceCanvas, `file` is not nullable")
      }

      if (!missing(`url`) && is.null(`url`)) {
        stop("Invalid value for `url` when calling OrsonApi$CreateVoiceCanvas, `url` is not nullable")
      }

      if (!missing(`parse_flag`) && is.null(`parse_flag`)) {
        stop("Invalid value for `parse_flag` when calling OrsonApi$CreateVoiceCanvas, `parse_flag` is not nullable")
      }

      if (!missing(`fetch_flag`) && is.null(`fetch_flag`)) {
        stop("Invalid value for `fetch_flag` when calling OrsonApi$CreateVoiceCanvas, `fetch_flag` is not nullable")
      }

      if (!missing(`callback`) && is.null(`callback`)) {
        stop("Invalid value for `callback` when calling OrsonApi$CreateVoiceCanvas, `callback` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["thirdPartyAccountId"]] <- `third_party_account_id`

      query_params[["dimensions"]] <- `dimensions`

      query_params[["text"]] <- `text`

      query_params[["file"]] <- `file`

      query_params[["url"]] <- `url`

      query_params[["parseFlag"]] <- `parse_flag`

      query_params[["fetchFlag"]] <- `fetch_flag`

      query_params[["callback"]] <- `callback`

      local_var_url_path <- "/api/{version}/orson/ai/voiceCanvas"
      if (!missing(`version`)) {
        local_var_url_path <- gsub("\\{version\\}", URLencode(as.character(`version`), reserved = TRUE), local_var_url_path)
      }


      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "OrsonAiVoiceCanvasResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Detect emotions
    #'
    #' @param version 
    #' @param account_id Sirqul Account Id
    #' @param third_party_account_id (optional) A third-party account id that is meaningful to your systems
    #' @param file (optional) An uploaded recording to analyze (Currently limited to 10MB)
    #' @param url (optional) A recording file to download and analyze (Size limit: 1GB)
    #' @param callback (optional) When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return OrsonAiEmotionsResponse
    Emotion = function(version, account_id, third_party_account_id = NULL, file = NULL, url = NULL, callback = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$EmotionWithHttpInfo(version, account_id, third_party_account_id, file, url, callback, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Detect emotions
    #'
    #' @param version 
    #' @param account_id Sirqul Account Id
    #' @param third_party_account_id (optional) A third-party account id that is meaningful to your systems
    #' @param file (optional) An uploaded recording to analyze (Currently limited to 10MB)
    #' @param url (optional) A recording file to download and analyze (Size limit: 1GB)
    #' @param callback (optional) When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (OrsonAiEmotionsResponse) with additional information such as HTTP status code, headers
    EmotionWithHttpInfo = function(version, account_id, third_party_account_id = NULL, file = NULL, url = NULL, callback = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`version`)) {
        stop("Missing required parameter `version`.")
      }

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (!missing(`version`) && is.null(`version`)) {
        stop("Invalid value for `version` when calling OrsonApi$Emotion, `version` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling OrsonApi$Emotion, `account_id` is not nullable")
      }

      if (!missing(`third_party_account_id`) && is.null(`third_party_account_id`)) {
        stop("Invalid value for `third_party_account_id` when calling OrsonApi$Emotion, `third_party_account_id` is not nullable")
      }

      if (!missing(`file`) && is.null(`file`)) {
        stop("Invalid value for `file` when calling OrsonApi$Emotion, `file` is not nullable")
      }

      if (!missing(`url`) && is.null(`url`)) {
        stop("Invalid value for `url` when calling OrsonApi$Emotion, `url` is not nullable")
      }

      if (!missing(`callback`) && is.null(`callback`)) {
        stop("Invalid value for `callback` when calling OrsonApi$Emotion, `callback` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["thirdPartyAccountId"]] <- `third_party_account_id`

      query_params[["file"]] <- `file`

      query_params[["url"]] <- `url`

      query_params[["callback"]] <- `callback`

      local_var_url_path <- "/api/{version}/orson/ai/emotion"
      if (!missing(`version`)) {
        local_var_url_path <- gsub("\\{version\\}", URLencode(as.character(`version`), reserved = TRUE), local_var_url_path)
      }


      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "OrsonAiEmotionsResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Get Add Movie Result
    #'
    #' @param version 
    #' @param request_id Orson Request Id
    #' @param account_id Sirqul Account Id
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return OrsonAiAddMovieResponse
    GetAddMovieResult = function(version, request_id, account_id, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$GetAddMovieResultWithHttpInfo(version, request_id, account_id, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Get Add Movie Result
    #'
    #' @param version 
    #' @param request_id Orson Request Id
    #' @param account_id Sirqul Account Id
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (OrsonAiAddMovieResponse) with additional information such as HTTP status code, headers
    GetAddMovieResultWithHttpInfo = function(version, request_id, account_id, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`version`)) {
        stop("Missing required parameter `version`.")
      }

      if (missing(`request_id`)) {
        stop("Missing required parameter `request_id`.")
      }

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (!missing(`version`) && is.null(`version`)) {
        stop("Invalid value for `version` when calling OrsonApi$GetAddMovieResult, `version` is not nullable")
      }

      if (!missing(`request_id`) && is.null(`request_id`)) {
        stop("Invalid value for `request_id` when calling OrsonApi$GetAddMovieResult, `request_id` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling OrsonApi$GetAddMovieResult, `account_id` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      local_var_url_path <- "/api/{version}/orson/ai/addMovie/{requestId}"
      if (!missing(`version`)) {
        local_var_url_path <- gsub("\\{version\\}", URLencode(as.character(`version`), reserved = TRUE), local_var_url_path)
      }

      if (!missing(`request_id`)) {
        local_var_url_path <- gsub("\\{requestId\\}", URLencode(as.character(`request_id`), reserved = TRUE), local_var_url_path)
      }


      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "OrsonAiAddMovieResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Get Batch Analysis Results
    #'
    #' @param version 
    #' @param request_id Orson Request Id
    #' @param account_id Sirqul Account Id
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return OrsonAiBatchResponse
    GetBatch = function(version, request_id, account_id, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$GetBatchWithHttpInfo(version, request_id, account_id, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Get Batch Analysis Results
    #'
    #' @param version 
    #' @param request_id Orson Request Id
    #' @param account_id Sirqul Account Id
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (OrsonAiBatchResponse) with additional information such as HTTP status code, headers
    GetBatchWithHttpInfo = function(version, request_id, account_id, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`version`)) {
        stop("Missing required parameter `version`.")
      }

      if (missing(`request_id`)) {
        stop("Missing required parameter `request_id`.")
      }

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (!missing(`version`) && is.null(`version`)) {
        stop("Invalid value for `version` when calling OrsonApi$GetBatch, `version` is not nullable")
      }

      if (!missing(`request_id`) && is.null(`request_id`)) {
        stop("Invalid value for `request_id` when calling OrsonApi$GetBatch, `request_id` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling OrsonApi$GetBatch, `account_id` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      local_var_url_path <- "/api/{version}/orson/ai/batch/{requestId}"
      if (!missing(`version`)) {
        local_var_url_path <- gsub("\\{version\\}", URLencode(as.character(`version`), reserved = TRUE), local_var_url_path)
      }

      if (!missing(`request_id`)) {
        local_var_url_path <- gsub("\\{requestId\\}", URLencode(as.character(`request_id`), reserved = TRUE), local_var_url_path)
      }


      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "OrsonAiBatchResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Get Emotion Results
    #'
    #' @param version 
    #' @param request_id Orson Request Id
    #' @param account_id Sirqul Account Id
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return OrsonAiEmotionsResponse
    GetEmotion = function(version, request_id, account_id, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$GetEmotionWithHttpInfo(version, request_id, account_id, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Get Emotion Results
    #'
    #' @param version 
    #' @param request_id Orson Request Id
    #' @param account_id Sirqul Account Id
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (OrsonAiEmotionsResponse) with additional information such as HTTP status code, headers
    GetEmotionWithHttpInfo = function(version, request_id, account_id, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`version`)) {
        stop("Missing required parameter `version`.")
      }

      if (missing(`request_id`)) {
        stop("Missing required parameter `request_id`.")
      }

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (!missing(`version`) && is.null(`version`)) {
        stop("Invalid value for `version` when calling OrsonApi$GetEmotion, `version` is not nullable")
      }

      if (!missing(`request_id`) && is.null(`request_id`)) {
        stop("Invalid value for `request_id` when calling OrsonApi$GetEmotion, `request_id` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling OrsonApi$GetEmotion, `account_id` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      local_var_url_path <- "/api/{version}/orson/ai/emotion/{requestId}"
      if (!missing(`version`)) {
        local_var_url_path <- gsub("\\{version\\}", URLencode(as.character(`version`), reserved = TRUE), local_var_url_path)
      }

      if (!missing(`request_id`)) {
        local_var_url_path <- gsub("\\{requestId\\}", URLencode(as.character(`request_id`), reserved = TRUE), local_var_url_path)
      }


      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "OrsonAiEmotionsResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Check episode status
    #'
    #' @param version 
    #' @param episode_id Episode ID
    #' @param account_id Sirqul Account Id
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return OrsonEpisodeResponse
    GetEpisodeStatus = function(version, episode_id, account_id, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$GetEpisodeStatusWithHttpInfo(version, episode_id, account_id, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Check episode status
    #'
    #' @param version 
    #' @param episode_id Episode ID
    #' @param account_id Sirqul Account Id
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (OrsonEpisodeResponse) with additional information such as HTTP status code, headers
    GetEpisodeStatusWithHttpInfo = function(version, episode_id, account_id, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`version`)) {
        stop("Missing required parameter `version`.")
      }

      if (missing(`episode_id`)) {
        stop("Missing required parameter `episode_id`.")
      }

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (!missing(`version`) && is.null(`version`)) {
        stop("Invalid value for `version` when calling OrsonApi$GetEpisodeStatus, `version` is not nullable")
      }

      if (!missing(`episode_id`) && is.null(`episode_id`)) {
        stop("Invalid value for `episode_id` when calling OrsonApi$GetEpisodeStatus, `episode_id` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling OrsonApi$GetEpisodeStatus, `account_id` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      local_var_url_path <- "/api/{version}/orson/stories/episodes/{episodeId}/status"
      if (!missing(`version`)) {
        local_var_url_path <- gsub("\\{version\\}", URLencode(as.character(`version`), reserved = TRUE), local_var_url_path)
      }

      if (!missing(`episode_id`)) {
        local_var_url_path <- gsub("\\{episodeId\\}", URLencode(as.character(`episode_id`), reserved = TRUE), local_var_url_path)
      }


      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "OrsonEpisodeResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Check episode status
    #'
    #' @param version 
    #' @param render_id Render ID
    #' @param account_id Sirqul Account Id
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return OrsonRenderResponse
    GetRenderStatus = function(version, render_id, account_id, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$GetRenderStatusWithHttpInfo(version, render_id, account_id, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Check episode status
    #'
    #' @param version 
    #' @param render_id Render ID
    #' @param account_id Sirqul Account Id
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (OrsonRenderResponse) with additional information such as HTTP status code, headers
    GetRenderStatusWithHttpInfo = function(version, render_id, account_id, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`version`)) {
        stop("Missing required parameter `version`.")
      }

      if (missing(`render_id`)) {
        stop("Missing required parameter `render_id`.")
      }

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (!missing(`version`) && is.null(`version`)) {
        stop("Invalid value for `version` when calling OrsonApi$GetRenderStatus, `version` is not nullable")
      }

      if (!missing(`render_id`) && is.null(`render_id`)) {
        stop("Invalid value for `render_id` when calling OrsonApi$GetRenderStatus, `render_id` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling OrsonApi$GetRenderStatus, `account_id` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      local_var_url_path <- "/api/{version}/orson/stories/renders/{renderId}/status"
      if (!missing(`version`)) {
        local_var_url_path <- gsub("\\{version\\}", URLencode(as.character(`version`), reserved = TRUE), local_var_url_path)
      }

      if (!missing(`render_id`)) {
        local_var_url_path <- gsub("\\{renderId\\}", URLencode(as.character(`render_id`), reserved = TRUE), local_var_url_path)
      }


      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "OrsonRenderResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Get Speach to Text Result
    #'
    #' @param version 
    #' @param request_id Orson Request Id
    #' @param account_id Sirqul Account Id
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return OrsonAiSTTResponse
    GetSTT = function(version, request_id, account_id, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$GetSTTWithHttpInfo(version, request_id, account_id, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Get Speach to Text Result
    #'
    #' @param version 
    #' @param request_id Orson Request Id
    #' @param account_id Sirqul Account Id
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (OrsonAiSTTResponse) with additional information such as HTTP status code, headers
    GetSTTWithHttpInfo = function(version, request_id, account_id, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`version`)) {
        stop("Missing required parameter `version`.")
      }

      if (missing(`request_id`)) {
        stop("Missing required parameter `request_id`.")
      }

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (!missing(`version`) && is.null(`version`)) {
        stop("Invalid value for `version` when calling OrsonApi$GetSTT, `version` is not nullable")
      }

      if (!missing(`request_id`) && is.null(`request_id`)) {
        stop("Invalid value for `request_id` when calling OrsonApi$GetSTT, `request_id` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling OrsonApi$GetSTT, `account_id` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      local_var_url_path <- "/api/{version}/orson/ai/stt/{requestId}"
      if (!missing(`version`)) {
        local_var_url_path <- gsub("\\{version\\}", URLencode(as.character(`version`), reserved = TRUE), local_var_url_path)
      }

      if (!missing(`request_id`)) {
        local_var_url_path <- gsub("\\{requestId\\}", URLencode(as.character(`request_id`), reserved = TRUE), local_var_url_path)
      }


      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "OrsonAiSTTResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Get Text to Speach Result
    #'
    #' @param version 
    #' @param request_id Orson Request Id
    #' @param account_id Sirqul Account Id
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return OrsonAiTTSResponse
    GetTTS = function(version, request_id, account_id, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$GetTTSWithHttpInfo(version, request_id, account_id, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Get Text to Speach Result
    #'
    #' @param version 
    #' @param request_id Orson Request Id
    #' @param account_id Sirqul Account Id
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (OrsonAiTTSResponse) with additional information such as HTTP status code, headers
    GetTTSWithHttpInfo = function(version, request_id, account_id, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`version`)) {
        stop("Missing required parameter `version`.")
      }

      if (missing(`request_id`)) {
        stop("Missing required parameter `request_id`.")
      }

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (!missing(`version`) && is.null(`version`)) {
        stop("Invalid value for `version` when calling OrsonApi$GetTTS, `version` is not nullable")
      }

      if (!missing(`request_id`) && is.null(`request_id`)) {
        stop("Invalid value for `request_id` when calling OrsonApi$GetTTS, `request_id` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling OrsonApi$GetTTS, `account_id` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      local_var_url_path <- "/api/{version}/orson/ai/tts/{requestId}"
      if (!missing(`version`)) {
        local_var_url_path <- gsub("\\{version\\}", URLencode(as.character(`version`), reserved = TRUE), local_var_url_path)
      }

      if (!missing(`request_id`)) {
        local_var_url_path <- gsub("\\{requestId\\}", URLencode(as.character(`request_id`), reserved = TRUE), local_var_url_path)
      }


      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "OrsonAiTTSResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Get TechTune Results
    #'
    #' @param version 
    #' @param request_id Orson Request Id
    #' @param account_id Sirqul Account Id
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return OrsonAiTechTuneResponse
    GetTechTune = function(version, request_id, account_id, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$GetTechTuneWithHttpInfo(version, request_id, account_id, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Get TechTune Results
    #'
    #' @param version 
    #' @param request_id Orson Request Id
    #' @param account_id Sirqul Account Id
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (OrsonAiTechTuneResponse) with additional information such as HTTP status code, headers
    GetTechTuneWithHttpInfo = function(version, request_id, account_id, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`version`)) {
        stop("Missing required parameter `version`.")
      }

      if (missing(`request_id`)) {
        stop("Missing required parameter `request_id`.")
      }

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (!missing(`version`) && is.null(`version`)) {
        stop("Invalid value for `version` when calling OrsonApi$GetTechTune, `version` is not nullable")
      }

      if (!missing(`request_id`) && is.null(`request_id`)) {
        stop("Invalid value for `request_id` when calling OrsonApi$GetTechTune, `request_id` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling OrsonApi$GetTechTune, `account_id` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      local_var_url_path <- "/api/{version}/orson/ai/techTune/{requestId}"
      if (!missing(`version`)) {
        local_var_url_path <- gsub("\\{version\\}", URLencode(as.character(`version`), reserved = TRUE), local_var_url_path)
      }

      if (!missing(`request_id`)) {
        local_var_url_path <- gsub("\\{requestId\\}", URLencode(as.character(`request_id`), reserved = TRUE), local_var_url_path)
      }


      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "OrsonAiTechTuneResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Get Topics
    #'
    #' @param version 
    #' @param request_id Orson Request Id
    #' @param account_id Sirqul Account Id
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return OrsonAiTopicsResponse
    GetTopics = function(version, request_id, account_id, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$GetTopicsWithHttpInfo(version, request_id, account_id, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Get Topics
    #'
    #' @param version 
    #' @param request_id Orson Request Id
    #' @param account_id Sirqul Account Id
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (OrsonAiTopicsResponse) with additional information such as HTTP status code, headers
    GetTopicsWithHttpInfo = function(version, request_id, account_id, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`version`)) {
        stop("Missing required parameter `version`.")
      }

      if (missing(`request_id`)) {
        stop("Missing required parameter `request_id`.")
      }

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (!missing(`version`) && is.null(`version`)) {
        stop("Invalid value for `version` when calling OrsonApi$GetTopics, `version` is not nullable")
      }

      if (!missing(`request_id`) && is.null(`request_id`)) {
        stop("Invalid value for `request_id` when calling OrsonApi$GetTopics, `request_id` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling OrsonApi$GetTopics, `account_id` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      local_var_url_path <- "/api/{version}/orson/ai/topics/{requestId}"
      if (!missing(`version`)) {
        local_var_url_path <- gsub("\\{version\\}", URLencode(as.character(`version`), reserved = TRUE), local_var_url_path)
      }

      if (!missing(`request_id`)) {
        local_var_url_path <- gsub("\\{requestId\\}", URLencode(as.character(`request_id`), reserved = TRUE), local_var_url_path)
      }


      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "OrsonAiTopicsResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Get VoiceCanvas images
    #'
    #' @param version 
    #' @param request_id Orson Request Id
    #' @param account_id Sirqul Account Id
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return OrsonAiVoiceCanvasResponse
    GetVoiceCanvas = function(version, request_id, account_id, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$GetVoiceCanvasWithHttpInfo(version, request_id, account_id, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Get VoiceCanvas images
    #'
    #' @param version 
    #' @param request_id Orson Request Id
    #' @param account_id Sirqul Account Id
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (OrsonAiVoiceCanvasResponse) with additional information such as HTTP status code, headers
    GetVoiceCanvasWithHttpInfo = function(version, request_id, account_id, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`version`)) {
        stop("Missing required parameter `version`.")
      }

      if (missing(`request_id`)) {
        stop("Missing required parameter `request_id`.")
      }

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (!missing(`version`) && is.null(`version`)) {
        stop("Invalid value for `version` when calling OrsonApi$GetVoiceCanvas, `version` is not nullable")
      }

      if (!missing(`request_id`) && is.null(`request_id`)) {
        stop("Invalid value for `request_id` when calling OrsonApi$GetVoiceCanvas, `request_id` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling OrsonApi$GetVoiceCanvas, `account_id` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      local_var_url_path <- "/api/{version}/orson/ai/voiceCanvas/{requestId}"
      if (!missing(`version`)) {
        local_var_url_path <- gsub("\\{version\\}", URLencode(as.character(`version`), reserved = TRUE), local_var_url_path)
      }

      if (!missing(`request_id`)) {
        local_var_url_path <- gsub("\\{requestId\\}", URLencode(as.character(`request_id`), reserved = TRUE), local_var_url_path)
      }


      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "OrsonAiVoiceCanvasResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Starts a StoryStitch video render
    #'
    #' @param version 
    #' @param account_id Sirqul Account Id
    #' @param data Request Data String
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return OrsonRenderResponse
    StartVideoRender = function(version, account_id, data, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$StartVideoRenderWithHttpInfo(version, account_id, data, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Starts a StoryStitch video render
    #'
    #' @param version 
    #' @param account_id Sirqul Account Id
    #' @param data Request Data String
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (OrsonRenderResponse) with additional information such as HTTP status code, headers
    StartVideoRenderWithHttpInfo = function(version, account_id, data, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`version`)) {
        stop("Missing required parameter `version`.")
      }

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (missing(`data`)) {
        stop("Missing required parameter `data`.")
      }

      if (!missing(`version`) && is.null(`version`)) {
        stop("Invalid value for `version` when calling OrsonApi$StartVideoRender, `version` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling OrsonApi$StartVideoRender, `account_id` is not nullable")
      }

      if (!missing(`data`) && is.null(`data`)) {
        stop("Invalid value for `data` when calling OrsonApi$StartVideoRender, `data` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["data"]] <- `data`

      local_var_url_path <- "/api/{version}/orson/stories/renders"
      if (!missing(`version`)) {
        local_var_url_path <- gsub("\\{version\\}", URLencode(as.character(`version`), reserved = TRUE), local_var_url_path)
      }


      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "OrsonRenderResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Speach to Text
    #'
    #' @param version 
    #' @param account_id Sirqul Account Id
    #' @param third_party_account_id (optional) A third-party account id that is meaningful to your systems
    #' @param source_language (optional) Source Language
    #' @param target_language (optional) Target Language
    #' @param file (optional) An uploaded recording to analyze (Currently limited to 10MB)
    #' @param url (optional) A recording file to download and analyze (Size limit: 1GB)
    #' @param callback (optional) When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return OrsonAiSTTResponse
    Stt = function(version, account_id, third_party_account_id = NULL, source_language = NULL, target_language = NULL, file = NULL, url = NULL, callback = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$SttWithHttpInfo(version, account_id, third_party_account_id, source_language, target_language, file, url, callback, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Speach to Text
    #'
    #' @param version 
    #' @param account_id Sirqul Account Id
    #' @param third_party_account_id (optional) A third-party account id that is meaningful to your systems
    #' @param source_language (optional) Source Language
    #' @param target_language (optional) Target Language
    #' @param file (optional) An uploaded recording to analyze (Currently limited to 10MB)
    #' @param url (optional) A recording file to download and analyze (Size limit: 1GB)
    #' @param callback (optional) When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (OrsonAiSTTResponse) with additional information such as HTTP status code, headers
    SttWithHttpInfo = function(version, account_id, third_party_account_id = NULL, source_language = NULL, target_language = NULL, file = NULL, url = NULL, callback = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`version`)) {
        stop("Missing required parameter `version`.")
      }

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (!missing(`version`) && is.null(`version`)) {
        stop("Invalid value for `version` when calling OrsonApi$Stt, `version` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling OrsonApi$Stt, `account_id` is not nullable")
      }

      if (!missing(`third_party_account_id`) && is.null(`third_party_account_id`)) {
        stop("Invalid value for `third_party_account_id` when calling OrsonApi$Stt, `third_party_account_id` is not nullable")
      }

      if (!missing(`source_language`) && is.null(`source_language`)) {
        stop("Invalid value for `source_language` when calling OrsonApi$Stt, `source_language` is not nullable")
      }

      if (!missing(`target_language`) && is.null(`target_language`)) {
        stop("Invalid value for `target_language` when calling OrsonApi$Stt, `target_language` is not nullable")
      }

      if (!missing(`file`) && is.null(`file`)) {
        stop("Invalid value for `file` when calling OrsonApi$Stt, `file` is not nullable")
      }

      if (!missing(`url`) && is.null(`url`)) {
        stop("Invalid value for `url` when calling OrsonApi$Stt, `url` is not nullable")
      }

      if (!missing(`callback`) && is.null(`callback`)) {
        stop("Invalid value for `callback` when calling OrsonApi$Stt, `callback` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["thirdPartyAccountId"]] <- `third_party_account_id`

      query_params[["sourceLanguage"]] <- `source_language`

      query_params[["targetLanguage"]] <- `target_language`

      query_params[["file"]] <- `file`

      query_params[["url"]] <- `url`

      query_params[["callback"]] <- `callback`

      local_var_url_path <- "/api/{version}/orson/ai/stt"
      if (!missing(`version`)) {
        local_var_url_path <- gsub("\\{version\\}", URLencode(as.character(`version`), reserved = TRUE), local_var_url_path)
      }


      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "OrsonAiSTTResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Summarize Topics
    #'
    #' @param version 
    #' @param account_id Sirqul Account Id
    #' @param third_party_account_id (optional) A third-party account id that is meaningful to your systems
    #' @param doc (optional) The text to get topics for.
    #' @param file (optional) An uploaded recording to analyze (Currently limited to 10MB)
    #' @param url (optional) A recording file to download and analyze (Size limit: 1GB)
    #' @param limit (optional) The number of results to return
    #' @param offset (optional) The starting offset into the total result set to start from
    #' @param callback (optional) When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return OrsonAiTopicsResponse
    SummarizeTopics = function(version, account_id, third_party_account_id = NULL, doc = NULL, file = NULL, url = NULL, limit = NULL, offset = NULL, callback = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$SummarizeTopicsWithHttpInfo(version, account_id, third_party_account_id, doc, file, url, limit, offset, callback, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Summarize Topics
    #'
    #' @param version 
    #' @param account_id Sirqul Account Id
    #' @param third_party_account_id (optional) A third-party account id that is meaningful to your systems
    #' @param doc (optional) The text to get topics for.
    #' @param file (optional) An uploaded recording to analyze (Currently limited to 10MB)
    #' @param url (optional) A recording file to download and analyze (Size limit: 1GB)
    #' @param limit (optional) The number of results to return
    #' @param offset (optional) The starting offset into the total result set to start from
    #' @param callback (optional) When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (OrsonAiTopicsResponse) with additional information such as HTTP status code, headers
    SummarizeTopicsWithHttpInfo = function(version, account_id, third_party_account_id = NULL, doc = NULL, file = NULL, url = NULL, limit = NULL, offset = NULL, callback = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`version`)) {
        stop("Missing required parameter `version`.")
      }

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (!missing(`version`) && is.null(`version`)) {
        stop("Invalid value for `version` when calling OrsonApi$SummarizeTopics, `version` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling OrsonApi$SummarizeTopics, `account_id` is not nullable")
      }

      if (!missing(`third_party_account_id`) && is.null(`third_party_account_id`)) {
        stop("Invalid value for `third_party_account_id` when calling OrsonApi$SummarizeTopics, `third_party_account_id` is not nullable")
      }

      if (!missing(`doc`) && is.null(`doc`)) {
        stop("Invalid value for `doc` when calling OrsonApi$SummarizeTopics, `doc` is not nullable")
      }

      if (!missing(`file`) && is.null(`file`)) {
        stop("Invalid value for `file` when calling OrsonApi$SummarizeTopics, `file` is not nullable")
      }

      if (!missing(`url`) && is.null(`url`)) {
        stop("Invalid value for `url` when calling OrsonApi$SummarizeTopics, `url` is not nullable")
      }

      if (!missing(`limit`) && is.null(`limit`)) {
        stop("Invalid value for `limit` when calling OrsonApi$SummarizeTopics, `limit` is not nullable")
      }

      if (!missing(`offset`) && is.null(`offset`)) {
        stop("Invalid value for `offset` when calling OrsonApi$SummarizeTopics, `offset` is not nullable")
      }

      if (!missing(`callback`) && is.null(`callback`)) {
        stop("Invalid value for `callback` when calling OrsonApi$SummarizeTopics, `callback` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["thirdPartyAccountId"]] <- `third_party_account_id`

      query_params[["doc"]] <- `doc`

      query_params[["file"]] <- `file`

      query_params[["url"]] <- `url`

      query_params[["limit"]] <- `limit`

      query_params[["offset"]] <- `offset`

      query_params[["callback"]] <- `callback`

      local_var_url_path <- "/api/{version}/orson/ai/topics"
      if (!missing(`version`)) {
        local_var_url_path <- gsub("\\{version\\}", URLencode(as.character(`version`), reserved = TRUE), local_var_url_path)
      }


      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "OrsonAiTopicsResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Detect Technical Issues
    #'
    #' @param version 
    #' @param account_id Sirqul Account Id
    #' @param num_faces_expected Number of expected faces
    #' @param third_party_account_id (optional) A third-party account id that is meaningful to your systems
    #' @param file (optional) An uploaded recording to analyze (Currently limited to 10MB)
    #' @param url (optional) A recording file to download and analyze (Size limit: 1GB)
    #' @param callback (optional) When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return OrsonAiTechTuneResponse
    TechTune = function(version, account_id, num_faces_expected, third_party_account_id = NULL, file = NULL, url = NULL, callback = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$TechTuneWithHttpInfo(version, account_id, num_faces_expected, third_party_account_id, file, url, callback, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Detect Technical Issues
    #'
    #' @param version 
    #' @param account_id Sirqul Account Id
    #' @param num_faces_expected Number of expected faces
    #' @param third_party_account_id (optional) A third-party account id that is meaningful to your systems
    #' @param file (optional) An uploaded recording to analyze (Currently limited to 10MB)
    #' @param url (optional) A recording file to download and analyze (Size limit: 1GB)
    #' @param callback (optional) When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (OrsonAiTechTuneResponse) with additional information such as HTTP status code, headers
    TechTuneWithHttpInfo = function(version, account_id, num_faces_expected, third_party_account_id = NULL, file = NULL, url = NULL, callback = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`version`)) {
        stop("Missing required parameter `version`.")
      }

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (missing(`num_faces_expected`)) {
        stop("Missing required parameter `num_faces_expected`.")
      }

      if (!missing(`version`) && is.null(`version`)) {
        stop("Invalid value for `version` when calling OrsonApi$TechTune, `version` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling OrsonApi$TechTune, `account_id` is not nullable")
      }

      if (!missing(`num_faces_expected`) && is.null(`num_faces_expected`)) {
        stop("Invalid value for `num_faces_expected` when calling OrsonApi$TechTune, `num_faces_expected` is not nullable")
      }

      if (!missing(`third_party_account_id`) && is.null(`third_party_account_id`)) {
        stop("Invalid value for `third_party_account_id` when calling OrsonApi$TechTune, `third_party_account_id` is not nullable")
      }

      if (!missing(`file`) && is.null(`file`)) {
        stop("Invalid value for `file` when calling OrsonApi$TechTune, `file` is not nullable")
      }

      if (!missing(`url`) && is.null(`url`)) {
        stop("Invalid value for `url` when calling OrsonApi$TechTune, `url` is not nullable")
      }

      if (!missing(`callback`) && is.null(`callback`)) {
        stop("Invalid value for `callback` when calling OrsonApi$TechTune, `callback` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["thirdPartyAccountId"]] <- `third_party_account_id`

      query_params[["numFacesExpected"]] <- `num_faces_expected`

      query_params[["file"]] <- `file`

      query_params[["url"]] <- `url`

      query_params[["callback"]] <- `callback`

      local_var_url_path <- "/api/{version}/orson/ai/techTune"
      if (!missing(`version`)) {
        local_var_url_path <- gsub("\\{version\\}", URLencode(as.character(`version`), reserved = TRUE), local_var_url_path)
      }


      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "OrsonAiTechTuneResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Text to Speach
    #'
    #' @param version 
    #' @param account_id Sirqul Account Id
    #' @param text Text
    #' @param third_party_account_id (optional) A third-party account id that is meaningful to your systems
    #' @param language (optional) The language to use for the speaker and incoming text
    #' @param voice (optional) A language-specific voice to use, or picks the language default if not provided
    #' @param callback (optional) When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return OrsonAiTTSResponse
    Tts = function(version, account_id, text, third_party_account_id = NULL, language = NULL, voice = NULL, callback = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$TtsWithHttpInfo(version, account_id, text, third_party_account_id, language, voice, callback, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Text to Speach
    #'
    #' @param version 
    #' @param account_id Sirqul Account Id
    #' @param text Text
    #' @param third_party_account_id (optional) A third-party account id that is meaningful to your systems
    #' @param language (optional) The language to use for the speaker and incoming text
    #' @param voice (optional) A language-specific voice to use, or picks the language default if not provided
    #' @param callback (optional) When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (OrsonAiTTSResponse) with additional information such as HTTP status code, headers
    TtsWithHttpInfo = function(version, account_id, text, third_party_account_id = NULL, language = NULL, voice = NULL, callback = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`version`)) {
        stop("Missing required parameter `version`.")
      }

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (missing(`text`)) {
        stop("Missing required parameter `text`.")
      }

      if (!missing(`version`) && is.null(`version`)) {
        stop("Invalid value for `version` when calling OrsonApi$Tts, `version` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling OrsonApi$Tts, `account_id` is not nullable")
      }

      if (!missing(`text`) && is.null(`text`)) {
        stop("Invalid value for `text` when calling OrsonApi$Tts, `text` is not nullable")
      }

      if (!missing(`third_party_account_id`) && is.null(`third_party_account_id`)) {
        stop("Invalid value for `third_party_account_id` when calling OrsonApi$Tts, `third_party_account_id` is not nullable")
      }

      if (!missing(`language`) && is.null(`language`)) {
        stop("Invalid value for `language` when calling OrsonApi$Tts, `language` is not nullable")
      }

      if (!missing(`voice`) && is.null(`voice`)) {
        stop("Invalid value for `voice` when calling OrsonApi$Tts, `voice` is not nullable")
      }

      if (!missing(`callback`) && is.null(`callback`)) {
        stop("Invalid value for `callback` when calling OrsonApi$Tts, `callback` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["thirdPartyAccountId"]] <- `third_party_account_id`

      query_params[["text"]] <- `text`

      query_params[["language"]] <- `language`

      query_params[["voice"]] <- `voice`

      query_params[["callback"]] <- `callback`

      local_var_url_path <- "/api/{version}/orson/ai/tts"
      if (!missing(`version`)) {
        local_var_url_path <- gsub("\\{version\\}", URLencode(as.character(`version`), reserved = TRUE), local_var_url_path)
      }


      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "OrsonAiTTSResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    }
  )
)
