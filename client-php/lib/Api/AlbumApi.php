<?php
/**
 * AlbumApi
 * PHP version 8.1
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Sirqul IoT Platform
 *
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.20.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\FormDataProcessor;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * AlbumApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class AlbumApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'addAlbumCollection' => [
            'application/json',
        ],
        'addAlbumUsers' => [
            'application/json',
        ],
        'approveAlbum' => [
            'application/json',
        ],
        'getAlbumCollection' => [
            'application/json',
        ],
        'leaveAlbum' => [
            'application/json',
        ],
        'removeAlbum' => [
            'application/json',
        ],
        'removeAlbumUsers' => [
            'application/json',
        ],
        'searchAlbums' => [
            'application/json',
        ],
        'updateAlbumCollection' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation addAlbumCollection
     *
     * Create Album
     *
     * @param  string $title the title of the album (required)
     * @param  bool $cover_asset_nullable determines whether the cover image of the album can be empty, else will use the user&#39;s profile picture as the cover image (required)
     * @param  bool $include_cover_in_asset_list determines whether the cover image should be added to the album asset list (required)
     * @param  bool $public_read determines whether the album&#39;s participants has read permissions (required)
     * @param  bool $public_write determines whether the album&#39;s participants has write permissions (required)
     * @param  bool $public_delete determines whether the album&#39;s participants has delete permissions (required)
     * @param  bool $public_add determines whether the album&#39;s participants has add permissions (required)
     * @param  bool $anonymous determines whether the album is posted anonymously (required)
     * @param  string|null $device_id a unique ID given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account ID of the user (deviceId or accountId required) (optional)
     * @param  string|null $assets_to_add Comma separated list of asset IDs to add to the album&#39;s asset list (use \&quot;assetId\&quot; for setting the cover of the album) (optional)
     * @param  \SplFileObject|null $media a MultipartFile containing the cover image of the album (this will only be used if \&quot;assetId\&quot; is empty) (optional)
     * @param  string|null $media_url this can be used if the \&quot;media\&quot; is a link (this will only be used if \&quot;assetId\&quot; and media are empty) (optional)
     * @param  int|null $asset_id The asset ID to set the album cover image (optional)
     * @param  \SplFileObject|null $attached_media a MultipartFile containing an asset that the \&quot;media\&quot; file references. Example to upload a video: the \&quot;media\&quot; file should contain a screen capture of the video, and the \&quot;attachedMedia\&quot; should be the actual video. (optional)
     * @param  string|null $attached_media_url this can be used if the \&quot;attachedMedia\&quot; is a link (i.e. a Youtube video, etc) (optional)
     * @param  int|null $start_date the start date (optional)
     * @param  int|null $end_date the end date (optional)
     * @param  string|null $tags the tags (optional)
     * @param  string|null $description the description of the album (optional)
     * @param  string|null $album_type a custom field used for aggregation and searching (optional)
     * @param  int|null $album_type_id a custom indexed number used for aggregation and searching (optional)
     * @param  string|null $sub_type a custom string field used for aggregation and searching (optional)
     * @param  float|null $latitude latitude used to update the album&#39;s location (optional)
     * @param  float|null $longitude longitude used to update the album&#39;s location (optional)
     * @param  string|null $location_description the location description (optional)
     * @param  string|null $visibility the determines the album&#39;s participants (PUBLIC - includes everyone in the system as a potential participant, PRIVATE - only considers people who have been invited as participants) (optional)
     * @param  string|null $game_type @deprecated, use the appKey (optional)
     * @param  string|null $app_key the application key (optional)
     * @param  string|null $cell_phone the cell phone number (optional)
     * @param  string|null $street_address The street address of the location (optional)
     * @param  string|null $street_address2 Additional address information (such as a suite number, floor number, building name, or PO Box) (optional)
     * @param  string|null $city The city of the location (optional)
     * @param  string|null $state The state of of the location (optional)
     * @param  string|null $postal_code The postal code of the location (optional)
     * @param  string|null $full_address The full address of the location which should include the street address, city, state, and postal code (optional)
     * @param  string|null $meta_data External custom client defined data (optional)
     * @param  string|null $category_ids comma separated category ids string associated with the Album (optional)
     * @param  string|null $category_filter_ids comma separated filter ids string associated with the Album (optional)
     * @param  string|null $audience_ids comma separated audience ids string associated with the album (optional)
     * @param  bool|null $include_all_app_users_as_members determines whether to include all app users as members (only admins of the app can do this) (optional)
     * @param  bool|null $include_audiences_as_members determines whether to include all users of the audiences as members (only admins of the app can do this) (optional)
     * @param  string|null $audience_operator determines whether to use ands or ors when using the audience list to add users (optional)
     * @param  string|null $approval_status The approval status to set {PENDING, REJECTED, APPROVED, FEATURED} (optional)
     * @param  string|null $linked_object_type sets a linked object so that it can be returned as part of the album response (optional)
     * @param  int|null $linked_object_id sets a linked object id so that it can be returned as part of the album response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addAlbumCollection'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SearchResponse
     */
    public function addAlbumCollection($title, $cover_asset_nullable, $include_cover_in_asset_list, $public_read, $public_write, $public_delete, $public_add, $anonymous, $device_id = null, $account_id = null, $assets_to_add = null, $media = null, $media_url = null, $asset_id = null, $attached_media = null, $attached_media_url = null, $start_date = null, $end_date = null, $tags = null, $description = null, $album_type = null, $album_type_id = null, $sub_type = null, $latitude = null, $longitude = null, $location_description = null, $visibility = null, $game_type = null, $app_key = null, $cell_phone = null, $street_address = null, $street_address2 = null, $city = null, $state = null, $postal_code = null, $full_address = null, $meta_data = null, $category_ids = null, $category_filter_ids = null, $audience_ids = null, $include_all_app_users_as_members = null, $include_audiences_as_members = null, $audience_operator = null, $approval_status = null, $linked_object_type = null, $linked_object_id = null, string $contentType = self::contentTypes['addAlbumCollection'][0])
    {
        list($response) = $this->addAlbumCollectionWithHttpInfo($title, $cover_asset_nullable, $include_cover_in_asset_list, $public_read, $public_write, $public_delete, $public_add, $anonymous, $device_id, $account_id, $assets_to_add, $media, $media_url, $asset_id, $attached_media, $attached_media_url, $start_date, $end_date, $tags, $description, $album_type, $album_type_id, $sub_type, $latitude, $longitude, $location_description, $visibility, $game_type, $app_key, $cell_phone, $street_address, $street_address2, $city, $state, $postal_code, $full_address, $meta_data, $category_ids, $category_filter_ids, $audience_ids, $include_all_app_users_as_members, $include_audiences_as_members, $audience_operator, $approval_status, $linked_object_type, $linked_object_id, $contentType);
        return $response;
    }

    /**
     * Operation addAlbumCollectionWithHttpInfo
     *
     * Create Album
     *
     * @param  string $title the title of the album (required)
     * @param  bool $cover_asset_nullable determines whether the cover image of the album can be empty, else will use the user&#39;s profile picture as the cover image (required)
     * @param  bool $include_cover_in_asset_list determines whether the cover image should be added to the album asset list (required)
     * @param  bool $public_read determines whether the album&#39;s participants has read permissions (required)
     * @param  bool $public_write determines whether the album&#39;s participants has write permissions (required)
     * @param  bool $public_delete determines whether the album&#39;s participants has delete permissions (required)
     * @param  bool $public_add determines whether the album&#39;s participants has add permissions (required)
     * @param  bool $anonymous determines whether the album is posted anonymously (required)
     * @param  string|null $device_id a unique ID given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account ID of the user (deviceId or accountId required) (optional)
     * @param  string|null $assets_to_add Comma separated list of asset IDs to add to the album&#39;s asset list (use \&quot;assetId\&quot; for setting the cover of the album) (optional)
     * @param  \SplFileObject|null $media a MultipartFile containing the cover image of the album (this will only be used if \&quot;assetId\&quot; is empty) (optional)
     * @param  string|null $media_url this can be used if the \&quot;media\&quot; is a link (this will only be used if \&quot;assetId\&quot; and media are empty) (optional)
     * @param  int|null $asset_id The asset ID to set the album cover image (optional)
     * @param  \SplFileObject|null $attached_media a MultipartFile containing an asset that the \&quot;media\&quot; file references. Example to upload a video: the \&quot;media\&quot; file should contain a screen capture of the video, and the \&quot;attachedMedia\&quot; should be the actual video. (optional)
     * @param  string|null $attached_media_url this can be used if the \&quot;attachedMedia\&quot; is a link (i.e. a Youtube video, etc) (optional)
     * @param  int|null $start_date the start date (optional)
     * @param  int|null $end_date the end date (optional)
     * @param  string|null $tags the tags (optional)
     * @param  string|null $description the description of the album (optional)
     * @param  string|null $album_type a custom field used for aggregation and searching (optional)
     * @param  int|null $album_type_id a custom indexed number used for aggregation and searching (optional)
     * @param  string|null $sub_type a custom string field used for aggregation and searching (optional)
     * @param  float|null $latitude latitude used to update the album&#39;s location (optional)
     * @param  float|null $longitude longitude used to update the album&#39;s location (optional)
     * @param  string|null $location_description the location description (optional)
     * @param  string|null $visibility the determines the album&#39;s participants (PUBLIC - includes everyone in the system as a potential participant, PRIVATE - only considers people who have been invited as participants) (optional)
     * @param  string|null $game_type @deprecated, use the appKey (optional)
     * @param  string|null $app_key the application key (optional)
     * @param  string|null $cell_phone the cell phone number (optional)
     * @param  string|null $street_address The street address of the location (optional)
     * @param  string|null $street_address2 Additional address information (such as a suite number, floor number, building name, or PO Box) (optional)
     * @param  string|null $city The city of the location (optional)
     * @param  string|null $state The state of of the location (optional)
     * @param  string|null $postal_code The postal code of the location (optional)
     * @param  string|null $full_address The full address of the location which should include the street address, city, state, and postal code (optional)
     * @param  string|null $meta_data External custom client defined data (optional)
     * @param  string|null $category_ids comma separated category ids string associated with the Album (optional)
     * @param  string|null $category_filter_ids comma separated filter ids string associated with the Album (optional)
     * @param  string|null $audience_ids comma separated audience ids string associated with the album (optional)
     * @param  bool|null $include_all_app_users_as_members determines whether to include all app users as members (only admins of the app can do this) (optional)
     * @param  bool|null $include_audiences_as_members determines whether to include all users of the audiences as members (only admins of the app can do this) (optional)
     * @param  string|null $audience_operator determines whether to use ands or ors when using the audience list to add users (optional)
     * @param  string|null $approval_status The approval status to set {PENDING, REJECTED, APPROVED, FEATURED} (optional)
     * @param  string|null $linked_object_type sets a linked object so that it can be returned as part of the album response (optional)
     * @param  int|null $linked_object_id sets a linked object id so that it can be returned as part of the album response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addAlbumCollection'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SearchResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function addAlbumCollectionWithHttpInfo($title, $cover_asset_nullable, $include_cover_in_asset_list, $public_read, $public_write, $public_delete, $public_add, $anonymous, $device_id = null, $account_id = null, $assets_to_add = null, $media = null, $media_url = null, $asset_id = null, $attached_media = null, $attached_media_url = null, $start_date = null, $end_date = null, $tags = null, $description = null, $album_type = null, $album_type_id = null, $sub_type = null, $latitude = null, $longitude = null, $location_description = null, $visibility = null, $game_type = null, $app_key = null, $cell_phone = null, $street_address = null, $street_address2 = null, $city = null, $state = null, $postal_code = null, $full_address = null, $meta_data = null, $category_ids = null, $category_filter_ids = null, $audience_ids = null, $include_all_app_users_as_members = null, $include_audiences_as_members = null, $audience_operator = null, $approval_status = null, $linked_object_type = null, $linked_object_id = null, string $contentType = self::contentTypes['addAlbumCollection'][0])
    {
        $request = $this->addAlbumCollectionRequest($title, $cover_asset_nullable, $include_cover_in_asset_list, $public_read, $public_write, $public_delete, $public_add, $anonymous, $device_id, $account_id, $assets_to_add, $media, $media_url, $asset_id, $attached_media, $attached_media_url, $start_date, $end_date, $tags, $description, $album_type, $album_type_id, $sub_type, $latitude, $longitude, $location_description, $visibility, $game_type, $app_key, $cell_phone, $street_address, $street_address2, $city, $state, $postal_code, $full_address, $meta_data, $category_ids, $category_filter_ids, $audience_ids, $include_all_app_users_as_members, $include_audiences_as_members, $audience_operator, $approval_status, $linked_object_type, $linked_object_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\SearchResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\SearchResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SearchResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation addAlbumCollectionAsync
     *
     * Create Album
     *
     * @param  string $title the title of the album (required)
     * @param  bool $cover_asset_nullable determines whether the cover image of the album can be empty, else will use the user&#39;s profile picture as the cover image (required)
     * @param  bool $include_cover_in_asset_list determines whether the cover image should be added to the album asset list (required)
     * @param  bool $public_read determines whether the album&#39;s participants has read permissions (required)
     * @param  bool $public_write determines whether the album&#39;s participants has write permissions (required)
     * @param  bool $public_delete determines whether the album&#39;s participants has delete permissions (required)
     * @param  bool $public_add determines whether the album&#39;s participants has add permissions (required)
     * @param  bool $anonymous determines whether the album is posted anonymously (required)
     * @param  string|null $device_id a unique ID given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account ID of the user (deviceId or accountId required) (optional)
     * @param  string|null $assets_to_add Comma separated list of asset IDs to add to the album&#39;s asset list (use \&quot;assetId\&quot; for setting the cover of the album) (optional)
     * @param  \SplFileObject|null $media a MultipartFile containing the cover image of the album (this will only be used if \&quot;assetId\&quot; is empty) (optional)
     * @param  string|null $media_url this can be used if the \&quot;media\&quot; is a link (this will only be used if \&quot;assetId\&quot; and media are empty) (optional)
     * @param  int|null $asset_id The asset ID to set the album cover image (optional)
     * @param  \SplFileObject|null $attached_media a MultipartFile containing an asset that the \&quot;media\&quot; file references. Example to upload a video: the \&quot;media\&quot; file should contain a screen capture of the video, and the \&quot;attachedMedia\&quot; should be the actual video. (optional)
     * @param  string|null $attached_media_url this can be used if the \&quot;attachedMedia\&quot; is a link (i.e. a Youtube video, etc) (optional)
     * @param  int|null $start_date the start date (optional)
     * @param  int|null $end_date the end date (optional)
     * @param  string|null $tags the tags (optional)
     * @param  string|null $description the description of the album (optional)
     * @param  string|null $album_type a custom field used for aggregation and searching (optional)
     * @param  int|null $album_type_id a custom indexed number used for aggregation and searching (optional)
     * @param  string|null $sub_type a custom string field used for aggregation and searching (optional)
     * @param  float|null $latitude latitude used to update the album&#39;s location (optional)
     * @param  float|null $longitude longitude used to update the album&#39;s location (optional)
     * @param  string|null $location_description the location description (optional)
     * @param  string|null $visibility the determines the album&#39;s participants (PUBLIC - includes everyone in the system as a potential participant, PRIVATE - only considers people who have been invited as participants) (optional)
     * @param  string|null $game_type @deprecated, use the appKey (optional)
     * @param  string|null $app_key the application key (optional)
     * @param  string|null $cell_phone the cell phone number (optional)
     * @param  string|null $street_address The street address of the location (optional)
     * @param  string|null $street_address2 Additional address information (such as a suite number, floor number, building name, or PO Box) (optional)
     * @param  string|null $city The city of the location (optional)
     * @param  string|null $state The state of of the location (optional)
     * @param  string|null $postal_code The postal code of the location (optional)
     * @param  string|null $full_address The full address of the location which should include the street address, city, state, and postal code (optional)
     * @param  string|null $meta_data External custom client defined data (optional)
     * @param  string|null $category_ids comma separated category ids string associated with the Album (optional)
     * @param  string|null $category_filter_ids comma separated filter ids string associated with the Album (optional)
     * @param  string|null $audience_ids comma separated audience ids string associated with the album (optional)
     * @param  bool|null $include_all_app_users_as_members determines whether to include all app users as members (only admins of the app can do this) (optional)
     * @param  bool|null $include_audiences_as_members determines whether to include all users of the audiences as members (only admins of the app can do this) (optional)
     * @param  string|null $audience_operator determines whether to use ands or ors when using the audience list to add users (optional)
     * @param  string|null $approval_status The approval status to set {PENDING, REJECTED, APPROVED, FEATURED} (optional)
     * @param  string|null $linked_object_type sets a linked object so that it can be returned as part of the album response (optional)
     * @param  int|null $linked_object_id sets a linked object id so that it can be returned as part of the album response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addAlbumCollection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addAlbumCollectionAsync($title, $cover_asset_nullable, $include_cover_in_asset_list, $public_read, $public_write, $public_delete, $public_add, $anonymous, $device_id = null, $account_id = null, $assets_to_add = null, $media = null, $media_url = null, $asset_id = null, $attached_media = null, $attached_media_url = null, $start_date = null, $end_date = null, $tags = null, $description = null, $album_type = null, $album_type_id = null, $sub_type = null, $latitude = null, $longitude = null, $location_description = null, $visibility = null, $game_type = null, $app_key = null, $cell_phone = null, $street_address = null, $street_address2 = null, $city = null, $state = null, $postal_code = null, $full_address = null, $meta_data = null, $category_ids = null, $category_filter_ids = null, $audience_ids = null, $include_all_app_users_as_members = null, $include_audiences_as_members = null, $audience_operator = null, $approval_status = null, $linked_object_type = null, $linked_object_id = null, string $contentType = self::contentTypes['addAlbumCollection'][0])
    {
        return $this->addAlbumCollectionAsyncWithHttpInfo($title, $cover_asset_nullable, $include_cover_in_asset_list, $public_read, $public_write, $public_delete, $public_add, $anonymous, $device_id, $account_id, $assets_to_add, $media, $media_url, $asset_id, $attached_media, $attached_media_url, $start_date, $end_date, $tags, $description, $album_type, $album_type_id, $sub_type, $latitude, $longitude, $location_description, $visibility, $game_type, $app_key, $cell_phone, $street_address, $street_address2, $city, $state, $postal_code, $full_address, $meta_data, $category_ids, $category_filter_ids, $audience_ids, $include_all_app_users_as_members, $include_audiences_as_members, $audience_operator, $approval_status, $linked_object_type, $linked_object_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addAlbumCollectionAsyncWithHttpInfo
     *
     * Create Album
     *
     * @param  string $title the title of the album (required)
     * @param  bool $cover_asset_nullable determines whether the cover image of the album can be empty, else will use the user&#39;s profile picture as the cover image (required)
     * @param  bool $include_cover_in_asset_list determines whether the cover image should be added to the album asset list (required)
     * @param  bool $public_read determines whether the album&#39;s participants has read permissions (required)
     * @param  bool $public_write determines whether the album&#39;s participants has write permissions (required)
     * @param  bool $public_delete determines whether the album&#39;s participants has delete permissions (required)
     * @param  bool $public_add determines whether the album&#39;s participants has add permissions (required)
     * @param  bool $anonymous determines whether the album is posted anonymously (required)
     * @param  string|null $device_id a unique ID given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account ID of the user (deviceId or accountId required) (optional)
     * @param  string|null $assets_to_add Comma separated list of asset IDs to add to the album&#39;s asset list (use \&quot;assetId\&quot; for setting the cover of the album) (optional)
     * @param  \SplFileObject|null $media a MultipartFile containing the cover image of the album (this will only be used if \&quot;assetId\&quot; is empty) (optional)
     * @param  string|null $media_url this can be used if the \&quot;media\&quot; is a link (this will only be used if \&quot;assetId\&quot; and media are empty) (optional)
     * @param  int|null $asset_id The asset ID to set the album cover image (optional)
     * @param  \SplFileObject|null $attached_media a MultipartFile containing an asset that the \&quot;media\&quot; file references. Example to upload a video: the \&quot;media\&quot; file should contain a screen capture of the video, and the \&quot;attachedMedia\&quot; should be the actual video. (optional)
     * @param  string|null $attached_media_url this can be used if the \&quot;attachedMedia\&quot; is a link (i.e. a Youtube video, etc) (optional)
     * @param  int|null $start_date the start date (optional)
     * @param  int|null $end_date the end date (optional)
     * @param  string|null $tags the tags (optional)
     * @param  string|null $description the description of the album (optional)
     * @param  string|null $album_type a custom field used for aggregation and searching (optional)
     * @param  int|null $album_type_id a custom indexed number used for aggregation and searching (optional)
     * @param  string|null $sub_type a custom string field used for aggregation and searching (optional)
     * @param  float|null $latitude latitude used to update the album&#39;s location (optional)
     * @param  float|null $longitude longitude used to update the album&#39;s location (optional)
     * @param  string|null $location_description the location description (optional)
     * @param  string|null $visibility the determines the album&#39;s participants (PUBLIC - includes everyone in the system as a potential participant, PRIVATE - only considers people who have been invited as participants) (optional)
     * @param  string|null $game_type @deprecated, use the appKey (optional)
     * @param  string|null $app_key the application key (optional)
     * @param  string|null $cell_phone the cell phone number (optional)
     * @param  string|null $street_address The street address of the location (optional)
     * @param  string|null $street_address2 Additional address information (such as a suite number, floor number, building name, or PO Box) (optional)
     * @param  string|null $city The city of the location (optional)
     * @param  string|null $state The state of of the location (optional)
     * @param  string|null $postal_code The postal code of the location (optional)
     * @param  string|null $full_address The full address of the location which should include the street address, city, state, and postal code (optional)
     * @param  string|null $meta_data External custom client defined data (optional)
     * @param  string|null $category_ids comma separated category ids string associated with the Album (optional)
     * @param  string|null $category_filter_ids comma separated filter ids string associated with the Album (optional)
     * @param  string|null $audience_ids comma separated audience ids string associated with the album (optional)
     * @param  bool|null $include_all_app_users_as_members determines whether to include all app users as members (only admins of the app can do this) (optional)
     * @param  bool|null $include_audiences_as_members determines whether to include all users of the audiences as members (only admins of the app can do this) (optional)
     * @param  string|null $audience_operator determines whether to use ands or ors when using the audience list to add users (optional)
     * @param  string|null $approval_status The approval status to set {PENDING, REJECTED, APPROVED, FEATURED} (optional)
     * @param  string|null $linked_object_type sets a linked object so that it can be returned as part of the album response (optional)
     * @param  int|null $linked_object_id sets a linked object id so that it can be returned as part of the album response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addAlbumCollection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addAlbumCollectionAsyncWithHttpInfo($title, $cover_asset_nullable, $include_cover_in_asset_list, $public_read, $public_write, $public_delete, $public_add, $anonymous, $device_id = null, $account_id = null, $assets_to_add = null, $media = null, $media_url = null, $asset_id = null, $attached_media = null, $attached_media_url = null, $start_date = null, $end_date = null, $tags = null, $description = null, $album_type = null, $album_type_id = null, $sub_type = null, $latitude = null, $longitude = null, $location_description = null, $visibility = null, $game_type = null, $app_key = null, $cell_phone = null, $street_address = null, $street_address2 = null, $city = null, $state = null, $postal_code = null, $full_address = null, $meta_data = null, $category_ids = null, $category_filter_ids = null, $audience_ids = null, $include_all_app_users_as_members = null, $include_audiences_as_members = null, $audience_operator = null, $approval_status = null, $linked_object_type = null, $linked_object_id = null, string $contentType = self::contentTypes['addAlbumCollection'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SearchResponse';
        $request = $this->addAlbumCollectionRequest($title, $cover_asset_nullable, $include_cover_in_asset_list, $public_read, $public_write, $public_delete, $public_add, $anonymous, $device_id, $account_id, $assets_to_add, $media, $media_url, $asset_id, $attached_media, $attached_media_url, $start_date, $end_date, $tags, $description, $album_type, $album_type_id, $sub_type, $latitude, $longitude, $location_description, $visibility, $game_type, $app_key, $cell_phone, $street_address, $street_address2, $city, $state, $postal_code, $full_address, $meta_data, $category_ids, $category_filter_ids, $audience_ids, $include_all_app_users_as_members, $include_audiences_as_members, $audience_operator, $approval_status, $linked_object_type, $linked_object_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addAlbumCollection'
     *
     * @param  string $title the title of the album (required)
     * @param  bool $cover_asset_nullable determines whether the cover image of the album can be empty, else will use the user&#39;s profile picture as the cover image (required)
     * @param  bool $include_cover_in_asset_list determines whether the cover image should be added to the album asset list (required)
     * @param  bool $public_read determines whether the album&#39;s participants has read permissions (required)
     * @param  bool $public_write determines whether the album&#39;s participants has write permissions (required)
     * @param  bool $public_delete determines whether the album&#39;s participants has delete permissions (required)
     * @param  bool $public_add determines whether the album&#39;s participants has add permissions (required)
     * @param  bool $anonymous determines whether the album is posted anonymously (required)
     * @param  string|null $device_id a unique ID given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account ID of the user (deviceId or accountId required) (optional)
     * @param  string|null $assets_to_add Comma separated list of asset IDs to add to the album&#39;s asset list (use \&quot;assetId\&quot; for setting the cover of the album) (optional)
     * @param  \SplFileObject|null $media a MultipartFile containing the cover image of the album (this will only be used if \&quot;assetId\&quot; is empty) (optional)
     * @param  string|null $media_url this can be used if the \&quot;media\&quot; is a link (this will only be used if \&quot;assetId\&quot; and media are empty) (optional)
     * @param  int|null $asset_id The asset ID to set the album cover image (optional)
     * @param  \SplFileObject|null $attached_media a MultipartFile containing an asset that the \&quot;media\&quot; file references. Example to upload a video: the \&quot;media\&quot; file should contain a screen capture of the video, and the \&quot;attachedMedia\&quot; should be the actual video. (optional)
     * @param  string|null $attached_media_url this can be used if the \&quot;attachedMedia\&quot; is a link (i.e. a Youtube video, etc) (optional)
     * @param  int|null $start_date the start date (optional)
     * @param  int|null $end_date the end date (optional)
     * @param  string|null $tags the tags (optional)
     * @param  string|null $description the description of the album (optional)
     * @param  string|null $album_type a custom field used for aggregation and searching (optional)
     * @param  int|null $album_type_id a custom indexed number used for aggregation and searching (optional)
     * @param  string|null $sub_type a custom string field used for aggregation and searching (optional)
     * @param  float|null $latitude latitude used to update the album&#39;s location (optional)
     * @param  float|null $longitude longitude used to update the album&#39;s location (optional)
     * @param  string|null $location_description the location description (optional)
     * @param  string|null $visibility the determines the album&#39;s participants (PUBLIC - includes everyone in the system as a potential participant, PRIVATE - only considers people who have been invited as participants) (optional)
     * @param  string|null $game_type @deprecated, use the appKey (optional)
     * @param  string|null $app_key the application key (optional)
     * @param  string|null $cell_phone the cell phone number (optional)
     * @param  string|null $street_address The street address of the location (optional)
     * @param  string|null $street_address2 Additional address information (such as a suite number, floor number, building name, or PO Box) (optional)
     * @param  string|null $city The city of the location (optional)
     * @param  string|null $state The state of of the location (optional)
     * @param  string|null $postal_code The postal code of the location (optional)
     * @param  string|null $full_address The full address of the location which should include the street address, city, state, and postal code (optional)
     * @param  string|null $meta_data External custom client defined data (optional)
     * @param  string|null $category_ids comma separated category ids string associated with the Album (optional)
     * @param  string|null $category_filter_ids comma separated filter ids string associated with the Album (optional)
     * @param  string|null $audience_ids comma separated audience ids string associated with the album (optional)
     * @param  bool|null $include_all_app_users_as_members determines whether to include all app users as members (only admins of the app can do this) (optional)
     * @param  bool|null $include_audiences_as_members determines whether to include all users of the audiences as members (only admins of the app can do this) (optional)
     * @param  string|null $audience_operator determines whether to use ands or ors when using the audience list to add users (optional)
     * @param  string|null $approval_status The approval status to set {PENDING, REJECTED, APPROVED, FEATURED} (optional)
     * @param  string|null $linked_object_type sets a linked object so that it can be returned as part of the album response (optional)
     * @param  int|null $linked_object_id sets a linked object id so that it can be returned as part of the album response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addAlbumCollection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function addAlbumCollectionRequest($title, $cover_asset_nullable, $include_cover_in_asset_list, $public_read, $public_write, $public_delete, $public_add, $anonymous, $device_id = null, $account_id = null, $assets_to_add = null, $media = null, $media_url = null, $asset_id = null, $attached_media = null, $attached_media_url = null, $start_date = null, $end_date = null, $tags = null, $description = null, $album_type = null, $album_type_id = null, $sub_type = null, $latitude = null, $longitude = null, $location_description = null, $visibility = null, $game_type = null, $app_key = null, $cell_phone = null, $street_address = null, $street_address2 = null, $city = null, $state = null, $postal_code = null, $full_address = null, $meta_data = null, $category_ids = null, $category_filter_ids = null, $audience_ids = null, $include_all_app_users_as_members = null, $include_audiences_as_members = null, $audience_operator = null, $approval_status = null, $linked_object_type = null, $linked_object_id = null, string $contentType = self::contentTypes['addAlbumCollection'][0])
    {

        // verify the required parameter 'title' is set
        if ($title === null || (is_array($title) && count($title) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $title when calling addAlbumCollection'
            );
        }

        // verify the required parameter 'cover_asset_nullable' is set
        if ($cover_asset_nullable === null || (is_array($cover_asset_nullable) && count($cover_asset_nullable) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cover_asset_nullable when calling addAlbumCollection'
            );
        }

        // verify the required parameter 'include_cover_in_asset_list' is set
        if ($include_cover_in_asset_list === null || (is_array($include_cover_in_asset_list) && count($include_cover_in_asset_list) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $include_cover_in_asset_list when calling addAlbumCollection'
            );
        }

        // verify the required parameter 'public_read' is set
        if ($public_read === null || (is_array($public_read) && count($public_read) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $public_read when calling addAlbumCollection'
            );
        }

        // verify the required parameter 'public_write' is set
        if ($public_write === null || (is_array($public_write) && count($public_write) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $public_write when calling addAlbumCollection'
            );
        }

        // verify the required parameter 'public_delete' is set
        if ($public_delete === null || (is_array($public_delete) && count($public_delete) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $public_delete when calling addAlbumCollection'
            );
        }

        // verify the required parameter 'public_add' is set
        if ($public_add === null || (is_array($public_add) && count($public_add) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $public_add when calling addAlbumCollection'
            );
        }

        // verify the required parameter 'anonymous' is set
        if ($anonymous === null || (is_array($anonymous) && count($anonymous) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $anonymous when calling addAlbumCollection'
            );
        }








































        $resourcePath = '/album/create';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_id,
            'deviceId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $title,
            'title', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $assets_to_add,
            'assetsToAdd', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $media,
            'media', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $media_url,
            'mediaURL', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $asset_id,
            'assetId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $attached_media,
            'attachedMedia', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $attached_media_url,
            'attachedMediaURL', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cover_asset_nullable,
            'coverAssetNullable', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_cover_in_asset_list,
            'includeCoverInAssetList', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'startDate', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'endDate', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tags,
            'tags', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description,
            'description', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $album_type,
            'albumType', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $album_type_id,
            'albumTypeId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sub_type,
            'subType', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $public_read,
            'publicRead', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $public_write,
            'publicWrite', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $public_delete,
            'publicDelete', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $public_add,
            'publicAdd', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $latitude,
            'latitude', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $longitude,
            'longitude', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $location_description,
            'locationDescription', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $visibility,
            'visibility', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $game_type,
            'gameType', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $app_key,
            'appKey', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cell_phone,
            'cellPhone', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $street_address,
            'streetAddress', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $street_address2,
            'streetAddress2', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $city,
            'city', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $state,
            'state', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $postal_code,
            'postalCode', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $full_address,
            'fullAddress', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $anonymous,
            'anonymous', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $meta_data,
            'metaData', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $category_ids,
            'categoryIds', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $category_filter_ids,
            'categoryFilterIds', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audience_ids,
            'audienceIds', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_all_app_users_as_members,
            'includeAllAppUsersAsMembers', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_audiences_as_members,
            'includeAudiencesAsMembers', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audience_operator,
            'audienceOperator', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $approval_status,
            'approvalStatus', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $linked_object_type,
            'linkedObjectType', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $linked_object_id,
            'linkedObjectId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation addAlbumUsers
     *
     * Add Album Users
     *
     * @param  int $album_id the album ID (required)
     * @param  bool $include_friend_group determines whether to include all friends as participants (required)
     * @param  string|null $device_id a unique ID given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account ID of the user (deviceId or accountId required) (optional)
     * @param  bool|null $read determines whether the users being added have read permissions (optional)
     * @param  bool|null $write determines whether the users being added have write permissions (optional)
     * @param  bool|null $delete determines whether the users being added have delete permissions (optional)
     * @param  bool|null $add determines whether the users being added have add permissions (optional)
     * @param  string|null $connections comma separated list of connection IDs (optional)
     * @param  string|null $connection_groups comma separated list of connection group IDs (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addAlbumUsers'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SirqulResponse
     */
    public function addAlbumUsers($album_id, $include_friend_group, $device_id = null, $account_id = null, $read = null, $write = null, $delete = null, $add = null, $connections = null, $connection_groups = null, string $contentType = self::contentTypes['addAlbumUsers'][0])
    {
        list($response) = $this->addAlbumUsersWithHttpInfo($album_id, $include_friend_group, $device_id, $account_id, $read, $write, $delete, $add, $connections, $connection_groups, $contentType);
        return $response;
    }

    /**
     * Operation addAlbumUsersWithHttpInfo
     *
     * Add Album Users
     *
     * @param  int $album_id the album ID (required)
     * @param  bool $include_friend_group determines whether to include all friends as participants (required)
     * @param  string|null $device_id a unique ID given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account ID of the user (deviceId or accountId required) (optional)
     * @param  bool|null $read determines whether the users being added have read permissions (optional)
     * @param  bool|null $write determines whether the users being added have write permissions (optional)
     * @param  bool|null $delete determines whether the users being added have delete permissions (optional)
     * @param  bool|null $add determines whether the users being added have add permissions (optional)
     * @param  string|null $connections comma separated list of connection IDs (optional)
     * @param  string|null $connection_groups comma separated list of connection group IDs (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addAlbumUsers'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SirqulResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function addAlbumUsersWithHttpInfo($album_id, $include_friend_group, $device_id = null, $account_id = null, $read = null, $write = null, $delete = null, $add = null, $connections = null, $connection_groups = null, string $contentType = self::contentTypes['addAlbumUsers'][0])
    {
        $request = $this->addAlbumUsersRequest($album_id, $include_friend_group, $device_id, $account_id, $read, $write, $delete, $add, $connections, $connection_groups, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\SirqulResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\SirqulResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SirqulResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation addAlbumUsersAsync
     *
     * Add Album Users
     *
     * @param  int $album_id the album ID (required)
     * @param  bool $include_friend_group determines whether to include all friends as participants (required)
     * @param  string|null $device_id a unique ID given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account ID of the user (deviceId or accountId required) (optional)
     * @param  bool|null $read determines whether the users being added have read permissions (optional)
     * @param  bool|null $write determines whether the users being added have write permissions (optional)
     * @param  bool|null $delete determines whether the users being added have delete permissions (optional)
     * @param  bool|null $add determines whether the users being added have add permissions (optional)
     * @param  string|null $connections comma separated list of connection IDs (optional)
     * @param  string|null $connection_groups comma separated list of connection group IDs (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addAlbumUsers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addAlbumUsersAsync($album_id, $include_friend_group, $device_id = null, $account_id = null, $read = null, $write = null, $delete = null, $add = null, $connections = null, $connection_groups = null, string $contentType = self::contentTypes['addAlbumUsers'][0])
    {
        return $this->addAlbumUsersAsyncWithHttpInfo($album_id, $include_friend_group, $device_id, $account_id, $read, $write, $delete, $add, $connections, $connection_groups, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addAlbumUsersAsyncWithHttpInfo
     *
     * Add Album Users
     *
     * @param  int $album_id the album ID (required)
     * @param  bool $include_friend_group determines whether to include all friends as participants (required)
     * @param  string|null $device_id a unique ID given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account ID of the user (deviceId or accountId required) (optional)
     * @param  bool|null $read determines whether the users being added have read permissions (optional)
     * @param  bool|null $write determines whether the users being added have write permissions (optional)
     * @param  bool|null $delete determines whether the users being added have delete permissions (optional)
     * @param  bool|null $add determines whether the users being added have add permissions (optional)
     * @param  string|null $connections comma separated list of connection IDs (optional)
     * @param  string|null $connection_groups comma separated list of connection group IDs (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addAlbumUsers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addAlbumUsersAsyncWithHttpInfo($album_id, $include_friend_group, $device_id = null, $account_id = null, $read = null, $write = null, $delete = null, $add = null, $connections = null, $connection_groups = null, string $contentType = self::contentTypes['addAlbumUsers'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SirqulResponse';
        $request = $this->addAlbumUsersRequest($album_id, $include_friend_group, $device_id, $account_id, $read, $write, $delete, $add, $connections, $connection_groups, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addAlbumUsers'
     *
     * @param  int $album_id the album ID (required)
     * @param  bool $include_friend_group determines whether to include all friends as participants (required)
     * @param  string|null $device_id a unique ID given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account ID of the user (deviceId or accountId required) (optional)
     * @param  bool|null $read determines whether the users being added have read permissions (optional)
     * @param  bool|null $write determines whether the users being added have write permissions (optional)
     * @param  bool|null $delete determines whether the users being added have delete permissions (optional)
     * @param  bool|null $add determines whether the users being added have add permissions (optional)
     * @param  string|null $connections comma separated list of connection IDs (optional)
     * @param  string|null $connection_groups comma separated list of connection group IDs (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addAlbumUsers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function addAlbumUsersRequest($album_id, $include_friend_group, $device_id = null, $account_id = null, $read = null, $write = null, $delete = null, $add = null, $connections = null, $connection_groups = null, string $contentType = self::contentTypes['addAlbumUsers'][0])
    {

        // verify the required parameter 'album_id' is set
        if ($album_id === null || (is_array($album_id) && count($album_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $album_id when calling addAlbumUsers'
            );
        }

        // verify the required parameter 'include_friend_group' is set
        if ($include_friend_group === null || (is_array($include_friend_group) && count($include_friend_group) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $include_friend_group when calling addAlbumUsers'
            );
        }










        $resourcePath = '/album/user/add';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_id,
            'deviceId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $album_id,
            'albumId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $read,
            'read', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $write,
            'write', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $delete,
            'delete', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $add,
            'add', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $connections,
            'connections', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $connection_groups,
            'connectionGroups', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_friend_group,
            'includeFriendGroup', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation approveAlbum
     *
     * Approve Album
     *
     * @param  int $album_id The ID of the album (required)
     * @param  string|null $device_id A unique ID given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id The account ID of the user (deviceId or accountId required) (optional)
     * @param  string|null $approval_status The approval status to set {PENDING, REJECTED, APPROVED, FEATURED} (optional)
     * @param  bool|null $verified Sets whether the album should be marked as \&quot;verified\&quot; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['approveAlbum'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SirqulResponse
     */
    public function approveAlbum($album_id, $device_id = null, $account_id = null, $approval_status = null, $verified = null, string $contentType = self::contentTypes['approveAlbum'][0])
    {
        list($response) = $this->approveAlbumWithHttpInfo($album_id, $device_id, $account_id, $approval_status, $verified, $contentType);
        return $response;
    }

    /**
     * Operation approveAlbumWithHttpInfo
     *
     * Approve Album
     *
     * @param  int $album_id The ID of the album (required)
     * @param  string|null $device_id A unique ID given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id The account ID of the user (deviceId or accountId required) (optional)
     * @param  string|null $approval_status The approval status to set {PENDING, REJECTED, APPROVED, FEATURED} (optional)
     * @param  bool|null $verified Sets whether the album should be marked as \&quot;verified\&quot; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['approveAlbum'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SirqulResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function approveAlbumWithHttpInfo($album_id, $device_id = null, $account_id = null, $approval_status = null, $verified = null, string $contentType = self::contentTypes['approveAlbum'][0])
    {
        $request = $this->approveAlbumRequest($album_id, $device_id, $account_id, $approval_status, $verified, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\SirqulResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\SirqulResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SirqulResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation approveAlbumAsync
     *
     * Approve Album
     *
     * @param  int $album_id The ID of the album (required)
     * @param  string|null $device_id A unique ID given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id The account ID of the user (deviceId or accountId required) (optional)
     * @param  string|null $approval_status The approval status to set {PENDING, REJECTED, APPROVED, FEATURED} (optional)
     * @param  bool|null $verified Sets whether the album should be marked as \&quot;verified\&quot; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['approveAlbum'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function approveAlbumAsync($album_id, $device_id = null, $account_id = null, $approval_status = null, $verified = null, string $contentType = self::contentTypes['approveAlbum'][0])
    {
        return $this->approveAlbumAsyncWithHttpInfo($album_id, $device_id, $account_id, $approval_status, $verified, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation approveAlbumAsyncWithHttpInfo
     *
     * Approve Album
     *
     * @param  int $album_id The ID of the album (required)
     * @param  string|null $device_id A unique ID given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id The account ID of the user (deviceId or accountId required) (optional)
     * @param  string|null $approval_status The approval status to set {PENDING, REJECTED, APPROVED, FEATURED} (optional)
     * @param  bool|null $verified Sets whether the album should be marked as \&quot;verified\&quot; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['approveAlbum'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function approveAlbumAsyncWithHttpInfo($album_id, $device_id = null, $account_id = null, $approval_status = null, $verified = null, string $contentType = self::contentTypes['approveAlbum'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SirqulResponse';
        $request = $this->approveAlbumRequest($album_id, $device_id, $account_id, $approval_status, $verified, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'approveAlbum'
     *
     * @param  int $album_id The ID of the album (required)
     * @param  string|null $device_id A unique ID given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id The account ID of the user (deviceId or accountId required) (optional)
     * @param  string|null $approval_status The approval status to set {PENDING, REJECTED, APPROVED, FEATURED} (optional)
     * @param  bool|null $verified Sets whether the album should be marked as \&quot;verified\&quot; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['approveAlbum'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function approveAlbumRequest($album_id, $device_id = null, $account_id = null, $approval_status = null, $verified = null, string $contentType = self::contentTypes['approveAlbum'][0])
    {

        // verify the required parameter 'album_id' is set
        if ($album_id === null || (is_array($album_id) && count($album_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $album_id when calling approveAlbum'
            );
        }






        $resourcePath = '/album/approve';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_id,
            'deviceId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $album_id,
            'albumId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $approval_status,
            'approvalStatus', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $verified,
            'verified', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAlbumCollection
     *
     * Get Album
     *
     * @param  bool $return_nulls This parameter is deprecated. (required)
     * @param  int $album_id the album to look up (required)
     * @param  string|null $device_id a unique ID given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account ID of the user (deviceId or accountId required) (optional)
     * @param  int|null $like_preview_size returns the last X likes. To search on and paginate the remaining likes - please use the \&quot;/like/search\&quot; endpoint. (optional)
     * @param  int|null $asset_preview_size returns the first X assets. To search on and paginate the remaining assets - please use the \&quot;/assets/search\&quot; endpoint. (optional)
     * @param  int|null $note_preview_size returns the last X notes. To search on and paginate the remaining notes - please use the \&quot;/note/search\&quot; endpoint. (optional)
     * @param  int|null $connection_preview_size returns the first X users/connections. To search on and paginate the remaining connections - please use the \&quot;/permissions/search\&quot; endpoint. (optional)
     * @param  int|null $audience_preview_size returns the first X audiences. To search on and paginate the remaining audiences - please use the \&quot;/audience/search\&quot; endpoint. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAlbumCollection'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AlbumFullResponse
     */
    public function getAlbumCollection($return_nulls, $album_id, $device_id = null, $account_id = null, $like_preview_size = null, $asset_preview_size = null, $note_preview_size = null, $connection_preview_size = null, $audience_preview_size = null, string $contentType = self::contentTypes['getAlbumCollection'][0])
    {
        list($response) = $this->getAlbumCollectionWithHttpInfo($return_nulls, $album_id, $device_id, $account_id, $like_preview_size, $asset_preview_size, $note_preview_size, $connection_preview_size, $audience_preview_size, $contentType);
        return $response;
    }

    /**
     * Operation getAlbumCollectionWithHttpInfo
     *
     * Get Album
     *
     * @param  bool $return_nulls This parameter is deprecated. (required)
     * @param  int $album_id the album to look up (required)
     * @param  string|null $device_id a unique ID given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account ID of the user (deviceId or accountId required) (optional)
     * @param  int|null $like_preview_size returns the last X likes. To search on and paginate the remaining likes - please use the \&quot;/like/search\&quot; endpoint. (optional)
     * @param  int|null $asset_preview_size returns the first X assets. To search on and paginate the remaining assets - please use the \&quot;/assets/search\&quot; endpoint. (optional)
     * @param  int|null $note_preview_size returns the last X notes. To search on and paginate the remaining notes - please use the \&quot;/note/search\&quot; endpoint. (optional)
     * @param  int|null $connection_preview_size returns the first X users/connections. To search on and paginate the remaining connections - please use the \&quot;/permissions/search\&quot; endpoint. (optional)
     * @param  int|null $audience_preview_size returns the first X audiences. To search on and paginate the remaining audiences - please use the \&quot;/audience/search\&quot; endpoint. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAlbumCollection'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AlbumFullResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAlbumCollectionWithHttpInfo($return_nulls, $album_id, $device_id = null, $account_id = null, $like_preview_size = null, $asset_preview_size = null, $note_preview_size = null, $connection_preview_size = null, $audience_preview_size = null, string $contentType = self::contentTypes['getAlbumCollection'][0])
    {
        $request = $this->getAlbumCollectionRequest($return_nulls, $album_id, $device_id, $account_id, $like_preview_size, $asset_preview_size, $note_preview_size, $connection_preview_size, $audience_preview_size, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\AlbumFullResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\AlbumFullResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AlbumFullResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getAlbumCollectionAsync
     *
     * Get Album
     *
     * @param  bool $return_nulls This parameter is deprecated. (required)
     * @param  int $album_id the album to look up (required)
     * @param  string|null $device_id a unique ID given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account ID of the user (deviceId or accountId required) (optional)
     * @param  int|null $like_preview_size returns the last X likes. To search on and paginate the remaining likes - please use the \&quot;/like/search\&quot; endpoint. (optional)
     * @param  int|null $asset_preview_size returns the first X assets. To search on and paginate the remaining assets - please use the \&quot;/assets/search\&quot; endpoint. (optional)
     * @param  int|null $note_preview_size returns the last X notes. To search on and paginate the remaining notes - please use the \&quot;/note/search\&quot; endpoint. (optional)
     * @param  int|null $connection_preview_size returns the first X users/connections. To search on and paginate the remaining connections - please use the \&quot;/permissions/search\&quot; endpoint. (optional)
     * @param  int|null $audience_preview_size returns the first X audiences. To search on and paginate the remaining audiences - please use the \&quot;/audience/search\&quot; endpoint. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAlbumCollection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAlbumCollectionAsync($return_nulls, $album_id, $device_id = null, $account_id = null, $like_preview_size = null, $asset_preview_size = null, $note_preview_size = null, $connection_preview_size = null, $audience_preview_size = null, string $contentType = self::contentTypes['getAlbumCollection'][0])
    {
        return $this->getAlbumCollectionAsyncWithHttpInfo($return_nulls, $album_id, $device_id, $account_id, $like_preview_size, $asset_preview_size, $note_preview_size, $connection_preview_size, $audience_preview_size, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAlbumCollectionAsyncWithHttpInfo
     *
     * Get Album
     *
     * @param  bool $return_nulls This parameter is deprecated. (required)
     * @param  int $album_id the album to look up (required)
     * @param  string|null $device_id a unique ID given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account ID of the user (deviceId or accountId required) (optional)
     * @param  int|null $like_preview_size returns the last X likes. To search on and paginate the remaining likes - please use the \&quot;/like/search\&quot; endpoint. (optional)
     * @param  int|null $asset_preview_size returns the first X assets. To search on and paginate the remaining assets - please use the \&quot;/assets/search\&quot; endpoint. (optional)
     * @param  int|null $note_preview_size returns the last X notes. To search on and paginate the remaining notes - please use the \&quot;/note/search\&quot; endpoint. (optional)
     * @param  int|null $connection_preview_size returns the first X users/connections. To search on and paginate the remaining connections - please use the \&quot;/permissions/search\&quot; endpoint. (optional)
     * @param  int|null $audience_preview_size returns the first X audiences. To search on and paginate the remaining audiences - please use the \&quot;/audience/search\&quot; endpoint. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAlbumCollection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAlbumCollectionAsyncWithHttpInfo($return_nulls, $album_id, $device_id = null, $account_id = null, $like_preview_size = null, $asset_preview_size = null, $note_preview_size = null, $connection_preview_size = null, $audience_preview_size = null, string $contentType = self::contentTypes['getAlbumCollection'][0])
    {
        $returnType = '\OpenAPI\Client\Model\AlbumFullResponse';
        $request = $this->getAlbumCollectionRequest($return_nulls, $album_id, $device_id, $account_id, $like_preview_size, $asset_preview_size, $note_preview_size, $connection_preview_size, $audience_preview_size, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAlbumCollection'
     *
     * @param  bool $return_nulls This parameter is deprecated. (required)
     * @param  int $album_id the album to look up (required)
     * @param  string|null $device_id a unique ID given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account ID of the user (deviceId or accountId required) (optional)
     * @param  int|null $like_preview_size returns the last X likes. To search on and paginate the remaining likes - please use the \&quot;/like/search\&quot; endpoint. (optional)
     * @param  int|null $asset_preview_size returns the first X assets. To search on and paginate the remaining assets - please use the \&quot;/assets/search\&quot; endpoint. (optional)
     * @param  int|null $note_preview_size returns the last X notes. To search on and paginate the remaining notes - please use the \&quot;/note/search\&quot; endpoint. (optional)
     * @param  int|null $connection_preview_size returns the first X users/connections. To search on and paginate the remaining connections - please use the \&quot;/permissions/search\&quot; endpoint. (optional)
     * @param  int|null $audience_preview_size returns the first X audiences. To search on and paginate the remaining audiences - please use the \&quot;/audience/search\&quot; endpoint. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAlbumCollection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAlbumCollectionRequest($return_nulls, $album_id, $device_id = null, $account_id = null, $like_preview_size = null, $asset_preview_size = null, $note_preview_size = null, $connection_preview_size = null, $audience_preview_size = null, string $contentType = self::contentTypes['getAlbumCollection'][0])
    {

        // verify the required parameter 'return_nulls' is set
        if ($return_nulls === null || (is_array($return_nulls) && count($return_nulls) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $return_nulls when calling getAlbumCollection'
            );
        }

        // verify the required parameter 'album_id' is set
        if ($album_id === null || (is_array($album_id) && count($album_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $album_id when calling getAlbumCollection'
            );
        }









        $resourcePath = '/album/get';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_nulls,
            'returnNulls', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_id,
            'deviceId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $album_id,
            'albumId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $like_preview_size,
            'likePreviewSize', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $asset_preview_size,
            'assetPreviewSize', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $note_preview_size,
            'notePreviewSize', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $connection_preview_size,
            'connectionPreviewSize', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audience_preview_size,
            'audiencePreviewSize', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation leaveAlbum
     *
     * Leave Album
     *
     * @param  int $album_id the album ID (required)
     * @param  string|null $device_id a unique ID given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account ID of the user (deviceId or accountId required) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leaveAlbum'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SirqulResponse
     */
    public function leaveAlbum($album_id, $device_id = null, $account_id = null, string $contentType = self::contentTypes['leaveAlbum'][0])
    {
        list($response) = $this->leaveAlbumWithHttpInfo($album_id, $device_id, $account_id, $contentType);
        return $response;
    }

    /**
     * Operation leaveAlbumWithHttpInfo
     *
     * Leave Album
     *
     * @param  int $album_id the album ID (required)
     * @param  string|null $device_id a unique ID given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account ID of the user (deviceId or accountId required) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leaveAlbum'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SirqulResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function leaveAlbumWithHttpInfo($album_id, $device_id = null, $account_id = null, string $contentType = self::contentTypes['leaveAlbum'][0])
    {
        $request = $this->leaveAlbumRequest($album_id, $device_id, $account_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\SirqulResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\SirqulResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SirqulResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation leaveAlbumAsync
     *
     * Leave Album
     *
     * @param  int $album_id the album ID (required)
     * @param  string|null $device_id a unique ID given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account ID of the user (deviceId or accountId required) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leaveAlbum'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function leaveAlbumAsync($album_id, $device_id = null, $account_id = null, string $contentType = self::contentTypes['leaveAlbum'][0])
    {
        return $this->leaveAlbumAsyncWithHttpInfo($album_id, $device_id, $account_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation leaveAlbumAsyncWithHttpInfo
     *
     * Leave Album
     *
     * @param  int $album_id the album ID (required)
     * @param  string|null $device_id a unique ID given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account ID of the user (deviceId or accountId required) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leaveAlbum'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function leaveAlbumAsyncWithHttpInfo($album_id, $device_id = null, $account_id = null, string $contentType = self::contentTypes['leaveAlbum'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SirqulResponse';
        $request = $this->leaveAlbumRequest($album_id, $device_id, $account_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'leaveAlbum'
     *
     * @param  int $album_id the album ID (required)
     * @param  string|null $device_id a unique ID given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account ID of the user (deviceId or accountId required) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leaveAlbum'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function leaveAlbumRequest($album_id, $device_id = null, $account_id = null, string $contentType = self::contentTypes['leaveAlbum'][0])
    {

        // verify the required parameter 'album_id' is set
        if ($album_id === null || (is_array($album_id) && count($album_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $album_id when calling leaveAlbum'
            );
        }




        $resourcePath = '/album/user/leave';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_id,
            'deviceId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $album_id,
            'albumId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation removeAlbum
     *
     * Delete Album
     *
     * @param  int $album_id the album ID to delete (required)
     * @param  string|null $device_id a unique ID given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account ID of the user (deviceId or accountId required) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removeAlbum'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SirqulResponse
     */
    public function removeAlbum($album_id, $device_id = null, $account_id = null, string $contentType = self::contentTypes['removeAlbum'][0])
    {
        list($response) = $this->removeAlbumWithHttpInfo($album_id, $device_id, $account_id, $contentType);
        return $response;
    }

    /**
     * Operation removeAlbumWithHttpInfo
     *
     * Delete Album
     *
     * @param  int $album_id the album ID to delete (required)
     * @param  string|null $device_id a unique ID given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account ID of the user (deviceId or accountId required) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removeAlbum'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SirqulResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function removeAlbumWithHttpInfo($album_id, $device_id = null, $account_id = null, string $contentType = self::contentTypes['removeAlbum'][0])
    {
        $request = $this->removeAlbumRequest($album_id, $device_id, $account_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\SirqulResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\SirqulResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SirqulResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation removeAlbumAsync
     *
     * Delete Album
     *
     * @param  int $album_id the album ID to delete (required)
     * @param  string|null $device_id a unique ID given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account ID of the user (deviceId or accountId required) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removeAlbum'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function removeAlbumAsync($album_id, $device_id = null, $account_id = null, string $contentType = self::contentTypes['removeAlbum'][0])
    {
        return $this->removeAlbumAsyncWithHttpInfo($album_id, $device_id, $account_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation removeAlbumAsyncWithHttpInfo
     *
     * Delete Album
     *
     * @param  int $album_id the album ID to delete (required)
     * @param  string|null $device_id a unique ID given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account ID of the user (deviceId or accountId required) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removeAlbum'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function removeAlbumAsyncWithHttpInfo($album_id, $device_id = null, $account_id = null, string $contentType = self::contentTypes['removeAlbum'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SirqulResponse';
        $request = $this->removeAlbumRequest($album_id, $device_id, $account_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'removeAlbum'
     *
     * @param  int $album_id the album ID to delete (required)
     * @param  string|null $device_id a unique ID given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account ID of the user (deviceId or accountId required) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removeAlbum'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function removeAlbumRequest($album_id, $device_id = null, $account_id = null, string $contentType = self::contentTypes['removeAlbum'][0])
    {

        // verify the required parameter 'album_id' is set
        if ($album_id === null || (is_array($album_id) && count($album_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $album_id when calling removeAlbum'
            );
        }




        $resourcePath = '/album/delete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_id,
            'deviceId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $album_id,
            'albumId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation removeAlbumUsers
     *
     * Remove Album Users
     *
     * @param  int $album_id the album ID (required)
     * @param  bool $remove_friend_group remove friend group (required)
     * @param  string|null $device_id a unique ID given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account ID of the user (deviceId or accountId required) (optional)
     * @param  string|null $connections comma separated list of connection IDs (optional)
     * @param  string|null $connection_groups comma separated list of connection group IDs (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removeAlbumUsers'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SirqulResponse
     */
    public function removeAlbumUsers($album_id, $remove_friend_group, $device_id = null, $account_id = null, $connections = null, $connection_groups = null, string $contentType = self::contentTypes['removeAlbumUsers'][0])
    {
        list($response) = $this->removeAlbumUsersWithHttpInfo($album_id, $remove_friend_group, $device_id, $account_id, $connections, $connection_groups, $contentType);
        return $response;
    }

    /**
     * Operation removeAlbumUsersWithHttpInfo
     *
     * Remove Album Users
     *
     * @param  int $album_id the album ID (required)
     * @param  bool $remove_friend_group remove friend group (required)
     * @param  string|null $device_id a unique ID given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account ID of the user (deviceId or accountId required) (optional)
     * @param  string|null $connections comma separated list of connection IDs (optional)
     * @param  string|null $connection_groups comma separated list of connection group IDs (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removeAlbumUsers'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SirqulResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function removeAlbumUsersWithHttpInfo($album_id, $remove_friend_group, $device_id = null, $account_id = null, $connections = null, $connection_groups = null, string $contentType = self::contentTypes['removeAlbumUsers'][0])
    {
        $request = $this->removeAlbumUsersRequest($album_id, $remove_friend_group, $device_id, $account_id, $connections, $connection_groups, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\SirqulResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\SirqulResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SirqulResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation removeAlbumUsersAsync
     *
     * Remove Album Users
     *
     * @param  int $album_id the album ID (required)
     * @param  bool $remove_friend_group remove friend group (required)
     * @param  string|null $device_id a unique ID given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account ID of the user (deviceId or accountId required) (optional)
     * @param  string|null $connections comma separated list of connection IDs (optional)
     * @param  string|null $connection_groups comma separated list of connection group IDs (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removeAlbumUsers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function removeAlbumUsersAsync($album_id, $remove_friend_group, $device_id = null, $account_id = null, $connections = null, $connection_groups = null, string $contentType = self::contentTypes['removeAlbumUsers'][0])
    {
        return $this->removeAlbumUsersAsyncWithHttpInfo($album_id, $remove_friend_group, $device_id, $account_id, $connections, $connection_groups, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation removeAlbumUsersAsyncWithHttpInfo
     *
     * Remove Album Users
     *
     * @param  int $album_id the album ID (required)
     * @param  bool $remove_friend_group remove friend group (required)
     * @param  string|null $device_id a unique ID given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account ID of the user (deviceId or accountId required) (optional)
     * @param  string|null $connections comma separated list of connection IDs (optional)
     * @param  string|null $connection_groups comma separated list of connection group IDs (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removeAlbumUsers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function removeAlbumUsersAsyncWithHttpInfo($album_id, $remove_friend_group, $device_id = null, $account_id = null, $connections = null, $connection_groups = null, string $contentType = self::contentTypes['removeAlbumUsers'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SirqulResponse';
        $request = $this->removeAlbumUsersRequest($album_id, $remove_friend_group, $device_id, $account_id, $connections, $connection_groups, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'removeAlbumUsers'
     *
     * @param  int $album_id the album ID (required)
     * @param  bool $remove_friend_group remove friend group (required)
     * @param  string|null $device_id a unique ID given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account ID of the user (deviceId or accountId required) (optional)
     * @param  string|null $connections comma separated list of connection IDs (optional)
     * @param  string|null $connection_groups comma separated list of connection group IDs (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removeAlbumUsers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function removeAlbumUsersRequest($album_id, $remove_friend_group, $device_id = null, $account_id = null, $connections = null, $connection_groups = null, string $contentType = self::contentTypes['removeAlbumUsers'][0])
    {

        // verify the required parameter 'album_id' is set
        if ($album_id === null || (is_array($album_id) && count($album_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $album_id when calling removeAlbumUsers'
            );
        }

        // verify the required parameter 'remove_friend_group' is set
        if ($remove_friend_group === null || (is_array($remove_friend_group) && count($remove_friend_group) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $remove_friend_group when calling removeAlbumUsers'
            );
        }






        $resourcePath = '/album/user/delete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_id,
            'deviceId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $album_id,
            'albumId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $connections,
            'connections', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $connection_groups,
            'connectionGroups', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $remove_friend_group,
            'removeFriendGroup', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchAlbums
     *
     * Search Albums
     *
     * @param  string $filter a comma separated list of filters: * MINE - Return albums that the user has created. * SHARED - Return albums that have been shared to the user via addAlbumUsers, or addUsersToPermissionable . * FOLLOWER - Return albums that have been created by the user&#39;s followers (the content needs to have been APPROVED or FEATURED). * FOLLOWING - Return albums that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED). * PUBLIC - Return all PUBLIC albums that have been APPROVED or FEATURED. * ALL_PUBLIC - Return all PUBLIC albums regardless of whether they are approved or not (ignores the approval status). * LIKED - Return all albums that the user has liked. * FEATURED - Return all albums that have been featured. * PENDING - Return all pending albums. (required)
     * @param  int $album_type_id id of custom albumType (required)
     * @param  string $sub_type filter albums with this album sub type (required)
     * @param  bool $include_inactive determines whether to return inactive albums (required)
     * @param  string $sort_field the field to sort by. See AlbumApiMap (required)
     * @param  bool $descending determines whether the sorted list is in descending or ascending order (required)
     * @param  int $start the start index for pagination (required)
     * @param  int $limit the limit for pagination (There is a hard limit of 100) (required)
     * @param  float $range the maximum range the album can be from the center (used when sortField&#x3D;ALBUM_DISTANCE) (required)
     * @param  bool $include_liked returns whether or not the current logged in user has liked the album (required)
     * @param  bool $include_favorited returns whether or not the current logged in user has favorited the album (required)
     * @param  bool $include_permissions returns permission details on whether they have read/write/delete permissions etc (client app probably doesn&#39;t need this) (required)
     * @param  int $like_preview_size returns the last X likes (required)
     * @param  int $asset_preview_size returns the first X assets (required)
     * @param  int $note_preview_size returns the last X notes (required)
     * @param  int $connection_preview_size returns the first X users/connections (required)
     * @param  int $audience_preview_size returns the first X audiences. To search on and paginate the remaining audiences, please use the \&quot;/audience/search\&quot; endpoint. (required)
     * @param  string|null $device_id a unique ID given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account ID of the user (deviceId or accountId required) (optional)
     * @param  int|null $connection_account_id the account ID of the user that the results will be based on. This is used to return albums that this account has liked/favorited. (optional)
     * @param  int|null $owner_id search on albums that have been created by this account (that the user has permissions to) (optional)
     * @param  string|null $album_ids search on album within a comma separated list of album IDs (this does not work with sortField&#x3D;ALBUM_DISTANCE, or when stackSearch&#x3D;true) (optional)
     * @param  string|null $exclude_album_ids Only for CLOUDINDEX mode, exclude albums with ids matching this list (optional)
     * @param  int|null $media_id search on albums that are in a particular media offering (optional)
     * @param  string|null $keyword keyword search string (optional)
     * @param  string|null $album_type filter albums with this album type (optional)
     * @param  int|null $limit_per_album_type When using multiple album types this sets a per-album-type limit (used with cloud index mode) (optional)
     * @param  int|null $date_created return items that have been created before this date (time-stamp in milliseconds) (optional)
     * @param  int|null $updated_since return items that have been updated since this date (time-stamp in milliseconds) (optional)
     * @param  int|null $updated_before return items that have been updated before this date (time-stamp in milliseconds) (optional)
     * @param  int|null $created_since return items that have been created since this date (time-stamp in milliseconds) (optional)
     * @param  int|null $created_before return items that have been created before this date (time-stamp in milliseconds) (optional)
     * @param  int|null $started_since return items that have been started since this date (time-stamp in milliseconds) (optional)
     * @param  int|null $started_before return items that have been started before this date (time-stamp in milliseconds) (optional)
     * @param  int|null $ended_since return items that have been ended since this date (time-stamp in milliseconds) (optional)
     * @param  int|null $ended_before return items that have been ended before this date (time-stamp in milliseconds) (optional)
     * @param  float|null $latitude the latitude of where the search is centered on (used when sortField&#x3D;ALBUM_DISTANCE) (optional)
     * @param  float|null $longitude the longitude of where the search is centered on (used when sortField&#x3D;ALBUM_DISTANCE) (optional)
     * @param  string|null $app_key the application key to filter results by application. This is required for consumer searches. Leaving this empty will return albums for the applications that the logged in user owns or has access to. (optional)
     * @param  string|null $category_ids return results with categories matching this list (optional)
     * @param  string|null $category_filter_ids return results with filters matching this list (optional)
     * @param  string|null $audience_ids return results with audiences matching this list (optional)
     * @param  string|null $exclude_audience_ids exclude audiences with ids matching this list (optional)
     * @param  bool|null $include_completable returns the user&#39;s completable object for the album if it exists (optional)
     * @param  bool|null $include_rating returns the user&#39;s rating for the album if it exists (optional)
     * @param  string|null $search_mode The search index mode to use (RDS, LUCENE, or CLOUDINDEX). If not provided will use server default. (optional)
     * @param  bool|null $stack_search groups similar albums together that have the same albumTypeId, within a time window defined in stackWindowSize (optional)
     * @param  int|null $stack_window_size size of each window for each stack (optional)
     * @param  int|null $min_stack_per_page The minimum number of stacks returned in a response. For example,  first call, minStackPerPage &#x3D; 20, the API will return at least 20 results (optional)
     * @param  string|null $stack_pagination_identifier this is used to tell the system where it left off on the previous previous page, since we can&#39;t use start/limit for stackSearch (optional)
     * @param  bool|null $stack_details set this to true when making the call to view the albums in the stack (optional)
     * @param  int|null $flag_count_minimum Return any results that have a minimum of the specified flag count (even ones that have met the flag threshold) (optional)
     * @param  bool|null $remove_flagged_content return items that have flagCount &gt;&#x3D; flagThreshold (controls removal of flagged content) (optional, default to true)
     * @param  bool|null $verified_filter setting to true will return only verified albums only, setting to false will return non-verified albums only (leave empty to return both) (optional)
     * @param  string|null $linked_object_type filter results by the linkedObjectType (optional)
     * @param  int|null $linked_object_id filter results by the linkedObjectId (optional)
     * @param  int|null $order_audience_id determines whether to use the order assigned via the /album/order/_* api (which is tied to an audience) (optional)
     * @param  bool|null $ignore_default_app_filter if true, ignore the application&#39;s default app filter when searching (optional)
     * @param  string|null $search_expression Advanced search expression to be used by the server (optional)
     * @param  bool|null $generate_albums If true and results are empty, attempt to generate albums via templates (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchAlbums'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AlbumFullResponse[]
     */
    public function searchAlbums($filter, $album_type_id, $sub_type, $include_inactive, $sort_field, $descending, $start, $limit, $range, $include_liked, $include_favorited, $include_permissions, $like_preview_size, $asset_preview_size, $note_preview_size, $connection_preview_size, $audience_preview_size, $device_id = null, $account_id = null, $connection_account_id = null, $owner_id = null, $album_ids = null, $exclude_album_ids = null, $media_id = null, $keyword = null, $album_type = null, $limit_per_album_type = null, $date_created = null, $updated_since = null, $updated_before = null, $created_since = null, $created_before = null, $started_since = null, $started_before = null, $ended_since = null, $ended_before = null, $latitude = null, $longitude = null, $app_key = null, $category_ids = null, $category_filter_ids = null, $audience_ids = null, $exclude_audience_ids = null, $include_completable = null, $include_rating = null, $search_mode = null, $stack_search = null, $stack_window_size = null, $min_stack_per_page = null, $stack_pagination_identifier = null, $stack_details = null, $flag_count_minimum = null, $remove_flagged_content = true, $verified_filter = null, $linked_object_type = null, $linked_object_id = null, $order_audience_id = null, $ignore_default_app_filter = null, $search_expression = null, $generate_albums = null, string $contentType = self::contentTypes['searchAlbums'][0])
    {
        list($response) = $this->searchAlbumsWithHttpInfo($filter, $album_type_id, $sub_type, $include_inactive, $sort_field, $descending, $start, $limit, $range, $include_liked, $include_favorited, $include_permissions, $like_preview_size, $asset_preview_size, $note_preview_size, $connection_preview_size, $audience_preview_size, $device_id, $account_id, $connection_account_id, $owner_id, $album_ids, $exclude_album_ids, $media_id, $keyword, $album_type, $limit_per_album_type, $date_created, $updated_since, $updated_before, $created_since, $created_before, $started_since, $started_before, $ended_since, $ended_before, $latitude, $longitude, $app_key, $category_ids, $category_filter_ids, $audience_ids, $exclude_audience_ids, $include_completable, $include_rating, $search_mode, $stack_search, $stack_window_size, $min_stack_per_page, $stack_pagination_identifier, $stack_details, $flag_count_minimum, $remove_flagged_content, $verified_filter, $linked_object_type, $linked_object_id, $order_audience_id, $ignore_default_app_filter, $search_expression, $generate_albums, $contentType);
        return $response;
    }

    /**
     * Operation searchAlbumsWithHttpInfo
     *
     * Search Albums
     *
     * @param  string $filter a comma separated list of filters: * MINE - Return albums that the user has created. * SHARED - Return albums that have been shared to the user via addAlbumUsers, or addUsersToPermissionable . * FOLLOWER - Return albums that have been created by the user&#39;s followers (the content needs to have been APPROVED or FEATURED). * FOLLOWING - Return albums that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED). * PUBLIC - Return all PUBLIC albums that have been APPROVED or FEATURED. * ALL_PUBLIC - Return all PUBLIC albums regardless of whether they are approved or not (ignores the approval status). * LIKED - Return all albums that the user has liked. * FEATURED - Return all albums that have been featured. * PENDING - Return all pending albums. (required)
     * @param  int $album_type_id id of custom albumType (required)
     * @param  string $sub_type filter albums with this album sub type (required)
     * @param  bool $include_inactive determines whether to return inactive albums (required)
     * @param  string $sort_field the field to sort by. See AlbumApiMap (required)
     * @param  bool $descending determines whether the sorted list is in descending or ascending order (required)
     * @param  int $start the start index for pagination (required)
     * @param  int $limit the limit for pagination (There is a hard limit of 100) (required)
     * @param  float $range the maximum range the album can be from the center (used when sortField&#x3D;ALBUM_DISTANCE) (required)
     * @param  bool $include_liked returns whether or not the current logged in user has liked the album (required)
     * @param  bool $include_favorited returns whether or not the current logged in user has favorited the album (required)
     * @param  bool $include_permissions returns permission details on whether they have read/write/delete permissions etc (client app probably doesn&#39;t need this) (required)
     * @param  int $like_preview_size returns the last X likes (required)
     * @param  int $asset_preview_size returns the first X assets (required)
     * @param  int $note_preview_size returns the last X notes (required)
     * @param  int $connection_preview_size returns the first X users/connections (required)
     * @param  int $audience_preview_size returns the first X audiences. To search on and paginate the remaining audiences, please use the \&quot;/audience/search\&quot; endpoint. (required)
     * @param  string|null $device_id a unique ID given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account ID of the user (deviceId or accountId required) (optional)
     * @param  int|null $connection_account_id the account ID of the user that the results will be based on. This is used to return albums that this account has liked/favorited. (optional)
     * @param  int|null $owner_id search on albums that have been created by this account (that the user has permissions to) (optional)
     * @param  string|null $album_ids search on album within a comma separated list of album IDs (this does not work with sortField&#x3D;ALBUM_DISTANCE, or when stackSearch&#x3D;true) (optional)
     * @param  string|null $exclude_album_ids Only for CLOUDINDEX mode, exclude albums with ids matching this list (optional)
     * @param  int|null $media_id search on albums that are in a particular media offering (optional)
     * @param  string|null $keyword keyword search string (optional)
     * @param  string|null $album_type filter albums with this album type (optional)
     * @param  int|null $limit_per_album_type When using multiple album types this sets a per-album-type limit (used with cloud index mode) (optional)
     * @param  int|null $date_created return items that have been created before this date (time-stamp in milliseconds) (optional)
     * @param  int|null $updated_since return items that have been updated since this date (time-stamp in milliseconds) (optional)
     * @param  int|null $updated_before return items that have been updated before this date (time-stamp in milliseconds) (optional)
     * @param  int|null $created_since return items that have been created since this date (time-stamp in milliseconds) (optional)
     * @param  int|null $created_before return items that have been created before this date (time-stamp in milliseconds) (optional)
     * @param  int|null $started_since return items that have been started since this date (time-stamp in milliseconds) (optional)
     * @param  int|null $started_before return items that have been started before this date (time-stamp in milliseconds) (optional)
     * @param  int|null $ended_since return items that have been ended since this date (time-stamp in milliseconds) (optional)
     * @param  int|null $ended_before return items that have been ended before this date (time-stamp in milliseconds) (optional)
     * @param  float|null $latitude the latitude of where the search is centered on (used when sortField&#x3D;ALBUM_DISTANCE) (optional)
     * @param  float|null $longitude the longitude of where the search is centered on (used when sortField&#x3D;ALBUM_DISTANCE) (optional)
     * @param  string|null $app_key the application key to filter results by application. This is required for consumer searches. Leaving this empty will return albums for the applications that the logged in user owns or has access to. (optional)
     * @param  string|null $category_ids return results with categories matching this list (optional)
     * @param  string|null $category_filter_ids return results with filters matching this list (optional)
     * @param  string|null $audience_ids return results with audiences matching this list (optional)
     * @param  string|null $exclude_audience_ids exclude audiences with ids matching this list (optional)
     * @param  bool|null $include_completable returns the user&#39;s completable object for the album if it exists (optional)
     * @param  bool|null $include_rating returns the user&#39;s rating for the album if it exists (optional)
     * @param  string|null $search_mode The search index mode to use (RDS, LUCENE, or CLOUDINDEX). If not provided will use server default. (optional)
     * @param  bool|null $stack_search groups similar albums together that have the same albumTypeId, within a time window defined in stackWindowSize (optional)
     * @param  int|null $stack_window_size size of each window for each stack (optional)
     * @param  int|null $min_stack_per_page The minimum number of stacks returned in a response. For example,  first call, minStackPerPage &#x3D; 20, the API will return at least 20 results (optional)
     * @param  string|null $stack_pagination_identifier this is used to tell the system where it left off on the previous previous page, since we can&#39;t use start/limit for stackSearch (optional)
     * @param  bool|null $stack_details set this to true when making the call to view the albums in the stack (optional)
     * @param  int|null $flag_count_minimum Return any results that have a minimum of the specified flag count (even ones that have met the flag threshold) (optional)
     * @param  bool|null $remove_flagged_content return items that have flagCount &gt;&#x3D; flagThreshold (controls removal of flagged content) (optional, default to true)
     * @param  bool|null $verified_filter setting to true will return only verified albums only, setting to false will return non-verified albums only (leave empty to return both) (optional)
     * @param  string|null $linked_object_type filter results by the linkedObjectType (optional)
     * @param  int|null $linked_object_id filter results by the linkedObjectId (optional)
     * @param  int|null $order_audience_id determines whether to use the order assigned via the /album/order/_* api (which is tied to an audience) (optional)
     * @param  bool|null $ignore_default_app_filter if true, ignore the application&#39;s default app filter when searching (optional)
     * @param  string|null $search_expression Advanced search expression to be used by the server (optional)
     * @param  bool|null $generate_albums If true and results are empty, attempt to generate albums via templates (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchAlbums'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AlbumFullResponse[], HTTP status code, HTTP response headers (array of strings)
     */
    public function searchAlbumsWithHttpInfo($filter, $album_type_id, $sub_type, $include_inactive, $sort_field, $descending, $start, $limit, $range, $include_liked, $include_favorited, $include_permissions, $like_preview_size, $asset_preview_size, $note_preview_size, $connection_preview_size, $audience_preview_size, $device_id = null, $account_id = null, $connection_account_id = null, $owner_id = null, $album_ids = null, $exclude_album_ids = null, $media_id = null, $keyword = null, $album_type = null, $limit_per_album_type = null, $date_created = null, $updated_since = null, $updated_before = null, $created_since = null, $created_before = null, $started_since = null, $started_before = null, $ended_since = null, $ended_before = null, $latitude = null, $longitude = null, $app_key = null, $category_ids = null, $category_filter_ids = null, $audience_ids = null, $exclude_audience_ids = null, $include_completable = null, $include_rating = null, $search_mode = null, $stack_search = null, $stack_window_size = null, $min_stack_per_page = null, $stack_pagination_identifier = null, $stack_details = null, $flag_count_minimum = null, $remove_flagged_content = true, $verified_filter = null, $linked_object_type = null, $linked_object_id = null, $order_audience_id = null, $ignore_default_app_filter = null, $search_expression = null, $generate_albums = null, string $contentType = self::contentTypes['searchAlbums'][0])
    {
        $request = $this->searchAlbumsRequest($filter, $album_type_id, $sub_type, $include_inactive, $sort_field, $descending, $start, $limit, $range, $include_liked, $include_favorited, $include_permissions, $like_preview_size, $asset_preview_size, $note_preview_size, $connection_preview_size, $audience_preview_size, $device_id, $account_id, $connection_account_id, $owner_id, $album_ids, $exclude_album_ids, $media_id, $keyword, $album_type, $limit_per_album_type, $date_created, $updated_since, $updated_before, $created_since, $created_before, $started_since, $started_before, $ended_since, $ended_before, $latitude, $longitude, $app_key, $category_ids, $category_filter_ids, $audience_ids, $exclude_audience_ids, $include_completable, $include_rating, $search_mode, $stack_search, $stack_window_size, $min_stack_per_page, $stack_pagination_identifier, $stack_details, $flag_count_minimum, $remove_flagged_content, $verified_filter, $linked_object_type, $linked_object_id, $order_audience_id, $ignore_default_app_filter, $search_expression, $generate_albums, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\AlbumFullResponse[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\AlbumFullResponse[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AlbumFullResponse[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation searchAlbumsAsync
     *
     * Search Albums
     *
     * @param  string $filter a comma separated list of filters: * MINE - Return albums that the user has created. * SHARED - Return albums that have been shared to the user via addAlbumUsers, or addUsersToPermissionable . * FOLLOWER - Return albums that have been created by the user&#39;s followers (the content needs to have been APPROVED or FEATURED). * FOLLOWING - Return albums that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED). * PUBLIC - Return all PUBLIC albums that have been APPROVED or FEATURED. * ALL_PUBLIC - Return all PUBLIC albums regardless of whether they are approved or not (ignores the approval status). * LIKED - Return all albums that the user has liked. * FEATURED - Return all albums that have been featured. * PENDING - Return all pending albums. (required)
     * @param  int $album_type_id id of custom albumType (required)
     * @param  string $sub_type filter albums with this album sub type (required)
     * @param  bool $include_inactive determines whether to return inactive albums (required)
     * @param  string $sort_field the field to sort by. See AlbumApiMap (required)
     * @param  bool $descending determines whether the sorted list is in descending or ascending order (required)
     * @param  int $start the start index for pagination (required)
     * @param  int $limit the limit for pagination (There is a hard limit of 100) (required)
     * @param  float $range the maximum range the album can be from the center (used when sortField&#x3D;ALBUM_DISTANCE) (required)
     * @param  bool $include_liked returns whether or not the current logged in user has liked the album (required)
     * @param  bool $include_favorited returns whether or not the current logged in user has favorited the album (required)
     * @param  bool $include_permissions returns permission details on whether they have read/write/delete permissions etc (client app probably doesn&#39;t need this) (required)
     * @param  int $like_preview_size returns the last X likes (required)
     * @param  int $asset_preview_size returns the first X assets (required)
     * @param  int $note_preview_size returns the last X notes (required)
     * @param  int $connection_preview_size returns the first X users/connections (required)
     * @param  int $audience_preview_size returns the first X audiences. To search on and paginate the remaining audiences, please use the \&quot;/audience/search\&quot; endpoint. (required)
     * @param  string|null $device_id a unique ID given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account ID of the user (deviceId or accountId required) (optional)
     * @param  int|null $connection_account_id the account ID of the user that the results will be based on. This is used to return albums that this account has liked/favorited. (optional)
     * @param  int|null $owner_id search on albums that have been created by this account (that the user has permissions to) (optional)
     * @param  string|null $album_ids search on album within a comma separated list of album IDs (this does not work with sortField&#x3D;ALBUM_DISTANCE, or when stackSearch&#x3D;true) (optional)
     * @param  string|null $exclude_album_ids Only for CLOUDINDEX mode, exclude albums with ids matching this list (optional)
     * @param  int|null $media_id search on albums that are in a particular media offering (optional)
     * @param  string|null $keyword keyword search string (optional)
     * @param  string|null $album_type filter albums with this album type (optional)
     * @param  int|null $limit_per_album_type When using multiple album types this sets a per-album-type limit (used with cloud index mode) (optional)
     * @param  int|null $date_created return items that have been created before this date (time-stamp in milliseconds) (optional)
     * @param  int|null $updated_since return items that have been updated since this date (time-stamp in milliseconds) (optional)
     * @param  int|null $updated_before return items that have been updated before this date (time-stamp in milliseconds) (optional)
     * @param  int|null $created_since return items that have been created since this date (time-stamp in milliseconds) (optional)
     * @param  int|null $created_before return items that have been created before this date (time-stamp in milliseconds) (optional)
     * @param  int|null $started_since return items that have been started since this date (time-stamp in milliseconds) (optional)
     * @param  int|null $started_before return items that have been started before this date (time-stamp in milliseconds) (optional)
     * @param  int|null $ended_since return items that have been ended since this date (time-stamp in milliseconds) (optional)
     * @param  int|null $ended_before return items that have been ended before this date (time-stamp in milliseconds) (optional)
     * @param  float|null $latitude the latitude of where the search is centered on (used when sortField&#x3D;ALBUM_DISTANCE) (optional)
     * @param  float|null $longitude the longitude of where the search is centered on (used when sortField&#x3D;ALBUM_DISTANCE) (optional)
     * @param  string|null $app_key the application key to filter results by application. This is required for consumer searches. Leaving this empty will return albums for the applications that the logged in user owns or has access to. (optional)
     * @param  string|null $category_ids return results with categories matching this list (optional)
     * @param  string|null $category_filter_ids return results with filters matching this list (optional)
     * @param  string|null $audience_ids return results with audiences matching this list (optional)
     * @param  string|null $exclude_audience_ids exclude audiences with ids matching this list (optional)
     * @param  bool|null $include_completable returns the user&#39;s completable object for the album if it exists (optional)
     * @param  bool|null $include_rating returns the user&#39;s rating for the album if it exists (optional)
     * @param  string|null $search_mode The search index mode to use (RDS, LUCENE, or CLOUDINDEX). If not provided will use server default. (optional)
     * @param  bool|null $stack_search groups similar albums together that have the same albumTypeId, within a time window defined in stackWindowSize (optional)
     * @param  int|null $stack_window_size size of each window for each stack (optional)
     * @param  int|null $min_stack_per_page The minimum number of stacks returned in a response. For example,  first call, minStackPerPage &#x3D; 20, the API will return at least 20 results (optional)
     * @param  string|null $stack_pagination_identifier this is used to tell the system where it left off on the previous previous page, since we can&#39;t use start/limit for stackSearch (optional)
     * @param  bool|null $stack_details set this to true when making the call to view the albums in the stack (optional)
     * @param  int|null $flag_count_minimum Return any results that have a minimum of the specified flag count (even ones that have met the flag threshold) (optional)
     * @param  bool|null $remove_flagged_content return items that have flagCount &gt;&#x3D; flagThreshold (controls removal of flagged content) (optional, default to true)
     * @param  bool|null $verified_filter setting to true will return only verified albums only, setting to false will return non-verified albums only (leave empty to return both) (optional)
     * @param  string|null $linked_object_type filter results by the linkedObjectType (optional)
     * @param  int|null $linked_object_id filter results by the linkedObjectId (optional)
     * @param  int|null $order_audience_id determines whether to use the order assigned via the /album/order/_* api (which is tied to an audience) (optional)
     * @param  bool|null $ignore_default_app_filter if true, ignore the application&#39;s default app filter when searching (optional)
     * @param  string|null $search_expression Advanced search expression to be used by the server (optional)
     * @param  bool|null $generate_albums If true and results are empty, attempt to generate albums via templates (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchAlbums'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchAlbumsAsync($filter, $album_type_id, $sub_type, $include_inactive, $sort_field, $descending, $start, $limit, $range, $include_liked, $include_favorited, $include_permissions, $like_preview_size, $asset_preview_size, $note_preview_size, $connection_preview_size, $audience_preview_size, $device_id = null, $account_id = null, $connection_account_id = null, $owner_id = null, $album_ids = null, $exclude_album_ids = null, $media_id = null, $keyword = null, $album_type = null, $limit_per_album_type = null, $date_created = null, $updated_since = null, $updated_before = null, $created_since = null, $created_before = null, $started_since = null, $started_before = null, $ended_since = null, $ended_before = null, $latitude = null, $longitude = null, $app_key = null, $category_ids = null, $category_filter_ids = null, $audience_ids = null, $exclude_audience_ids = null, $include_completable = null, $include_rating = null, $search_mode = null, $stack_search = null, $stack_window_size = null, $min_stack_per_page = null, $stack_pagination_identifier = null, $stack_details = null, $flag_count_minimum = null, $remove_flagged_content = true, $verified_filter = null, $linked_object_type = null, $linked_object_id = null, $order_audience_id = null, $ignore_default_app_filter = null, $search_expression = null, $generate_albums = null, string $contentType = self::contentTypes['searchAlbums'][0])
    {
        return $this->searchAlbumsAsyncWithHttpInfo($filter, $album_type_id, $sub_type, $include_inactive, $sort_field, $descending, $start, $limit, $range, $include_liked, $include_favorited, $include_permissions, $like_preview_size, $asset_preview_size, $note_preview_size, $connection_preview_size, $audience_preview_size, $device_id, $account_id, $connection_account_id, $owner_id, $album_ids, $exclude_album_ids, $media_id, $keyword, $album_type, $limit_per_album_type, $date_created, $updated_since, $updated_before, $created_since, $created_before, $started_since, $started_before, $ended_since, $ended_before, $latitude, $longitude, $app_key, $category_ids, $category_filter_ids, $audience_ids, $exclude_audience_ids, $include_completable, $include_rating, $search_mode, $stack_search, $stack_window_size, $min_stack_per_page, $stack_pagination_identifier, $stack_details, $flag_count_minimum, $remove_flagged_content, $verified_filter, $linked_object_type, $linked_object_id, $order_audience_id, $ignore_default_app_filter, $search_expression, $generate_albums, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchAlbumsAsyncWithHttpInfo
     *
     * Search Albums
     *
     * @param  string $filter a comma separated list of filters: * MINE - Return albums that the user has created. * SHARED - Return albums that have been shared to the user via addAlbumUsers, or addUsersToPermissionable . * FOLLOWER - Return albums that have been created by the user&#39;s followers (the content needs to have been APPROVED or FEATURED). * FOLLOWING - Return albums that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED). * PUBLIC - Return all PUBLIC albums that have been APPROVED or FEATURED. * ALL_PUBLIC - Return all PUBLIC albums regardless of whether they are approved or not (ignores the approval status). * LIKED - Return all albums that the user has liked. * FEATURED - Return all albums that have been featured. * PENDING - Return all pending albums. (required)
     * @param  int $album_type_id id of custom albumType (required)
     * @param  string $sub_type filter albums with this album sub type (required)
     * @param  bool $include_inactive determines whether to return inactive albums (required)
     * @param  string $sort_field the field to sort by. See AlbumApiMap (required)
     * @param  bool $descending determines whether the sorted list is in descending or ascending order (required)
     * @param  int $start the start index for pagination (required)
     * @param  int $limit the limit for pagination (There is a hard limit of 100) (required)
     * @param  float $range the maximum range the album can be from the center (used when sortField&#x3D;ALBUM_DISTANCE) (required)
     * @param  bool $include_liked returns whether or not the current logged in user has liked the album (required)
     * @param  bool $include_favorited returns whether or not the current logged in user has favorited the album (required)
     * @param  bool $include_permissions returns permission details on whether they have read/write/delete permissions etc (client app probably doesn&#39;t need this) (required)
     * @param  int $like_preview_size returns the last X likes (required)
     * @param  int $asset_preview_size returns the first X assets (required)
     * @param  int $note_preview_size returns the last X notes (required)
     * @param  int $connection_preview_size returns the first X users/connections (required)
     * @param  int $audience_preview_size returns the first X audiences. To search on and paginate the remaining audiences, please use the \&quot;/audience/search\&quot; endpoint. (required)
     * @param  string|null $device_id a unique ID given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account ID of the user (deviceId or accountId required) (optional)
     * @param  int|null $connection_account_id the account ID of the user that the results will be based on. This is used to return albums that this account has liked/favorited. (optional)
     * @param  int|null $owner_id search on albums that have been created by this account (that the user has permissions to) (optional)
     * @param  string|null $album_ids search on album within a comma separated list of album IDs (this does not work with sortField&#x3D;ALBUM_DISTANCE, or when stackSearch&#x3D;true) (optional)
     * @param  string|null $exclude_album_ids Only for CLOUDINDEX mode, exclude albums with ids matching this list (optional)
     * @param  int|null $media_id search on albums that are in a particular media offering (optional)
     * @param  string|null $keyword keyword search string (optional)
     * @param  string|null $album_type filter albums with this album type (optional)
     * @param  int|null $limit_per_album_type When using multiple album types this sets a per-album-type limit (used with cloud index mode) (optional)
     * @param  int|null $date_created return items that have been created before this date (time-stamp in milliseconds) (optional)
     * @param  int|null $updated_since return items that have been updated since this date (time-stamp in milliseconds) (optional)
     * @param  int|null $updated_before return items that have been updated before this date (time-stamp in milliseconds) (optional)
     * @param  int|null $created_since return items that have been created since this date (time-stamp in milliseconds) (optional)
     * @param  int|null $created_before return items that have been created before this date (time-stamp in milliseconds) (optional)
     * @param  int|null $started_since return items that have been started since this date (time-stamp in milliseconds) (optional)
     * @param  int|null $started_before return items that have been started before this date (time-stamp in milliseconds) (optional)
     * @param  int|null $ended_since return items that have been ended since this date (time-stamp in milliseconds) (optional)
     * @param  int|null $ended_before return items that have been ended before this date (time-stamp in milliseconds) (optional)
     * @param  float|null $latitude the latitude of where the search is centered on (used when sortField&#x3D;ALBUM_DISTANCE) (optional)
     * @param  float|null $longitude the longitude of where the search is centered on (used when sortField&#x3D;ALBUM_DISTANCE) (optional)
     * @param  string|null $app_key the application key to filter results by application. This is required for consumer searches. Leaving this empty will return albums for the applications that the logged in user owns or has access to. (optional)
     * @param  string|null $category_ids return results with categories matching this list (optional)
     * @param  string|null $category_filter_ids return results with filters matching this list (optional)
     * @param  string|null $audience_ids return results with audiences matching this list (optional)
     * @param  string|null $exclude_audience_ids exclude audiences with ids matching this list (optional)
     * @param  bool|null $include_completable returns the user&#39;s completable object for the album if it exists (optional)
     * @param  bool|null $include_rating returns the user&#39;s rating for the album if it exists (optional)
     * @param  string|null $search_mode The search index mode to use (RDS, LUCENE, or CLOUDINDEX). If not provided will use server default. (optional)
     * @param  bool|null $stack_search groups similar albums together that have the same albumTypeId, within a time window defined in stackWindowSize (optional)
     * @param  int|null $stack_window_size size of each window for each stack (optional)
     * @param  int|null $min_stack_per_page The minimum number of stacks returned in a response. For example,  first call, minStackPerPage &#x3D; 20, the API will return at least 20 results (optional)
     * @param  string|null $stack_pagination_identifier this is used to tell the system where it left off on the previous previous page, since we can&#39;t use start/limit for stackSearch (optional)
     * @param  bool|null $stack_details set this to true when making the call to view the albums in the stack (optional)
     * @param  int|null $flag_count_minimum Return any results that have a minimum of the specified flag count (even ones that have met the flag threshold) (optional)
     * @param  bool|null $remove_flagged_content return items that have flagCount &gt;&#x3D; flagThreshold (controls removal of flagged content) (optional, default to true)
     * @param  bool|null $verified_filter setting to true will return only verified albums only, setting to false will return non-verified albums only (leave empty to return both) (optional)
     * @param  string|null $linked_object_type filter results by the linkedObjectType (optional)
     * @param  int|null $linked_object_id filter results by the linkedObjectId (optional)
     * @param  int|null $order_audience_id determines whether to use the order assigned via the /album/order/_* api (which is tied to an audience) (optional)
     * @param  bool|null $ignore_default_app_filter if true, ignore the application&#39;s default app filter when searching (optional)
     * @param  string|null $search_expression Advanced search expression to be used by the server (optional)
     * @param  bool|null $generate_albums If true and results are empty, attempt to generate albums via templates (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchAlbums'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchAlbumsAsyncWithHttpInfo($filter, $album_type_id, $sub_type, $include_inactive, $sort_field, $descending, $start, $limit, $range, $include_liked, $include_favorited, $include_permissions, $like_preview_size, $asset_preview_size, $note_preview_size, $connection_preview_size, $audience_preview_size, $device_id = null, $account_id = null, $connection_account_id = null, $owner_id = null, $album_ids = null, $exclude_album_ids = null, $media_id = null, $keyword = null, $album_type = null, $limit_per_album_type = null, $date_created = null, $updated_since = null, $updated_before = null, $created_since = null, $created_before = null, $started_since = null, $started_before = null, $ended_since = null, $ended_before = null, $latitude = null, $longitude = null, $app_key = null, $category_ids = null, $category_filter_ids = null, $audience_ids = null, $exclude_audience_ids = null, $include_completable = null, $include_rating = null, $search_mode = null, $stack_search = null, $stack_window_size = null, $min_stack_per_page = null, $stack_pagination_identifier = null, $stack_details = null, $flag_count_minimum = null, $remove_flagged_content = true, $verified_filter = null, $linked_object_type = null, $linked_object_id = null, $order_audience_id = null, $ignore_default_app_filter = null, $search_expression = null, $generate_albums = null, string $contentType = self::contentTypes['searchAlbums'][0])
    {
        $returnType = '\OpenAPI\Client\Model\AlbumFullResponse[]';
        $request = $this->searchAlbumsRequest($filter, $album_type_id, $sub_type, $include_inactive, $sort_field, $descending, $start, $limit, $range, $include_liked, $include_favorited, $include_permissions, $like_preview_size, $asset_preview_size, $note_preview_size, $connection_preview_size, $audience_preview_size, $device_id, $account_id, $connection_account_id, $owner_id, $album_ids, $exclude_album_ids, $media_id, $keyword, $album_type, $limit_per_album_type, $date_created, $updated_since, $updated_before, $created_since, $created_before, $started_since, $started_before, $ended_since, $ended_before, $latitude, $longitude, $app_key, $category_ids, $category_filter_ids, $audience_ids, $exclude_audience_ids, $include_completable, $include_rating, $search_mode, $stack_search, $stack_window_size, $min_stack_per_page, $stack_pagination_identifier, $stack_details, $flag_count_minimum, $remove_flagged_content, $verified_filter, $linked_object_type, $linked_object_id, $order_audience_id, $ignore_default_app_filter, $search_expression, $generate_albums, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchAlbums'
     *
     * @param  string $filter a comma separated list of filters: * MINE - Return albums that the user has created. * SHARED - Return albums that have been shared to the user via addAlbumUsers, or addUsersToPermissionable . * FOLLOWER - Return albums that have been created by the user&#39;s followers (the content needs to have been APPROVED or FEATURED). * FOLLOWING - Return albums that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED). * PUBLIC - Return all PUBLIC albums that have been APPROVED or FEATURED. * ALL_PUBLIC - Return all PUBLIC albums regardless of whether they are approved or not (ignores the approval status). * LIKED - Return all albums that the user has liked. * FEATURED - Return all albums that have been featured. * PENDING - Return all pending albums. (required)
     * @param  int $album_type_id id of custom albumType (required)
     * @param  string $sub_type filter albums with this album sub type (required)
     * @param  bool $include_inactive determines whether to return inactive albums (required)
     * @param  string $sort_field the field to sort by. See AlbumApiMap (required)
     * @param  bool $descending determines whether the sorted list is in descending or ascending order (required)
     * @param  int $start the start index for pagination (required)
     * @param  int $limit the limit for pagination (There is a hard limit of 100) (required)
     * @param  float $range the maximum range the album can be from the center (used when sortField&#x3D;ALBUM_DISTANCE) (required)
     * @param  bool $include_liked returns whether or not the current logged in user has liked the album (required)
     * @param  bool $include_favorited returns whether or not the current logged in user has favorited the album (required)
     * @param  bool $include_permissions returns permission details on whether they have read/write/delete permissions etc (client app probably doesn&#39;t need this) (required)
     * @param  int $like_preview_size returns the last X likes (required)
     * @param  int $asset_preview_size returns the first X assets (required)
     * @param  int $note_preview_size returns the last X notes (required)
     * @param  int $connection_preview_size returns the first X users/connections (required)
     * @param  int $audience_preview_size returns the first X audiences. To search on and paginate the remaining audiences, please use the \&quot;/audience/search\&quot; endpoint. (required)
     * @param  string|null $device_id a unique ID given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account ID of the user (deviceId or accountId required) (optional)
     * @param  int|null $connection_account_id the account ID of the user that the results will be based on. This is used to return albums that this account has liked/favorited. (optional)
     * @param  int|null $owner_id search on albums that have been created by this account (that the user has permissions to) (optional)
     * @param  string|null $album_ids search on album within a comma separated list of album IDs (this does not work with sortField&#x3D;ALBUM_DISTANCE, or when stackSearch&#x3D;true) (optional)
     * @param  string|null $exclude_album_ids Only for CLOUDINDEX mode, exclude albums with ids matching this list (optional)
     * @param  int|null $media_id search on albums that are in a particular media offering (optional)
     * @param  string|null $keyword keyword search string (optional)
     * @param  string|null $album_type filter albums with this album type (optional)
     * @param  int|null $limit_per_album_type When using multiple album types this sets a per-album-type limit (used with cloud index mode) (optional)
     * @param  int|null $date_created return items that have been created before this date (time-stamp in milliseconds) (optional)
     * @param  int|null $updated_since return items that have been updated since this date (time-stamp in milliseconds) (optional)
     * @param  int|null $updated_before return items that have been updated before this date (time-stamp in milliseconds) (optional)
     * @param  int|null $created_since return items that have been created since this date (time-stamp in milliseconds) (optional)
     * @param  int|null $created_before return items that have been created before this date (time-stamp in milliseconds) (optional)
     * @param  int|null $started_since return items that have been started since this date (time-stamp in milliseconds) (optional)
     * @param  int|null $started_before return items that have been started before this date (time-stamp in milliseconds) (optional)
     * @param  int|null $ended_since return items that have been ended since this date (time-stamp in milliseconds) (optional)
     * @param  int|null $ended_before return items that have been ended before this date (time-stamp in milliseconds) (optional)
     * @param  float|null $latitude the latitude of where the search is centered on (used when sortField&#x3D;ALBUM_DISTANCE) (optional)
     * @param  float|null $longitude the longitude of where the search is centered on (used when sortField&#x3D;ALBUM_DISTANCE) (optional)
     * @param  string|null $app_key the application key to filter results by application. This is required for consumer searches. Leaving this empty will return albums for the applications that the logged in user owns or has access to. (optional)
     * @param  string|null $category_ids return results with categories matching this list (optional)
     * @param  string|null $category_filter_ids return results with filters matching this list (optional)
     * @param  string|null $audience_ids return results with audiences matching this list (optional)
     * @param  string|null $exclude_audience_ids exclude audiences with ids matching this list (optional)
     * @param  bool|null $include_completable returns the user&#39;s completable object for the album if it exists (optional)
     * @param  bool|null $include_rating returns the user&#39;s rating for the album if it exists (optional)
     * @param  string|null $search_mode The search index mode to use (RDS, LUCENE, or CLOUDINDEX). If not provided will use server default. (optional)
     * @param  bool|null $stack_search groups similar albums together that have the same albumTypeId, within a time window defined in stackWindowSize (optional)
     * @param  int|null $stack_window_size size of each window for each stack (optional)
     * @param  int|null $min_stack_per_page The minimum number of stacks returned in a response. For example,  first call, minStackPerPage &#x3D; 20, the API will return at least 20 results (optional)
     * @param  string|null $stack_pagination_identifier this is used to tell the system where it left off on the previous previous page, since we can&#39;t use start/limit for stackSearch (optional)
     * @param  bool|null $stack_details set this to true when making the call to view the albums in the stack (optional)
     * @param  int|null $flag_count_minimum Return any results that have a minimum of the specified flag count (even ones that have met the flag threshold) (optional)
     * @param  bool|null $remove_flagged_content return items that have flagCount &gt;&#x3D; flagThreshold (controls removal of flagged content) (optional, default to true)
     * @param  bool|null $verified_filter setting to true will return only verified albums only, setting to false will return non-verified albums only (leave empty to return both) (optional)
     * @param  string|null $linked_object_type filter results by the linkedObjectType (optional)
     * @param  int|null $linked_object_id filter results by the linkedObjectId (optional)
     * @param  int|null $order_audience_id determines whether to use the order assigned via the /album/order/_* api (which is tied to an audience) (optional)
     * @param  bool|null $ignore_default_app_filter if true, ignore the application&#39;s default app filter when searching (optional)
     * @param  string|null $search_expression Advanced search expression to be used by the server (optional)
     * @param  bool|null $generate_albums If true and results are empty, attempt to generate albums via templates (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchAlbums'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function searchAlbumsRequest($filter, $album_type_id, $sub_type, $include_inactive, $sort_field, $descending, $start, $limit, $range, $include_liked, $include_favorited, $include_permissions, $like_preview_size, $asset_preview_size, $note_preview_size, $connection_preview_size, $audience_preview_size, $device_id = null, $account_id = null, $connection_account_id = null, $owner_id = null, $album_ids = null, $exclude_album_ids = null, $media_id = null, $keyword = null, $album_type = null, $limit_per_album_type = null, $date_created = null, $updated_since = null, $updated_before = null, $created_since = null, $created_before = null, $started_since = null, $started_before = null, $ended_since = null, $ended_before = null, $latitude = null, $longitude = null, $app_key = null, $category_ids = null, $category_filter_ids = null, $audience_ids = null, $exclude_audience_ids = null, $include_completable = null, $include_rating = null, $search_mode = null, $stack_search = null, $stack_window_size = null, $min_stack_per_page = null, $stack_pagination_identifier = null, $stack_details = null, $flag_count_minimum = null, $remove_flagged_content = true, $verified_filter = null, $linked_object_type = null, $linked_object_id = null, $order_audience_id = null, $ignore_default_app_filter = null, $search_expression = null, $generate_albums = null, string $contentType = self::contentTypes['searchAlbums'][0])
    {

        // verify the required parameter 'filter' is set
        if ($filter === null || (is_array($filter) && count($filter) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $filter when calling searchAlbums'
            );
        }

        // verify the required parameter 'album_type_id' is set
        if ($album_type_id === null || (is_array($album_type_id) && count($album_type_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $album_type_id when calling searchAlbums'
            );
        }

        // verify the required parameter 'sub_type' is set
        if ($sub_type === null || (is_array($sub_type) && count($sub_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sub_type when calling searchAlbums'
            );
        }

        // verify the required parameter 'include_inactive' is set
        if ($include_inactive === null || (is_array($include_inactive) && count($include_inactive) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $include_inactive when calling searchAlbums'
            );
        }

        // verify the required parameter 'sort_field' is set
        if ($sort_field === null || (is_array($sort_field) && count($sort_field) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sort_field when calling searchAlbums'
            );
        }

        // verify the required parameter 'descending' is set
        if ($descending === null || (is_array($descending) && count($descending) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $descending when calling searchAlbums'
            );
        }

        // verify the required parameter 'start' is set
        if ($start === null || (is_array($start) && count($start) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $start when calling searchAlbums'
            );
        }

        // verify the required parameter 'limit' is set
        if ($limit === null || (is_array($limit) && count($limit) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $limit when calling searchAlbums'
            );
        }

        // verify the required parameter 'range' is set
        if ($range === null || (is_array($range) && count($range) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $range when calling searchAlbums'
            );
        }

        // verify the required parameter 'include_liked' is set
        if ($include_liked === null || (is_array($include_liked) && count($include_liked) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $include_liked when calling searchAlbums'
            );
        }

        // verify the required parameter 'include_favorited' is set
        if ($include_favorited === null || (is_array($include_favorited) && count($include_favorited) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $include_favorited when calling searchAlbums'
            );
        }

        // verify the required parameter 'include_permissions' is set
        if ($include_permissions === null || (is_array($include_permissions) && count($include_permissions) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $include_permissions when calling searchAlbums'
            );
        }

        // verify the required parameter 'like_preview_size' is set
        if ($like_preview_size === null || (is_array($like_preview_size) && count($like_preview_size) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $like_preview_size when calling searchAlbums'
            );
        }

        // verify the required parameter 'asset_preview_size' is set
        if ($asset_preview_size === null || (is_array($asset_preview_size) && count($asset_preview_size) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $asset_preview_size when calling searchAlbums'
            );
        }

        // verify the required parameter 'note_preview_size' is set
        if ($note_preview_size === null || (is_array($note_preview_size) && count($note_preview_size) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $note_preview_size when calling searchAlbums'
            );
        }

        // verify the required parameter 'connection_preview_size' is set
        if ($connection_preview_size === null || (is_array($connection_preview_size) && count($connection_preview_size) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $connection_preview_size when calling searchAlbums'
            );
        }

        // verify the required parameter 'audience_preview_size' is set
        if ($audience_preview_size === null || (is_array($audience_preview_size) && count($audience_preview_size) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $audience_preview_size when calling searchAlbums'
            );
        }













































        $resourcePath = '/album/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_id,
            'deviceId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $connection_account_id,
            'connectionAccountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $owner_id,
            'ownerId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $album_ids,
            'albumIds', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $exclude_album_ids,
            'excludeAlbumIds', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $media_id,
            'mediaId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $keyword,
            'keyword', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $filter,
            'filter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $album_type,
            'albumType', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $album_type_id,
            'albumTypeId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sub_type,
            'subType', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_inactive,
            'includeInactive', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort_field,
            'sortField', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $descending,
            'descending', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start,
            'start', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit_per_album_type,
            'limitPerAlbumType', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $date_created,
            'dateCreated', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_since,
            'updatedSince', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_before,
            'updatedBefore', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_since,
            'createdSince', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_before,
            'createdBefore', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $started_since,
            'startedSince', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $started_before,
            'startedBefore', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ended_since,
            'endedSince', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ended_before,
            'endedBefore', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $latitude,
            'latitude', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $longitude,
            'longitude', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $range,
            'range', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $app_key,
            'appKey', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $category_ids,
            'categoryIds', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $category_filter_ids,
            'categoryFilterIds', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audience_ids,
            'audienceIds', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $exclude_audience_ids,
            'excludeAudienceIds', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_liked,
            'includeLiked', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_favorited,
            'includeFavorited', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_permissions,
            'includePermissions', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_completable,
            'includeCompletable', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_rating,
            'includeRating', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $like_preview_size,
            'likePreviewSize', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $asset_preview_size,
            'assetPreviewSize', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $note_preview_size,
            'notePreviewSize', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $connection_preview_size,
            'connectionPreviewSize', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audience_preview_size,
            'audiencePreviewSize', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $search_mode,
            'searchMode', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $stack_search,
            'stackSearch', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $stack_window_size,
            'stackWindowSize', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_stack_per_page,
            'minStackPerPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $stack_pagination_identifier,
            'stackPaginationIdentifier', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $stack_details,
            'stackDetails', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $flag_count_minimum,
            'flagCountMinimum', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $remove_flagged_content,
            'removeFlaggedContent', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $verified_filter,
            'verifiedFilter', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $linked_object_type,
            'linkedObjectType', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $linked_object_id,
            'linkedObjectId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $order_audience_id,
            'orderAudienceId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ignore_default_app_filter,
            'ignoreDefaultAppFilter', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $search_expression,
            'searchExpression', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $generate_albums,
            'generateAlbums', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateAlbumCollection
     *
     * Update Album
     *
     * @param  int $album_id the ID of the album to update (required)
     * @param  string|null $device_id a unique ID given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account ID of the user (deviceId or accountId required) (optional)
     * @param  string|null $assets_to_add Comma separated list of asset IDs to add to the album&#39;s asset list (use \&quot;assetId\&quot; for setting the cover of the album) (optional)
     * @param  string|null $assets_to_remove Comma separated list of asset IDs to remove from the album&#39;s asset list (optional)
     * @param  int|null $asset_id the cover asset ID (optional)
     * @param  \SplFileObject|null $media a MultipartFile containing the cover image of the album (this will only be used if \&quot;assetId\&quot; is empty) (optional)
     * @param  string|null $media_url this can be used if the \&quot;media\&quot; is a link (this will only be used if \&quot;assetId\&quot; and media are empty) (optional)
     * @param  bool|null $active determines whether the album is active or inactive (optional)
     * @param  string|null $title the title of the album (optional)
     * @param  int|null $start_date the start date (optional)
     * @param  int|null $end_date the end date (optional)
     * @param  string|null $tags the tags (optional)
     * @param  string|null $description the description of the album (optional)
     * @param  string|null $album_type a custom field used for aggregation and searching (optional)
     * @param  int|null $album_type_id a custom indexed number used for aggregation and searching (optional)
     * @param  string|null $sub_type a custom string field used for aggregation and searching (optional)
     * @param  bool|null $public_read determines whether the album&#39;s participants have read permissions (optional)
     * @param  bool|null $public_write determines whether the album&#39;s participants have write permissions (optional)
     * @param  bool|null $public_delete determines whether the album&#39;s participants have delete permissions (optional)
     * @param  bool|null $public_add determines whether the album&#39;s participants have add permissions (optional)
     * @param  float|null $latitude latitude used to update the album&#39;s location (optional)
     * @param  float|null $longitude longitude used to update the album&#39;s location (optional)
     * @param  string|null $location_description the location description (optional)
     * @param  string|null $visibility the determines the album&#39;s participants (PUBLIC - includes everyone in the system as a potential participant, PRIVATE - only considers people who have been invited as participants) (optional)
     * @param  string|null $cell_phone the cell phone number (optional)
     * @param  string|null $street_address The street address of the location (optional)
     * @param  string|null $street_address2 Additional address information (such as a suite number, floor number, building name, or PO Box) (optional)
     * @param  string|null $city The city of the location (optional)
     * @param  string|null $state The state of of the location (optional)
     * @param  string|null $postal_code The postal code of the location (optional)
     * @param  string|null $full_address The full address of the location which should include the street address, city, state, and postal code (optional)
     * @param  bool|null $anonymous determines whether the album is posted anonymously (optional)
     * @param  string|null $meta_data External custom client defined data (optional)
     * @param  string|null $category_ids comma separated category ids string associated with the Album (optional)
     * @param  string|null $category_filter_ids comma separated filter ids string associated with the Album (optional)
     * @param  string|null $audience_ids comma separated audience ids string associated with the album (optional)
     * @param  string|null $audience_ids_to_add comma separated audience ids to add to the album (optional)
     * @param  string|null $audience_ids_to_remove comma separated audience ids to remove from the album (overrides audienceIds and audienceIdsToAdd) (optional)
     * @param  bool|null $include_all_app_users_as_members determines whether to include all app users as members (only admins of the app can do this) (optional)
     * @param  bool|null $include_audiences_as_members determines whether to include all users of the audiences as members (only admins of the app can do this) (optional)
     * @param  string|null $audience_operator determines whether to use ands or ors when using the audience list to add users (optional)
     * @param  string|null $linked_object_type sets a linked object so that it can be returned as part of the album response (optional)
     * @param  int|null $linked_object_id sets a linked object id so that it can be returned as part of the album response (optional)
     * @param  bool|null $index_now determines whether the album should be indexed immediately (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAlbumCollection'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AlbumResponse
     */
    public function updateAlbumCollection($album_id, $device_id = null, $account_id = null, $assets_to_add = null, $assets_to_remove = null, $asset_id = null, $media = null, $media_url = null, $active = null, $title = null, $start_date = null, $end_date = null, $tags = null, $description = null, $album_type = null, $album_type_id = null, $sub_type = null, $public_read = null, $public_write = null, $public_delete = null, $public_add = null, $latitude = null, $longitude = null, $location_description = null, $visibility = null, $cell_phone = null, $street_address = null, $street_address2 = null, $city = null, $state = null, $postal_code = null, $full_address = null, $anonymous = null, $meta_data = null, $category_ids = null, $category_filter_ids = null, $audience_ids = null, $audience_ids_to_add = null, $audience_ids_to_remove = null, $include_all_app_users_as_members = null, $include_audiences_as_members = null, $audience_operator = null, $linked_object_type = null, $linked_object_id = null, $index_now = null, string $contentType = self::contentTypes['updateAlbumCollection'][0])
    {
        list($response) = $this->updateAlbumCollectionWithHttpInfo($album_id, $device_id, $account_id, $assets_to_add, $assets_to_remove, $asset_id, $media, $media_url, $active, $title, $start_date, $end_date, $tags, $description, $album_type, $album_type_id, $sub_type, $public_read, $public_write, $public_delete, $public_add, $latitude, $longitude, $location_description, $visibility, $cell_phone, $street_address, $street_address2, $city, $state, $postal_code, $full_address, $anonymous, $meta_data, $category_ids, $category_filter_ids, $audience_ids, $audience_ids_to_add, $audience_ids_to_remove, $include_all_app_users_as_members, $include_audiences_as_members, $audience_operator, $linked_object_type, $linked_object_id, $index_now, $contentType);
        return $response;
    }

    /**
     * Operation updateAlbumCollectionWithHttpInfo
     *
     * Update Album
     *
     * @param  int $album_id the ID of the album to update (required)
     * @param  string|null $device_id a unique ID given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account ID of the user (deviceId or accountId required) (optional)
     * @param  string|null $assets_to_add Comma separated list of asset IDs to add to the album&#39;s asset list (use \&quot;assetId\&quot; for setting the cover of the album) (optional)
     * @param  string|null $assets_to_remove Comma separated list of asset IDs to remove from the album&#39;s asset list (optional)
     * @param  int|null $asset_id the cover asset ID (optional)
     * @param  \SplFileObject|null $media a MultipartFile containing the cover image of the album (this will only be used if \&quot;assetId\&quot; is empty) (optional)
     * @param  string|null $media_url this can be used if the \&quot;media\&quot; is a link (this will only be used if \&quot;assetId\&quot; and media are empty) (optional)
     * @param  bool|null $active determines whether the album is active or inactive (optional)
     * @param  string|null $title the title of the album (optional)
     * @param  int|null $start_date the start date (optional)
     * @param  int|null $end_date the end date (optional)
     * @param  string|null $tags the tags (optional)
     * @param  string|null $description the description of the album (optional)
     * @param  string|null $album_type a custom field used for aggregation and searching (optional)
     * @param  int|null $album_type_id a custom indexed number used for aggregation and searching (optional)
     * @param  string|null $sub_type a custom string field used for aggregation and searching (optional)
     * @param  bool|null $public_read determines whether the album&#39;s participants have read permissions (optional)
     * @param  bool|null $public_write determines whether the album&#39;s participants have write permissions (optional)
     * @param  bool|null $public_delete determines whether the album&#39;s participants have delete permissions (optional)
     * @param  bool|null $public_add determines whether the album&#39;s participants have add permissions (optional)
     * @param  float|null $latitude latitude used to update the album&#39;s location (optional)
     * @param  float|null $longitude longitude used to update the album&#39;s location (optional)
     * @param  string|null $location_description the location description (optional)
     * @param  string|null $visibility the determines the album&#39;s participants (PUBLIC - includes everyone in the system as a potential participant, PRIVATE - only considers people who have been invited as participants) (optional)
     * @param  string|null $cell_phone the cell phone number (optional)
     * @param  string|null $street_address The street address of the location (optional)
     * @param  string|null $street_address2 Additional address information (such as a suite number, floor number, building name, or PO Box) (optional)
     * @param  string|null $city The city of the location (optional)
     * @param  string|null $state The state of of the location (optional)
     * @param  string|null $postal_code The postal code of the location (optional)
     * @param  string|null $full_address The full address of the location which should include the street address, city, state, and postal code (optional)
     * @param  bool|null $anonymous determines whether the album is posted anonymously (optional)
     * @param  string|null $meta_data External custom client defined data (optional)
     * @param  string|null $category_ids comma separated category ids string associated with the Album (optional)
     * @param  string|null $category_filter_ids comma separated filter ids string associated with the Album (optional)
     * @param  string|null $audience_ids comma separated audience ids string associated with the album (optional)
     * @param  string|null $audience_ids_to_add comma separated audience ids to add to the album (optional)
     * @param  string|null $audience_ids_to_remove comma separated audience ids to remove from the album (overrides audienceIds and audienceIdsToAdd) (optional)
     * @param  bool|null $include_all_app_users_as_members determines whether to include all app users as members (only admins of the app can do this) (optional)
     * @param  bool|null $include_audiences_as_members determines whether to include all users of the audiences as members (only admins of the app can do this) (optional)
     * @param  string|null $audience_operator determines whether to use ands or ors when using the audience list to add users (optional)
     * @param  string|null $linked_object_type sets a linked object so that it can be returned as part of the album response (optional)
     * @param  int|null $linked_object_id sets a linked object id so that it can be returned as part of the album response (optional)
     * @param  bool|null $index_now determines whether the album should be indexed immediately (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAlbumCollection'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AlbumResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateAlbumCollectionWithHttpInfo($album_id, $device_id = null, $account_id = null, $assets_to_add = null, $assets_to_remove = null, $asset_id = null, $media = null, $media_url = null, $active = null, $title = null, $start_date = null, $end_date = null, $tags = null, $description = null, $album_type = null, $album_type_id = null, $sub_type = null, $public_read = null, $public_write = null, $public_delete = null, $public_add = null, $latitude = null, $longitude = null, $location_description = null, $visibility = null, $cell_phone = null, $street_address = null, $street_address2 = null, $city = null, $state = null, $postal_code = null, $full_address = null, $anonymous = null, $meta_data = null, $category_ids = null, $category_filter_ids = null, $audience_ids = null, $audience_ids_to_add = null, $audience_ids_to_remove = null, $include_all_app_users_as_members = null, $include_audiences_as_members = null, $audience_operator = null, $linked_object_type = null, $linked_object_id = null, $index_now = null, string $contentType = self::contentTypes['updateAlbumCollection'][0])
    {
        $request = $this->updateAlbumCollectionRequest($album_id, $device_id, $account_id, $assets_to_add, $assets_to_remove, $asset_id, $media, $media_url, $active, $title, $start_date, $end_date, $tags, $description, $album_type, $album_type_id, $sub_type, $public_read, $public_write, $public_delete, $public_add, $latitude, $longitude, $location_description, $visibility, $cell_phone, $street_address, $street_address2, $city, $state, $postal_code, $full_address, $anonymous, $meta_data, $category_ids, $category_filter_ids, $audience_ids, $audience_ids_to_add, $audience_ids_to_remove, $include_all_app_users_as_members, $include_audiences_as_members, $audience_operator, $linked_object_type, $linked_object_id, $index_now, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\AlbumResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\AlbumResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AlbumResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateAlbumCollectionAsync
     *
     * Update Album
     *
     * @param  int $album_id the ID of the album to update (required)
     * @param  string|null $device_id a unique ID given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account ID of the user (deviceId or accountId required) (optional)
     * @param  string|null $assets_to_add Comma separated list of asset IDs to add to the album&#39;s asset list (use \&quot;assetId\&quot; for setting the cover of the album) (optional)
     * @param  string|null $assets_to_remove Comma separated list of asset IDs to remove from the album&#39;s asset list (optional)
     * @param  int|null $asset_id the cover asset ID (optional)
     * @param  \SplFileObject|null $media a MultipartFile containing the cover image of the album (this will only be used if \&quot;assetId\&quot; is empty) (optional)
     * @param  string|null $media_url this can be used if the \&quot;media\&quot; is a link (this will only be used if \&quot;assetId\&quot; and media are empty) (optional)
     * @param  bool|null $active determines whether the album is active or inactive (optional)
     * @param  string|null $title the title of the album (optional)
     * @param  int|null $start_date the start date (optional)
     * @param  int|null $end_date the end date (optional)
     * @param  string|null $tags the tags (optional)
     * @param  string|null $description the description of the album (optional)
     * @param  string|null $album_type a custom field used for aggregation and searching (optional)
     * @param  int|null $album_type_id a custom indexed number used for aggregation and searching (optional)
     * @param  string|null $sub_type a custom string field used for aggregation and searching (optional)
     * @param  bool|null $public_read determines whether the album&#39;s participants have read permissions (optional)
     * @param  bool|null $public_write determines whether the album&#39;s participants have write permissions (optional)
     * @param  bool|null $public_delete determines whether the album&#39;s participants have delete permissions (optional)
     * @param  bool|null $public_add determines whether the album&#39;s participants have add permissions (optional)
     * @param  float|null $latitude latitude used to update the album&#39;s location (optional)
     * @param  float|null $longitude longitude used to update the album&#39;s location (optional)
     * @param  string|null $location_description the location description (optional)
     * @param  string|null $visibility the determines the album&#39;s participants (PUBLIC - includes everyone in the system as a potential participant, PRIVATE - only considers people who have been invited as participants) (optional)
     * @param  string|null $cell_phone the cell phone number (optional)
     * @param  string|null $street_address The street address of the location (optional)
     * @param  string|null $street_address2 Additional address information (such as a suite number, floor number, building name, or PO Box) (optional)
     * @param  string|null $city The city of the location (optional)
     * @param  string|null $state The state of of the location (optional)
     * @param  string|null $postal_code The postal code of the location (optional)
     * @param  string|null $full_address The full address of the location which should include the street address, city, state, and postal code (optional)
     * @param  bool|null $anonymous determines whether the album is posted anonymously (optional)
     * @param  string|null $meta_data External custom client defined data (optional)
     * @param  string|null $category_ids comma separated category ids string associated with the Album (optional)
     * @param  string|null $category_filter_ids comma separated filter ids string associated with the Album (optional)
     * @param  string|null $audience_ids comma separated audience ids string associated with the album (optional)
     * @param  string|null $audience_ids_to_add comma separated audience ids to add to the album (optional)
     * @param  string|null $audience_ids_to_remove comma separated audience ids to remove from the album (overrides audienceIds and audienceIdsToAdd) (optional)
     * @param  bool|null $include_all_app_users_as_members determines whether to include all app users as members (only admins of the app can do this) (optional)
     * @param  bool|null $include_audiences_as_members determines whether to include all users of the audiences as members (only admins of the app can do this) (optional)
     * @param  string|null $audience_operator determines whether to use ands or ors when using the audience list to add users (optional)
     * @param  string|null $linked_object_type sets a linked object so that it can be returned as part of the album response (optional)
     * @param  int|null $linked_object_id sets a linked object id so that it can be returned as part of the album response (optional)
     * @param  bool|null $index_now determines whether the album should be indexed immediately (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAlbumCollection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAlbumCollectionAsync($album_id, $device_id = null, $account_id = null, $assets_to_add = null, $assets_to_remove = null, $asset_id = null, $media = null, $media_url = null, $active = null, $title = null, $start_date = null, $end_date = null, $tags = null, $description = null, $album_type = null, $album_type_id = null, $sub_type = null, $public_read = null, $public_write = null, $public_delete = null, $public_add = null, $latitude = null, $longitude = null, $location_description = null, $visibility = null, $cell_phone = null, $street_address = null, $street_address2 = null, $city = null, $state = null, $postal_code = null, $full_address = null, $anonymous = null, $meta_data = null, $category_ids = null, $category_filter_ids = null, $audience_ids = null, $audience_ids_to_add = null, $audience_ids_to_remove = null, $include_all_app_users_as_members = null, $include_audiences_as_members = null, $audience_operator = null, $linked_object_type = null, $linked_object_id = null, $index_now = null, string $contentType = self::contentTypes['updateAlbumCollection'][0])
    {
        return $this->updateAlbumCollectionAsyncWithHttpInfo($album_id, $device_id, $account_id, $assets_to_add, $assets_to_remove, $asset_id, $media, $media_url, $active, $title, $start_date, $end_date, $tags, $description, $album_type, $album_type_id, $sub_type, $public_read, $public_write, $public_delete, $public_add, $latitude, $longitude, $location_description, $visibility, $cell_phone, $street_address, $street_address2, $city, $state, $postal_code, $full_address, $anonymous, $meta_data, $category_ids, $category_filter_ids, $audience_ids, $audience_ids_to_add, $audience_ids_to_remove, $include_all_app_users_as_members, $include_audiences_as_members, $audience_operator, $linked_object_type, $linked_object_id, $index_now, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateAlbumCollectionAsyncWithHttpInfo
     *
     * Update Album
     *
     * @param  int $album_id the ID of the album to update (required)
     * @param  string|null $device_id a unique ID given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account ID of the user (deviceId or accountId required) (optional)
     * @param  string|null $assets_to_add Comma separated list of asset IDs to add to the album&#39;s asset list (use \&quot;assetId\&quot; for setting the cover of the album) (optional)
     * @param  string|null $assets_to_remove Comma separated list of asset IDs to remove from the album&#39;s asset list (optional)
     * @param  int|null $asset_id the cover asset ID (optional)
     * @param  \SplFileObject|null $media a MultipartFile containing the cover image of the album (this will only be used if \&quot;assetId\&quot; is empty) (optional)
     * @param  string|null $media_url this can be used if the \&quot;media\&quot; is a link (this will only be used if \&quot;assetId\&quot; and media are empty) (optional)
     * @param  bool|null $active determines whether the album is active or inactive (optional)
     * @param  string|null $title the title of the album (optional)
     * @param  int|null $start_date the start date (optional)
     * @param  int|null $end_date the end date (optional)
     * @param  string|null $tags the tags (optional)
     * @param  string|null $description the description of the album (optional)
     * @param  string|null $album_type a custom field used for aggregation and searching (optional)
     * @param  int|null $album_type_id a custom indexed number used for aggregation and searching (optional)
     * @param  string|null $sub_type a custom string field used for aggregation and searching (optional)
     * @param  bool|null $public_read determines whether the album&#39;s participants have read permissions (optional)
     * @param  bool|null $public_write determines whether the album&#39;s participants have write permissions (optional)
     * @param  bool|null $public_delete determines whether the album&#39;s participants have delete permissions (optional)
     * @param  bool|null $public_add determines whether the album&#39;s participants have add permissions (optional)
     * @param  float|null $latitude latitude used to update the album&#39;s location (optional)
     * @param  float|null $longitude longitude used to update the album&#39;s location (optional)
     * @param  string|null $location_description the location description (optional)
     * @param  string|null $visibility the determines the album&#39;s participants (PUBLIC - includes everyone in the system as a potential participant, PRIVATE - only considers people who have been invited as participants) (optional)
     * @param  string|null $cell_phone the cell phone number (optional)
     * @param  string|null $street_address The street address of the location (optional)
     * @param  string|null $street_address2 Additional address information (such as a suite number, floor number, building name, or PO Box) (optional)
     * @param  string|null $city The city of the location (optional)
     * @param  string|null $state The state of of the location (optional)
     * @param  string|null $postal_code The postal code of the location (optional)
     * @param  string|null $full_address The full address of the location which should include the street address, city, state, and postal code (optional)
     * @param  bool|null $anonymous determines whether the album is posted anonymously (optional)
     * @param  string|null $meta_data External custom client defined data (optional)
     * @param  string|null $category_ids comma separated category ids string associated with the Album (optional)
     * @param  string|null $category_filter_ids comma separated filter ids string associated with the Album (optional)
     * @param  string|null $audience_ids comma separated audience ids string associated with the album (optional)
     * @param  string|null $audience_ids_to_add comma separated audience ids to add to the album (optional)
     * @param  string|null $audience_ids_to_remove comma separated audience ids to remove from the album (overrides audienceIds and audienceIdsToAdd) (optional)
     * @param  bool|null $include_all_app_users_as_members determines whether to include all app users as members (only admins of the app can do this) (optional)
     * @param  bool|null $include_audiences_as_members determines whether to include all users of the audiences as members (only admins of the app can do this) (optional)
     * @param  string|null $audience_operator determines whether to use ands or ors when using the audience list to add users (optional)
     * @param  string|null $linked_object_type sets a linked object so that it can be returned as part of the album response (optional)
     * @param  int|null $linked_object_id sets a linked object id so that it can be returned as part of the album response (optional)
     * @param  bool|null $index_now determines whether the album should be indexed immediately (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAlbumCollection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAlbumCollectionAsyncWithHttpInfo($album_id, $device_id = null, $account_id = null, $assets_to_add = null, $assets_to_remove = null, $asset_id = null, $media = null, $media_url = null, $active = null, $title = null, $start_date = null, $end_date = null, $tags = null, $description = null, $album_type = null, $album_type_id = null, $sub_type = null, $public_read = null, $public_write = null, $public_delete = null, $public_add = null, $latitude = null, $longitude = null, $location_description = null, $visibility = null, $cell_phone = null, $street_address = null, $street_address2 = null, $city = null, $state = null, $postal_code = null, $full_address = null, $anonymous = null, $meta_data = null, $category_ids = null, $category_filter_ids = null, $audience_ids = null, $audience_ids_to_add = null, $audience_ids_to_remove = null, $include_all_app_users_as_members = null, $include_audiences_as_members = null, $audience_operator = null, $linked_object_type = null, $linked_object_id = null, $index_now = null, string $contentType = self::contentTypes['updateAlbumCollection'][0])
    {
        $returnType = '\OpenAPI\Client\Model\AlbumResponse';
        $request = $this->updateAlbumCollectionRequest($album_id, $device_id, $account_id, $assets_to_add, $assets_to_remove, $asset_id, $media, $media_url, $active, $title, $start_date, $end_date, $tags, $description, $album_type, $album_type_id, $sub_type, $public_read, $public_write, $public_delete, $public_add, $latitude, $longitude, $location_description, $visibility, $cell_phone, $street_address, $street_address2, $city, $state, $postal_code, $full_address, $anonymous, $meta_data, $category_ids, $category_filter_ids, $audience_ids, $audience_ids_to_add, $audience_ids_to_remove, $include_all_app_users_as_members, $include_audiences_as_members, $audience_operator, $linked_object_type, $linked_object_id, $index_now, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateAlbumCollection'
     *
     * @param  int $album_id the ID of the album to update (required)
     * @param  string|null $device_id a unique ID given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account ID of the user (deviceId or accountId required) (optional)
     * @param  string|null $assets_to_add Comma separated list of asset IDs to add to the album&#39;s asset list (use \&quot;assetId\&quot; for setting the cover of the album) (optional)
     * @param  string|null $assets_to_remove Comma separated list of asset IDs to remove from the album&#39;s asset list (optional)
     * @param  int|null $asset_id the cover asset ID (optional)
     * @param  \SplFileObject|null $media a MultipartFile containing the cover image of the album (this will only be used if \&quot;assetId\&quot; is empty) (optional)
     * @param  string|null $media_url this can be used if the \&quot;media\&quot; is a link (this will only be used if \&quot;assetId\&quot; and media are empty) (optional)
     * @param  bool|null $active determines whether the album is active or inactive (optional)
     * @param  string|null $title the title of the album (optional)
     * @param  int|null $start_date the start date (optional)
     * @param  int|null $end_date the end date (optional)
     * @param  string|null $tags the tags (optional)
     * @param  string|null $description the description of the album (optional)
     * @param  string|null $album_type a custom field used for aggregation and searching (optional)
     * @param  int|null $album_type_id a custom indexed number used for aggregation and searching (optional)
     * @param  string|null $sub_type a custom string field used for aggregation and searching (optional)
     * @param  bool|null $public_read determines whether the album&#39;s participants have read permissions (optional)
     * @param  bool|null $public_write determines whether the album&#39;s participants have write permissions (optional)
     * @param  bool|null $public_delete determines whether the album&#39;s participants have delete permissions (optional)
     * @param  bool|null $public_add determines whether the album&#39;s participants have add permissions (optional)
     * @param  float|null $latitude latitude used to update the album&#39;s location (optional)
     * @param  float|null $longitude longitude used to update the album&#39;s location (optional)
     * @param  string|null $location_description the location description (optional)
     * @param  string|null $visibility the determines the album&#39;s participants (PUBLIC - includes everyone in the system as a potential participant, PRIVATE - only considers people who have been invited as participants) (optional)
     * @param  string|null $cell_phone the cell phone number (optional)
     * @param  string|null $street_address The street address of the location (optional)
     * @param  string|null $street_address2 Additional address information (such as a suite number, floor number, building name, or PO Box) (optional)
     * @param  string|null $city The city of the location (optional)
     * @param  string|null $state The state of of the location (optional)
     * @param  string|null $postal_code The postal code of the location (optional)
     * @param  string|null $full_address The full address of the location which should include the street address, city, state, and postal code (optional)
     * @param  bool|null $anonymous determines whether the album is posted anonymously (optional)
     * @param  string|null $meta_data External custom client defined data (optional)
     * @param  string|null $category_ids comma separated category ids string associated with the Album (optional)
     * @param  string|null $category_filter_ids comma separated filter ids string associated with the Album (optional)
     * @param  string|null $audience_ids comma separated audience ids string associated with the album (optional)
     * @param  string|null $audience_ids_to_add comma separated audience ids to add to the album (optional)
     * @param  string|null $audience_ids_to_remove comma separated audience ids to remove from the album (overrides audienceIds and audienceIdsToAdd) (optional)
     * @param  bool|null $include_all_app_users_as_members determines whether to include all app users as members (only admins of the app can do this) (optional)
     * @param  bool|null $include_audiences_as_members determines whether to include all users of the audiences as members (only admins of the app can do this) (optional)
     * @param  string|null $audience_operator determines whether to use ands or ors when using the audience list to add users (optional)
     * @param  string|null $linked_object_type sets a linked object so that it can be returned as part of the album response (optional)
     * @param  int|null $linked_object_id sets a linked object id so that it can be returned as part of the album response (optional)
     * @param  bool|null $index_now determines whether the album should be indexed immediately (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAlbumCollection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateAlbumCollectionRequest($album_id, $device_id = null, $account_id = null, $assets_to_add = null, $assets_to_remove = null, $asset_id = null, $media = null, $media_url = null, $active = null, $title = null, $start_date = null, $end_date = null, $tags = null, $description = null, $album_type = null, $album_type_id = null, $sub_type = null, $public_read = null, $public_write = null, $public_delete = null, $public_add = null, $latitude = null, $longitude = null, $location_description = null, $visibility = null, $cell_phone = null, $street_address = null, $street_address2 = null, $city = null, $state = null, $postal_code = null, $full_address = null, $anonymous = null, $meta_data = null, $category_ids = null, $category_filter_ids = null, $audience_ids = null, $audience_ids_to_add = null, $audience_ids_to_remove = null, $include_all_app_users_as_members = null, $include_audiences_as_members = null, $audience_operator = null, $linked_object_type = null, $linked_object_id = null, $index_now = null, string $contentType = self::contentTypes['updateAlbumCollection'][0])
    {

        // verify the required parameter 'album_id' is set
        if ($album_id === null || (is_array($album_id) && count($album_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $album_id when calling updateAlbumCollection'
            );
        }














































        $resourcePath = '/album/update';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_id,
            'deviceId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $album_id,
            'albumId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $assets_to_add,
            'assetsToAdd', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $assets_to_remove,
            'assetsToRemove', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $asset_id,
            'assetId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $media,
            'media', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $media_url,
            'mediaURL', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $active,
            'active', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $title,
            'title', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'startDate', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'endDate', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tags,
            'tags', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description,
            'description', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $album_type,
            'albumType', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $album_type_id,
            'albumTypeId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sub_type,
            'subType', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $public_read,
            'publicRead', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $public_write,
            'publicWrite', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $public_delete,
            'publicDelete', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $public_add,
            'publicAdd', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $latitude,
            'latitude', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $longitude,
            'longitude', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $location_description,
            'locationDescription', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $visibility,
            'visibility', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cell_phone,
            'cellPhone', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $street_address,
            'streetAddress', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $street_address2,
            'streetAddress2', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $city,
            'city', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $state,
            'state', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $postal_code,
            'postalCode', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $full_address,
            'fullAddress', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $anonymous,
            'anonymous', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $meta_data,
            'metaData', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $category_ids,
            'categoryIds', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $category_filter_ids,
            'categoryFilterIds', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audience_ids,
            'audienceIds', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audience_ids_to_add,
            'audienceIdsToAdd', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audience_ids_to_remove,
            'audienceIdsToRemove', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_all_app_users_as_members,
            'includeAllAppUsersAsMembers', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_audiences_as_members,
            'includeAudiencesAsMembers', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audience_operator,
            'audienceOperator', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $linked_object_type,
            'linkedObjectType', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $linked_object_id,
            'linkedObjectId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $index_now,
            'indexNow', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        if ($this->config->getCertFile()) {
            $options[RequestOptions::CERT] = $this->config->getCertFile();
        }

        if ($this->config->getKeyFile()) {
            $options[RequestOptions::SSL_KEY] = $this->config->getKeyFile();
        }

        return $options;
    }

    private function handleResponseWithDataType(
        string $dataType,
        RequestInterface $request,
        ResponseInterface $response
    ): array {
        if ($dataType === '\SplFileObject') {
            $content = $response->getBody(); //stream goes to serializer
        } else {
            $content = (string) $response->getBody();
            if ($dataType !== 'string') {
                try {
                    $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                } catch (\JsonException $exception) {
                    throw new ApiException(
                        sprintf(
                            'Error JSON decoding server response (%s)',
                            $request->getUri()
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                        $content
                    );
                }
            }
        }

        return [
            ObjectSerializer::deserialize($content, $dataType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    private function responseWithinRangeCode(
        string $rangeCode,
        int $statusCode
    ): bool {
        $left = (int) ($rangeCode[0].'00');
        $right = (int) ($rangeCode[0].'99');

        return $statusCode >= $left && $statusCode <= $right;
    }
}
