<?php
/**
 * CategoryApi
 * PHP version 8.1
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Sirqul IoT Platform
 *
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.20.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\FormDataProcessor;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * CategoryApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class CategoryApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'categoryDistanceSearch' => [
            'application/json',
        ],
        'createCategory' => [
            'application/json',
        ],
        'deleteCategory' => [
            'application/json',
        ],
        'duplicateCategory' => [
            'application/json',
        ],
        'getCategory' => [
            'application/json',
        ],
        'searchCategories' => [
            'application/json',
        ],
        'updateCategory' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation categoryDistanceSearch
     *
     * Search Categories by Distance
     *
     * @param  float $version version (required)
     * @param  int|null $account_id The account id of the user (optional)
     * @param  string|null $keyword The keyword string to search on (optional)
     * @param  string|null $app_key the appKey of the application to retrieve categories for, if not specified then search on the global application. (optional)
     * @param  string|null $category_ids Restrict the search by specific categories (optional)
     * @param  string|null $parent_category_ids Restrict the search by specific parent categories so that only its sub children are searched. (optional)
     * @param  bool|null $root_only Restrict the search to only those categories with no parent category assigned. (optional)
     * @param  string|null $sort_field The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, DISPLAY (optional, default to 'DISPLAY')
     * @param  string|null $response_group The group of categories to return: ALL, GLOBAL or MINE. ALL returns both global and application specific matches, GLOBAL only returns global matches, and MINE only returns the application specific matches. If not provided search on the application provided. (optional)
     * @param  bool|null $descending The order to return the search results (optional, default to false)
     * @param  int|null $start The record to begin the return set on (optional, default to 0)
     * @param  int|null $limit The number of records to return (optional, default to 20)
     * @param  bool|null $active_only Determines whether to return only active categories (optional, default to true)
     * @param  bool|null $return_external Determines whether to return extra info about the category&#39;s \&quot;Participant\&quot; reference (optional)
     * @param  bool|null $exact_match If true search categories using the exact keyword, if false then do a partial match (like) search. (optional)
     * @param  string|null $type Filters results by the Category&#39;s type (optional)
     * @param  string|null $external_type Filters results by externalType (optional)
     * @param  int|null $min_offer_count Filters results to only return Categories that have been referenced by a minimum number of Offers (optional)
     * @param  float|null $latitude the latitude of where the search is centered on (optional)
     * @param  float|null $longitude the longitude of where the search is centered on (optional)
     * @param  float|null $range the maximum range the category can be from the center (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['categoryDistanceSearch'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CategoryResponse[]
     */
    public function categoryDistanceSearch($version, $account_id = null, $keyword = null, $app_key = null, $category_ids = null, $parent_category_ids = null, $root_only = null, $sort_field = 'DISPLAY', $response_group = null, $descending = false, $start = 0, $limit = 20, $active_only = true, $return_external = null, $exact_match = null, $type = null, $external_type = null, $min_offer_count = null, $latitude = null, $longitude = null, $range = null, string $contentType = self::contentTypes['categoryDistanceSearch'][0])
    {
        list($response) = $this->categoryDistanceSearchWithHttpInfo($version, $account_id, $keyword, $app_key, $category_ids, $parent_category_ids, $root_only, $sort_field, $response_group, $descending, $start, $limit, $active_only, $return_external, $exact_match, $type, $external_type, $min_offer_count, $latitude, $longitude, $range, $contentType);
        return $response;
    }

    /**
     * Operation categoryDistanceSearchWithHttpInfo
     *
     * Search Categories by Distance
     *
     * @param  float $version (required)
     * @param  int|null $account_id The account id of the user (optional)
     * @param  string|null $keyword The keyword string to search on (optional)
     * @param  string|null $app_key the appKey of the application to retrieve categories for, if not specified then search on the global application. (optional)
     * @param  string|null $category_ids Restrict the search by specific categories (optional)
     * @param  string|null $parent_category_ids Restrict the search by specific parent categories so that only its sub children are searched. (optional)
     * @param  bool|null $root_only Restrict the search to only those categories with no parent category assigned. (optional)
     * @param  string|null $sort_field The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, DISPLAY (optional, default to 'DISPLAY')
     * @param  string|null $response_group The group of categories to return: ALL, GLOBAL or MINE. ALL returns both global and application specific matches, GLOBAL only returns global matches, and MINE only returns the application specific matches. If not provided search on the application provided. (optional)
     * @param  bool|null $descending The order to return the search results (optional, default to false)
     * @param  int|null $start The record to begin the return set on (optional, default to 0)
     * @param  int|null $limit The number of records to return (optional, default to 20)
     * @param  bool|null $active_only Determines whether to return only active categories (optional, default to true)
     * @param  bool|null $return_external Determines whether to return extra info about the category&#39;s \&quot;Participant\&quot; reference (optional)
     * @param  bool|null $exact_match If true search categories using the exact keyword, if false then do a partial match (like) search. (optional)
     * @param  string|null $type Filters results by the Category&#39;s type (optional)
     * @param  string|null $external_type Filters results by externalType (optional)
     * @param  int|null $min_offer_count Filters results to only return Categories that have been referenced by a minimum number of Offers (optional)
     * @param  float|null $latitude the latitude of where the search is centered on (optional)
     * @param  float|null $longitude the longitude of where the search is centered on (optional)
     * @param  float|null $range the maximum range the category can be from the center (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['categoryDistanceSearch'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CategoryResponse[], HTTP status code, HTTP response headers (array of strings)
     */
    public function categoryDistanceSearchWithHttpInfo($version, $account_id = null, $keyword = null, $app_key = null, $category_ids = null, $parent_category_ids = null, $root_only = null, $sort_field = 'DISPLAY', $response_group = null, $descending = false, $start = 0, $limit = 20, $active_only = true, $return_external = null, $exact_match = null, $type = null, $external_type = null, $min_offer_count = null, $latitude = null, $longitude = null, $range = null, string $contentType = self::contentTypes['categoryDistanceSearch'][0])
    {
        $request = $this->categoryDistanceSearchRequest($version, $account_id, $keyword, $app_key, $category_ids, $parent_category_ids, $root_only, $sort_field, $response_group, $descending, $start, $limit, $active_only, $return_external, $exact_match, $type, $external_type, $min_offer_count, $latitude, $longitude, $range, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\CategoryResponse[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\CategoryResponse[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CategoryResponse[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation categoryDistanceSearchAsync
     *
     * Search Categories by Distance
     *
     * @param  float $version (required)
     * @param  int|null $account_id The account id of the user (optional)
     * @param  string|null $keyword The keyword string to search on (optional)
     * @param  string|null $app_key the appKey of the application to retrieve categories for, if not specified then search on the global application. (optional)
     * @param  string|null $category_ids Restrict the search by specific categories (optional)
     * @param  string|null $parent_category_ids Restrict the search by specific parent categories so that only its sub children are searched. (optional)
     * @param  bool|null $root_only Restrict the search to only those categories with no parent category assigned. (optional)
     * @param  string|null $sort_field The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, DISPLAY (optional, default to 'DISPLAY')
     * @param  string|null $response_group The group of categories to return: ALL, GLOBAL or MINE. ALL returns both global and application specific matches, GLOBAL only returns global matches, and MINE only returns the application specific matches. If not provided search on the application provided. (optional)
     * @param  bool|null $descending The order to return the search results (optional, default to false)
     * @param  int|null $start The record to begin the return set on (optional, default to 0)
     * @param  int|null $limit The number of records to return (optional, default to 20)
     * @param  bool|null $active_only Determines whether to return only active categories (optional, default to true)
     * @param  bool|null $return_external Determines whether to return extra info about the category&#39;s \&quot;Participant\&quot; reference (optional)
     * @param  bool|null $exact_match If true search categories using the exact keyword, if false then do a partial match (like) search. (optional)
     * @param  string|null $type Filters results by the Category&#39;s type (optional)
     * @param  string|null $external_type Filters results by externalType (optional)
     * @param  int|null $min_offer_count Filters results to only return Categories that have been referenced by a minimum number of Offers (optional)
     * @param  float|null $latitude the latitude of where the search is centered on (optional)
     * @param  float|null $longitude the longitude of where the search is centered on (optional)
     * @param  float|null $range the maximum range the category can be from the center (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['categoryDistanceSearch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function categoryDistanceSearchAsync($version, $account_id = null, $keyword = null, $app_key = null, $category_ids = null, $parent_category_ids = null, $root_only = null, $sort_field = 'DISPLAY', $response_group = null, $descending = false, $start = 0, $limit = 20, $active_only = true, $return_external = null, $exact_match = null, $type = null, $external_type = null, $min_offer_count = null, $latitude = null, $longitude = null, $range = null, string $contentType = self::contentTypes['categoryDistanceSearch'][0])
    {
        return $this->categoryDistanceSearchAsyncWithHttpInfo($version, $account_id, $keyword, $app_key, $category_ids, $parent_category_ids, $root_only, $sort_field, $response_group, $descending, $start, $limit, $active_only, $return_external, $exact_match, $type, $external_type, $min_offer_count, $latitude, $longitude, $range, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation categoryDistanceSearchAsyncWithHttpInfo
     *
     * Search Categories by Distance
     *
     * @param  float $version (required)
     * @param  int|null $account_id The account id of the user (optional)
     * @param  string|null $keyword The keyword string to search on (optional)
     * @param  string|null $app_key the appKey of the application to retrieve categories for, if not specified then search on the global application. (optional)
     * @param  string|null $category_ids Restrict the search by specific categories (optional)
     * @param  string|null $parent_category_ids Restrict the search by specific parent categories so that only its sub children are searched. (optional)
     * @param  bool|null $root_only Restrict the search to only those categories with no parent category assigned. (optional)
     * @param  string|null $sort_field The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, DISPLAY (optional, default to 'DISPLAY')
     * @param  string|null $response_group The group of categories to return: ALL, GLOBAL or MINE. ALL returns both global and application specific matches, GLOBAL only returns global matches, and MINE only returns the application specific matches. If not provided search on the application provided. (optional)
     * @param  bool|null $descending The order to return the search results (optional, default to false)
     * @param  int|null $start The record to begin the return set on (optional, default to 0)
     * @param  int|null $limit The number of records to return (optional, default to 20)
     * @param  bool|null $active_only Determines whether to return only active categories (optional, default to true)
     * @param  bool|null $return_external Determines whether to return extra info about the category&#39;s \&quot;Participant\&quot; reference (optional)
     * @param  bool|null $exact_match If true search categories using the exact keyword, if false then do a partial match (like) search. (optional)
     * @param  string|null $type Filters results by the Category&#39;s type (optional)
     * @param  string|null $external_type Filters results by externalType (optional)
     * @param  int|null $min_offer_count Filters results to only return Categories that have been referenced by a minimum number of Offers (optional)
     * @param  float|null $latitude the latitude of where the search is centered on (optional)
     * @param  float|null $longitude the longitude of where the search is centered on (optional)
     * @param  float|null $range the maximum range the category can be from the center (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['categoryDistanceSearch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function categoryDistanceSearchAsyncWithHttpInfo($version, $account_id = null, $keyword = null, $app_key = null, $category_ids = null, $parent_category_ids = null, $root_only = null, $sort_field = 'DISPLAY', $response_group = null, $descending = false, $start = 0, $limit = 20, $active_only = true, $return_external = null, $exact_match = null, $type = null, $external_type = null, $min_offer_count = null, $latitude = null, $longitude = null, $range = null, string $contentType = self::contentTypes['categoryDistanceSearch'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CategoryResponse[]';
        $request = $this->categoryDistanceSearchRequest($version, $account_id, $keyword, $app_key, $category_ids, $parent_category_ids, $root_only, $sort_field, $response_group, $descending, $start, $limit, $active_only, $return_external, $exact_match, $type, $external_type, $min_offer_count, $latitude, $longitude, $range, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'categoryDistanceSearch'
     *
     * @param  float $version (required)
     * @param  int|null $account_id The account id of the user (optional)
     * @param  string|null $keyword The keyword string to search on (optional)
     * @param  string|null $app_key the appKey of the application to retrieve categories for, if not specified then search on the global application. (optional)
     * @param  string|null $category_ids Restrict the search by specific categories (optional)
     * @param  string|null $parent_category_ids Restrict the search by specific parent categories so that only its sub children are searched. (optional)
     * @param  bool|null $root_only Restrict the search to only those categories with no parent category assigned. (optional)
     * @param  string|null $sort_field The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, DISPLAY (optional, default to 'DISPLAY')
     * @param  string|null $response_group The group of categories to return: ALL, GLOBAL or MINE. ALL returns both global and application specific matches, GLOBAL only returns global matches, and MINE only returns the application specific matches. If not provided search on the application provided. (optional)
     * @param  bool|null $descending The order to return the search results (optional, default to false)
     * @param  int|null $start The record to begin the return set on (optional, default to 0)
     * @param  int|null $limit The number of records to return (optional, default to 20)
     * @param  bool|null $active_only Determines whether to return only active categories (optional, default to true)
     * @param  bool|null $return_external Determines whether to return extra info about the category&#39;s \&quot;Participant\&quot; reference (optional)
     * @param  bool|null $exact_match If true search categories using the exact keyword, if false then do a partial match (like) search. (optional)
     * @param  string|null $type Filters results by the Category&#39;s type (optional)
     * @param  string|null $external_type Filters results by externalType (optional)
     * @param  int|null $min_offer_count Filters results to only return Categories that have been referenced by a minimum number of Offers (optional)
     * @param  float|null $latitude the latitude of where the search is centered on (optional)
     * @param  float|null $longitude the longitude of where the search is centered on (optional)
     * @param  float|null $range the maximum range the category can be from the center (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['categoryDistanceSearch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function categoryDistanceSearchRequest($version, $account_id = null, $keyword = null, $app_key = null, $category_ids = null, $parent_category_ids = null, $root_only = null, $sort_field = 'DISPLAY', $response_group = null, $descending = false, $start = 0, $limit = 20, $active_only = true, $return_external = null, $exact_match = null, $type = null, $external_type = null, $min_offer_count = null, $latitude = null, $longitude = null, $range = null, string $contentType = self::contentTypes['categoryDistanceSearch'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling categoryDistanceSearch'
            );
        }






















        $resourcePath = '/api/{version}/category/distancesearch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $keyword,
            'keyword', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $app_key,
            'appKey', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $category_ids,
            'categoryIds', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $parent_category_ids,
            'parentCategoryIds', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $root_only,
            'rootOnly', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort_field,
            'sortField', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $response_group,
            'responseGroup', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $descending,
            'descending', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start,
            'start', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $active_only,
            'activeOnly', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_external,
            'returnExternal', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $exact_match,
            'exactMatch', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type,
            'type', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $external_type,
            'externalType', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_offer_count,
            'minOfferCount', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $latitude,
            'latitude', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $longitude,
            'longitude', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $range,
            'range', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createCategory
     *
     * Create Category
     *
     * @param  float $version version (required)
     * @param  int $account_id The account id of the user (must have permissions to the target application) (required)
     * @param  string $name The name of the category (required)
     * @param  string|null $app_key The appKey of the application to assign the category to, if not provided then the category will be applied to the global application (if the account has permissions) (optional)
     * @param  int|null $parent_category_id The ID of the parent category, if not provided then the parent category will be null (optional)
     * @param  string|null $description The description of the category (optional)
     * @param  string|null $type The type of the category (optional)
     * @param  int|null $asset_id The ID of the image asset previously uploaded using the media service (optional)
     * @param  string|null $external_id A string identifier used by client applications to store external information (optional)
     * @param  string|null $external_type A string type used by client applications to store external information (optional)
     * @param  string|null $external_category_slug external category slug (optional)
     * @param  string|null $sqoot_slug sqoot slug (optional)
     * @param  bool|null $active Sets whether the category is active or inactive (hidden from consumers) (optional)
     * @param  string|null $meta_data external custom client defined data (optional)
     * @param  string|null $search_tags user defined strings for searching (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCategory'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CategoryTreeResponse
     */
    public function createCategory($version, $account_id, $name, $app_key = null, $parent_category_id = null, $description = null, $type = null, $asset_id = null, $external_id = null, $external_type = null, $external_category_slug = null, $sqoot_slug = null, $active = null, $meta_data = null, $search_tags = null, string $contentType = self::contentTypes['createCategory'][0])
    {
        list($response) = $this->createCategoryWithHttpInfo($version, $account_id, $name, $app_key, $parent_category_id, $description, $type, $asset_id, $external_id, $external_type, $external_category_slug, $sqoot_slug, $active, $meta_data, $search_tags, $contentType);
        return $response;
    }

    /**
     * Operation createCategoryWithHttpInfo
     *
     * Create Category
     *
     * @param  float $version (required)
     * @param  int $account_id The account id of the user (must have permissions to the target application) (required)
     * @param  string $name The name of the category (required)
     * @param  string|null $app_key The appKey of the application to assign the category to, if not provided then the category will be applied to the global application (if the account has permissions) (optional)
     * @param  int|null $parent_category_id The ID of the parent category, if not provided then the parent category will be null (optional)
     * @param  string|null $description The description of the category (optional)
     * @param  string|null $type The type of the category (optional)
     * @param  int|null $asset_id The ID of the image asset previously uploaded using the media service (optional)
     * @param  string|null $external_id A string identifier used by client applications to store external information (optional)
     * @param  string|null $external_type A string type used by client applications to store external information (optional)
     * @param  string|null $external_category_slug external category slug (optional)
     * @param  string|null $sqoot_slug sqoot slug (optional)
     * @param  bool|null $active Sets whether the category is active or inactive (hidden from consumers) (optional)
     * @param  string|null $meta_data external custom client defined data (optional)
     * @param  string|null $search_tags user defined strings for searching (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCategory'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CategoryTreeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCategoryWithHttpInfo($version, $account_id, $name, $app_key = null, $parent_category_id = null, $description = null, $type = null, $asset_id = null, $external_id = null, $external_type = null, $external_category_slug = null, $sqoot_slug = null, $active = null, $meta_data = null, $search_tags = null, string $contentType = self::contentTypes['createCategory'][0])
    {
        $request = $this->createCategoryRequest($version, $account_id, $name, $app_key, $parent_category_id, $description, $type, $asset_id, $external_id, $external_type, $external_category_slug, $sqoot_slug, $active, $meta_data, $search_tags, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\CategoryTreeResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\CategoryTreeResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CategoryTreeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createCategoryAsync
     *
     * Create Category
     *
     * @param  float $version (required)
     * @param  int $account_id The account id of the user (must have permissions to the target application) (required)
     * @param  string $name The name of the category (required)
     * @param  string|null $app_key The appKey of the application to assign the category to, if not provided then the category will be applied to the global application (if the account has permissions) (optional)
     * @param  int|null $parent_category_id The ID of the parent category, if not provided then the parent category will be null (optional)
     * @param  string|null $description The description of the category (optional)
     * @param  string|null $type The type of the category (optional)
     * @param  int|null $asset_id The ID of the image asset previously uploaded using the media service (optional)
     * @param  string|null $external_id A string identifier used by client applications to store external information (optional)
     * @param  string|null $external_type A string type used by client applications to store external information (optional)
     * @param  string|null $external_category_slug external category slug (optional)
     * @param  string|null $sqoot_slug sqoot slug (optional)
     * @param  bool|null $active Sets whether the category is active or inactive (hidden from consumers) (optional)
     * @param  string|null $meta_data external custom client defined data (optional)
     * @param  string|null $search_tags user defined strings for searching (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCategory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCategoryAsync($version, $account_id, $name, $app_key = null, $parent_category_id = null, $description = null, $type = null, $asset_id = null, $external_id = null, $external_type = null, $external_category_slug = null, $sqoot_slug = null, $active = null, $meta_data = null, $search_tags = null, string $contentType = self::contentTypes['createCategory'][0])
    {
        return $this->createCategoryAsyncWithHttpInfo($version, $account_id, $name, $app_key, $parent_category_id, $description, $type, $asset_id, $external_id, $external_type, $external_category_slug, $sqoot_slug, $active, $meta_data, $search_tags, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createCategoryAsyncWithHttpInfo
     *
     * Create Category
     *
     * @param  float $version (required)
     * @param  int $account_id The account id of the user (must have permissions to the target application) (required)
     * @param  string $name The name of the category (required)
     * @param  string|null $app_key The appKey of the application to assign the category to, if not provided then the category will be applied to the global application (if the account has permissions) (optional)
     * @param  int|null $parent_category_id The ID of the parent category, if not provided then the parent category will be null (optional)
     * @param  string|null $description The description of the category (optional)
     * @param  string|null $type The type of the category (optional)
     * @param  int|null $asset_id The ID of the image asset previously uploaded using the media service (optional)
     * @param  string|null $external_id A string identifier used by client applications to store external information (optional)
     * @param  string|null $external_type A string type used by client applications to store external information (optional)
     * @param  string|null $external_category_slug external category slug (optional)
     * @param  string|null $sqoot_slug sqoot slug (optional)
     * @param  bool|null $active Sets whether the category is active or inactive (hidden from consumers) (optional)
     * @param  string|null $meta_data external custom client defined data (optional)
     * @param  string|null $search_tags user defined strings for searching (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCategory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCategoryAsyncWithHttpInfo($version, $account_id, $name, $app_key = null, $parent_category_id = null, $description = null, $type = null, $asset_id = null, $external_id = null, $external_type = null, $external_category_slug = null, $sqoot_slug = null, $active = null, $meta_data = null, $search_tags = null, string $contentType = self::contentTypes['createCategory'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CategoryTreeResponse';
        $request = $this->createCategoryRequest($version, $account_id, $name, $app_key, $parent_category_id, $description, $type, $asset_id, $external_id, $external_type, $external_category_slug, $sqoot_slug, $active, $meta_data, $search_tags, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createCategory'
     *
     * @param  float $version (required)
     * @param  int $account_id The account id of the user (must have permissions to the target application) (required)
     * @param  string $name The name of the category (required)
     * @param  string|null $app_key The appKey of the application to assign the category to, if not provided then the category will be applied to the global application (if the account has permissions) (optional)
     * @param  int|null $parent_category_id The ID of the parent category, if not provided then the parent category will be null (optional)
     * @param  string|null $description The description of the category (optional)
     * @param  string|null $type The type of the category (optional)
     * @param  int|null $asset_id The ID of the image asset previously uploaded using the media service (optional)
     * @param  string|null $external_id A string identifier used by client applications to store external information (optional)
     * @param  string|null $external_type A string type used by client applications to store external information (optional)
     * @param  string|null $external_category_slug external category slug (optional)
     * @param  string|null $sqoot_slug sqoot slug (optional)
     * @param  bool|null $active Sets whether the category is active or inactive (hidden from consumers) (optional)
     * @param  string|null $meta_data external custom client defined data (optional)
     * @param  string|null $search_tags user defined strings for searching (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCategory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createCategoryRequest($version, $account_id, $name, $app_key = null, $parent_category_id = null, $description = null, $type = null, $asset_id = null, $external_id = null, $external_type = null, $external_category_slug = null, $sqoot_slug = null, $active = null, $meta_data = null, $search_tags = null, string $contentType = self::contentTypes['createCategory'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling createCategory'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling createCategory'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling createCategory'
            );
        }














        $resourcePath = '/api/{version}/category/create';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $app_key,
            'appKey', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $parent_category_id,
            'parentCategoryId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description,
            'description', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type,
            'type', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $asset_id,
            'assetId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $external_id,
            'externalId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $external_type,
            'externalType', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $external_category_slug,
            'externalCategorySlug', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sqoot_slug,
            'sqootSlug', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $active,
            'active', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $meta_data,
            'metaData', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $search_tags,
            'searchTags', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteCategory
     *
     * Delete Category
     *
     * @param  float $version version (required)
     * @param  int $account_id the ID of the account (required)
     * @param  int $category_id the ID of the category (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteCategory'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SirqulResponse
     */
    public function deleteCategory($version, $account_id, $category_id, string $contentType = self::contentTypes['deleteCategory'][0])
    {
        list($response) = $this->deleteCategoryWithHttpInfo($version, $account_id, $category_id, $contentType);
        return $response;
    }

    /**
     * Operation deleteCategoryWithHttpInfo
     *
     * Delete Category
     *
     * @param  float $version (required)
     * @param  int $account_id the ID of the account (required)
     * @param  int $category_id the ID of the category (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteCategory'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SirqulResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCategoryWithHttpInfo($version, $account_id, $category_id, string $contentType = self::contentTypes['deleteCategory'][0])
    {
        $request = $this->deleteCategoryRequest($version, $account_id, $category_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\SirqulResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\SirqulResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SirqulResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteCategoryAsync
     *
     * Delete Category
     *
     * @param  float $version (required)
     * @param  int $account_id the ID of the account (required)
     * @param  int $category_id the ID of the category (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteCategory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCategoryAsync($version, $account_id, $category_id, string $contentType = self::contentTypes['deleteCategory'][0])
    {
        return $this->deleteCategoryAsyncWithHttpInfo($version, $account_id, $category_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteCategoryAsyncWithHttpInfo
     *
     * Delete Category
     *
     * @param  float $version (required)
     * @param  int $account_id the ID of the account (required)
     * @param  int $category_id the ID of the category (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteCategory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCategoryAsyncWithHttpInfo($version, $account_id, $category_id, string $contentType = self::contentTypes['deleteCategory'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SirqulResponse';
        $request = $this->deleteCategoryRequest($version, $account_id, $category_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteCategory'
     *
     * @param  float $version (required)
     * @param  int $account_id the ID of the account (required)
     * @param  int $category_id the ID of the category (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteCategory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteCategoryRequest($version, $account_id, $category_id, string $contentType = self::contentTypes['deleteCategory'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling deleteCategory'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling deleteCategory'
            );
        }

        // verify the required parameter 'category_id' is set
        if ($category_id === null || (is_array($category_id) && count($category_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $category_id when calling deleteCategory'
            );
        }


        $resourcePath = '/api/{version}/category/delete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $category_id,
            'categoryId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation duplicateCategory
     *
     * Duplicate Category
     *
     * @param  float $version version (required)
     * @param  int $account_id The account id of the user (must have permissions to the target application) (required)
     * @param  int $category_id The category ID to duplicate (includes all children) (required)
     * @param  string|null $app_key The application to assign the new category to, may be different then the application the source category is assigned to (optional)
     * @param  int|null $parent_category_id The parent category ID to add the target category to. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['duplicateCategory'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CategoryTreeResponse
     */
    public function duplicateCategory($version, $account_id, $category_id, $app_key = null, $parent_category_id = null, string $contentType = self::contentTypes['duplicateCategory'][0])
    {
        list($response) = $this->duplicateCategoryWithHttpInfo($version, $account_id, $category_id, $app_key, $parent_category_id, $contentType);
        return $response;
    }

    /**
     * Operation duplicateCategoryWithHttpInfo
     *
     * Duplicate Category
     *
     * @param  float $version (required)
     * @param  int $account_id The account id of the user (must have permissions to the target application) (required)
     * @param  int $category_id The category ID to duplicate (includes all children) (required)
     * @param  string|null $app_key The application to assign the new category to, may be different then the application the source category is assigned to (optional)
     * @param  int|null $parent_category_id The parent category ID to add the target category to. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['duplicateCategory'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CategoryTreeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function duplicateCategoryWithHttpInfo($version, $account_id, $category_id, $app_key = null, $parent_category_id = null, string $contentType = self::contentTypes['duplicateCategory'][0])
    {
        $request = $this->duplicateCategoryRequest($version, $account_id, $category_id, $app_key, $parent_category_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\CategoryTreeResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\CategoryTreeResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CategoryTreeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation duplicateCategoryAsync
     *
     * Duplicate Category
     *
     * @param  float $version (required)
     * @param  int $account_id The account id of the user (must have permissions to the target application) (required)
     * @param  int $category_id The category ID to duplicate (includes all children) (required)
     * @param  string|null $app_key The application to assign the new category to, may be different then the application the source category is assigned to (optional)
     * @param  int|null $parent_category_id The parent category ID to add the target category to. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['duplicateCategory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function duplicateCategoryAsync($version, $account_id, $category_id, $app_key = null, $parent_category_id = null, string $contentType = self::contentTypes['duplicateCategory'][0])
    {
        return $this->duplicateCategoryAsyncWithHttpInfo($version, $account_id, $category_id, $app_key, $parent_category_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation duplicateCategoryAsyncWithHttpInfo
     *
     * Duplicate Category
     *
     * @param  float $version (required)
     * @param  int $account_id The account id of the user (must have permissions to the target application) (required)
     * @param  int $category_id The category ID to duplicate (includes all children) (required)
     * @param  string|null $app_key The application to assign the new category to, may be different then the application the source category is assigned to (optional)
     * @param  int|null $parent_category_id The parent category ID to add the target category to. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['duplicateCategory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function duplicateCategoryAsyncWithHttpInfo($version, $account_id, $category_id, $app_key = null, $parent_category_id = null, string $contentType = self::contentTypes['duplicateCategory'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CategoryTreeResponse';
        $request = $this->duplicateCategoryRequest($version, $account_id, $category_id, $app_key, $parent_category_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'duplicateCategory'
     *
     * @param  float $version (required)
     * @param  int $account_id The account id of the user (must have permissions to the target application) (required)
     * @param  int $category_id The category ID to duplicate (includes all children) (required)
     * @param  string|null $app_key The application to assign the new category to, may be different then the application the source category is assigned to (optional)
     * @param  int|null $parent_category_id The parent category ID to add the target category to. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['duplicateCategory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function duplicateCategoryRequest($version, $account_id, $category_id, $app_key = null, $parent_category_id = null, string $contentType = self::contentTypes['duplicateCategory'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling duplicateCategory'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling duplicateCategory'
            );
        }

        // verify the required parameter 'category_id' is set
        if ($category_id === null || (is_array($category_id) && count($category_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $category_id when calling duplicateCategory'
            );
        }




        $resourcePath = '/api/{version}/category/duplicate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $app_key,
            'appKey', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $category_id,
            'categoryId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $parent_category_id,
            'parentCategoryId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCategory
     *
     * Get Category
     *
     * @param  float $version version (required)
     * @param  int $category_id the ID of the category (required)
     * @param  bool|null $return_external Determines whether to return extra info about the category&#39;s \&quot;Participant\&quot; reference (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCategory'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CategoryTreeResponse
     */
    public function getCategory($version, $category_id, $return_external = true, string $contentType = self::contentTypes['getCategory'][0])
    {
        list($response) = $this->getCategoryWithHttpInfo($version, $category_id, $return_external, $contentType);
        return $response;
    }

    /**
     * Operation getCategoryWithHttpInfo
     *
     * Get Category
     *
     * @param  float $version (required)
     * @param  int $category_id the ID of the category (required)
     * @param  bool|null $return_external Determines whether to return extra info about the category&#39;s \&quot;Participant\&quot; reference (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCategory'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CategoryTreeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCategoryWithHttpInfo($version, $category_id, $return_external = true, string $contentType = self::contentTypes['getCategory'][0])
    {
        $request = $this->getCategoryRequest($version, $category_id, $return_external, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\CategoryTreeResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\CategoryTreeResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CategoryTreeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getCategoryAsync
     *
     * Get Category
     *
     * @param  float $version (required)
     * @param  int $category_id the ID of the category (required)
     * @param  bool|null $return_external Determines whether to return extra info about the category&#39;s \&quot;Participant\&quot; reference (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCategory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCategoryAsync($version, $category_id, $return_external = true, string $contentType = self::contentTypes['getCategory'][0])
    {
        return $this->getCategoryAsyncWithHttpInfo($version, $category_id, $return_external, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCategoryAsyncWithHttpInfo
     *
     * Get Category
     *
     * @param  float $version (required)
     * @param  int $category_id the ID of the category (required)
     * @param  bool|null $return_external Determines whether to return extra info about the category&#39;s \&quot;Participant\&quot; reference (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCategory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCategoryAsyncWithHttpInfo($version, $category_id, $return_external = true, string $contentType = self::contentTypes['getCategory'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CategoryTreeResponse';
        $request = $this->getCategoryRequest($version, $category_id, $return_external, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCategory'
     *
     * @param  float $version (required)
     * @param  int $category_id the ID of the category (required)
     * @param  bool|null $return_external Determines whether to return extra info about the category&#39;s \&quot;Participant\&quot; reference (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCategory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getCategoryRequest($version, $category_id, $return_external = true, string $contentType = self::contentTypes['getCategory'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling getCategory'
            );
        }

        // verify the required parameter 'category_id' is set
        if ($category_id === null || (is_array($category_id) && count($category_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $category_id when calling getCategory'
            );
        }



        $resourcePath = '/api/{version}/category/get';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $category_id,
            'categoryId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_external,
            'returnExternal', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchCategories
     *
     * Search Categories
     *
     * @param  float $version version (required)
     * @param  int|null $account_id The account id of the user (optional)
     * @param  string|null $keyword The string to search on (optional)
     * @param  string|null $app_key the appKey of the application to retrieve categories for, if not specified then search on the global application. (optional)
     * @param  string|null $category_id @Deprecated, use parentCategoryIds instead (optional)
     * @param  string|null $category_ids Restrict the search by specific categories (optional)
     * @param  string|null $parent_category_ids Restrict the search by specific parent categories so that only its sub children are searched. (optional)
     * @param  bool|null $root_only Restrict the search to only those categories with no parent category assigned. (optional)
     * @param  string|null $sort_field The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, DISPLAY (optional, default to 'DISPLAY')
     * @param  string|null $response_group The group of categories to return: ALL, GLOBAL or MINE. ALL returns both global and application specific matches, GLOBAL only returns global matches, and MINE only returns the application specific matches. If not provided search on the application provided. (optional)
     * @param  bool|null $descending The order to return the search results (optional, default to false)
     * @param  int|null $start The record to begin the return set on (optional, default to 0)
     * @param  int|null $limit The number of records to return (optional, default to 20)
     * @param  bool|null $active_only Determines whether to return only active categories (optional, default to true)
     * @param  bool|null $return_external Determines whether to return extra info about the category&#39;s \&quot;Participant\&quot; reference (optional, default to true)
     * @param  bool|null $exact_match If true search categories using the exact keyword, if false then do a partial match (like) search. Default is false. (optional, default to false)
     * @param  string|null $type Filters results by the Category&#39;s type (optional)
     * @param  string|null $external_type Filters results by externalType (optional)
     * @param  bool|null $exclude_external_type Determines whether the \&quot;externalType\&quot; param is excluded from the search results (optional)
     * @param  int|null $min_offer_count Filters results to only return Categories that have been referenced by a minimum number of Offers (optional)
     * @param  int|null $search_depth When searching by a specific parent category (to return sub children), this determines the number of child layers to search in. The minimum is 1, the maximum is 4. (optional, default to 4)
     * @param  string|null $search_mode The search index mode to use (e.g. OPENSEARCH or RDS) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchCategories'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CategoryResponse[]
     */
    public function searchCategories($version, $account_id = null, $keyword = null, $app_key = null, $category_id = null, $category_ids = null, $parent_category_ids = null, $root_only = null, $sort_field = 'DISPLAY', $response_group = null, $descending = false, $start = 0, $limit = 20, $active_only = true, $return_external = true, $exact_match = false, $type = null, $external_type = null, $exclude_external_type = null, $min_offer_count = null, $search_depth = 4, $search_mode = null, string $contentType = self::contentTypes['searchCategories'][0])
    {
        list($response) = $this->searchCategoriesWithHttpInfo($version, $account_id, $keyword, $app_key, $category_id, $category_ids, $parent_category_ids, $root_only, $sort_field, $response_group, $descending, $start, $limit, $active_only, $return_external, $exact_match, $type, $external_type, $exclude_external_type, $min_offer_count, $search_depth, $search_mode, $contentType);
        return $response;
    }

    /**
     * Operation searchCategoriesWithHttpInfo
     *
     * Search Categories
     *
     * @param  float $version (required)
     * @param  int|null $account_id The account id of the user (optional)
     * @param  string|null $keyword The string to search on (optional)
     * @param  string|null $app_key the appKey of the application to retrieve categories for, if not specified then search on the global application. (optional)
     * @param  string|null $category_id @Deprecated, use parentCategoryIds instead (optional)
     * @param  string|null $category_ids Restrict the search by specific categories (optional)
     * @param  string|null $parent_category_ids Restrict the search by specific parent categories so that only its sub children are searched. (optional)
     * @param  bool|null $root_only Restrict the search to only those categories with no parent category assigned. (optional)
     * @param  string|null $sort_field The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, DISPLAY (optional, default to 'DISPLAY')
     * @param  string|null $response_group The group of categories to return: ALL, GLOBAL or MINE. ALL returns both global and application specific matches, GLOBAL only returns global matches, and MINE only returns the application specific matches. If not provided search on the application provided. (optional)
     * @param  bool|null $descending The order to return the search results (optional, default to false)
     * @param  int|null $start The record to begin the return set on (optional, default to 0)
     * @param  int|null $limit The number of records to return (optional, default to 20)
     * @param  bool|null $active_only Determines whether to return only active categories (optional, default to true)
     * @param  bool|null $return_external Determines whether to return extra info about the category&#39;s \&quot;Participant\&quot; reference (optional, default to true)
     * @param  bool|null $exact_match If true search categories using the exact keyword, if false then do a partial match (like) search. Default is false. (optional, default to false)
     * @param  string|null $type Filters results by the Category&#39;s type (optional)
     * @param  string|null $external_type Filters results by externalType (optional)
     * @param  bool|null $exclude_external_type Determines whether the \&quot;externalType\&quot; param is excluded from the search results (optional)
     * @param  int|null $min_offer_count Filters results to only return Categories that have been referenced by a minimum number of Offers (optional)
     * @param  int|null $search_depth When searching by a specific parent category (to return sub children), this determines the number of child layers to search in. The minimum is 1, the maximum is 4. (optional, default to 4)
     * @param  string|null $search_mode The search index mode to use (e.g. OPENSEARCH or RDS) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchCategories'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CategoryResponse[], HTTP status code, HTTP response headers (array of strings)
     */
    public function searchCategoriesWithHttpInfo($version, $account_id = null, $keyword = null, $app_key = null, $category_id = null, $category_ids = null, $parent_category_ids = null, $root_only = null, $sort_field = 'DISPLAY', $response_group = null, $descending = false, $start = 0, $limit = 20, $active_only = true, $return_external = true, $exact_match = false, $type = null, $external_type = null, $exclude_external_type = null, $min_offer_count = null, $search_depth = 4, $search_mode = null, string $contentType = self::contentTypes['searchCategories'][0])
    {
        $request = $this->searchCategoriesRequest($version, $account_id, $keyword, $app_key, $category_id, $category_ids, $parent_category_ids, $root_only, $sort_field, $response_group, $descending, $start, $limit, $active_only, $return_external, $exact_match, $type, $external_type, $exclude_external_type, $min_offer_count, $search_depth, $search_mode, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\CategoryResponse[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\CategoryResponse[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CategoryResponse[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation searchCategoriesAsync
     *
     * Search Categories
     *
     * @param  float $version (required)
     * @param  int|null $account_id The account id of the user (optional)
     * @param  string|null $keyword The string to search on (optional)
     * @param  string|null $app_key the appKey of the application to retrieve categories for, if not specified then search on the global application. (optional)
     * @param  string|null $category_id @Deprecated, use parentCategoryIds instead (optional)
     * @param  string|null $category_ids Restrict the search by specific categories (optional)
     * @param  string|null $parent_category_ids Restrict the search by specific parent categories so that only its sub children are searched. (optional)
     * @param  bool|null $root_only Restrict the search to only those categories with no parent category assigned. (optional)
     * @param  string|null $sort_field The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, DISPLAY (optional, default to 'DISPLAY')
     * @param  string|null $response_group The group of categories to return: ALL, GLOBAL or MINE. ALL returns both global and application specific matches, GLOBAL only returns global matches, and MINE only returns the application specific matches. If not provided search on the application provided. (optional)
     * @param  bool|null $descending The order to return the search results (optional, default to false)
     * @param  int|null $start The record to begin the return set on (optional, default to 0)
     * @param  int|null $limit The number of records to return (optional, default to 20)
     * @param  bool|null $active_only Determines whether to return only active categories (optional, default to true)
     * @param  bool|null $return_external Determines whether to return extra info about the category&#39;s \&quot;Participant\&quot; reference (optional, default to true)
     * @param  bool|null $exact_match If true search categories using the exact keyword, if false then do a partial match (like) search. Default is false. (optional, default to false)
     * @param  string|null $type Filters results by the Category&#39;s type (optional)
     * @param  string|null $external_type Filters results by externalType (optional)
     * @param  bool|null $exclude_external_type Determines whether the \&quot;externalType\&quot; param is excluded from the search results (optional)
     * @param  int|null $min_offer_count Filters results to only return Categories that have been referenced by a minimum number of Offers (optional)
     * @param  int|null $search_depth When searching by a specific parent category (to return sub children), this determines the number of child layers to search in. The minimum is 1, the maximum is 4. (optional, default to 4)
     * @param  string|null $search_mode The search index mode to use (e.g. OPENSEARCH or RDS) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchCategories'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchCategoriesAsync($version, $account_id = null, $keyword = null, $app_key = null, $category_id = null, $category_ids = null, $parent_category_ids = null, $root_only = null, $sort_field = 'DISPLAY', $response_group = null, $descending = false, $start = 0, $limit = 20, $active_only = true, $return_external = true, $exact_match = false, $type = null, $external_type = null, $exclude_external_type = null, $min_offer_count = null, $search_depth = 4, $search_mode = null, string $contentType = self::contentTypes['searchCategories'][0])
    {
        return $this->searchCategoriesAsyncWithHttpInfo($version, $account_id, $keyword, $app_key, $category_id, $category_ids, $parent_category_ids, $root_only, $sort_field, $response_group, $descending, $start, $limit, $active_only, $return_external, $exact_match, $type, $external_type, $exclude_external_type, $min_offer_count, $search_depth, $search_mode, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchCategoriesAsyncWithHttpInfo
     *
     * Search Categories
     *
     * @param  float $version (required)
     * @param  int|null $account_id The account id of the user (optional)
     * @param  string|null $keyword The string to search on (optional)
     * @param  string|null $app_key the appKey of the application to retrieve categories for, if not specified then search on the global application. (optional)
     * @param  string|null $category_id @Deprecated, use parentCategoryIds instead (optional)
     * @param  string|null $category_ids Restrict the search by specific categories (optional)
     * @param  string|null $parent_category_ids Restrict the search by specific parent categories so that only its sub children are searched. (optional)
     * @param  bool|null $root_only Restrict the search to only those categories with no parent category assigned. (optional)
     * @param  string|null $sort_field The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, DISPLAY (optional, default to 'DISPLAY')
     * @param  string|null $response_group The group of categories to return: ALL, GLOBAL or MINE. ALL returns both global and application specific matches, GLOBAL only returns global matches, and MINE only returns the application specific matches. If not provided search on the application provided. (optional)
     * @param  bool|null $descending The order to return the search results (optional, default to false)
     * @param  int|null $start The record to begin the return set on (optional, default to 0)
     * @param  int|null $limit The number of records to return (optional, default to 20)
     * @param  bool|null $active_only Determines whether to return only active categories (optional, default to true)
     * @param  bool|null $return_external Determines whether to return extra info about the category&#39;s \&quot;Participant\&quot; reference (optional, default to true)
     * @param  bool|null $exact_match If true search categories using the exact keyword, if false then do a partial match (like) search. Default is false. (optional, default to false)
     * @param  string|null $type Filters results by the Category&#39;s type (optional)
     * @param  string|null $external_type Filters results by externalType (optional)
     * @param  bool|null $exclude_external_type Determines whether the \&quot;externalType\&quot; param is excluded from the search results (optional)
     * @param  int|null $min_offer_count Filters results to only return Categories that have been referenced by a minimum number of Offers (optional)
     * @param  int|null $search_depth When searching by a specific parent category (to return sub children), this determines the number of child layers to search in. The minimum is 1, the maximum is 4. (optional, default to 4)
     * @param  string|null $search_mode The search index mode to use (e.g. OPENSEARCH or RDS) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchCategories'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchCategoriesAsyncWithHttpInfo($version, $account_id = null, $keyword = null, $app_key = null, $category_id = null, $category_ids = null, $parent_category_ids = null, $root_only = null, $sort_field = 'DISPLAY', $response_group = null, $descending = false, $start = 0, $limit = 20, $active_only = true, $return_external = true, $exact_match = false, $type = null, $external_type = null, $exclude_external_type = null, $min_offer_count = null, $search_depth = 4, $search_mode = null, string $contentType = self::contentTypes['searchCategories'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CategoryResponse[]';
        $request = $this->searchCategoriesRequest($version, $account_id, $keyword, $app_key, $category_id, $category_ids, $parent_category_ids, $root_only, $sort_field, $response_group, $descending, $start, $limit, $active_only, $return_external, $exact_match, $type, $external_type, $exclude_external_type, $min_offer_count, $search_depth, $search_mode, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchCategories'
     *
     * @param  float $version (required)
     * @param  int|null $account_id The account id of the user (optional)
     * @param  string|null $keyword The string to search on (optional)
     * @param  string|null $app_key the appKey of the application to retrieve categories for, if not specified then search on the global application. (optional)
     * @param  string|null $category_id @Deprecated, use parentCategoryIds instead (optional)
     * @param  string|null $category_ids Restrict the search by specific categories (optional)
     * @param  string|null $parent_category_ids Restrict the search by specific parent categories so that only its sub children are searched. (optional)
     * @param  bool|null $root_only Restrict the search to only those categories with no parent category assigned. (optional)
     * @param  string|null $sort_field The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, DISPLAY (optional, default to 'DISPLAY')
     * @param  string|null $response_group The group of categories to return: ALL, GLOBAL or MINE. ALL returns both global and application specific matches, GLOBAL only returns global matches, and MINE only returns the application specific matches. If not provided search on the application provided. (optional)
     * @param  bool|null $descending The order to return the search results (optional, default to false)
     * @param  int|null $start The record to begin the return set on (optional, default to 0)
     * @param  int|null $limit The number of records to return (optional, default to 20)
     * @param  bool|null $active_only Determines whether to return only active categories (optional, default to true)
     * @param  bool|null $return_external Determines whether to return extra info about the category&#39;s \&quot;Participant\&quot; reference (optional, default to true)
     * @param  bool|null $exact_match If true search categories using the exact keyword, if false then do a partial match (like) search. Default is false. (optional, default to false)
     * @param  string|null $type Filters results by the Category&#39;s type (optional)
     * @param  string|null $external_type Filters results by externalType (optional)
     * @param  bool|null $exclude_external_type Determines whether the \&quot;externalType\&quot; param is excluded from the search results (optional)
     * @param  int|null $min_offer_count Filters results to only return Categories that have been referenced by a minimum number of Offers (optional)
     * @param  int|null $search_depth When searching by a specific parent category (to return sub children), this determines the number of child layers to search in. The minimum is 1, the maximum is 4. (optional, default to 4)
     * @param  string|null $search_mode The search index mode to use (e.g. OPENSEARCH or RDS) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchCategories'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function searchCategoriesRequest($version, $account_id = null, $keyword = null, $app_key = null, $category_id = null, $category_ids = null, $parent_category_ids = null, $root_only = null, $sort_field = 'DISPLAY', $response_group = null, $descending = false, $start = 0, $limit = 20, $active_only = true, $return_external = true, $exact_match = false, $type = null, $external_type = null, $exclude_external_type = null, $min_offer_count = null, $search_depth = 4, $search_mode = null, string $contentType = self::contentTypes['searchCategories'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling searchCategories'
            );
        }























        $resourcePath = '/api/{version}/category/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $keyword,
            'keyword', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $app_key,
            'appKey', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $category_id,
            'categoryId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $category_ids,
            'categoryIds', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $parent_category_ids,
            'parentCategoryIds', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $root_only,
            'rootOnly', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort_field,
            'sortField', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $response_group,
            'responseGroup', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $descending,
            'descending', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start,
            'start', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $active_only,
            'activeOnly', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_external,
            'returnExternal', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $exact_match,
            'exactMatch', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type,
            'type', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $external_type,
            'externalType', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $exclude_external_type,
            'excludeExternalType', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_offer_count,
            'minOfferCount', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $search_depth,
            'searchDepth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $search_mode,
            'searchMode', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateCategory
     *
     * Update Category
     *
     * @param  float $version version (required)
     * @param  int $account_id The account id of the user (required)
     * @param  int $category_id The ID of the category to edit (required)
     * @param  int|null $parent_category_id The ID of the parent category, if not provided then the parent category will be null (optional)
     * @param  string|null $name The name of the category (optional)
     * @param  string|null $description The description of the category (optional)
     * @param  string|null $type The type of the category (optional)
     * @param  int|null $asset_id The ID of the image asset previously uploaded using the media service (optional)
     * @param  string|null $external_id A string identifier used by client applications to store external information (optional)
     * @param  string|null $external_type A string type used by client applications to store external information (optional)
     * @param  string|null $external_category_slug external category slug (optional)
     * @param  string|null $sqoot_slug sqoot slug (optional)
     * @param  bool|null $active Sets whether the category is active or inactive (hidden from consumers) (optional)
     * @param  string|null $meta_data external custom client defined data (optional)
     * @param  string|null $search_tags user defined strings for searching (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateCategory'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CategoryTreeResponse
     */
    public function updateCategory($version, $account_id, $category_id, $parent_category_id = null, $name = null, $description = null, $type = null, $asset_id = null, $external_id = null, $external_type = null, $external_category_slug = null, $sqoot_slug = null, $active = null, $meta_data = null, $search_tags = null, string $contentType = self::contentTypes['updateCategory'][0])
    {
        list($response) = $this->updateCategoryWithHttpInfo($version, $account_id, $category_id, $parent_category_id, $name, $description, $type, $asset_id, $external_id, $external_type, $external_category_slug, $sqoot_slug, $active, $meta_data, $search_tags, $contentType);
        return $response;
    }

    /**
     * Operation updateCategoryWithHttpInfo
     *
     * Update Category
     *
     * @param  float $version (required)
     * @param  int $account_id The account id of the user (required)
     * @param  int $category_id The ID of the category to edit (required)
     * @param  int|null $parent_category_id The ID of the parent category, if not provided then the parent category will be null (optional)
     * @param  string|null $name The name of the category (optional)
     * @param  string|null $description The description of the category (optional)
     * @param  string|null $type The type of the category (optional)
     * @param  int|null $asset_id The ID of the image asset previously uploaded using the media service (optional)
     * @param  string|null $external_id A string identifier used by client applications to store external information (optional)
     * @param  string|null $external_type A string type used by client applications to store external information (optional)
     * @param  string|null $external_category_slug external category slug (optional)
     * @param  string|null $sqoot_slug sqoot slug (optional)
     * @param  bool|null $active Sets whether the category is active or inactive (hidden from consumers) (optional)
     * @param  string|null $meta_data external custom client defined data (optional)
     * @param  string|null $search_tags user defined strings for searching (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateCategory'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CategoryTreeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateCategoryWithHttpInfo($version, $account_id, $category_id, $parent_category_id = null, $name = null, $description = null, $type = null, $asset_id = null, $external_id = null, $external_type = null, $external_category_slug = null, $sqoot_slug = null, $active = null, $meta_data = null, $search_tags = null, string $contentType = self::contentTypes['updateCategory'][0])
    {
        $request = $this->updateCategoryRequest($version, $account_id, $category_id, $parent_category_id, $name, $description, $type, $asset_id, $external_id, $external_type, $external_category_slug, $sqoot_slug, $active, $meta_data, $search_tags, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\CategoryTreeResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\CategoryTreeResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CategoryTreeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateCategoryAsync
     *
     * Update Category
     *
     * @param  float $version (required)
     * @param  int $account_id The account id of the user (required)
     * @param  int $category_id The ID of the category to edit (required)
     * @param  int|null $parent_category_id The ID of the parent category, if not provided then the parent category will be null (optional)
     * @param  string|null $name The name of the category (optional)
     * @param  string|null $description The description of the category (optional)
     * @param  string|null $type The type of the category (optional)
     * @param  int|null $asset_id The ID of the image asset previously uploaded using the media service (optional)
     * @param  string|null $external_id A string identifier used by client applications to store external information (optional)
     * @param  string|null $external_type A string type used by client applications to store external information (optional)
     * @param  string|null $external_category_slug external category slug (optional)
     * @param  string|null $sqoot_slug sqoot slug (optional)
     * @param  bool|null $active Sets whether the category is active or inactive (hidden from consumers) (optional)
     * @param  string|null $meta_data external custom client defined data (optional)
     * @param  string|null $search_tags user defined strings for searching (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateCategory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateCategoryAsync($version, $account_id, $category_id, $parent_category_id = null, $name = null, $description = null, $type = null, $asset_id = null, $external_id = null, $external_type = null, $external_category_slug = null, $sqoot_slug = null, $active = null, $meta_data = null, $search_tags = null, string $contentType = self::contentTypes['updateCategory'][0])
    {
        return $this->updateCategoryAsyncWithHttpInfo($version, $account_id, $category_id, $parent_category_id, $name, $description, $type, $asset_id, $external_id, $external_type, $external_category_slug, $sqoot_slug, $active, $meta_data, $search_tags, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateCategoryAsyncWithHttpInfo
     *
     * Update Category
     *
     * @param  float $version (required)
     * @param  int $account_id The account id of the user (required)
     * @param  int $category_id The ID of the category to edit (required)
     * @param  int|null $parent_category_id The ID of the parent category, if not provided then the parent category will be null (optional)
     * @param  string|null $name The name of the category (optional)
     * @param  string|null $description The description of the category (optional)
     * @param  string|null $type The type of the category (optional)
     * @param  int|null $asset_id The ID of the image asset previously uploaded using the media service (optional)
     * @param  string|null $external_id A string identifier used by client applications to store external information (optional)
     * @param  string|null $external_type A string type used by client applications to store external information (optional)
     * @param  string|null $external_category_slug external category slug (optional)
     * @param  string|null $sqoot_slug sqoot slug (optional)
     * @param  bool|null $active Sets whether the category is active or inactive (hidden from consumers) (optional)
     * @param  string|null $meta_data external custom client defined data (optional)
     * @param  string|null $search_tags user defined strings for searching (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateCategory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateCategoryAsyncWithHttpInfo($version, $account_id, $category_id, $parent_category_id = null, $name = null, $description = null, $type = null, $asset_id = null, $external_id = null, $external_type = null, $external_category_slug = null, $sqoot_slug = null, $active = null, $meta_data = null, $search_tags = null, string $contentType = self::contentTypes['updateCategory'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CategoryTreeResponse';
        $request = $this->updateCategoryRequest($version, $account_id, $category_id, $parent_category_id, $name, $description, $type, $asset_id, $external_id, $external_type, $external_category_slug, $sqoot_slug, $active, $meta_data, $search_tags, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateCategory'
     *
     * @param  float $version (required)
     * @param  int $account_id The account id of the user (required)
     * @param  int $category_id The ID of the category to edit (required)
     * @param  int|null $parent_category_id The ID of the parent category, if not provided then the parent category will be null (optional)
     * @param  string|null $name The name of the category (optional)
     * @param  string|null $description The description of the category (optional)
     * @param  string|null $type The type of the category (optional)
     * @param  int|null $asset_id The ID of the image asset previously uploaded using the media service (optional)
     * @param  string|null $external_id A string identifier used by client applications to store external information (optional)
     * @param  string|null $external_type A string type used by client applications to store external information (optional)
     * @param  string|null $external_category_slug external category slug (optional)
     * @param  string|null $sqoot_slug sqoot slug (optional)
     * @param  bool|null $active Sets whether the category is active or inactive (hidden from consumers) (optional)
     * @param  string|null $meta_data external custom client defined data (optional)
     * @param  string|null $search_tags user defined strings for searching (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateCategory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateCategoryRequest($version, $account_id, $category_id, $parent_category_id = null, $name = null, $description = null, $type = null, $asset_id = null, $external_id = null, $external_type = null, $external_category_slug = null, $sqoot_slug = null, $active = null, $meta_data = null, $search_tags = null, string $contentType = self::contentTypes['updateCategory'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling updateCategory'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling updateCategory'
            );
        }

        // verify the required parameter 'category_id' is set
        if ($category_id === null || (is_array($category_id) && count($category_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $category_id when calling updateCategory'
            );
        }














        $resourcePath = '/api/{version}/category/update';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $category_id,
            'categoryId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $parent_category_id,
            'parentCategoryId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description,
            'description', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type,
            'type', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $asset_id,
            'assetId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $external_id,
            'externalId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $external_type,
            'externalType', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $external_category_slug,
            'externalCategorySlug', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sqoot_slug,
            'sqootSlug', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $active,
            'active', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $meta_data,
            'metaData', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $search_tags,
            'searchTags', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        if ($this->config->getCertFile()) {
            $options[RequestOptions::CERT] = $this->config->getCertFile();
        }

        if ($this->config->getKeyFile()) {
            $options[RequestOptions::SSL_KEY] = $this->config->getKeyFile();
        }

        return $options;
    }

    private function handleResponseWithDataType(
        string $dataType,
        RequestInterface $request,
        ResponseInterface $response
    ): array {
        if ($dataType === '\SplFileObject') {
            $content = $response->getBody(); //stream goes to serializer
        } else {
            $content = (string) $response->getBody();
            if ($dataType !== 'string') {
                try {
                    $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                } catch (\JsonException $exception) {
                    throw new ApiException(
                        sprintf(
                            'Error JSON decoding server response (%s)',
                            $request->getUri()
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                        $content
                    );
                }
            }
        }

        return [
            ObjectSerializer::deserialize($content, $dataType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    private function responseWithinRangeCode(
        string $rangeCode,
        int $statusCode
    ): bool {
        $left = (int) ($rangeCode[0].'00');
        $right = (int) ($rangeCode[0].'99');

        return $statusCode >= $left && $statusCode <= $right;
    }
}
