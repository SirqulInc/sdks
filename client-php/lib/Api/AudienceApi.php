<?php
/**
 * AudienceApi
 * PHP version 8.1
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Sirqul IoT Platform
 *
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.20.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\FormDataProcessor;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * AudienceApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class AudienceApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'createAudience' => [
            'application/json',
        ],
        'deleteAudience' => [
            'application/json',
        ],
        'getAgeGroups' => [
            'application/json',
        ],
        'getAudience' => [
            'application/json',
        ],
        'getAudienceList' => [
            'application/json',
        ],
        'getDevices' => [
            'application/json',
        ],
        'getExperiences' => [
            'application/json',
        ],
        'getGroupedAudiences' => [
            'application/json',
        ],
        'listByAccount' => [
            'application/json',
        ],
        'listByAudience' => [
            'application/json',
        ],
        'listLastestByAccount' => [
            'application/json',
        ],
        'sendByAccount' => [
            'application/json',
        ],
        'updateAudience' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation createAudience
     *
     * Create Audience
     *
     * @param  int $account_id The logged in user. (required)
     * @param  string $name The name of the audience (required)
     * @param  string|null $description The description of the audience (optional)
     * @param  string|null $search_tags The search tags (optional)
     * @param  string|null $gender The gender; possible values are: MALE, FEMALE, ANY (optional)
     * @param  string|null $age_groups The list of age groups, comma separated; possible values are AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS, AGE_ANY (to reset to none) (optional)
     * @param  string|null $category_ids The list of category ids, comma separated; possible values are retrieved via /api/{version}/category/search (pass in id values) (optional)
     * @param  string|null $application_ids The list of application ids, comma separated; possible values are retrieved via /api/{version}/application/list (pass in id values) (optional)
     * @param  string|null $game_experience_level The experience level of the player; possible values are: ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT (optional)
     * @param  string|null $devices (Deprecated) Use deviceIds. The list of targeted device names, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in name values) (optional)
     * @param  string|null $device_ids The list of targeted device ids, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in id values) (optional)
     * @param  string|null $device_versions The list of targeted device version ranges that are aligned with the provided devices list, comma separated (examples: 2.3-X, 0-5.1.4, 4.3.1-6.1.4) (optional)
     * @param  string|null $locations The list of locations to build the center around; comma separated list of latitude/longitude pairs (example: lat1,long1,lat2,long2) (optional)
     * @param  string|null $radius The list of radius of influence for the audience, in miles; comma separated list. Either provide 1 to be applied to all location pairs or a matching list to each lat/long pair. (optional)
     * @param  int|null $start_time_offset Seconds from the start time of an event (optional)
     * @param  int|null $end_time_offset Seconds from the end time of an event (optional)
     * @param  bool|null $send_suggestion If true, then notify matching users when they are inside the radius (optional, default to true)
     * @param  string|null $associate_description The description of the associated object (optional)
     * @param  string|null $associate_type The type of the object to center the audience geofence (optional)
     * @param  int|null $associate_id The ID of the object to center the audience geofence (optional)
     * @param  string|null $grouping_id Optional grouping id for the audience (optional)
     * @param  string|null $meta_data External custom client defined data (optional)
     * @param  string|null $visibility Visibility of the audience (optional)
     * @param  string|null $audience_type Type of audience (optional)
     * @param  bool|null $use_order Use order for cohort (optional)
     * @param  string|null $cohort_regions_data Cohort data for \&quot;cohort\&quot; audience type (optional)
     * @param  string|null $app_key Filter results by application key (optional)
     * @param  string|null $trilateration_types Trilateration types (optional)
     * @param  bool|null $unique_name If true, makes sure the audience name is unique (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAudience'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AudienceResponse
     */
    public function createAudience($account_id, $name, $description = null, $search_tags = null, $gender = null, $age_groups = null, $category_ids = null, $application_ids = null, $game_experience_level = null, $devices = null, $device_ids = null, $device_versions = null, $locations = null, $radius = null, $start_time_offset = null, $end_time_offset = null, $send_suggestion = true, $associate_description = null, $associate_type = null, $associate_id = null, $grouping_id = null, $meta_data = null, $visibility = null, $audience_type = null, $use_order = null, $cohort_regions_data = null, $app_key = null, $trilateration_types = null, $unique_name = null, string $contentType = self::contentTypes['createAudience'][0])
    {
        list($response) = $this->createAudienceWithHttpInfo($account_id, $name, $description, $search_tags, $gender, $age_groups, $category_ids, $application_ids, $game_experience_level, $devices, $device_ids, $device_versions, $locations, $radius, $start_time_offset, $end_time_offset, $send_suggestion, $associate_description, $associate_type, $associate_id, $grouping_id, $meta_data, $visibility, $audience_type, $use_order, $cohort_regions_data, $app_key, $trilateration_types, $unique_name, $contentType);
        return $response;
    }

    /**
     * Operation createAudienceWithHttpInfo
     *
     * Create Audience
     *
     * @param  int $account_id The logged in user. (required)
     * @param  string $name The name of the audience (required)
     * @param  string|null $description The description of the audience (optional)
     * @param  string|null $search_tags The search tags (optional)
     * @param  string|null $gender The gender; possible values are: MALE, FEMALE, ANY (optional)
     * @param  string|null $age_groups The list of age groups, comma separated; possible values are AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS, AGE_ANY (to reset to none) (optional)
     * @param  string|null $category_ids The list of category ids, comma separated; possible values are retrieved via /api/{version}/category/search (pass in id values) (optional)
     * @param  string|null $application_ids The list of application ids, comma separated; possible values are retrieved via /api/{version}/application/list (pass in id values) (optional)
     * @param  string|null $game_experience_level The experience level of the player; possible values are: ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT (optional)
     * @param  string|null $devices (Deprecated) Use deviceIds. The list of targeted device names, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in name values) (optional)
     * @param  string|null $device_ids The list of targeted device ids, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in id values) (optional)
     * @param  string|null $device_versions The list of targeted device version ranges that are aligned with the provided devices list, comma separated (examples: 2.3-X, 0-5.1.4, 4.3.1-6.1.4) (optional)
     * @param  string|null $locations The list of locations to build the center around; comma separated list of latitude/longitude pairs (example: lat1,long1,lat2,long2) (optional)
     * @param  string|null $radius The list of radius of influence for the audience, in miles; comma separated list. Either provide 1 to be applied to all location pairs or a matching list to each lat/long pair. (optional)
     * @param  int|null $start_time_offset Seconds from the start time of an event (optional)
     * @param  int|null $end_time_offset Seconds from the end time of an event (optional)
     * @param  bool|null $send_suggestion If true, then notify matching users when they are inside the radius (optional, default to true)
     * @param  string|null $associate_description The description of the associated object (optional)
     * @param  string|null $associate_type The type of the object to center the audience geofence (optional)
     * @param  int|null $associate_id The ID of the object to center the audience geofence (optional)
     * @param  string|null $grouping_id Optional grouping id for the audience (optional)
     * @param  string|null $meta_data External custom client defined data (optional)
     * @param  string|null $visibility Visibility of the audience (optional)
     * @param  string|null $audience_type Type of audience (optional)
     * @param  bool|null $use_order Use order for cohort (optional)
     * @param  string|null $cohort_regions_data Cohort data for \&quot;cohort\&quot; audience type (optional)
     * @param  string|null $app_key Filter results by application key (optional)
     * @param  string|null $trilateration_types Trilateration types (optional)
     * @param  bool|null $unique_name If true, makes sure the audience name is unique (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAudience'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AudienceResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createAudienceWithHttpInfo($account_id, $name, $description = null, $search_tags = null, $gender = null, $age_groups = null, $category_ids = null, $application_ids = null, $game_experience_level = null, $devices = null, $device_ids = null, $device_versions = null, $locations = null, $radius = null, $start_time_offset = null, $end_time_offset = null, $send_suggestion = true, $associate_description = null, $associate_type = null, $associate_id = null, $grouping_id = null, $meta_data = null, $visibility = null, $audience_type = null, $use_order = null, $cohort_regions_data = null, $app_key = null, $trilateration_types = null, $unique_name = null, string $contentType = self::contentTypes['createAudience'][0])
    {
        $request = $this->createAudienceRequest($account_id, $name, $description, $search_tags, $gender, $age_groups, $category_ids, $application_ids, $game_experience_level, $devices, $device_ids, $device_versions, $locations, $radius, $start_time_offset, $end_time_offset, $send_suggestion, $associate_description, $associate_type, $associate_id, $grouping_id, $meta_data, $visibility, $audience_type, $use_order, $cohort_regions_data, $app_key, $trilateration_types, $unique_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\AudienceResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\AudienceResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AudienceResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createAudienceAsync
     *
     * Create Audience
     *
     * @param  int $account_id The logged in user. (required)
     * @param  string $name The name of the audience (required)
     * @param  string|null $description The description of the audience (optional)
     * @param  string|null $search_tags The search tags (optional)
     * @param  string|null $gender The gender; possible values are: MALE, FEMALE, ANY (optional)
     * @param  string|null $age_groups The list of age groups, comma separated; possible values are AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS, AGE_ANY (to reset to none) (optional)
     * @param  string|null $category_ids The list of category ids, comma separated; possible values are retrieved via /api/{version}/category/search (pass in id values) (optional)
     * @param  string|null $application_ids The list of application ids, comma separated; possible values are retrieved via /api/{version}/application/list (pass in id values) (optional)
     * @param  string|null $game_experience_level The experience level of the player; possible values are: ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT (optional)
     * @param  string|null $devices (Deprecated) Use deviceIds. The list of targeted device names, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in name values) (optional)
     * @param  string|null $device_ids The list of targeted device ids, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in id values) (optional)
     * @param  string|null $device_versions The list of targeted device version ranges that are aligned with the provided devices list, comma separated (examples: 2.3-X, 0-5.1.4, 4.3.1-6.1.4) (optional)
     * @param  string|null $locations The list of locations to build the center around; comma separated list of latitude/longitude pairs (example: lat1,long1,lat2,long2) (optional)
     * @param  string|null $radius The list of radius of influence for the audience, in miles; comma separated list. Either provide 1 to be applied to all location pairs or a matching list to each lat/long pair. (optional)
     * @param  int|null $start_time_offset Seconds from the start time of an event (optional)
     * @param  int|null $end_time_offset Seconds from the end time of an event (optional)
     * @param  bool|null $send_suggestion If true, then notify matching users when they are inside the radius (optional, default to true)
     * @param  string|null $associate_description The description of the associated object (optional)
     * @param  string|null $associate_type The type of the object to center the audience geofence (optional)
     * @param  int|null $associate_id The ID of the object to center the audience geofence (optional)
     * @param  string|null $grouping_id Optional grouping id for the audience (optional)
     * @param  string|null $meta_data External custom client defined data (optional)
     * @param  string|null $visibility Visibility of the audience (optional)
     * @param  string|null $audience_type Type of audience (optional)
     * @param  bool|null $use_order Use order for cohort (optional)
     * @param  string|null $cohort_regions_data Cohort data for \&quot;cohort\&quot; audience type (optional)
     * @param  string|null $app_key Filter results by application key (optional)
     * @param  string|null $trilateration_types Trilateration types (optional)
     * @param  bool|null $unique_name If true, makes sure the audience name is unique (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAudience'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAudienceAsync($account_id, $name, $description = null, $search_tags = null, $gender = null, $age_groups = null, $category_ids = null, $application_ids = null, $game_experience_level = null, $devices = null, $device_ids = null, $device_versions = null, $locations = null, $radius = null, $start_time_offset = null, $end_time_offset = null, $send_suggestion = true, $associate_description = null, $associate_type = null, $associate_id = null, $grouping_id = null, $meta_data = null, $visibility = null, $audience_type = null, $use_order = null, $cohort_regions_data = null, $app_key = null, $trilateration_types = null, $unique_name = null, string $contentType = self::contentTypes['createAudience'][0])
    {
        return $this->createAudienceAsyncWithHttpInfo($account_id, $name, $description, $search_tags, $gender, $age_groups, $category_ids, $application_ids, $game_experience_level, $devices, $device_ids, $device_versions, $locations, $radius, $start_time_offset, $end_time_offset, $send_suggestion, $associate_description, $associate_type, $associate_id, $grouping_id, $meta_data, $visibility, $audience_type, $use_order, $cohort_regions_data, $app_key, $trilateration_types, $unique_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createAudienceAsyncWithHttpInfo
     *
     * Create Audience
     *
     * @param  int $account_id The logged in user. (required)
     * @param  string $name The name of the audience (required)
     * @param  string|null $description The description of the audience (optional)
     * @param  string|null $search_tags The search tags (optional)
     * @param  string|null $gender The gender; possible values are: MALE, FEMALE, ANY (optional)
     * @param  string|null $age_groups The list of age groups, comma separated; possible values are AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS, AGE_ANY (to reset to none) (optional)
     * @param  string|null $category_ids The list of category ids, comma separated; possible values are retrieved via /api/{version}/category/search (pass in id values) (optional)
     * @param  string|null $application_ids The list of application ids, comma separated; possible values are retrieved via /api/{version}/application/list (pass in id values) (optional)
     * @param  string|null $game_experience_level The experience level of the player; possible values are: ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT (optional)
     * @param  string|null $devices (Deprecated) Use deviceIds. The list of targeted device names, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in name values) (optional)
     * @param  string|null $device_ids The list of targeted device ids, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in id values) (optional)
     * @param  string|null $device_versions The list of targeted device version ranges that are aligned with the provided devices list, comma separated (examples: 2.3-X, 0-5.1.4, 4.3.1-6.1.4) (optional)
     * @param  string|null $locations The list of locations to build the center around; comma separated list of latitude/longitude pairs (example: lat1,long1,lat2,long2) (optional)
     * @param  string|null $radius The list of radius of influence for the audience, in miles; comma separated list. Either provide 1 to be applied to all location pairs or a matching list to each lat/long pair. (optional)
     * @param  int|null $start_time_offset Seconds from the start time of an event (optional)
     * @param  int|null $end_time_offset Seconds from the end time of an event (optional)
     * @param  bool|null $send_suggestion If true, then notify matching users when they are inside the radius (optional, default to true)
     * @param  string|null $associate_description The description of the associated object (optional)
     * @param  string|null $associate_type The type of the object to center the audience geofence (optional)
     * @param  int|null $associate_id The ID of the object to center the audience geofence (optional)
     * @param  string|null $grouping_id Optional grouping id for the audience (optional)
     * @param  string|null $meta_data External custom client defined data (optional)
     * @param  string|null $visibility Visibility of the audience (optional)
     * @param  string|null $audience_type Type of audience (optional)
     * @param  bool|null $use_order Use order for cohort (optional)
     * @param  string|null $cohort_regions_data Cohort data for \&quot;cohort\&quot; audience type (optional)
     * @param  string|null $app_key Filter results by application key (optional)
     * @param  string|null $trilateration_types Trilateration types (optional)
     * @param  bool|null $unique_name If true, makes sure the audience name is unique (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAudience'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAudienceAsyncWithHttpInfo($account_id, $name, $description = null, $search_tags = null, $gender = null, $age_groups = null, $category_ids = null, $application_ids = null, $game_experience_level = null, $devices = null, $device_ids = null, $device_versions = null, $locations = null, $radius = null, $start_time_offset = null, $end_time_offset = null, $send_suggestion = true, $associate_description = null, $associate_type = null, $associate_id = null, $grouping_id = null, $meta_data = null, $visibility = null, $audience_type = null, $use_order = null, $cohort_regions_data = null, $app_key = null, $trilateration_types = null, $unique_name = null, string $contentType = self::contentTypes['createAudience'][0])
    {
        $returnType = '\OpenAPI\Client\Model\AudienceResponse';
        $request = $this->createAudienceRequest($account_id, $name, $description, $search_tags, $gender, $age_groups, $category_ids, $application_ids, $game_experience_level, $devices, $device_ids, $device_versions, $locations, $radius, $start_time_offset, $end_time_offset, $send_suggestion, $associate_description, $associate_type, $associate_id, $grouping_id, $meta_data, $visibility, $audience_type, $use_order, $cohort_regions_data, $app_key, $trilateration_types, $unique_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createAudience'
     *
     * @param  int $account_id The logged in user. (required)
     * @param  string $name The name of the audience (required)
     * @param  string|null $description The description of the audience (optional)
     * @param  string|null $search_tags The search tags (optional)
     * @param  string|null $gender The gender; possible values are: MALE, FEMALE, ANY (optional)
     * @param  string|null $age_groups The list of age groups, comma separated; possible values are AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS, AGE_ANY (to reset to none) (optional)
     * @param  string|null $category_ids The list of category ids, comma separated; possible values are retrieved via /api/{version}/category/search (pass in id values) (optional)
     * @param  string|null $application_ids The list of application ids, comma separated; possible values are retrieved via /api/{version}/application/list (pass in id values) (optional)
     * @param  string|null $game_experience_level The experience level of the player; possible values are: ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT (optional)
     * @param  string|null $devices (Deprecated) Use deviceIds. The list of targeted device names, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in name values) (optional)
     * @param  string|null $device_ids The list of targeted device ids, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in id values) (optional)
     * @param  string|null $device_versions The list of targeted device version ranges that are aligned with the provided devices list, comma separated (examples: 2.3-X, 0-5.1.4, 4.3.1-6.1.4) (optional)
     * @param  string|null $locations The list of locations to build the center around; comma separated list of latitude/longitude pairs (example: lat1,long1,lat2,long2) (optional)
     * @param  string|null $radius The list of radius of influence for the audience, in miles; comma separated list. Either provide 1 to be applied to all location pairs or a matching list to each lat/long pair. (optional)
     * @param  int|null $start_time_offset Seconds from the start time of an event (optional)
     * @param  int|null $end_time_offset Seconds from the end time of an event (optional)
     * @param  bool|null $send_suggestion If true, then notify matching users when they are inside the radius (optional, default to true)
     * @param  string|null $associate_description The description of the associated object (optional)
     * @param  string|null $associate_type The type of the object to center the audience geofence (optional)
     * @param  int|null $associate_id The ID of the object to center the audience geofence (optional)
     * @param  string|null $grouping_id Optional grouping id for the audience (optional)
     * @param  string|null $meta_data External custom client defined data (optional)
     * @param  string|null $visibility Visibility of the audience (optional)
     * @param  string|null $audience_type Type of audience (optional)
     * @param  bool|null $use_order Use order for cohort (optional)
     * @param  string|null $cohort_regions_data Cohort data for \&quot;cohort\&quot; audience type (optional)
     * @param  string|null $app_key Filter results by application key (optional)
     * @param  string|null $trilateration_types Trilateration types (optional)
     * @param  bool|null $unique_name If true, makes sure the audience name is unique (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAudience'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createAudienceRequest($account_id, $name, $description = null, $search_tags = null, $gender = null, $age_groups = null, $category_ids = null, $application_ids = null, $game_experience_level = null, $devices = null, $device_ids = null, $device_versions = null, $locations = null, $radius = null, $start_time_offset = null, $end_time_offset = null, $send_suggestion = true, $associate_description = null, $associate_type = null, $associate_id = null, $grouping_id = null, $meta_data = null, $visibility = null, $audience_type = null, $use_order = null, $cohort_regions_data = null, $app_key = null, $trilateration_types = null, $unique_name = null, string $contentType = self::contentTypes['createAudience'][0])
    {

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling createAudience'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling createAudience'
            );
        }





























        $resourcePath = '/audience/create';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description,
            'description', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $search_tags,
            'searchTags', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $gender,
            'gender', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $age_groups,
            'ageGroups', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $category_ids,
            'categoryIds', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $application_ids,
            'applicationIds', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $game_experience_level,
            'gameExperienceLevel', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $devices,
            'devices', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_ids,
            'deviceIds', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_versions,
            'deviceVersions', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $locations,
            'locations', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $radius,
            'radius', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_time_offset,
            'startTimeOffset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_time_offset,
            'endTimeOffset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $send_suggestion,
            'sendSuggestion', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $associate_description,
            'associateDescription', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $associate_type,
            'associateType', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $associate_id,
            'associateId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $grouping_id,
            'groupingId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $meta_data,
            'metaData', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $visibility,
            'visibility', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audience_type,
            'audienceType', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $use_order,
            'useOrder', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cohort_regions_data,
            'cohortRegionsData', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $app_key,
            'appKey', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $trilateration_types,
            'trilaterationTypes', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $unique_name,
            'uniqueName', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteAudience
     *
     * Delete Audience
     *
     * @param  int $account_id The logged in user. (required)
     * @param  int $audience_id The id of the audience to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAudience'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SirqulResponse
     */
    public function deleteAudience($account_id, $audience_id, string $contentType = self::contentTypes['deleteAudience'][0])
    {
        list($response) = $this->deleteAudienceWithHttpInfo($account_id, $audience_id, $contentType);
        return $response;
    }

    /**
     * Operation deleteAudienceWithHttpInfo
     *
     * Delete Audience
     *
     * @param  int $account_id The logged in user. (required)
     * @param  int $audience_id The id of the audience to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAudience'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SirqulResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteAudienceWithHttpInfo($account_id, $audience_id, string $contentType = self::contentTypes['deleteAudience'][0])
    {
        $request = $this->deleteAudienceRequest($account_id, $audience_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\SirqulResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\SirqulResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SirqulResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteAudienceAsync
     *
     * Delete Audience
     *
     * @param  int $account_id The logged in user. (required)
     * @param  int $audience_id The id of the audience to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAudience'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAudienceAsync($account_id, $audience_id, string $contentType = self::contentTypes['deleteAudience'][0])
    {
        return $this->deleteAudienceAsyncWithHttpInfo($account_id, $audience_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteAudienceAsyncWithHttpInfo
     *
     * Delete Audience
     *
     * @param  int $account_id The logged in user. (required)
     * @param  int $audience_id The id of the audience to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAudience'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAudienceAsyncWithHttpInfo($account_id, $audience_id, string $contentType = self::contentTypes['deleteAudience'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SirqulResponse';
        $request = $this->deleteAudienceRequest($account_id, $audience_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteAudience'
     *
     * @param  int $account_id The logged in user. (required)
     * @param  int $audience_id The id of the audience to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAudience'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteAudienceRequest($account_id, $audience_id, string $contentType = self::contentTypes['deleteAudience'][0])
    {

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling deleteAudience'
            );
        }

        // verify the required parameter 'audience_id' is set
        if ($audience_id === null || (is_array($audience_id) && count($audience_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $audience_id when calling deleteAudience'
            );
        }


        $resourcePath = '/audience/delete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audience_id,
            'audienceId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAgeGroups
     *
     * Get Age Groups
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAgeGroups'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AgeGroupResponse[]
     */
    public function getAgeGroups(string $contentType = self::contentTypes['getAgeGroups'][0])
    {
        list($response) = $this->getAgeGroupsWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getAgeGroupsWithHttpInfo
     *
     * Get Age Groups
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAgeGroups'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AgeGroupResponse[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getAgeGroupsWithHttpInfo(string $contentType = self::contentTypes['getAgeGroups'][0])
    {
        $request = $this->getAgeGroupsRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\AgeGroupResponse[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\AgeGroupResponse[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AgeGroupResponse[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getAgeGroupsAsync
     *
     * Get Age Groups
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAgeGroups'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAgeGroupsAsync(string $contentType = self::contentTypes['getAgeGroups'][0])
    {
        return $this->getAgeGroupsAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAgeGroupsAsyncWithHttpInfo
     *
     * Get Age Groups
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAgeGroups'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAgeGroupsAsyncWithHttpInfo(string $contentType = self::contentTypes['getAgeGroups'][0])
    {
        $returnType = '\OpenAPI\Client\Model\AgeGroupResponse[]';
        $request = $this->getAgeGroupsRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAgeGroups'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAgeGroups'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAgeGroupsRequest(string $contentType = self::contentTypes['getAgeGroups'][0])
    {


        $resourcePath = '/audience/ageGroups';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAudience
     *
     * Get Audience
     *
     * @param  int $account_id The logged in user. (required)
     * @param  int $audience_id The id of the audience to return. (required)
     * @param  string|null $app_key The application key (optional). If provided, results may be scoped to this application. (optional)
     * @param  bool|null $return_account_count (boolean) set to true to include the accountCount associated with current audience of the current app (optional, default to false)
     * @param  bool|null $return_album_count (boolean) set to true to include the albumCount associated with current audience of the current app (optional, default to false)
     * @param  string|null $album_types_for_count (String) comma separated list, return an array with each item is the count of each album type. If not provided, \&quot;all_types\&quot; count is returned. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAudience'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AudienceResponse
     */
    public function getAudience($account_id, $audience_id, $app_key = null, $return_account_count = false, $return_album_count = false, $album_types_for_count = null, string $contentType = self::contentTypes['getAudience'][0])
    {
        list($response) = $this->getAudienceWithHttpInfo($account_id, $audience_id, $app_key, $return_account_count, $return_album_count, $album_types_for_count, $contentType);
        return $response;
    }

    /**
     * Operation getAudienceWithHttpInfo
     *
     * Get Audience
     *
     * @param  int $account_id The logged in user. (required)
     * @param  int $audience_id The id of the audience to return. (required)
     * @param  string|null $app_key The application key (optional). If provided, results may be scoped to this application. (optional)
     * @param  bool|null $return_account_count (boolean) set to true to include the accountCount associated with current audience of the current app (optional, default to false)
     * @param  bool|null $return_album_count (boolean) set to true to include the albumCount associated with current audience of the current app (optional, default to false)
     * @param  string|null $album_types_for_count (String) comma separated list, return an array with each item is the count of each album type. If not provided, \&quot;all_types\&quot; count is returned. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAudience'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AudienceResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAudienceWithHttpInfo($account_id, $audience_id, $app_key = null, $return_account_count = false, $return_album_count = false, $album_types_for_count = null, string $contentType = self::contentTypes['getAudience'][0])
    {
        $request = $this->getAudienceRequest($account_id, $audience_id, $app_key, $return_account_count, $return_album_count, $album_types_for_count, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\AudienceResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\AudienceResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AudienceResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getAudienceAsync
     *
     * Get Audience
     *
     * @param  int $account_id The logged in user. (required)
     * @param  int $audience_id The id of the audience to return. (required)
     * @param  string|null $app_key The application key (optional). If provided, results may be scoped to this application. (optional)
     * @param  bool|null $return_account_count (boolean) set to true to include the accountCount associated with current audience of the current app (optional, default to false)
     * @param  bool|null $return_album_count (boolean) set to true to include the albumCount associated with current audience of the current app (optional, default to false)
     * @param  string|null $album_types_for_count (String) comma separated list, return an array with each item is the count of each album type. If not provided, \&quot;all_types\&quot; count is returned. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAudience'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAudienceAsync($account_id, $audience_id, $app_key = null, $return_account_count = false, $return_album_count = false, $album_types_for_count = null, string $contentType = self::contentTypes['getAudience'][0])
    {
        return $this->getAudienceAsyncWithHttpInfo($account_id, $audience_id, $app_key, $return_account_count, $return_album_count, $album_types_for_count, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAudienceAsyncWithHttpInfo
     *
     * Get Audience
     *
     * @param  int $account_id The logged in user. (required)
     * @param  int $audience_id The id of the audience to return. (required)
     * @param  string|null $app_key The application key (optional). If provided, results may be scoped to this application. (optional)
     * @param  bool|null $return_account_count (boolean) set to true to include the accountCount associated with current audience of the current app (optional, default to false)
     * @param  bool|null $return_album_count (boolean) set to true to include the albumCount associated with current audience of the current app (optional, default to false)
     * @param  string|null $album_types_for_count (String) comma separated list, return an array with each item is the count of each album type. If not provided, \&quot;all_types\&quot; count is returned. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAudience'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAudienceAsyncWithHttpInfo($account_id, $audience_id, $app_key = null, $return_account_count = false, $return_album_count = false, $album_types_for_count = null, string $contentType = self::contentTypes['getAudience'][0])
    {
        $returnType = '\OpenAPI\Client\Model\AudienceResponse';
        $request = $this->getAudienceRequest($account_id, $audience_id, $app_key, $return_account_count, $return_album_count, $album_types_for_count, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAudience'
     *
     * @param  int $account_id The logged in user. (required)
     * @param  int $audience_id The id of the audience to return. (required)
     * @param  string|null $app_key The application key (optional). If provided, results may be scoped to this application. (optional)
     * @param  bool|null $return_account_count (boolean) set to true to include the accountCount associated with current audience of the current app (optional, default to false)
     * @param  bool|null $return_album_count (boolean) set to true to include the albumCount associated with current audience of the current app (optional, default to false)
     * @param  string|null $album_types_for_count (String) comma separated list, return an array with each item is the count of each album type. If not provided, \&quot;all_types\&quot; count is returned. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAudience'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAudienceRequest($account_id, $audience_id, $app_key = null, $return_account_count = false, $return_album_count = false, $album_types_for_count = null, string $contentType = self::contentTypes['getAudience'][0])
    {

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling getAudience'
            );
        }

        // verify the required parameter 'audience_id' is set
        if ($audience_id === null || (is_array($audience_id) && count($audience_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $audience_id when calling getAudience'
            );
        }






        $resourcePath = '/audience/get';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audience_id,
            'audienceId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $app_key,
            'appKey', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_account_count,
            'returnAccountCount', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_album_count,
            'returnAlbumCount', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $album_types_for_count,
            'albumTypesForCount', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAudienceList
     *
     * Search Audiences
     *
     * @param  int|null $account_id The logged in user. (optional)
     * @param  string|null $album_ids Comma separated list of album IDs to filter results with (optional)
     * @param  string|null $keyword The keyword used to search (optional)
     * @param  string|null $keyword_fields Comma separated list of fields that the keywords will match against. Possible values include: SEARCH_TAGS, NAME, DESCRIPTION, OWNER_DISPLAY (optional, default to 'SEARCH_TAGS,NAME,DESCRIPTION')
     * @param  string|null $sort_field The field to sort by, possible values include: {ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, NAME, DESCRIPTION, OWNER_ID, OWNER_DISPLAY, GENDER} (optional, default to 'NAME')
     * @param  bool|null $descending The order to return the results. Default is false, which will return the results in ascending order. (optional, default to false)
     * @param  int|null $start The index into the record set to start with. (optional, default to 0)
     * @param  int|null $limit The total number of record to return (there is a hard limit of 100). (optional, default to 20)
     * @param  bool|null $send_suggestion Filter results based on whether or not the audience is set to send suggestions (optional)
     * @param  bool|null $active_only Determines whether to return only active results. Default is false. (optional)
     * @param  bool|null $group_by_grouping_id Groups results by the audience groupingId (this does not work in conjunction with the following parameters: albumIds, audienceType, appKey, returnGlobal) (optional)
     * @param  string|null $app_key Filter results by application key (optional)
     * @param  bool|null $return_global If filtering by appKey, determines whether or not audiences that do not have an application set will also be returned as well (optional)
     * @param  bool|null $exact_keyword If true, match keyword exactly (optional)
     * @param  string|null $audience_type (Deprecated) Filter results by audience type (optional)
     * @param  string|null $audience_types comma separated string with the different audience types you want to filter for (optional)
     * @param  bool|null $return_account_count (boolean) set to true to include the accountCount associated with current audience of the current app (optional, default to false)
     * @param  bool|null $return_album_count (boolean) set to true to include the albumCount associated with current audience of the current app (optional, default to false)
     * @param  string|null $album_types_for_count (String) comma separated list, return an array with each item is the count of each album type. If not provided, \&quot;all_types\&quot; count is returned. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAudienceList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SearchResponse[]
     */
    public function getAudienceList($account_id = null, $album_ids = null, $keyword = null, $keyword_fields = 'SEARCH_TAGS,NAME,DESCRIPTION', $sort_field = 'NAME', $descending = false, $start = 0, $limit = 20, $send_suggestion = null, $active_only = null, $group_by_grouping_id = null, $app_key = null, $return_global = null, $exact_keyword = null, $audience_type = null, $audience_types = null, $return_account_count = false, $return_album_count = false, $album_types_for_count = null, string $contentType = self::contentTypes['getAudienceList'][0])
    {
        list($response) = $this->getAudienceListWithHttpInfo($account_id, $album_ids, $keyword, $keyword_fields, $sort_field, $descending, $start, $limit, $send_suggestion, $active_only, $group_by_grouping_id, $app_key, $return_global, $exact_keyword, $audience_type, $audience_types, $return_account_count, $return_album_count, $album_types_for_count, $contentType);
        return $response;
    }

    /**
     * Operation getAudienceListWithHttpInfo
     *
     * Search Audiences
     *
     * @param  int|null $account_id The logged in user. (optional)
     * @param  string|null $album_ids Comma separated list of album IDs to filter results with (optional)
     * @param  string|null $keyword The keyword used to search (optional)
     * @param  string|null $keyword_fields Comma separated list of fields that the keywords will match against. Possible values include: SEARCH_TAGS, NAME, DESCRIPTION, OWNER_DISPLAY (optional, default to 'SEARCH_TAGS,NAME,DESCRIPTION')
     * @param  string|null $sort_field The field to sort by, possible values include: {ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, NAME, DESCRIPTION, OWNER_ID, OWNER_DISPLAY, GENDER} (optional, default to 'NAME')
     * @param  bool|null $descending The order to return the results. Default is false, which will return the results in ascending order. (optional, default to false)
     * @param  int|null $start The index into the record set to start with. (optional, default to 0)
     * @param  int|null $limit The total number of record to return (there is a hard limit of 100). (optional, default to 20)
     * @param  bool|null $send_suggestion Filter results based on whether or not the audience is set to send suggestions (optional)
     * @param  bool|null $active_only Determines whether to return only active results. Default is false. (optional)
     * @param  bool|null $group_by_grouping_id Groups results by the audience groupingId (this does not work in conjunction with the following parameters: albumIds, audienceType, appKey, returnGlobal) (optional)
     * @param  string|null $app_key Filter results by application key (optional)
     * @param  bool|null $return_global If filtering by appKey, determines whether or not audiences that do not have an application set will also be returned as well (optional)
     * @param  bool|null $exact_keyword If true, match keyword exactly (optional)
     * @param  string|null $audience_type (Deprecated) Filter results by audience type (optional)
     * @param  string|null $audience_types comma separated string with the different audience types you want to filter for (optional)
     * @param  bool|null $return_account_count (boolean) set to true to include the accountCount associated with current audience of the current app (optional, default to false)
     * @param  bool|null $return_album_count (boolean) set to true to include the albumCount associated with current audience of the current app (optional, default to false)
     * @param  string|null $album_types_for_count (String) comma separated list, return an array with each item is the count of each album type. If not provided, \&quot;all_types\&quot; count is returned. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAudienceList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SearchResponse[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getAudienceListWithHttpInfo($account_id = null, $album_ids = null, $keyword = null, $keyword_fields = 'SEARCH_TAGS,NAME,DESCRIPTION', $sort_field = 'NAME', $descending = false, $start = 0, $limit = 20, $send_suggestion = null, $active_only = null, $group_by_grouping_id = null, $app_key = null, $return_global = null, $exact_keyword = null, $audience_type = null, $audience_types = null, $return_account_count = false, $return_album_count = false, $album_types_for_count = null, string $contentType = self::contentTypes['getAudienceList'][0])
    {
        $request = $this->getAudienceListRequest($account_id, $album_ids, $keyword, $keyword_fields, $sort_field, $descending, $start, $limit, $send_suggestion, $active_only, $group_by_grouping_id, $app_key, $return_global, $exact_keyword, $audience_type, $audience_types, $return_account_count, $return_album_count, $album_types_for_count, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\SearchResponse[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\SearchResponse[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SearchResponse[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getAudienceListAsync
     *
     * Search Audiences
     *
     * @param  int|null $account_id The logged in user. (optional)
     * @param  string|null $album_ids Comma separated list of album IDs to filter results with (optional)
     * @param  string|null $keyword The keyword used to search (optional)
     * @param  string|null $keyword_fields Comma separated list of fields that the keywords will match against. Possible values include: SEARCH_TAGS, NAME, DESCRIPTION, OWNER_DISPLAY (optional, default to 'SEARCH_TAGS,NAME,DESCRIPTION')
     * @param  string|null $sort_field The field to sort by, possible values include: {ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, NAME, DESCRIPTION, OWNER_ID, OWNER_DISPLAY, GENDER} (optional, default to 'NAME')
     * @param  bool|null $descending The order to return the results. Default is false, which will return the results in ascending order. (optional, default to false)
     * @param  int|null $start The index into the record set to start with. (optional, default to 0)
     * @param  int|null $limit The total number of record to return (there is a hard limit of 100). (optional, default to 20)
     * @param  bool|null $send_suggestion Filter results based on whether or not the audience is set to send suggestions (optional)
     * @param  bool|null $active_only Determines whether to return only active results. Default is false. (optional)
     * @param  bool|null $group_by_grouping_id Groups results by the audience groupingId (this does not work in conjunction with the following parameters: albumIds, audienceType, appKey, returnGlobal) (optional)
     * @param  string|null $app_key Filter results by application key (optional)
     * @param  bool|null $return_global If filtering by appKey, determines whether or not audiences that do not have an application set will also be returned as well (optional)
     * @param  bool|null $exact_keyword If true, match keyword exactly (optional)
     * @param  string|null $audience_type (Deprecated) Filter results by audience type (optional)
     * @param  string|null $audience_types comma separated string with the different audience types you want to filter for (optional)
     * @param  bool|null $return_account_count (boolean) set to true to include the accountCount associated with current audience of the current app (optional, default to false)
     * @param  bool|null $return_album_count (boolean) set to true to include the albumCount associated with current audience of the current app (optional, default to false)
     * @param  string|null $album_types_for_count (String) comma separated list, return an array with each item is the count of each album type. If not provided, \&quot;all_types\&quot; count is returned. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAudienceList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAudienceListAsync($account_id = null, $album_ids = null, $keyword = null, $keyword_fields = 'SEARCH_TAGS,NAME,DESCRIPTION', $sort_field = 'NAME', $descending = false, $start = 0, $limit = 20, $send_suggestion = null, $active_only = null, $group_by_grouping_id = null, $app_key = null, $return_global = null, $exact_keyword = null, $audience_type = null, $audience_types = null, $return_account_count = false, $return_album_count = false, $album_types_for_count = null, string $contentType = self::contentTypes['getAudienceList'][0])
    {
        return $this->getAudienceListAsyncWithHttpInfo($account_id, $album_ids, $keyword, $keyword_fields, $sort_field, $descending, $start, $limit, $send_suggestion, $active_only, $group_by_grouping_id, $app_key, $return_global, $exact_keyword, $audience_type, $audience_types, $return_account_count, $return_album_count, $album_types_for_count, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAudienceListAsyncWithHttpInfo
     *
     * Search Audiences
     *
     * @param  int|null $account_id The logged in user. (optional)
     * @param  string|null $album_ids Comma separated list of album IDs to filter results with (optional)
     * @param  string|null $keyword The keyword used to search (optional)
     * @param  string|null $keyword_fields Comma separated list of fields that the keywords will match against. Possible values include: SEARCH_TAGS, NAME, DESCRIPTION, OWNER_DISPLAY (optional, default to 'SEARCH_TAGS,NAME,DESCRIPTION')
     * @param  string|null $sort_field The field to sort by, possible values include: {ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, NAME, DESCRIPTION, OWNER_ID, OWNER_DISPLAY, GENDER} (optional, default to 'NAME')
     * @param  bool|null $descending The order to return the results. Default is false, which will return the results in ascending order. (optional, default to false)
     * @param  int|null $start The index into the record set to start with. (optional, default to 0)
     * @param  int|null $limit The total number of record to return (there is a hard limit of 100). (optional, default to 20)
     * @param  bool|null $send_suggestion Filter results based on whether or not the audience is set to send suggestions (optional)
     * @param  bool|null $active_only Determines whether to return only active results. Default is false. (optional)
     * @param  bool|null $group_by_grouping_id Groups results by the audience groupingId (this does not work in conjunction with the following parameters: albumIds, audienceType, appKey, returnGlobal) (optional)
     * @param  string|null $app_key Filter results by application key (optional)
     * @param  bool|null $return_global If filtering by appKey, determines whether or not audiences that do not have an application set will also be returned as well (optional)
     * @param  bool|null $exact_keyword If true, match keyword exactly (optional)
     * @param  string|null $audience_type (Deprecated) Filter results by audience type (optional)
     * @param  string|null $audience_types comma separated string with the different audience types you want to filter for (optional)
     * @param  bool|null $return_account_count (boolean) set to true to include the accountCount associated with current audience of the current app (optional, default to false)
     * @param  bool|null $return_album_count (boolean) set to true to include the albumCount associated with current audience of the current app (optional, default to false)
     * @param  string|null $album_types_for_count (String) comma separated list, return an array with each item is the count of each album type. If not provided, \&quot;all_types\&quot; count is returned. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAudienceList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAudienceListAsyncWithHttpInfo($account_id = null, $album_ids = null, $keyword = null, $keyword_fields = 'SEARCH_TAGS,NAME,DESCRIPTION', $sort_field = 'NAME', $descending = false, $start = 0, $limit = 20, $send_suggestion = null, $active_only = null, $group_by_grouping_id = null, $app_key = null, $return_global = null, $exact_keyword = null, $audience_type = null, $audience_types = null, $return_account_count = false, $return_album_count = false, $album_types_for_count = null, string $contentType = self::contentTypes['getAudienceList'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SearchResponse[]';
        $request = $this->getAudienceListRequest($account_id, $album_ids, $keyword, $keyword_fields, $sort_field, $descending, $start, $limit, $send_suggestion, $active_only, $group_by_grouping_id, $app_key, $return_global, $exact_keyword, $audience_type, $audience_types, $return_account_count, $return_album_count, $album_types_for_count, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAudienceList'
     *
     * @param  int|null $account_id The logged in user. (optional)
     * @param  string|null $album_ids Comma separated list of album IDs to filter results with (optional)
     * @param  string|null $keyword The keyword used to search (optional)
     * @param  string|null $keyword_fields Comma separated list of fields that the keywords will match against. Possible values include: SEARCH_TAGS, NAME, DESCRIPTION, OWNER_DISPLAY (optional, default to 'SEARCH_TAGS,NAME,DESCRIPTION')
     * @param  string|null $sort_field The field to sort by, possible values include: {ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, NAME, DESCRIPTION, OWNER_ID, OWNER_DISPLAY, GENDER} (optional, default to 'NAME')
     * @param  bool|null $descending The order to return the results. Default is false, which will return the results in ascending order. (optional, default to false)
     * @param  int|null $start The index into the record set to start with. (optional, default to 0)
     * @param  int|null $limit The total number of record to return (there is a hard limit of 100). (optional, default to 20)
     * @param  bool|null $send_suggestion Filter results based on whether or not the audience is set to send suggestions (optional)
     * @param  bool|null $active_only Determines whether to return only active results. Default is false. (optional)
     * @param  bool|null $group_by_grouping_id Groups results by the audience groupingId (this does not work in conjunction with the following parameters: albumIds, audienceType, appKey, returnGlobal) (optional)
     * @param  string|null $app_key Filter results by application key (optional)
     * @param  bool|null $return_global If filtering by appKey, determines whether or not audiences that do not have an application set will also be returned as well (optional)
     * @param  bool|null $exact_keyword If true, match keyword exactly (optional)
     * @param  string|null $audience_type (Deprecated) Filter results by audience type (optional)
     * @param  string|null $audience_types comma separated string with the different audience types you want to filter for (optional)
     * @param  bool|null $return_account_count (boolean) set to true to include the accountCount associated with current audience of the current app (optional, default to false)
     * @param  bool|null $return_album_count (boolean) set to true to include the albumCount associated with current audience of the current app (optional, default to false)
     * @param  string|null $album_types_for_count (String) comma separated list, return an array with each item is the count of each album type. If not provided, \&quot;all_types\&quot; count is returned. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAudienceList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAudienceListRequest($account_id = null, $album_ids = null, $keyword = null, $keyword_fields = 'SEARCH_TAGS,NAME,DESCRIPTION', $sort_field = 'NAME', $descending = false, $start = 0, $limit = 20, $send_suggestion = null, $active_only = null, $group_by_grouping_id = null, $app_key = null, $return_global = null, $exact_keyword = null, $audience_type = null, $audience_types = null, $return_account_count = false, $return_album_count = false, $album_types_for_count = null, string $contentType = self::contentTypes['getAudienceList'][0])
    {





















        $resourcePath = '/audience/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $album_ids,
            'albumIds', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $keyword,
            'keyword', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $keyword_fields,
            'keywordFields', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort_field,
            'sortField', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $descending,
            'descending', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start,
            'start', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $send_suggestion,
            'sendSuggestion', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $active_only,
            'activeOnly', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $group_by_grouping_id,
            'groupByGroupingId', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $app_key,
            'appKey', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_global,
            'returnGlobal', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $exact_keyword,
            'exactKeyword', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audience_type,
            'audienceType', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audience_types,
            'audienceTypes', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_account_count,
            'returnAccountCount', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_album_count,
            'returnAlbumCount', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $album_types_for_count,
            'albumTypesForCount', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDevices
     *
     * Get Devices
     *
     * @param  bool $include_inactive If true return inactive record as well. default is false. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDevices'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AudienceDeviceResponse[]
     */
    public function getDevices($include_inactive, string $contentType = self::contentTypes['getDevices'][0])
    {
        list($response) = $this->getDevicesWithHttpInfo($include_inactive, $contentType);
        return $response;
    }

    /**
     * Operation getDevicesWithHttpInfo
     *
     * Get Devices
     *
     * @param  bool $include_inactive If true return inactive record as well. default is false. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDevices'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AudienceDeviceResponse[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getDevicesWithHttpInfo($include_inactive, string $contentType = self::contentTypes['getDevices'][0])
    {
        $request = $this->getDevicesRequest($include_inactive, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\AudienceDeviceResponse[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\AudienceDeviceResponse[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AudienceDeviceResponse[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getDevicesAsync
     *
     * Get Devices
     *
     * @param  bool $include_inactive If true return inactive record as well. default is false. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDevices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDevicesAsync($include_inactive, string $contentType = self::contentTypes['getDevices'][0])
    {
        return $this->getDevicesAsyncWithHttpInfo($include_inactive, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDevicesAsyncWithHttpInfo
     *
     * Get Devices
     *
     * @param  bool $include_inactive If true return inactive record as well. default is false. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDevices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDevicesAsyncWithHttpInfo($include_inactive, string $contentType = self::contentTypes['getDevices'][0])
    {
        $returnType = '\OpenAPI\Client\Model\AudienceDeviceResponse[]';
        $request = $this->getDevicesRequest($include_inactive, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDevices'
     *
     * @param  bool $include_inactive If true return inactive record as well. default is false. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDevices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getDevicesRequest($include_inactive, string $contentType = self::contentTypes['getDevices'][0])
    {

        // verify the required parameter 'include_inactive' is set
        if ($include_inactive === null || (is_array($include_inactive) && count($include_inactive) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $include_inactive when calling getDevices'
            );
        }


        $resourcePath = '/audience/devices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_inactive,
            'includeInactive', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getExperiences
     *
     * Get Experiences
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getExperiences'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SirqulResponse
     */
    public function getExperiences(string $contentType = self::contentTypes['getExperiences'][0])
    {
        list($response) = $this->getExperiencesWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getExperiencesWithHttpInfo
     *
     * Get Experiences
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getExperiences'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SirqulResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getExperiencesWithHttpInfo(string $contentType = self::contentTypes['getExperiences'][0])
    {
        $request = $this->getExperiencesRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\SirqulResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\SirqulResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SirqulResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getExperiencesAsync
     *
     * Get Experiences
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getExperiences'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getExperiencesAsync(string $contentType = self::contentTypes['getExperiences'][0])
    {
        return $this->getExperiencesAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getExperiencesAsyncWithHttpInfo
     *
     * Get Experiences
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getExperiences'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getExperiencesAsyncWithHttpInfo(string $contentType = self::contentTypes['getExperiences'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SirqulResponse';
        $request = $this->getExperiencesRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getExperiences'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getExperiences'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getExperiencesRequest(string $contentType = self::contentTypes['getExperiences'][0])
    {


        $resourcePath = '/audience/experiences';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getGroupedAudiences
     *
     * Get GroupedAudiences
     *
     * @param  int $account_id The logged in user. (required)
     * @param  string $audience_grouping_id The audience grouping id to return. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGroupedAudiences'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AudienceResponse
     */
    public function getGroupedAudiences($account_id, $audience_grouping_id, string $contentType = self::contentTypes['getGroupedAudiences'][0])
    {
        list($response) = $this->getGroupedAudiencesWithHttpInfo($account_id, $audience_grouping_id, $contentType);
        return $response;
    }

    /**
     * Operation getGroupedAudiencesWithHttpInfo
     *
     * Get GroupedAudiences
     *
     * @param  int $account_id The logged in user. (required)
     * @param  string $audience_grouping_id The audience grouping id to return. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGroupedAudiences'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AudienceResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getGroupedAudiencesWithHttpInfo($account_id, $audience_grouping_id, string $contentType = self::contentTypes['getGroupedAudiences'][0])
    {
        $request = $this->getGroupedAudiencesRequest($account_id, $audience_grouping_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\AudienceResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\AudienceResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AudienceResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getGroupedAudiencesAsync
     *
     * Get GroupedAudiences
     *
     * @param  int $account_id The logged in user. (required)
     * @param  string $audience_grouping_id The audience grouping id to return. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGroupedAudiences'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGroupedAudiencesAsync($account_id, $audience_grouping_id, string $contentType = self::contentTypes['getGroupedAudiences'][0])
    {
        return $this->getGroupedAudiencesAsyncWithHttpInfo($account_id, $audience_grouping_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getGroupedAudiencesAsyncWithHttpInfo
     *
     * Get GroupedAudiences
     *
     * @param  int $account_id The logged in user. (required)
     * @param  string $audience_grouping_id The audience grouping id to return. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGroupedAudiences'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGroupedAudiencesAsyncWithHttpInfo($account_id, $audience_grouping_id, string $contentType = self::contentTypes['getGroupedAudiences'][0])
    {
        $returnType = '\OpenAPI\Client\Model\AudienceResponse';
        $request = $this->getGroupedAudiencesRequest($account_id, $audience_grouping_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getGroupedAudiences'
     *
     * @param  int $account_id The logged in user. (required)
     * @param  string $audience_grouping_id The audience grouping id to return. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGroupedAudiences'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getGroupedAudiencesRequest($account_id, $audience_grouping_id, string $contentType = self::contentTypes['getGroupedAudiences'][0])
    {

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling getGroupedAudiences'
            );
        }

        // verify the required parameter 'audience_grouping_id' is set
        if ($audience_grouping_id === null || (is_array($audience_grouping_id) && count($audience_grouping_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $audience_grouping_id when calling getGroupedAudiences'
            );
        }


        $resourcePath = '/audience/grouped/get';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audience_grouping_id,
            'audienceGroupingId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listByAccount
     *
     * List Suggestions by Audience
     *
     * @param  int $account_id The account to match offers for. (required)
     * @param  int $limit the limit of the index (required)
     * @param  string $suggestion_type the type of suggestion (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listByAccount'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OfferListResponse
     */
    public function listByAccount($account_id, $limit, $suggestion_type, string $contentType = self::contentTypes['listByAccount'][0])
    {
        list($response) = $this->listByAccountWithHttpInfo($account_id, $limit, $suggestion_type, $contentType);
        return $response;
    }

    /**
     * Operation listByAccountWithHttpInfo
     *
     * List Suggestions by Audience
     *
     * @param  int $account_id The account to match offers for. (required)
     * @param  int $limit the limit of the index (required)
     * @param  string $suggestion_type the type of suggestion (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listByAccount'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OfferListResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listByAccountWithHttpInfo($account_id, $limit, $suggestion_type, string $contentType = self::contentTypes['listByAccount'][0])
    {
        $request = $this->listByAccountRequest($account_id, $limit, $suggestion_type, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\OfferListResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\OfferListResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OfferListResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listByAccountAsync
     *
     * List Suggestions by Audience
     *
     * @param  int $account_id The account to match offers for. (required)
     * @param  int $limit the limit of the index (required)
     * @param  string $suggestion_type the type of suggestion (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listByAccount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listByAccountAsync($account_id, $limit, $suggestion_type, string $contentType = self::contentTypes['listByAccount'][0])
    {
        return $this->listByAccountAsyncWithHttpInfo($account_id, $limit, $suggestion_type, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listByAccountAsyncWithHttpInfo
     *
     * List Suggestions by Audience
     *
     * @param  int $account_id The account to match offers for. (required)
     * @param  int $limit the limit of the index (required)
     * @param  string $suggestion_type the type of suggestion (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listByAccount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listByAccountAsyncWithHttpInfo($account_id, $limit, $suggestion_type, string $contentType = self::contentTypes['listByAccount'][0])
    {
        $returnType = '\OpenAPI\Client\Model\OfferListResponse';
        $request = $this->listByAccountRequest($account_id, $limit, $suggestion_type, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listByAccount'
     *
     * @param  int $account_id The account to match offers for. (required)
     * @param  int $limit the limit of the index (required)
     * @param  string $suggestion_type the type of suggestion (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listByAccount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listByAccountRequest($account_id, $limit, $suggestion_type, string $contentType = self::contentTypes['listByAccount'][0])
    {

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling listByAccount'
            );
        }

        // verify the required parameter 'limit' is set
        if ($limit === null || (is_array($limit) && count($limit) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $limit when calling listByAccount'
            );
        }

        // verify the required parameter 'suggestion_type' is set
        if ($suggestion_type === null || (is_array($suggestion_type) && count($suggestion_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $suggestion_type when calling listByAccount'
            );
        }


        $resourcePath = '/audience/suggestion/list';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $suggestion_type,
            'suggestionType', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listByAudience
     *
     * List Offers by Audience
     *
     * @param  int $limit this is the limit of the index (required)
     * @param  string|null $gender this is the gender to list offers by (optional)
     * @param  int|null $age this is the age to list offers by (optional)
     * @param  string|null $category_ids this is the category IDs to list offers by (optional)
     * @param  float|null $latitude this is the latitude to list offers by (optional)
     * @param  float|null $longitude this is the longitude to list offers by (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listByAudience'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OfferListResponse
     */
    public function listByAudience($limit, $gender = null, $age = null, $category_ids = null, $latitude = null, $longitude = null, string $contentType = self::contentTypes['listByAudience'][0])
    {
        list($response) = $this->listByAudienceWithHttpInfo($limit, $gender, $age, $category_ids, $latitude, $longitude, $contentType);
        return $response;
    }

    /**
     * Operation listByAudienceWithHttpInfo
     *
     * List Offers by Audience
     *
     * @param  int $limit this is the limit of the index (required)
     * @param  string|null $gender this is the gender to list offers by (optional)
     * @param  int|null $age this is the age to list offers by (optional)
     * @param  string|null $category_ids this is the category IDs to list offers by (optional)
     * @param  float|null $latitude this is the latitude to list offers by (optional)
     * @param  float|null $longitude this is the longitude to list offers by (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listByAudience'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OfferListResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listByAudienceWithHttpInfo($limit, $gender = null, $age = null, $category_ids = null, $latitude = null, $longitude = null, string $contentType = self::contentTypes['listByAudience'][0])
    {
        $request = $this->listByAudienceRequest($limit, $gender, $age, $category_ids, $latitude, $longitude, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\OfferListResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\OfferListResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OfferListResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listByAudienceAsync
     *
     * List Offers by Audience
     *
     * @param  int $limit this is the limit of the index (required)
     * @param  string|null $gender this is the gender to list offers by (optional)
     * @param  int|null $age this is the age to list offers by (optional)
     * @param  string|null $category_ids this is the category IDs to list offers by (optional)
     * @param  float|null $latitude this is the latitude to list offers by (optional)
     * @param  float|null $longitude this is the longitude to list offers by (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listByAudience'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listByAudienceAsync($limit, $gender = null, $age = null, $category_ids = null, $latitude = null, $longitude = null, string $contentType = self::contentTypes['listByAudience'][0])
    {
        return $this->listByAudienceAsyncWithHttpInfo($limit, $gender, $age, $category_ids, $latitude, $longitude, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listByAudienceAsyncWithHttpInfo
     *
     * List Offers by Audience
     *
     * @param  int $limit this is the limit of the index (required)
     * @param  string|null $gender this is the gender to list offers by (optional)
     * @param  int|null $age this is the age to list offers by (optional)
     * @param  string|null $category_ids this is the category IDs to list offers by (optional)
     * @param  float|null $latitude this is the latitude to list offers by (optional)
     * @param  float|null $longitude this is the longitude to list offers by (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listByAudience'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listByAudienceAsyncWithHttpInfo($limit, $gender = null, $age = null, $category_ids = null, $latitude = null, $longitude = null, string $contentType = self::contentTypes['listByAudience'][0])
    {
        $returnType = '\OpenAPI\Client\Model\OfferListResponse';
        $request = $this->listByAudienceRequest($limit, $gender, $age, $category_ids, $latitude, $longitude, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listByAudience'
     *
     * @param  int $limit this is the limit of the index (required)
     * @param  string|null $gender this is the gender to list offers by (optional)
     * @param  int|null $age this is the age to list offers by (optional)
     * @param  string|null $category_ids this is the category IDs to list offers by (optional)
     * @param  float|null $latitude this is the latitude to list offers by (optional)
     * @param  float|null $longitude this is the longitude to list offers by (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listByAudience'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listByAudienceRequest($limit, $gender = null, $age = null, $category_ids = null, $latitude = null, $longitude = null, string $contentType = self::contentTypes['listByAudience'][0])
    {

        // verify the required parameter 'limit' is set
        if ($limit === null || (is_array($limit) && count($limit) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $limit when calling listByAudience'
            );
        }







        $resourcePath = '/audience/suggestion/offersByAudience';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $gender,
            'gender', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $age,
            'age', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $category_ids,
            'categoryIds', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $latitude,
            'latitude', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $longitude,
            'longitude', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listLastestByAccount
     *
     * List Sent Suggestions
     *
     * @param  int $account_id The account to match offers for. (required)
     * @param  int $timeframe The timeframe in seconds of the latest suggestions (required)
     * @param  string $suggestion_type The type of trigger suggestions to return (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listLastestByAccount'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OfferListResponse
     */
    public function listLastestByAccount($account_id, $timeframe, $suggestion_type, string $contentType = self::contentTypes['listLastestByAccount'][0])
    {
        list($response) = $this->listLastestByAccountWithHttpInfo($account_id, $timeframe, $suggestion_type, $contentType);
        return $response;
    }

    /**
     * Operation listLastestByAccountWithHttpInfo
     *
     * List Sent Suggestions
     *
     * @param  int $account_id The account to match offers for. (required)
     * @param  int $timeframe The timeframe in seconds of the latest suggestions (required)
     * @param  string $suggestion_type The type of trigger suggestions to return (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listLastestByAccount'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OfferListResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listLastestByAccountWithHttpInfo($account_id, $timeframe, $suggestion_type, string $contentType = self::contentTypes['listLastestByAccount'][0])
    {
        $request = $this->listLastestByAccountRequest($account_id, $timeframe, $suggestion_type, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\OfferListResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\OfferListResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OfferListResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listLastestByAccountAsync
     *
     * List Sent Suggestions
     *
     * @param  int $account_id The account to match offers for. (required)
     * @param  int $timeframe The timeframe in seconds of the latest suggestions (required)
     * @param  string $suggestion_type The type of trigger suggestions to return (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listLastestByAccount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listLastestByAccountAsync($account_id, $timeframe, $suggestion_type, string $contentType = self::contentTypes['listLastestByAccount'][0])
    {
        return $this->listLastestByAccountAsyncWithHttpInfo($account_id, $timeframe, $suggestion_type, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listLastestByAccountAsyncWithHttpInfo
     *
     * List Sent Suggestions
     *
     * @param  int $account_id The account to match offers for. (required)
     * @param  int $timeframe The timeframe in seconds of the latest suggestions (required)
     * @param  string $suggestion_type The type of trigger suggestions to return (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listLastestByAccount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listLastestByAccountAsyncWithHttpInfo($account_id, $timeframe, $suggestion_type, string $contentType = self::contentTypes['listLastestByAccount'][0])
    {
        $returnType = '\OpenAPI\Client\Model\OfferListResponse';
        $request = $this->listLastestByAccountRequest($account_id, $timeframe, $suggestion_type, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listLastestByAccount'
     *
     * @param  int $account_id The account to match offers for. (required)
     * @param  int $timeframe The timeframe in seconds of the latest suggestions (required)
     * @param  string $suggestion_type The type of trigger suggestions to return (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listLastestByAccount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listLastestByAccountRequest($account_id, $timeframe, $suggestion_type, string $contentType = self::contentTypes['listLastestByAccount'][0])
    {

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling listLastestByAccount'
            );
        }

        // verify the required parameter 'timeframe' is set
        if ($timeframe === null || (is_array($timeframe) && count($timeframe) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $timeframe when calling listLastestByAccount'
            );
        }

        // verify the required parameter 'suggestion_type' is set
        if ($suggestion_type === null || (is_array($suggestion_type) && count($suggestion_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $suggestion_type when calling listLastestByAccount'
            );
        }


        $resourcePath = '/audience/suggestion/latest';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timeframe,
            'timeframe', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $suggestion_type,
            'suggestionType', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation sendByAccount
     *
     * Send Suggestions
     *
     * @param  int $account_id The account to match offers for. (required)
     * @param  float $latitude the latitude (required)
     * @param  float $longitude the longitude (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendByAccount'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SirqulResponse
     */
    public function sendByAccount($account_id, $latitude, $longitude, string $contentType = self::contentTypes['sendByAccount'][0])
    {
        list($response) = $this->sendByAccountWithHttpInfo($account_id, $latitude, $longitude, $contentType);
        return $response;
    }

    /**
     * Operation sendByAccountWithHttpInfo
     *
     * Send Suggestions
     *
     * @param  int $account_id The account to match offers for. (required)
     * @param  float $latitude the latitude (required)
     * @param  float $longitude the longitude (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendByAccount'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SirqulResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function sendByAccountWithHttpInfo($account_id, $latitude, $longitude, string $contentType = self::contentTypes['sendByAccount'][0])
    {
        $request = $this->sendByAccountRequest($account_id, $latitude, $longitude, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\SirqulResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\SirqulResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SirqulResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation sendByAccountAsync
     *
     * Send Suggestions
     *
     * @param  int $account_id The account to match offers for. (required)
     * @param  float $latitude the latitude (required)
     * @param  float $longitude the longitude (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendByAccount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sendByAccountAsync($account_id, $latitude, $longitude, string $contentType = self::contentTypes['sendByAccount'][0])
    {
        return $this->sendByAccountAsyncWithHttpInfo($account_id, $latitude, $longitude, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation sendByAccountAsyncWithHttpInfo
     *
     * Send Suggestions
     *
     * @param  int $account_id The account to match offers for. (required)
     * @param  float $latitude the latitude (required)
     * @param  float $longitude the longitude (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendByAccount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sendByAccountAsyncWithHttpInfo($account_id, $latitude, $longitude, string $contentType = self::contentTypes['sendByAccount'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SirqulResponse';
        $request = $this->sendByAccountRequest($account_id, $latitude, $longitude, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'sendByAccount'
     *
     * @param  int $account_id The account to match offers for. (required)
     * @param  float $latitude the latitude (required)
     * @param  float $longitude the longitude (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendByAccount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function sendByAccountRequest($account_id, $latitude, $longitude, string $contentType = self::contentTypes['sendByAccount'][0])
    {

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling sendByAccount'
            );
        }

        // verify the required parameter 'latitude' is set
        if ($latitude === null || (is_array($latitude) && count($latitude) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $latitude when calling sendByAccount'
            );
        }

        // verify the required parameter 'longitude' is set
        if ($longitude === null || (is_array($longitude) && count($longitude) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $longitude when calling sendByAccount'
            );
        }


        $resourcePath = '/audience/suggestion/send';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $latitude,
            'latitude', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $longitude,
            'longitude', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateAudience
     *
     * Update Audience
     *
     * @param  int $account_id The logged in user. (required)
     * @param  int $audience_id The id of the audience to update. (required)
     * @param  string|null $name The name of the audience (optional)
     * @param  string|null $description The description of the audience (optional)
     * @param  string|null $search_tags The search tags (optional)
     * @param  string|null $gender The gender; possible values are: MALE, FEMALE, ANY (optional)
     * @param  string|null $age_groups The list of age groups, comma separated; possible values are AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS, AGE_ANY (to reset to none) (optional)
     * @param  string|null $category_ids The list of category ids, comma separated; possible values are retrieved via /api/{version}/category/search (pass in id values) (optional)
     * @param  string|null $application_ids The list of application ids, comma separated; possible values are retrieved via /api/{version}/application/list (pass in id values) (optional)
     * @param  string|null $game_experience_level The experience level of the player; possible values are: ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT (optional)
     * @param  string|null $devices (Deprecated) Use deviceIds. The list of targeted device names, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in name values) (optional)
     * @param  string|null $device_ids The list of targeted device ids, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in id values) (optional)
     * @param  string|null $device_versions The list of targeted device version ranges that are aligned with the provided devices list, comma separated (examples: 2.3-X, 0-5.1.4, 4.3.1-6.1.4) (optional)
     * @param  string|null $locations The list of locations to build the center around; comma separated list of latitude/longitude pairs (example: lat1,long1,lat2,long2) (optional)
     * @param  string|null $radius The list of radius of influence for the audience, in miles; comma separated list. Either provide 1 to be applied to all location pairs or a matching list to each lat/long pair. (optional)
     * @param  bool|null $active if audience is active (optional)
     * @param  bool|null $send_suggestion If true, then notify matching users when they are inside the radius (optional)
     * @param  int|null $start_time_offset Seconds from the start time of an event (optional)
     * @param  int|null $end_time_offset Seconds from the end time of an event (optional)
     * @param  string|null $associate_description the associate description (optional)
     * @param  string|null $associate_type The type of the object to center the audience geofence (optional)
     * @param  int|null $associate_id The ID of the object to center the audience geofence (optional)
     * @param  string|null $grouping_id Optional grouping id for the audience (optional)
     * @param  string|null $meta_data External custom client defined data (optional)
     * @param  string|null $visibility Visibility of the audience (optional)
     * @param  string|null $audience_type Type of audience (optional)
     * @param  bool|null $use_order Use order for cohort (optional)
     * @param  string|null $cohort_regions_data Cohort data for \&quot;cohort\&quot; audience type (optional)
     * @param  string|null $app_key Filter results by application key (optional)
     * @param  string|null $trilateration_types Trilateration types (optional)
     * @param  bool|null $unique_name If true, makes sure the audience name is unique (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAudience'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AudienceResponse
     */
    public function updateAudience($account_id, $audience_id, $name = null, $description = null, $search_tags = null, $gender = null, $age_groups = null, $category_ids = null, $application_ids = null, $game_experience_level = null, $devices = null, $device_ids = null, $device_versions = null, $locations = null, $radius = null, $active = null, $send_suggestion = null, $start_time_offset = null, $end_time_offset = null, $associate_description = null, $associate_type = null, $associate_id = null, $grouping_id = null, $meta_data = null, $visibility = null, $audience_type = null, $use_order = null, $cohort_regions_data = null, $app_key = null, $trilateration_types = null, $unique_name = null, string $contentType = self::contentTypes['updateAudience'][0])
    {
        list($response) = $this->updateAudienceWithHttpInfo($account_id, $audience_id, $name, $description, $search_tags, $gender, $age_groups, $category_ids, $application_ids, $game_experience_level, $devices, $device_ids, $device_versions, $locations, $radius, $active, $send_suggestion, $start_time_offset, $end_time_offset, $associate_description, $associate_type, $associate_id, $grouping_id, $meta_data, $visibility, $audience_type, $use_order, $cohort_regions_data, $app_key, $trilateration_types, $unique_name, $contentType);
        return $response;
    }

    /**
     * Operation updateAudienceWithHttpInfo
     *
     * Update Audience
     *
     * @param  int $account_id The logged in user. (required)
     * @param  int $audience_id The id of the audience to update. (required)
     * @param  string|null $name The name of the audience (optional)
     * @param  string|null $description The description of the audience (optional)
     * @param  string|null $search_tags The search tags (optional)
     * @param  string|null $gender The gender; possible values are: MALE, FEMALE, ANY (optional)
     * @param  string|null $age_groups The list of age groups, comma separated; possible values are AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS, AGE_ANY (to reset to none) (optional)
     * @param  string|null $category_ids The list of category ids, comma separated; possible values are retrieved via /api/{version}/category/search (pass in id values) (optional)
     * @param  string|null $application_ids The list of application ids, comma separated; possible values are retrieved via /api/{version}/application/list (pass in id values) (optional)
     * @param  string|null $game_experience_level The experience level of the player; possible values are: ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT (optional)
     * @param  string|null $devices (Deprecated) Use deviceIds. The list of targeted device names, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in name values) (optional)
     * @param  string|null $device_ids The list of targeted device ids, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in id values) (optional)
     * @param  string|null $device_versions The list of targeted device version ranges that are aligned with the provided devices list, comma separated (examples: 2.3-X, 0-5.1.4, 4.3.1-6.1.4) (optional)
     * @param  string|null $locations The list of locations to build the center around; comma separated list of latitude/longitude pairs (example: lat1,long1,lat2,long2) (optional)
     * @param  string|null $radius The list of radius of influence for the audience, in miles; comma separated list. Either provide 1 to be applied to all location pairs or a matching list to each lat/long pair. (optional)
     * @param  bool|null $active if audience is active (optional)
     * @param  bool|null $send_suggestion If true, then notify matching users when they are inside the radius (optional)
     * @param  int|null $start_time_offset Seconds from the start time of an event (optional)
     * @param  int|null $end_time_offset Seconds from the end time of an event (optional)
     * @param  string|null $associate_description the associate description (optional)
     * @param  string|null $associate_type The type of the object to center the audience geofence (optional)
     * @param  int|null $associate_id The ID of the object to center the audience geofence (optional)
     * @param  string|null $grouping_id Optional grouping id for the audience (optional)
     * @param  string|null $meta_data External custom client defined data (optional)
     * @param  string|null $visibility Visibility of the audience (optional)
     * @param  string|null $audience_type Type of audience (optional)
     * @param  bool|null $use_order Use order for cohort (optional)
     * @param  string|null $cohort_regions_data Cohort data for \&quot;cohort\&quot; audience type (optional)
     * @param  string|null $app_key Filter results by application key (optional)
     * @param  string|null $trilateration_types Trilateration types (optional)
     * @param  bool|null $unique_name If true, makes sure the audience name is unique (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAudience'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AudienceResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateAudienceWithHttpInfo($account_id, $audience_id, $name = null, $description = null, $search_tags = null, $gender = null, $age_groups = null, $category_ids = null, $application_ids = null, $game_experience_level = null, $devices = null, $device_ids = null, $device_versions = null, $locations = null, $radius = null, $active = null, $send_suggestion = null, $start_time_offset = null, $end_time_offset = null, $associate_description = null, $associate_type = null, $associate_id = null, $grouping_id = null, $meta_data = null, $visibility = null, $audience_type = null, $use_order = null, $cohort_regions_data = null, $app_key = null, $trilateration_types = null, $unique_name = null, string $contentType = self::contentTypes['updateAudience'][0])
    {
        $request = $this->updateAudienceRequest($account_id, $audience_id, $name, $description, $search_tags, $gender, $age_groups, $category_ids, $application_ids, $game_experience_level, $devices, $device_ids, $device_versions, $locations, $radius, $active, $send_suggestion, $start_time_offset, $end_time_offset, $associate_description, $associate_type, $associate_id, $grouping_id, $meta_data, $visibility, $audience_type, $use_order, $cohort_regions_data, $app_key, $trilateration_types, $unique_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\AudienceResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\AudienceResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AudienceResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateAudienceAsync
     *
     * Update Audience
     *
     * @param  int $account_id The logged in user. (required)
     * @param  int $audience_id The id of the audience to update. (required)
     * @param  string|null $name The name of the audience (optional)
     * @param  string|null $description The description of the audience (optional)
     * @param  string|null $search_tags The search tags (optional)
     * @param  string|null $gender The gender; possible values are: MALE, FEMALE, ANY (optional)
     * @param  string|null $age_groups The list of age groups, comma separated; possible values are AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS, AGE_ANY (to reset to none) (optional)
     * @param  string|null $category_ids The list of category ids, comma separated; possible values are retrieved via /api/{version}/category/search (pass in id values) (optional)
     * @param  string|null $application_ids The list of application ids, comma separated; possible values are retrieved via /api/{version}/application/list (pass in id values) (optional)
     * @param  string|null $game_experience_level The experience level of the player; possible values are: ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT (optional)
     * @param  string|null $devices (Deprecated) Use deviceIds. The list of targeted device names, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in name values) (optional)
     * @param  string|null $device_ids The list of targeted device ids, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in id values) (optional)
     * @param  string|null $device_versions The list of targeted device version ranges that are aligned with the provided devices list, comma separated (examples: 2.3-X, 0-5.1.4, 4.3.1-6.1.4) (optional)
     * @param  string|null $locations The list of locations to build the center around; comma separated list of latitude/longitude pairs (example: lat1,long1,lat2,long2) (optional)
     * @param  string|null $radius The list of radius of influence for the audience, in miles; comma separated list. Either provide 1 to be applied to all location pairs or a matching list to each lat/long pair. (optional)
     * @param  bool|null $active if audience is active (optional)
     * @param  bool|null $send_suggestion If true, then notify matching users when they are inside the radius (optional)
     * @param  int|null $start_time_offset Seconds from the start time of an event (optional)
     * @param  int|null $end_time_offset Seconds from the end time of an event (optional)
     * @param  string|null $associate_description the associate description (optional)
     * @param  string|null $associate_type The type of the object to center the audience geofence (optional)
     * @param  int|null $associate_id The ID of the object to center the audience geofence (optional)
     * @param  string|null $grouping_id Optional grouping id for the audience (optional)
     * @param  string|null $meta_data External custom client defined data (optional)
     * @param  string|null $visibility Visibility of the audience (optional)
     * @param  string|null $audience_type Type of audience (optional)
     * @param  bool|null $use_order Use order for cohort (optional)
     * @param  string|null $cohort_regions_data Cohort data for \&quot;cohort\&quot; audience type (optional)
     * @param  string|null $app_key Filter results by application key (optional)
     * @param  string|null $trilateration_types Trilateration types (optional)
     * @param  bool|null $unique_name If true, makes sure the audience name is unique (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAudience'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAudienceAsync($account_id, $audience_id, $name = null, $description = null, $search_tags = null, $gender = null, $age_groups = null, $category_ids = null, $application_ids = null, $game_experience_level = null, $devices = null, $device_ids = null, $device_versions = null, $locations = null, $radius = null, $active = null, $send_suggestion = null, $start_time_offset = null, $end_time_offset = null, $associate_description = null, $associate_type = null, $associate_id = null, $grouping_id = null, $meta_data = null, $visibility = null, $audience_type = null, $use_order = null, $cohort_regions_data = null, $app_key = null, $trilateration_types = null, $unique_name = null, string $contentType = self::contentTypes['updateAudience'][0])
    {
        return $this->updateAudienceAsyncWithHttpInfo($account_id, $audience_id, $name, $description, $search_tags, $gender, $age_groups, $category_ids, $application_ids, $game_experience_level, $devices, $device_ids, $device_versions, $locations, $radius, $active, $send_suggestion, $start_time_offset, $end_time_offset, $associate_description, $associate_type, $associate_id, $grouping_id, $meta_data, $visibility, $audience_type, $use_order, $cohort_regions_data, $app_key, $trilateration_types, $unique_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateAudienceAsyncWithHttpInfo
     *
     * Update Audience
     *
     * @param  int $account_id The logged in user. (required)
     * @param  int $audience_id The id of the audience to update. (required)
     * @param  string|null $name The name of the audience (optional)
     * @param  string|null $description The description of the audience (optional)
     * @param  string|null $search_tags The search tags (optional)
     * @param  string|null $gender The gender; possible values are: MALE, FEMALE, ANY (optional)
     * @param  string|null $age_groups The list of age groups, comma separated; possible values are AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS, AGE_ANY (to reset to none) (optional)
     * @param  string|null $category_ids The list of category ids, comma separated; possible values are retrieved via /api/{version}/category/search (pass in id values) (optional)
     * @param  string|null $application_ids The list of application ids, comma separated; possible values are retrieved via /api/{version}/application/list (pass in id values) (optional)
     * @param  string|null $game_experience_level The experience level of the player; possible values are: ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT (optional)
     * @param  string|null $devices (Deprecated) Use deviceIds. The list of targeted device names, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in name values) (optional)
     * @param  string|null $device_ids The list of targeted device ids, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in id values) (optional)
     * @param  string|null $device_versions The list of targeted device version ranges that are aligned with the provided devices list, comma separated (examples: 2.3-X, 0-5.1.4, 4.3.1-6.1.4) (optional)
     * @param  string|null $locations The list of locations to build the center around; comma separated list of latitude/longitude pairs (example: lat1,long1,lat2,long2) (optional)
     * @param  string|null $radius The list of radius of influence for the audience, in miles; comma separated list. Either provide 1 to be applied to all location pairs or a matching list to each lat/long pair. (optional)
     * @param  bool|null $active if audience is active (optional)
     * @param  bool|null $send_suggestion If true, then notify matching users when they are inside the radius (optional)
     * @param  int|null $start_time_offset Seconds from the start time of an event (optional)
     * @param  int|null $end_time_offset Seconds from the end time of an event (optional)
     * @param  string|null $associate_description the associate description (optional)
     * @param  string|null $associate_type The type of the object to center the audience geofence (optional)
     * @param  int|null $associate_id The ID of the object to center the audience geofence (optional)
     * @param  string|null $grouping_id Optional grouping id for the audience (optional)
     * @param  string|null $meta_data External custom client defined data (optional)
     * @param  string|null $visibility Visibility of the audience (optional)
     * @param  string|null $audience_type Type of audience (optional)
     * @param  bool|null $use_order Use order for cohort (optional)
     * @param  string|null $cohort_regions_data Cohort data for \&quot;cohort\&quot; audience type (optional)
     * @param  string|null $app_key Filter results by application key (optional)
     * @param  string|null $trilateration_types Trilateration types (optional)
     * @param  bool|null $unique_name If true, makes sure the audience name is unique (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAudience'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAudienceAsyncWithHttpInfo($account_id, $audience_id, $name = null, $description = null, $search_tags = null, $gender = null, $age_groups = null, $category_ids = null, $application_ids = null, $game_experience_level = null, $devices = null, $device_ids = null, $device_versions = null, $locations = null, $radius = null, $active = null, $send_suggestion = null, $start_time_offset = null, $end_time_offset = null, $associate_description = null, $associate_type = null, $associate_id = null, $grouping_id = null, $meta_data = null, $visibility = null, $audience_type = null, $use_order = null, $cohort_regions_data = null, $app_key = null, $trilateration_types = null, $unique_name = null, string $contentType = self::contentTypes['updateAudience'][0])
    {
        $returnType = '\OpenAPI\Client\Model\AudienceResponse';
        $request = $this->updateAudienceRequest($account_id, $audience_id, $name, $description, $search_tags, $gender, $age_groups, $category_ids, $application_ids, $game_experience_level, $devices, $device_ids, $device_versions, $locations, $radius, $active, $send_suggestion, $start_time_offset, $end_time_offset, $associate_description, $associate_type, $associate_id, $grouping_id, $meta_data, $visibility, $audience_type, $use_order, $cohort_regions_data, $app_key, $trilateration_types, $unique_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateAudience'
     *
     * @param  int $account_id The logged in user. (required)
     * @param  int $audience_id The id of the audience to update. (required)
     * @param  string|null $name The name of the audience (optional)
     * @param  string|null $description The description of the audience (optional)
     * @param  string|null $search_tags The search tags (optional)
     * @param  string|null $gender The gender; possible values are: MALE, FEMALE, ANY (optional)
     * @param  string|null $age_groups The list of age groups, comma separated; possible values are AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS, AGE_ANY (to reset to none) (optional)
     * @param  string|null $category_ids The list of category ids, comma separated; possible values are retrieved via /api/{version}/category/search (pass in id values) (optional)
     * @param  string|null $application_ids The list of application ids, comma separated; possible values are retrieved via /api/{version}/application/list (pass in id values) (optional)
     * @param  string|null $game_experience_level The experience level of the player; possible values are: ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT (optional)
     * @param  string|null $devices (Deprecated) Use deviceIds. The list of targeted device names, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in name values) (optional)
     * @param  string|null $device_ids The list of targeted device ids, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in id values) (optional)
     * @param  string|null $device_versions The list of targeted device version ranges that are aligned with the provided devices list, comma separated (examples: 2.3-X, 0-5.1.4, 4.3.1-6.1.4) (optional)
     * @param  string|null $locations The list of locations to build the center around; comma separated list of latitude/longitude pairs (example: lat1,long1,lat2,long2) (optional)
     * @param  string|null $radius The list of radius of influence for the audience, in miles; comma separated list. Either provide 1 to be applied to all location pairs or a matching list to each lat/long pair. (optional)
     * @param  bool|null $active if audience is active (optional)
     * @param  bool|null $send_suggestion If true, then notify matching users when they are inside the radius (optional)
     * @param  int|null $start_time_offset Seconds from the start time of an event (optional)
     * @param  int|null $end_time_offset Seconds from the end time of an event (optional)
     * @param  string|null $associate_description the associate description (optional)
     * @param  string|null $associate_type The type of the object to center the audience geofence (optional)
     * @param  int|null $associate_id The ID of the object to center the audience geofence (optional)
     * @param  string|null $grouping_id Optional grouping id for the audience (optional)
     * @param  string|null $meta_data External custom client defined data (optional)
     * @param  string|null $visibility Visibility of the audience (optional)
     * @param  string|null $audience_type Type of audience (optional)
     * @param  bool|null $use_order Use order for cohort (optional)
     * @param  string|null $cohort_regions_data Cohort data for \&quot;cohort\&quot; audience type (optional)
     * @param  string|null $app_key Filter results by application key (optional)
     * @param  string|null $trilateration_types Trilateration types (optional)
     * @param  bool|null $unique_name If true, makes sure the audience name is unique (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAudience'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateAudienceRequest($account_id, $audience_id, $name = null, $description = null, $search_tags = null, $gender = null, $age_groups = null, $category_ids = null, $application_ids = null, $game_experience_level = null, $devices = null, $device_ids = null, $device_versions = null, $locations = null, $radius = null, $active = null, $send_suggestion = null, $start_time_offset = null, $end_time_offset = null, $associate_description = null, $associate_type = null, $associate_id = null, $grouping_id = null, $meta_data = null, $visibility = null, $audience_type = null, $use_order = null, $cohort_regions_data = null, $app_key = null, $trilateration_types = null, $unique_name = null, string $contentType = self::contentTypes['updateAudience'][0])
    {

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling updateAudience'
            );
        }

        // verify the required parameter 'audience_id' is set
        if ($audience_id === null || (is_array($audience_id) && count($audience_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $audience_id when calling updateAudience'
            );
        }































        $resourcePath = '/audience/update';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audience_id,
            'audienceId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description,
            'description', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $search_tags,
            'searchTags', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $gender,
            'gender', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $age_groups,
            'ageGroups', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $category_ids,
            'categoryIds', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $application_ids,
            'applicationIds', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $game_experience_level,
            'gameExperienceLevel', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $devices,
            'devices', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_ids,
            'deviceIds', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_versions,
            'deviceVersions', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $locations,
            'locations', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $radius,
            'radius', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $active,
            'active', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $send_suggestion,
            'sendSuggestion', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_time_offset,
            'startTimeOffset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_time_offset,
            'endTimeOffset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $associate_description,
            'associateDescription', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $associate_type,
            'associateType', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $associate_id,
            'associateId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $grouping_id,
            'groupingId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $meta_data,
            'metaData', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $visibility,
            'visibility', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audience_type,
            'audienceType', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $use_order,
            'useOrder', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cohort_regions_data,
            'cohortRegionsData', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $app_key,
            'appKey', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $trilateration_types,
            'trilaterationTypes', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $unique_name,
            'uniqueName', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        if ($this->config->getCertFile()) {
            $options[RequestOptions::CERT] = $this->config->getCertFile();
        }

        if ($this->config->getKeyFile()) {
            $options[RequestOptions::SSL_KEY] = $this->config->getKeyFile();
        }

        return $options;
    }

    private function handleResponseWithDataType(
        string $dataType,
        RequestInterface $request,
        ResponseInterface $response
    ): array {
        if ($dataType === '\SplFileObject') {
            $content = $response->getBody(); //stream goes to serializer
        } else {
            $content = (string) $response->getBody();
            if ($dataType !== 'string') {
                try {
                    $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                } catch (\JsonException $exception) {
                    throw new ApiException(
                        sprintf(
                            'Error JSON decoding server response (%s)',
                            $request->getUri()
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                        $content
                    );
                }
            }
        }

        return [
            ObjectSerializer::deserialize($content, $dataType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    private function responseWithinRangeCode(
        string $rangeCode,
        int $statusCode
    ): bool {
        $left = (int) ($rangeCode[0].'00');
        $right = (int) ($rangeCode[0].'99');

        return $statusCode >= $left && $statusCode <= $right;
    }
}
