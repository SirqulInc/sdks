<?php
/**
 * TrackingApi
 * PHP version 8.1
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Sirqul IoT Platform
 *
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.20.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\FormDataProcessor;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * TrackingApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class TrackingApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'batchSaveTracking' => [
            'application/json',
        ],
        'getPredictedLocations' => [
            'application/json',
        ],
        'getPredictedPath' => [
            'application/json',
        ],
        'getPreferredLocations' => [
            'application/json',
        ],
        'getTrackingLegs' => [
            'application/json',
        ],
        'saveTrackingLeg' => [
            'application/json',
        ],
        'saveTrackingStep' => [
            'application/json',
        ],
        'searchAccountsWithTrackingLegs' => [
            'application/json',
        ],
        'searchTrackingLegs' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation batchSaveTracking
     *
     * Create Batch Tracking
     *
     * @param  float $version version (required)
     * @param  string $data JSON array of tracking legs &#x60;&#x60;&#x60;json [   \&quot;distance\&quot;: \&quot;0.08\&quot;,   \&quot;duration\&quot;: \&quot;10000\&quot;,   \&quot;startLatitude\&quot;: \&quot;47.614603\&quot;,   \&quot;startLongitude\&quot;: \&quot;-122.350518\&quot;,   \&quot;endLatitude\&quot;: \&quot;47.614384\&quot;,   \&quot;endLongitude\&quot;: \&quot;-122.349161\&quot;,   \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,   \&quot;endDate\&quot;: \&quot;1361924020000\&quot;,   \&quot;steps\&quot;: [     {       \&quot;distance\&quot;: \&quot;0.03\&quot;,       \&quot;duration\&quot;: \&quot;5000\&quot;,       \&quot;startLat\&quot;: \&quot;47.614603\&quot;,       \&quot;startLng\&quot;: \&quot;-122.350518\&quot;,       \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,       \&quot;endLat\&quot;: \&quot;47.614941\&quot;,       \&quot;endLng\&quot;: \&quot;-122.350062\&quot;,       \&quot;endDate\&quot;: \&quot;1361924015000\&quot;     },{       \&quot;distance\&quot;: \&quot;0.05\&quot;,       \&quot;duration\&quot;: \&quot;5000\&quot;,       \&quot;startLat\&quot;: \&quot;47.614941\&quot;,       \&quot;startLng\&quot;: \&quot;-122.350062\&quot;,       \&quot;startDate\&quot;: \&quot;1361924015000\&quot;,       \&quot;endLat\&quot;: \&quot;47.614384\&quot;,       \&quot;endLng\&quot;: \&quot;-122.349161\&quot;,       \&quot;endDate\&quot;: \&quot;1361924020000\&quot;     }   ] ] &#x60;&#x60;&#x60; (required)
     * @param  string|null $device_id the device id (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  bool|null $generate_accounts Whether to generate accounts for tracking entries when the owner does not exist (optional)
     * @param  bool|null $update_account_locations Whether to update the account&#39;s current location from the incoming tracking data (optional)
     * @param  string|null $default_tag The default tag to apply to incoming legs when no tag is provided (optional, default to 'PASSIVE')
     * @param  string|null $slave_uid  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['batchSaveTracking'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Leg[]
     */
    public function batchSaveTracking($version, $data, $device_id = null, $account_id = null, $generate_accounts = null, $update_account_locations = null, $default_tag = 'PASSIVE', $slave_uid = null, string $contentType = self::contentTypes['batchSaveTracking'][0])
    {
        list($response) = $this->batchSaveTrackingWithHttpInfo($version, $data, $device_id, $account_id, $generate_accounts, $update_account_locations, $default_tag, $slave_uid, $contentType);
        return $response;
    }

    /**
     * Operation batchSaveTrackingWithHttpInfo
     *
     * Create Batch Tracking
     *
     * @param  float $version (required)
     * @param  string $data JSON array of tracking legs &#x60;&#x60;&#x60;json [   \&quot;distance\&quot;: \&quot;0.08\&quot;,   \&quot;duration\&quot;: \&quot;10000\&quot;,   \&quot;startLatitude\&quot;: \&quot;47.614603\&quot;,   \&quot;startLongitude\&quot;: \&quot;-122.350518\&quot;,   \&quot;endLatitude\&quot;: \&quot;47.614384\&quot;,   \&quot;endLongitude\&quot;: \&quot;-122.349161\&quot;,   \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,   \&quot;endDate\&quot;: \&quot;1361924020000\&quot;,   \&quot;steps\&quot;: [     {       \&quot;distance\&quot;: \&quot;0.03\&quot;,       \&quot;duration\&quot;: \&quot;5000\&quot;,       \&quot;startLat\&quot;: \&quot;47.614603\&quot;,       \&quot;startLng\&quot;: \&quot;-122.350518\&quot;,       \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,       \&quot;endLat\&quot;: \&quot;47.614941\&quot;,       \&quot;endLng\&quot;: \&quot;-122.350062\&quot;,       \&quot;endDate\&quot;: \&quot;1361924015000\&quot;     },{       \&quot;distance\&quot;: \&quot;0.05\&quot;,       \&quot;duration\&quot;: \&quot;5000\&quot;,       \&quot;startLat\&quot;: \&quot;47.614941\&quot;,       \&quot;startLng\&quot;: \&quot;-122.350062\&quot;,       \&quot;startDate\&quot;: \&quot;1361924015000\&quot;,       \&quot;endLat\&quot;: \&quot;47.614384\&quot;,       \&quot;endLng\&quot;: \&quot;-122.349161\&quot;,       \&quot;endDate\&quot;: \&quot;1361924020000\&quot;     }   ] ] &#x60;&#x60;&#x60; (required)
     * @param  string|null $device_id the device id (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  bool|null $generate_accounts Whether to generate accounts for tracking entries when the owner does not exist (optional)
     * @param  bool|null $update_account_locations Whether to update the account&#39;s current location from the incoming tracking data (optional)
     * @param  string|null $default_tag The default tag to apply to incoming legs when no tag is provided (optional, default to 'PASSIVE')
     * @param  string|null $slave_uid  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['batchSaveTracking'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Leg[], HTTP status code, HTTP response headers (array of strings)
     */
    public function batchSaveTrackingWithHttpInfo($version, $data, $device_id = null, $account_id = null, $generate_accounts = null, $update_account_locations = null, $default_tag = 'PASSIVE', $slave_uid = null, string $contentType = self::contentTypes['batchSaveTracking'][0])
    {
        $request = $this->batchSaveTrackingRequest($version, $data, $device_id, $account_id, $generate_accounts, $update_account_locations, $default_tag, $slave_uid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Leg[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\Leg[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Leg[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation batchSaveTrackingAsync
     *
     * Create Batch Tracking
     *
     * @param  float $version (required)
     * @param  string $data JSON array of tracking legs &#x60;&#x60;&#x60;json [   \&quot;distance\&quot;: \&quot;0.08\&quot;,   \&quot;duration\&quot;: \&quot;10000\&quot;,   \&quot;startLatitude\&quot;: \&quot;47.614603\&quot;,   \&quot;startLongitude\&quot;: \&quot;-122.350518\&quot;,   \&quot;endLatitude\&quot;: \&quot;47.614384\&quot;,   \&quot;endLongitude\&quot;: \&quot;-122.349161\&quot;,   \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,   \&quot;endDate\&quot;: \&quot;1361924020000\&quot;,   \&quot;steps\&quot;: [     {       \&quot;distance\&quot;: \&quot;0.03\&quot;,       \&quot;duration\&quot;: \&quot;5000\&quot;,       \&quot;startLat\&quot;: \&quot;47.614603\&quot;,       \&quot;startLng\&quot;: \&quot;-122.350518\&quot;,       \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,       \&quot;endLat\&quot;: \&quot;47.614941\&quot;,       \&quot;endLng\&quot;: \&quot;-122.350062\&quot;,       \&quot;endDate\&quot;: \&quot;1361924015000\&quot;     },{       \&quot;distance\&quot;: \&quot;0.05\&quot;,       \&quot;duration\&quot;: \&quot;5000\&quot;,       \&quot;startLat\&quot;: \&quot;47.614941\&quot;,       \&quot;startLng\&quot;: \&quot;-122.350062\&quot;,       \&quot;startDate\&quot;: \&quot;1361924015000\&quot;,       \&quot;endLat\&quot;: \&quot;47.614384\&quot;,       \&quot;endLng\&quot;: \&quot;-122.349161\&quot;,       \&quot;endDate\&quot;: \&quot;1361924020000\&quot;     }   ] ] &#x60;&#x60;&#x60; (required)
     * @param  string|null $device_id the device id (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  bool|null $generate_accounts Whether to generate accounts for tracking entries when the owner does not exist (optional)
     * @param  bool|null $update_account_locations Whether to update the account&#39;s current location from the incoming tracking data (optional)
     * @param  string|null $default_tag The default tag to apply to incoming legs when no tag is provided (optional, default to 'PASSIVE')
     * @param  string|null $slave_uid  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['batchSaveTracking'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function batchSaveTrackingAsync($version, $data, $device_id = null, $account_id = null, $generate_accounts = null, $update_account_locations = null, $default_tag = 'PASSIVE', $slave_uid = null, string $contentType = self::contentTypes['batchSaveTracking'][0])
    {
        return $this->batchSaveTrackingAsyncWithHttpInfo($version, $data, $device_id, $account_id, $generate_accounts, $update_account_locations, $default_tag, $slave_uid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation batchSaveTrackingAsyncWithHttpInfo
     *
     * Create Batch Tracking
     *
     * @param  float $version (required)
     * @param  string $data JSON array of tracking legs &#x60;&#x60;&#x60;json [   \&quot;distance\&quot;: \&quot;0.08\&quot;,   \&quot;duration\&quot;: \&quot;10000\&quot;,   \&quot;startLatitude\&quot;: \&quot;47.614603\&quot;,   \&quot;startLongitude\&quot;: \&quot;-122.350518\&quot;,   \&quot;endLatitude\&quot;: \&quot;47.614384\&quot;,   \&quot;endLongitude\&quot;: \&quot;-122.349161\&quot;,   \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,   \&quot;endDate\&quot;: \&quot;1361924020000\&quot;,   \&quot;steps\&quot;: [     {       \&quot;distance\&quot;: \&quot;0.03\&quot;,       \&quot;duration\&quot;: \&quot;5000\&quot;,       \&quot;startLat\&quot;: \&quot;47.614603\&quot;,       \&quot;startLng\&quot;: \&quot;-122.350518\&quot;,       \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,       \&quot;endLat\&quot;: \&quot;47.614941\&quot;,       \&quot;endLng\&quot;: \&quot;-122.350062\&quot;,       \&quot;endDate\&quot;: \&quot;1361924015000\&quot;     },{       \&quot;distance\&quot;: \&quot;0.05\&quot;,       \&quot;duration\&quot;: \&quot;5000\&quot;,       \&quot;startLat\&quot;: \&quot;47.614941\&quot;,       \&quot;startLng\&quot;: \&quot;-122.350062\&quot;,       \&quot;startDate\&quot;: \&quot;1361924015000\&quot;,       \&quot;endLat\&quot;: \&quot;47.614384\&quot;,       \&quot;endLng\&quot;: \&quot;-122.349161\&quot;,       \&quot;endDate\&quot;: \&quot;1361924020000\&quot;     }   ] ] &#x60;&#x60;&#x60; (required)
     * @param  string|null $device_id the device id (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  bool|null $generate_accounts Whether to generate accounts for tracking entries when the owner does not exist (optional)
     * @param  bool|null $update_account_locations Whether to update the account&#39;s current location from the incoming tracking data (optional)
     * @param  string|null $default_tag The default tag to apply to incoming legs when no tag is provided (optional, default to 'PASSIVE')
     * @param  string|null $slave_uid  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['batchSaveTracking'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function batchSaveTrackingAsyncWithHttpInfo($version, $data, $device_id = null, $account_id = null, $generate_accounts = null, $update_account_locations = null, $default_tag = 'PASSIVE', $slave_uid = null, string $contentType = self::contentTypes['batchSaveTracking'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Leg[]';
        $request = $this->batchSaveTrackingRequest($version, $data, $device_id, $account_id, $generate_accounts, $update_account_locations, $default_tag, $slave_uid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'batchSaveTracking'
     *
     * @param  float $version (required)
     * @param  string $data JSON array of tracking legs &#x60;&#x60;&#x60;json [   \&quot;distance\&quot;: \&quot;0.08\&quot;,   \&quot;duration\&quot;: \&quot;10000\&quot;,   \&quot;startLatitude\&quot;: \&quot;47.614603\&quot;,   \&quot;startLongitude\&quot;: \&quot;-122.350518\&quot;,   \&quot;endLatitude\&quot;: \&quot;47.614384\&quot;,   \&quot;endLongitude\&quot;: \&quot;-122.349161\&quot;,   \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,   \&quot;endDate\&quot;: \&quot;1361924020000\&quot;,   \&quot;steps\&quot;: [     {       \&quot;distance\&quot;: \&quot;0.03\&quot;,       \&quot;duration\&quot;: \&quot;5000\&quot;,       \&quot;startLat\&quot;: \&quot;47.614603\&quot;,       \&quot;startLng\&quot;: \&quot;-122.350518\&quot;,       \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,       \&quot;endLat\&quot;: \&quot;47.614941\&quot;,       \&quot;endLng\&quot;: \&quot;-122.350062\&quot;,       \&quot;endDate\&quot;: \&quot;1361924015000\&quot;     },{       \&quot;distance\&quot;: \&quot;0.05\&quot;,       \&quot;duration\&quot;: \&quot;5000\&quot;,       \&quot;startLat\&quot;: \&quot;47.614941\&quot;,       \&quot;startLng\&quot;: \&quot;-122.350062\&quot;,       \&quot;startDate\&quot;: \&quot;1361924015000\&quot;,       \&quot;endLat\&quot;: \&quot;47.614384\&quot;,       \&quot;endLng\&quot;: \&quot;-122.349161\&quot;,       \&quot;endDate\&quot;: \&quot;1361924020000\&quot;     }   ] ] &#x60;&#x60;&#x60; (required)
     * @param  string|null $device_id the device id (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  bool|null $generate_accounts Whether to generate accounts for tracking entries when the owner does not exist (optional)
     * @param  bool|null $update_account_locations Whether to update the account&#39;s current location from the incoming tracking data (optional)
     * @param  string|null $default_tag The default tag to apply to incoming legs when no tag is provided (optional, default to 'PASSIVE')
     * @param  string|null $slave_uid  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['batchSaveTracking'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function batchSaveTrackingRequest($version, $data, $device_id = null, $account_id = null, $generate_accounts = null, $update_account_locations = null, $default_tag = 'PASSIVE', $slave_uid = null, string $contentType = self::contentTypes['batchSaveTracking'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling batchSaveTracking'
            );
        }

        // verify the required parameter 'data' is set
        if ($data === null || (is_array($data) && count($data) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $data when calling batchSaveTracking'
            );
        }








        $resourcePath = '/api/{version}/tracking/batch/create';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_id,
            'deviceId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $data,
            'data', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $generate_accounts,
            'generateAccounts', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $update_account_locations,
            'updateAccountLocations', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $default_tag,
            'defaultTag', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slave_uid,
            'slaveUID', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPredictedLocations
     *
     * Get Predicted Locations
     *
     * @param  float $version version (required)
     * @param  int $account_id The account id of the customer (required)
     * @param  float|null $latitude latitude to return a more likely result set based on the user&#39;s current location (optional)
     * @param  float|null $longitude longitude to return a more likely result set based on the user&#39;s current location (optional)
     * @param  int|null $date_check Used to specify which day to get predicted locations for. So if you want to look at where they might be tomorrow, pass in tomorrow&#39;s date (timestamp in milliseconds). If no value is passed in, the current date will be used. (optional)
     * @param  string|null $hour_check Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see predicted locations for the mornings and evening you can pass in \&quot;8,9,10,11,17,18,19,20\&quot;. (optional)
     * @param  int|null $threshold The minimum number matches in 1 hour to be considered a likely location. (optional, default to 1)
     * @param  string|null $distance_unit Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS} (optional, default to 'MILES')
     * @param  float|null $search_range Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \&quot;0\&quot; (zero) will ignore the radius restriction. (optional, default to 0)
     * @param  string|null $sort_order The ordering algorithm for sorting the returned results: {MATCHES, DISTANCE, WEIGHTED} (optional, default to 'MATCHES')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPredictedLocations'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PredictedLocationResponse
     */
    public function getPredictedLocations($version, $account_id, $latitude = null, $longitude = null, $date_check = null, $hour_check = null, $threshold = 1, $distance_unit = 'MILES', $search_range = 0, $sort_order = 'MATCHES', string $contentType = self::contentTypes['getPredictedLocations'][0])
    {
        list($response) = $this->getPredictedLocationsWithHttpInfo($version, $account_id, $latitude, $longitude, $date_check, $hour_check, $threshold, $distance_unit, $search_range, $sort_order, $contentType);
        return $response;
    }

    /**
     * Operation getPredictedLocationsWithHttpInfo
     *
     * Get Predicted Locations
     *
     * @param  float $version (required)
     * @param  int $account_id The account id of the customer (required)
     * @param  float|null $latitude latitude to return a more likely result set based on the user&#39;s current location (optional)
     * @param  float|null $longitude longitude to return a more likely result set based on the user&#39;s current location (optional)
     * @param  int|null $date_check Used to specify which day to get predicted locations for. So if you want to look at where they might be tomorrow, pass in tomorrow&#39;s date (timestamp in milliseconds). If no value is passed in, the current date will be used. (optional)
     * @param  string|null $hour_check Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see predicted locations for the mornings and evening you can pass in \&quot;8,9,10,11,17,18,19,20\&quot;. (optional)
     * @param  int|null $threshold The minimum number matches in 1 hour to be considered a likely location. (optional, default to 1)
     * @param  string|null $distance_unit Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS} (optional, default to 'MILES')
     * @param  float|null $search_range Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \&quot;0\&quot; (zero) will ignore the radius restriction. (optional, default to 0)
     * @param  string|null $sort_order The ordering algorithm for sorting the returned results: {MATCHES, DISTANCE, WEIGHTED} (optional, default to 'MATCHES')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPredictedLocations'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PredictedLocationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPredictedLocationsWithHttpInfo($version, $account_id, $latitude = null, $longitude = null, $date_check = null, $hour_check = null, $threshold = 1, $distance_unit = 'MILES', $search_range = 0, $sort_order = 'MATCHES', string $contentType = self::contentTypes['getPredictedLocations'][0])
    {
        $request = $this->getPredictedLocationsRequest($version, $account_id, $latitude, $longitude, $date_check, $hour_check, $threshold, $distance_unit, $search_range, $sort_order, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\PredictedLocationResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\PredictedLocationResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PredictedLocationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getPredictedLocationsAsync
     *
     * Get Predicted Locations
     *
     * @param  float $version (required)
     * @param  int $account_id The account id of the customer (required)
     * @param  float|null $latitude latitude to return a more likely result set based on the user&#39;s current location (optional)
     * @param  float|null $longitude longitude to return a more likely result set based on the user&#39;s current location (optional)
     * @param  int|null $date_check Used to specify which day to get predicted locations for. So if you want to look at where they might be tomorrow, pass in tomorrow&#39;s date (timestamp in milliseconds). If no value is passed in, the current date will be used. (optional)
     * @param  string|null $hour_check Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see predicted locations for the mornings and evening you can pass in \&quot;8,9,10,11,17,18,19,20\&quot;. (optional)
     * @param  int|null $threshold The minimum number matches in 1 hour to be considered a likely location. (optional, default to 1)
     * @param  string|null $distance_unit Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS} (optional, default to 'MILES')
     * @param  float|null $search_range Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \&quot;0\&quot; (zero) will ignore the radius restriction. (optional, default to 0)
     * @param  string|null $sort_order The ordering algorithm for sorting the returned results: {MATCHES, DISTANCE, WEIGHTED} (optional, default to 'MATCHES')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPredictedLocations'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPredictedLocationsAsync($version, $account_id, $latitude = null, $longitude = null, $date_check = null, $hour_check = null, $threshold = 1, $distance_unit = 'MILES', $search_range = 0, $sort_order = 'MATCHES', string $contentType = self::contentTypes['getPredictedLocations'][0])
    {
        return $this->getPredictedLocationsAsyncWithHttpInfo($version, $account_id, $latitude, $longitude, $date_check, $hour_check, $threshold, $distance_unit, $search_range, $sort_order, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPredictedLocationsAsyncWithHttpInfo
     *
     * Get Predicted Locations
     *
     * @param  float $version (required)
     * @param  int $account_id The account id of the customer (required)
     * @param  float|null $latitude latitude to return a more likely result set based on the user&#39;s current location (optional)
     * @param  float|null $longitude longitude to return a more likely result set based on the user&#39;s current location (optional)
     * @param  int|null $date_check Used to specify which day to get predicted locations for. So if you want to look at where they might be tomorrow, pass in tomorrow&#39;s date (timestamp in milliseconds). If no value is passed in, the current date will be used. (optional)
     * @param  string|null $hour_check Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see predicted locations for the mornings and evening you can pass in \&quot;8,9,10,11,17,18,19,20\&quot;. (optional)
     * @param  int|null $threshold The minimum number matches in 1 hour to be considered a likely location. (optional, default to 1)
     * @param  string|null $distance_unit Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS} (optional, default to 'MILES')
     * @param  float|null $search_range Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \&quot;0\&quot; (zero) will ignore the radius restriction. (optional, default to 0)
     * @param  string|null $sort_order The ordering algorithm for sorting the returned results: {MATCHES, DISTANCE, WEIGHTED} (optional, default to 'MATCHES')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPredictedLocations'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPredictedLocationsAsyncWithHttpInfo($version, $account_id, $latitude = null, $longitude = null, $date_check = null, $hour_check = null, $threshold = 1, $distance_unit = 'MILES', $search_range = 0, $sort_order = 'MATCHES', string $contentType = self::contentTypes['getPredictedLocations'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PredictedLocationResponse';
        $request = $this->getPredictedLocationsRequest($version, $account_id, $latitude, $longitude, $date_check, $hour_check, $threshold, $distance_unit, $search_range, $sort_order, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPredictedLocations'
     *
     * @param  float $version (required)
     * @param  int $account_id The account id of the customer (required)
     * @param  float|null $latitude latitude to return a more likely result set based on the user&#39;s current location (optional)
     * @param  float|null $longitude longitude to return a more likely result set based on the user&#39;s current location (optional)
     * @param  int|null $date_check Used to specify which day to get predicted locations for. So if you want to look at where they might be tomorrow, pass in tomorrow&#39;s date (timestamp in milliseconds). If no value is passed in, the current date will be used. (optional)
     * @param  string|null $hour_check Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see predicted locations for the mornings and evening you can pass in \&quot;8,9,10,11,17,18,19,20\&quot;. (optional)
     * @param  int|null $threshold The minimum number matches in 1 hour to be considered a likely location. (optional, default to 1)
     * @param  string|null $distance_unit Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS} (optional, default to 'MILES')
     * @param  float|null $search_range Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \&quot;0\&quot; (zero) will ignore the radius restriction. (optional, default to 0)
     * @param  string|null $sort_order The ordering algorithm for sorting the returned results: {MATCHES, DISTANCE, WEIGHTED} (optional, default to 'MATCHES')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPredictedLocations'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getPredictedLocationsRequest($version, $account_id, $latitude = null, $longitude = null, $date_check = null, $hour_check = null, $threshold = 1, $distance_unit = 'MILES', $search_range = 0, $sort_order = 'MATCHES', string $contentType = self::contentTypes['getPredictedLocations'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling getPredictedLocations'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling getPredictedLocations'
            );
        }










        $resourcePath = '/api/{version}/tracking/predicted/get';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $latitude,
            'latitude', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $longitude,
            'longitude', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $date_check,
            'dateCheck', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $hour_check,
            'hourCheck', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $threshold,
            'threshold', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $distance_unit,
            'distanceUnit', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $search_range,
            'searchRange', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort_order,
            'sortOrder', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPredictedPath
     *
     * Get Tracking Path
     *
     * @param  float $version version (required)
     * @param  int $account_id The account id of the customer (required)
     * @param  int $start_step_id The stepId to begin from (required)
     * @param  int $end_step_id The stepId to end with (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPredictedPath'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\StepResponse[]
     */
    public function getPredictedPath($version, $account_id, $start_step_id, $end_step_id, string $contentType = self::contentTypes['getPredictedPath'][0])
    {
        list($response) = $this->getPredictedPathWithHttpInfo($version, $account_id, $start_step_id, $end_step_id, $contentType);
        return $response;
    }

    /**
     * Operation getPredictedPathWithHttpInfo
     *
     * Get Tracking Path
     *
     * @param  float $version (required)
     * @param  int $account_id The account id of the customer (required)
     * @param  int $start_step_id The stepId to begin from (required)
     * @param  int $end_step_id The stepId to end with (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPredictedPath'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\StepResponse[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getPredictedPathWithHttpInfo($version, $account_id, $start_step_id, $end_step_id, string $contentType = self::contentTypes['getPredictedPath'][0])
    {
        $request = $this->getPredictedPathRequest($version, $account_id, $start_step_id, $end_step_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\StepResponse[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\StepResponse[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\StepResponse[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getPredictedPathAsync
     *
     * Get Tracking Path
     *
     * @param  float $version (required)
     * @param  int $account_id The account id of the customer (required)
     * @param  int $start_step_id The stepId to begin from (required)
     * @param  int $end_step_id The stepId to end with (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPredictedPath'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPredictedPathAsync($version, $account_id, $start_step_id, $end_step_id, string $contentType = self::contentTypes['getPredictedPath'][0])
    {
        return $this->getPredictedPathAsyncWithHttpInfo($version, $account_id, $start_step_id, $end_step_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPredictedPathAsyncWithHttpInfo
     *
     * Get Tracking Path
     *
     * @param  float $version (required)
     * @param  int $account_id The account id of the customer (required)
     * @param  int $start_step_id The stepId to begin from (required)
     * @param  int $end_step_id The stepId to end with (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPredictedPath'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPredictedPathAsyncWithHttpInfo($version, $account_id, $start_step_id, $end_step_id, string $contentType = self::contentTypes['getPredictedPath'][0])
    {
        $returnType = '\OpenAPI\Client\Model\StepResponse[]';
        $request = $this->getPredictedPathRequest($version, $account_id, $start_step_id, $end_step_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPredictedPath'
     *
     * @param  float $version (required)
     * @param  int $account_id The account id of the customer (required)
     * @param  int $start_step_id The stepId to begin from (required)
     * @param  int $end_step_id The stepId to end with (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPredictedPath'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getPredictedPathRequest($version, $account_id, $start_step_id, $end_step_id, string $contentType = self::contentTypes['getPredictedPath'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling getPredictedPath'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling getPredictedPath'
            );
        }

        // verify the required parameter 'start_step_id' is set
        if ($start_step_id === null || (is_array($start_step_id) && count($start_step_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $start_step_id when calling getPredictedPath'
            );
        }

        // verify the required parameter 'end_step_id' is set
        if ($end_step_id === null || (is_array($end_step_id) && count($end_step_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $end_step_id when calling getPredictedPath'
            );
        }


        $resourcePath = '/api/{version}/tracking/path/get';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_step_id,
            'startStepId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_step_id,
            'endStepId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPreferredLocations
     *
     * Search Preferred Locations
     *
     * @param  float $version version (required)
     * @param  int $account_id The account id of the customer (required)
     * @param  float|null $latitude latitude to return a more likely result set based on the user&#39;s current location (optional)
     * @param  float|null $longitude longitude to return a more likely result set based on the user&#39;s current location (optional)
     * @param  int|null $date_check Used to specify which day to get preferred locations for. So if you want to look at where they might be tomorrow, pass in tomorrow&#39;s date (timestamp in milliseconds). If no value is passed in, results from all time will be returned. (optional)
     * @param  string|null $hour_check Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see preferred locations for the mornings and evening you can pass in \&quot;8,9,10,11,17,18,19,20\&quot;. (optional)
     * @param  string|null $sort_field Specifies how the results will be ordered. Supported values include: CREATED - the time of when the preferred location data was processed. PREFERRED_DATE - the time of when the user sent in the tracking data. HOUR - the hour of when the user sent in the tracking data. DURATION - the duration of the preferred location (optional, default to 'PREFERRED_DATE')
     * @param  bool|null $descending Determines whether the sorted list is in descending or ascending order (optional, default to true)
     * @param  int|null $start The start index for pagination (optional, default to 0)
     * @param  int|null $limit The limit for pagination (optional, default to 20)
     * @param  float|null $search_range Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \&quot;0\&quot; (zero) will ignore the radius restriction. (optional, default to 0)
     * @param  string|null $distance_unit Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS} (optional, default to 'MILES')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPreferredLocations'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PreferredLocationResponse[]
     */
    public function getPreferredLocations($version, $account_id, $latitude = null, $longitude = null, $date_check = null, $hour_check = null, $sort_field = 'PREFERRED_DATE', $descending = true, $start = 0, $limit = 20, $search_range = 0, $distance_unit = 'MILES', string $contentType = self::contentTypes['getPreferredLocations'][0])
    {
        list($response) = $this->getPreferredLocationsWithHttpInfo($version, $account_id, $latitude, $longitude, $date_check, $hour_check, $sort_field, $descending, $start, $limit, $search_range, $distance_unit, $contentType);
        return $response;
    }

    /**
     * Operation getPreferredLocationsWithHttpInfo
     *
     * Search Preferred Locations
     *
     * @param  float $version (required)
     * @param  int $account_id The account id of the customer (required)
     * @param  float|null $latitude latitude to return a more likely result set based on the user&#39;s current location (optional)
     * @param  float|null $longitude longitude to return a more likely result set based on the user&#39;s current location (optional)
     * @param  int|null $date_check Used to specify which day to get preferred locations for. So if you want to look at where they might be tomorrow, pass in tomorrow&#39;s date (timestamp in milliseconds). If no value is passed in, results from all time will be returned. (optional)
     * @param  string|null $hour_check Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see preferred locations for the mornings and evening you can pass in \&quot;8,9,10,11,17,18,19,20\&quot;. (optional)
     * @param  string|null $sort_field Specifies how the results will be ordered. Supported values include: CREATED - the time of when the preferred location data was processed. PREFERRED_DATE - the time of when the user sent in the tracking data. HOUR - the hour of when the user sent in the tracking data. DURATION - the duration of the preferred location (optional, default to 'PREFERRED_DATE')
     * @param  bool|null $descending Determines whether the sorted list is in descending or ascending order (optional, default to true)
     * @param  int|null $start The start index for pagination (optional, default to 0)
     * @param  int|null $limit The limit for pagination (optional, default to 20)
     * @param  float|null $search_range Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \&quot;0\&quot; (zero) will ignore the radius restriction. (optional, default to 0)
     * @param  string|null $distance_unit Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS} (optional, default to 'MILES')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPreferredLocations'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PreferredLocationResponse[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getPreferredLocationsWithHttpInfo($version, $account_id, $latitude = null, $longitude = null, $date_check = null, $hour_check = null, $sort_field = 'PREFERRED_DATE', $descending = true, $start = 0, $limit = 20, $search_range = 0, $distance_unit = 'MILES', string $contentType = self::contentTypes['getPreferredLocations'][0])
    {
        $request = $this->getPreferredLocationsRequest($version, $account_id, $latitude, $longitude, $date_check, $hour_check, $sort_field, $descending, $start, $limit, $search_range, $distance_unit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\PreferredLocationResponse[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\PreferredLocationResponse[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PreferredLocationResponse[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getPreferredLocationsAsync
     *
     * Search Preferred Locations
     *
     * @param  float $version (required)
     * @param  int $account_id The account id of the customer (required)
     * @param  float|null $latitude latitude to return a more likely result set based on the user&#39;s current location (optional)
     * @param  float|null $longitude longitude to return a more likely result set based on the user&#39;s current location (optional)
     * @param  int|null $date_check Used to specify which day to get preferred locations for. So if you want to look at where they might be tomorrow, pass in tomorrow&#39;s date (timestamp in milliseconds). If no value is passed in, results from all time will be returned. (optional)
     * @param  string|null $hour_check Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see preferred locations for the mornings and evening you can pass in \&quot;8,9,10,11,17,18,19,20\&quot;. (optional)
     * @param  string|null $sort_field Specifies how the results will be ordered. Supported values include: CREATED - the time of when the preferred location data was processed. PREFERRED_DATE - the time of when the user sent in the tracking data. HOUR - the hour of when the user sent in the tracking data. DURATION - the duration of the preferred location (optional, default to 'PREFERRED_DATE')
     * @param  bool|null $descending Determines whether the sorted list is in descending or ascending order (optional, default to true)
     * @param  int|null $start The start index for pagination (optional, default to 0)
     * @param  int|null $limit The limit for pagination (optional, default to 20)
     * @param  float|null $search_range Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \&quot;0\&quot; (zero) will ignore the radius restriction. (optional, default to 0)
     * @param  string|null $distance_unit Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS} (optional, default to 'MILES')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPreferredLocations'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPreferredLocationsAsync($version, $account_id, $latitude = null, $longitude = null, $date_check = null, $hour_check = null, $sort_field = 'PREFERRED_DATE', $descending = true, $start = 0, $limit = 20, $search_range = 0, $distance_unit = 'MILES', string $contentType = self::contentTypes['getPreferredLocations'][0])
    {
        return $this->getPreferredLocationsAsyncWithHttpInfo($version, $account_id, $latitude, $longitude, $date_check, $hour_check, $sort_field, $descending, $start, $limit, $search_range, $distance_unit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPreferredLocationsAsyncWithHttpInfo
     *
     * Search Preferred Locations
     *
     * @param  float $version (required)
     * @param  int $account_id The account id of the customer (required)
     * @param  float|null $latitude latitude to return a more likely result set based on the user&#39;s current location (optional)
     * @param  float|null $longitude longitude to return a more likely result set based on the user&#39;s current location (optional)
     * @param  int|null $date_check Used to specify which day to get preferred locations for. So if you want to look at where they might be tomorrow, pass in tomorrow&#39;s date (timestamp in milliseconds). If no value is passed in, results from all time will be returned. (optional)
     * @param  string|null $hour_check Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see preferred locations for the mornings and evening you can pass in \&quot;8,9,10,11,17,18,19,20\&quot;. (optional)
     * @param  string|null $sort_field Specifies how the results will be ordered. Supported values include: CREATED - the time of when the preferred location data was processed. PREFERRED_DATE - the time of when the user sent in the tracking data. HOUR - the hour of when the user sent in the tracking data. DURATION - the duration of the preferred location (optional, default to 'PREFERRED_DATE')
     * @param  bool|null $descending Determines whether the sorted list is in descending or ascending order (optional, default to true)
     * @param  int|null $start The start index for pagination (optional, default to 0)
     * @param  int|null $limit The limit for pagination (optional, default to 20)
     * @param  float|null $search_range Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \&quot;0\&quot; (zero) will ignore the radius restriction. (optional, default to 0)
     * @param  string|null $distance_unit Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS} (optional, default to 'MILES')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPreferredLocations'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPreferredLocationsAsyncWithHttpInfo($version, $account_id, $latitude = null, $longitude = null, $date_check = null, $hour_check = null, $sort_field = 'PREFERRED_DATE', $descending = true, $start = 0, $limit = 20, $search_range = 0, $distance_unit = 'MILES', string $contentType = self::contentTypes['getPreferredLocations'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PreferredLocationResponse[]';
        $request = $this->getPreferredLocationsRequest($version, $account_id, $latitude, $longitude, $date_check, $hour_check, $sort_field, $descending, $start, $limit, $search_range, $distance_unit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPreferredLocations'
     *
     * @param  float $version (required)
     * @param  int $account_id The account id of the customer (required)
     * @param  float|null $latitude latitude to return a more likely result set based on the user&#39;s current location (optional)
     * @param  float|null $longitude longitude to return a more likely result set based on the user&#39;s current location (optional)
     * @param  int|null $date_check Used to specify which day to get preferred locations for. So if you want to look at where they might be tomorrow, pass in tomorrow&#39;s date (timestamp in milliseconds). If no value is passed in, results from all time will be returned. (optional)
     * @param  string|null $hour_check Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see preferred locations for the mornings and evening you can pass in \&quot;8,9,10,11,17,18,19,20\&quot;. (optional)
     * @param  string|null $sort_field Specifies how the results will be ordered. Supported values include: CREATED - the time of when the preferred location data was processed. PREFERRED_DATE - the time of when the user sent in the tracking data. HOUR - the hour of when the user sent in the tracking data. DURATION - the duration of the preferred location (optional, default to 'PREFERRED_DATE')
     * @param  bool|null $descending Determines whether the sorted list is in descending or ascending order (optional, default to true)
     * @param  int|null $start The start index for pagination (optional, default to 0)
     * @param  int|null $limit The limit for pagination (optional, default to 20)
     * @param  float|null $search_range Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \&quot;0\&quot; (zero) will ignore the radius restriction. (optional, default to 0)
     * @param  string|null $distance_unit Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS} (optional, default to 'MILES')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPreferredLocations'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getPreferredLocationsRequest($version, $account_id, $latitude = null, $longitude = null, $date_check = null, $hour_check = null, $sort_field = 'PREFERRED_DATE', $descending = true, $start = 0, $limit = 20, $search_range = 0, $distance_unit = 'MILES', string $contentType = self::contentTypes['getPreferredLocations'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling getPreferredLocations'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling getPreferredLocations'
            );
        }












        $resourcePath = '/api/{version}/tracking/preferred/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $latitude,
            'latitude', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $longitude,
            'longitude', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $date_check,
            'dateCheck', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $hour_check,
            'hourCheck', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort_field,
            'sortField', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $descending,
            'descending', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start,
            'start', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $search_range,
            'searchRange', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $distance_unit,
            'distanceUnit', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTrackingLegs
     *
     * Search Tracking
     *
     * @param  float $version version (required)
     * @param  string|null $device_id the device id (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  int|null $owner_id the account id of the person the user wants to tracking data for (optional)
     * @param  string|null $tracking_device_id the id of the tracking device (optional)
     * @param  int|null $start_date the start date in (UTC milliseconds) to filter the tracking results. If no startDate is passed in, the last 30 days will be returned. (optional)
     * @param  int|null $end_date the end date in (UTC milliseconds) to filter the tracking results (optional)
     * @param  string|null $tags filter results by tag (optional)
     * @param  bool|null $get_last_point gets the last known location of the user (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTrackingLegs'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\LegResponse[]
     */
    public function getTrackingLegs($version, $device_id = null, $account_id = null, $owner_id = null, $tracking_device_id = null, $start_date = null, $end_date = null, $tags = null, $get_last_point = false, string $contentType = self::contentTypes['getTrackingLegs'][0])
    {
        list($response) = $this->getTrackingLegsWithHttpInfo($version, $device_id, $account_id, $owner_id, $tracking_device_id, $start_date, $end_date, $tags, $get_last_point, $contentType);
        return $response;
    }

    /**
     * Operation getTrackingLegsWithHttpInfo
     *
     * Search Tracking
     *
     * @param  float $version (required)
     * @param  string|null $device_id the device id (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  int|null $owner_id the account id of the person the user wants to tracking data for (optional)
     * @param  string|null $tracking_device_id the id of the tracking device (optional)
     * @param  int|null $start_date the start date in (UTC milliseconds) to filter the tracking results. If no startDate is passed in, the last 30 days will be returned. (optional)
     * @param  int|null $end_date the end date in (UTC milliseconds) to filter the tracking results (optional)
     * @param  string|null $tags filter results by tag (optional)
     * @param  bool|null $get_last_point gets the last known location of the user (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTrackingLegs'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\LegResponse[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getTrackingLegsWithHttpInfo($version, $device_id = null, $account_id = null, $owner_id = null, $tracking_device_id = null, $start_date = null, $end_date = null, $tags = null, $get_last_point = false, string $contentType = self::contentTypes['getTrackingLegs'][0])
    {
        $request = $this->getTrackingLegsRequest($version, $device_id, $account_id, $owner_id, $tracking_device_id, $start_date, $end_date, $tags, $get_last_point, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\LegResponse[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\LegResponse[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\LegResponse[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getTrackingLegsAsync
     *
     * Search Tracking
     *
     * @param  float $version (required)
     * @param  string|null $device_id the device id (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  int|null $owner_id the account id of the person the user wants to tracking data for (optional)
     * @param  string|null $tracking_device_id the id of the tracking device (optional)
     * @param  int|null $start_date the start date in (UTC milliseconds) to filter the tracking results. If no startDate is passed in, the last 30 days will be returned. (optional)
     * @param  int|null $end_date the end date in (UTC milliseconds) to filter the tracking results (optional)
     * @param  string|null $tags filter results by tag (optional)
     * @param  bool|null $get_last_point gets the last known location of the user (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTrackingLegs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTrackingLegsAsync($version, $device_id = null, $account_id = null, $owner_id = null, $tracking_device_id = null, $start_date = null, $end_date = null, $tags = null, $get_last_point = false, string $contentType = self::contentTypes['getTrackingLegs'][0])
    {
        return $this->getTrackingLegsAsyncWithHttpInfo($version, $device_id, $account_id, $owner_id, $tracking_device_id, $start_date, $end_date, $tags, $get_last_point, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTrackingLegsAsyncWithHttpInfo
     *
     * Search Tracking
     *
     * @param  float $version (required)
     * @param  string|null $device_id the device id (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  int|null $owner_id the account id of the person the user wants to tracking data for (optional)
     * @param  string|null $tracking_device_id the id of the tracking device (optional)
     * @param  int|null $start_date the start date in (UTC milliseconds) to filter the tracking results. If no startDate is passed in, the last 30 days will be returned. (optional)
     * @param  int|null $end_date the end date in (UTC milliseconds) to filter the tracking results (optional)
     * @param  string|null $tags filter results by tag (optional)
     * @param  bool|null $get_last_point gets the last known location of the user (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTrackingLegs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTrackingLegsAsyncWithHttpInfo($version, $device_id = null, $account_id = null, $owner_id = null, $tracking_device_id = null, $start_date = null, $end_date = null, $tags = null, $get_last_point = false, string $contentType = self::contentTypes['getTrackingLegs'][0])
    {
        $returnType = '\OpenAPI\Client\Model\LegResponse[]';
        $request = $this->getTrackingLegsRequest($version, $device_id, $account_id, $owner_id, $tracking_device_id, $start_date, $end_date, $tags, $get_last_point, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTrackingLegs'
     *
     * @param  float $version (required)
     * @param  string|null $device_id the device id (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  int|null $owner_id the account id of the person the user wants to tracking data for (optional)
     * @param  string|null $tracking_device_id the id of the tracking device (optional)
     * @param  int|null $start_date the start date in (UTC milliseconds) to filter the tracking results. If no startDate is passed in, the last 30 days will be returned. (optional)
     * @param  int|null $end_date the end date in (UTC milliseconds) to filter the tracking results (optional)
     * @param  string|null $tags filter results by tag (optional)
     * @param  bool|null $get_last_point gets the last known location of the user (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTrackingLegs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getTrackingLegsRequest($version, $device_id = null, $account_id = null, $owner_id = null, $tracking_device_id = null, $start_date = null, $end_date = null, $tags = null, $get_last_point = false, string $contentType = self::contentTypes['getTrackingLegs'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling getTrackingLegs'
            );
        }










        $resourcePath = '/api/{version}/tracking/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_id,
            'deviceId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $owner_id,
            'ownerId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tracking_device_id,
            'trackingDeviceId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'startDate', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'endDate', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tags,
            'tags', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $get_last_point,
            'getLastPoint', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation saveTrackingLeg
     *
     * Create Tracking Leg
     *
     * @param  float $version version (required)
     * @param  float $start_lat the latitude of the first point (required)
     * @param  float $start_lng the longitude of the first point (required)
     * @param  int $start_date the start date (in UTC milliseconds) of the first point (required)
     * @param  float $end_lat the latitude of the last point (required)
     * @param  float $end_lng the longitude of the last point (required)
     * @param  int $end_date the end date (in UTC milliseconds) of the last point (required)
     * @param  string|null $device_id the device id (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  float|null $distance the total distance (optional)
     * @param  int|null $duration the total duration (optional)
     * @param  string|null $steps JSON array of tracking vectors used for smoother pathing data. If null then the leg data will be used to generate a single step, if an empty array then no steps will be generated. &#x60;&#x60;&#x60;json [{   \&quot;distance\&quot;: \&quot;0.03\&quot;,   \&quot;duration\&quot;: \&quot;5000\&quot;,   \&quot;startLat\&quot;: \&quot;47.614603\&quot;,   \&quot;startLng\&quot;: \&quot;-122.350518\&quot;,   \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,   \&quot;endLat\&quot;: \&quot;47.614941\&quot;,   \&quot;endLng\&quot;: \&quot;-122.350062\&quot;,   \&quot;endDate\&quot;: \&quot;1361924015000\&quot; }] &#x60;&#x60;&#x60; (optional)
     * @param  string|null $tags name the leg for searching (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['saveTrackingLeg'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SirqulResponse
     */
    public function saveTrackingLeg($version, $start_lat, $start_lng, $start_date, $end_lat, $end_lng, $end_date, $device_id = null, $account_id = null, $distance = null, $duration = null, $steps = null, $tags = null, string $contentType = self::contentTypes['saveTrackingLeg'][0])
    {
        list($response) = $this->saveTrackingLegWithHttpInfo($version, $start_lat, $start_lng, $start_date, $end_lat, $end_lng, $end_date, $device_id, $account_id, $distance, $duration, $steps, $tags, $contentType);
        return $response;
    }

    /**
     * Operation saveTrackingLegWithHttpInfo
     *
     * Create Tracking Leg
     *
     * @param  float $version (required)
     * @param  float $start_lat the latitude of the first point (required)
     * @param  float $start_lng the longitude of the first point (required)
     * @param  int $start_date the start date (in UTC milliseconds) of the first point (required)
     * @param  float $end_lat the latitude of the last point (required)
     * @param  float $end_lng the longitude of the last point (required)
     * @param  int $end_date the end date (in UTC milliseconds) of the last point (required)
     * @param  string|null $device_id the device id (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  float|null $distance the total distance (optional)
     * @param  int|null $duration the total duration (optional)
     * @param  string|null $steps JSON array of tracking vectors used for smoother pathing data. If null then the leg data will be used to generate a single step, if an empty array then no steps will be generated. &#x60;&#x60;&#x60;json [{   \&quot;distance\&quot;: \&quot;0.03\&quot;,   \&quot;duration\&quot;: \&quot;5000\&quot;,   \&quot;startLat\&quot;: \&quot;47.614603\&quot;,   \&quot;startLng\&quot;: \&quot;-122.350518\&quot;,   \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,   \&quot;endLat\&quot;: \&quot;47.614941\&quot;,   \&quot;endLng\&quot;: \&quot;-122.350062\&quot;,   \&quot;endDate\&quot;: \&quot;1361924015000\&quot; }] &#x60;&#x60;&#x60; (optional)
     * @param  string|null $tags name the leg for searching (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['saveTrackingLeg'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SirqulResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function saveTrackingLegWithHttpInfo($version, $start_lat, $start_lng, $start_date, $end_lat, $end_lng, $end_date, $device_id = null, $account_id = null, $distance = null, $duration = null, $steps = null, $tags = null, string $contentType = self::contentTypes['saveTrackingLeg'][0])
    {
        $request = $this->saveTrackingLegRequest($version, $start_lat, $start_lng, $start_date, $end_lat, $end_lng, $end_date, $device_id, $account_id, $distance, $duration, $steps, $tags, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\SirqulResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\SirqulResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SirqulResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation saveTrackingLegAsync
     *
     * Create Tracking Leg
     *
     * @param  float $version (required)
     * @param  float $start_lat the latitude of the first point (required)
     * @param  float $start_lng the longitude of the first point (required)
     * @param  int $start_date the start date (in UTC milliseconds) of the first point (required)
     * @param  float $end_lat the latitude of the last point (required)
     * @param  float $end_lng the longitude of the last point (required)
     * @param  int $end_date the end date (in UTC milliseconds) of the last point (required)
     * @param  string|null $device_id the device id (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  float|null $distance the total distance (optional)
     * @param  int|null $duration the total duration (optional)
     * @param  string|null $steps JSON array of tracking vectors used for smoother pathing data. If null then the leg data will be used to generate a single step, if an empty array then no steps will be generated. &#x60;&#x60;&#x60;json [{   \&quot;distance\&quot;: \&quot;0.03\&quot;,   \&quot;duration\&quot;: \&quot;5000\&quot;,   \&quot;startLat\&quot;: \&quot;47.614603\&quot;,   \&quot;startLng\&quot;: \&quot;-122.350518\&quot;,   \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,   \&quot;endLat\&quot;: \&quot;47.614941\&quot;,   \&quot;endLng\&quot;: \&quot;-122.350062\&quot;,   \&quot;endDate\&quot;: \&quot;1361924015000\&quot; }] &#x60;&#x60;&#x60; (optional)
     * @param  string|null $tags name the leg for searching (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['saveTrackingLeg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function saveTrackingLegAsync($version, $start_lat, $start_lng, $start_date, $end_lat, $end_lng, $end_date, $device_id = null, $account_id = null, $distance = null, $duration = null, $steps = null, $tags = null, string $contentType = self::contentTypes['saveTrackingLeg'][0])
    {
        return $this->saveTrackingLegAsyncWithHttpInfo($version, $start_lat, $start_lng, $start_date, $end_lat, $end_lng, $end_date, $device_id, $account_id, $distance, $duration, $steps, $tags, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation saveTrackingLegAsyncWithHttpInfo
     *
     * Create Tracking Leg
     *
     * @param  float $version (required)
     * @param  float $start_lat the latitude of the first point (required)
     * @param  float $start_lng the longitude of the first point (required)
     * @param  int $start_date the start date (in UTC milliseconds) of the first point (required)
     * @param  float $end_lat the latitude of the last point (required)
     * @param  float $end_lng the longitude of the last point (required)
     * @param  int $end_date the end date (in UTC milliseconds) of the last point (required)
     * @param  string|null $device_id the device id (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  float|null $distance the total distance (optional)
     * @param  int|null $duration the total duration (optional)
     * @param  string|null $steps JSON array of tracking vectors used for smoother pathing data. If null then the leg data will be used to generate a single step, if an empty array then no steps will be generated. &#x60;&#x60;&#x60;json [{   \&quot;distance\&quot;: \&quot;0.03\&quot;,   \&quot;duration\&quot;: \&quot;5000\&quot;,   \&quot;startLat\&quot;: \&quot;47.614603\&quot;,   \&quot;startLng\&quot;: \&quot;-122.350518\&quot;,   \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,   \&quot;endLat\&quot;: \&quot;47.614941\&quot;,   \&quot;endLng\&quot;: \&quot;-122.350062\&quot;,   \&quot;endDate\&quot;: \&quot;1361924015000\&quot; }] &#x60;&#x60;&#x60; (optional)
     * @param  string|null $tags name the leg for searching (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['saveTrackingLeg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function saveTrackingLegAsyncWithHttpInfo($version, $start_lat, $start_lng, $start_date, $end_lat, $end_lng, $end_date, $device_id = null, $account_id = null, $distance = null, $duration = null, $steps = null, $tags = null, string $contentType = self::contentTypes['saveTrackingLeg'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SirqulResponse';
        $request = $this->saveTrackingLegRequest($version, $start_lat, $start_lng, $start_date, $end_lat, $end_lng, $end_date, $device_id, $account_id, $distance, $duration, $steps, $tags, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'saveTrackingLeg'
     *
     * @param  float $version (required)
     * @param  float $start_lat the latitude of the first point (required)
     * @param  float $start_lng the longitude of the first point (required)
     * @param  int $start_date the start date (in UTC milliseconds) of the first point (required)
     * @param  float $end_lat the latitude of the last point (required)
     * @param  float $end_lng the longitude of the last point (required)
     * @param  int $end_date the end date (in UTC milliseconds) of the last point (required)
     * @param  string|null $device_id the device id (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  float|null $distance the total distance (optional)
     * @param  int|null $duration the total duration (optional)
     * @param  string|null $steps JSON array of tracking vectors used for smoother pathing data. If null then the leg data will be used to generate a single step, if an empty array then no steps will be generated. &#x60;&#x60;&#x60;json [{   \&quot;distance\&quot;: \&quot;0.03\&quot;,   \&quot;duration\&quot;: \&quot;5000\&quot;,   \&quot;startLat\&quot;: \&quot;47.614603\&quot;,   \&quot;startLng\&quot;: \&quot;-122.350518\&quot;,   \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,   \&quot;endLat\&quot;: \&quot;47.614941\&quot;,   \&quot;endLng\&quot;: \&quot;-122.350062\&quot;,   \&quot;endDate\&quot;: \&quot;1361924015000\&quot; }] &#x60;&#x60;&#x60; (optional)
     * @param  string|null $tags name the leg for searching (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['saveTrackingLeg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function saveTrackingLegRequest($version, $start_lat, $start_lng, $start_date, $end_lat, $end_lng, $end_date, $device_id = null, $account_id = null, $distance = null, $duration = null, $steps = null, $tags = null, string $contentType = self::contentTypes['saveTrackingLeg'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling saveTrackingLeg'
            );
        }

        // verify the required parameter 'start_lat' is set
        if ($start_lat === null || (is_array($start_lat) && count($start_lat) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $start_lat when calling saveTrackingLeg'
            );
        }

        // verify the required parameter 'start_lng' is set
        if ($start_lng === null || (is_array($start_lng) && count($start_lng) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $start_lng when calling saveTrackingLeg'
            );
        }

        // verify the required parameter 'start_date' is set
        if ($start_date === null || (is_array($start_date) && count($start_date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $start_date when calling saveTrackingLeg'
            );
        }

        // verify the required parameter 'end_lat' is set
        if ($end_lat === null || (is_array($end_lat) && count($end_lat) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $end_lat when calling saveTrackingLeg'
            );
        }

        // verify the required parameter 'end_lng' is set
        if ($end_lng === null || (is_array($end_lng) && count($end_lng) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $end_lng when calling saveTrackingLeg'
            );
        }

        // verify the required parameter 'end_date' is set
        if ($end_date === null || (is_array($end_date) && count($end_date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $end_date when calling saveTrackingLeg'
            );
        }








        $resourcePath = '/api/{version}/tracking/leg/create';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_id,
            'deviceId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $distance,
            'distance', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $duration,
            'duration', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_lat,
            'startLat', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_lng,
            'startLng', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'startDate', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_lat,
            'endLat', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_lng,
            'endLng', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'endDate', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $steps,
            'steps', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tags,
            'tags', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation saveTrackingStep
     *
     * Create Tracking Step
     *
     * @param  float $version version (required)
     * @param  int $leg_id the leg to add the step to (required)
     * @param  float $start_lat the latitude of the first point (required)
     * @param  float $start_lng the longitude of the first point (required)
     * @param  int $start_date the start date (in UTC milliseconds) of the first point (required)
     * @param  float $end_lat the latitude of the last point (required)
     * @param  float $end_lng the longitude of the last point (required)
     * @param  int $end_date the end date (in UTC milliseconds) of the last point (required)
     * @param  string|null $device_id the device id (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  float|null $distance the total distance (optional)
     * @param  int|null $duration the total duration (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['saveTrackingStep'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SirqulResponse
     */
    public function saveTrackingStep($version, $leg_id, $start_lat, $start_lng, $start_date, $end_lat, $end_lng, $end_date, $device_id = null, $account_id = null, $distance = null, $duration = null, string $contentType = self::contentTypes['saveTrackingStep'][0])
    {
        list($response) = $this->saveTrackingStepWithHttpInfo($version, $leg_id, $start_lat, $start_lng, $start_date, $end_lat, $end_lng, $end_date, $device_id, $account_id, $distance, $duration, $contentType);
        return $response;
    }

    /**
     * Operation saveTrackingStepWithHttpInfo
     *
     * Create Tracking Step
     *
     * @param  float $version (required)
     * @param  int $leg_id the leg to add the step to (required)
     * @param  float $start_lat the latitude of the first point (required)
     * @param  float $start_lng the longitude of the first point (required)
     * @param  int $start_date the start date (in UTC milliseconds) of the first point (required)
     * @param  float $end_lat the latitude of the last point (required)
     * @param  float $end_lng the longitude of the last point (required)
     * @param  int $end_date the end date (in UTC milliseconds) of the last point (required)
     * @param  string|null $device_id the device id (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  float|null $distance the total distance (optional)
     * @param  int|null $duration the total duration (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['saveTrackingStep'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SirqulResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function saveTrackingStepWithHttpInfo($version, $leg_id, $start_lat, $start_lng, $start_date, $end_lat, $end_lng, $end_date, $device_id = null, $account_id = null, $distance = null, $duration = null, string $contentType = self::contentTypes['saveTrackingStep'][0])
    {
        $request = $this->saveTrackingStepRequest($version, $leg_id, $start_lat, $start_lng, $start_date, $end_lat, $end_lng, $end_date, $device_id, $account_id, $distance, $duration, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\SirqulResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\SirqulResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SirqulResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation saveTrackingStepAsync
     *
     * Create Tracking Step
     *
     * @param  float $version (required)
     * @param  int $leg_id the leg to add the step to (required)
     * @param  float $start_lat the latitude of the first point (required)
     * @param  float $start_lng the longitude of the first point (required)
     * @param  int $start_date the start date (in UTC milliseconds) of the first point (required)
     * @param  float $end_lat the latitude of the last point (required)
     * @param  float $end_lng the longitude of the last point (required)
     * @param  int $end_date the end date (in UTC milliseconds) of the last point (required)
     * @param  string|null $device_id the device id (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  float|null $distance the total distance (optional)
     * @param  int|null $duration the total duration (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['saveTrackingStep'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function saveTrackingStepAsync($version, $leg_id, $start_lat, $start_lng, $start_date, $end_lat, $end_lng, $end_date, $device_id = null, $account_id = null, $distance = null, $duration = null, string $contentType = self::contentTypes['saveTrackingStep'][0])
    {
        return $this->saveTrackingStepAsyncWithHttpInfo($version, $leg_id, $start_lat, $start_lng, $start_date, $end_lat, $end_lng, $end_date, $device_id, $account_id, $distance, $duration, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation saveTrackingStepAsyncWithHttpInfo
     *
     * Create Tracking Step
     *
     * @param  float $version (required)
     * @param  int $leg_id the leg to add the step to (required)
     * @param  float $start_lat the latitude of the first point (required)
     * @param  float $start_lng the longitude of the first point (required)
     * @param  int $start_date the start date (in UTC milliseconds) of the first point (required)
     * @param  float $end_lat the latitude of the last point (required)
     * @param  float $end_lng the longitude of the last point (required)
     * @param  int $end_date the end date (in UTC milliseconds) of the last point (required)
     * @param  string|null $device_id the device id (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  float|null $distance the total distance (optional)
     * @param  int|null $duration the total duration (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['saveTrackingStep'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function saveTrackingStepAsyncWithHttpInfo($version, $leg_id, $start_lat, $start_lng, $start_date, $end_lat, $end_lng, $end_date, $device_id = null, $account_id = null, $distance = null, $duration = null, string $contentType = self::contentTypes['saveTrackingStep'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SirqulResponse';
        $request = $this->saveTrackingStepRequest($version, $leg_id, $start_lat, $start_lng, $start_date, $end_lat, $end_lng, $end_date, $device_id, $account_id, $distance, $duration, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'saveTrackingStep'
     *
     * @param  float $version (required)
     * @param  int $leg_id the leg to add the step to (required)
     * @param  float $start_lat the latitude of the first point (required)
     * @param  float $start_lng the longitude of the first point (required)
     * @param  int $start_date the start date (in UTC milliseconds) of the first point (required)
     * @param  float $end_lat the latitude of the last point (required)
     * @param  float $end_lng the longitude of the last point (required)
     * @param  int $end_date the end date (in UTC milliseconds) of the last point (required)
     * @param  string|null $device_id the device id (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  float|null $distance the total distance (optional)
     * @param  int|null $duration the total duration (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['saveTrackingStep'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function saveTrackingStepRequest($version, $leg_id, $start_lat, $start_lng, $start_date, $end_lat, $end_lng, $end_date, $device_id = null, $account_id = null, $distance = null, $duration = null, string $contentType = self::contentTypes['saveTrackingStep'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling saveTrackingStep'
            );
        }

        // verify the required parameter 'leg_id' is set
        if ($leg_id === null || (is_array($leg_id) && count($leg_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $leg_id when calling saveTrackingStep'
            );
        }

        // verify the required parameter 'start_lat' is set
        if ($start_lat === null || (is_array($start_lat) && count($start_lat) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $start_lat when calling saveTrackingStep'
            );
        }

        // verify the required parameter 'start_lng' is set
        if ($start_lng === null || (is_array($start_lng) && count($start_lng) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $start_lng when calling saveTrackingStep'
            );
        }

        // verify the required parameter 'start_date' is set
        if ($start_date === null || (is_array($start_date) && count($start_date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $start_date when calling saveTrackingStep'
            );
        }

        // verify the required parameter 'end_lat' is set
        if ($end_lat === null || (is_array($end_lat) && count($end_lat) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $end_lat when calling saveTrackingStep'
            );
        }

        // verify the required parameter 'end_lng' is set
        if ($end_lng === null || (is_array($end_lng) && count($end_lng) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $end_lng when calling saveTrackingStep'
            );
        }

        // verify the required parameter 'end_date' is set
        if ($end_date === null || (is_array($end_date) && count($end_date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $end_date when calling saveTrackingStep'
            );
        }






        $resourcePath = '/api/{version}/tracking/step/create';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_id,
            'deviceId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $leg_id,
            'legId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $distance,
            'distance', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $duration,
            'duration', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_lat,
            'startLat', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_lng,
            'startLng', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'startDate', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_lat,
            'endLat', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_lng,
            'endLng', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'endDate', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchAccountsWithTrackingLegs
     *
     * List Tracking
     *
     * @param  float $version version (required)
     * @param  int $account_id The account id of the user (required)
     * @param  string|null $keyword Used for LIKE search of first or last name on the acocunt (optional)
     * @param  int|null $start_date Range to begin in UTC milliseconds (optional)
     * @param  int|null $end_date Range to end in UTC milliseconds (optional)
     * @param  string|null $tags Exact match on tag field of Legs&#39;s searchTag (optional)
     * @param  string|null $audience_ids  (optional)
     * @param  float|null $latitude Origin latitude to perform searching constraints with given range (optional)
     * @param  float|null $longitude Origin longitude to perform searching constraints with given range (optional)
     * @param  float|null $range The radius, in miles, to perform the search for (optional, default to 5)
     * @param  string|null $sort_field The column to sort the search on. Possible values include: {LEG_START_DATE, ACCOUNT_DISPLAY} (optional, default to 'LEG_START_DATE')
     * @param  bool|null $descending The order to return the results. Default is false, which will return the results in ascending order. (optional, default to true)
     * @param  int|null $start The index into the record set to start with. Default is 0. (optional, default to 0)
     * @param  int|null $limit The total number of records to return. Default is 20. (optional, default to 20)
     * @param  bool|null $active_only Determines whether to return only active results. Default is false. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchAccountsWithTrackingLegs'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AccountMiniResponse[]
     */
    public function searchAccountsWithTrackingLegs($version, $account_id, $keyword = null, $start_date = null, $end_date = null, $tags = null, $audience_ids = null, $latitude = null, $longitude = null, $range = 5, $sort_field = 'LEG_START_DATE', $descending = true, $start = 0, $limit = 20, $active_only = false, string $contentType = self::contentTypes['searchAccountsWithTrackingLegs'][0])
    {
        list($response) = $this->searchAccountsWithTrackingLegsWithHttpInfo($version, $account_id, $keyword, $start_date, $end_date, $tags, $audience_ids, $latitude, $longitude, $range, $sort_field, $descending, $start, $limit, $active_only, $contentType);
        return $response;
    }

    /**
     * Operation searchAccountsWithTrackingLegsWithHttpInfo
     *
     * List Tracking
     *
     * @param  float $version (required)
     * @param  int $account_id The account id of the user (required)
     * @param  string|null $keyword Used for LIKE search of first or last name on the acocunt (optional)
     * @param  int|null $start_date Range to begin in UTC milliseconds (optional)
     * @param  int|null $end_date Range to end in UTC milliseconds (optional)
     * @param  string|null $tags Exact match on tag field of Legs&#39;s searchTag (optional)
     * @param  string|null $audience_ids  (optional)
     * @param  float|null $latitude Origin latitude to perform searching constraints with given range (optional)
     * @param  float|null $longitude Origin longitude to perform searching constraints with given range (optional)
     * @param  float|null $range The radius, in miles, to perform the search for (optional, default to 5)
     * @param  string|null $sort_field The column to sort the search on. Possible values include: {LEG_START_DATE, ACCOUNT_DISPLAY} (optional, default to 'LEG_START_DATE')
     * @param  bool|null $descending The order to return the results. Default is false, which will return the results in ascending order. (optional, default to true)
     * @param  int|null $start The index into the record set to start with. Default is 0. (optional, default to 0)
     * @param  int|null $limit The total number of records to return. Default is 20. (optional, default to 20)
     * @param  bool|null $active_only Determines whether to return only active results. Default is false. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchAccountsWithTrackingLegs'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AccountMiniResponse[], HTTP status code, HTTP response headers (array of strings)
     */
    public function searchAccountsWithTrackingLegsWithHttpInfo($version, $account_id, $keyword = null, $start_date = null, $end_date = null, $tags = null, $audience_ids = null, $latitude = null, $longitude = null, $range = 5, $sort_field = 'LEG_START_DATE', $descending = true, $start = 0, $limit = 20, $active_only = false, string $contentType = self::contentTypes['searchAccountsWithTrackingLegs'][0])
    {
        $request = $this->searchAccountsWithTrackingLegsRequest($version, $account_id, $keyword, $start_date, $end_date, $tags, $audience_ids, $latitude, $longitude, $range, $sort_field, $descending, $start, $limit, $active_only, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\AccountMiniResponse[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\AccountMiniResponse[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AccountMiniResponse[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation searchAccountsWithTrackingLegsAsync
     *
     * List Tracking
     *
     * @param  float $version (required)
     * @param  int $account_id The account id of the user (required)
     * @param  string|null $keyword Used for LIKE search of first or last name on the acocunt (optional)
     * @param  int|null $start_date Range to begin in UTC milliseconds (optional)
     * @param  int|null $end_date Range to end in UTC milliseconds (optional)
     * @param  string|null $tags Exact match on tag field of Legs&#39;s searchTag (optional)
     * @param  string|null $audience_ids  (optional)
     * @param  float|null $latitude Origin latitude to perform searching constraints with given range (optional)
     * @param  float|null $longitude Origin longitude to perform searching constraints with given range (optional)
     * @param  float|null $range The radius, in miles, to perform the search for (optional, default to 5)
     * @param  string|null $sort_field The column to sort the search on. Possible values include: {LEG_START_DATE, ACCOUNT_DISPLAY} (optional, default to 'LEG_START_DATE')
     * @param  bool|null $descending The order to return the results. Default is false, which will return the results in ascending order. (optional, default to true)
     * @param  int|null $start The index into the record set to start with. Default is 0. (optional, default to 0)
     * @param  int|null $limit The total number of records to return. Default is 20. (optional, default to 20)
     * @param  bool|null $active_only Determines whether to return only active results. Default is false. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchAccountsWithTrackingLegs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchAccountsWithTrackingLegsAsync($version, $account_id, $keyword = null, $start_date = null, $end_date = null, $tags = null, $audience_ids = null, $latitude = null, $longitude = null, $range = 5, $sort_field = 'LEG_START_DATE', $descending = true, $start = 0, $limit = 20, $active_only = false, string $contentType = self::contentTypes['searchAccountsWithTrackingLegs'][0])
    {
        return $this->searchAccountsWithTrackingLegsAsyncWithHttpInfo($version, $account_id, $keyword, $start_date, $end_date, $tags, $audience_ids, $latitude, $longitude, $range, $sort_field, $descending, $start, $limit, $active_only, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchAccountsWithTrackingLegsAsyncWithHttpInfo
     *
     * List Tracking
     *
     * @param  float $version (required)
     * @param  int $account_id The account id of the user (required)
     * @param  string|null $keyword Used for LIKE search of first or last name on the acocunt (optional)
     * @param  int|null $start_date Range to begin in UTC milliseconds (optional)
     * @param  int|null $end_date Range to end in UTC milliseconds (optional)
     * @param  string|null $tags Exact match on tag field of Legs&#39;s searchTag (optional)
     * @param  string|null $audience_ids  (optional)
     * @param  float|null $latitude Origin latitude to perform searching constraints with given range (optional)
     * @param  float|null $longitude Origin longitude to perform searching constraints with given range (optional)
     * @param  float|null $range The radius, in miles, to perform the search for (optional, default to 5)
     * @param  string|null $sort_field The column to sort the search on. Possible values include: {LEG_START_DATE, ACCOUNT_DISPLAY} (optional, default to 'LEG_START_DATE')
     * @param  bool|null $descending The order to return the results. Default is false, which will return the results in ascending order. (optional, default to true)
     * @param  int|null $start The index into the record set to start with. Default is 0. (optional, default to 0)
     * @param  int|null $limit The total number of records to return. Default is 20. (optional, default to 20)
     * @param  bool|null $active_only Determines whether to return only active results. Default is false. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchAccountsWithTrackingLegs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchAccountsWithTrackingLegsAsyncWithHttpInfo($version, $account_id, $keyword = null, $start_date = null, $end_date = null, $tags = null, $audience_ids = null, $latitude = null, $longitude = null, $range = 5, $sort_field = 'LEG_START_DATE', $descending = true, $start = 0, $limit = 20, $active_only = false, string $contentType = self::contentTypes['searchAccountsWithTrackingLegs'][0])
    {
        $returnType = '\OpenAPI\Client\Model\AccountMiniResponse[]';
        $request = $this->searchAccountsWithTrackingLegsRequest($version, $account_id, $keyword, $start_date, $end_date, $tags, $audience_ids, $latitude, $longitude, $range, $sort_field, $descending, $start, $limit, $active_only, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchAccountsWithTrackingLegs'
     *
     * @param  float $version (required)
     * @param  int $account_id The account id of the user (required)
     * @param  string|null $keyword Used for LIKE search of first or last name on the acocunt (optional)
     * @param  int|null $start_date Range to begin in UTC milliseconds (optional)
     * @param  int|null $end_date Range to end in UTC milliseconds (optional)
     * @param  string|null $tags Exact match on tag field of Legs&#39;s searchTag (optional)
     * @param  string|null $audience_ids  (optional)
     * @param  float|null $latitude Origin latitude to perform searching constraints with given range (optional)
     * @param  float|null $longitude Origin longitude to perform searching constraints with given range (optional)
     * @param  float|null $range The radius, in miles, to perform the search for (optional, default to 5)
     * @param  string|null $sort_field The column to sort the search on. Possible values include: {LEG_START_DATE, ACCOUNT_DISPLAY} (optional, default to 'LEG_START_DATE')
     * @param  bool|null $descending The order to return the results. Default is false, which will return the results in ascending order. (optional, default to true)
     * @param  int|null $start The index into the record set to start with. Default is 0. (optional, default to 0)
     * @param  int|null $limit The total number of records to return. Default is 20. (optional, default to 20)
     * @param  bool|null $active_only Determines whether to return only active results. Default is false. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchAccountsWithTrackingLegs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function searchAccountsWithTrackingLegsRequest($version, $account_id, $keyword = null, $start_date = null, $end_date = null, $tags = null, $audience_ids = null, $latitude = null, $longitude = null, $range = 5, $sort_field = 'LEG_START_DATE', $descending = true, $start = 0, $limit = 20, $active_only = false, string $contentType = self::contentTypes['searchAccountsWithTrackingLegs'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling searchAccountsWithTrackingLegs'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling searchAccountsWithTrackingLegs'
            );
        }















        $resourcePath = '/api/{version}/tracking/list';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $keyword,
            'keyword', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'startDate', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'endDate', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tags,
            'tags', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audience_ids,
            'audienceIds', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $latitude,
            'latitude', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $longitude,
            'longitude', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $range,
            'range', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort_field,
            'sortField', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $descending,
            'descending', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start,
            'start', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $active_only,
            'activeOnly', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchTrackingLegs
     *
     * Search Tracking (Billable)
     *
     * @param  float $version version (required)
     * @param  int $account_id The account id to search tracking for (required)
     * @param  string $app_key The application key (required)
     * @param  string|null $tracking_device_id The id of the tracking device (optional)
     * @param  int|null $start_date The start date in (UTC milliseconds) to filter the tracking results (optional)
     * @param  int|null $end_date The end date in (UTC milliseconds) to filter the tracking results (optional)
     * @param  string|null $tags Filter results by tag (optional)
     * @param  int|null $start The start index for pagination (optional, default to 0)
     * @param  int|null $limit The limit for pagination (optional, default to 100)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchTrackingLegs'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\LegResponse[]
     */
    public function searchTrackingLegs($version, $account_id, $app_key, $tracking_device_id = null, $start_date = null, $end_date = null, $tags = null, $start = 0, $limit = 100, string $contentType = self::contentTypes['searchTrackingLegs'][0])
    {
        list($response) = $this->searchTrackingLegsWithHttpInfo($version, $account_id, $app_key, $tracking_device_id, $start_date, $end_date, $tags, $start, $limit, $contentType);
        return $response;
    }

    /**
     * Operation searchTrackingLegsWithHttpInfo
     *
     * Search Tracking (Billable)
     *
     * @param  float $version (required)
     * @param  int $account_id The account id to search tracking for (required)
     * @param  string $app_key The application key (required)
     * @param  string|null $tracking_device_id The id of the tracking device (optional)
     * @param  int|null $start_date The start date in (UTC milliseconds) to filter the tracking results (optional)
     * @param  int|null $end_date The end date in (UTC milliseconds) to filter the tracking results (optional)
     * @param  string|null $tags Filter results by tag (optional)
     * @param  int|null $start The start index for pagination (optional, default to 0)
     * @param  int|null $limit The limit for pagination (optional, default to 100)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchTrackingLegs'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\LegResponse[], HTTP status code, HTTP response headers (array of strings)
     */
    public function searchTrackingLegsWithHttpInfo($version, $account_id, $app_key, $tracking_device_id = null, $start_date = null, $end_date = null, $tags = null, $start = 0, $limit = 100, string $contentType = self::contentTypes['searchTrackingLegs'][0])
    {
        $request = $this->searchTrackingLegsRequest($version, $account_id, $app_key, $tracking_device_id, $start_date, $end_date, $tags, $start, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\LegResponse[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\LegResponse[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\LegResponse[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation searchTrackingLegsAsync
     *
     * Search Tracking (Billable)
     *
     * @param  float $version (required)
     * @param  int $account_id The account id to search tracking for (required)
     * @param  string $app_key The application key (required)
     * @param  string|null $tracking_device_id The id of the tracking device (optional)
     * @param  int|null $start_date The start date in (UTC milliseconds) to filter the tracking results (optional)
     * @param  int|null $end_date The end date in (UTC milliseconds) to filter the tracking results (optional)
     * @param  string|null $tags Filter results by tag (optional)
     * @param  int|null $start The start index for pagination (optional, default to 0)
     * @param  int|null $limit The limit for pagination (optional, default to 100)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchTrackingLegs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchTrackingLegsAsync($version, $account_id, $app_key, $tracking_device_id = null, $start_date = null, $end_date = null, $tags = null, $start = 0, $limit = 100, string $contentType = self::contentTypes['searchTrackingLegs'][0])
    {
        return $this->searchTrackingLegsAsyncWithHttpInfo($version, $account_id, $app_key, $tracking_device_id, $start_date, $end_date, $tags, $start, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchTrackingLegsAsyncWithHttpInfo
     *
     * Search Tracking (Billable)
     *
     * @param  float $version (required)
     * @param  int $account_id The account id to search tracking for (required)
     * @param  string $app_key The application key (required)
     * @param  string|null $tracking_device_id The id of the tracking device (optional)
     * @param  int|null $start_date The start date in (UTC milliseconds) to filter the tracking results (optional)
     * @param  int|null $end_date The end date in (UTC milliseconds) to filter the tracking results (optional)
     * @param  string|null $tags Filter results by tag (optional)
     * @param  int|null $start The start index for pagination (optional, default to 0)
     * @param  int|null $limit The limit for pagination (optional, default to 100)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchTrackingLegs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchTrackingLegsAsyncWithHttpInfo($version, $account_id, $app_key, $tracking_device_id = null, $start_date = null, $end_date = null, $tags = null, $start = 0, $limit = 100, string $contentType = self::contentTypes['searchTrackingLegs'][0])
    {
        $returnType = '\OpenAPI\Client\Model\LegResponse[]';
        $request = $this->searchTrackingLegsRequest($version, $account_id, $app_key, $tracking_device_id, $start_date, $end_date, $tags, $start, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchTrackingLegs'
     *
     * @param  float $version (required)
     * @param  int $account_id The account id to search tracking for (required)
     * @param  string $app_key The application key (required)
     * @param  string|null $tracking_device_id The id of the tracking device (optional)
     * @param  int|null $start_date The start date in (UTC milliseconds) to filter the tracking results (optional)
     * @param  int|null $end_date The end date in (UTC milliseconds) to filter the tracking results (optional)
     * @param  string|null $tags Filter results by tag (optional)
     * @param  int|null $start The start index for pagination (optional, default to 0)
     * @param  int|null $limit The limit for pagination (optional, default to 100)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchTrackingLegs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function searchTrackingLegsRequest($version, $account_id, $app_key, $tracking_device_id = null, $start_date = null, $end_date = null, $tags = null, $start = 0, $limit = 100, string $contentType = self::contentTypes['searchTrackingLegs'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling searchTrackingLegs'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling searchTrackingLegs'
            );
        }

        // verify the required parameter 'app_key' is set
        if ($app_key === null || (is_array($app_key) && count($app_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_key when calling searchTrackingLegs'
            );
        }








        $resourcePath = '/api/{version}/tracking/searchByBillable';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $app_key,
            'appKey', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tracking_device_id,
            'trackingDeviceId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'startDate', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'endDate', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tags,
            'tags', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start,
            'start', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        if ($this->config->getCertFile()) {
            $options[RequestOptions::CERT] = $this->config->getCertFile();
        }

        if ($this->config->getKeyFile()) {
            $options[RequestOptions::SSL_KEY] = $this->config->getKeyFile();
        }

        return $options;
    }

    private function handleResponseWithDataType(
        string $dataType,
        RequestInterface $request,
        ResponseInterface $response
    ): array {
        if ($dataType === '\SplFileObject') {
            $content = $response->getBody(); //stream goes to serializer
        } else {
            $content = (string) $response->getBody();
            if ($dataType !== 'string') {
                try {
                    $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                } catch (\JsonException $exception) {
                    throw new ApiException(
                        sprintf(
                            'Error JSON decoding server response (%s)',
                            $request->getUri()
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                        $content
                    );
                }
            }
        }

        return [
            ObjectSerializer::deserialize($content, $dataType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    private function responseWithinRangeCode(
        string $rangeCode,
        int $statusCode
    ): bool {
        $left = (int) ($rangeCode[0].'00');
        $right = (int) ($rangeCode[0].'99');

        return $statusCode >= $left && $statusCode <= $right;
    }
}
