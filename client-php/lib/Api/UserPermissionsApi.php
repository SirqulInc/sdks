<?php
/**
 * UserPermissionsApi
 * PHP version 8.1
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Sirqul IoT Platform
 *
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.20.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\FormDataProcessor;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * UserPermissionsApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class UserPermissionsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'addUsersToPermissionable' => [
            'application/json',
        ],
        'approvePermissionable' => [
            'application/json',
        ],
        'leaveFromPermissionable' => [
            'application/json',
        ],
        'removeUsersFromPermissionable' => [
            'application/json',
        ],
        'searchPermissionables' => [
            'application/json',
        ],
        'searchPermissionablesFollowingDistance' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation addUsersToPermissionable
     *
     * Add User
     *
     * @param  float $version version (required)
     * @param  string $permissionable_type the permissionable type of the object (required)
     * @param  int $permissionable_id the id of the permissionable object (required)
     * @param  string|null $device_id the device id (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  bool|null $read the read permission of the users/groups (optional, default to true)
     * @param  bool|null $write the write permission of the users/groups (optional, default to false)
     * @param  bool|null $delete the delete permission of the users/groups (optional, default to false)
     * @param  bool|null $add the add permission of the users/groups (optional, default to false)
     * @param  string|null $connection_ids a comma separated list of connection ids (NOT the account ids) (optional)
     * @param  string|null $connection_account_ids a comma separated list of account ids (optional)
     * @param  string|null $connection_group_ids a comma separated list of connection group ids (these are groups made by the user) (optional)
     * @param  bool|null $pending sets whether the added users are marked as pending (and will require the album admins to accept) - admins can set this to false (to accept) (optional, default to false)
     * @param  bool|null $admin sets whether the added users will become admins or not (optional)
     * @param  bool|null $include_friend_group flag to determine whether to include the built-in \&quot;friends\&quot; group (optional, default to false)
     * @param  float|null $latitude the current latitude of the user (optional)
     * @param  float|null $longitude the current longitude of the user (optional)
     * @param  string|null $audience_ids comma separated list of audience ids. This is a feature only available to the permissionable&#39;s application owner (and its employees). This will add all users from these audiences to the permissionable object. Notifications will not be sent to users if this feature is used. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addUsersToPermissionable'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SirqulResponse
     */
    public function addUsersToPermissionable($version, $permissionable_type, $permissionable_id, $device_id = null, $account_id = null, $read = true, $write = false, $delete = false, $add = false, $connection_ids = null, $connection_account_ids = null, $connection_group_ids = null, $pending = false, $admin = null, $include_friend_group = false, $latitude = null, $longitude = null, $audience_ids = null, string $contentType = self::contentTypes['addUsersToPermissionable'][0])
    {
        list($response) = $this->addUsersToPermissionableWithHttpInfo($version, $permissionable_type, $permissionable_id, $device_id, $account_id, $read, $write, $delete, $add, $connection_ids, $connection_account_ids, $connection_group_ids, $pending, $admin, $include_friend_group, $latitude, $longitude, $audience_ids, $contentType);
        return $response;
    }

    /**
     * Operation addUsersToPermissionableWithHttpInfo
     *
     * Add User
     *
     * @param  float $version (required)
     * @param  string $permissionable_type the permissionable type of the object (required)
     * @param  int $permissionable_id the id of the permissionable object (required)
     * @param  string|null $device_id the device id (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  bool|null $read the read permission of the users/groups (optional, default to true)
     * @param  bool|null $write the write permission of the users/groups (optional, default to false)
     * @param  bool|null $delete the delete permission of the users/groups (optional, default to false)
     * @param  bool|null $add the add permission of the users/groups (optional, default to false)
     * @param  string|null $connection_ids a comma separated list of connection ids (NOT the account ids) (optional)
     * @param  string|null $connection_account_ids a comma separated list of account ids (optional)
     * @param  string|null $connection_group_ids a comma separated list of connection group ids (these are groups made by the user) (optional)
     * @param  bool|null $pending sets whether the added users are marked as pending (and will require the album admins to accept) - admins can set this to false (to accept) (optional, default to false)
     * @param  bool|null $admin sets whether the added users will become admins or not (optional)
     * @param  bool|null $include_friend_group flag to determine whether to include the built-in \&quot;friends\&quot; group (optional, default to false)
     * @param  float|null $latitude the current latitude of the user (optional)
     * @param  float|null $longitude the current longitude of the user (optional)
     * @param  string|null $audience_ids comma separated list of audience ids. This is a feature only available to the permissionable&#39;s application owner (and its employees). This will add all users from these audiences to the permissionable object. Notifications will not be sent to users if this feature is used. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addUsersToPermissionable'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SirqulResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function addUsersToPermissionableWithHttpInfo($version, $permissionable_type, $permissionable_id, $device_id = null, $account_id = null, $read = true, $write = false, $delete = false, $add = false, $connection_ids = null, $connection_account_ids = null, $connection_group_ids = null, $pending = false, $admin = null, $include_friend_group = false, $latitude = null, $longitude = null, $audience_ids = null, string $contentType = self::contentTypes['addUsersToPermissionable'][0])
    {
        $request = $this->addUsersToPermissionableRequest($version, $permissionable_type, $permissionable_id, $device_id, $account_id, $read, $write, $delete, $add, $connection_ids, $connection_account_ids, $connection_group_ids, $pending, $admin, $include_friend_group, $latitude, $longitude, $audience_ids, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\SirqulResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\SirqulResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SirqulResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation addUsersToPermissionableAsync
     *
     * Add User
     *
     * @param  float $version (required)
     * @param  string $permissionable_type the permissionable type of the object (required)
     * @param  int $permissionable_id the id of the permissionable object (required)
     * @param  string|null $device_id the device id (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  bool|null $read the read permission of the users/groups (optional, default to true)
     * @param  bool|null $write the write permission of the users/groups (optional, default to false)
     * @param  bool|null $delete the delete permission of the users/groups (optional, default to false)
     * @param  bool|null $add the add permission of the users/groups (optional, default to false)
     * @param  string|null $connection_ids a comma separated list of connection ids (NOT the account ids) (optional)
     * @param  string|null $connection_account_ids a comma separated list of account ids (optional)
     * @param  string|null $connection_group_ids a comma separated list of connection group ids (these are groups made by the user) (optional)
     * @param  bool|null $pending sets whether the added users are marked as pending (and will require the album admins to accept) - admins can set this to false (to accept) (optional, default to false)
     * @param  bool|null $admin sets whether the added users will become admins or not (optional)
     * @param  bool|null $include_friend_group flag to determine whether to include the built-in \&quot;friends\&quot; group (optional, default to false)
     * @param  float|null $latitude the current latitude of the user (optional)
     * @param  float|null $longitude the current longitude of the user (optional)
     * @param  string|null $audience_ids comma separated list of audience ids. This is a feature only available to the permissionable&#39;s application owner (and its employees). This will add all users from these audiences to the permissionable object. Notifications will not be sent to users if this feature is used. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addUsersToPermissionable'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addUsersToPermissionableAsync($version, $permissionable_type, $permissionable_id, $device_id = null, $account_id = null, $read = true, $write = false, $delete = false, $add = false, $connection_ids = null, $connection_account_ids = null, $connection_group_ids = null, $pending = false, $admin = null, $include_friend_group = false, $latitude = null, $longitude = null, $audience_ids = null, string $contentType = self::contentTypes['addUsersToPermissionable'][0])
    {
        return $this->addUsersToPermissionableAsyncWithHttpInfo($version, $permissionable_type, $permissionable_id, $device_id, $account_id, $read, $write, $delete, $add, $connection_ids, $connection_account_ids, $connection_group_ids, $pending, $admin, $include_friend_group, $latitude, $longitude, $audience_ids, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addUsersToPermissionableAsyncWithHttpInfo
     *
     * Add User
     *
     * @param  float $version (required)
     * @param  string $permissionable_type the permissionable type of the object (required)
     * @param  int $permissionable_id the id of the permissionable object (required)
     * @param  string|null $device_id the device id (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  bool|null $read the read permission of the users/groups (optional, default to true)
     * @param  bool|null $write the write permission of the users/groups (optional, default to false)
     * @param  bool|null $delete the delete permission of the users/groups (optional, default to false)
     * @param  bool|null $add the add permission of the users/groups (optional, default to false)
     * @param  string|null $connection_ids a comma separated list of connection ids (NOT the account ids) (optional)
     * @param  string|null $connection_account_ids a comma separated list of account ids (optional)
     * @param  string|null $connection_group_ids a comma separated list of connection group ids (these are groups made by the user) (optional)
     * @param  bool|null $pending sets whether the added users are marked as pending (and will require the album admins to accept) - admins can set this to false (to accept) (optional, default to false)
     * @param  bool|null $admin sets whether the added users will become admins or not (optional)
     * @param  bool|null $include_friend_group flag to determine whether to include the built-in \&quot;friends\&quot; group (optional, default to false)
     * @param  float|null $latitude the current latitude of the user (optional)
     * @param  float|null $longitude the current longitude of the user (optional)
     * @param  string|null $audience_ids comma separated list of audience ids. This is a feature only available to the permissionable&#39;s application owner (and its employees). This will add all users from these audiences to the permissionable object. Notifications will not be sent to users if this feature is used. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addUsersToPermissionable'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addUsersToPermissionableAsyncWithHttpInfo($version, $permissionable_type, $permissionable_id, $device_id = null, $account_id = null, $read = true, $write = false, $delete = false, $add = false, $connection_ids = null, $connection_account_ids = null, $connection_group_ids = null, $pending = false, $admin = null, $include_friend_group = false, $latitude = null, $longitude = null, $audience_ids = null, string $contentType = self::contentTypes['addUsersToPermissionable'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SirqulResponse';
        $request = $this->addUsersToPermissionableRequest($version, $permissionable_type, $permissionable_id, $device_id, $account_id, $read, $write, $delete, $add, $connection_ids, $connection_account_ids, $connection_group_ids, $pending, $admin, $include_friend_group, $latitude, $longitude, $audience_ids, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addUsersToPermissionable'
     *
     * @param  float $version (required)
     * @param  string $permissionable_type the permissionable type of the object (required)
     * @param  int $permissionable_id the id of the permissionable object (required)
     * @param  string|null $device_id the device id (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  bool|null $read the read permission of the users/groups (optional, default to true)
     * @param  bool|null $write the write permission of the users/groups (optional, default to false)
     * @param  bool|null $delete the delete permission of the users/groups (optional, default to false)
     * @param  bool|null $add the add permission of the users/groups (optional, default to false)
     * @param  string|null $connection_ids a comma separated list of connection ids (NOT the account ids) (optional)
     * @param  string|null $connection_account_ids a comma separated list of account ids (optional)
     * @param  string|null $connection_group_ids a comma separated list of connection group ids (these are groups made by the user) (optional)
     * @param  bool|null $pending sets whether the added users are marked as pending (and will require the album admins to accept) - admins can set this to false (to accept) (optional, default to false)
     * @param  bool|null $admin sets whether the added users will become admins or not (optional)
     * @param  bool|null $include_friend_group flag to determine whether to include the built-in \&quot;friends\&quot; group (optional, default to false)
     * @param  float|null $latitude the current latitude of the user (optional)
     * @param  float|null $longitude the current longitude of the user (optional)
     * @param  string|null $audience_ids comma separated list of audience ids. This is a feature only available to the permissionable&#39;s application owner (and its employees). This will add all users from these audiences to the permissionable object. Notifications will not be sent to users if this feature is used. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addUsersToPermissionable'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function addUsersToPermissionableRequest($version, $permissionable_type, $permissionable_id, $device_id = null, $account_id = null, $read = true, $write = false, $delete = false, $add = false, $connection_ids = null, $connection_account_ids = null, $connection_group_ids = null, $pending = false, $admin = null, $include_friend_group = false, $latitude = null, $longitude = null, $audience_ids = null, string $contentType = self::contentTypes['addUsersToPermissionable'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling addUsersToPermissionable'
            );
        }

        // verify the required parameter 'permissionable_type' is set
        if ($permissionable_type === null || (is_array($permissionable_type) && count($permissionable_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $permissionable_type when calling addUsersToPermissionable'
            );
        }

        // verify the required parameter 'permissionable_id' is set
        if ($permissionable_id === null || (is_array($permissionable_id) && count($permissionable_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $permissionable_id when calling addUsersToPermissionable'
            );
        }

















        $resourcePath = '/api/{version}/consumer/permissions/add';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_id,
            'deviceId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $permissionable_type,
            'permissionableType', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $permissionable_id,
            'permissionableId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $read,
            'read', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $write,
            'write', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $delete,
            'delete', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $add,
            'add', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $connection_ids,
            'connectionIds', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $connection_account_ids,
            'connectionAccountIds', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $connection_group_ids,
            'connectionGroupIds', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pending,
            'pending', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $admin,
            'admin', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_friend_group,
            'includeFriendGroup', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $latitude,
            'latitude', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $longitude,
            'longitude', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audience_ids,
            'audienceIds', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation approvePermissionable
     *
     * Approve Permissionable
     *
     * @param  float $version version (required)
     * @param  string $permissionable_type The permissionable type of the object (required)
     * @param  int $permissionable_id The id of the permissionable object (required)
     * @param  string|null $device_id A unique ID given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id The account ID of the user (deviceId or accountId required) (optional)
     * @param  string|null $approval_status The approval status to set {PENDING, REJECTED, APPROVED, FEATURED} (optional, default to 'APPROVED')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['approvePermissionable'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SirqulResponse
     */
    public function approvePermissionable($version, $permissionable_type, $permissionable_id, $device_id = null, $account_id = null, $approval_status = 'APPROVED', string $contentType = self::contentTypes['approvePermissionable'][0])
    {
        list($response) = $this->approvePermissionableWithHttpInfo($version, $permissionable_type, $permissionable_id, $device_id, $account_id, $approval_status, $contentType);
        return $response;
    }

    /**
     * Operation approvePermissionableWithHttpInfo
     *
     * Approve Permissionable
     *
     * @param  float $version (required)
     * @param  string $permissionable_type The permissionable type of the object (required)
     * @param  int $permissionable_id The id of the permissionable object (required)
     * @param  string|null $device_id A unique ID given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id The account ID of the user (deviceId or accountId required) (optional)
     * @param  string|null $approval_status The approval status to set {PENDING, REJECTED, APPROVED, FEATURED} (optional, default to 'APPROVED')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['approvePermissionable'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SirqulResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function approvePermissionableWithHttpInfo($version, $permissionable_type, $permissionable_id, $device_id = null, $account_id = null, $approval_status = 'APPROVED', string $contentType = self::contentTypes['approvePermissionable'][0])
    {
        $request = $this->approvePermissionableRequest($version, $permissionable_type, $permissionable_id, $device_id, $account_id, $approval_status, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\SirqulResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\SirqulResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SirqulResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation approvePermissionableAsync
     *
     * Approve Permissionable
     *
     * @param  float $version (required)
     * @param  string $permissionable_type The permissionable type of the object (required)
     * @param  int $permissionable_id The id of the permissionable object (required)
     * @param  string|null $device_id A unique ID given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id The account ID of the user (deviceId or accountId required) (optional)
     * @param  string|null $approval_status The approval status to set {PENDING, REJECTED, APPROVED, FEATURED} (optional, default to 'APPROVED')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['approvePermissionable'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function approvePermissionableAsync($version, $permissionable_type, $permissionable_id, $device_id = null, $account_id = null, $approval_status = 'APPROVED', string $contentType = self::contentTypes['approvePermissionable'][0])
    {
        return $this->approvePermissionableAsyncWithHttpInfo($version, $permissionable_type, $permissionable_id, $device_id, $account_id, $approval_status, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation approvePermissionableAsyncWithHttpInfo
     *
     * Approve Permissionable
     *
     * @param  float $version (required)
     * @param  string $permissionable_type The permissionable type of the object (required)
     * @param  int $permissionable_id The id of the permissionable object (required)
     * @param  string|null $device_id A unique ID given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id The account ID of the user (deviceId or accountId required) (optional)
     * @param  string|null $approval_status The approval status to set {PENDING, REJECTED, APPROVED, FEATURED} (optional, default to 'APPROVED')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['approvePermissionable'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function approvePermissionableAsyncWithHttpInfo($version, $permissionable_type, $permissionable_id, $device_id = null, $account_id = null, $approval_status = 'APPROVED', string $contentType = self::contentTypes['approvePermissionable'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SirqulResponse';
        $request = $this->approvePermissionableRequest($version, $permissionable_type, $permissionable_id, $device_id, $account_id, $approval_status, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'approvePermissionable'
     *
     * @param  float $version (required)
     * @param  string $permissionable_type The permissionable type of the object (required)
     * @param  int $permissionable_id The id of the permissionable object (required)
     * @param  string|null $device_id A unique ID given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id The account ID of the user (deviceId or accountId required) (optional)
     * @param  string|null $approval_status The approval status to set {PENDING, REJECTED, APPROVED, FEATURED} (optional, default to 'APPROVED')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['approvePermissionable'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function approvePermissionableRequest($version, $permissionable_type, $permissionable_id, $device_id = null, $account_id = null, $approval_status = 'APPROVED', string $contentType = self::contentTypes['approvePermissionable'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling approvePermissionable'
            );
        }

        // verify the required parameter 'permissionable_type' is set
        if ($permissionable_type === null || (is_array($permissionable_type) && count($permissionable_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $permissionable_type when calling approvePermissionable'
            );
        }

        // verify the required parameter 'permissionable_id' is set
        if ($permissionable_id === null || (is_array($permissionable_id) && count($permissionable_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $permissionable_id when calling approvePermissionable'
            );
        }





        $resourcePath = '/api/{version}/permissionable/approve';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_id,
            'deviceId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $permissionable_type,
            'permissionableType', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $permissionable_id,
            'permissionableId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $approval_status,
            'approvalStatus', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation leaveFromPermissionable
     *
     * Leave
     *
     * @param  float $version version (required)
     * @param  string $permissionable_type the permissionable type PermissionableType (required)
     * @param  int $permissionable_id the id of the permissionable object (required)
     * @param  string|null $device_id the device id (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  float|null $latitude the current latitude of the user (optional)
     * @param  float|null $longitude the current longitude of the user (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leaveFromPermissionable'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SirqulResponse
     */
    public function leaveFromPermissionable($version, $permissionable_type, $permissionable_id, $device_id = null, $account_id = null, $latitude = null, $longitude = null, string $contentType = self::contentTypes['leaveFromPermissionable'][0])
    {
        list($response) = $this->leaveFromPermissionableWithHttpInfo($version, $permissionable_type, $permissionable_id, $device_id, $account_id, $latitude, $longitude, $contentType);
        return $response;
    }

    /**
     * Operation leaveFromPermissionableWithHttpInfo
     *
     * Leave
     *
     * @param  float $version (required)
     * @param  string $permissionable_type the permissionable type PermissionableType (required)
     * @param  int $permissionable_id the id of the permissionable object (required)
     * @param  string|null $device_id the device id (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  float|null $latitude the current latitude of the user (optional)
     * @param  float|null $longitude the current longitude of the user (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leaveFromPermissionable'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SirqulResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function leaveFromPermissionableWithHttpInfo($version, $permissionable_type, $permissionable_id, $device_id = null, $account_id = null, $latitude = null, $longitude = null, string $contentType = self::contentTypes['leaveFromPermissionable'][0])
    {
        $request = $this->leaveFromPermissionableRequest($version, $permissionable_type, $permissionable_id, $device_id, $account_id, $latitude, $longitude, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\SirqulResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\SirqulResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SirqulResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation leaveFromPermissionableAsync
     *
     * Leave
     *
     * @param  float $version (required)
     * @param  string $permissionable_type the permissionable type PermissionableType (required)
     * @param  int $permissionable_id the id of the permissionable object (required)
     * @param  string|null $device_id the device id (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  float|null $latitude the current latitude of the user (optional)
     * @param  float|null $longitude the current longitude of the user (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leaveFromPermissionable'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function leaveFromPermissionableAsync($version, $permissionable_type, $permissionable_id, $device_id = null, $account_id = null, $latitude = null, $longitude = null, string $contentType = self::contentTypes['leaveFromPermissionable'][0])
    {
        return $this->leaveFromPermissionableAsyncWithHttpInfo($version, $permissionable_type, $permissionable_id, $device_id, $account_id, $latitude, $longitude, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation leaveFromPermissionableAsyncWithHttpInfo
     *
     * Leave
     *
     * @param  float $version (required)
     * @param  string $permissionable_type the permissionable type PermissionableType (required)
     * @param  int $permissionable_id the id of the permissionable object (required)
     * @param  string|null $device_id the device id (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  float|null $latitude the current latitude of the user (optional)
     * @param  float|null $longitude the current longitude of the user (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leaveFromPermissionable'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function leaveFromPermissionableAsyncWithHttpInfo($version, $permissionable_type, $permissionable_id, $device_id = null, $account_id = null, $latitude = null, $longitude = null, string $contentType = self::contentTypes['leaveFromPermissionable'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SirqulResponse';
        $request = $this->leaveFromPermissionableRequest($version, $permissionable_type, $permissionable_id, $device_id, $account_id, $latitude, $longitude, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'leaveFromPermissionable'
     *
     * @param  float $version (required)
     * @param  string $permissionable_type the permissionable type PermissionableType (required)
     * @param  int $permissionable_id the id of the permissionable object (required)
     * @param  string|null $device_id the device id (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  float|null $latitude the current latitude of the user (optional)
     * @param  float|null $longitude the current longitude of the user (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leaveFromPermissionable'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function leaveFromPermissionableRequest($version, $permissionable_type, $permissionable_id, $device_id = null, $account_id = null, $latitude = null, $longitude = null, string $contentType = self::contentTypes['leaveFromPermissionable'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling leaveFromPermissionable'
            );
        }

        // verify the required parameter 'permissionable_type' is set
        if ($permissionable_type === null || (is_array($permissionable_type) && count($permissionable_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $permissionable_type when calling leaveFromPermissionable'
            );
        }

        // verify the required parameter 'permissionable_id' is set
        if ($permissionable_id === null || (is_array($permissionable_id) && count($permissionable_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $permissionable_id when calling leaveFromPermissionable'
            );
        }






        $resourcePath = '/api/{version}/consumer/permissions/leave';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_id,
            'deviceId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $permissionable_type,
            'permissionableType', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $permissionable_id,
            'permissionableId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $latitude,
            'latitude', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $longitude,
            'longitude', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation removeUsersFromPermissionable
     *
     * Remove User
     *
     * @param  float $version version (required)
     * @param  string $permissionable_type the permissionable type of the object (required)
     * @param  int $permissionable_id the id of the permissionable object (required)
     * @param  string|null $device_id the device id (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  string|null $connection_ids a comma separated list of connection ids (NOT the account ids) (optional)
     * @param  string|null $connection_account_ids a comma separated list of account ids (optional)
     * @param  string|null $connection_group_ids a comma separated list of connection group ids (these are groups made by the user) (optional)
     * @param  bool|null $remove_friend_group flag to determine whether to remove the built-in \&quot;friends\&quot; group (optional, default to false)
     * @param  float|null $latitude the current latitude of the user (optional)
     * @param  float|null $longitude the current longitude of the user (optional)
     * @param  string|null $audience_ids comma separated list of audience ids. This will remove all users from these audiences from the permissionable object. Notifications will not be sent to users if this feature is used. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removeUsersFromPermissionable'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SirqulResponse
     */
    public function removeUsersFromPermissionable($version, $permissionable_type, $permissionable_id, $device_id = null, $account_id = null, $connection_ids = null, $connection_account_ids = null, $connection_group_ids = null, $remove_friend_group = false, $latitude = null, $longitude = null, $audience_ids = null, string $contentType = self::contentTypes['removeUsersFromPermissionable'][0])
    {
        list($response) = $this->removeUsersFromPermissionableWithHttpInfo($version, $permissionable_type, $permissionable_id, $device_id, $account_id, $connection_ids, $connection_account_ids, $connection_group_ids, $remove_friend_group, $latitude, $longitude, $audience_ids, $contentType);
        return $response;
    }

    /**
     * Operation removeUsersFromPermissionableWithHttpInfo
     *
     * Remove User
     *
     * @param  float $version (required)
     * @param  string $permissionable_type the permissionable type of the object (required)
     * @param  int $permissionable_id the id of the permissionable object (required)
     * @param  string|null $device_id the device id (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  string|null $connection_ids a comma separated list of connection ids (NOT the account ids) (optional)
     * @param  string|null $connection_account_ids a comma separated list of account ids (optional)
     * @param  string|null $connection_group_ids a comma separated list of connection group ids (these are groups made by the user) (optional)
     * @param  bool|null $remove_friend_group flag to determine whether to remove the built-in \&quot;friends\&quot; group (optional, default to false)
     * @param  float|null $latitude the current latitude of the user (optional)
     * @param  float|null $longitude the current longitude of the user (optional)
     * @param  string|null $audience_ids comma separated list of audience ids. This will remove all users from these audiences from the permissionable object. Notifications will not be sent to users if this feature is used. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removeUsersFromPermissionable'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SirqulResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function removeUsersFromPermissionableWithHttpInfo($version, $permissionable_type, $permissionable_id, $device_id = null, $account_id = null, $connection_ids = null, $connection_account_ids = null, $connection_group_ids = null, $remove_friend_group = false, $latitude = null, $longitude = null, $audience_ids = null, string $contentType = self::contentTypes['removeUsersFromPermissionable'][0])
    {
        $request = $this->removeUsersFromPermissionableRequest($version, $permissionable_type, $permissionable_id, $device_id, $account_id, $connection_ids, $connection_account_ids, $connection_group_ids, $remove_friend_group, $latitude, $longitude, $audience_ids, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\SirqulResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\SirqulResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SirqulResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation removeUsersFromPermissionableAsync
     *
     * Remove User
     *
     * @param  float $version (required)
     * @param  string $permissionable_type the permissionable type of the object (required)
     * @param  int $permissionable_id the id of the permissionable object (required)
     * @param  string|null $device_id the device id (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  string|null $connection_ids a comma separated list of connection ids (NOT the account ids) (optional)
     * @param  string|null $connection_account_ids a comma separated list of account ids (optional)
     * @param  string|null $connection_group_ids a comma separated list of connection group ids (these are groups made by the user) (optional)
     * @param  bool|null $remove_friend_group flag to determine whether to remove the built-in \&quot;friends\&quot; group (optional, default to false)
     * @param  float|null $latitude the current latitude of the user (optional)
     * @param  float|null $longitude the current longitude of the user (optional)
     * @param  string|null $audience_ids comma separated list of audience ids. This will remove all users from these audiences from the permissionable object. Notifications will not be sent to users if this feature is used. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removeUsersFromPermissionable'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function removeUsersFromPermissionableAsync($version, $permissionable_type, $permissionable_id, $device_id = null, $account_id = null, $connection_ids = null, $connection_account_ids = null, $connection_group_ids = null, $remove_friend_group = false, $latitude = null, $longitude = null, $audience_ids = null, string $contentType = self::contentTypes['removeUsersFromPermissionable'][0])
    {
        return $this->removeUsersFromPermissionableAsyncWithHttpInfo($version, $permissionable_type, $permissionable_id, $device_id, $account_id, $connection_ids, $connection_account_ids, $connection_group_ids, $remove_friend_group, $latitude, $longitude, $audience_ids, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation removeUsersFromPermissionableAsyncWithHttpInfo
     *
     * Remove User
     *
     * @param  float $version (required)
     * @param  string $permissionable_type the permissionable type of the object (required)
     * @param  int $permissionable_id the id of the permissionable object (required)
     * @param  string|null $device_id the device id (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  string|null $connection_ids a comma separated list of connection ids (NOT the account ids) (optional)
     * @param  string|null $connection_account_ids a comma separated list of account ids (optional)
     * @param  string|null $connection_group_ids a comma separated list of connection group ids (these are groups made by the user) (optional)
     * @param  bool|null $remove_friend_group flag to determine whether to remove the built-in \&quot;friends\&quot; group (optional, default to false)
     * @param  float|null $latitude the current latitude of the user (optional)
     * @param  float|null $longitude the current longitude of the user (optional)
     * @param  string|null $audience_ids comma separated list of audience ids. This will remove all users from these audiences from the permissionable object. Notifications will not be sent to users if this feature is used. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removeUsersFromPermissionable'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function removeUsersFromPermissionableAsyncWithHttpInfo($version, $permissionable_type, $permissionable_id, $device_id = null, $account_id = null, $connection_ids = null, $connection_account_ids = null, $connection_group_ids = null, $remove_friend_group = false, $latitude = null, $longitude = null, $audience_ids = null, string $contentType = self::contentTypes['removeUsersFromPermissionable'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SirqulResponse';
        $request = $this->removeUsersFromPermissionableRequest($version, $permissionable_type, $permissionable_id, $device_id, $account_id, $connection_ids, $connection_account_ids, $connection_group_ids, $remove_friend_group, $latitude, $longitude, $audience_ids, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'removeUsersFromPermissionable'
     *
     * @param  float $version (required)
     * @param  string $permissionable_type the permissionable type of the object (required)
     * @param  int $permissionable_id the id of the permissionable object (required)
     * @param  string|null $device_id the device id (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  string|null $connection_ids a comma separated list of connection ids (NOT the account ids) (optional)
     * @param  string|null $connection_account_ids a comma separated list of account ids (optional)
     * @param  string|null $connection_group_ids a comma separated list of connection group ids (these are groups made by the user) (optional)
     * @param  bool|null $remove_friend_group flag to determine whether to remove the built-in \&quot;friends\&quot; group (optional, default to false)
     * @param  float|null $latitude the current latitude of the user (optional)
     * @param  float|null $longitude the current longitude of the user (optional)
     * @param  string|null $audience_ids comma separated list of audience ids. This will remove all users from these audiences from the permissionable object. Notifications will not be sent to users if this feature is used. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removeUsersFromPermissionable'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function removeUsersFromPermissionableRequest($version, $permissionable_type, $permissionable_id, $device_id = null, $account_id = null, $connection_ids = null, $connection_account_ids = null, $connection_group_ids = null, $remove_friend_group = false, $latitude = null, $longitude = null, $audience_ids = null, string $contentType = self::contentTypes['removeUsersFromPermissionable'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling removeUsersFromPermissionable'
            );
        }

        // verify the required parameter 'permissionable_type' is set
        if ($permissionable_type === null || (is_array($permissionable_type) && count($permissionable_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $permissionable_type when calling removeUsersFromPermissionable'
            );
        }

        // verify the required parameter 'permissionable_id' is set
        if ($permissionable_id === null || (is_array($permissionable_id) && count($permissionable_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $permissionable_id when calling removeUsersFromPermissionable'
            );
        }











        $resourcePath = '/api/{version}/consumer/permissions/remove';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_id,
            'deviceId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $permissionable_type,
            'permissionableType', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $permissionable_id,
            'permissionableId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $connection_ids,
            'connectionIds', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $connection_account_ids,
            'connectionAccountIds', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $connection_group_ids,
            'connectionGroupIds', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $remove_friend_group,
            'removeFriendGroup', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $latitude,
            'latitude', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $longitude,
            'longitude', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audience_ids,
            'audienceIds', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchPermissionables
     *
     * Search Permissionables
     *
     * @param  float $version version (required)
     * @param  string|null $device_id A unique ID given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id The account ID of the user (deviceId or accountId required) (optional)
     * @param  int|null $connection_account_id Filter results for a specific user account (optional)
     * @param  string|null $connection_account_ids Comma separated list of account IDs to filter results with (optional)
     * @param  string|null $permissionable_type Filter user permissions by the permissionable object type (optional)
     * @param  int|null $permissionable_id The id of the permissionable object to filter by (optional)
     * @param  string|null $keyword Keyword to search within permissionable records (optional)
     * @param  string|null $sort_field Field to sort results on (optional)
     * @param  bool|null $descending Sort descending when true (optional)
     * @param  bool|null $pending Return user permissions that are pending (optional)
     * @param  bool|null $admin Return user permissions that are admins (optional)
     * @param  int|null $start the start index for pagination (optional, default to 0)
     * @param  int|null $limit the limit for pagination (optional, default to 20)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchPermissionables'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\UserPermissionsResponse[]
     */
    public function searchPermissionables($version, $device_id = null, $account_id = null, $connection_account_id = null, $connection_account_ids = null, $permissionable_type = null, $permissionable_id = null, $keyword = null, $sort_field = null, $descending = null, $pending = null, $admin = null, $start = 0, $limit = 20, string $contentType = self::contentTypes['searchPermissionables'][0])
    {
        list($response) = $this->searchPermissionablesWithHttpInfo($version, $device_id, $account_id, $connection_account_id, $connection_account_ids, $permissionable_type, $permissionable_id, $keyword, $sort_field, $descending, $pending, $admin, $start, $limit, $contentType);
        return $response;
    }

    /**
     * Operation searchPermissionablesWithHttpInfo
     *
     * Search Permissionables
     *
     * @param  float $version (required)
     * @param  string|null $device_id A unique ID given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id The account ID of the user (deviceId or accountId required) (optional)
     * @param  int|null $connection_account_id Filter results for a specific user account (optional)
     * @param  string|null $connection_account_ids Comma separated list of account IDs to filter results with (optional)
     * @param  string|null $permissionable_type Filter user permissions by the permissionable object type (optional)
     * @param  int|null $permissionable_id The id of the permissionable object to filter by (optional)
     * @param  string|null $keyword Keyword to search within permissionable records (optional)
     * @param  string|null $sort_field Field to sort results on (optional)
     * @param  bool|null $descending Sort descending when true (optional)
     * @param  bool|null $pending Return user permissions that are pending (optional)
     * @param  bool|null $admin Return user permissions that are admins (optional)
     * @param  int|null $start the start index for pagination (optional, default to 0)
     * @param  int|null $limit the limit for pagination (optional, default to 20)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchPermissionables'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\UserPermissionsResponse[], HTTP status code, HTTP response headers (array of strings)
     */
    public function searchPermissionablesWithHttpInfo($version, $device_id = null, $account_id = null, $connection_account_id = null, $connection_account_ids = null, $permissionable_type = null, $permissionable_id = null, $keyword = null, $sort_field = null, $descending = null, $pending = null, $admin = null, $start = 0, $limit = 20, string $contentType = self::contentTypes['searchPermissionables'][0])
    {
        $request = $this->searchPermissionablesRequest($version, $device_id, $account_id, $connection_account_id, $connection_account_ids, $permissionable_type, $permissionable_id, $keyword, $sort_field, $descending, $pending, $admin, $start, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\UserPermissionsResponse[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\UserPermissionsResponse[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\UserPermissionsResponse[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation searchPermissionablesAsync
     *
     * Search Permissionables
     *
     * @param  float $version (required)
     * @param  string|null $device_id A unique ID given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id The account ID of the user (deviceId or accountId required) (optional)
     * @param  int|null $connection_account_id Filter results for a specific user account (optional)
     * @param  string|null $connection_account_ids Comma separated list of account IDs to filter results with (optional)
     * @param  string|null $permissionable_type Filter user permissions by the permissionable object type (optional)
     * @param  int|null $permissionable_id The id of the permissionable object to filter by (optional)
     * @param  string|null $keyword Keyword to search within permissionable records (optional)
     * @param  string|null $sort_field Field to sort results on (optional)
     * @param  bool|null $descending Sort descending when true (optional)
     * @param  bool|null $pending Return user permissions that are pending (optional)
     * @param  bool|null $admin Return user permissions that are admins (optional)
     * @param  int|null $start the start index for pagination (optional, default to 0)
     * @param  int|null $limit the limit for pagination (optional, default to 20)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchPermissionables'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchPermissionablesAsync($version, $device_id = null, $account_id = null, $connection_account_id = null, $connection_account_ids = null, $permissionable_type = null, $permissionable_id = null, $keyword = null, $sort_field = null, $descending = null, $pending = null, $admin = null, $start = 0, $limit = 20, string $contentType = self::contentTypes['searchPermissionables'][0])
    {
        return $this->searchPermissionablesAsyncWithHttpInfo($version, $device_id, $account_id, $connection_account_id, $connection_account_ids, $permissionable_type, $permissionable_id, $keyword, $sort_field, $descending, $pending, $admin, $start, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchPermissionablesAsyncWithHttpInfo
     *
     * Search Permissionables
     *
     * @param  float $version (required)
     * @param  string|null $device_id A unique ID given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id The account ID of the user (deviceId or accountId required) (optional)
     * @param  int|null $connection_account_id Filter results for a specific user account (optional)
     * @param  string|null $connection_account_ids Comma separated list of account IDs to filter results with (optional)
     * @param  string|null $permissionable_type Filter user permissions by the permissionable object type (optional)
     * @param  int|null $permissionable_id The id of the permissionable object to filter by (optional)
     * @param  string|null $keyword Keyword to search within permissionable records (optional)
     * @param  string|null $sort_field Field to sort results on (optional)
     * @param  bool|null $descending Sort descending when true (optional)
     * @param  bool|null $pending Return user permissions that are pending (optional)
     * @param  bool|null $admin Return user permissions that are admins (optional)
     * @param  int|null $start the start index for pagination (optional, default to 0)
     * @param  int|null $limit the limit for pagination (optional, default to 20)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchPermissionables'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchPermissionablesAsyncWithHttpInfo($version, $device_id = null, $account_id = null, $connection_account_id = null, $connection_account_ids = null, $permissionable_type = null, $permissionable_id = null, $keyword = null, $sort_field = null, $descending = null, $pending = null, $admin = null, $start = 0, $limit = 20, string $contentType = self::contentTypes['searchPermissionables'][0])
    {
        $returnType = '\OpenAPI\Client\Model\UserPermissionsResponse[]';
        $request = $this->searchPermissionablesRequest($version, $device_id, $account_id, $connection_account_id, $connection_account_ids, $permissionable_type, $permissionable_id, $keyword, $sort_field, $descending, $pending, $admin, $start, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchPermissionables'
     *
     * @param  float $version (required)
     * @param  string|null $device_id A unique ID given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id The account ID of the user (deviceId or accountId required) (optional)
     * @param  int|null $connection_account_id Filter results for a specific user account (optional)
     * @param  string|null $connection_account_ids Comma separated list of account IDs to filter results with (optional)
     * @param  string|null $permissionable_type Filter user permissions by the permissionable object type (optional)
     * @param  int|null $permissionable_id The id of the permissionable object to filter by (optional)
     * @param  string|null $keyword Keyword to search within permissionable records (optional)
     * @param  string|null $sort_field Field to sort results on (optional)
     * @param  bool|null $descending Sort descending when true (optional)
     * @param  bool|null $pending Return user permissions that are pending (optional)
     * @param  bool|null $admin Return user permissions that are admins (optional)
     * @param  int|null $start the start index for pagination (optional, default to 0)
     * @param  int|null $limit the limit for pagination (optional, default to 20)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchPermissionables'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function searchPermissionablesRequest($version, $device_id = null, $account_id = null, $connection_account_id = null, $connection_account_ids = null, $permissionable_type = null, $permissionable_id = null, $keyword = null, $sort_field = null, $descending = null, $pending = null, $admin = null, $start = 0, $limit = 20, string $contentType = self::contentTypes['searchPermissionables'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling searchPermissionables'
            );
        }















        $resourcePath = '/api/{version}/permissions/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_id,
            'deviceId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $connection_account_id,
            'connectionAccountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $connection_account_ids,
            'connectionAccountIds', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $permissionable_type,
            'permissionableType', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $permissionable_id,
            'permissionableId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $keyword,
            'keyword', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort_field,
            'sortField', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $descending,
            'descending', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pending,
            'pending', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $admin,
            'admin', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start,
            'start', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchPermissionablesFollowingDistance
     *
     * Search Permissionables by Distnace
     *
     * @param  float $version version (required)
     * @param  float $latitude The latitude of the current account (required)
     * @param  float $longitude The longitude of the current account (required)
     * @param  string|null $device_id A unique ID given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id The account ID of the user (deviceId or accountId required) (optional)
     * @param  int|null $connection_account_id Filter results for a specific user account (optional)
     * @param  string|null $connection_account_ids Comma separated list of account IDs to filter results with (optional)
     * @param  string|null $permissionable_type Filter user permissions by the permissionable object type (optional)
     * @param  int|null $permissionable_id The id of the permissionable object to filter by (optional)
     * @param  float|null $search_range The search range in miles (optional, default to 5)
     * @param  string|null $keyword Keyword to search within permissionable records (optional)
     * @param  bool|null $pending Return user permissions that are pending (optional)
     * @param  bool|null $admin Return user permissions that are admins (optional)
     * @param  int|null $start The start index for pagination (optional, default to 0)
     * @param  int|null $limit The limit for pagination (optional, default to 20)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchPermissionablesFollowingDistance'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\UserPermissionsResponse[]
     */
    public function searchPermissionablesFollowingDistance($version, $latitude, $longitude, $device_id = null, $account_id = null, $connection_account_id = null, $connection_account_ids = null, $permissionable_type = null, $permissionable_id = null, $search_range = 5, $keyword = null, $pending = null, $admin = null, $start = 0, $limit = 20, string $contentType = self::contentTypes['searchPermissionablesFollowingDistance'][0])
    {
        list($response) = $this->searchPermissionablesFollowingDistanceWithHttpInfo($version, $latitude, $longitude, $device_id, $account_id, $connection_account_id, $connection_account_ids, $permissionable_type, $permissionable_id, $search_range, $keyword, $pending, $admin, $start, $limit, $contentType);
        return $response;
    }

    /**
     * Operation searchPermissionablesFollowingDistanceWithHttpInfo
     *
     * Search Permissionables by Distnace
     *
     * @param  float $version (required)
     * @param  float $latitude The latitude of the current account (required)
     * @param  float $longitude The longitude of the current account (required)
     * @param  string|null $device_id A unique ID given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id The account ID of the user (deviceId or accountId required) (optional)
     * @param  int|null $connection_account_id Filter results for a specific user account (optional)
     * @param  string|null $connection_account_ids Comma separated list of account IDs to filter results with (optional)
     * @param  string|null $permissionable_type Filter user permissions by the permissionable object type (optional)
     * @param  int|null $permissionable_id The id of the permissionable object to filter by (optional)
     * @param  float|null $search_range The search range in miles (optional, default to 5)
     * @param  string|null $keyword Keyword to search within permissionable records (optional)
     * @param  bool|null $pending Return user permissions that are pending (optional)
     * @param  bool|null $admin Return user permissions that are admins (optional)
     * @param  int|null $start The start index for pagination (optional, default to 0)
     * @param  int|null $limit The limit for pagination (optional, default to 20)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchPermissionablesFollowingDistance'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\UserPermissionsResponse[], HTTP status code, HTTP response headers (array of strings)
     */
    public function searchPermissionablesFollowingDistanceWithHttpInfo($version, $latitude, $longitude, $device_id = null, $account_id = null, $connection_account_id = null, $connection_account_ids = null, $permissionable_type = null, $permissionable_id = null, $search_range = 5, $keyword = null, $pending = null, $admin = null, $start = 0, $limit = 20, string $contentType = self::contentTypes['searchPermissionablesFollowingDistance'][0])
    {
        $request = $this->searchPermissionablesFollowingDistanceRequest($version, $latitude, $longitude, $device_id, $account_id, $connection_account_id, $connection_account_ids, $permissionable_type, $permissionable_id, $search_range, $keyword, $pending, $admin, $start, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\UserPermissionsResponse[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\UserPermissionsResponse[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\UserPermissionsResponse[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation searchPermissionablesFollowingDistanceAsync
     *
     * Search Permissionables by Distnace
     *
     * @param  float $version (required)
     * @param  float $latitude The latitude of the current account (required)
     * @param  float $longitude The longitude of the current account (required)
     * @param  string|null $device_id A unique ID given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id The account ID of the user (deviceId or accountId required) (optional)
     * @param  int|null $connection_account_id Filter results for a specific user account (optional)
     * @param  string|null $connection_account_ids Comma separated list of account IDs to filter results with (optional)
     * @param  string|null $permissionable_type Filter user permissions by the permissionable object type (optional)
     * @param  int|null $permissionable_id The id of the permissionable object to filter by (optional)
     * @param  float|null $search_range The search range in miles (optional, default to 5)
     * @param  string|null $keyword Keyword to search within permissionable records (optional)
     * @param  bool|null $pending Return user permissions that are pending (optional)
     * @param  bool|null $admin Return user permissions that are admins (optional)
     * @param  int|null $start The start index for pagination (optional, default to 0)
     * @param  int|null $limit The limit for pagination (optional, default to 20)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchPermissionablesFollowingDistance'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchPermissionablesFollowingDistanceAsync($version, $latitude, $longitude, $device_id = null, $account_id = null, $connection_account_id = null, $connection_account_ids = null, $permissionable_type = null, $permissionable_id = null, $search_range = 5, $keyword = null, $pending = null, $admin = null, $start = 0, $limit = 20, string $contentType = self::contentTypes['searchPermissionablesFollowingDistance'][0])
    {
        return $this->searchPermissionablesFollowingDistanceAsyncWithHttpInfo($version, $latitude, $longitude, $device_id, $account_id, $connection_account_id, $connection_account_ids, $permissionable_type, $permissionable_id, $search_range, $keyword, $pending, $admin, $start, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchPermissionablesFollowingDistanceAsyncWithHttpInfo
     *
     * Search Permissionables by Distnace
     *
     * @param  float $version (required)
     * @param  float $latitude The latitude of the current account (required)
     * @param  float $longitude The longitude of the current account (required)
     * @param  string|null $device_id A unique ID given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id The account ID of the user (deviceId or accountId required) (optional)
     * @param  int|null $connection_account_id Filter results for a specific user account (optional)
     * @param  string|null $connection_account_ids Comma separated list of account IDs to filter results with (optional)
     * @param  string|null $permissionable_type Filter user permissions by the permissionable object type (optional)
     * @param  int|null $permissionable_id The id of the permissionable object to filter by (optional)
     * @param  float|null $search_range The search range in miles (optional, default to 5)
     * @param  string|null $keyword Keyword to search within permissionable records (optional)
     * @param  bool|null $pending Return user permissions that are pending (optional)
     * @param  bool|null $admin Return user permissions that are admins (optional)
     * @param  int|null $start The start index for pagination (optional, default to 0)
     * @param  int|null $limit The limit for pagination (optional, default to 20)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchPermissionablesFollowingDistance'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchPermissionablesFollowingDistanceAsyncWithHttpInfo($version, $latitude, $longitude, $device_id = null, $account_id = null, $connection_account_id = null, $connection_account_ids = null, $permissionable_type = null, $permissionable_id = null, $search_range = 5, $keyword = null, $pending = null, $admin = null, $start = 0, $limit = 20, string $contentType = self::contentTypes['searchPermissionablesFollowingDistance'][0])
    {
        $returnType = '\OpenAPI\Client\Model\UserPermissionsResponse[]';
        $request = $this->searchPermissionablesFollowingDistanceRequest($version, $latitude, $longitude, $device_id, $account_id, $connection_account_id, $connection_account_ids, $permissionable_type, $permissionable_id, $search_range, $keyword, $pending, $admin, $start, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchPermissionablesFollowingDistance'
     *
     * @param  float $version (required)
     * @param  float $latitude The latitude of the current account (required)
     * @param  float $longitude The longitude of the current account (required)
     * @param  string|null $device_id A unique ID given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id The account ID of the user (deviceId or accountId required) (optional)
     * @param  int|null $connection_account_id Filter results for a specific user account (optional)
     * @param  string|null $connection_account_ids Comma separated list of account IDs to filter results with (optional)
     * @param  string|null $permissionable_type Filter user permissions by the permissionable object type (optional)
     * @param  int|null $permissionable_id The id of the permissionable object to filter by (optional)
     * @param  float|null $search_range The search range in miles (optional, default to 5)
     * @param  string|null $keyword Keyword to search within permissionable records (optional)
     * @param  bool|null $pending Return user permissions that are pending (optional)
     * @param  bool|null $admin Return user permissions that are admins (optional)
     * @param  int|null $start The start index for pagination (optional, default to 0)
     * @param  int|null $limit The limit for pagination (optional, default to 20)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchPermissionablesFollowingDistance'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function searchPermissionablesFollowingDistanceRequest($version, $latitude, $longitude, $device_id = null, $account_id = null, $connection_account_id = null, $connection_account_ids = null, $permissionable_type = null, $permissionable_id = null, $search_range = 5, $keyword = null, $pending = null, $admin = null, $start = 0, $limit = 20, string $contentType = self::contentTypes['searchPermissionablesFollowingDistance'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling searchPermissionablesFollowingDistance'
            );
        }

        // verify the required parameter 'latitude' is set
        if ($latitude === null || (is_array($latitude) && count($latitude) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $latitude when calling searchPermissionablesFollowingDistance'
            );
        }

        // verify the required parameter 'longitude' is set
        if ($longitude === null || (is_array($longitude) && count($longitude) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $longitude when calling searchPermissionablesFollowingDistance'
            );
        }














        $resourcePath = '/api/{version}/permissions/distancesearch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_id,
            'deviceId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $connection_account_id,
            'connectionAccountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $connection_account_ids,
            'connectionAccountIds', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $permissionable_type,
            'permissionableType', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $permissionable_id,
            'permissionableId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $latitude,
            'latitude', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $longitude,
            'longitude', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $search_range,
            'searchRange', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $keyword,
            'keyword', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pending,
            'pending', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $admin,
            'admin', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start,
            'start', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        if ($this->config->getCertFile()) {
            $options[RequestOptions::CERT] = $this->config->getCertFile();
        }

        if ($this->config->getKeyFile()) {
            $options[RequestOptions::SSL_KEY] = $this->config->getKeyFile();
        }

        return $options;
    }

    private function handleResponseWithDataType(
        string $dataType,
        RequestInterface $request,
        ResponseInterface $response
    ): array {
        if ($dataType === '\SplFileObject') {
            $content = $response->getBody(); //stream goes to serializer
        } else {
            $content = (string) $response->getBody();
            if ($dataType !== 'string') {
                try {
                    $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                } catch (\JsonException $exception) {
                    throw new ApiException(
                        sprintf(
                            'Error JSON decoding server response (%s)',
                            $request->getUri()
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                        $content
                    );
                }
            }
        }

        return [
            ObjectSerializer::deserialize($content, $dataType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    private function responseWithinRangeCode(
        string $rangeCode,
        int $statusCode
    ): bool {
        $left = (int) ($rangeCode[0].'00');
        $right = (int) ($rangeCode[0].'99');

        return $statusCode >= $left && $statusCode <= $right;
    }
}
