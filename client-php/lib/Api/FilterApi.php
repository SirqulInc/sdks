<?php
/**
 * FilterApi
 * PHP version 8.1
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Sirqul IoT Platform
 *
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.20.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\FormDataProcessor;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * FilterApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class FilterApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'createFilter' => [
            'application/json',
        ],
        'deleteFilter' => [
            'application/json',
        ],
        'getFilter' => [
            'application/json',
        ],
        'searchFilters' => [
            'application/json',
        ],
        'updateFilter' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation createFilter
     *
     * Create Filter
     *
     * @param  float $version version (required)
     * @param  int $account_id The account id of the user (must have permissions to the target application) (required)
     * @param  string $name The name of the filter (required)
     * @param  string|null $app_key The appKey of the application to assign the filter to, if not provided then the filter will be applied to the global application (if the account has permissions) (optional)
     * @param  int|null $parent_filter_id The ID of the parent filter, if not provided then the parent filter will be null (optional)
     * @param  string|null $description The description of the filter (optional)
     * @param  string|null $external_id A string identifier used by client applications to store external information (optional)
     * @param  string|null $external_type A string type used by client applications to store external information (optional)
     * @param  bool|null $active Sets whether the filter is active or inactive (hidden from consumers) (optional)
     * @param  string|null $meta_data external custom client defined data (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createFilter'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FilterTreeResponse
     */
    public function createFilter($version, $account_id, $name, $app_key = null, $parent_filter_id = null, $description = null, $external_id = null, $external_type = null, $active = null, $meta_data = null, string $contentType = self::contentTypes['createFilter'][0])
    {
        list($response) = $this->createFilterWithHttpInfo($version, $account_id, $name, $app_key, $parent_filter_id, $description, $external_id, $external_type, $active, $meta_data, $contentType);
        return $response;
    }

    /**
     * Operation createFilterWithHttpInfo
     *
     * Create Filter
     *
     * @param  float $version (required)
     * @param  int $account_id The account id of the user (must have permissions to the target application) (required)
     * @param  string $name The name of the filter (required)
     * @param  string|null $app_key The appKey of the application to assign the filter to, if not provided then the filter will be applied to the global application (if the account has permissions) (optional)
     * @param  int|null $parent_filter_id The ID of the parent filter, if not provided then the parent filter will be null (optional)
     * @param  string|null $description The description of the filter (optional)
     * @param  string|null $external_id A string identifier used by client applications to store external information (optional)
     * @param  string|null $external_type A string type used by client applications to store external information (optional)
     * @param  bool|null $active Sets whether the filter is active or inactive (hidden from consumers) (optional)
     * @param  string|null $meta_data external custom client defined data (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createFilter'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FilterTreeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createFilterWithHttpInfo($version, $account_id, $name, $app_key = null, $parent_filter_id = null, $description = null, $external_id = null, $external_type = null, $active = null, $meta_data = null, string $contentType = self::contentTypes['createFilter'][0])
    {
        $request = $this->createFilterRequest($version, $account_id, $name, $app_key, $parent_filter_id, $description, $external_id, $external_type, $active, $meta_data, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FilterTreeResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FilterTreeResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FilterTreeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createFilterAsync
     *
     * Create Filter
     *
     * @param  float $version (required)
     * @param  int $account_id The account id of the user (must have permissions to the target application) (required)
     * @param  string $name The name of the filter (required)
     * @param  string|null $app_key The appKey of the application to assign the filter to, if not provided then the filter will be applied to the global application (if the account has permissions) (optional)
     * @param  int|null $parent_filter_id The ID of the parent filter, if not provided then the parent filter will be null (optional)
     * @param  string|null $description The description of the filter (optional)
     * @param  string|null $external_id A string identifier used by client applications to store external information (optional)
     * @param  string|null $external_type A string type used by client applications to store external information (optional)
     * @param  bool|null $active Sets whether the filter is active or inactive (hidden from consumers) (optional)
     * @param  string|null $meta_data external custom client defined data (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createFilter'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createFilterAsync($version, $account_id, $name, $app_key = null, $parent_filter_id = null, $description = null, $external_id = null, $external_type = null, $active = null, $meta_data = null, string $contentType = self::contentTypes['createFilter'][0])
    {
        return $this->createFilterAsyncWithHttpInfo($version, $account_id, $name, $app_key, $parent_filter_id, $description, $external_id, $external_type, $active, $meta_data, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createFilterAsyncWithHttpInfo
     *
     * Create Filter
     *
     * @param  float $version (required)
     * @param  int $account_id The account id of the user (must have permissions to the target application) (required)
     * @param  string $name The name of the filter (required)
     * @param  string|null $app_key The appKey of the application to assign the filter to, if not provided then the filter will be applied to the global application (if the account has permissions) (optional)
     * @param  int|null $parent_filter_id The ID of the parent filter, if not provided then the parent filter will be null (optional)
     * @param  string|null $description The description of the filter (optional)
     * @param  string|null $external_id A string identifier used by client applications to store external information (optional)
     * @param  string|null $external_type A string type used by client applications to store external information (optional)
     * @param  bool|null $active Sets whether the filter is active or inactive (hidden from consumers) (optional)
     * @param  string|null $meta_data external custom client defined data (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createFilter'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createFilterAsyncWithHttpInfo($version, $account_id, $name, $app_key = null, $parent_filter_id = null, $description = null, $external_id = null, $external_type = null, $active = null, $meta_data = null, string $contentType = self::contentTypes['createFilter'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FilterTreeResponse';
        $request = $this->createFilterRequest($version, $account_id, $name, $app_key, $parent_filter_id, $description, $external_id, $external_type, $active, $meta_data, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createFilter'
     *
     * @param  float $version (required)
     * @param  int $account_id The account id of the user (must have permissions to the target application) (required)
     * @param  string $name The name of the filter (required)
     * @param  string|null $app_key The appKey of the application to assign the filter to, if not provided then the filter will be applied to the global application (if the account has permissions) (optional)
     * @param  int|null $parent_filter_id The ID of the parent filter, if not provided then the parent filter will be null (optional)
     * @param  string|null $description The description of the filter (optional)
     * @param  string|null $external_id A string identifier used by client applications to store external information (optional)
     * @param  string|null $external_type A string type used by client applications to store external information (optional)
     * @param  bool|null $active Sets whether the filter is active or inactive (hidden from consumers) (optional)
     * @param  string|null $meta_data external custom client defined data (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createFilter'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createFilterRequest($version, $account_id, $name, $app_key = null, $parent_filter_id = null, $description = null, $external_id = null, $external_type = null, $active = null, $meta_data = null, string $contentType = self::contentTypes['createFilter'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling createFilter'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling createFilter'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling createFilter'
            );
        }









        $resourcePath = '/api/{version}/filter/create';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $app_key,
            'appKey', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $parent_filter_id,
            'parentFilterId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description,
            'description', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $external_id,
            'externalId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $external_type,
            'externalType', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $active,
            'active', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $meta_data,
            'metaData', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteFilter
     *
     * Delete Filter
     *
     * @param  float $version version (required)
     * @param  int $account_id The account id of the user (must have permissions to the filter&#39;s assigned application) (required)
     * @param  int $filter_id The ID of the filter to delete (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteFilter'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SirqulResponse
     */
    public function deleteFilter($version, $account_id, $filter_id, string $contentType = self::contentTypes['deleteFilter'][0])
    {
        list($response) = $this->deleteFilterWithHttpInfo($version, $account_id, $filter_id, $contentType);
        return $response;
    }

    /**
     * Operation deleteFilterWithHttpInfo
     *
     * Delete Filter
     *
     * @param  float $version (required)
     * @param  int $account_id The account id of the user (must have permissions to the filter&#39;s assigned application) (required)
     * @param  int $filter_id The ID of the filter to delete (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteFilter'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SirqulResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteFilterWithHttpInfo($version, $account_id, $filter_id, string $contentType = self::contentTypes['deleteFilter'][0])
    {
        $request = $this->deleteFilterRequest($version, $account_id, $filter_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\SirqulResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\SirqulResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SirqulResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteFilterAsync
     *
     * Delete Filter
     *
     * @param  float $version (required)
     * @param  int $account_id The account id of the user (must have permissions to the filter&#39;s assigned application) (required)
     * @param  int $filter_id The ID of the filter to delete (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteFilter'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFilterAsync($version, $account_id, $filter_id, string $contentType = self::contentTypes['deleteFilter'][0])
    {
        return $this->deleteFilterAsyncWithHttpInfo($version, $account_id, $filter_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteFilterAsyncWithHttpInfo
     *
     * Delete Filter
     *
     * @param  float $version (required)
     * @param  int $account_id The account id of the user (must have permissions to the filter&#39;s assigned application) (required)
     * @param  int $filter_id The ID of the filter to delete (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteFilter'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFilterAsyncWithHttpInfo($version, $account_id, $filter_id, string $contentType = self::contentTypes['deleteFilter'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SirqulResponse';
        $request = $this->deleteFilterRequest($version, $account_id, $filter_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteFilter'
     *
     * @param  float $version (required)
     * @param  int $account_id The account id of the user (must have permissions to the filter&#39;s assigned application) (required)
     * @param  int $filter_id The ID of the filter to delete (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteFilter'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteFilterRequest($version, $account_id, $filter_id, string $contentType = self::contentTypes['deleteFilter'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling deleteFilter'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling deleteFilter'
            );
        }

        // verify the required parameter 'filter_id' is set
        if ($filter_id === null || (is_array($filter_id) && count($filter_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $filter_id when calling deleteFilter'
            );
        }


        $resourcePath = '/api/{version}/filter/delete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $filter_id,
            'filterId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFilter
     *
     * Get Filter
     *
     * @param  float $version version (required)
     * @param  int $filter_id the id of the filter to get (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFilter'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FilterTreeResponse
     */
    public function getFilter($version, $filter_id, string $contentType = self::contentTypes['getFilter'][0])
    {
        list($response) = $this->getFilterWithHttpInfo($version, $filter_id, $contentType);
        return $response;
    }

    /**
     * Operation getFilterWithHttpInfo
     *
     * Get Filter
     *
     * @param  float $version (required)
     * @param  int $filter_id the id of the filter to get (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFilter'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FilterTreeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFilterWithHttpInfo($version, $filter_id, string $contentType = self::contentTypes['getFilter'][0])
    {
        $request = $this->getFilterRequest($version, $filter_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FilterTreeResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FilterTreeResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FilterTreeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getFilterAsync
     *
     * Get Filter
     *
     * @param  float $version (required)
     * @param  int $filter_id the id of the filter to get (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFilter'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFilterAsync($version, $filter_id, string $contentType = self::contentTypes['getFilter'][0])
    {
        return $this->getFilterAsyncWithHttpInfo($version, $filter_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFilterAsyncWithHttpInfo
     *
     * Get Filter
     *
     * @param  float $version (required)
     * @param  int $filter_id the id of the filter to get (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFilter'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFilterAsyncWithHttpInfo($version, $filter_id, string $contentType = self::contentTypes['getFilter'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FilterTreeResponse';
        $request = $this->getFilterRequest($version, $filter_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFilter'
     *
     * @param  float $version (required)
     * @param  int $filter_id the id of the filter to get (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFilter'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getFilterRequest($version, $filter_id, string $contentType = self::contentTypes['getFilter'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling getFilter'
            );
        }

        // verify the required parameter 'filter_id' is set
        if ($filter_id === null || (is_array($filter_id) && count($filter_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $filter_id when calling getFilter'
            );
        }


        $resourcePath = '/api/{version}/filter/get';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $filter_id,
            'filterId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchFilters
     *
     * Search Filters
     *
     * @param  float $version version (required)
     * @param  int|null $account_id The account id of the user (optional)
     * @param  string|null $keyword The string to search on (optional)
     * @param  string|null $app_key the appKey of the application to retrieve filters for (optional)
     * @param  string|null $response_group The group of filters to return: ALL, GLOBAL or MINE. ALL returns both global and application specific matches, GLOBAL only returns global matches, and MINE only returns the application specific matches. If not provided search on the application provided. (optional)
     * @param  bool|null $root_only Restrict the search to only those filters with no parent filter assigned. (optional)
     * @param  string|null $sort_field The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, DISPLAY (optional, default to 'DISPLAY')
     * @param  bool|null $descending The order to return the search results (optional, default to false)
     * @param  int|null $start The record to begin the return set on (optional, default to 0)
     * @param  int|null $limit The number of records to return (optional, default to 20)
     * @param  bool|null $active_only Determines whether to return only active categories (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchFilters'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FilterResponse[]
     */
    public function searchFilters($version, $account_id = null, $keyword = null, $app_key = null, $response_group = null, $root_only = null, $sort_field = 'DISPLAY', $descending = false, $start = 0, $limit = 20, $active_only = true, string $contentType = self::contentTypes['searchFilters'][0])
    {
        list($response) = $this->searchFiltersWithHttpInfo($version, $account_id, $keyword, $app_key, $response_group, $root_only, $sort_field, $descending, $start, $limit, $active_only, $contentType);
        return $response;
    }

    /**
     * Operation searchFiltersWithHttpInfo
     *
     * Search Filters
     *
     * @param  float $version (required)
     * @param  int|null $account_id The account id of the user (optional)
     * @param  string|null $keyword The string to search on (optional)
     * @param  string|null $app_key the appKey of the application to retrieve filters for (optional)
     * @param  string|null $response_group The group of filters to return: ALL, GLOBAL or MINE. ALL returns both global and application specific matches, GLOBAL only returns global matches, and MINE only returns the application specific matches. If not provided search on the application provided. (optional)
     * @param  bool|null $root_only Restrict the search to only those filters with no parent filter assigned. (optional)
     * @param  string|null $sort_field The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, DISPLAY (optional, default to 'DISPLAY')
     * @param  bool|null $descending The order to return the search results (optional, default to false)
     * @param  int|null $start The record to begin the return set on (optional, default to 0)
     * @param  int|null $limit The number of records to return (optional, default to 20)
     * @param  bool|null $active_only Determines whether to return only active categories (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchFilters'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FilterResponse[], HTTP status code, HTTP response headers (array of strings)
     */
    public function searchFiltersWithHttpInfo($version, $account_id = null, $keyword = null, $app_key = null, $response_group = null, $root_only = null, $sort_field = 'DISPLAY', $descending = false, $start = 0, $limit = 20, $active_only = true, string $contentType = self::contentTypes['searchFilters'][0])
    {
        $request = $this->searchFiltersRequest($version, $account_id, $keyword, $app_key, $response_group, $root_only, $sort_field, $descending, $start, $limit, $active_only, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FilterResponse[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FilterResponse[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FilterResponse[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation searchFiltersAsync
     *
     * Search Filters
     *
     * @param  float $version (required)
     * @param  int|null $account_id The account id of the user (optional)
     * @param  string|null $keyword The string to search on (optional)
     * @param  string|null $app_key the appKey of the application to retrieve filters for (optional)
     * @param  string|null $response_group The group of filters to return: ALL, GLOBAL or MINE. ALL returns both global and application specific matches, GLOBAL only returns global matches, and MINE only returns the application specific matches. If not provided search on the application provided. (optional)
     * @param  bool|null $root_only Restrict the search to only those filters with no parent filter assigned. (optional)
     * @param  string|null $sort_field The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, DISPLAY (optional, default to 'DISPLAY')
     * @param  bool|null $descending The order to return the search results (optional, default to false)
     * @param  int|null $start The record to begin the return set on (optional, default to 0)
     * @param  int|null $limit The number of records to return (optional, default to 20)
     * @param  bool|null $active_only Determines whether to return only active categories (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchFilters'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchFiltersAsync($version, $account_id = null, $keyword = null, $app_key = null, $response_group = null, $root_only = null, $sort_field = 'DISPLAY', $descending = false, $start = 0, $limit = 20, $active_only = true, string $contentType = self::contentTypes['searchFilters'][0])
    {
        return $this->searchFiltersAsyncWithHttpInfo($version, $account_id, $keyword, $app_key, $response_group, $root_only, $sort_field, $descending, $start, $limit, $active_only, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchFiltersAsyncWithHttpInfo
     *
     * Search Filters
     *
     * @param  float $version (required)
     * @param  int|null $account_id The account id of the user (optional)
     * @param  string|null $keyword The string to search on (optional)
     * @param  string|null $app_key the appKey of the application to retrieve filters for (optional)
     * @param  string|null $response_group The group of filters to return: ALL, GLOBAL or MINE. ALL returns both global and application specific matches, GLOBAL only returns global matches, and MINE only returns the application specific matches. If not provided search on the application provided. (optional)
     * @param  bool|null $root_only Restrict the search to only those filters with no parent filter assigned. (optional)
     * @param  string|null $sort_field The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, DISPLAY (optional, default to 'DISPLAY')
     * @param  bool|null $descending The order to return the search results (optional, default to false)
     * @param  int|null $start The record to begin the return set on (optional, default to 0)
     * @param  int|null $limit The number of records to return (optional, default to 20)
     * @param  bool|null $active_only Determines whether to return only active categories (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchFilters'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchFiltersAsyncWithHttpInfo($version, $account_id = null, $keyword = null, $app_key = null, $response_group = null, $root_only = null, $sort_field = 'DISPLAY', $descending = false, $start = 0, $limit = 20, $active_only = true, string $contentType = self::contentTypes['searchFilters'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FilterResponse[]';
        $request = $this->searchFiltersRequest($version, $account_id, $keyword, $app_key, $response_group, $root_only, $sort_field, $descending, $start, $limit, $active_only, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchFilters'
     *
     * @param  float $version (required)
     * @param  int|null $account_id The account id of the user (optional)
     * @param  string|null $keyword The string to search on (optional)
     * @param  string|null $app_key the appKey of the application to retrieve filters for (optional)
     * @param  string|null $response_group The group of filters to return: ALL, GLOBAL or MINE. ALL returns both global and application specific matches, GLOBAL only returns global matches, and MINE only returns the application specific matches. If not provided search on the application provided. (optional)
     * @param  bool|null $root_only Restrict the search to only those filters with no parent filter assigned. (optional)
     * @param  string|null $sort_field The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, DISPLAY (optional, default to 'DISPLAY')
     * @param  bool|null $descending The order to return the search results (optional, default to false)
     * @param  int|null $start The record to begin the return set on (optional, default to 0)
     * @param  int|null $limit The number of records to return (optional, default to 20)
     * @param  bool|null $active_only Determines whether to return only active categories (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchFilters'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function searchFiltersRequest($version, $account_id = null, $keyword = null, $app_key = null, $response_group = null, $root_only = null, $sort_field = 'DISPLAY', $descending = false, $start = 0, $limit = 20, $active_only = true, string $contentType = self::contentTypes['searchFilters'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling searchFilters'
            );
        }












        $resourcePath = '/api/{version}/filter/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $keyword,
            'keyword', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $app_key,
            'appKey', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $response_group,
            'responseGroup', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $root_only,
            'rootOnly', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort_field,
            'sortField', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $descending,
            'descending', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start,
            'start', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $active_only,
            'activeOnly', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateFilter
     *
     * Update Filter
     *
     * @param  float $version version (required)
     * @param  int $account_id The account id of the user (required)
     * @param  int $filter_id The ID of the filter to edit (required)
     * @param  int|null $parent_filter_id The ID of the parent filter, if not provided then the parent filter will be null (optional)
     * @param  string|null $name The name of the filter (optional)
     * @param  string|null $description The description of the filter (optional)
     * @param  string|null $external_id A string identifier used by client applications to store external information (optional)
     * @param  string|null $external_type A string type used by client applications to store external information (optional)
     * @param  bool|null $active Sets whether the filter is active or inactive (hidden from consumers) (optional)
     * @param  string|null $meta_data external custom client defined data (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateFilter'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FilterTreeResponse
     */
    public function updateFilter($version, $account_id, $filter_id, $parent_filter_id = null, $name = null, $description = null, $external_id = null, $external_type = null, $active = null, $meta_data = null, string $contentType = self::contentTypes['updateFilter'][0])
    {
        list($response) = $this->updateFilterWithHttpInfo($version, $account_id, $filter_id, $parent_filter_id, $name, $description, $external_id, $external_type, $active, $meta_data, $contentType);
        return $response;
    }

    /**
     * Operation updateFilterWithHttpInfo
     *
     * Update Filter
     *
     * @param  float $version (required)
     * @param  int $account_id The account id of the user (required)
     * @param  int $filter_id The ID of the filter to edit (required)
     * @param  int|null $parent_filter_id The ID of the parent filter, if not provided then the parent filter will be null (optional)
     * @param  string|null $name The name of the filter (optional)
     * @param  string|null $description The description of the filter (optional)
     * @param  string|null $external_id A string identifier used by client applications to store external information (optional)
     * @param  string|null $external_type A string type used by client applications to store external information (optional)
     * @param  bool|null $active Sets whether the filter is active or inactive (hidden from consumers) (optional)
     * @param  string|null $meta_data external custom client defined data (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateFilter'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FilterTreeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateFilterWithHttpInfo($version, $account_id, $filter_id, $parent_filter_id = null, $name = null, $description = null, $external_id = null, $external_type = null, $active = null, $meta_data = null, string $contentType = self::contentTypes['updateFilter'][0])
    {
        $request = $this->updateFilterRequest($version, $account_id, $filter_id, $parent_filter_id, $name, $description, $external_id, $external_type, $active, $meta_data, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FilterTreeResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FilterTreeResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FilterTreeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateFilterAsync
     *
     * Update Filter
     *
     * @param  float $version (required)
     * @param  int $account_id The account id of the user (required)
     * @param  int $filter_id The ID of the filter to edit (required)
     * @param  int|null $parent_filter_id The ID of the parent filter, if not provided then the parent filter will be null (optional)
     * @param  string|null $name The name of the filter (optional)
     * @param  string|null $description The description of the filter (optional)
     * @param  string|null $external_id A string identifier used by client applications to store external information (optional)
     * @param  string|null $external_type A string type used by client applications to store external information (optional)
     * @param  bool|null $active Sets whether the filter is active or inactive (hidden from consumers) (optional)
     * @param  string|null $meta_data external custom client defined data (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateFilter'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateFilterAsync($version, $account_id, $filter_id, $parent_filter_id = null, $name = null, $description = null, $external_id = null, $external_type = null, $active = null, $meta_data = null, string $contentType = self::contentTypes['updateFilter'][0])
    {
        return $this->updateFilterAsyncWithHttpInfo($version, $account_id, $filter_id, $parent_filter_id, $name, $description, $external_id, $external_type, $active, $meta_data, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateFilterAsyncWithHttpInfo
     *
     * Update Filter
     *
     * @param  float $version (required)
     * @param  int $account_id The account id of the user (required)
     * @param  int $filter_id The ID of the filter to edit (required)
     * @param  int|null $parent_filter_id The ID of the parent filter, if not provided then the parent filter will be null (optional)
     * @param  string|null $name The name of the filter (optional)
     * @param  string|null $description The description of the filter (optional)
     * @param  string|null $external_id A string identifier used by client applications to store external information (optional)
     * @param  string|null $external_type A string type used by client applications to store external information (optional)
     * @param  bool|null $active Sets whether the filter is active or inactive (hidden from consumers) (optional)
     * @param  string|null $meta_data external custom client defined data (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateFilter'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateFilterAsyncWithHttpInfo($version, $account_id, $filter_id, $parent_filter_id = null, $name = null, $description = null, $external_id = null, $external_type = null, $active = null, $meta_data = null, string $contentType = self::contentTypes['updateFilter'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FilterTreeResponse';
        $request = $this->updateFilterRequest($version, $account_id, $filter_id, $parent_filter_id, $name, $description, $external_id, $external_type, $active, $meta_data, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateFilter'
     *
     * @param  float $version (required)
     * @param  int $account_id The account id of the user (required)
     * @param  int $filter_id The ID of the filter to edit (required)
     * @param  int|null $parent_filter_id The ID of the parent filter, if not provided then the parent filter will be null (optional)
     * @param  string|null $name The name of the filter (optional)
     * @param  string|null $description The description of the filter (optional)
     * @param  string|null $external_id A string identifier used by client applications to store external information (optional)
     * @param  string|null $external_type A string type used by client applications to store external information (optional)
     * @param  bool|null $active Sets whether the filter is active or inactive (hidden from consumers) (optional)
     * @param  string|null $meta_data external custom client defined data (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateFilter'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateFilterRequest($version, $account_id, $filter_id, $parent_filter_id = null, $name = null, $description = null, $external_id = null, $external_type = null, $active = null, $meta_data = null, string $contentType = self::contentTypes['updateFilter'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling updateFilter'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling updateFilter'
            );
        }

        // verify the required parameter 'filter_id' is set
        if ($filter_id === null || (is_array($filter_id) && count($filter_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $filter_id when calling updateFilter'
            );
        }









        $resourcePath = '/api/{version}/filter/update';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $filter_id,
            'filterId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $parent_filter_id,
            'parentFilterId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description,
            'description', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $external_id,
            'externalId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $external_type,
            'externalType', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $active,
            'active', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $meta_data,
            'metaData', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        if ($this->config->getCertFile()) {
            $options[RequestOptions::CERT] = $this->config->getCertFile();
        }

        if ($this->config->getKeyFile()) {
            $options[RequestOptions::SSL_KEY] = $this->config->getKeyFile();
        }

        return $options;
    }

    private function handleResponseWithDataType(
        string $dataType,
        RequestInterface $request,
        ResponseInterface $response
    ): array {
        if ($dataType === '\SplFileObject') {
            $content = $response->getBody(); //stream goes to serializer
        } else {
            $content = (string) $response->getBody();
            if ($dataType !== 'string') {
                try {
                    $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                } catch (\JsonException $exception) {
                    throw new ApiException(
                        sprintf(
                            'Error JSON decoding server response (%s)',
                            $request->getUri()
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                        $content
                    );
                }
            }
        }

        return [
            ObjectSerializer::deserialize($content, $dataType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    private function responseWithinRangeCode(
        string $rangeCode,
        int $statusCode
    ): bool {
        $left = (int) ($rangeCode[0].'00');
        $right = (int) ($rangeCode[0].'99');

        return $statusCode >= $left && $statusCode <= $right;
    }
}
