<?php
/**
 * OrsonApi
 * PHP version 8.1
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Sirqul IoT Platform
 *
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.20.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\FormDataProcessor;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * OrsonApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class OrsonApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'addMovie' => [
            'application/json',
        ],
        'aiDocs' => [
            'application/json',
        ],
        'aiFindImages' => [
            'application/json',
        ],
        'aiTags' => [
            'application/json',
        ],
        'aiText' => [
            'application/json',
        ],
        'batch' => [
            'application/json',
        ],
        'createInstantEpisode' => [
            'application/json',
        ],
        'createVoiceCanvas' => [
            'application/json',
        ],
        'emotion' => [
            'application/json',
        ],
        'getAddMovieResult' => [
            'application/json',
        ],
        'getBatch' => [
            'application/json',
        ],
        'getEmotion' => [
            'application/json',
        ],
        'getEpisodeStatus' => [
            'application/json',
        ],
        'getRenderStatus' => [
            'application/json',
        ],
        'getSTT' => [
            'application/json',
        ],
        'getTTS' => [
            'application/json',
        ],
        'getTechTune' => [
            'application/json',
        ],
        'getTopics' => [
            'application/json',
        ],
        'getVoiceCanvas' => [
            'application/json',
        ],
        'startVideoRender' => [
            'application/json',
        ],
        'stt' => [
            'application/json',
        ],
        'summarizeTopics' => [
            'application/json',
        ],
        'techTune' => [
            'application/json',
        ],
        'tts' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation addMovie
     *
     * Add Movie
     *
     * @param  float $version version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $movie_name Movie Name (required)
     * @param  string|null $third_party_account_id A third-party account id that is meaningful to your systems (optional)
     * @param  string|null $tags A user defined list (comma-delimited) of tags associated with the movie (optional)
     * @param  \SplFileObject|null $file An uploaded recording to analyze (Currently limited to 10MB) (optional)
     * @param  string|null $url A recording file to download and analyze (Size limit: 1GB) (optional)
     * @param  string|null $callback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addMovie'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrsonAiAddMovieResponse
     */
    public function addMovie($version, $account_id, $movie_name, $third_party_account_id = null, $tags = null, $file = null, $url = null, $callback = null, string $contentType = self::contentTypes['addMovie'][0])
    {
        list($response) = $this->addMovieWithHttpInfo($version, $account_id, $movie_name, $third_party_account_id, $tags, $file, $url, $callback, $contentType);
        return $response;
    }

    /**
     * Operation addMovieWithHttpInfo
     *
     * Add Movie
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $movie_name Movie Name (required)
     * @param  string|null $third_party_account_id A third-party account id that is meaningful to your systems (optional)
     * @param  string|null $tags A user defined list (comma-delimited) of tags associated with the movie (optional)
     * @param  \SplFileObject|null $file An uploaded recording to analyze (Currently limited to 10MB) (optional)
     * @param  string|null $url A recording file to download and analyze (Size limit: 1GB) (optional)
     * @param  string|null $callback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addMovie'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrsonAiAddMovieResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function addMovieWithHttpInfo($version, $account_id, $movie_name, $third_party_account_id = null, $tags = null, $file = null, $url = null, $callback = null, string $contentType = self::contentTypes['addMovie'][0])
    {
        $request = $this->addMovieRequest($version, $account_id, $movie_name, $third_party_account_id, $tags, $file, $url, $callback, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\OrsonAiAddMovieResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\OrsonAiAddMovieResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrsonAiAddMovieResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation addMovieAsync
     *
     * Add Movie
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $movie_name Movie Name (required)
     * @param  string|null $third_party_account_id A third-party account id that is meaningful to your systems (optional)
     * @param  string|null $tags A user defined list (comma-delimited) of tags associated with the movie (optional)
     * @param  \SplFileObject|null $file An uploaded recording to analyze (Currently limited to 10MB) (optional)
     * @param  string|null $url A recording file to download and analyze (Size limit: 1GB) (optional)
     * @param  string|null $callback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addMovie'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addMovieAsync($version, $account_id, $movie_name, $third_party_account_id = null, $tags = null, $file = null, $url = null, $callback = null, string $contentType = self::contentTypes['addMovie'][0])
    {
        return $this->addMovieAsyncWithHttpInfo($version, $account_id, $movie_name, $third_party_account_id, $tags, $file, $url, $callback, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addMovieAsyncWithHttpInfo
     *
     * Add Movie
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $movie_name Movie Name (required)
     * @param  string|null $third_party_account_id A third-party account id that is meaningful to your systems (optional)
     * @param  string|null $tags A user defined list (comma-delimited) of tags associated with the movie (optional)
     * @param  \SplFileObject|null $file An uploaded recording to analyze (Currently limited to 10MB) (optional)
     * @param  string|null $url A recording file to download and analyze (Size limit: 1GB) (optional)
     * @param  string|null $callback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addMovie'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addMovieAsyncWithHttpInfo($version, $account_id, $movie_name, $third_party_account_id = null, $tags = null, $file = null, $url = null, $callback = null, string $contentType = self::contentTypes['addMovie'][0])
    {
        $returnType = '\OpenAPI\Client\Model\OrsonAiAddMovieResponse';
        $request = $this->addMovieRequest($version, $account_id, $movie_name, $third_party_account_id, $tags, $file, $url, $callback, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addMovie'
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $movie_name Movie Name (required)
     * @param  string|null $third_party_account_id A third-party account id that is meaningful to your systems (optional)
     * @param  string|null $tags A user defined list (comma-delimited) of tags associated with the movie (optional)
     * @param  \SplFileObject|null $file An uploaded recording to analyze (Currently limited to 10MB) (optional)
     * @param  string|null $url A recording file to download and analyze (Size limit: 1GB) (optional)
     * @param  string|null $callback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addMovie'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function addMovieRequest($version, $account_id, $movie_name, $third_party_account_id = null, $tags = null, $file = null, $url = null, $callback = null, string $contentType = self::contentTypes['addMovie'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling addMovie'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling addMovie'
            );
        }

        // verify the required parameter 'movie_name' is set
        if ($movie_name === null || (is_array($movie_name) && count($movie_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $movie_name when calling addMovie'
            );
        }







        $resourcePath = '/api/{version}/orson/ai/addMovie';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $third_party_account_id,
            'thirdPartyAccountId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tags,
            'tags', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $movie_name,
            'movieName', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $file,
            'file', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $url,
            'url', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $callback,
            'callback', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation aiDocs
     *
     * Search Docs
     *
     * @param  float $version version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $doc Doc (required)
     * @param  bool|null $return_topics Return Topics (optional)
     * @param  int|null $limit Limit (optional)
     * @param  int|null $offset Offset (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['aiDocs'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrsonAiProtoResponse
     */
    public function aiDocs($version, $account_id, $doc, $return_topics = null, $limit = null, $offset = null, string $contentType = self::contentTypes['aiDocs'][0])
    {
        list($response) = $this->aiDocsWithHttpInfo($version, $account_id, $doc, $return_topics, $limit, $offset, $contentType);
        return $response;
    }

    /**
     * Operation aiDocsWithHttpInfo
     *
     * Search Docs
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $doc Doc (required)
     * @param  bool|null $return_topics Return Topics (optional)
     * @param  int|null $limit Limit (optional)
     * @param  int|null $offset Offset (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['aiDocs'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrsonAiProtoResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function aiDocsWithHttpInfo($version, $account_id, $doc, $return_topics = null, $limit = null, $offset = null, string $contentType = self::contentTypes['aiDocs'][0])
    {
        $request = $this->aiDocsRequest($version, $account_id, $doc, $return_topics, $limit, $offset, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\OrsonAiProtoResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\OrsonAiProtoResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrsonAiProtoResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation aiDocsAsync
     *
     * Search Docs
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $doc Doc (required)
     * @param  bool|null $return_topics Return Topics (optional)
     * @param  int|null $limit Limit (optional)
     * @param  int|null $offset Offset (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['aiDocs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function aiDocsAsync($version, $account_id, $doc, $return_topics = null, $limit = null, $offset = null, string $contentType = self::contentTypes['aiDocs'][0])
    {
        return $this->aiDocsAsyncWithHttpInfo($version, $account_id, $doc, $return_topics, $limit, $offset, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation aiDocsAsyncWithHttpInfo
     *
     * Search Docs
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $doc Doc (required)
     * @param  bool|null $return_topics Return Topics (optional)
     * @param  int|null $limit Limit (optional)
     * @param  int|null $offset Offset (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['aiDocs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function aiDocsAsyncWithHttpInfo($version, $account_id, $doc, $return_topics = null, $limit = null, $offset = null, string $contentType = self::contentTypes['aiDocs'][0])
    {
        $returnType = '\OpenAPI\Client\Model\OrsonAiProtoResponse';
        $request = $this->aiDocsRequest($version, $account_id, $doc, $return_topics, $limit, $offset, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'aiDocs'
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $doc Doc (required)
     * @param  bool|null $return_topics Return Topics (optional)
     * @param  int|null $limit Limit (optional)
     * @param  int|null $offset Offset (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['aiDocs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function aiDocsRequest($version, $account_id, $doc, $return_topics = null, $limit = null, $offset = null, string $contentType = self::contentTypes['aiDocs'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling aiDocs'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling aiDocs'
            );
        }

        // verify the required parameter 'doc' is set
        if ($doc === null || (is_array($doc) && count($doc) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $doc when calling aiDocs'
            );
        }





        $resourcePath = '/api/{version}/orson/ai/docs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $doc,
            'doc', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_topics,
            'return_topics', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation aiFindImages
     *
     * Find images
     *
     * @param  float $version version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $text Text (required)
     * @param  string|null $parse_flag Parse Flag (optional)
     * @param  string|null $fetch_flag Fetch Flag (optional)
     * @param  string|null $size Size (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['aiFindImages'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrsonAiProtoResponse
     */
    public function aiFindImages($version, $account_id, $text, $parse_flag = null, $fetch_flag = null, $size = null, string $contentType = self::contentTypes['aiFindImages'][0])
    {
        list($response) = $this->aiFindImagesWithHttpInfo($version, $account_id, $text, $parse_flag, $fetch_flag, $size, $contentType);
        return $response;
    }

    /**
     * Operation aiFindImagesWithHttpInfo
     *
     * Find images
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $text Text (required)
     * @param  string|null $parse_flag Parse Flag (optional)
     * @param  string|null $fetch_flag Fetch Flag (optional)
     * @param  string|null $size Size (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['aiFindImages'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrsonAiProtoResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function aiFindImagesWithHttpInfo($version, $account_id, $text, $parse_flag = null, $fetch_flag = null, $size = null, string $contentType = self::contentTypes['aiFindImages'][0])
    {
        $request = $this->aiFindImagesRequest($version, $account_id, $text, $parse_flag, $fetch_flag, $size, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\OrsonAiProtoResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\OrsonAiProtoResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrsonAiProtoResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation aiFindImagesAsync
     *
     * Find images
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $text Text (required)
     * @param  string|null $parse_flag Parse Flag (optional)
     * @param  string|null $fetch_flag Fetch Flag (optional)
     * @param  string|null $size Size (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['aiFindImages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function aiFindImagesAsync($version, $account_id, $text, $parse_flag = null, $fetch_flag = null, $size = null, string $contentType = self::contentTypes['aiFindImages'][0])
    {
        return $this->aiFindImagesAsyncWithHttpInfo($version, $account_id, $text, $parse_flag, $fetch_flag, $size, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation aiFindImagesAsyncWithHttpInfo
     *
     * Find images
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $text Text (required)
     * @param  string|null $parse_flag Parse Flag (optional)
     * @param  string|null $fetch_flag Fetch Flag (optional)
     * @param  string|null $size Size (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['aiFindImages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function aiFindImagesAsyncWithHttpInfo($version, $account_id, $text, $parse_flag = null, $fetch_flag = null, $size = null, string $contentType = self::contentTypes['aiFindImages'][0])
    {
        $returnType = '\OpenAPI\Client\Model\OrsonAiProtoResponse';
        $request = $this->aiFindImagesRequest($version, $account_id, $text, $parse_flag, $fetch_flag, $size, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'aiFindImages'
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $text Text (required)
     * @param  string|null $parse_flag Parse Flag (optional)
     * @param  string|null $fetch_flag Fetch Flag (optional)
     * @param  string|null $size Size (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['aiFindImages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function aiFindImagesRequest($version, $account_id, $text, $parse_flag = null, $fetch_flag = null, $size = null, string $contentType = self::contentTypes['aiFindImages'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling aiFindImages'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling aiFindImages'
            );
        }

        // verify the required parameter 'text' is set
        if ($text === null || (is_array($text) && count($text) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $text when calling aiFindImages'
            );
        }





        $resourcePath = '/api/{version}/orson/ai/img';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $text,
            'text', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $parse_flag,
            'parse_flag', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fetch_flag,
            'fetch_flag', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $size,
            'size', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation aiTags
     *
     * Search Tags
     *
     * @param  float $version version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $tags Tags (required)
     * @param  string|null $conditional Conditional (optional)
     * @param  int|null $limit Limit (optional)
     * @param  int|null $offset Offset (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['aiTags'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrsonAiProtoResponse
     */
    public function aiTags($version, $account_id, $tags, $conditional = null, $limit = null, $offset = null, string $contentType = self::contentTypes['aiTags'][0])
    {
        list($response) = $this->aiTagsWithHttpInfo($version, $account_id, $tags, $conditional, $limit, $offset, $contentType);
        return $response;
    }

    /**
     * Operation aiTagsWithHttpInfo
     *
     * Search Tags
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $tags Tags (required)
     * @param  string|null $conditional Conditional (optional)
     * @param  int|null $limit Limit (optional)
     * @param  int|null $offset Offset (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['aiTags'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrsonAiProtoResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function aiTagsWithHttpInfo($version, $account_id, $tags, $conditional = null, $limit = null, $offset = null, string $contentType = self::contentTypes['aiTags'][0])
    {
        $request = $this->aiTagsRequest($version, $account_id, $tags, $conditional, $limit, $offset, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\OrsonAiProtoResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\OrsonAiProtoResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrsonAiProtoResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation aiTagsAsync
     *
     * Search Tags
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $tags Tags (required)
     * @param  string|null $conditional Conditional (optional)
     * @param  int|null $limit Limit (optional)
     * @param  int|null $offset Offset (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['aiTags'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function aiTagsAsync($version, $account_id, $tags, $conditional = null, $limit = null, $offset = null, string $contentType = self::contentTypes['aiTags'][0])
    {
        return $this->aiTagsAsyncWithHttpInfo($version, $account_id, $tags, $conditional, $limit, $offset, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation aiTagsAsyncWithHttpInfo
     *
     * Search Tags
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $tags Tags (required)
     * @param  string|null $conditional Conditional (optional)
     * @param  int|null $limit Limit (optional)
     * @param  int|null $offset Offset (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['aiTags'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function aiTagsAsyncWithHttpInfo($version, $account_id, $tags, $conditional = null, $limit = null, $offset = null, string $contentType = self::contentTypes['aiTags'][0])
    {
        $returnType = '\OpenAPI\Client\Model\OrsonAiProtoResponse';
        $request = $this->aiTagsRequest($version, $account_id, $tags, $conditional, $limit, $offset, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'aiTags'
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $tags Tags (required)
     * @param  string|null $conditional Conditional (optional)
     * @param  int|null $limit Limit (optional)
     * @param  int|null $offset Offset (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['aiTags'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function aiTagsRequest($version, $account_id, $tags, $conditional = null, $limit = null, $offset = null, string $contentType = self::contentTypes['aiTags'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling aiTags'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling aiTags'
            );
        }

        // verify the required parameter 'tags' is set
        if ($tags === null || (is_array($tags) && count($tags) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tags when calling aiTags'
            );
        }





        $resourcePath = '/api/{version}/orson/ai/tags';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tags,
            'tags', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $conditional,
            'conditional', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation aiText
     *
     * Search Text
     *
     * @param  float $version version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $terms Terms (required)
     * @param  string|null $conditional Conditional (optional)
     * @param  int|null $limit Limit (optional)
     * @param  int|null $offset Offset (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['aiText'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrsonAiProtoResponse
     */
    public function aiText($version, $account_id, $terms, $conditional = null, $limit = null, $offset = null, string $contentType = self::contentTypes['aiText'][0])
    {
        list($response) = $this->aiTextWithHttpInfo($version, $account_id, $terms, $conditional, $limit, $offset, $contentType);
        return $response;
    }

    /**
     * Operation aiTextWithHttpInfo
     *
     * Search Text
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $terms Terms (required)
     * @param  string|null $conditional Conditional (optional)
     * @param  int|null $limit Limit (optional)
     * @param  int|null $offset Offset (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['aiText'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrsonAiProtoResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function aiTextWithHttpInfo($version, $account_id, $terms, $conditional = null, $limit = null, $offset = null, string $contentType = self::contentTypes['aiText'][0])
    {
        $request = $this->aiTextRequest($version, $account_id, $terms, $conditional, $limit, $offset, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\OrsonAiProtoResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\OrsonAiProtoResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrsonAiProtoResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation aiTextAsync
     *
     * Search Text
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $terms Terms (required)
     * @param  string|null $conditional Conditional (optional)
     * @param  int|null $limit Limit (optional)
     * @param  int|null $offset Offset (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['aiText'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function aiTextAsync($version, $account_id, $terms, $conditional = null, $limit = null, $offset = null, string $contentType = self::contentTypes['aiText'][0])
    {
        return $this->aiTextAsyncWithHttpInfo($version, $account_id, $terms, $conditional, $limit, $offset, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation aiTextAsyncWithHttpInfo
     *
     * Search Text
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $terms Terms (required)
     * @param  string|null $conditional Conditional (optional)
     * @param  int|null $limit Limit (optional)
     * @param  int|null $offset Offset (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['aiText'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function aiTextAsyncWithHttpInfo($version, $account_id, $terms, $conditional = null, $limit = null, $offset = null, string $contentType = self::contentTypes['aiText'][0])
    {
        $returnType = '\OpenAPI\Client\Model\OrsonAiProtoResponse';
        $request = $this->aiTextRequest($version, $account_id, $terms, $conditional, $limit, $offset, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'aiText'
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $terms Terms (required)
     * @param  string|null $conditional Conditional (optional)
     * @param  int|null $limit Limit (optional)
     * @param  int|null $offset Offset (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['aiText'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function aiTextRequest($version, $account_id, $terms, $conditional = null, $limit = null, $offset = null, string $contentType = self::contentTypes['aiText'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling aiText'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling aiText'
            );
        }

        // verify the required parameter 'terms' is set
        if ($terms === null || (is_array($terms) && count($terms) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $terms when calling aiText'
            );
        }





        $resourcePath = '/api/{version}/orson/ai/text';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $terms,
            'terms', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $conditional,
            'conditional', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation batch
     *
     * Batch Analysis
     *
     * @param  float $version version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string|null $third_party_account_id A third-party account id that is meaningful to your systems (optional)
     * @param  int|null $limit The number of topics to return (optional)
     * @param  string|null $operations The comma-delimited list of A/V batch analysis operations to run on this file. Possible values: Transcript,Topics,Emotions (optional)
     * @param  \SplFileObject|null $file An uploaded recording to analyze (Currently limited to 10MB) (optional)
     * @param  string|null $url A recording file to download and analyze (Size limit: 1GB) (optional)
     * @param  string|null $callback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['batch'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrsonAiBatchResponse
     */
    public function batch($version, $account_id, $third_party_account_id = null, $limit = null, $operations = null, $file = null, $url = null, $callback = null, string $contentType = self::contentTypes['batch'][0])
    {
        list($response) = $this->batchWithHttpInfo($version, $account_id, $third_party_account_id, $limit, $operations, $file, $url, $callback, $contentType);
        return $response;
    }

    /**
     * Operation batchWithHttpInfo
     *
     * Batch Analysis
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string|null $third_party_account_id A third-party account id that is meaningful to your systems (optional)
     * @param  int|null $limit The number of topics to return (optional)
     * @param  string|null $operations The comma-delimited list of A/V batch analysis operations to run on this file. Possible values: Transcript,Topics,Emotions (optional)
     * @param  \SplFileObject|null $file An uploaded recording to analyze (Currently limited to 10MB) (optional)
     * @param  string|null $url A recording file to download and analyze (Size limit: 1GB) (optional)
     * @param  string|null $callback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['batch'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrsonAiBatchResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function batchWithHttpInfo($version, $account_id, $third_party_account_id = null, $limit = null, $operations = null, $file = null, $url = null, $callback = null, string $contentType = self::contentTypes['batch'][0])
    {
        $request = $this->batchRequest($version, $account_id, $third_party_account_id, $limit, $operations, $file, $url, $callback, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\OrsonAiBatchResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\OrsonAiBatchResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrsonAiBatchResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation batchAsync
     *
     * Batch Analysis
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string|null $third_party_account_id A third-party account id that is meaningful to your systems (optional)
     * @param  int|null $limit The number of topics to return (optional)
     * @param  string|null $operations The comma-delimited list of A/V batch analysis operations to run on this file. Possible values: Transcript,Topics,Emotions (optional)
     * @param  \SplFileObject|null $file An uploaded recording to analyze (Currently limited to 10MB) (optional)
     * @param  string|null $url A recording file to download and analyze (Size limit: 1GB) (optional)
     * @param  string|null $callback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['batch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function batchAsync($version, $account_id, $third_party_account_id = null, $limit = null, $operations = null, $file = null, $url = null, $callback = null, string $contentType = self::contentTypes['batch'][0])
    {
        return $this->batchAsyncWithHttpInfo($version, $account_id, $third_party_account_id, $limit, $operations, $file, $url, $callback, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation batchAsyncWithHttpInfo
     *
     * Batch Analysis
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string|null $third_party_account_id A third-party account id that is meaningful to your systems (optional)
     * @param  int|null $limit The number of topics to return (optional)
     * @param  string|null $operations The comma-delimited list of A/V batch analysis operations to run on this file. Possible values: Transcript,Topics,Emotions (optional)
     * @param  \SplFileObject|null $file An uploaded recording to analyze (Currently limited to 10MB) (optional)
     * @param  string|null $url A recording file to download and analyze (Size limit: 1GB) (optional)
     * @param  string|null $callback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['batch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function batchAsyncWithHttpInfo($version, $account_id, $third_party_account_id = null, $limit = null, $operations = null, $file = null, $url = null, $callback = null, string $contentType = self::contentTypes['batch'][0])
    {
        $returnType = '\OpenAPI\Client\Model\OrsonAiBatchResponse';
        $request = $this->batchRequest($version, $account_id, $third_party_account_id, $limit, $operations, $file, $url, $callback, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'batch'
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string|null $third_party_account_id A third-party account id that is meaningful to your systems (optional)
     * @param  int|null $limit The number of topics to return (optional)
     * @param  string|null $operations The comma-delimited list of A/V batch analysis operations to run on this file. Possible values: Transcript,Topics,Emotions (optional)
     * @param  \SplFileObject|null $file An uploaded recording to analyze (Currently limited to 10MB) (optional)
     * @param  string|null $url A recording file to download and analyze (Size limit: 1GB) (optional)
     * @param  string|null $callback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['batch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function batchRequest($version, $account_id, $third_party_account_id = null, $limit = null, $operations = null, $file = null, $url = null, $callback = null, string $contentType = self::contentTypes['batch'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling batch'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling batch'
            );
        }








        $resourcePath = '/api/{version}/orson/ai/batch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $third_party_account_id,
            'thirdPartyAccountId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $operations,
            'operations', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $file,
            'file', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $url,
            'url', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $callback,
            'callback', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createInstantEpisode
     *
     * Creates an instant episode
     *
     * @param  float $version version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $data Request Data String (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createInstantEpisode'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrsonEpisodeResponse
     */
    public function createInstantEpisode($version, $account_id, $data, string $contentType = self::contentTypes['createInstantEpisode'][0])
    {
        list($response) = $this->createInstantEpisodeWithHttpInfo($version, $account_id, $data, $contentType);
        return $response;
    }

    /**
     * Operation createInstantEpisodeWithHttpInfo
     *
     * Creates an instant episode
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $data Request Data String (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createInstantEpisode'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrsonEpisodeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createInstantEpisodeWithHttpInfo($version, $account_id, $data, string $contentType = self::contentTypes['createInstantEpisode'][0])
    {
        $request = $this->createInstantEpisodeRequest($version, $account_id, $data, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\OrsonEpisodeResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\OrsonEpisodeResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrsonEpisodeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createInstantEpisodeAsync
     *
     * Creates an instant episode
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $data Request Data String (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createInstantEpisode'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createInstantEpisodeAsync($version, $account_id, $data, string $contentType = self::contentTypes['createInstantEpisode'][0])
    {
        return $this->createInstantEpisodeAsyncWithHttpInfo($version, $account_id, $data, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createInstantEpisodeAsyncWithHttpInfo
     *
     * Creates an instant episode
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $data Request Data String (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createInstantEpisode'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createInstantEpisodeAsyncWithHttpInfo($version, $account_id, $data, string $contentType = self::contentTypes['createInstantEpisode'][0])
    {
        $returnType = '\OpenAPI\Client\Model\OrsonEpisodeResponse';
        $request = $this->createInstantEpisodeRequest($version, $account_id, $data, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createInstantEpisode'
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $data Request Data String (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createInstantEpisode'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createInstantEpisodeRequest($version, $account_id, $data, string $contentType = self::contentTypes['createInstantEpisode'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling createInstantEpisode'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling createInstantEpisode'
            );
        }

        // verify the required parameter 'data' is set
        if ($data === null || (is_array($data) && count($data) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $data when calling createInstantEpisode'
            );
        }


        $resourcePath = '/api/{version}/orson/stories/episodes/instant';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $data,
            'data', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createVoiceCanvas
     *
     * Create VoiceCanvas images
     *
     * @param  float $version version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $dimensions Enum: \&quot;256x256\&quot; \&quot;512x512\&quot; \&quot;1024x1024\&quot; (required)
     * @param  string|null $third_party_account_id A third-party account id that is meaningful to your systems (optional)
     * @param  string|null $text Provide a transcript or previously extracted topics for image generation (optional)
     * @param  \SplFileObject|null $file An uploaded recording to analyze (Currently limited to 10MB) (optional)
     * @param  string|null $url A recording file to download and analyze (Size limit: 1GB) (optional)
     * @param  bool|null $parse_flag When false, uses the raw value from text instead of identifying topics to fetch/generate from (optional)
     * @param  bool|null $fetch_flag When true, fetches images instead of generating them (optional)
     * @param  string|null $callback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createVoiceCanvas'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrsonAiVoiceCanvasResponse
     */
    public function createVoiceCanvas($version, $account_id, $dimensions, $third_party_account_id = null, $text = null, $file = null, $url = null, $parse_flag = null, $fetch_flag = null, $callback = null, string $contentType = self::contentTypes['createVoiceCanvas'][0])
    {
        list($response) = $this->createVoiceCanvasWithHttpInfo($version, $account_id, $dimensions, $third_party_account_id, $text, $file, $url, $parse_flag, $fetch_flag, $callback, $contentType);
        return $response;
    }

    /**
     * Operation createVoiceCanvasWithHttpInfo
     *
     * Create VoiceCanvas images
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $dimensions Enum: \&quot;256x256\&quot; \&quot;512x512\&quot; \&quot;1024x1024\&quot; (required)
     * @param  string|null $third_party_account_id A third-party account id that is meaningful to your systems (optional)
     * @param  string|null $text Provide a transcript or previously extracted topics for image generation (optional)
     * @param  \SplFileObject|null $file An uploaded recording to analyze (Currently limited to 10MB) (optional)
     * @param  string|null $url A recording file to download and analyze (Size limit: 1GB) (optional)
     * @param  bool|null $parse_flag When false, uses the raw value from text instead of identifying topics to fetch/generate from (optional)
     * @param  bool|null $fetch_flag When true, fetches images instead of generating them (optional)
     * @param  string|null $callback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createVoiceCanvas'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrsonAiVoiceCanvasResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createVoiceCanvasWithHttpInfo($version, $account_id, $dimensions, $third_party_account_id = null, $text = null, $file = null, $url = null, $parse_flag = null, $fetch_flag = null, $callback = null, string $contentType = self::contentTypes['createVoiceCanvas'][0])
    {
        $request = $this->createVoiceCanvasRequest($version, $account_id, $dimensions, $third_party_account_id, $text, $file, $url, $parse_flag, $fetch_flag, $callback, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\OrsonAiVoiceCanvasResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\OrsonAiVoiceCanvasResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrsonAiVoiceCanvasResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createVoiceCanvasAsync
     *
     * Create VoiceCanvas images
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $dimensions Enum: \&quot;256x256\&quot; \&quot;512x512\&quot; \&quot;1024x1024\&quot; (required)
     * @param  string|null $third_party_account_id A third-party account id that is meaningful to your systems (optional)
     * @param  string|null $text Provide a transcript or previously extracted topics for image generation (optional)
     * @param  \SplFileObject|null $file An uploaded recording to analyze (Currently limited to 10MB) (optional)
     * @param  string|null $url A recording file to download and analyze (Size limit: 1GB) (optional)
     * @param  bool|null $parse_flag When false, uses the raw value from text instead of identifying topics to fetch/generate from (optional)
     * @param  bool|null $fetch_flag When true, fetches images instead of generating them (optional)
     * @param  string|null $callback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createVoiceCanvas'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createVoiceCanvasAsync($version, $account_id, $dimensions, $third_party_account_id = null, $text = null, $file = null, $url = null, $parse_flag = null, $fetch_flag = null, $callback = null, string $contentType = self::contentTypes['createVoiceCanvas'][0])
    {
        return $this->createVoiceCanvasAsyncWithHttpInfo($version, $account_id, $dimensions, $third_party_account_id, $text, $file, $url, $parse_flag, $fetch_flag, $callback, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createVoiceCanvasAsyncWithHttpInfo
     *
     * Create VoiceCanvas images
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $dimensions Enum: \&quot;256x256\&quot; \&quot;512x512\&quot; \&quot;1024x1024\&quot; (required)
     * @param  string|null $third_party_account_id A third-party account id that is meaningful to your systems (optional)
     * @param  string|null $text Provide a transcript or previously extracted topics for image generation (optional)
     * @param  \SplFileObject|null $file An uploaded recording to analyze (Currently limited to 10MB) (optional)
     * @param  string|null $url A recording file to download and analyze (Size limit: 1GB) (optional)
     * @param  bool|null $parse_flag When false, uses the raw value from text instead of identifying topics to fetch/generate from (optional)
     * @param  bool|null $fetch_flag When true, fetches images instead of generating them (optional)
     * @param  string|null $callback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createVoiceCanvas'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createVoiceCanvasAsyncWithHttpInfo($version, $account_id, $dimensions, $third_party_account_id = null, $text = null, $file = null, $url = null, $parse_flag = null, $fetch_flag = null, $callback = null, string $contentType = self::contentTypes['createVoiceCanvas'][0])
    {
        $returnType = '\OpenAPI\Client\Model\OrsonAiVoiceCanvasResponse';
        $request = $this->createVoiceCanvasRequest($version, $account_id, $dimensions, $third_party_account_id, $text, $file, $url, $parse_flag, $fetch_flag, $callback, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createVoiceCanvas'
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $dimensions Enum: \&quot;256x256\&quot; \&quot;512x512\&quot; \&quot;1024x1024\&quot; (required)
     * @param  string|null $third_party_account_id A third-party account id that is meaningful to your systems (optional)
     * @param  string|null $text Provide a transcript or previously extracted topics for image generation (optional)
     * @param  \SplFileObject|null $file An uploaded recording to analyze (Currently limited to 10MB) (optional)
     * @param  string|null $url A recording file to download and analyze (Size limit: 1GB) (optional)
     * @param  bool|null $parse_flag When false, uses the raw value from text instead of identifying topics to fetch/generate from (optional)
     * @param  bool|null $fetch_flag When true, fetches images instead of generating them (optional)
     * @param  string|null $callback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createVoiceCanvas'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createVoiceCanvasRequest($version, $account_id, $dimensions, $third_party_account_id = null, $text = null, $file = null, $url = null, $parse_flag = null, $fetch_flag = null, $callback = null, string $contentType = self::contentTypes['createVoiceCanvas'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling createVoiceCanvas'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling createVoiceCanvas'
            );
        }

        // verify the required parameter 'dimensions' is set
        if ($dimensions === null || (is_array($dimensions) && count($dimensions) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $dimensions when calling createVoiceCanvas'
            );
        }









        $resourcePath = '/api/{version}/orson/ai/voiceCanvas';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $third_party_account_id,
            'thirdPartyAccountId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $dimensions,
            'dimensions', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $text,
            'text', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $file,
            'file', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $url,
            'url', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $parse_flag,
            'parseFlag', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fetch_flag,
            'fetchFlag', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $callback,
            'callback', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation emotion
     *
     * Detect emotions
     *
     * @param  float $version version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string|null $third_party_account_id A third-party account id that is meaningful to your systems (optional)
     * @param  \SplFileObject|null $file An uploaded recording to analyze (Currently limited to 10MB) (optional)
     * @param  string|null $url A recording file to download and analyze (Size limit: 1GB) (optional)
     * @param  string|null $callback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['emotion'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrsonAiEmotionsResponse
     */
    public function emotion($version, $account_id, $third_party_account_id = null, $file = null, $url = null, $callback = null, string $contentType = self::contentTypes['emotion'][0])
    {
        list($response) = $this->emotionWithHttpInfo($version, $account_id, $third_party_account_id, $file, $url, $callback, $contentType);
        return $response;
    }

    /**
     * Operation emotionWithHttpInfo
     *
     * Detect emotions
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string|null $third_party_account_id A third-party account id that is meaningful to your systems (optional)
     * @param  \SplFileObject|null $file An uploaded recording to analyze (Currently limited to 10MB) (optional)
     * @param  string|null $url A recording file to download and analyze (Size limit: 1GB) (optional)
     * @param  string|null $callback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['emotion'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrsonAiEmotionsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function emotionWithHttpInfo($version, $account_id, $third_party_account_id = null, $file = null, $url = null, $callback = null, string $contentType = self::contentTypes['emotion'][0])
    {
        $request = $this->emotionRequest($version, $account_id, $third_party_account_id, $file, $url, $callback, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\OrsonAiEmotionsResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\OrsonAiEmotionsResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrsonAiEmotionsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation emotionAsync
     *
     * Detect emotions
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string|null $third_party_account_id A third-party account id that is meaningful to your systems (optional)
     * @param  \SplFileObject|null $file An uploaded recording to analyze (Currently limited to 10MB) (optional)
     * @param  string|null $url A recording file to download and analyze (Size limit: 1GB) (optional)
     * @param  string|null $callback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['emotion'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function emotionAsync($version, $account_id, $third_party_account_id = null, $file = null, $url = null, $callback = null, string $contentType = self::contentTypes['emotion'][0])
    {
        return $this->emotionAsyncWithHttpInfo($version, $account_id, $third_party_account_id, $file, $url, $callback, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation emotionAsyncWithHttpInfo
     *
     * Detect emotions
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string|null $third_party_account_id A third-party account id that is meaningful to your systems (optional)
     * @param  \SplFileObject|null $file An uploaded recording to analyze (Currently limited to 10MB) (optional)
     * @param  string|null $url A recording file to download and analyze (Size limit: 1GB) (optional)
     * @param  string|null $callback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['emotion'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function emotionAsyncWithHttpInfo($version, $account_id, $third_party_account_id = null, $file = null, $url = null, $callback = null, string $contentType = self::contentTypes['emotion'][0])
    {
        $returnType = '\OpenAPI\Client\Model\OrsonAiEmotionsResponse';
        $request = $this->emotionRequest($version, $account_id, $third_party_account_id, $file, $url, $callback, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'emotion'
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string|null $third_party_account_id A third-party account id that is meaningful to your systems (optional)
     * @param  \SplFileObject|null $file An uploaded recording to analyze (Currently limited to 10MB) (optional)
     * @param  string|null $url A recording file to download and analyze (Size limit: 1GB) (optional)
     * @param  string|null $callback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['emotion'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function emotionRequest($version, $account_id, $third_party_account_id = null, $file = null, $url = null, $callback = null, string $contentType = self::contentTypes['emotion'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling emotion'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling emotion'
            );
        }






        $resourcePath = '/api/{version}/orson/ai/emotion';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $third_party_account_id,
            'thirdPartyAccountId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $file,
            'file', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $url,
            'url', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $callback,
            'callback', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAddMovieResult
     *
     * Get Add Movie Result
     *
     * @param  float $version version (required)
     * @param  string $request_id Orson Request Id (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAddMovieResult'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrsonAiAddMovieResponse
     */
    public function getAddMovieResult($version, $request_id, $account_id, string $contentType = self::contentTypes['getAddMovieResult'][0])
    {
        list($response) = $this->getAddMovieResultWithHttpInfo($version, $request_id, $account_id, $contentType);
        return $response;
    }

    /**
     * Operation getAddMovieResultWithHttpInfo
     *
     * Get Add Movie Result
     *
     * @param  float $version (required)
     * @param  string $request_id Orson Request Id (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAddMovieResult'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrsonAiAddMovieResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAddMovieResultWithHttpInfo($version, $request_id, $account_id, string $contentType = self::contentTypes['getAddMovieResult'][0])
    {
        $request = $this->getAddMovieResultRequest($version, $request_id, $account_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\OrsonAiAddMovieResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\OrsonAiAddMovieResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrsonAiAddMovieResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getAddMovieResultAsync
     *
     * Get Add Movie Result
     *
     * @param  float $version (required)
     * @param  string $request_id Orson Request Id (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAddMovieResult'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAddMovieResultAsync($version, $request_id, $account_id, string $contentType = self::contentTypes['getAddMovieResult'][0])
    {
        return $this->getAddMovieResultAsyncWithHttpInfo($version, $request_id, $account_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAddMovieResultAsyncWithHttpInfo
     *
     * Get Add Movie Result
     *
     * @param  float $version (required)
     * @param  string $request_id Orson Request Id (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAddMovieResult'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAddMovieResultAsyncWithHttpInfo($version, $request_id, $account_id, string $contentType = self::contentTypes['getAddMovieResult'][0])
    {
        $returnType = '\OpenAPI\Client\Model\OrsonAiAddMovieResponse';
        $request = $this->getAddMovieResultRequest($version, $request_id, $account_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAddMovieResult'
     *
     * @param  float $version (required)
     * @param  string $request_id Orson Request Id (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAddMovieResult'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAddMovieResultRequest($version, $request_id, $account_id, string $contentType = self::contentTypes['getAddMovieResult'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling getAddMovieResult'
            );
        }

        // verify the required parameter 'request_id' is set
        if ($request_id === null || (is_array($request_id) && count($request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $request_id when calling getAddMovieResult'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling getAddMovieResult'
            );
        }


        $resourcePath = '/api/{version}/orson/ai/addMovie/{requestId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($request_id !== null) {
            $resourcePath = str_replace(
                '{' . 'requestId' . '}',
                ObjectSerializer::toPathValue($request_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBatch
     *
     * Get Batch Analysis Results
     *
     * @param  float $version version (required)
     * @param  string $request_id Orson Request Id (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBatch'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrsonAiBatchResponse
     */
    public function getBatch($version, $request_id, $account_id, string $contentType = self::contentTypes['getBatch'][0])
    {
        list($response) = $this->getBatchWithHttpInfo($version, $request_id, $account_id, $contentType);
        return $response;
    }

    /**
     * Operation getBatchWithHttpInfo
     *
     * Get Batch Analysis Results
     *
     * @param  float $version (required)
     * @param  string $request_id Orson Request Id (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBatch'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrsonAiBatchResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBatchWithHttpInfo($version, $request_id, $account_id, string $contentType = self::contentTypes['getBatch'][0])
    {
        $request = $this->getBatchRequest($version, $request_id, $account_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\OrsonAiBatchResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\OrsonAiBatchResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrsonAiBatchResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getBatchAsync
     *
     * Get Batch Analysis Results
     *
     * @param  float $version (required)
     * @param  string $request_id Orson Request Id (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBatchAsync($version, $request_id, $account_id, string $contentType = self::contentTypes['getBatch'][0])
    {
        return $this->getBatchAsyncWithHttpInfo($version, $request_id, $account_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBatchAsyncWithHttpInfo
     *
     * Get Batch Analysis Results
     *
     * @param  float $version (required)
     * @param  string $request_id Orson Request Id (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBatchAsyncWithHttpInfo($version, $request_id, $account_id, string $contentType = self::contentTypes['getBatch'][0])
    {
        $returnType = '\OpenAPI\Client\Model\OrsonAiBatchResponse';
        $request = $this->getBatchRequest($version, $request_id, $account_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBatch'
     *
     * @param  float $version (required)
     * @param  string $request_id Orson Request Id (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getBatchRequest($version, $request_id, $account_id, string $contentType = self::contentTypes['getBatch'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling getBatch'
            );
        }

        // verify the required parameter 'request_id' is set
        if ($request_id === null || (is_array($request_id) && count($request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $request_id when calling getBatch'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling getBatch'
            );
        }


        $resourcePath = '/api/{version}/orson/ai/batch/{requestId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($request_id !== null) {
            $resourcePath = str_replace(
                '{' . 'requestId' . '}',
                ObjectSerializer::toPathValue($request_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getEmotion
     *
     * Get Emotion Results
     *
     * @param  float $version version (required)
     * @param  string $request_id Orson Request Id (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEmotion'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrsonAiEmotionsResponse
     */
    public function getEmotion($version, $request_id, $account_id, string $contentType = self::contentTypes['getEmotion'][0])
    {
        list($response) = $this->getEmotionWithHttpInfo($version, $request_id, $account_id, $contentType);
        return $response;
    }

    /**
     * Operation getEmotionWithHttpInfo
     *
     * Get Emotion Results
     *
     * @param  float $version (required)
     * @param  string $request_id Orson Request Id (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEmotion'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrsonAiEmotionsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getEmotionWithHttpInfo($version, $request_id, $account_id, string $contentType = self::contentTypes['getEmotion'][0])
    {
        $request = $this->getEmotionRequest($version, $request_id, $account_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\OrsonAiEmotionsResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\OrsonAiEmotionsResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrsonAiEmotionsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getEmotionAsync
     *
     * Get Emotion Results
     *
     * @param  float $version (required)
     * @param  string $request_id Orson Request Id (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEmotion'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEmotionAsync($version, $request_id, $account_id, string $contentType = self::contentTypes['getEmotion'][0])
    {
        return $this->getEmotionAsyncWithHttpInfo($version, $request_id, $account_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getEmotionAsyncWithHttpInfo
     *
     * Get Emotion Results
     *
     * @param  float $version (required)
     * @param  string $request_id Orson Request Id (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEmotion'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEmotionAsyncWithHttpInfo($version, $request_id, $account_id, string $contentType = self::contentTypes['getEmotion'][0])
    {
        $returnType = '\OpenAPI\Client\Model\OrsonAiEmotionsResponse';
        $request = $this->getEmotionRequest($version, $request_id, $account_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getEmotion'
     *
     * @param  float $version (required)
     * @param  string $request_id Orson Request Id (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEmotion'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getEmotionRequest($version, $request_id, $account_id, string $contentType = self::contentTypes['getEmotion'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling getEmotion'
            );
        }

        // verify the required parameter 'request_id' is set
        if ($request_id === null || (is_array($request_id) && count($request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $request_id when calling getEmotion'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling getEmotion'
            );
        }


        $resourcePath = '/api/{version}/orson/ai/emotion/{requestId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($request_id !== null) {
            $resourcePath = str_replace(
                '{' . 'requestId' . '}',
                ObjectSerializer::toPathValue($request_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getEpisodeStatus
     *
     * Check episode status
     *
     * @param  float $version version (required)
     * @param  int $episode_id Episode ID (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEpisodeStatus'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrsonEpisodeResponse
     */
    public function getEpisodeStatus($version, $episode_id, $account_id, string $contentType = self::contentTypes['getEpisodeStatus'][0])
    {
        list($response) = $this->getEpisodeStatusWithHttpInfo($version, $episode_id, $account_id, $contentType);
        return $response;
    }

    /**
     * Operation getEpisodeStatusWithHttpInfo
     *
     * Check episode status
     *
     * @param  float $version (required)
     * @param  int $episode_id Episode ID (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEpisodeStatus'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrsonEpisodeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getEpisodeStatusWithHttpInfo($version, $episode_id, $account_id, string $contentType = self::contentTypes['getEpisodeStatus'][0])
    {
        $request = $this->getEpisodeStatusRequest($version, $episode_id, $account_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\OrsonEpisodeResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\OrsonEpisodeResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrsonEpisodeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getEpisodeStatusAsync
     *
     * Check episode status
     *
     * @param  float $version (required)
     * @param  int $episode_id Episode ID (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEpisodeStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEpisodeStatusAsync($version, $episode_id, $account_id, string $contentType = self::contentTypes['getEpisodeStatus'][0])
    {
        return $this->getEpisodeStatusAsyncWithHttpInfo($version, $episode_id, $account_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getEpisodeStatusAsyncWithHttpInfo
     *
     * Check episode status
     *
     * @param  float $version (required)
     * @param  int $episode_id Episode ID (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEpisodeStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEpisodeStatusAsyncWithHttpInfo($version, $episode_id, $account_id, string $contentType = self::contentTypes['getEpisodeStatus'][0])
    {
        $returnType = '\OpenAPI\Client\Model\OrsonEpisodeResponse';
        $request = $this->getEpisodeStatusRequest($version, $episode_id, $account_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getEpisodeStatus'
     *
     * @param  float $version (required)
     * @param  int $episode_id Episode ID (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEpisodeStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getEpisodeStatusRequest($version, $episode_id, $account_id, string $contentType = self::contentTypes['getEpisodeStatus'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling getEpisodeStatus'
            );
        }

        // verify the required parameter 'episode_id' is set
        if ($episode_id === null || (is_array($episode_id) && count($episode_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $episode_id when calling getEpisodeStatus'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling getEpisodeStatus'
            );
        }


        $resourcePath = '/api/{version}/orson/stories/episodes/{episodeId}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($episode_id !== null) {
            $resourcePath = str_replace(
                '{' . 'episodeId' . '}',
                ObjectSerializer::toPathValue($episode_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRenderStatus
     *
     * Check episode status
     *
     * @param  float $version version (required)
     * @param  string $render_id Render ID (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRenderStatus'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrsonRenderResponse
     */
    public function getRenderStatus($version, $render_id, $account_id, string $contentType = self::contentTypes['getRenderStatus'][0])
    {
        list($response) = $this->getRenderStatusWithHttpInfo($version, $render_id, $account_id, $contentType);
        return $response;
    }

    /**
     * Operation getRenderStatusWithHttpInfo
     *
     * Check episode status
     *
     * @param  float $version (required)
     * @param  string $render_id Render ID (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRenderStatus'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrsonRenderResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRenderStatusWithHttpInfo($version, $render_id, $account_id, string $contentType = self::contentTypes['getRenderStatus'][0])
    {
        $request = $this->getRenderStatusRequest($version, $render_id, $account_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\OrsonRenderResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\OrsonRenderResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrsonRenderResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getRenderStatusAsync
     *
     * Check episode status
     *
     * @param  float $version (required)
     * @param  string $render_id Render ID (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRenderStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRenderStatusAsync($version, $render_id, $account_id, string $contentType = self::contentTypes['getRenderStatus'][0])
    {
        return $this->getRenderStatusAsyncWithHttpInfo($version, $render_id, $account_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRenderStatusAsyncWithHttpInfo
     *
     * Check episode status
     *
     * @param  float $version (required)
     * @param  string $render_id Render ID (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRenderStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRenderStatusAsyncWithHttpInfo($version, $render_id, $account_id, string $contentType = self::contentTypes['getRenderStatus'][0])
    {
        $returnType = '\OpenAPI\Client\Model\OrsonRenderResponse';
        $request = $this->getRenderStatusRequest($version, $render_id, $account_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRenderStatus'
     *
     * @param  float $version (required)
     * @param  string $render_id Render ID (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRenderStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getRenderStatusRequest($version, $render_id, $account_id, string $contentType = self::contentTypes['getRenderStatus'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling getRenderStatus'
            );
        }

        // verify the required parameter 'render_id' is set
        if ($render_id === null || (is_array($render_id) && count($render_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $render_id when calling getRenderStatus'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling getRenderStatus'
            );
        }


        $resourcePath = '/api/{version}/orson/stories/renders/{renderId}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($render_id !== null) {
            $resourcePath = str_replace(
                '{' . 'renderId' . '}',
                ObjectSerializer::toPathValue($render_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSTT
     *
     * Get Speach to Text Result
     *
     * @param  float $version version (required)
     * @param  string $request_id Orson Request Id (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSTT'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrsonAiSTTResponse
     */
    public function getSTT($version, $request_id, $account_id, string $contentType = self::contentTypes['getSTT'][0])
    {
        list($response) = $this->getSTTWithHttpInfo($version, $request_id, $account_id, $contentType);
        return $response;
    }

    /**
     * Operation getSTTWithHttpInfo
     *
     * Get Speach to Text Result
     *
     * @param  float $version (required)
     * @param  string $request_id Orson Request Id (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSTT'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrsonAiSTTResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSTTWithHttpInfo($version, $request_id, $account_id, string $contentType = self::contentTypes['getSTT'][0])
    {
        $request = $this->getSTTRequest($version, $request_id, $account_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\OrsonAiSTTResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\OrsonAiSTTResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrsonAiSTTResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getSTTAsync
     *
     * Get Speach to Text Result
     *
     * @param  float $version (required)
     * @param  string $request_id Orson Request Id (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSTT'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSTTAsync($version, $request_id, $account_id, string $contentType = self::contentTypes['getSTT'][0])
    {
        return $this->getSTTAsyncWithHttpInfo($version, $request_id, $account_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSTTAsyncWithHttpInfo
     *
     * Get Speach to Text Result
     *
     * @param  float $version (required)
     * @param  string $request_id Orson Request Id (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSTT'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSTTAsyncWithHttpInfo($version, $request_id, $account_id, string $contentType = self::contentTypes['getSTT'][0])
    {
        $returnType = '\OpenAPI\Client\Model\OrsonAiSTTResponse';
        $request = $this->getSTTRequest($version, $request_id, $account_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSTT'
     *
     * @param  float $version (required)
     * @param  string $request_id Orson Request Id (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSTT'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getSTTRequest($version, $request_id, $account_id, string $contentType = self::contentTypes['getSTT'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling getSTT'
            );
        }

        // verify the required parameter 'request_id' is set
        if ($request_id === null || (is_array($request_id) && count($request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $request_id when calling getSTT'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling getSTT'
            );
        }


        $resourcePath = '/api/{version}/orson/ai/stt/{requestId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($request_id !== null) {
            $resourcePath = str_replace(
                '{' . 'requestId' . '}',
                ObjectSerializer::toPathValue($request_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTTS
     *
     * Get Text to Speach Result
     *
     * @param  float $version version (required)
     * @param  string $request_id Orson Request Id (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTTS'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrsonAiTTSResponse
     */
    public function getTTS($version, $request_id, $account_id, string $contentType = self::contentTypes['getTTS'][0])
    {
        list($response) = $this->getTTSWithHttpInfo($version, $request_id, $account_id, $contentType);
        return $response;
    }

    /**
     * Operation getTTSWithHttpInfo
     *
     * Get Text to Speach Result
     *
     * @param  float $version (required)
     * @param  string $request_id Orson Request Id (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTTS'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrsonAiTTSResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTTSWithHttpInfo($version, $request_id, $account_id, string $contentType = self::contentTypes['getTTS'][0])
    {
        $request = $this->getTTSRequest($version, $request_id, $account_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\OrsonAiTTSResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\OrsonAiTTSResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrsonAiTTSResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getTTSAsync
     *
     * Get Text to Speach Result
     *
     * @param  float $version (required)
     * @param  string $request_id Orson Request Id (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTTS'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTTSAsync($version, $request_id, $account_id, string $contentType = self::contentTypes['getTTS'][0])
    {
        return $this->getTTSAsyncWithHttpInfo($version, $request_id, $account_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTTSAsyncWithHttpInfo
     *
     * Get Text to Speach Result
     *
     * @param  float $version (required)
     * @param  string $request_id Orson Request Id (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTTS'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTTSAsyncWithHttpInfo($version, $request_id, $account_id, string $contentType = self::contentTypes['getTTS'][0])
    {
        $returnType = '\OpenAPI\Client\Model\OrsonAiTTSResponse';
        $request = $this->getTTSRequest($version, $request_id, $account_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTTS'
     *
     * @param  float $version (required)
     * @param  string $request_id Orson Request Id (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTTS'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getTTSRequest($version, $request_id, $account_id, string $contentType = self::contentTypes['getTTS'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling getTTS'
            );
        }

        // verify the required parameter 'request_id' is set
        if ($request_id === null || (is_array($request_id) && count($request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $request_id when calling getTTS'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling getTTS'
            );
        }


        $resourcePath = '/api/{version}/orson/ai/tts/{requestId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($request_id !== null) {
            $resourcePath = str_replace(
                '{' . 'requestId' . '}',
                ObjectSerializer::toPathValue($request_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTechTune
     *
     * Get TechTune Results
     *
     * @param  float $version version (required)
     * @param  string $request_id Orson Request Id (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTechTune'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrsonAiTechTuneResponse
     */
    public function getTechTune($version, $request_id, $account_id, string $contentType = self::contentTypes['getTechTune'][0])
    {
        list($response) = $this->getTechTuneWithHttpInfo($version, $request_id, $account_id, $contentType);
        return $response;
    }

    /**
     * Operation getTechTuneWithHttpInfo
     *
     * Get TechTune Results
     *
     * @param  float $version (required)
     * @param  string $request_id Orson Request Id (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTechTune'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrsonAiTechTuneResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTechTuneWithHttpInfo($version, $request_id, $account_id, string $contentType = self::contentTypes['getTechTune'][0])
    {
        $request = $this->getTechTuneRequest($version, $request_id, $account_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\OrsonAiTechTuneResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\OrsonAiTechTuneResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrsonAiTechTuneResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getTechTuneAsync
     *
     * Get TechTune Results
     *
     * @param  float $version (required)
     * @param  string $request_id Orson Request Id (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTechTune'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTechTuneAsync($version, $request_id, $account_id, string $contentType = self::contentTypes['getTechTune'][0])
    {
        return $this->getTechTuneAsyncWithHttpInfo($version, $request_id, $account_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTechTuneAsyncWithHttpInfo
     *
     * Get TechTune Results
     *
     * @param  float $version (required)
     * @param  string $request_id Orson Request Id (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTechTune'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTechTuneAsyncWithHttpInfo($version, $request_id, $account_id, string $contentType = self::contentTypes['getTechTune'][0])
    {
        $returnType = '\OpenAPI\Client\Model\OrsonAiTechTuneResponse';
        $request = $this->getTechTuneRequest($version, $request_id, $account_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTechTune'
     *
     * @param  float $version (required)
     * @param  string $request_id Orson Request Id (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTechTune'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getTechTuneRequest($version, $request_id, $account_id, string $contentType = self::contentTypes['getTechTune'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling getTechTune'
            );
        }

        // verify the required parameter 'request_id' is set
        if ($request_id === null || (is_array($request_id) && count($request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $request_id when calling getTechTune'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling getTechTune'
            );
        }


        $resourcePath = '/api/{version}/orson/ai/techTune/{requestId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($request_id !== null) {
            $resourcePath = str_replace(
                '{' . 'requestId' . '}',
                ObjectSerializer::toPathValue($request_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTopics
     *
     * Get Topics
     *
     * @param  float $version version (required)
     * @param  string $request_id Orson Request Id (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTopics'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrsonAiTopicsResponse
     */
    public function getTopics($version, $request_id, $account_id, string $contentType = self::contentTypes['getTopics'][0])
    {
        list($response) = $this->getTopicsWithHttpInfo($version, $request_id, $account_id, $contentType);
        return $response;
    }

    /**
     * Operation getTopicsWithHttpInfo
     *
     * Get Topics
     *
     * @param  float $version (required)
     * @param  string $request_id Orson Request Id (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTopics'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrsonAiTopicsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTopicsWithHttpInfo($version, $request_id, $account_id, string $contentType = self::contentTypes['getTopics'][0])
    {
        $request = $this->getTopicsRequest($version, $request_id, $account_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\OrsonAiTopicsResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\OrsonAiTopicsResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrsonAiTopicsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getTopicsAsync
     *
     * Get Topics
     *
     * @param  float $version (required)
     * @param  string $request_id Orson Request Id (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTopics'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTopicsAsync($version, $request_id, $account_id, string $contentType = self::contentTypes['getTopics'][0])
    {
        return $this->getTopicsAsyncWithHttpInfo($version, $request_id, $account_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTopicsAsyncWithHttpInfo
     *
     * Get Topics
     *
     * @param  float $version (required)
     * @param  string $request_id Orson Request Id (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTopics'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTopicsAsyncWithHttpInfo($version, $request_id, $account_id, string $contentType = self::contentTypes['getTopics'][0])
    {
        $returnType = '\OpenAPI\Client\Model\OrsonAiTopicsResponse';
        $request = $this->getTopicsRequest($version, $request_id, $account_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTopics'
     *
     * @param  float $version (required)
     * @param  string $request_id Orson Request Id (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTopics'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getTopicsRequest($version, $request_id, $account_id, string $contentType = self::contentTypes['getTopics'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling getTopics'
            );
        }

        // verify the required parameter 'request_id' is set
        if ($request_id === null || (is_array($request_id) && count($request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $request_id when calling getTopics'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling getTopics'
            );
        }


        $resourcePath = '/api/{version}/orson/ai/topics/{requestId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($request_id !== null) {
            $resourcePath = str_replace(
                '{' . 'requestId' . '}',
                ObjectSerializer::toPathValue($request_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getVoiceCanvas
     *
     * Get VoiceCanvas images
     *
     * @param  float $version version (required)
     * @param  string $request_id Orson Request Id (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVoiceCanvas'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrsonAiVoiceCanvasResponse
     */
    public function getVoiceCanvas($version, $request_id, $account_id, string $contentType = self::contentTypes['getVoiceCanvas'][0])
    {
        list($response) = $this->getVoiceCanvasWithHttpInfo($version, $request_id, $account_id, $contentType);
        return $response;
    }

    /**
     * Operation getVoiceCanvasWithHttpInfo
     *
     * Get VoiceCanvas images
     *
     * @param  float $version (required)
     * @param  string $request_id Orson Request Id (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVoiceCanvas'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrsonAiVoiceCanvasResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getVoiceCanvasWithHttpInfo($version, $request_id, $account_id, string $contentType = self::contentTypes['getVoiceCanvas'][0])
    {
        $request = $this->getVoiceCanvasRequest($version, $request_id, $account_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\OrsonAiVoiceCanvasResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\OrsonAiVoiceCanvasResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrsonAiVoiceCanvasResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getVoiceCanvasAsync
     *
     * Get VoiceCanvas images
     *
     * @param  float $version (required)
     * @param  string $request_id Orson Request Id (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVoiceCanvas'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVoiceCanvasAsync($version, $request_id, $account_id, string $contentType = self::contentTypes['getVoiceCanvas'][0])
    {
        return $this->getVoiceCanvasAsyncWithHttpInfo($version, $request_id, $account_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getVoiceCanvasAsyncWithHttpInfo
     *
     * Get VoiceCanvas images
     *
     * @param  float $version (required)
     * @param  string $request_id Orson Request Id (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVoiceCanvas'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVoiceCanvasAsyncWithHttpInfo($version, $request_id, $account_id, string $contentType = self::contentTypes['getVoiceCanvas'][0])
    {
        $returnType = '\OpenAPI\Client\Model\OrsonAiVoiceCanvasResponse';
        $request = $this->getVoiceCanvasRequest($version, $request_id, $account_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getVoiceCanvas'
     *
     * @param  float $version (required)
     * @param  string $request_id Orson Request Id (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVoiceCanvas'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getVoiceCanvasRequest($version, $request_id, $account_id, string $contentType = self::contentTypes['getVoiceCanvas'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling getVoiceCanvas'
            );
        }

        // verify the required parameter 'request_id' is set
        if ($request_id === null || (is_array($request_id) && count($request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $request_id when calling getVoiceCanvas'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling getVoiceCanvas'
            );
        }


        $resourcePath = '/api/{version}/orson/ai/voiceCanvas/{requestId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($request_id !== null) {
            $resourcePath = str_replace(
                '{' . 'requestId' . '}',
                ObjectSerializer::toPathValue($request_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation startVideoRender
     *
     * Starts a StoryStitch video render
     *
     * @param  float $version version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $data Request Data String (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['startVideoRender'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrsonRenderResponse
     */
    public function startVideoRender($version, $account_id, $data, string $contentType = self::contentTypes['startVideoRender'][0])
    {
        list($response) = $this->startVideoRenderWithHttpInfo($version, $account_id, $data, $contentType);
        return $response;
    }

    /**
     * Operation startVideoRenderWithHttpInfo
     *
     * Starts a StoryStitch video render
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $data Request Data String (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['startVideoRender'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrsonRenderResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function startVideoRenderWithHttpInfo($version, $account_id, $data, string $contentType = self::contentTypes['startVideoRender'][0])
    {
        $request = $this->startVideoRenderRequest($version, $account_id, $data, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\OrsonRenderResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\OrsonRenderResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrsonRenderResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation startVideoRenderAsync
     *
     * Starts a StoryStitch video render
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $data Request Data String (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['startVideoRender'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function startVideoRenderAsync($version, $account_id, $data, string $contentType = self::contentTypes['startVideoRender'][0])
    {
        return $this->startVideoRenderAsyncWithHttpInfo($version, $account_id, $data, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation startVideoRenderAsyncWithHttpInfo
     *
     * Starts a StoryStitch video render
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $data Request Data String (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['startVideoRender'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function startVideoRenderAsyncWithHttpInfo($version, $account_id, $data, string $contentType = self::contentTypes['startVideoRender'][0])
    {
        $returnType = '\OpenAPI\Client\Model\OrsonRenderResponse';
        $request = $this->startVideoRenderRequest($version, $account_id, $data, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'startVideoRender'
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $data Request Data String (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['startVideoRender'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function startVideoRenderRequest($version, $account_id, $data, string $contentType = self::contentTypes['startVideoRender'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling startVideoRender'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling startVideoRender'
            );
        }

        // verify the required parameter 'data' is set
        if ($data === null || (is_array($data) && count($data) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $data when calling startVideoRender'
            );
        }


        $resourcePath = '/api/{version}/orson/stories/renders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $data,
            'data', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation stt
     *
     * Speach to Text
     *
     * @param  float $version version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string|null $third_party_account_id A third-party account id that is meaningful to your systems (optional)
     * @param  string|null $source_language Source Language (optional)
     * @param  string|null $target_language Target Language (optional)
     * @param  \SplFileObject|null $file An uploaded recording to analyze (Currently limited to 10MB) (optional)
     * @param  string|null $url A recording file to download and analyze (Size limit: 1GB) (optional)
     * @param  string|null $callback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['stt'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrsonAiSTTResponse
     */
    public function stt($version, $account_id, $third_party_account_id = null, $source_language = null, $target_language = null, $file = null, $url = null, $callback = null, string $contentType = self::contentTypes['stt'][0])
    {
        list($response) = $this->sttWithHttpInfo($version, $account_id, $third_party_account_id, $source_language, $target_language, $file, $url, $callback, $contentType);
        return $response;
    }

    /**
     * Operation sttWithHttpInfo
     *
     * Speach to Text
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string|null $third_party_account_id A third-party account id that is meaningful to your systems (optional)
     * @param  string|null $source_language Source Language (optional)
     * @param  string|null $target_language Target Language (optional)
     * @param  \SplFileObject|null $file An uploaded recording to analyze (Currently limited to 10MB) (optional)
     * @param  string|null $url A recording file to download and analyze (Size limit: 1GB) (optional)
     * @param  string|null $callback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['stt'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrsonAiSTTResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function sttWithHttpInfo($version, $account_id, $third_party_account_id = null, $source_language = null, $target_language = null, $file = null, $url = null, $callback = null, string $contentType = self::contentTypes['stt'][0])
    {
        $request = $this->sttRequest($version, $account_id, $third_party_account_id, $source_language, $target_language, $file, $url, $callback, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\OrsonAiSTTResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\OrsonAiSTTResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrsonAiSTTResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation sttAsync
     *
     * Speach to Text
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string|null $third_party_account_id A third-party account id that is meaningful to your systems (optional)
     * @param  string|null $source_language Source Language (optional)
     * @param  string|null $target_language Target Language (optional)
     * @param  \SplFileObject|null $file An uploaded recording to analyze (Currently limited to 10MB) (optional)
     * @param  string|null $url A recording file to download and analyze (Size limit: 1GB) (optional)
     * @param  string|null $callback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['stt'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sttAsync($version, $account_id, $third_party_account_id = null, $source_language = null, $target_language = null, $file = null, $url = null, $callback = null, string $contentType = self::contentTypes['stt'][0])
    {
        return $this->sttAsyncWithHttpInfo($version, $account_id, $third_party_account_id, $source_language, $target_language, $file, $url, $callback, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation sttAsyncWithHttpInfo
     *
     * Speach to Text
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string|null $third_party_account_id A third-party account id that is meaningful to your systems (optional)
     * @param  string|null $source_language Source Language (optional)
     * @param  string|null $target_language Target Language (optional)
     * @param  \SplFileObject|null $file An uploaded recording to analyze (Currently limited to 10MB) (optional)
     * @param  string|null $url A recording file to download and analyze (Size limit: 1GB) (optional)
     * @param  string|null $callback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['stt'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sttAsyncWithHttpInfo($version, $account_id, $third_party_account_id = null, $source_language = null, $target_language = null, $file = null, $url = null, $callback = null, string $contentType = self::contentTypes['stt'][0])
    {
        $returnType = '\OpenAPI\Client\Model\OrsonAiSTTResponse';
        $request = $this->sttRequest($version, $account_id, $third_party_account_id, $source_language, $target_language, $file, $url, $callback, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'stt'
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string|null $third_party_account_id A third-party account id that is meaningful to your systems (optional)
     * @param  string|null $source_language Source Language (optional)
     * @param  string|null $target_language Target Language (optional)
     * @param  \SplFileObject|null $file An uploaded recording to analyze (Currently limited to 10MB) (optional)
     * @param  string|null $url A recording file to download and analyze (Size limit: 1GB) (optional)
     * @param  string|null $callback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['stt'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function sttRequest($version, $account_id, $third_party_account_id = null, $source_language = null, $target_language = null, $file = null, $url = null, $callback = null, string $contentType = self::contentTypes['stt'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling stt'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling stt'
            );
        }








        $resourcePath = '/api/{version}/orson/ai/stt';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $third_party_account_id,
            'thirdPartyAccountId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $source_language,
            'sourceLanguage', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $target_language,
            'targetLanguage', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $file,
            'file', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $url,
            'url', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $callback,
            'callback', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation summarizeTopics
     *
     * Summarize Topics
     *
     * @param  float $version version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string|null $third_party_account_id A third-party account id that is meaningful to your systems (optional)
     * @param  string|null $doc The text to get topics for. (optional)
     * @param  \SplFileObject|null $file An uploaded recording to analyze (Currently limited to 10MB) (optional)
     * @param  string|null $url A recording file to download and analyze (Size limit: 1GB) (optional)
     * @param  int|null $limit The number of results to return (optional)
     * @param  int|null $offset The starting offset into the total result set to start from (optional)
     * @param  string|null $callback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['summarizeTopics'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrsonAiTopicsResponse
     */
    public function summarizeTopics($version, $account_id, $third_party_account_id = null, $doc = null, $file = null, $url = null, $limit = null, $offset = null, $callback = null, string $contentType = self::contentTypes['summarizeTopics'][0])
    {
        list($response) = $this->summarizeTopicsWithHttpInfo($version, $account_id, $third_party_account_id, $doc, $file, $url, $limit, $offset, $callback, $contentType);
        return $response;
    }

    /**
     * Operation summarizeTopicsWithHttpInfo
     *
     * Summarize Topics
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string|null $third_party_account_id A third-party account id that is meaningful to your systems (optional)
     * @param  string|null $doc The text to get topics for. (optional)
     * @param  \SplFileObject|null $file An uploaded recording to analyze (Currently limited to 10MB) (optional)
     * @param  string|null $url A recording file to download and analyze (Size limit: 1GB) (optional)
     * @param  int|null $limit The number of results to return (optional)
     * @param  int|null $offset The starting offset into the total result set to start from (optional)
     * @param  string|null $callback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['summarizeTopics'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrsonAiTopicsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function summarizeTopicsWithHttpInfo($version, $account_id, $third_party_account_id = null, $doc = null, $file = null, $url = null, $limit = null, $offset = null, $callback = null, string $contentType = self::contentTypes['summarizeTopics'][0])
    {
        $request = $this->summarizeTopicsRequest($version, $account_id, $third_party_account_id, $doc, $file, $url, $limit, $offset, $callback, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\OrsonAiTopicsResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\OrsonAiTopicsResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrsonAiTopicsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation summarizeTopicsAsync
     *
     * Summarize Topics
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string|null $third_party_account_id A third-party account id that is meaningful to your systems (optional)
     * @param  string|null $doc The text to get topics for. (optional)
     * @param  \SplFileObject|null $file An uploaded recording to analyze (Currently limited to 10MB) (optional)
     * @param  string|null $url A recording file to download and analyze (Size limit: 1GB) (optional)
     * @param  int|null $limit The number of results to return (optional)
     * @param  int|null $offset The starting offset into the total result set to start from (optional)
     * @param  string|null $callback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['summarizeTopics'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function summarizeTopicsAsync($version, $account_id, $third_party_account_id = null, $doc = null, $file = null, $url = null, $limit = null, $offset = null, $callback = null, string $contentType = self::contentTypes['summarizeTopics'][0])
    {
        return $this->summarizeTopicsAsyncWithHttpInfo($version, $account_id, $third_party_account_id, $doc, $file, $url, $limit, $offset, $callback, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation summarizeTopicsAsyncWithHttpInfo
     *
     * Summarize Topics
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string|null $third_party_account_id A third-party account id that is meaningful to your systems (optional)
     * @param  string|null $doc The text to get topics for. (optional)
     * @param  \SplFileObject|null $file An uploaded recording to analyze (Currently limited to 10MB) (optional)
     * @param  string|null $url A recording file to download and analyze (Size limit: 1GB) (optional)
     * @param  int|null $limit The number of results to return (optional)
     * @param  int|null $offset The starting offset into the total result set to start from (optional)
     * @param  string|null $callback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['summarizeTopics'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function summarizeTopicsAsyncWithHttpInfo($version, $account_id, $third_party_account_id = null, $doc = null, $file = null, $url = null, $limit = null, $offset = null, $callback = null, string $contentType = self::contentTypes['summarizeTopics'][0])
    {
        $returnType = '\OpenAPI\Client\Model\OrsonAiTopicsResponse';
        $request = $this->summarizeTopicsRequest($version, $account_id, $third_party_account_id, $doc, $file, $url, $limit, $offset, $callback, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'summarizeTopics'
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string|null $third_party_account_id A third-party account id that is meaningful to your systems (optional)
     * @param  string|null $doc The text to get topics for. (optional)
     * @param  \SplFileObject|null $file An uploaded recording to analyze (Currently limited to 10MB) (optional)
     * @param  string|null $url A recording file to download and analyze (Size limit: 1GB) (optional)
     * @param  int|null $limit The number of results to return (optional)
     * @param  int|null $offset The starting offset into the total result set to start from (optional)
     * @param  string|null $callback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['summarizeTopics'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function summarizeTopicsRequest($version, $account_id, $third_party_account_id = null, $doc = null, $file = null, $url = null, $limit = null, $offset = null, $callback = null, string $contentType = self::contentTypes['summarizeTopics'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling summarizeTopics'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling summarizeTopics'
            );
        }









        $resourcePath = '/api/{version}/orson/ai/topics';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $third_party_account_id,
            'thirdPartyAccountId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $doc,
            'doc', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $file,
            'file', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $url,
            'url', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $callback,
            'callback', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation techTune
     *
     * Detect Technical Issues
     *
     * @param  float $version version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  int $num_faces_expected Number of expected faces (required)
     * @param  string|null $third_party_account_id A third-party account id that is meaningful to your systems (optional)
     * @param  \SplFileObject|null $file An uploaded recording to analyze (Currently limited to 10MB) (optional)
     * @param  string|null $url A recording file to download and analyze (Size limit: 1GB) (optional)
     * @param  string|null $callback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['techTune'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrsonAiTechTuneResponse
     */
    public function techTune($version, $account_id, $num_faces_expected, $third_party_account_id = null, $file = null, $url = null, $callback = null, string $contentType = self::contentTypes['techTune'][0])
    {
        list($response) = $this->techTuneWithHttpInfo($version, $account_id, $num_faces_expected, $third_party_account_id, $file, $url, $callback, $contentType);
        return $response;
    }

    /**
     * Operation techTuneWithHttpInfo
     *
     * Detect Technical Issues
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  int $num_faces_expected Number of expected faces (required)
     * @param  string|null $third_party_account_id A third-party account id that is meaningful to your systems (optional)
     * @param  \SplFileObject|null $file An uploaded recording to analyze (Currently limited to 10MB) (optional)
     * @param  string|null $url A recording file to download and analyze (Size limit: 1GB) (optional)
     * @param  string|null $callback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['techTune'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrsonAiTechTuneResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function techTuneWithHttpInfo($version, $account_id, $num_faces_expected, $third_party_account_id = null, $file = null, $url = null, $callback = null, string $contentType = self::contentTypes['techTune'][0])
    {
        $request = $this->techTuneRequest($version, $account_id, $num_faces_expected, $third_party_account_id, $file, $url, $callback, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\OrsonAiTechTuneResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\OrsonAiTechTuneResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrsonAiTechTuneResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation techTuneAsync
     *
     * Detect Technical Issues
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  int $num_faces_expected Number of expected faces (required)
     * @param  string|null $third_party_account_id A third-party account id that is meaningful to your systems (optional)
     * @param  \SplFileObject|null $file An uploaded recording to analyze (Currently limited to 10MB) (optional)
     * @param  string|null $url A recording file to download and analyze (Size limit: 1GB) (optional)
     * @param  string|null $callback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['techTune'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function techTuneAsync($version, $account_id, $num_faces_expected, $third_party_account_id = null, $file = null, $url = null, $callback = null, string $contentType = self::contentTypes['techTune'][0])
    {
        return $this->techTuneAsyncWithHttpInfo($version, $account_id, $num_faces_expected, $third_party_account_id, $file, $url, $callback, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation techTuneAsyncWithHttpInfo
     *
     * Detect Technical Issues
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  int $num_faces_expected Number of expected faces (required)
     * @param  string|null $third_party_account_id A third-party account id that is meaningful to your systems (optional)
     * @param  \SplFileObject|null $file An uploaded recording to analyze (Currently limited to 10MB) (optional)
     * @param  string|null $url A recording file to download and analyze (Size limit: 1GB) (optional)
     * @param  string|null $callback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['techTune'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function techTuneAsyncWithHttpInfo($version, $account_id, $num_faces_expected, $third_party_account_id = null, $file = null, $url = null, $callback = null, string $contentType = self::contentTypes['techTune'][0])
    {
        $returnType = '\OpenAPI\Client\Model\OrsonAiTechTuneResponse';
        $request = $this->techTuneRequest($version, $account_id, $num_faces_expected, $third_party_account_id, $file, $url, $callback, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'techTune'
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  int $num_faces_expected Number of expected faces (required)
     * @param  string|null $third_party_account_id A third-party account id that is meaningful to your systems (optional)
     * @param  \SplFileObject|null $file An uploaded recording to analyze (Currently limited to 10MB) (optional)
     * @param  string|null $url A recording file to download and analyze (Size limit: 1GB) (optional)
     * @param  string|null $callback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['techTune'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function techTuneRequest($version, $account_id, $num_faces_expected, $third_party_account_id = null, $file = null, $url = null, $callback = null, string $contentType = self::contentTypes['techTune'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling techTune'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling techTune'
            );
        }

        // verify the required parameter 'num_faces_expected' is set
        if ($num_faces_expected === null || (is_array($num_faces_expected) && count($num_faces_expected) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $num_faces_expected when calling techTune'
            );
        }






        $resourcePath = '/api/{version}/orson/ai/techTune';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $third_party_account_id,
            'thirdPartyAccountId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $num_faces_expected,
            'numFacesExpected', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $file,
            'file', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $url,
            'url', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $callback,
            'callback', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation tts
     *
     * Text to Speach
     *
     * @param  float $version version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $text Text (required)
     * @param  string|null $third_party_account_id A third-party account id that is meaningful to your systems (optional)
     * @param  string|null $language The language to use for the speaker and incoming text (optional)
     * @param  string|null $voice A language-specific voice to use, or picks the language default if not provided (optional)
     * @param  string|null $callback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['tts'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrsonAiTTSResponse
     */
    public function tts($version, $account_id, $text, $third_party_account_id = null, $language = null, $voice = null, $callback = null, string $contentType = self::contentTypes['tts'][0])
    {
        list($response) = $this->ttsWithHttpInfo($version, $account_id, $text, $third_party_account_id, $language, $voice, $callback, $contentType);
        return $response;
    }

    /**
     * Operation ttsWithHttpInfo
     *
     * Text to Speach
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $text Text (required)
     * @param  string|null $third_party_account_id A third-party account id that is meaningful to your systems (optional)
     * @param  string|null $language The language to use for the speaker and incoming text (optional)
     * @param  string|null $voice A language-specific voice to use, or picks the language default if not provided (optional)
     * @param  string|null $callback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['tts'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrsonAiTTSResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function ttsWithHttpInfo($version, $account_id, $text, $third_party_account_id = null, $language = null, $voice = null, $callback = null, string $contentType = self::contentTypes['tts'][0])
    {
        $request = $this->ttsRequest($version, $account_id, $text, $third_party_account_id, $language, $voice, $callback, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\OrsonAiTTSResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\OrsonAiTTSResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrsonAiTTSResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation ttsAsync
     *
     * Text to Speach
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $text Text (required)
     * @param  string|null $third_party_account_id A third-party account id that is meaningful to your systems (optional)
     * @param  string|null $language The language to use for the speaker and incoming text (optional)
     * @param  string|null $voice A language-specific voice to use, or picks the language default if not provided (optional)
     * @param  string|null $callback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['tts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ttsAsync($version, $account_id, $text, $third_party_account_id = null, $language = null, $voice = null, $callback = null, string $contentType = self::contentTypes['tts'][0])
    {
        return $this->ttsAsyncWithHttpInfo($version, $account_id, $text, $third_party_account_id, $language, $voice, $callback, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ttsAsyncWithHttpInfo
     *
     * Text to Speach
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $text Text (required)
     * @param  string|null $third_party_account_id A third-party account id that is meaningful to your systems (optional)
     * @param  string|null $language The language to use for the speaker and incoming text (optional)
     * @param  string|null $voice A language-specific voice to use, or picks the language default if not provided (optional)
     * @param  string|null $callback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['tts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ttsAsyncWithHttpInfo($version, $account_id, $text, $third_party_account_id = null, $language = null, $voice = null, $callback = null, string $contentType = self::contentTypes['tts'][0])
    {
        $returnType = '\OpenAPI\Client\Model\OrsonAiTTSResponse';
        $request = $this->ttsRequest($version, $account_id, $text, $third_party_account_id, $language, $voice, $callback, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'tts'
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $text Text (required)
     * @param  string|null $third_party_account_id A third-party account id that is meaningful to your systems (optional)
     * @param  string|null $language The language to use for the speaker and incoming text (optional)
     * @param  string|null $voice A language-specific voice to use, or picks the language default if not provided (optional)
     * @param  string|null $callback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['tts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ttsRequest($version, $account_id, $text, $third_party_account_id = null, $language = null, $voice = null, $callback = null, string $contentType = self::contentTypes['tts'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling tts'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling tts'
            );
        }

        // verify the required parameter 'text' is set
        if ($text === null || (is_array($text) && count($text) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $text when calling tts'
            );
        }






        $resourcePath = '/api/{version}/orson/ai/tts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $third_party_account_id,
            'thirdPartyAccountId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $text,
            'text', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $language,
            'language', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $voice,
            'voice', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $callback,
            'callback', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        if ($this->config->getCertFile()) {
            $options[RequestOptions::CERT] = $this->config->getCertFile();
        }

        if ($this->config->getKeyFile()) {
            $options[RequestOptions::SSL_KEY] = $this->config->getKeyFile();
        }

        return $options;
    }

    private function handleResponseWithDataType(
        string $dataType,
        RequestInterface $request,
        ResponseInterface $response
    ): array {
        if ($dataType === '\SplFileObject') {
            $content = $response->getBody(); //stream goes to serializer
        } else {
            $content = (string) $response->getBody();
            if ($dataType !== 'string') {
                try {
                    $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                } catch (\JsonException $exception) {
                    throw new ApiException(
                        sprintf(
                            'Error JSON decoding server response (%s)',
                            $request->getUri()
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                        $content
                    );
                }
            }
        }

        return [
            ObjectSerializer::deserialize($content, $dataType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    private function responseWithinRangeCode(
        string $rangeCode,
        int $statusCode
    ): bool {
        $left = (int) ($rangeCode[0].'00');
        $right = (int) ($rangeCode[0].'99');

        return $statusCode >= $left && $statusCode <= $right;
    }
}
