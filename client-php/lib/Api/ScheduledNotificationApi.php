<?php
/**
 * ScheduledNotificationApi
 * PHP version 8.1
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Sirqul IoT Platform
 *
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.20.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\FormDataProcessor;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * ScheduledNotificationApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class ScheduledNotificationApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'createScheduledNotification' => [
            'application/json',
        ],
        'deleteScheduledNotification' => [
            'application/json',
        ],
        'getScheduledNotification' => [
            'application/json',
        ],
        'scheduleNotificationListings' => [
            'application/json',
        ],
        'searchScheduledNotifications' => [
            'application/json',
        ],
        'updateScheduledNotification' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation createScheduledNotification
     *
     * Create Scheduled Notification
     *
     * @param  int $account_id The logged in user. (required)
     * @param  string $name The name of the scheduled notification (required)
     * @param  string $type The type of scheduled notification. Supported values include: MOBILE_NOTIFICATION - sends push notifications via APNS and GCM EMAIL - sends email messages SMS - sends text messages (required)
     * @param  string $message The message to send (required)
     * @param  int|null $content_id The payload content ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param  string|null $content_name The payload content name that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param  string|null $content_type The payload content type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param  int|null $parent_id The payload parent ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param  string|null $parent_type The payload parent type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param  string|null $app_key The application that the notifications will send to. If connectionGroupIds, connectionAccountIds, and audienceIds is not set, this will send to all users who have used the application. This parameter is also required when sending push notifications via the MOBILE_NOTIFICATION type. (optional)
     * @param  string|null $grouping_id Client defined identifier for grouping multiple scheduled notifications. This can be used with the search endpoint to return scheduled notifications with the same groupingId for display purposes. Only results that have been created by the user will be returned when using this feature. (optional)
     * @param  string|null $connection_group_ids The connection groups to use to generate the list of recipients (comma separated list of connection group IDs) (optional)
     * @param  string|null $connection_account_ids The connection accounts to use to generate the list of recipients (comma separated list of user account ids) (optional)
     * @param  int|null $audience_id This parameter is deprecated. The audience used to generate the list of recipients (optional)
     * @param  string|null $audience_ids The audiences used to generate the list of recipients (comma separated list of audience IDs) (optional)
     * @param  string|null $album_ids The album ids to associate with the scheduled notification (comma separated list of album IDs) (optional)
     * @param  int|null $report_id The report used to generate the the list of recipients (optional)
     * @param  string|null $report_params The parameters to supply to the report used to generate the the list of recipients (optional)
     * @param  string|null $endpoint_url The URL for making an HTTP call (optional)
     * @param  string|null $payload The parameters for making an HTTP call (optional)
     * @param  int|null $scheduled_date The next time when the scheduled notification should begin processing (time in milliseconds). If this is left empty, then the startDate will be used. (optional)
     * @param  int|null $start_date The start time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to be available now. (optional)
     * @param  int|null $end_date The end time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to not have an expiration date. (optional)
     * @param  string|null $cron_expression The cron expression that represents the processing schedule. This uses the unix cron expression format. For example: 0 0 * * * will run once a day at midnight UTC. (optional)
     * @param  string|null $cron_type The cron expression type: UNIX, CRON4J, QUARTZ (optional)
     * @param  string|null $meta_data Additional metadata for the scheduled notification (optional)
     * @param  string|null $conditional_input Json input representing conditional logic that has to be met before running the scheduled notification (optional)
     * @param  string|null $template_type This determines if the Scheduled Notification is a template which is used as a basis for dynamically generating re-occurring Scheduled Notifications. The available types include: REPORTING - saves an adhoc report to be able to run again at another time GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business owner) GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business employee, retailer location, etc) GEOFENCE_TRIGGER - template for sending notifications to the account that triggered the geofence/audience (i.e. the customer) GEOFENCE_HTTP_CALL - template for making http calls when the geofences are triggered (optional)
     * @param  string|null $visibility Determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited) (optional)
     * @param  bool|null $active Sets whether the Scheduled Notification is active or not (inactive Scheduled Notifications are not processed). This is a quick way to toggle on or off without altering its schedule. The default value is &#39;true&#39;. (optional)
     * @param  bool|null $send_now  (optional)
     * @param  string|null $event_type Sets the event type for the notification (optional, default to 'CUSTOM')
     * @param  string|null $deep_link_uri The payload deep link URI that can be used by the client app to direct users to a screen in the app (optional)
     * @param  bool|null $send_to_all Determines whether to send to all users of the app if set to true for push notifications (appKey is required) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createScheduledNotification'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ScheduledNotificationFullResponse
     */
    public function createScheduledNotification($account_id, $name, $type, $message, $content_id = null, $content_name = null, $content_type = null, $parent_id = null, $parent_type = null, $app_key = null, $grouping_id = null, $connection_group_ids = null, $connection_account_ids = null, $audience_id = null, $audience_ids = null, $album_ids = null, $report_id = null, $report_params = null, $endpoint_url = null, $payload = null, $scheduled_date = null, $start_date = null, $end_date = null, $cron_expression = null, $cron_type = null, $meta_data = null, $conditional_input = null, $template_type = null, $visibility = null, $active = null, $send_now = null, $event_type = 'CUSTOM', $deep_link_uri = null, $send_to_all = null, string $contentType = self::contentTypes['createScheduledNotification'][0])
    {
        list($response) = $this->createScheduledNotificationWithHttpInfo($account_id, $name, $type, $message, $content_id, $content_name, $content_type, $parent_id, $parent_type, $app_key, $grouping_id, $connection_group_ids, $connection_account_ids, $audience_id, $audience_ids, $album_ids, $report_id, $report_params, $endpoint_url, $payload, $scheduled_date, $start_date, $end_date, $cron_expression, $cron_type, $meta_data, $conditional_input, $template_type, $visibility, $active, $send_now, $event_type, $deep_link_uri, $send_to_all, $contentType);
        return $response;
    }

    /**
     * Operation createScheduledNotificationWithHttpInfo
     *
     * Create Scheduled Notification
     *
     * @param  int $account_id The logged in user. (required)
     * @param  string $name The name of the scheduled notification (required)
     * @param  string $type The type of scheduled notification. Supported values include: MOBILE_NOTIFICATION - sends push notifications via APNS and GCM EMAIL - sends email messages SMS - sends text messages (required)
     * @param  string $message The message to send (required)
     * @param  int|null $content_id The payload content ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param  string|null $content_name The payload content name that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param  string|null $content_type The payload content type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param  int|null $parent_id The payload parent ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param  string|null $parent_type The payload parent type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param  string|null $app_key The application that the notifications will send to. If connectionGroupIds, connectionAccountIds, and audienceIds is not set, this will send to all users who have used the application. This parameter is also required when sending push notifications via the MOBILE_NOTIFICATION type. (optional)
     * @param  string|null $grouping_id Client defined identifier for grouping multiple scheduled notifications. This can be used with the search endpoint to return scheduled notifications with the same groupingId for display purposes. Only results that have been created by the user will be returned when using this feature. (optional)
     * @param  string|null $connection_group_ids The connection groups to use to generate the list of recipients (comma separated list of connection group IDs) (optional)
     * @param  string|null $connection_account_ids The connection accounts to use to generate the list of recipients (comma separated list of user account ids) (optional)
     * @param  int|null $audience_id This parameter is deprecated. The audience used to generate the list of recipients (optional)
     * @param  string|null $audience_ids The audiences used to generate the list of recipients (comma separated list of audience IDs) (optional)
     * @param  string|null $album_ids The album ids to associate with the scheduled notification (comma separated list of album IDs) (optional)
     * @param  int|null $report_id The report used to generate the the list of recipients (optional)
     * @param  string|null $report_params The parameters to supply to the report used to generate the the list of recipients (optional)
     * @param  string|null $endpoint_url The URL for making an HTTP call (optional)
     * @param  string|null $payload The parameters for making an HTTP call (optional)
     * @param  int|null $scheduled_date The next time when the scheduled notification should begin processing (time in milliseconds). If this is left empty, then the startDate will be used. (optional)
     * @param  int|null $start_date The start time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to be available now. (optional)
     * @param  int|null $end_date The end time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to not have an expiration date. (optional)
     * @param  string|null $cron_expression The cron expression that represents the processing schedule. This uses the unix cron expression format. For example: 0 0 * * * will run once a day at midnight UTC. (optional)
     * @param  string|null $cron_type The cron expression type: UNIX, CRON4J, QUARTZ (optional)
     * @param  string|null $meta_data Additional metadata for the scheduled notification (optional)
     * @param  string|null $conditional_input Json input representing conditional logic that has to be met before running the scheduled notification (optional)
     * @param  string|null $template_type This determines if the Scheduled Notification is a template which is used as a basis for dynamically generating re-occurring Scheduled Notifications. The available types include: REPORTING - saves an adhoc report to be able to run again at another time GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business owner) GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business employee, retailer location, etc) GEOFENCE_TRIGGER - template for sending notifications to the account that triggered the geofence/audience (i.e. the customer) GEOFENCE_HTTP_CALL - template for making http calls when the geofences are triggered (optional)
     * @param  string|null $visibility Determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited) (optional)
     * @param  bool|null $active Sets whether the Scheduled Notification is active or not (inactive Scheduled Notifications are not processed). This is a quick way to toggle on or off without altering its schedule. The default value is &#39;true&#39;. (optional)
     * @param  bool|null $send_now  (optional)
     * @param  string|null $event_type Sets the event type for the notification (optional, default to 'CUSTOM')
     * @param  string|null $deep_link_uri The payload deep link URI that can be used by the client app to direct users to a screen in the app (optional)
     * @param  bool|null $send_to_all Determines whether to send to all users of the app if set to true for push notifications (appKey is required) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createScheduledNotification'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ScheduledNotificationFullResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createScheduledNotificationWithHttpInfo($account_id, $name, $type, $message, $content_id = null, $content_name = null, $content_type = null, $parent_id = null, $parent_type = null, $app_key = null, $grouping_id = null, $connection_group_ids = null, $connection_account_ids = null, $audience_id = null, $audience_ids = null, $album_ids = null, $report_id = null, $report_params = null, $endpoint_url = null, $payload = null, $scheduled_date = null, $start_date = null, $end_date = null, $cron_expression = null, $cron_type = null, $meta_data = null, $conditional_input = null, $template_type = null, $visibility = null, $active = null, $send_now = null, $event_type = 'CUSTOM', $deep_link_uri = null, $send_to_all = null, string $contentType = self::contentTypes['createScheduledNotification'][0])
    {
        $request = $this->createScheduledNotificationRequest($account_id, $name, $type, $message, $content_id, $content_name, $content_type, $parent_id, $parent_type, $app_key, $grouping_id, $connection_group_ids, $connection_account_ids, $audience_id, $audience_ids, $album_ids, $report_id, $report_params, $endpoint_url, $payload, $scheduled_date, $start_date, $end_date, $cron_expression, $cron_type, $meta_data, $conditional_input, $template_type, $visibility, $active, $send_now, $event_type, $deep_link_uri, $send_to_all, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ScheduledNotificationFullResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\ScheduledNotificationFullResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ScheduledNotificationFullResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createScheduledNotificationAsync
     *
     * Create Scheduled Notification
     *
     * @param  int $account_id The logged in user. (required)
     * @param  string $name The name of the scheduled notification (required)
     * @param  string $type The type of scheduled notification. Supported values include: MOBILE_NOTIFICATION - sends push notifications via APNS and GCM EMAIL - sends email messages SMS - sends text messages (required)
     * @param  string $message The message to send (required)
     * @param  int|null $content_id The payload content ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param  string|null $content_name The payload content name that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param  string|null $content_type The payload content type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param  int|null $parent_id The payload parent ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param  string|null $parent_type The payload parent type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param  string|null $app_key The application that the notifications will send to. If connectionGroupIds, connectionAccountIds, and audienceIds is not set, this will send to all users who have used the application. This parameter is also required when sending push notifications via the MOBILE_NOTIFICATION type. (optional)
     * @param  string|null $grouping_id Client defined identifier for grouping multiple scheduled notifications. This can be used with the search endpoint to return scheduled notifications with the same groupingId for display purposes. Only results that have been created by the user will be returned when using this feature. (optional)
     * @param  string|null $connection_group_ids The connection groups to use to generate the list of recipients (comma separated list of connection group IDs) (optional)
     * @param  string|null $connection_account_ids The connection accounts to use to generate the list of recipients (comma separated list of user account ids) (optional)
     * @param  int|null $audience_id This parameter is deprecated. The audience used to generate the list of recipients (optional)
     * @param  string|null $audience_ids The audiences used to generate the list of recipients (comma separated list of audience IDs) (optional)
     * @param  string|null $album_ids The album ids to associate with the scheduled notification (comma separated list of album IDs) (optional)
     * @param  int|null $report_id The report used to generate the the list of recipients (optional)
     * @param  string|null $report_params The parameters to supply to the report used to generate the the list of recipients (optional)
     * @param  string|null $endpoint_url The URL for making an HTTP call (optional)
     * @param  string|null $payload The parameters for making an HTTP call (optional)
     * @param  int|null $scheduled_date The next time when the scheduled notification should begin processing (time in milliseconds). If this is left empty, then the startDate will be used. (optional)
     * @param  int|null $start_date The start time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to be available now. (optional)
     * @param  int|null $end_date The end time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to not have an expiration date. (optional)
     * @param  string|null $cron_expression The cron expression that represents the processing schedule. This uses the unix cron expression format. For example: 0 0 * * * will run once a day at midnight UTC. (optional)
     * @param  string|null $cron_type The cron expression type: UNIX, CRON4J, QUARTZ (optional)
     * @param  string|null $meta_data Additional metadata for the scheduled notification (optional)
     * @param  string|null $conditional_input Json input representing conditional logic that has to be met before running the scheduled notification (optional)
     * @param  string|null $template_type This determines if the Scheduled Notification is a template which is used as a basis for dynamically generating re-occurring Scheduled Notifications. The available types include: REPORTING - saves an adhoc report to be able to run again at another time GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business owner) GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business employee, retailer location, etc) GEOFENCE_TRIGGER - template for sending notifications to the account that triggered the geofence/audience (i.e. the customer) GEOFENCE_HTTP_CALL - template for making http calls when the geofences are triggered (optional)
     * @param  string|null $visibility Determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited) (optional)
     * @param  bool|null $active Sets whether the Scheduled Notification is active or not (inactive Scheduled Notifications are not processed). This is a quick way to toggle on or off without altering its schedule. The default value is &#39;true&#39;. (optional)
     * @param  bool|null $send_now  (optional)
     * @param  string|null $event_type Sets the event type for the notification (optional, default to 'CUSTOM')
     * @param  string|null $deep_link_uri The payload deep link URI that can be used by the client app to direct users to a screen in the app (optional)
     * @param  bool|null $send_to_all Determines whether to send to all users of the app if set to true for push notifications (appKey is required) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createScheduledNotification'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createScheduledNotificationAsync($account_id, $name, $type, $message, $content_id = null, $content_name = null, $content_type = null, $parent_id = null, $parent_type = null, $app_key = null, $grouping_id = null, $connection_group_ids = null, $connection_account_ids = null, $audience_id = null, $audience_ids = null, $album_ids = null, $report_id = null, $report_params = null, $endpoint_url = null, $payload = null, $scheduled_date = null, $start_date = null, $end_date = null, $cron_expression = null, $cron_type = null, $meta_data = null, $conditional_input = null, $template_type = null, $visibility = null, $active = null, $send_now = null, $event_type = 'CUSTOM', $deep_link_uri = null, $send_to_all = null, string $contentType = self::contentTypes['createScheduledNotification'][0])
    {
        return $this->createScheduledNotificationAsyncWithHttpInfo($account_id, $name, $type, $message, $content_id, $content_name, $content_type, $parent_id, $parent_type, $app_key, $grouping_id, $connection_group_ids, $connection_account_ids, $audience_id, $audience_ids, $album_ids, $report_id, $report_params, $endpoint_url, $payload, $scheduled_date, $start_date, $end_date, $cron_expression, $cron_type, $meta_data, $conditional_input, $template_type, $visibility, $active, $send_now, $event_type, $deep_link_uri, $send_to_all, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createScheduledNotificationAsyncWithHttpInfo
     *
     * Create Scheduled Notification
     *
     * @param  int $account_id The logged in user. (required)
     * @param  string $name The name of the scheduled notification (required)
     * @param  string $type The type of scheduled notification. Supported values include: MOBILE_NOTIFICATION - sends push notifications via APNS and GCM EMAIL - sends email messages SMS - sends text messages (required)
     * @param  string $message The message to send (required)
     * @param  int|null $content_id The payload content ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param  string|null $content_name The payload content name that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param  string|null $content_type The payload content type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param  int|null $parent_id The payload parent ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param  string|null $parent_type The payload parent type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param  string|null $app_key The application that the notifications will send to. If connectionGroupIds, connectionAccountIds, and audienceIds is not set, this will send to all users who have used the application. This parameter is also required when sending push notifications via the MOBILE_NOTIFICATION type. (optional)
     * @param  string|null $grouping_id Client defined identifier for grouping multiple scheduled notifications. This can be used with the search endpoint to return scheduled notifications with the same groupingId for display purposes. Only results that have been created by the user will be returned when using this feature. (optional)
     * @param  string|null $connection_group_ids The connection groups to use to generate the list of recipients (comma separated list of connection group IDs) (optional)
     * @param  string|null $connection_account_ids The connection accounts to use to generate the list of recipients (comma separated list of user account ids) (optional)
     * @param  int|null $audience_id This parameter is deprecated. The audience used to generate the list of recipients (optional)
     * @param  string|null $audience_ids The audiences used to generate the list of recipients (comma separated list of audience IDs) (optional)
     * @param  string|null $album_ids The album ids to associate with the scheduled notification (comma separated list of album IDs) (optional)
     * @param  int|null $report_id The report used to generate the the list of recipients (optional)
     * @param  string|null $report_params The parameters to supply to the report used to generate the the list of recipients (optional)
     * @param  string|null $endpoint_url The URL for making an HTTP call (optional)
     * @param  string|null $payload The parameters for making an HTTP call (optional)
     * @param  int|null $scheduled_date The next time when the scheduled notification should begin processing (time in milliseconds). If this is left empty, then the startDate will be used. (optional)
     * @param  int|null $start_date The start time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to be available now. (optional)
     * @param  int|null $end_date The end time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to not have an expiration date. (optional)
     * @param  string|null $cron_expression The cron expression that represents the processing schedule. This uses the unix cron expression format. For example: 0 0 * * * will run once a day at midnight UTC. (optional)
     * @param  string|null $cron_type The cron expression type: UNIX, CRON4J, QUARTZ (optional)
     * @param  string|null $meta_data Additional metadata for the scheduled notification (optional)
     * @param  string|null $conditional_input Json input representing conditional logic that has to be met before running the scheduled notification (optional)
     * @param  string|null $template_type This determines if the Scheduled Notification is a template which is used as a basis for dynamically generating re-occurring Scheduled Notifications. The available types include: REPORTING - saves an adhoc report to be able to run again at another time GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business owner) GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business employee, retailer location, etc) GEOFENCE_TRIGGER - template for sending notifications to the account that triggered the geofence/audience (i.e. the customer) GEOFENCE_HTTP_CALL - template for making http calls when the geofences are triggered (optional)
     * @param  string|null $visibility Determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited) (optional)
     * @param  bool|null $active Sets whether the Scheduled Notification is active or not (inactive Scheduled Notifications are not processed). This is a quick way to toggle on or off without altering its schedule. The default value is &#39;true&#39;. (optional)
     * @param  bool|null $send_now  (optional)
     * @param  string|null $event_type Sets the event type for the notification (optional, default to 'CUSTOM')
     * @param  string|null $deep_link_uri The payload deep link URI that can be used by the client app to direct users to a screen in the app (optional)
     * @param  bool|null $send_to_all Determines whether to send to all users of the app if set to true for push notifications (appKey is required) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createScheduledNotification'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createScheduledNotificationAsyncWithHttpInfo($account_id, $name, $type, $message, $content_id = null, $content_name = null, $content_type = null, $parent_id = null, $parent_type = null, $app_key = null, $grouping_id = null, $connection_group_ids = null, $connection_account_ids = null, $audience_id = null, $audience_ids = null, $album_ids = null, $report_id = null, $report_params = null, $endpoint_url = null, $payload = null, $scheduled_date = null, $start_date = null, $end_date = null, $cron_expression = null, $cron_type = null, $meta_data = null, $conditional_input = null, $template_type = null, $visibility = null, $active = null, $send_now = null, $event_type = 'CUSTOM', $deep_link_uri = null, $send_to_all = null, string $contentType = self::contentTypes['createScheduledNotification'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ScheduledNotificationFullResponse';
        $request = $this->createScheduledNotificationRequest($account_id, $name, $type, $message, $content_id, $content_name, $content_type, $parent_id, $parent_type, $app_key, $grouping_id, $connection_group_ids, $connection_account_ids, $audience_id, $audience_ids, $album_ids, $report_id, $report_params, $endpoint_url, $payload, $scheduled_date, $start_date, $end_date, $cron_expression, $cron_type, $meta_data, $conditional_input, $template_type, $visibility, $active, $send_now, $event_type, $deep_link_uri, $send_to_all, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createScheduledNotification'
     *
     * @param  int $account_id The logged in user. (required)
     * @param  string $name The name of the scheduled notification (required)
     * @param  string $type The type of scheduled notification. Supported values include: MOBILE_NOTIFICATION - sends push notifications via APNS and GCM EMAIL - sends email messages SMS - sends text messages (required)
     * @param  string $message The message to send (required)
     * @param  int|null $content_id The payload content ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param  string|null $content_name The payload content name that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param  string|null $content_type The payload content type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param  int|null $parent_id The payload parent ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param  string|null $parent_type The payload parent type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param  string|null $app_key The application that the notifications will send to. If connectionGroupIds, connectionAccountIds, and audienceIds is not set, this will send to all users who have used the application. This parameter is also required when sending push notifications via the MOBILE_NOTIFICATION type. (optional)
     * @param  string|null $grouping_id Client defined identifier for grouping multiple scheduled notifications. This can be used with the search endpoint to return scheduled notifications with the same groupingId for display purposes. Only results that have been created by the user will be returned when using this feature. (optional)
     * @param  string|null $connection_group_ids The connection groups to use to generate the list of recipients (comma separated list of connection group IDs) (optional)
     * @param  string|null $connection_account_ids The connection accounts to use to generate the list of recipients (comma separated list of user account ids) (optional)
     * @param  int|null $audience_id This parameter is deprecated. The audience used to generate the list of recipients (optional)
     * @param  string|null $audience_ids The audiences used to generate the list of recipients (comma separated list of audience IDs) (optional)
     * @param  string|null $album_ids The album ids to associate with the scheduled notification (comma separated list of album IDs) (optional)
     * @param  int|null $report_id The report used to generate the the list of recipients (optional)
     * @param  string|null $report_params The parameters to supply to the report used to generate the the list of recipients (optional)
     * @param  string|null $endpoint_url The URL for making an HTTP call (optional)
     * @param  string|null $payload The parameters for making an HTTP call (optional)
     * @param  int|null $scheduled_date The next time when the scheduled notification should begin processing (time in milliseconds). If this is left empty, then the startDate will be used. (optional)
     * @param  int|null $start_date The start time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to be available now. (optional)
     * @param  int|null $end_date The end time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to not have an expiration date. (optional)
     * @param  string|null $cron_expression The cron expression that represents the processing schedule. This uses the unix cron expression format. For example: 0 0 * * * will run once a day at midnight UTC. (optional)
     * @param  string|null $cron_type The cron expression type: UNIX, CRON4J, QUARTZ (optional)
     * @param  string|null $meta_data Additional metadata for the scheduled notification (optional)
     * @param  string|null $conditional_input Json input representing conditional logic that has to be met before running the scheduled notification (optional)
     * @param  string|null $template_type This determines if the Scheduled Notification is a template which is used as a basis for dynamically generating re-occurring Scheduled Notifications. The available types include: REPORTING - saves an adhoc report to be able to run again at another time GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business owner) GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business employee, retailer location, etc) GEOFENCE_TRIGGER - template for sending notifications to the account that triggered the geofence/audience (i.e. the customer) GEOFENCE_HTTP_CALL - template for making http calls when the geofences are triggered (optional)
     * @param  string|null $visibility Determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited) (optional)
     * @param  bool|null $active Sets whether the Scheduled Notification is active or not (inactive Scheduled Notifications are not processed). This is a quick way to toggle on or off without altering its schedule. The default value is &#39;true&#39;. (optional)
     * @param  bool|null $send_now  (optional)
     * @param  string|null $event_type Sets the event type for the notification (optional, default to 'CUSTOM')
     * @param  string|null $deep_link_uri The payload deep link URI that can be used by the client app to direct users to a screen in the app (optional)
     * @param  bool|null $send_to_all Determines whether to send to all users of the app if set to true for push notifications (appKey is required) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createScheduledNotification'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createScheduledNotificationRequest($account_id, $name, $type, $message, $content_id = null, $content_name = null, $content_type = null, $parent_id = null, $parent_type = null, $app_key = null, $grouping_id = null, $connection_group_ids = null, $connection_account_ids = null, $audience_id = null, $audience_ids = null, $album_ids = null, $report_id = null, $report_params = null, $endpoint_url = null, $payload = null, $scheduled_date = null, $start_date = null, $end_date = null, $cron_expression = null, $cron_type = null, $meta_data = null, $conditional_input = null, $template_type = null, $visibility = null, $active = null, $send_now = null, $event_type = 'CUSTOM', $deep_link_uri = null, $send_to_all = null, string $contentType = self::contentTypes['createScheduledNotification'][0])
    {

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling createScheduledNotification'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling createScheduledNotification'
            );
        }

        // verify the required parameter 'type' is set
        if ($type === null || (is_array($type) && count($type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type when calling createScheduledNotification'
            );
        }

        // verify the required parameter 'message' is set
        if ($message === null || (is_array($message) && count($message) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $message when calling createScheduledNotification'
            );
        }
































        $resourcePath = '/notification/schedule/create';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type,
            'type', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $message,
            'message', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $content_id,
            'contentId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $content_name,
            'contentName', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $content_type,
            'contentType', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $parent_id,
            'parentId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $parent_type,
            'parentType', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $app_key,
            'appKey', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $grouping_id,
            'groupingId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $connection_group_ids,
            'connectionGroupIds', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $connection_account_ids,
            'connectionAccountIds', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audience_id,
            'audienceId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audience_ids,
            'audienceIds', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $album_ids,
            'albumIds', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $report_id,
            'reportId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $report_params,
            'reportParams', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $endpoint_url,
            'endpointURL', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $payload,
            'payload', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $scheduled_date,
            'scheduledDate', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'startDate', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'endDate', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cron_expression,
            'cronExpression', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cron_type,
            'cronType', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $meta_data,
            'metaData', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $conditional_input,
            'conditionalInput', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $template_type,
            'templateType', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $visibility,
            'visibility', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $active,
            'active', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $send_now,
            'sendNow', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $event_type,
            'eventType', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $deep_link_uri,
            'deepLinkURI', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $send_to_all,
            'sendToAll', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteScheduledNotification
     *
     * Delete Scheduled Notification
     *
     * @param  int $account_id the id of the logged in user (required)
     * @param  int $scheduled_notification_id the id of the scheduled notification to delete (required)
     * @param  bool|null $delete_by_grouping_id If set to true, also deletes Scheduled Notifications under the same account with the same groupingId. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteScheduledNotification'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ScheduledNotificationFullResponse
     */
    public function deleteScheduledNotification($account_id, $scheduled_notification_id, $delete_by_grouping_id = null, string $contentType = self::contentTypes['deleteScheduledNotification'][0])
    {
        list($response) = $this->deleteScheduledNotificationWithHttpInfo($account_id, $scheduled_notification_id, $delete_by_grouping_id, $contentType);
        return $response;
    }

    /**
     * Operation deleteScheduledNotificationWithHttpInfo
     *
     * Delete Scheduled Notification
     *
     * @param  int $account_id the id of the logged in user (required)
     * @param  int $scheduled_notification_id the id of the scheduled notification to delete (required)
     * @param  bool|null $delete_by_grouping_id If set to true, also deletes Scheduled Notifications under the same account with the same groupingId. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteScheduledNotification'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ScheduledNotificationFullResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteScheduledNotificationWithHttpInfo($account_id, $scheduled_notification_id, $delete_by_grouping_id = null, string $contentType = self::contentTypes['deleteScheduledNotification'][0])
    {
        $request = $this->deleteScheduledNotificationRequest($account_id, $scheduled_notification_id, $delete_by_grouping_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ScheduledNotificationFullResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\ScheduledNotificationFullResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ScheduledNotificationFullResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteScheduledNotificationAsync
     *
     * Delete Scheduled Notification
     *
     * @param  int $account_id the id of the logged in user (required)
     * @param  int $scheduled_notification_id the id of the scheduled notification to delete (required)
     * @param  bool|null $delete_by_grouping_id If set to true, also deletes Scheduled Notifications under the same account with the same groupingId. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteScheduledNotification'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteScheduledNotificationAsync($account_id, $scheduled_notification_id, $delete_by_grouping_id = null, string $contentType = self::contentTypes['deleteScheduledNotification'][0])
    {
        return $this->deleteScheduledNotificationAsyncWithHttpInfo($account_id, $scheduled_notification_id, $delete_by_grouping_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteScheduledNotificationAsyncWithHttpInfo
     *
     * Delete Scheduled Notification
     *
     * @param  int $account_id the id of the logged in user (required)
     * @param  int $scheduled_notification_id the id of the scheduled notification to delete (required)
     * @param  bool|null $delete_by_grouping_id If set to true, also deletes Scheduled Notifications under the same account with the same groupingId. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteScheduledNotification'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteScheduledNotificationAsyncWithHttpInfo($account_id, $scheduled_notification_id, $delete_by_grouping_id = null, string $contentType = self::contentTypes['deleteScheduledNotification'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ScheduledNotificationFullResponse';
        $request = $this->deleteScheduledNotificationRequest($account_id, $scheduled_notification_id, $delete_by_grouping_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteScheduledNotification'
     *
     * @param  int $account_id the id of the logged in user (required)
     * @param  int $scheduled_notification_id the id of the scheduled notification to delete (required)
     * @param  bool|null $delete_by_grouping_id If set to true, also deletes Scheduled Notifications under the same account with the same groupingId. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteScheduledNotification'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteScheduledNotificationRequest($account_id, $scheduled_notification_id, $delete_by_grouping_id = null, string $contentType = self::contentTypes['deleteScheduledNotification'][0])
    {

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling deleteScheduledNotification'
            );
        }

        // verify the required parameter 'scheduled_notification_id' is set
        if ($scheduled_notification_id === null || (is_array($scheduled_notification_id) && count($scheduled_notification_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $scheduled_notification_id when calling deleteScheduledNotification'
            );
        }



        $resourcePath = '/notification/schedule/delete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $scheduled_notification_id,
            'scheduledNotificationId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $delete_by_grouping_id,
            'deleteByGroupingId', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getScheduledNotification
     *
     * Get Scheduled Notification
     *
     * @param  int $account_id the id of the account logged in (required)
     * @param  int $scheduled_notification_id the id of the scheduled notification to get (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getScheduledNotification'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ScheduledNotificationFullResponse
     */
    public function getScheduledNotification($account_id, $scheduled_notification_id, string $contentType = self::contentTypes['getScheduledNotification'][0])
    {
        list($response) = $this->getScheduledNotificationWithHttpInfo($account_id, $scheduled_notification_id, $contentType);
        return $response;
    }

    /**
     * Operation getScheduledNotificationWithHttpInfo
     *
     * Get Scheduled Notification
     *
     * @param  int $account_id the id of the account logged in (required)
     * @param  int $scheduled_notification_id the id of the scheduled notification to get (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getScheduledNotification'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ScheduledNotificationFullResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getScheduledNotificationWithHttpInfo($account_id, $scheduled_notification_id, string $contentType = self::contentTypes['getScheduledNotification'][0])
    {
        $request = $this->getScheduledNotificationRequest($account_id, $scheduled_notification_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ScheduledNotificationFullResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\ScheduledNotificationFullResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ScheduledNotificationFullResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getScheduledNotificationAsync
     *
     * Get Scheduled Notification
     *
     * @param  int $account_id the id of the account logged in (required)
     * @param  int $scheduled_notification_id the id of the scheduled notification to get (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getScheduledNotification'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getScheduledNotificationAsync($account_id, $scheduled_notification_id, string $contentType = self::contentTypes['getScheduledNotification'][0])
    {
        return $this->getScheduledNotificationAsyncWithHttpInfo($account_id, $scheduled_notification_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getScheduledNotificationAsyncWithHttpInfo
     *
     * Get Scheduled Notification
     *
     * @param  int $account_id the id of the account logged in (required)
     * @param  int $scheduled_notification_id the id of the scheduled notification to get (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getScheduledNotification'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getScheduledNotificationAsyncWithHttpInfo($account_id, $scheduled_notification_id, string $contentType = self::contentTypes['getScheduledNotification'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ScheduledNotificationFullResponse';
        $request = $this->getScheduledNotificationRequest($account_id, $scheduled_notification_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getScheduledNotification'
     *
     * @param  int $account_id the id of the account logged in (required)
     * @param  int $scheduled_notification_id the id of the scheduled notification to get (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getScheduledNotification'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getScheduledNotificationRequest($account_id, $scheduled_notification_id, string $contentType = self::contentTypes['getScheduledNotification'][0])
    {

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling getScheduledNotification'
            );
        }

        // verify the required parameter 'scheduled_notification_id' is set
        if ($scheduled_notification_id === null || (is_array($scheduled_notification_id) && count($scheduled_notification_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $scheduled_notification_id when calling getScheduledNotification'
            );
        }


        $resourcePath = '/notification/schedule/get';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $scheduled_notification_id,
            'scheduledNotificationId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation scheduleNotificationListings
     *
     * Generate Schedule Notifications
     *
     * @param  int $account_id The logged in user. (required)
     * @param  string $app_key The application to target (required)
     * @param  string $report_name The name of the report used to identify events. The report must return columns named: id, name, date, params, and type otherwise it will fail (required)
     * @param  string $message The message to be sent to the recipients. If you set %name% the report row name value will be swapped in. If you set %time% or %date% the report row start date/time value will be swapped in (required)
     * @param  int $offset Time in munites before the event starts to notify recipients (required)
     * @param  int $recipient_report_id The report id used to generate the recipient list (required)
     * @param  string|null $report_params The parameters of the report used to identify events in a json structure, example: &#x60;&#x60;&#x60;json {   \&quot;string\&quot;: \&quot;value\&quot;,   \&quot;number\&quot;: 3.345,   \&quot;date\&quot;: \&quot;2014-05-01 00:00:00\&quot; } &#x60;&#x60;&#x60; (optional)
     * @param  string|null $type The type of scheduled notification; supported values are: MOBILE_NOTIFICATION (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['scheduleNotificationListings'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SirqulResponse
     */
    public function scheduleNotificationListings($account_id, $app_key, $report_name, $message, $offset, $recipient_report_id, $report_params = null, $type = null, string $contentType = self::contentTypes['scheduleNotificationListings'][0])
    {
        list($response) = $this->scheduleNotificationListingsWithHttpInfo($account_id, $app_key, $report_name, $message, $offset, $recipient_report_id, $report_params, $type, $contentType);
        return $response;
    }

    /**
     * Operation scheduleNotificationListingsWithHttpInfo
     *
     * Generate Schedule Notifications
     *
     * @param  int $account_id The logged in user. (required)
     * @param  string $app_key The application to target (required)
     * @param  string $report_name The name of the report used to identify events. The report must return columns named: id, name, date, params, and type otherwise it will fail (required)
     * @param  string $message The message to be sent to the recipients. If you set %name% the report row name value will be swapped in. If you set %time% or %date% the report row start date/time value will be swapped in (required)
     * @param  int $offset Time in munites before the event starts to notify recipients (required)
     * @param  int $recipient_report_id The report id used to generate the recipient list (required)
     * @param  string|null $report_params The parameters of the report used to identify events in a json structure, example: &#x60;&#x60;&#x60;json {   \&quot;string\&quot;: \&quot;value\&quot;,   \&quot;number\&quot;: 3.345,   \&quot;date\&quot;: \&quot;2014-05-01 00:00:00\&quot; } &#x60;&#x60;&#x60; (optional)
     * @param  string|null $type The type of scheduled notification; supported values are: MOBILE_NOTIFICATION (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['scheduleNotificationListings'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SirqulResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function scheduleNotificationListingsWithHttpInfo($account_id, $app_key, $report_name, $message, $offset, $recipient_report_id, $report_params = null, $type = null, string $contentType = self::contentTypes['scheduleNotificationListings'][0])
    {
        $request = $this->scheduleNotificationListingsRequest($account_id, $app_key, $report_name, $message, $offset, $recipient_report_id, $report_params, $type, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\SirqulResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\SirqulResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SirqulResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation scheduleNotificationListingsAsync
     *
     * Generate Schedule Notifications
     *
     * @param  int $account_id The logged in user. (required)
     * @param  string $app_key The application to target (required)
     * @param  string $report_name The name of the report used to identify events. The report must return columns named: id, name, date, params, and type otherwise it will fail (required)
     * @param  string $message The message to be sent to the recipients. If you set %name% the report row name value will be swapped in. If you set %time% or %date% the report row start date/time value will be swapped in (required)
     * @param  int $offset Time in munites before the event starts to notify recipients (required)
     * @param  int $recipient_report_id The report id used to generate the recipient list (required)
     * @param  string|null $report_params The parameters of the report used to identify events in a json structure, example: &#x60;&#x60;&#x60;json {   \&quot;string\&quot;: \&quot;value\&quot;,   \&quot;number\&quot;: 3.345,   \&quot;date\&quot;: \&quot;2014-05-01 00:00:00\&quot; } &#x60;&#x60;&#x60; (optional)
     * @param  string|null $type The type of scheduled notification; supported values are: MOBILE_NOTIFICATION (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['scheduleNotificationListings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function scheduleNotificationListingsAsync($account_id, $app_key, $report_name, $message, $offset, $recipient_report_id, $report_params = null, $type = null, string $contentType = self::contentTypes['scheduleNotificationListings'][0])
    {
        return $this->scheduleNotificationListingsAsyncWithHttpInfo($account_id, $app_key, $report_name, $message, $offset, $recipient_report_id, $report_params, $type, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation scheduleNotificationListingsAsyncWithHttpInfo
     *
     * Generate Schedule Notifications
     *
     * @param  int $account_id The logged in user. (required)
     * @param  string $app_key The application to target (required)
     * @param  string $report_name The name of the report used to identify events. The report must return columns named: id, name, date, params, and type otherwise it will fail (required)
     * @param  string $message The message to be sent to the recipients. If you set %name% the report row name value will be swapped in. If you set %time% or %date% the report row start date/time value will be swapped in (required)
     * @param  int $offset Time in munites before the event starts to notify recipients (required)
     * @param  int $recipient_report_id The report id used to generate the recipient list (required)
     * @param  string|null $report_params The parameters of the report used to identify events in a json structure, example: &#x60;&#x60;&#x60;json {   \&quot;string\&quot;: \&quot;value\&quot;,   \&quot;number\&quot;: 3.345,   \&quot;date\&quot;: \&quot;2014-05-01 00:00:00\&quot; } &#x60;&#x60;&#x60; (optional)
     * @param  string|null $type The type of scheduled notification; supported values are: MOBILE_NOTIFICATION (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['scheduleNotificationListings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function scheduleNotificationListingsAsyncWithHttpInfo($account_id, $app_key, $report_name, $message, $offset, $recipient_report_id, $report_params = null, $type = null, string $contentType = self::contentTypes['scheduleNotificationListings'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SirqulResponse';
        $request = $this->scheduleNotificationListingsRequest($account_id, $app_key, $report_name, $message, $offset, $recipient_report_id, $report_params, $type, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'scheduleNotificationListings'
     *
     * @param  int $account_id The logged in user. (required)
     * @param  string $app_key The application to target (required)
     * @param  string $report_name The name of the report used to identify events. The report must return columns named: id, name, date, params, and type otherwise it will fail (required)
     * @param  string $message The message to be sent to the recipients. If you set %name% the report row name value will be swapped in. If you set %time% or %date% the report row start date/time value will be swapped in (required)
     * @param  int $offset Time in munites before the event starts to notify recipients (required)
     * @param  int $recipient_report_id The report id used to generate the recipient list (required)
     * @param  string|null $report_params The parameters of the report used to identify events in a json structure, example: &#x60;&#x60;&#x60;json {   \&quot;string\&quot;: \&quot;value\&quot;,   \&quot;number\&quot;: 3.345,   \&quot;date\&quot;: \&quot;2014-05-01 00:00:00\&quot; } &#x60;&#x60;&#x60; (optional)
     * @param  string|null $type The type of scheduled notification; supported values are: MOBILE_NOTIFICATION (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['scheduleNotificationListings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function scheduleNotificationListingsRequest($account_id, $app_key, $report_name, $message, $offset, $recipient_report_id, $report_params = null, $type = null, string $contentType = self::contentTypes['scheduleNotificationListings'][0])
    {

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling scheduleNotificationListings'
            );
        }

        // verify the required parameter 'app_key' is set
        if ($app_key === null || (is_array($app_key) && count($app_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_key when calling scheduleNotificationListings'
            );
        }

        // verify the required parameter 'report_name' is set
        if ($report_name === null || (is_array($report_name) && count($report_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $report_name when calling scheduleNotificationListings'
            );
        }

        // verify the required parameter 'message' is set
        if ($message === null || (is_array($message) && count($message) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $message when calling scheduleNotificationListings'
            );
        }

        // verify the required parameter 'offset' is set
        if ($offset === null || (is_array($offset) && count($offset) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $offset when calling scheduleNotificationListings'
            );
        }

        // verify the required parameter 'recipient_report_id' is set
        if ($recipient_report_id === null || (is_array($recipient_report_id) && count($recipient_report_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $recipient_report_id when calling scheduleNotificationListings'
            );
        }




        $resourcePath = '/notification/schedule/generate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $app_key,
            'appKey', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $report_name,
            'reportName', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $report_params,
            'reportParams', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $message,
            'message', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type,
            'type', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recipient_report_id,
            'recipientReportId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchScheduledNotifications
     *
     * Search Scheduled Notifications
     *
     * @param  int $account_id The logged in user. (required)
     * @param  string|null $grouping_id Filter results by a grouping identifier defined by the client (optional)
     * @param  int|null $audience_id Filter results by audience (optional)
     * @param  string|null $filter a comma separated list of filters: MINE - Return scheduled notifications that the user has created. SHARED - Return scheduled notifications that have been shared to the user via addUsersToPermissionable. FOLLOWER - Return scheduled notifications that have been created by the users followers (the content needs to have been APPROVED or FEATURED). FOLLOWING - Return scheduled notifications that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED). PUBLIC - Return all PUBLIC scheduled notifications that have been APPROVED or FEATURED. ALL_PUBLIC - Return all PUBLIC scheduled notifications regardless of whether they are approved or not (ignores the approval status). LIKED - Return all scheduled notifications that the user has liked. FEATURED - Return all scheduled notifications that have been featured. PENDING - Return all pending scheduled notifications. (optional)
     * @param  string|null $types Filter results by notification types (comma separated list). Values include: HTTP, EMAIL, SMS, MOBILE_NOTIFICATION (optional)
     * @param  string|null $content_ids search using content IDs (optional)
     * @param  string|null $content_types search using content types (optional)
     * @param  string|null $parent_ids search using parent IDs (optional)
     * @param  string|null $parent_types search using parent types (optional)
     * @param  string|null $statuses Filter results by status (comma separated list). Possible values include: NEW - scheduled to run ERROR - encountered an error during processing COMPLETE - processing has completed and it is no longer scheduled to run PROCESSING - currently processing/sending (optional)
     * @param  string|null $template_types  (optional)
     * @param  string|null $app_key Filter the list by a specific application (optional)
     * @param  string|null $keyword Keyword search on the scheduled notification names. (optional)
     * @param  string|null $sort_field The field to sort by. Possible values include: ID - order by the scheduledNotificationId CREATED - order by the timestamp it was created UPDATED - order by the timestamp it was last updated ACTIVE - order by whether it is active or inactive NAME - order by the scheduled notification name SCHEDULED_DATE - order by the next scheduled date START_DATE - order by the start date END_DATE - order by the end date (optional)
     * @param  bool|null $descending Determines whether the sorted list is in descending or ascending order (optional)
     * @param  int|null $start Start the result set at some index. (optional)
     * @param  int|null $limit Limit the result to some number. (optional)
     * @param  bool|null $active_only Determines whether to return only active results (optional)
     * @param  bool|null $group_by_grouping_id Determines whether to group results with the same groupingId together. (optional)
     * @param  bool|null $return_audience_account_count If true, include audience account counts in the response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchScheduledNotifications'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ScheduledNotificationFullResponse
     */
    public function searchScheduledNotifications($account_id, $grouping_id = null, $audience_id = null, $filter = null, $types = null, $content_ids = null, $content_types = null, $parent_ids = null, $parent_types = null, $statuses = null, $template_types = null, $app_key = null, $keyword = null, $sort_field = null, $descending = null, $start = null, $limit = null, $active_only = null, $group_by_grouping_id = null, $return_audience_account_count = null, string $contentType = self::contentTypes['searchScheduledNotifications'][0])
    {
        list($response) = $this->searchScheduledNotificationsWithHttpInfo($account_id, $grouping_id, $audience_id, $filter, $types, $content_ids, $content_types, $parent_ids, $parent_types, $statuses, $template_types, $app_key, $keyword, $sort_field, $descending, $start, $limit, $active_only, $group_by_grouping_id, $return_audience_account_count, $contentType);
        return $response;
    }

    /**
     * Operation searchScheduledNotificationsWithHttpInfo
     *
     * Search Scheduled Notifications
     *
     * @param  int $account_id The logged in user. (required)
     * @param  string|null $grouping_id Filter results by a grouping identifier defined by the client (optional)
     * @param  int|null $audience_id Filter results by audience (optional)
     * @param  string|null $filter a comma separated list of filters: MINE - Return scheduled notifications that the user has created. SHARED - Return scheduled notifications that have been shared to the user via addUsersToPermissionable. FOLLOWER - Return scheduled notifications that have been created by the users followers (the content needs to have been APPROVED or FEATURED). FOLLOWING - Return scheduled notifications that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED). PUBLIC - Return all PUBLIC scheduled notifications that have been APPROVED or FEATURED. ALL_PUBLIC - Return all PUBLIC scheduled notifications regardless of whether they are approved or not (ignores the approval status). LIKED - Return all scheduled notifications that the user has liked. FEATURED - Return all scheduled notifications that have been featured. PENDING - Return all pending scheduled notifications. (optional)
     * @param  string|null $types Filter results by notification types (comma separated list). Values include: HTTP, EMAIL, SMS, MOBILE_NOTIFICATION (optional)
     * @param  string|null $content_ids search using content IDs (optional)
     * @param  string|null $content_types search using content types (optional)
     * @param  string|null $parent_ids search using parent IDs (optional)
     * @param  string|null $parent_types search using parent types (optional)
     * @param  string|null $statuses Filter results by status (comma separated list). Possible values include: NEW - scheduled to run ERROR - encountered an error during processing COMPLETE - processing has completed and it is no longer scheduled to run PROCESSING - currently processing/sending (optional)
     * @param  string|null $template_types  (optional)
     * @param  string|null $app_key Filter the list by a specific application (optional)
     * @param  string|null $keyword Keyword search on the scheduled notification names. (optional)
     * @param  string|null $sort_field The field to sort by. Possible values include: ID - order by the scheduledNotificationId CREATED - order by the timestamp it was created UPDATED - order by the timestamp it was last updated ACTIVE - order by whether it is active or inactive NAME - order by the scheduled notification name SCHEDULED_DATE - order by the next scheduled date START_DATE - order by the start date END_DATE - order by the end date (optional)
     * @param  bool|null $descending Determines whether the sorted list is in descending or ascending order (optional)
     * @param  int|null $start Start the result set at some index. (optional)
     * @param  int|null $limit Limit the result to some number. (optional)
     * @param  bool|null $active_only Determines whether to return only active results (optional)
     * @param  bool|null $group_by_grouping_id Determines whether to group results with the same groupingId together. (optional)
     * @param  bool|null $return_audience_account_count If true, include audience account counts in the response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchScheduledNotifications'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ScheduledNotificationFullResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchScheduledNotificationsWithHttpInfo($account_id, $grouping_id = null, $audience_id = null, $filter = null, $types = null, $content_ids = null, $content_types = null, $parent_ids = null, $parent_types = null, $statuses = null, $template_types = null, $app_key = null, $keyword = null, $sort_field = null, $descending = null, $start = null, $limit = null, $active_only = null, $group_by_grouping_id = null, $return_audience_account_count = null, string $contentType = self::contentTypes['searchScheduledNotifications'][0])
    {
        $request = $this->searchScheduledNotificationsRequest($account_id, $grouping_id, $audience_id, $filter, $types, $content_ids, $content_types, $parent_ids, $parent_types, $statuses, $template_types, $app_key, $keyword, $sort_field, $descending, $start, $limit, $active_only, $group_by_grouping_id, $return_audience_account_count, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ScheduledNotificationFullResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\ScheduledNotificationFullResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ScheduledNotificationFullResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation searchScheduledNotificationsAsync
     *
     * Search Scheduled Notifications
     *
     * @param  int $account_id The logged in user. (required)
     * @param  string|null $grouping_id Filter results by a grouping identifier defined by the client (optional)
     * @param  int|null $audience_id Filter results by audience (optional)
     * @param  string|null $filter a comma separated list of filters: MINE - Return scheduled notifications that the user has created. SHARED - Return scheduled notifications that have been shared to the user via addUsersToPermissionable. FOLLOWER - Return scheduled notifications that have been created by the users followers (the content needs to have been APPROVED or FEATURED). FOLLOWING - Return scheduled notifications that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED). PUBLIC - Return all PUBLIC scheduled notifications that have been APPROVED or FEATURED. ALL_PUBLIC - Return all PUBLIC scheduled notifications regardless of whether they are approved or not (ignores the approval status). LIKED - Return all scheduled notifications that the user has liked. FEATURED - Return all scheduled notifications that have been featured. PENDING - Return all pending scheduled notifications. (optional)
     * @param  string|null $types Filter results by notification types (comma separated list). Values include: HTTP, EMAIL, SMS, MOBILE_NOTIFICATION (optional)
     * @param  string|null $content_ids search using content IDs (optional)
     * @param  string|null $content_types search using content types (optional)
     * @param  string|null $parent_ids search using parent IDs (optional)
     * @param  string|null $parent_types search using parent types (optional)
     * @param  string|null $statuses Filter results by status (comma separated list). Possible values include: NEW - scheduled to run ERROR - encountered an error during processing COMPLETE - processing has completed and it is no longer scheduled to run PROCESSING - currently processing/sending (optional)
     * @param  string|null $template_types  (optional)
     * @param  string|null $app_key Filter the list by a specific application (optional)
     * @param  string|null $keyword Keyword search on the scheduled notification names. (optional)
     * @param  string|null $sort_field The field to sort by. Possible values include: ID - order by the scheduledNotificationId CREATED - order by the timestamp it was created UPDATED - order by the timestamp it was last updated ACTIVE - order by whether it is active or inactive NAME - order by the scheduled notification name SCHEDULED_DATE - order by the next scheduled date START_DATE - order by the start date END_DATE - order by the end date (optional)
     * @param  bool|null $descending Determines whether the sorted list is in descending or ascending order (optional)
     * @param  int|null $start Start the result set at some index. (optional)
     * @param  int|null $limit Limit the result to some number. (optional)
     * @param  bool|null $active_only Determines whether to return only active results (optional)
     * @param  bool|null $group_by_grouping_id Determines whether to group results with the same groupingId together. (optional)
     * @param  bool|null $return_audience_account_count If true, include audience account counts in the response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchScheduledNotifications'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchScheduledNotificationsAsync($account_id, $grouping_id = null, $audience_id = null, $filter = null, $types = null, $content_ids = null, $content_types = null, $parent_ids = null, $parent_types = null, $statuses = null, $template_types = null, $app_key = null, $keyword = null, $sort_field = null, $descending = null, $start = null, $limit = null, $active_only = null, $group_by_grouping_id = null, $return_audience_account_count = null, string $contentType = self::contentTypes['searchScheduledNotifications'][0])
    {
        return $this->searchScheduledNotificationsAsyncWithHttpInfo($account_id, $grouping_id, $audience_id, $filter, $types, $content_ids, $content_types, $parent_ids, $parent_types, $statuses, $template_types, $app_key, $keyword, $sort_field, $descending, $start, $limit, $active_only, $group_by_grouping_id, $return_audience_account_count, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchScheduledNotificationsAsyncWithHttpInfo
     *
     * Search Scheduled Notifications
     *
     * @param  int $account_id The logged in user. (required)
     * @param  string|null $grouping_id Filter results by a grouping identifier defined by the client (optional)
     * @param  int|null $audience_id Filter results by audience (optional)
     * @param  string|null $filter a comma separated list of filters: MINE - Return scheduled notifications that the user has created. SHARED - Return scheduled notifications that have been shared to the user via addUsersToPermissionable. FOLLOWER - Return scheduled notifications that have been created by the users followers (the content needs to have been APPROVED or FEATURED). FOLLOWING - Return scheduled notifications that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED). PUBLIC - Return all PUBLIC scheduled notifications that have been APPROVED or FEATURED. ALL_PUBLIC - Return all PUBLIC scheduled notifications regardless of whether they are approved or not (ignores the approval status). LIKED - Return all scheduled notifications that the user has liked. FEATURED - Return all scheduled notifications that have been featured. PENDING - Return all pending scheduled notifications. (optional)
     * @param  string|null $types Filter results by notification types (comma separated list). Values include: HTTP, EMAIL, SMS, MOBILE_NOTIFICATION (optional)
     * @param  string|null $content_ids search using content IDs (optional)
     * @param  string|null $content_types search using content types (optional)
     * @param  string|null $parent_ids search using parent IDs (optional)
     * @param  string|null $parent_types search using parent types (optional)
     * @param  string|null $statuses Filter results by status (comma separated list). Possible values include: NEW - scheduled to run ERROR - encountered an error during processing COMPLETE - processing has completed and it is no longer scheduled to run PROCESSING - currently processing/sending (optional)
     * @param  string|null $template_types  (optional)
     * @param  string|null $app_key Filter the list by a specific application (optional)
     * @param  string|null $keyword Keyword search on the scheduled notification names. (optional)
     * @param  string|null $sort_field The field to sort by. Possible values include: ID - order by the scheduledNotificationId CREATED - order by the timestamp it was created UPDATED - order by the timestamp it was last updated ACTIVE - order by whether it is active or inactive NAME - order by the scheduled notification name SCHEDULED_DATE - order by the next scheduled date START_DATE - order by the start date END_DATE - order by the end date (optional)
     * @param  bool|null $descending Determines whether the sorted list is in descending or ascending order (optional)
     * @param  int|null $start Start the result set at some index. (optional)
     * @param  int|null $limit Limit the result to some number. (optional)
     * @param  bool|null $active_only Determines whether to return only active results (optional)
     * @param  bool|null $group_by_grouping_id Determines whether to group results with the same groupingId together. (optional)
     * @param  bool|null $return_audience_account_count If true, include audience account counts in the response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchScheduledNotifications'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchScheduledNotificationsAsyncWithHttpInfo($account_id, $grouping_id = null, $audience_id = null, $filter = null, $types = null, $content_ids = null, $content_types = null, $parent_ids = null, $parent_types = null, $statuses = null, $template_types = null, $app_key = null, $keyword = null, $sort_field = null, $descending = null, $start = null, $limit = null, $active_only = null, $group_by_grouping_id = null, $return_audience_account_count = null, string $contentType = self::contentTypes['searchScheduledNotifications'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ScheduledNotificationFullResponse';
        $request = $this->searchScheduledNotificationsRequest($account_id, $grouping_id, $audience_id, $filter, $types, $content_ids, $content_types, $parent_ids, $parent_types, $statuses, $template_types, $app_key, $keyword, $sort_field, $descending, $start, $limit, $active_only, $group_by_grouping_id, $return_audience_account_count, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchScheduledNotifications'
     *
     * @param  int $account_id The logged in user. (required)
     * @param  string|null $grouping_id Filter results by a grouping identifier defined by the client (optional)
     * @param  int|null $audience_id Filter results by audience (optional)
     * @param  string|null $filter a comma separated list of filters: MINE - Return scheduled notifications that the user has created. SHARED - Return scheduled notifications that have been shared to the user via addUsersToPermissionable. FOLLOWER - Return scheduled notifications that have been created by the users followers (the content needs to have been APPROVED or FEATURED). FOLLOWING - Return scheduled notifications that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED). PUBLIC - Return all PUBLIC scheduled notifications that have been APPROVED or FEATURED. ALL_PUBLIC - Return all PUBLIC scheduled notifications regardless of whether they are approved or not (ignores the approval status). LIKED - Return all scheduled notifications that the user has liked. FEATURED - Return all scheduled notifications that have been featured. PENDING - Return all pending scheduled notifications. (optional)
     * @param  string|null $types Filter results by notification types (comma separated list). Values include: HTTP, EMAIL, SMS, MOBILE_NOTIFICATION (optional)
     * @param  string|null $content_ids search using content IDs (optional)
     * @param  string|null $content_types search using content types (optional)
     * @param  string|null $parent_ids search using parent IDs (optional)
     * @param  string|null $parent_types search using parent types (optional)
     * @param  string|null $statuses Filter results by status (comma separated list). Possible values include: NEW - scheduled to run ERROR - encountered an error during processing COMPLETE - processing has completed and it is no longer scheduled to run PROCESSING - currently processing/sending (optional)
     * @param  string|null $template_types  (optional)
     * @param  string|null $app_key Filter the list by a specific application (optional)
     * @param  string|null $keyword Keyword search on the scheduled notification names. (optional)
     * @param  string|null $sort_field The field to sort by. Possible values include: ID - order by the scheduledNotificationId CREATED - order by the timestamp it was created UPDATED - order by the timestamp it was last updated ACTIVE - order by whether it is active or inactive NAME - order by the scheduled notification name SCHEDULED_DATE - order by the next scheduled date START_DATE - order by the start date END_DATE - order by the end date (optional)
     * @param  bool|null $descending Determines whether the sorted list is in descending or ascending order (optional)
     * @param  int|null $start Start the result set at some index. (optional)
     * @param  int|null $limit Limit the result to some number. (optional)
     * @param  bool|null $active_only Determines whether to return only active results (optional)
     * @param  bool|null $group_by_grouping_id Determines whether to group results with the same groupingId together. (optional)
     * @param  bool|null $return_audience_account_count If true, include audience account counts in the response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchScheduledNotifications'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function searchScheduledNotificationsRequest($account_id, $grouping_id = null, $audience_id = null, $filter = null, $types = null, $content_ids = null, $content_types = null, $parent_ids = null, $parent_types = null, $statuses = null, $template_types = null, $app_key = null, $keyword = null, $sort_field = null, $descending = null, $start = null, $limit = null, $active_only = null, $group_by_grouping_id = null, $return_audience_account_count = null, string $contentType = self::contentTypes['searchScheduledNotifications'][0])
    {

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling searchScheduledNotifications'
            );
        }





















        $resourcePath = '/notification/schedule/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $grouping_id,
            'groupingId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audience_id,
            'audienceId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $filter,
            'filter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $types,
            'types', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $content_ids,
            'contentIds', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $content_types,
            'contentTypes', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $parent_ids,
            'parentIds', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $parent_types,
            'parentTypes', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $statuses,
            'statuses', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $template_types,
            'templateTypes', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $app_key,
            'appKey', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $keyword,
            'keyword', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort_field,
            'sortField', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $descending,
            'descending', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start,
            'start', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $active_only,
            'activeOnly', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $group_by_grouping_id,
            'groupByGroupingId', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_audience_account_count,
            'returnAudienceAccountCount', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateScheduledNotification
     *
     * Update Scheduled Notification
     *
     * @param  int $scheduled_notification_id The id of scheduled notification to update (required)
     * @param  int $account_id The logged in user. (required)
     * @param  string|null $name The name of the scheduled notification (optional)
     * @param  string|null $type The type of scheduled notification. Supported values include: MOBILE_NOTIFICATION - sends push notifications via APNS and GCM EMAIL - sends email messages SMS - sends text messages (optional)
     * @param  string|null $message The message to send (optional)
     * @param  string|null $payload The parameters for making an HTTP call (optional)
     * @param  int|null $content_id The payload content ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param  string|null $content_name The payload content name that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param  string|null $content_type The payload content type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param  int|null $parent_id The payload parent ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param  string|null $parent_type The payload parent type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param  string|null $app_key The application that the notifications will send to. If connectionGroupIds, connectionAccountIds, and audienceIds is not set, this will send to all users who have used the application. This parameter is also required when sending push notifications via the MOBILE_NOTIFICATION type. (optional)
     * @param  string|null $grouping_id Client defined identifier for grouping multiple scheduled notifications. This can be used with the search endpoint to return scheduled notifications with the same groupingId for display purposes. Only results that have been created by the user will be returned when using this feature. (optional)
     * @param  string|null $connection_group_ids The connection groups to use to generate the list of recipients (comma separated list of connection group IDs) (optional)
     * @param  string|null $connection_account_ids The connection accounts to use to generate the list of recipients (comma separated list of user account ids) (optional)
     * @param  int|null $audience_id This parameter is deprecated. The audience used to generate the list of recipients (optional)
     * @param  string|null $audience_ids The audiences used to generate the list of recipients (comma separated list of audience IDs) (optional)
     * @param  string|null $album_ids The album ids to associate with the scheduled notification (comma separated list of album IDs) (optional)
     * @param  int|null $report_id The report used to generate the the list of recipients (optional)
     * @param  string|null $report_params The parameters to supply to the report used to generate the the list of recipients (optional)
     * @param  string|null $endpoint_url The URL for making an HTTP call (optional)
     * @param  int|null $scheduled_date The next time when the scheduled notification should begin processing (time in milliseconds). If this is left empty, then the startDate will be used. (optional)
     * @param  int|null $start_date The start time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to be available now. (optional)
     * @param  int|null $end_date The end time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to not have an expiration date. (optional)
     * @param  string|null $cron_expression The cron expression that represents the processing schedule. This uses the unix cron expression format. For example: 0 0 * * * will run once a day at midnight UTC. (optional)
     * @param  string|null $cron_type The cron expression type: UNIX, CRON4J, QUARTZ (optional)
     * @param  string|null $meta_data Additional metadata for the scheduled notification (optional)
     * @param  string|null $conditional_input Json input representing conditional logic that has to be met before running the scheduled notification (optional)
     * @param  string|null $template_type This determines if the Scheduled Notification is a template which is used as a basis for dynamically generating re-occurring Scheduled Notifications. The available types include: REPORTING - saves an adhoc report to be able to run again at another time GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business owner) GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business employee, retailer location, etc) GEOFENCE_TRIGGER - template for sending notifications to the account that triggered the geofence/audience (i.e. the customer) GEOFENCE_HTTP_CALL - template for making http calls when the geofences are triggered (optional)
     * @param  string|null $visibility Determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited) (optional)
     * @param  bool|null $active Sets whether the Scheduled Notification is active or not (inactive Scheduled Notifications are not processed). This is a quick way to toggle on or off without altering its schedule. (optional)
     * @param  string|null $error_message the error message associated with the scheduled notification (optional)
     * @param  string|null $status the status of the scheduled notification (optional)
     * @param  bool|null $update_by_grouping_id also updates ScheduledNotifications with the same groupingId and account (optional)
     * @param  bool|null $send_now whether to send the scheduled notification now or not (optional)
     * @param  string|null $event_type Sets the event type for the notification (optional, default to 'CUSTOM')
     * @param  string|null $deep_link_uri The payload deep link URI that can be used by the client app to direct users to a screen in the app (optional)
     * @param  bool|null $send_to_all Determines whether to send to all users of the app if set to true for push notifications (appKey is required) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateScheduledNotification'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ScheduledNotificationFullResponse
     */
    public function updateScheduledNotification($scheduled_notification_id, $account_id, $name = null, $type = null, $message = null, $payload = null, $content_id = null, $content_name = null, $content_type = null, $parent_id = null, $parent_type = null, $app_key = null, $grouping_id = null, $connection_group_ids = null, $connection_account_ids = null, $audience_id = null, $audience_ids = null, $album_ids = null, $report_id = null, $report_params = null, $endpoint_url = null, $scheduled_date = null, $start_date = null, $end_date = null, $cron_expression = null, $cron_type = null, $meta_data = null, $conditional_input = null, $template_type = null, $visibility = null, $active = null, $error_message = null, $status = null, $update_by_grouping_id = null, $send_now = null, $event_type = 'CUSTOM', $deep_link_uri = null, $send_to_all = null, string $contentType = self::contentTypes['updateScheduledNotification'][0])
    {
        list($response) = $this->updateScheduledNotificationWithHttpInfo($scheduled_notification_id, $account_id, $name, $type, $message, $payload, $content_id, $content_name, $content_type, $parent_id, $parent_type, $app_key, $grouping_id, $connection_group_ids, $connection_account_ids, $audience_id, $audience_ids, $album_ids, $report_id, $report_params, $endpoint_url, $scheduled_date, $start_date, $end_date, $cron_expression, $cron_type, $meta_data, $conditional_input, $template_type, $visibility, $active, $error_message, $status, $update_by_grouping_id, $send_now, $event_type, $deep_link_uri, $send_to_all, $contentType);
        return $response;
    }

    /**
     * Operation updateScheduledNotificationWithHttpInfo
     *
     * Update Scheduled Notification
     *
     * @param  int $scheduled_notification_id The id of scheduled notification to update (required)
     * @param  int $account_id The logged in user. (required)
     * @param  string|null $name The name of the scheduled notification (optional)
     * @param  string|null $type The type of scheduled notification. Supported values include: MOBILE_NOTIFICATION - sends push notifications via APNS and GCM EMAIL - sends email messages SMS - sends text messages (optional)
     * @param  string|null $message The message to send (optional)
     * @param  string|null $payload The parameters for making an HTTP call (optional)
     * @param  int|null $content_id The payload content ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param  string|null $content_name The payload content name that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param  string|null $content_type The payload content type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param  int|null $parent_id The payload parent ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param  string|null $parent_type The payload parent type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param  string|null $app_key The application that the notifications will send to. If connectionGroupIds, connectionAccountIds, and audienceIds is not set, this will send to all users who have used the application. This parameter is also required when sending push notifications via the MOBILE_NOTIFICATION type. (optional)
     * @param  string|null $grouping_id Client defined identifier for grouping multiple scheduled notifications. This can be used with the search endpoint to return scheduled notifications with the same groupingId for display purposes. Only results that have been created by the user will be returned when using this feature. (optional)
     * @param  string|null $connection_group_ids The connection groups to use to generate the list of recipients (comma separated list of connection group IDs) (optional)
     * @param  string|null $connection_account_ids The connection accounts to use to generate the list of recipients (comma separated list of user account ids) (optional)
     * @param  int|null $audience_id This parameter is deprecated. The audience used to generate the list of recipients (optional)
     * @param  string|null $audience_ids The audiences used to generate the list of recipients (comma separated list of audience IDs) (optional)
     * @param  string|null $album_ids The album ids to associate with the scheduled notification (comma separated list of album IDs) (optional)
     * @param  int|null $report_id The report used to generate the the list of recipients (optional)
     * @param  string|null $report_params The parameters to supply to the report used to generate the the list of recipients (optional)
     * @param  string|null $endpoint_url The URL for making an HTTP call (optional)
     * @param  int|null $scheduled_date The next time when the scheduled notification should begin processing (time in milliseconds). If this is left empty, then the startDate will be used. (optional)
     * @param  int|null $start_date The start time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to be available now. (optional)
     * @param  int|null $end_date The end time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to not have an expiration date. (optional)
     * @param  string|null $cron_expression The cron expression that represents the processing schedule. This uses the unix cron expression format. For example: 0 0 * * * will run once a day at midnight UTC. (optional)
     * @param  string|null $cron_type The cron expression type: UNIX, CRON4J, QUARTZ (optional)
     * @param  string|null $meta_data Additional metadata for the scheduled notification (optional)
     * @param  string|null $conditional_input Json input representing conditional logic that has to be met before running the scheduled notification (optional)
     * @param  string|null $template_type This determines if the Scheduled Notification is a template which is used as a basis for dynamically generating re-occurring Scheduled Notifications. The available types include: REPORTING - saves an adhoc report to be able to run again at another time GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business owner) GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business employee, retailer location, etc) GEOFENCE_TRIGGER - template for sending notifications to the account that triggered the geofence/audience (i.e. the customer) GEOFENCE_HTTP_CALL - template for making http calls when the geofences are triggered (optional)
     * @param  string|null $visibility Determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited) (optional)
     * @param  bool|null $active Sets whether the Scheduled Notification is active or not (inactive Scheduled Notifications are not processed). This is a quick way to toggle on or off without altering its schedule. (optional)
     * @param  string|null $error_message the error message associated with the scheduled notification (optional)
     * @param  string|null $status the status of the scheduled notification (optional)
     * @param  bool|null $update_by_grouping_id also updates ScheduledNotifications with the same groupingId and account (optional)
     * @param  bool|null $send_now whether to send the scheduled notification now or not (optional)
     * @param  string|null $event_type Sets the event type for the notification (optional, default to 'CUSTOM')
     * @param  string|null $deep_link_uri The payload deep link URI that can be used by the client app to direct users to a screen in the app (optional)
     * @param  bool|null $send_to_all Determines whether to send to all users of the app if set to true for push notifications (appKey is required) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateScheduledNotification'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ScheduledNotificationFullResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateScheduledNotificationWithHttpInfo($scheduled_notification_id, $account_id, $name = null, $type = null, $message = null, $payload = null, $content_id = null, $content_name = null, $content_type = null, $parent_id = null, $parent_type = null, $app_key = null, $grouping_id = null, $connection_group_ids = null, $connection_account_ids = null, $audience_id = null, $audience_ids = null, $album_ids = null, $report_id = null, $report_params = null, $endpoint_url = null, $scheduled_date = null, $start_date = null, $end_date = null, $cron_expression = null, $cron_type = null, $meta_data = null, $conditional_input = null, $template_type = null, $visibility = null, $active = null, $error_message = null, $status = null, $update_by_grouping_id = null, $send_now = null, $event_type = 'CUSTOM', $deep_link_uri = null, $send_to_all = null, string $contentType = self::contentTypes['updateScheduledNotification'][0])
    {
        $request = $this->updateScheduledNotificationRequest($scheduled_notification_id, $account_id, $name, $type, $message, $payload, $content_id, $content_name, $content_type, $parent_id, $parent_type, $app_key, $grouping_id, $connection_group_ids, $connection_account_ids, $audience_id, $audience_ids, $album_ids, $report_id, $report_params, $endpoint_url, $scheduled_date, $start_date, $end_date, $cron_expression, $cron_type, $meta_data, $conditional_input, $template_type, $visibility, $active, $error_message, $status, $update_by_grouping_id, $send_now, $event_type, $deep_link_uri, $send_to_all, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ScheduledNotificationFullResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\ScheduledNotificationFullResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ScheduledNotificationFullResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateScheduledNotificationAsync
     *
     * Update Scheduled Notification
     *
     * @param  int $scheduled_notification_id The id of scheduled notification to update (required)
     * @param  int $account_id The logged in user. (required)
     * @param  string|null $name The name of the scheduled notification (optional)
     * @param  string|null $type The type of scheduled notification. Supported values include: MOBILE_NOTIFICATION - sends push notifications via APNS and GCM EMAIL - sends email messages SMS - sends text messages (optional)
     * @param  string|null $message The message to send (optional)
     * @param  string|null $payload The parameters for making an HTTP call (optional)
     * @param  int|null $content_id The payload content ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param  string|null $content_name The payload content name that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param  string|null $content_type The payload content type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param  int|null $parent_id The payload parent ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param  string|null $parent_type The payload parent type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param  string|null $app_key The application that the notifications will send to. If connectionGroupIds, connectionAccountIds, and audienceIds is not set, this will send to all users who have used the application. This parameter is also required when sending push notifications via the MOBILE_NOTIFICATION type. (optional)
     * @param  string|null $grouping_id Client defined identifier for grouping multiple scheduled notifications. This can be used with the search endpoint to return scheduled notifications with the same groupingId for display purposes. Only results that have been created by the user will be returned when using this feature. (optional)
     * @param  string|null $connection_group_ids The connection groups to use to generate the list of recipients (comma separated list of connection group IDs) (optional)
     * @param  string|null $connection_account_ids The connection accounts to use to generate the list of recipients (comma separated list of user account ids) (optional)
     * @param  int|null $audience_id This parameter is deprecated. The audience used to generate the list of recipients (optional)
     * @param  string|null $audience_ids The audiences used to generate the list of recipients (comma separated list of audience IDs) (optional)
     * @param  string|null $album_ids The album ids to associate with the scheduled notification (comma separated list of album IDs) (optional)
     * @param  int|null $report_id The report used to generate the the list of recipients (optional)
     * @param  string|null $report_params The parameters to supply to the report used to generate the the list of recipients (optional)
     * @param  string|null $endpoint_url The URL for making an HTTP call (optional)
     * @param  int|null $scheduled_date The next time when the scheduled notification should begin processing (time in milliseconds). If this is left empty, then the startDate will be used. (optional)
     * @param  int|null $start_date The start time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to be available now. (optional)
     * @param  int|null $end_date The end time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to not have an expiration date. (optional)
     * @param  string|null $cron_expression The cron expression that represents the processing schedule. This uses the unix cron expression format. For example: 0 0 * * * will run once a day at midnight UTC. (optional)
     * @param  string|null $cron_type The cron expression type: UNIX, CRON4J, QUARTZ (optional)
     * @param  string|null $meta_data Additional metadata for the scheduled notification (optional)
     * @param  string|null $conditional_input Json input representing conditional logic that has to be met before running the scheduled notification (optional)
     * @param  string|null $template_type This determines if the Scheduled Notification is a template which is used as a basis for dynamically generating re-occurring Scheduled Notifications. The available types include: REPORTING - saves an adhoc report to be able to run again at another time GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business owner) GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business employee, retailer location, etc) GEOFENCE_TRIGGER - template for sending notifications to the account that triggered the geofence/audience (i.e. the customer) GEOFENCE_HTTP_CALL - template for making http calls when the geofences are triggered (optional)
     * @param  string|null $visibility Determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited) (optional)
     * @param  bool|null $active Sets whether the Scheduled Notification is active or not (inactive Scheduled Notifications are not processed). This is a quick way to toggle on or off without altering its schedule. (optional)
     * @param  string|null $error_message the error message associated with the scheduled notification (optional)
     * @param  string|null $status the status of the scheduled notification (optional)
     * @param  bool|null $update_by_grouping_id also updates ScheduledNotifications with the same groupingId and account (optional)
     * @param  bool|null $send_now whether to send the scheduled notification now or not (optional)
     * @param  string|null $event_type Sets the event type for the notification (optional, default to 'CUSTOM')
     * @param  string|null $deep_link_uri The payload deep link URI that can be used by the client app to direct users to a screen in the app (optional)
     * @param  bool|null $send_to_all Determines whether to send to all users of the app if set to true for push notifications (appKey is required) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateScheduledNotification'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateScheduledNotificationAsync($scheduled_notification_id, $account_id, $name = null, $type = null, $message = null, $payload = null, $content_id = null, $content_name = null, $content_type = null, $parent_id = null, $parent_type = null, $app_key = null, $grouping_id = null, $connection_group_ids = null, $connection_account_ids = null, $audience_id = null, $audience_ids = null, $album_ids = null, $report_id = null, $report_params = null, $endpoint_url = null, $scheduled_date = null, $start_date = null, $end_date = null, $cron_expression = null, $cron_type = null, $meta_data = null, $conditional_input = null, $template_type = null, $visibility = null, $active = null, $error_message = null, $status = null, $update_by_grouping_id = null, $send_now = null, $event_type = 'CUSTOM', $deep_link_uri = null, $send_to_all = null, string $contentType = self::contentTypes['updateScheduledNotification'][0])
    {
        return $this->updateScheduledNotificationAsyncWithHttpInfo($scheduled_notification_id, $account_id, $name, $type, $message, $payload, $content_id, $content_name, $content_type, $parent_id, $parent_type, $app_key, $grouping_id, $connection_group_ids, $connection_account_ids, $audience_id, $audience_ids, $album_ids, $report_id, $report_params, $endpoint_url, $scheduled_date, $start_date, $end_date, $cron_expression, $cron_type, $meta_data, $conditional_input, $template_type, $visibility, $active, $error_message, $status, $update_by_grouping_id, $send_now, $event_type, $deep_link_uri, $send_to_all, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateScheduledNotificationAsyncWithHttpInfo
     *
     * Update Scheduled Notification
     *
     * @param  int $scheduled_notification_id The id of scheduled notification to update (required)
     * @param  int $account_id The logged in user. (required)
     * @param  string|null $name The name of the scheduled notification (optional)
     * @param  string|null $type The type of scheduled notification. Supported values include: MOBILE_NOTIFICATION - sends push notifications via APNS and GCM EMAIL - sends email messages SMS - sends text messages (optional)
     * @param  string|null $message The message to send (optional)
     * @param  string|null $payload The parameters for making an HTTP call (optional)
     * @param  int|null $content_id The payload content ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param  string|null $content_name The payload content name that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param  string|null $content_type The payload content type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param  int|null $parent_id The payload parent ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param  string|null $parent_type The payload parent type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param  string|null $app_key The application that the notifications will send to. If connectionGroupIds, connectionAccountIds, and audienceIds is not set, this will send to all users who have used the application. This parameter is also required when sending push notifications via the MOBILE_NOTIFICATION type. (optional)
     * @param  string|null $grouping_id Client defined identifier for grouping multiple scheduled notifications. This can be used with the search endpoint to return scheduled notifications with the same groupingId for display purposes. Only results that have been created by the user will be returned when using this feature. (optional)
     * @param  string|null $connection_group_ids The connection groups to use to generate the list of recipients (comma separated list of connection group IDs) (optional)
     * @param  string|null $connection_account_ids The connection accounts to use to generate the list of recipients (comma separated list of user account ids) (optional)
     * @param  int|null $audience_id This parameter is deprecated. The audience used to generate the list of recipients (optional)
     * @param  string|null $audience_ids The audiences used to generate the list of recipients (comma separated list of audience IDs) (optional)
     * @param  string|null $album_ids The album ids to associate with the scheduled notification (comma separated list of album IDs) (optional)
     * @param  int|null $report_id The report used to generate the the list of recipients (optional)
     * @param  string|null $report_params The parameters to supply to the report used to generate the the list of recipients (optional)
     * @param  string|null $endpoint_url The URL for making an HTTP call (optional)
     * @param  int|null $scheduled_date The next time when the scheduled notification should begin processing (time in milliseconds). If this is left empty, then the startDate will be used. (optional)
     * @param  int|null $start_date The start time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to be available now. (optional)
     * @param  int|null $end_date The end time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to not have an expiration date. (optional)
     * @param  string|null $cron_expression The cron expression that represents the processing schedule. This uses the unix cron expression format. For example: 0 0 * * * will run once a day at midnight UTC. (optional)
     * @param  string|null $cron_type The cron expression type: UNIX, CRON4J, QUARTZ (optional)
     * @param  string|null $meta_data Additional metadata for the scheduled notification (optional)
     * @param  string|null $conditional_input Json input representing conditional logic that has to be met before running the scheduled notification (optional)
     * @param  string|null $template_type This determines if the Scheduled Notification is a template which is used as a basis for dynamically generating re-occurring Scheduled Notifications. The available types include: REPORTING - saves an adhoc report to be able to run again at another time GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business owner) GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business employee, retailer location, etc) GEOFENCE_TRIGGER - template for sending notifications to the account that triggered the geofence/audience (i.e. the customer) GEOFENCE_HTTP_CALL - template for making http calls when the geofences are triggered (optional)
     * @param  string|null $visibility Determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited) (optional)
     * @param  bool|null $active Sets whether the Scheduled Notification is active or not (inactive Scheduled Notifications are not processed). This is a quick way to toggle on or off without altering its schedule. (optional)
     * @param  string|null $error_message the error message associated with the scheduled notification (optional)
     * @param  string|null $status the status of the scheduled notification (optional)
     * @param  bool|null $update_by_grouping_id also updates ScheduledNotifications with the same groupingId and account (optional)
     * @param  bool|null $send_now whether to send the scheduled notification now or not (optional)
     * @param  string|null $event_type Sets the event type for the notification (optional, default to 'CUSTOM')
     * @param  string|null $deep_link_uri The payload deep link URI that can be used by the client app to direct users to a screen in the app (optional)
     * @param  bool|null $send_to_all Determines whether to send to all users of the app if set to true for push notifications (appKey is required) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateScheduledNotification'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateScheduledNotificationAsyncWithHttpInfo($scheduled_notification_id, $account_id, $name = null, $type = null, $message = null, $payload = null, $content_id = null, $content_name = null, $content_type = null, $parent_id = null, $parent_type = null, $app_key = null, $grouping_id = null, $connection_group_ids = null, $connection_account_ids = null, $audience_id = null, $audience_ids = null, $album_ids = null, $report_id = null, $report_params = null, $endpoint_url = null, $scheduled_date = null, $start_date = null, $end_date = null, $cron_expression = null, $cron_type = null, $meta_data = null, $conditional_input = null, $template_type = null, $visibility = null, $active = null, $error_message = null, $status = null, $update_by_grouping_id = null, $send_now = null, $event_type = 'CUSTOM', $deep_link_uri = null, $send_to_all = null, string $contentType = self::contentTypes['updateScheduledNotification'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ScheduledNotificationFullResponse';
        $request = $this->updateScheduledNotificationRequest($scheduled_notification_id, $account_id, $name, $type, $message, $payload, $content_id, $content_name, $content_type, $parent_id, $parent_type, $app_key, $grouping_id, $connection_group_ids, $connection_account_ids, $audience_id, $audience_ids, $album_ids, $report_id, $report_params, $endpoint_url, $scheduled_date, $start_date, $end_date, $cron_expression, $cron_type, $meta_data, $conditional_input, $template_type, $visibility, $active, $error_message, $status, $update_by_grouping_id, $send_now, $event_type, $deep_link_uri, $send_to_all, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateScheduledNotification'
     *
     * @param  int $scheduled_notification_id The id of scheduled notification to update (required)
     * @param  int $account_id The logged in user. (required)
     * @param  string|null $name The name of the scheduled notification (optional)
     * @param  string|null $type The type of scheduled notification. Supported values include: MOBILE_NOTIFICATION - sends push notifications via APNS and GCM EMAIL - sends email messages SMS - sends text messages (optional)
     * @param  string|null $message The message to send (optional)
     * @param  string|null $payload The parameters for making an HTTP call (optional)
     * @param  int|null $content_id The payload content ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param  string|null $content_name The payload content name that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param  string|null $content_type The payload content type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param  int|null $parent_id The payload parent ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param  string|null $parent_type The payload parent type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param  string|null $app_key The application that the notifications will send to. If connectionGroupIds, connectionAccountIds, and audienceIds is not set, this will send to all users who have used the application. This parameter is also required when sending push notifications via the MOBILE_NOTIFICATION type. (optional)
     * @param  string|null $grouping_id Client defined identifier for grouping multiple scheduled notifications. This can be used with the search endpoint to return scheduled notifications with the same groupingId for display purposes. Only results that have been created by the user will be returned when using this feature. (optional)
     * @param  string|null $connection_group_ids The connection groups to use to generate the list of recipients (comma separated list of connection group IDs) (optional)
     * @param  string|null $connection_account_ids The connection accounts to use to generate the list of recipients (comma separated list of user account ids) (optional)
     * @param  int|null $audience_id This parameter is deprecated. The audience used to generate the list of recipients (optional)
     * @param  string|null $audience_ids The audiences used to generate the list of recipients (comma separated list of audience IDs) (optional)
     * @param  string|null $album_ids The album ids to associate with the scheduled notification (comma separated list of album IDs) (optional)
     * @param  int|null $report_id The report used to generate the the list of recipients (optional)
     * @param  string|null $report_params The parameters to supply to the report used to generate the the list of recipients (optional)
     * @param  string|null $endpoint_url The URL for making an HTTP call (optional)
     * @param  int|null $scheduled_date The next time when the scheduled notification should begin processing (time in milliseconds). If this is left empty, then the startDate will be used. (optional)
     * @param  int|null $start_date The start time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to be available now. (optional)
     * @param  int|null $end_date The end time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to not have an expiration date. (optional)
     * @param  string|null $cron_expression The cron expression that represents the processing schedule. This uses the unix cron expression format. For example: 0 0 * * * will run once a day at midnight UTC. (optional)
     * @param  string|null $cron_type The cron expression type: UNIX, CRON4J, QUARTZ (optional)
     * @param  string|null $meta_data Additional metadata for the scheduled notification (optional)
     * @param  string|null $conditional_input Json input representing conditional logic that has to be met before running the scheduled notification (optional)
     * @param  string|null $template_type This determines if the Scheduled Notification is a template which is used as a basis for dynamically generating re-occurring Scheduled Notifications. The available types include: REPORTING - saves an adhoc report to be able to run again at another time GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business owner) GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business employee, retailer location, etc) GEOFENCE_TRIGGER - template for sending notifications to the account that triggered the geofence/audience (i.e. the customer) GEOFENCE_HTTP_CALL - template for making http calls when the geofences are triggered (optional)
     * @param  string|null $visibility Determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited) (optional)
     * @param  bool|null $active Sets whether the Scheduled Notification is active or not (inactive Scheduled Notifications are not processed). This is a quick way to toggle on or off without altering its schedule. (optional)
     * @param  string|null $error_message the error message associated with the scheduled notification (optional)
     * @param  string|null $status the status of the scheduled notification (optional)
     * @param  bool|null $update_by_grouping_id also updates ScheduledNotifications with the same groupingId and account (optional)
     * @param  bool|null $send_now whether to send the scheduled notification now or not (optional)
     * @param  string|null $event_type Sets the event type for the notification (optional, default to 'CUSTOM')
     * @param  string|null $deep_link_uri The payload deep link URI that can be used by the client app to direct users to a screen in the app (optional)
     * @param  bool|null $send_to_all Determines whether to send to all users of the app if set to true for push notifications (appKey is required) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateScheduledNotification'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateScheduledNotificationRequest($scheduled_notification_id, $account_id, $name = null, $type = null, $message = null, $payload = null, $content_id = null, $content_name = null, $content_type = null, $parent_id = null, $parent_type = null, $app_key = null, $grouping_id = null, $connection_group_ids = null, $connection_account_ids = null, $audience_id = null, $audience_ids = null, $album_ids = null, $report_id = null, $report_params = null, $endpoint_url = null, $scheduled_date = null, $start_date = null, $end_date = null, $cron_expression = null, $cron_type = null, $meta_data = null, $conditional_input = null, $template_type = null, $visibility = null, $active = null, $error_message = null, $status = null, $update_by_grouping_id = null, $send_now = null, $event_type = 'CUSTOM', $deep_link_uri = null, $send_to_all = null, string $contentType = self::contentTypes['updateScheduledNotification'][0])
    {

        // verify the required parameter 'scheduled_notification_id' is set
        if ($scheduled_notification_id === null || (is_array($scheduled_notification_id) && count($scheduled_notification_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $scheduled_notification_id when calling updateScheduledNotification'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling updateScheduledNotification'
            );
        }






































        $resourcePath = '/notification/schedule/update';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $scheduled_notification_id,
            'scheduledNotificationId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type,
            'type', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $message,
            'message', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $payload,
            'payload', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $content_id,
            'contentId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $content_name,
            'contentName', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $content_type,
            'contentType', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $parent_id,
            'parentId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $parent_type,
            'parentType', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $app_key,
            'appKey', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $grouping_id,
            'groupingId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $connection_group_ids,
            'connectionGroupIds', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $connection_account_ids,
            'connectionAccountIds', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audience_id,
            'audienceId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $audience_ids,
            'audienceIds', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $album_ids,
            'albumIds', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $report_id,
            'reportId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $report_params,
            'reportParams', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $endpoint_url,
            'endpointURL', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $scheduled_date,
            'scheduledDate', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'startDate', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'endDate', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cron_expression,
            'cronExpression', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cron_type,
            'cronType', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $meta_data,
            'metaData', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $conditional_input,
            'conditionalInput', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $template_type,
            'templateType', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $visibility,
            'visibility', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $active,
            'active', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $error_message,
            'errorMessage', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $update_by_grouping_id,
            'updateByGroupingId', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $send_now,
            'sendNow', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $event_type,
            'eventType', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $deep_link_uri,
            'deepLinkURI', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $send_to_all,
            'sendToAll', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        if ($this->config->getCertFile()) {
            $options[RequestOptions::CERT] = $this->config->getCertFile();
        }

        if ($this->config->getKeyFile()) {
            $options[RequestOptions::SSL_KEY] = $this->config->getKeyFile();
        }

        return $options;
    }

    private function handleResponseWithDataType(
        string $dataType,
        RequestInterface $request,
        ResponseInterface $response
    ): array {
        if ($dataType === '\SplFileObject') {
            $content = $response->getBody(); //stream goes to serializer
        } else {
            $content = (string) $response->getBody();
            if ($dataType !== 'string') {
                try {
                    $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                } catch (\JsonException $exception) {
                    throw new ApiException(
                        sprintf(
                            'Error JSON decoding server response (%s)',
                            $request->getUri()
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                        $content
                    );
                }
            }
        }

        return [
            ObjectSerializer::deserialize($content, $dataType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    private function responseWithinRangeCode(
        string $rangeCode,
        int $statusCode
    ): bool {
        $left = (int) ($rangeCode[0].'00');
        $right = (int) ($rangeCode[0].'99');

        return $statusCode >= $left && $statusCode <= $right;
    }
}
