<?php
/**
 * VatomApi
 * PHP version 8.1
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Sirqul IoT Platform
 *
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.20.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\FormDataProcessor;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * VatomApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class VatomApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'createFollowing' => [
            'application/json',
        ],
        'createSpace' => [
            'application/json',
        ],
        'createVatomEvent' => [
            'application/json',
        ],
        'deleteFollowing' => [
            'application/json',
        ],
        'deletePointsBalance' => [
            'application/json',
        ],
        'deleteSpace' => [
            'application/json',
        ],
        'deleteVatomEvent' => [
            'application/json',
        ],
        'deleteVatomNFT' => [
            'application/json',
        ],
        'executeActionOnNFT' => [
            'application/json',
        ],
        'geomapSearch' => [
            'application/json',
        ],
        'getBusinessBehaviors' => [
            'application/json',
        ],
        'getBusinessCoinsBalance' => [
            'application/json',
        ],
        'getBusinessIds' => [
            'application/json',
        ],
        'getBusinessInfo' => [
            'application/json',
        ],
        'getBusinessUsers' => [
            'application/json',
        ],
        'getCampaignGroupEntities' => [
            'application/json',
        ],
        'getCampaignGroupRules' => [
            'application/json',
        ],
        'getCampaignGroupStats' => [
            'application/json',
        ],
        'getCampaignInfo' => [
            'application/json',
        ],
        'getEventGuestList' => [
            'application/json',
        ],
        'getInventory' => [
            'application/json',
        ],
        'getMyFollowing' => [
            'application/json',
        ],
        'getPointsBalance' => [
            'application/json',
        ],
        'getPointsBalanceAsBusiness' => [
            'application/json',
        ],
        'getSpace' => [
            'application/json',
        ],
        'getUserCoinsAsBusiness' => [
            'application/json',
        ],
        'getUserCoinsBalance' => [
            'application/json',
        ],
        'getUserFollowers' => [
            'application/json',
        ],
        'getUserFollowing' => [
            'application/json',
        ],
        'getUserInfo' => [
            'application/json',
        ],
        'getUserProfile' => [
            'application/json',
        ],
        'getVatomEvent' => [
            'application/json',
        ],
        'getVatomNFT' => [
            'application/json',
        ],
        'listCommunities' => [
            'application/json',
        ],
        'listEvents' => [
            'application/json',
        ],
        'listSpaces' => [
            'application/json',
        ],
        'listUserCoinTransactions' => [
            'application/json',
        ],
        'listUserCoinTransactionsAsBusiness' => [
            'application/json',
        ],
        'performActionOnNFT' => [
            'application/json',
        ],
        'redeemNFT' => [
            'application/json',
        ],
        'redeemUserCoinsAsBusiness' => [
            'application/json',
        ],
        'searchBusinesses' => [
            'application/json',
        ],
        'searchCampaignGroups' => [
            'application/json',
        ],
        'searchIdentities' => [
            'application/json',
        ],
        'searchInventory' => [
            'application/json',
        ],
        'sendNFT' => [
            'application/json',
        ],
        'setPointsBalanceAsBusiness' => [
            'application/json',
        ],
        'transferUserCoins' => [
            'application/json',
        ],
        'updateBusinessCoins' => [
            'application/json',
        ],
        'updateEventGuestList' => [
            'application/json',
        ],
        'updateSpace' => [
            'application/json',
        ],
        'updateUserCoinsAsBusiness' => [
            'application/json',
        ],
        'updateUserProfile' => [
            'application/json',
        ],
        'updateVatomEvent' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation createFollowing
     *
     * Create following
     *
     * @param  float $version version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createFollowing'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function createFollowing($version, $account_id, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['createFollowing'][0])
    {
        $this->createFollowingWithHttpInfo($version, $account_id, $vatom_parameters, $return_raw_response, $contentType);
    }

    /**
     * Operation createFollowingWithHttpInfo
     *
     * Create following
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createFollowing'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function createFollowingWithHttpInfo($version, $account_id, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['createFollowing'][0])
    {
        $request = $this->createFollowingRequest($version, $account_id, $vatom_parameters, $return_raw_response, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation createFollowingAsync
     *
     * Create following
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createFollowing'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createFollowingAsync($version, $account_id, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['createFollowing'][0])
    {
        return $this->createFollowingAsyncWithHttpInfo($version, $account_id, $vatom_parameters, $return_raw_response, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createFollowingAsyncWithHttpInfo
     *
     * Create following
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createFollowing'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createFollowingAsyncWithHttpInfo($version, $account_id, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['createFollowing'][0])
    {
        $returnType = '';
        $request = $this->createFollowingRequest($version, $account_id, $vatom_parameters, $return_raw_response, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createFollowing'
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createFollowing'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createFollowingRequest($version, $account_id, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['createFollowing'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling createFollowing'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling createFollowing'
            );
        }

        // verify the required parameter 'vatom_parameters' is set
        if ($vatom_parameters === null || (is_array($vatom_parameters) && count($vatom_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vatom_parameters when calling createFollowing'
            );
        }



        $resourcePath = '/api/{version}/vatom/me/rels/following/create';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vatom_parameters,
            'vatomParameters', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_raw_response,
            'returnRawResponse', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createSpace
     *
     * Create Vatom Space
     *
     * @param  float $version version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createSpace'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function createSpace($version, $account_id, $app_key, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['createSpace'][0])
    {
        $this->createSpaceWithHttpInfo($version, $account_id, $app_key, $vatom_parameters, $return_raw_response, $contentType);
    }

    /**
     * Operation createSpaceWithHttpInfo
     *
     * Create Vatom Space
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createSpace'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function createSpaceWithHttpInfo($version, $account_id, $app_key, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['createSpace'][0])
    {
        $request = $this->createSpaceRequest($version, $account_id, $app_key, $vatom_parameters, $return_raw_response, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation createSpaceAsync
     *
     * Create Vatom Space
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createSpaceAsync($version, $account_id, $app_key, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['createSpace'][0])
    {
        return $this->createSpaceAsyncWithHttpInfo($version, $account_id, $app_key, $vatom_parameters, $return_raw_response, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createSpaceAsyncWithHttpInfo
     *
     * Create Vatom Space
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createSpaceAsyncWithHttpInfo($version, $account_id, $app_key, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['createSpace'][0])
    {
        $returnType = '';
        $request = $this->createSpaceRequest($version, $account_id, $app_key, $vatom_parameters, $return_raw_response, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createSpace'
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createSpaceRequest($version, $account_id, $app_key, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['createSpace'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling createSpace'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling createSpace'
            );
        }

        // verify the required parameter 'app_key' is set
        if ($app_key === null || (is_array($app_key) && count($app_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_key when calling createSpace'
            );
        }

        // verify the required parameter 'vatom_parameters' is set
        if ($vatom_parameters === null || (is_array($vatom_parameters) && count($vatom_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vatom_parameters when calling createSpace'
            );
        }



        $resourcePath = '/api/{version}/vatom/b/spaces/create';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $app_key,
            'appKey', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vatom_parameters,
            'vatomParameters', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_raw_response,
            'returnRawResponse', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createVatomEvent
     *
     * Create Vatom Event
     *
     * @param  float $version version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createVatomEvent'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function createVatomEvent($version, $account_id, $app_key, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['createVatomEvent'][0])
    {
        $this->createVatomEventWithHttpInfo($version, $account_id, $app_key, $vatom_parameters, $return_raw_response, $contentType);
    }

    /**
     * Operation createVatomEventWithHttpInfo
     *
     * Create Vatom Event
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createVatomEvent'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function createVatomEventWithHttpInfo($version, $account_id, $app_key, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['createVatomEvent'][0])
    {
        $request = $this->createVatomEventRequest($version, $account_id, $app_key, $vatom_parameters, $return_raw_response, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation createVatomEventAsync
     *
     * Create Vatom Event
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createVatomEvent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createVatomEventAsync($version, $account_id, $app_key, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['createVatomEvent'][0])
    {
        return $this->createVatomEventAsyncWithHttpInfo($version, $account_id, $app_key, $vatom_parameters, $return_raw_response, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createVatomEventAsyncWithHttpInfo
     *
     * Create Vatom Event
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createVatomEvent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createVatomEventAsyncWithHttpInfo($version, $account_id, $app_key, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['createVatomEvent'][0])
    {
        $returnType = '';
        $request = $this->createVatomEventRequest($version, $account_id, $app_key, $vatom_parameters, $return_raw_response, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createVatomEvent'
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createVatomEvent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createVatomEventRequest($version, $account_id, $app_key, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['createVatomEvent'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling createVatomEvent'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling createVatomEvent'
            );
        }

        // verify the required parameter 'app_key' is set
        if ($app_key === null || (is_array($app_key) && count($app_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_key when calling createVatomEvent'
            );
        }

        // verify the required parameter 'vatom_parameters' is set
        if ($vatom_parameters === null || (is_array($vatom_parameters) && count($vatom_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vatom_parameters when calling createVatomEvent'
            );
        }



        $resourcePath = '/api/{version}/vatom/b/events/create';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $app_key,
            'appKey', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vatom_parameters,
            'vatomParameters', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_raw_response,
            'returnRawResponse', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteFollowing
     *
     * Delete following
     *
     * @param  float $version version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_rels_key Vatom Rels Key (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteFollowing'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteFollowing($version, $account_id, $vatom_rels_key, $return_raw_response = null, string $contentType = self::contentTypes['deleteFollowing'][0])
    {
        $this->deleteFollowingWithHttpInfo($version, $account_id, $vatom_rels_key, $return_raw_response, $contentType);
    }

    /**
     * Operation deleteFollowingWithHttpInfo
     *
     * Delete following
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_rels_key Vatom Rels Key (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteFollowing'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteFollowingWithHttpInfo($version, $account_id, $vatom_rels_key, $return_raw_response = null, string $contentType = self::contentTypes['deleteFollowing'][0])
    {
        $request = $this->deleteFollowingRequest($version, $account_id, $vatom_rels_key, $return_raw_response, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteFollowingAsync
     *
     * Delete following
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_rels_key Vatom Rels Key (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteFollowing'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFollowingAsync($version, $account_id, $vatom_rels_key, $return_raw_response = null, string $contentType = self::contentTypes['deleteFollowing'][0])
    {
        return $this->deleteFollowingAsyncWithHttpInfo($version, $account_id, $vatom_rels_key, $return_raw_response, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteFollowingAsyncWithHttpInfo
     *
     * Delete following
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_rels_key Vatom Rels Key (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteFollowing'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFollowingAsyncWithHttpInfo($version, $account_id, $vatom_rels_key, $return_raw_response = null, string $contentType = self::contentTypes['deleteFollowing'][0])
    {
        $returnType = '';
        $request = $this->deleteFollowingRequest($version, $account_id, $vatom_rels_key, $return_raw_response, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteFollowing'
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_rels_key Vatom Rels Key (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteFollowing'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteFollowingRequest($version, $account_id, $vatom_rels_key, $return_raw_response = null, string $contentType = self::contentTypes['deleteFollowing'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling deleteFollowing'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling deleteFollowing'
            );
        }

        // verify the required parameter 'vatom_rels_key' is set
        if ($vatom_rels_key === null || (is_array($vatom_rels_key) && count($vatom_rels_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vatom_rels_key when calling deleteFollowing'
            );
        }



        $resourcePath = '/api/{version}/vatom/me/rels/following/delete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vatom_rels_key,
            'vatomRelsKey', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_raw_response,
            'returnRawResponse', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deletePointsBalance
     *
     * Reset All Points Balance
     *
     * @param  float $version version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_campaign_id Vatom Campaign Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deletePointsBalance'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deletePointsBalance($version, $account_id, $app_key, $vatom_campaign_id, $return_raw_response = null, string $contentType = self::contentTypes['deletePointsBalance'][0])
    {
        $this->deletePointsBalanceWithHttpInfo($version, $account_id, $app_key, $vatom_campaign_id, $return_raw_response, $contentType);
    }

    /**
     * Operation deletePointsBalanceWithHttpInfo
     *
     * Reset All Points Balance
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_campaign_id Vatom Campaign Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deletePointsBalance'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deletePointsBalanceWithHttpInfo($version, $account_id, $app_key, $vatom_campaign_id, $return_raw_response = null, string $contentType = self::contentTypes['deletePointsBalance'][0])
    {
        $request = $this->deletePointsBalanceRequest($version, $account_id, $app_key, $vatom_campaign_id, $return_raw_response, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation deletePointsBalanceAsync
     *
     * Reset All Points Balance
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_campaign_id Vatom Campaign Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deletePointsBalance'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePointsBalanceAsync($version, $account_id, $app_key, $vatom_campaign_id, $return_raw_response = null, string $contentType = self::contentTypes['deletePointsBalance'][0])
    {
        return $this->deletePointsBalanceAsyncWithHttpInfo($version, $account_id, $app_key, $vatom_campaign_id, $return_raw_response, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deletePointsBalanceAsyncWithHttpInfo
     *
     * Reset All Points Balance
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_campaign_id Vatom Campaign Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deletePointsBalance'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePointsBalanceAsyncWithHttpInfo($version, $account_id, $app_key, $vatom_campaign_id, $return_raw_response = null, string $contentType = self::contentTypes['deletePointsBalance'][0])
    {
        $returnType = '';
        $request = $this->deletePointsBalanceRequest($version, $account_id, $app_key, $vatom_campaign_id, $return_raw_response, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deletePointsBalance'
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_campaign_id Vatom Campaign Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deletePointsBalance'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deletePointsBalanceRequest($version, $account_id, $app_key, $vatom_campaign_id, $return_raw_response = null, string $contentType = self::contentTypes['deletePointsBalance'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling deletePointsBalance'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling deletePointsBalance'
            );
        }

        // verify the required parameter 'app_key' is set
        if ($app_key === null || (is_array($app_key) && count($app_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_key when calling deletePointsBalance'
            );
        }

        // verify the required parameter 'vatom_campaign_id' is set
        if ($vatom_campaign_id === null || (is_array($vatom_campaign_id) && count($vatom_campaign_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vatom_campaign_id when calling deletePointsBalance'
            );
        }



        $resourcePath = '/api/{version}/vatom/b/campaign/points/delete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $app_key,
            'appKey', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vatom_campaign_id,
            'vatomCampaignId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_raw_response,
            'returnRawResponse', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteSpace
     *
     * Delete Vatom Space
     *
     * @param  float $version version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_space_id Vatom Space Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteSpace'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteSpace($version, $account_id, $app_key, $vatom_space_id, $return_raw_response = null, string $contentType = self::contentTypes['deleteSpace'][0])
    {
        $this->deleteSpaceWithHttpInfo($version, $account_id, $app_key, $vatom_space_id, $return_raw_response, $contentType);
    }

    /**
     * Operation deleteSpaceWithHttpInfo
     *
     * Delete Vatom Space
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_space_id Vatom Space Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteSpace'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteSpaceWithHttpInfo($version, $account_id, $app_key, $vatom_space_id, $return_raw_response = null, string $contentType = self::contentTypes['deleteSpace'][0])
    {
        $request = $this->deleteSpaceRequest($version, $account_id, $app_key, $vatom_space_id, $return_raw_response, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteSpaceAsync
     *
     * Delete Vatom Space
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_space_id Vatom Space Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteSpaceAsync($version, $account_id, $app_key, $vatom_space_id, $return_raw_response = null, string $contentType = self::contentTypes['deleteSpace'][0])
    {
        return $this->deleteSpaceAsyncWithHttpInfo($version, $account_id, $app_key, $vatom_space_id, $return_raw_response, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteSpaceAsyncWithHttpInfo
     *
     * Delete Vatom Space
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_space_id Vatom Space Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteSpaceAsyncWithHttpInfo($version, $account_id, $app_key, $vatom_space_id, $return_raw_response = null, string $contentType = self::contentTypes['deleteSpace'][0])
    {
        $returnType = '';
        $request = $this->deleteSpaceRequest($version, $account_id, $app_key, $vatom_space_id, $return_raw_response, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteSpace'
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_space_id Vatom Space Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteSpaceRequest($version, $account_id, $app_key, $vatom_space_id, $return_raw_response = null, string $contentType = self::contentTypes['deleteSpace'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling deleteSpace'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling deleteSpace'
            );
        }

        // verify the required parameter 'app_key' is set
        if ($app_key === null || (is_array($app_key) && count($app_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_key when calling deleteSpace'
            );
        }

        // verify the required parameter 'vatom_space_id' is set
        if ($vatom_space_id === null || (is_array($vatom_space_id) && count($vatom_space_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vatom_space_id when calling deleteSpace'
            );
        }



        $resourcePath = '/api/{version}/vatom/b/spaces/delete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $app_key,
            'appKey', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vatom_space_id,
            'vatomSpaceId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_raw_response,
            'returnRawResponse', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteVatomEvent
     *
     * Delete Vatom Event
     *
     * @param  float $version version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_event_id Vatom Event Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteVatomEvent'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteVatomEvent($version, $account_id, $app_key, $vatom_event_id, $return_raw_response = null, string $contentType = self::contentTypes['deleteVatomEvent'][0])
    {
        $this->deleteVatomEventWithHttpInfo($version, $account_id, $app_key, $vatom_event_id, $return_raw_response, $contentType);
    }

    /**
     * Operation deleteVatomEventWithHttpInfo
     *
     * Delete Vatom Event
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_event_id Vatom Event Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteVatomEvent'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteVatomEventWithHttpInfo($version, $account_id, $app_key, $vatom_event_id, $return_raw_response = null, string $contentType = self::contentTypes['deleteVatomEvent'][0])
    {
        $request = $this->deleteVatomEventRequest($version, $account_id, $app_key, $vatom_event_id, $return_raw_response, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteVatomEventAsync
     *
     * Delete Vatom Event
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_event_id Vatom Event Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteVatomEvent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteVatomEventAsync($version, $account_id, $app_key, $vatom_event_id, $return_raw_response = null, string $contentType = self::contentTypes['deleteVatomEvent'][0])
    {
        return $this->deleteVatomEventAsyncWithHttpInfo($version, $account_id, $app_key, $vatom_event_id, $return_raw_response, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteVatomEventAsyncWithHttpInfo
     *
     * Delete Vatom Event
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_event_id Vatom Event Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteVatomEvent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteVatomEventAsyncWithHttpInfo($version, $account_id, $app_key, $vatom_event_id, $return_raw_response = null, string $contentType = self::contentTypes['deleteVatomEvent'][0])
    {
        $returnType = '';
        $request = $this->deleteVatomEventRequest($version, $account_id, $app_key, $vatom_event_id, $return_raw_response, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteVatomEvent'
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_event_id Vatom Event Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteVatomEvent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteVatomEventRequest($version, $account_id, $app_key, $vatom_event_id, $return_raw_response = null, string $contentType = self::contentTypes['deleteVatomEvent'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling deleteVatomEvent'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling deleteVatomEvent'
            );
        }

        // verify the required parameter 'app_key' is set
        if ($app_key === null || (is_array($app_key) && count($app_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_key when calling deleteVatomEvent'
            );
        }

        // verify the required parameter 'vatom_event_id' is set
        if ($vatom_event_id === null || (is_array($vatom_event_id) && count($vatom_event_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vatom_event_id when calling deleteVatomEvent'
            );
        }



        $resourcePath = '/api/{version}/vatom/b/events/delete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $app_key,
            'appKey', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vatom_event_id,
            'vatomEventId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_raw_response,
            'returnRawResponse', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteVatomNFT
     *
     * Delete Vatom NFT
     *
     * @param  float $version version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_id Vatom NFT Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteVatomNFT'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteVatomNFT($version, $account_id, $vatom_id, $return_raw_response = null, string $contentType = self::contentTypes['deleteVatomNFT'][0])
    {
        $this->deleteVatomNFTWithHttpInfo($version, $account_id, $vatom_id, $return_raw_response, $contentType);
    }

    /**
     * Operation deleteVatomNFTWithHttpInfo
     *
     * Delete Vatom NFT
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_id Vatom NFT Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteVatomNFT'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteVatomNFTWithHttpInfo($version, $account_id, $vatom_id, $return_raw_response = null, string $contentType = self::contentTypes['deleteVatomNFT'][0])
    {
        $request = $this->deleteVatomNFTRequest($version, $account_id, $vatom_id, $return_raw_response, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteVatomNFTAsync
     *
     * Delete Vatom NFT
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_id Vatom NFT Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteVatomNFT'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteVatomNFTAsync($version, $account_id, $vatom_id, $return_raw_response = null, string $contentType = self::contentTypes['deleteVatomNFT'][0])
    {
        return $this->deleteVatomNFTAsyncWithHttpInfo($version, $account_id, $vatom_id, $return_raw_response, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteVatomNFTAsyncWithHttpInfo
     *
     * Delete Vatom NFT
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_id Vatom NFT Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteVatomNFT'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteVatomNFTAsyncWithHttpInfo($version, $account_id, $vatom_id, $return_raw_response = null, string $contentType = self::contentTypes['deleteVatomNFT'][0])
    {
        $returnType = '';
        $request = $this->deleteVatomNFTRequest($version, $account_id, $vatom_id, $return_raw_response, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteVatomNFT'
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_id Vatom NFT Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteVatomNFT'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteVatomNFTRequest($version, $account_id, $vatom_id, $return_raw_response = null, string $contentType = self::contentTypes['deleteVatomNFT'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling deleteVatomNFT'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling deleteVatomNFT'
            );
        }

        // verify the required parameter 'vatom_id' is set
        if ($vatom_id === null || (is_array($vatom_id) && count($vatom_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vatom_id when calling deleteVatomNFT'
            );
        }



        $resourcePath = '/api/{version}/vatom/vatoms/delete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vatom_id,
            'vatomId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_raw_response,
            'returnRawResponse', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation executeActionOnNFT
     *
     * Execute Action on NFT
     *
     * @param  float $version version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_id Vatom NFT Id (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['executeActionOnNFT'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function executeActionOnNFT($version, $account_id, $vatom_id, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['executeActionOnNFT'][0])
    {
        $this->executeActionOnNFTWithHttpInfo($version, $account_id, $vatom_id, $vatom_parameters, $return_raw_response, $contentType);
    }

    /**
     * Operation executeActionOnNFTWithHttpInfo
     *
     * Execute Action on NFT
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_id Vatom NFT Id (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['executeActionOnNFT'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function executeActionOnNFTWithHttpInfo($version, $account_id, $vatom_id, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['executeActionOnNFT'][0])
    {
        $request = $this->executeActionOnNFTRequest($version, $account_id, $vatom_id, $vatom_parameters, $return_raw_response, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation executeActionOnNFTAsync
     *
     * Execute Action on NFT
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_id Vatom NFT Id (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['executeActionOnNFT'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function executeActionOnNFTAsync($version, $account_id, $vatom_id, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['executeActionOnNFT'][0])
    {
        return $this->executeActionOnNFTAsyncWithHttpInfo($version, $account_id, $vatom_id, $vatom_parameters, $return_raw_response, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation executeActionOnNFTAsyncWithHttpInfo
     *
     * Execute Action on NFT
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_id Vatom NFT Id (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['executeActionOnNFT'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function executeActionOnNFTAsyncWithHttpInfo($version, $account_id, $vatom_id, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['executeActionOnNFT'][0])
    {
        $returnType = '';
        $request = $this->executeActionOnNFTRequest($version, $account_id, $vatom_id, $vatom_parameters, $return_raw_response, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'executeActionOnNFT'
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_id Vatom NFT Id (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['executeActionOnNFT'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function executeActionOnNFTRequest($version, $account_id, $vatom_id, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['executeActionOnNFT'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling executeActionOnNFT'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling executeActionOnNFT'
            );
        }

        // verify the required parameter 'vatom_id' is set
        if ($vatom_id === null || (is_array($vatom_id) && count($vatom_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vatom_id when calling executeActionOnNFT'
            );
        }

        // verify the required parameter 'vatom_parameters' is set
        if ($vatom_parameters === null || (is_array($vatom_parameters) && count($vatom_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vatom_parameters when calling executeActionOnNFT'
            );
        }



        $resourcePath = '/api/{version}/vatom/vatoms/execute-action';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vatom_id,
            'vatomId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vatom_parameters,
            'vatomParameters', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_raw_response,
            'returnRawResponse', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation geomapSearch
     *
     * Search Vatom Geo Map
     *
     * @param  float $version version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['geomapSearch'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function geomapSearch($version, $account_id, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['geomapSearch'][0])
    {
        $this->geomapSearchWithHttpInfo($version, $account_id, $vatom_parameters, $return_raw_response, $contentType);
    }

    /**
     * Operation geomapSearchWithHttpInfo
     *
     * Search Vatom Geo Map
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['geomapSearch'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function geomapSearchWithHttpInfo($version, $account_id, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['geomapSearch'][0])
    {
        $request = $this->geomapSearchRequest($version, $account_id, $vatom_parameters, $return_raw_response, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation geomapSearchAsync
     *
     * Search Vatom Geo Map
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['geomapSearch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function geomapSearchAsync($version, $account_id, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['geomapSearch'][0])
    {
        return $this->geomapSearchAsyncWithHttpInfo($version, $account_id, $vatom_parameters, $return_raw_response, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation geomapSearchAsyncWithHttpInfo
     *
     * Search Vatom Geo Map
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['geomapSearch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function geomapSearchAsyncWithHttpInfo($version, $account_id, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['geomapSearch'][0])
    {
        $returnType = '';
        $request = $this->geomapSearchRequest($version, $account_id, $vatom_parameters, $return_raw_response, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'geomapSearch'
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['geomapSearch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function geomapSearchRequest($version, $account_id, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['geomapSearch'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling geomapSearch'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling geomapSearch'
            );
        }

        // verify the required parameter 'vatom_parameters' is set
        if ($vatom_parameters === null || (is_array($vatom_parameters) && count($vatom_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vatom_parameters when calling geomapSearch'
            );
        }



        $resourcePath = '/api/{version}/vatom/vatoms/geo-map/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vatom_parameters,
            'vatomParameters', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_raw_response,
            'returnRawResponse', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBusinessBehaviors
     *
     * Get Vatom Business Behaviors
     *
     * @param  float $version version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBusinessBehaviors'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function getBusinessBehaviors($version, $account_id, $app_key, $return_raw_response = null, string $contentType = self::contentTypes['getBusinessBehaviors'][0])
    {
        $this->getBusinessBehaviorsWithHttpInfo($version, $account_id, $app_key, $return_raw_response, $contentType);
    }

    /**
     * Operation getBusinessBehaviorsWithHttpInfo
     *
     * Get Vatom Business Behaviors
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBusinessBehaviors'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBusinessBehaviorsWithHttpInfo($version, $account_id, $app_key, $return_raw_response = null, string $contentType = self::contentTypes['getBusinessBehaviors'][0])
    {
        $request = $this->getBusinessBehaviorsRequest($version, $account_id, $app_key, $return_raw_response, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation getBusinessBehaviorsAsync
     *
     * Get Vatom Business Behaviors
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBusinessBehaviors'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBusinessBehaviorsAsync($version, $account_id, $app_key, $return_raw_response = null, string $contentType = self::contentTypes['getBusinessBehaviors'][0])
    {
        return $this->getBusinessBehaviorsAsyncWithHttpInfo($version, $account_id, $app_key, $return_raw_response, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBusinessBehaviorsAsyncWithHttpInfo
     *
     * Get Vatom Business Behaviors
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBusinessBehaviors'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBusinessBehaviorsAsyncWithHttpInfo($version, $account_id, $app_key, $return_raw_response = null, string $contentType = self::contentTypes['getBusinessBehaviors'][0])
    {
        $returnType = '';
        $request = $this->getBusinessBehaviorsRequest($version, $account_id, $app_key, $return_raw_response, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBusinessBehaviors'
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBusinessBehaviors'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getBusinessBehaviorsRequest($version, $account_id, $app_key, $return_raw_response = null, string $contentType = self::contentTypes['getBusinessBehaviors'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling getBusinessBehaviors'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling getBusinessBehaviors'
            );
        }

        // verify the required parameter 'app_key' is set
        if ($app_key === null || (is_array($app_key) && count($app_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_key when calling getBusinessBehaviors'
            );
        }



        $resourcePath = '/api/{version}/vatom/b/behaviors';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $app_key,
            'appKey', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_raw_response,
            'returnRawResponse', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBusinessCoinsBalance
     *
     * Get the coins for a Business
     *
     * @param  float $version version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBusinessCoinsBalance'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function getBusinessCoinsBalance($version, $account_id, $app_key, $return_raw_response = null, string $contentType = self::contentTypes['getBusinessCoinsBalance'][0])
    {
        $this->getBusinessCoinsBalanceWithHttpInfo($version, $account_id, $app_key, $return_raw_response, $contentType);
    }

    /**
     * Operation getBusinessCoinsBalanceWithHttpInfo
     *
     * Get the coins for a Business
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBusinessCoinsBalance'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBusinessCoinsBalanceWithHttpInfo($version, $account_id, $app_key, $return_raw_response = null, string $contentType = self::contentTypes['getBusinessCoinsBalance'][0])
    {
        $request = $this->getBusinessCoinsBalanceRequest($version, $account_id, $app_key, $return_raw_response, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation getBusinessCoinsBalanceAsync
     *
     * Get the coins for a Business
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBusinessCoinsBalance'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBusinessCoinsBalanceAsync($version, $account_id, $app_key, $return_raw_response = null, string $contentType = self::contentTypes['getBusinessCoinsBalance'][0])
    {
        return $this->getBusinessCoinsBalanceAsyncWithHttpInfo($version, $account_id, $app_key, $return_raw_response, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBusinessCoinsBalanceAsyncWithHttpInfo
     *
     * Get the coins for a Business
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBusinessCoinsBalance'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBusinessCoinsBalanceAsyncWithHttpInfo($version, $account_id, $app_key, $return_raw_response = null, string $contentType = self::contentTypes['getBusinessCoinsBalance'][0])
    {
        $returnType = '';
        $request = $this->getBusinessCoinsBalanceRequest($version, $account_id, $app_key, $return_raw_response, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBusinessCoinsBalance'
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBusinessCoinsBalance'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getBusinessCoinsBalanceRequest($version, $account_id, $app_key, $return_raw_response = null, string $contentType = self::contentTypes['getBusinessCoinsBalance'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling getBusinessCoinsBalance'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling getBusinessCoinsBalance'
            );
        }

        // verify the required parameter 'app_key' is set
        if ($app_key === null || (is_array($app_key) && count($app_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_key when calling getBusinessCoinsBalance'
            );
        }



        $resourcePath = '/api/{version}/vatom/b/coins/get';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $app_key,
            'appKey', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_raw_response,
            'returnRawResponse', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBusinessIds
     *
     * Get the user business ids
     *
     * @param  float $version version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBusinessIds'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function getBusinessIds($version, $account_id, $return_raw_response = null, string $contentType = self::contentTypes['getBusinessIds'][0])
    {
        $this->getBusinessIdsWithHttpInfo($version, $account_id, $return_raw_response, $contentType);
    }

    /**
     * Operation getBusinessIdsWithHttpInfo
     *
     * Get the user business ids
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBusinessIds'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBusinessIdsWithHttpInfo($version, $account_id, $return_raw_response = null, string $contentType = self::contentTypes['getBusinessIds'][0])
    {
        $request = $this->getBusinessIdsRequest($version, $account_id, $return_raw_response, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation getBusinessIdsAsync
     *
     * Get the user business ids
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBusinessIds'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBusinessIdsAsync($version, $account_id, $return_raw_response = null, string $contentType = self::contentTypes['getBusinessIds'][0])
    {
        return $this->getBusinessIdsAsyncWithHttpInfo($version, $account_id, $return_raw_response, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBusinessIdsAsyncWithHttpInfo
     *
     * Get the user business ids
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBusinessIds'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBusinessIdsAsyncWithHttpInfo($version, $account_id, $return_raw_response = null, string $contentType = self::contentTypes['getBusinessIds'][0])
    {
        $returnType = '';
        $request = $this->getBusinessIdsRequest($version, $account_id, $return_raw_response, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBusinessIds'
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBusinessIds'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getBusinessIdsRequest($version, $account_id, $return_raw_response = null, string $contentType = self::contentTypes['getBusinessIds'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling getBusinessIds'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling getBusinessIds'
            );
        }



        $resourcePath = '/api/{version}/vatom/me/businesses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_raw_response,
            'returnRawResponse', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBusinessInfo
     *
     * Get Vatom Business Info
     *
     * @param  float $version version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string|null $vatom_parameters Vatom Parameters (optional)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBusinessInfo'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function getBusinessInfo($version, $account_id, $app_key, $vatom_parameters = null, $return_raw_response = null, string $contentType = self::contentTypes['getBusinessInfo'][0])
    {
        $this->getBusinessInfoWithHttpInfo($version, $account_id, $app_key, $vatom_parameters, $return_raw_response, $contentType);
    }

    /**
     * Operation getBusinessInfoWithHttpInfo
     *
     * Get Vatom Business Info
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string|null $vatom_parameters Vatom Parameters (optional)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBusinessInfo'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBusinessInfoWithHttpInfo($version, $account_id, $app_key, $vatom_parameters = null, $return_raw_response = null, string $contentType = self::contentTypes['getBusinessInfo'][0])
    {
        $request = $this->getBusinessInfoRequest($version, $account_id, $app_key, $vatom_parameters, $return_raw_response, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation getBusinessInfoAsync
     *
     * Get Vatom Business Info
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string|null $vatom_parameters Vatom Parameters (optional)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBusinessInfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBusinessInfoAsync($version, $account_id, $app_key, $vatom_parameters = null, $return_raw_response = null, string $contentType = self::contentTypes['getBusinessInfo'][0])
    {
        return $this->getBusinessInfoAsyncWithHttpInfo($version, $account_id, $app_key, $vatom_parameters, $return_raw_response, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBusinessInfoAsyncWithHttpInfo
     *
     * Get Vatom Business Info
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string|null $vatom_parameters Vatom Parameters (optional)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBusinessInfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBusinessInfoAsyncWithHttpInfo($version, $account_id, $app_key, $vatom_parameters = null, $return_raw_response = null, string $contentType = self::contentTypes['getBusinessInfo'][0])
    {
        $returnType = '';
        $request = $this->getBusinessInfoRequest($version, $account_id, $app_key, $vatom_parameters, $return_raw_response, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBusinessInfo'
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string|null $vatom_parameters Vatom Parameters (optional)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBusinessInfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getBusinessInfoRequest($version, $account_id, $app_key, $vatom_parameters = null, $return_raw_response = null, string $contentType = self::contentTypes['getBusinessInfo'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling getBusinessInfo'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling getBusinessInfo'
            );
        }

        // verify the required parameter 'app_key' is set
        if ($app_key === null || (is_array($app_key) && count($app_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_key when calling getBusinessInfo'
            );
        }




        $resourcePath = '/api/{version}/vatom/b/get';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $app_key,
            'appKey', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vatom_parameters,
            'vatomParameters', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_raw_response,
            'returnRawResponse', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBusinessUsers
     *
     * Get Vatom Business Users
     *
     * @param  float $version version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBusinessUsers'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function getBusinessUsers($version, $account_id, $app_key, $return_raw_response = null, string $contentType = self::contentTypes['getBusinessUsers'][0])
    {
        $this->getBusinessUsersWithHttpInfo($version, $account_id, $app_key, $return_raw_response, $contentType);
    }

    /**
     * Operation getBusinessUsersWithHttpInfo
     *
     * Get Vatom Business Users
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBusinessUsers'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBusinessUsersWithHttpInfo($version, $account_id, $app_key, $return_raw_response = null, string $contentType = self::contentTypes['getBusinessUsers'][0])
    {
        $request = $this->getBusinessUsersRequest($version, $account_id, $app_key, $return_raw_response, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation getBusinessUsersAsync
     *
     * Get Vatom Business Users
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBusinessUsers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBusinessUsersAsync($version, $account_id, $app_key, $return_raw_response = null, string $contentType = self::contentTypes['getBusinessUsers'][0])
    {
        return $this->getBusinessUsersAsyncWithHttpInfo($version, $account_id, $app_key, $return_raw_response, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBusinessUsersAsyncWithHttpInfo
     *
     * Get Vatom Business Users
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBusinessUsers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBusinessUsersAsyncWithHttpInfo($version, $account_id, $app_key, $return_raw_response = null, string $contentType = self::contentTypes['getBusinessUsers'][0])
    {
        $returnType = '';
        $request = $this->getBusinessUsersRequest($version, $account_id, $app_key, $return_raw_response, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBusinessUsers'
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBusinessUsers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getBusinessUsersRequest($version, $account_id, $app_key, $return_raw_response = null, string $contentType = self::contentTypes['getBusinessUsers'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling getBusinessUsers'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling getBusinessUsers'
            );
        }

        // verify the required parameter 'app_key' is set
        if ($app_key === null || (is_array($app_key) && count($app_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_key when calling getBusinessUsers'
            );
        }



        $resourcePath = '/api/{version}/vatom/b/users';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $app_key,
            'appKey', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_raw_response,
            'returnRawResponse', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCampaignGroupEntities
     *
     * Get Campaign Group Entities
     *
     * @param  float $version version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_campaign_id Vatom Campaign Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCampaignGroupEntities'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function getCampaignGroupEntities($version, $account_id, $app_key, $vatom_campaign_id, $return_raw_response = null, string $contentType = self::contentTypes['getCampaignGroupEntities'][0])
    {
        $this->getCampaignGroupEntitiesWithHttpInfo($version, $account_id, $app_key, $vatom_campaign_id, $return_raw_response, $contentType);
    }

    /**
     * Operation getCampaignGroupEntitiesWithHttpInfo
     *
     * Get Campaign Group Entities
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_campaign_id Vatom Campaign Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCampaignGroupEntities'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCampaignGroupEntitiesWithHttpInfo($version, $account_id, $app_key, $vatom_campaign_id, $return_raw_response = null, string $contentType = self::contentTypes['getCampaignGroupEntities'][0])
    {
        $request = $this->getCampaignGroupEntitiesRequest($version, $account_id, $app_key, $vatom_campaign_id, $return_raw_response, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation getCampaignGroupEntitiesAsync
     *
     * Get Campaign Group Entities
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_campaign_id Vatom Campaign Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCampaignGroupEntities'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCampaignGroupEntitiesAsync($version, $account_id, $app_key, $vatom_campaign_id, $return_raw_response = null, string $contentType = self::contentTypes['getCampaignGroupEntities'][0])
    {
        return $this->getCampaignGroupEntitiesAsyncWithHttpInfo($version, $account_id, $app_key, $vatom_campaign_id, $return_raw_response, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCampaignGroupEntitiesAsyncWithHttpInfo
     *
     * Get Campaign Group Entities
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_campaign_id Vatom Campaign Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCampaignGroupEntities'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCampaignGroupEntitiesAsyncWithHttpInfo($version, $account_id, $app_key, $vatom_campaign_id, $return_raw_response = null, string $contentType = self::contentTypes['getCampaignGroupEntities'][0])
    {
        $returnType = '';
        $request = $this->getCampaignGroupEntitiesRequest($version, $account_id, $app_key, $vatom_campaign_id, $return_raw_response, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCampaignGroupEntities'
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_campaign_id Vatom Campaign Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCampaignGroupEntities'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getCampaignGroupEntitiesRequest($version, $account_id, $app_key, $vatom_campaign_id, $return_raw_response = null, string $contentType = self::contentTypes['getCampaignGroupEntities'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling getCampaignGroupEntities'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling getCampaignGroupEntities'
            );
        }

        // verify the required parameter 'app_key' is set
        if ($app_key === null || (is_array($app_key) && count($app_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_key when calling getCampaignGroupEntities'
            );
        }

        // verify the required parameter 'vatom_campaign_id' is set
        if ($vatom_campaign_id === null || (is_array($vatom_campaign_id) && count($vatom_campaign_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vatom_campaign_id when calling getCampaignGroupEntities'
            );
        }



        $resourcePath = '/api/{version}/vatom/b/campaign-groups/entities';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $app_key,
            'appKey', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vatom_campaign_id,
            'vatomCampaignId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_raw_response,
            'returnRawResponse', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCampaignGroupRules
     *
     * Get Campaign Group Rules
     *
     * @param  float $version version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_campaign_id Vatom Campaign Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCampaignGroupRules'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function getCampaignGroupRules($version, $account_id, $app_key, $vatom_campaign_id, $return_raw_response = null, string $contentType = self::contentTypes['getCampaignGroupRules'][0])
    {
        $this->getCampaignGroupRulesWithHttpInfo($version, $account_id, $app_key, $vatom_campaign_id, $return_raw_response, $contentType);
    }

    /**
     * Operation getCampaignGroupRulesWithHttpInfo
     *
     * Get Campaign Group Rules
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_campaign_id Vatom Campaign Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCampaignGroupRules'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCampaignGroupRulesWithHttpInfo($version, $account_id, $app_key, $vatom_campaign_id, $return_raw_response = null, string $contentType = self::contentTypes['getCampaignGroupRules'][0])
    {
        $request = $this->getCampaignGroupRulesRequest($version, $account_id, $app_key, $vatom_campaign_id, $return_raw_response, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation getCampaignGroupRulesAsync
     *
     * Get Campaign Group Rules
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_campaign_id Vatom Campaign Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCampaignGroupRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCampaignGroupRulesAsync($version, $account_id, $app_key, $vatom_campaign_id, $return_raw_response = null, string $contentType = self::contentTypes['getCampaignGroupRules'][0])
    {
        return $this->getCampaignGroupRulesAsyncWithHttpInfo($version, $account_id, $app_key, $vatom_campaign_id, $return_raw_response, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCampaignGroupRulesAsyncWithHttpInfo
     *
     * Get Campaign Group Rules
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_campaign_id Vatom Campaign Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCampaignGroupRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCampaignGroupRulesAsyncWithHttpInfo($version, $account_id, $app_key, $vatom_campaign_id, $return_raw_response = null, string $contentType = self::contentTypes['getCampaignGroupRules'][0])
    {
        $returnType = '';
        $request = $this->getCampaignGroupRulesRequest($version, $account_id, $app_key, $vatom_campaign_id, $return_raw_response, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCampaignGroupRules'
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_campaign_id Vatom Campaign Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCampaignGroupRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getCampaignGroupRulesRequest($version, $account_id, $app_key, $vatom_campaign_id, $return_raw_response = null, string $contentType = self::contentTypes['getCampaignGroupRules'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling getCampaignGroupRules'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling getCampaignGroupRules'
            );
        }

        // verify the required parameter 'app_key' is set
        if ($app_key === null || (is_array($app_key) && count($app_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_key when calling getCampaignGroupRules'
            );
        }

        // verify the required parameter 'vatom_campaign_id' is set
        if ($vatom_campaign_id === null || (is_array($vatom_campaign_id) && count($vatom_campaign_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vatom_campaign_id when calling getCampaignGroupRules'
            );
        }



        $resourcePath = '/api/{version}/vatom/b/campaign-groups/rules';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $app_key,
            'appKey', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vatom_campaign_id,
            'vatomCampaignId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_raw_response,
            'returnRawResponse', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCampaignGroupStats
     *
     * Get Campaign Group Stats
     *
     * @param  float $version version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_campaign_id Vatom Campaign Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCampaignGroupStats'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function getCampaignGroupStats($version, $account_id, $app_key, $vatom_campaign_id, $return_raw_response = null, string $contentType = self::contentTypes['getCampaignGroupStats'][0])
    {
        $this->getCampaignGroupStatsWithHttpInfo($version, $account_id, $app_key, $vatom_campaign_id, $return_raw_response, $contentType);
    }

    /**
     * Operation getCampaignGroupStatsWithHttpInfo
     *
     * Get Campaign Group Stats
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_campaign_id Vatom Campaign Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCampaignGroupStats'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCampaignGroupStatsWithHttpInfo($version, $account_id, $app_key, $vatom_campaign_id, $return_raw_response = null, string $contentType = self::contentTypes['getCampaignGroupStats'][0])
    {
        $request = $this->getCampaignGroupStatsRequest($version, $account_id, $app_key, $vatom_campaign_id, $return_raw_response, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation getCampaignGroupStatsAsync
     *
     * Get Campaign Group Stats
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_campaign_id Vatom Campaign Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCampaignGroupStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCampaignGroupStatsAsync($version, $account_id, $app_key, $vatom_campaign_id, $return_raw_response = null, string $contentType = self::contentTypes['getCampaignGroupStats'][0])
    {
        return $this->getCampaignGroupStatsAsyncWithHttpInfo($version, $account_id, $app_key, $vatom_campaign_id, $return_raw_response, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCampaignGroupStatsAsyncWithHttpInfo
     *
     * Get Campaign Group Stats
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_campaign_id Vatom Campaign Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCampaignGroupStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCampaignGroupStatsAsyncWithHttpInfo($version, $account_id, $app_key, $vatom_campaign_id, $return_raw_response = null, string $contentType = self::contentTypes['getCampaignGroupStats'][0])
    {
        $returnType = '';
        $request = $this->getCampaignGroupStatsRequest($version, $account_id, $app_key, $vatom_campaign_id, $return_raw_response, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCampaignGroupStats'
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_campaign_id Vatom Campaign Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCampaignGroupStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getCampaignGroupStatsRequest($version, $account_id, $app_key, $vatom_campaign_id, $return_raw_response = null, string $contentType = self::contentTypes['getCampaignGroupStats'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling getCampaignGroupStats'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling getCampaignGroupStats'
            );
        }

        // verify the required parameter 'app_key' is set
        if ($app_key === null || (is_array($app_key) && count($app_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_key when calling getCampaignGroupStats'
            );
        }

        // verify the required parameter 'vatom_campaign_id' is set
        if ($vatom_campaign_id === null || (is_array($vatom_campaign_id) && count($vatom_campaign_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vatom_campaign_id when calling getCampaignGroupStats'
            );
        }



        $resourcePath = '/api/{version}/vatom/b/campaign-groups/stats';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $app_key,
            'appKey', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vatom_campaign_id,
            'vatomCampaignId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_raw_response,
            'returnRawResponse', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCampaignInfo
     *
     * Get Campaign Info
     *
     * @param  float $version version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_campaign_id Vatom Campaign Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCampaignInfo'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function getCampaignInfo($version, $account_id, $app_key, $vatom_campaign_id, $return_raw_response = null, string $contentType = self::contentTypes['getCampaignInfo'][0])
    {
        $this->getCampaignInfoWithHttpInfo($version, $account_id, $app_key, $vatom_campaign_id, $return_raw_response, $contentType);
    }

    /**
     * Operation getCampaignInfoWithHttpInfo
     *
     * Get Campaign Info
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_campaign_id Vatom Campaign Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCampaignInfo'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCampaignInfoWithHttpInfo($version, $account_id, $app_key, $vatom_campaign_id, $return_raw_response = null, string $contentType = self::contentTypes['getCampaignInfo'][0])
    {
        $request = $this->getCampaignInfoRequest($version, $account_id, $app_key, $vatom_campaign_id, $return_raw_response, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation getCampaignInfoAsync
     *
     * Get Campaign Info
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_campaign_id Vatom Campaign Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCampaignInfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCampaignInfoAsync($version, $account_id, $app_key, $vatom_campaign_id, $return_raw_response = null, string $contentType = self::contentTypes['getCampaignInfo'][0])
    {
        return $this->getCampaignInfoAsyncWithHttpInfo($version, $account_id, $app_key, $vatom_campaign_id, $return_raw_response, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCampaignInfoAsyncWithHttpInfo
     *
     * Get Campaign Info
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_campaign_id Vatom Campaign Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCampaignInfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCampaignInfoAsyncWithHttpInfo($version, $account_id, $app_key, $vatom_campaign_id, $return_raw_response = null, string $contentType = self::contentTypes['getCampaignInfo'][0])
    {
        $returnType = '';
        $request = $this->getCampaignInfoRequest($version, $account_id, $app_key, $vatom_campaign_id, $return_raw_response, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCampaignInfo'
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_campaign_id Vatom Campaign Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCampaignInfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getCampaignInfoRequest($version, $account_id, $app_key, $vatom_campaign_id, $return_raw_response = null, string $contentType = self::contentTypes['getCampaignInfo'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling getCampaignInfo'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling getCampaignInfo'
            );
        }

        // verify the required parameter 'app_key' is set
        if ($app_key === null || (is_array($app_key) && count($app_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_key when calling getCampaignInfo'
            );
        }

        // verify the required parameter 'vatom_campaign_id' is set
        if ($vatom_campaign_id === null || (is_array($vatom_campaign_id) && count($vatom_campaign_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vatom_campaign_id when calling getCampaignInfo'
            );
        }



        $resourcePath = '/api/{version}/vatom/b/campaign-groups/get';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $app_key,
            'appKey', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vatom_campaign_id,
            'vatomCampaignId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_raw_response,
            'returnRawResponse', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getEventGuestList
     *
     * Get Vatom Event Guest List
     *
     * @param  float $version version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_event_id Vatom Event Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEventGuestList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function getEventGuestList($version, $account_id, $app_key, $vatom_event_id, $return_raw_response = null, string $contentType = self::contentTypes['getEventGuestList'][0])
    {
        $this->getEventGuestListWithHttpInfo($version, $account_id, $app_key, $vatom_event_id, $return_raw_response, $contentType);
    }

    /**
     * Operation getEventGuestListWithHttpInfo
     *
     * Get Vatom Event Guest List
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_event_id Vatom Event Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEventGuestList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getEventGuestListWithHttpInfo($version, $account_id, $app_key, $vatom_event_id, $return_raw_response = null, string $contentType = self::contentTypes['getEventGuestList'][0])
    {
        $request = $this->getEventGuestListRequest($version, $account_id, $app_key, $vatom_event_id, $return_raw_response, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation getEventGuestListAsync
     *
     * Get Vatom Event Guest List
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_event_id Vatom Event Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEventGuestList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEventGuestListAsync($version, $account_id, $app_key, $vatom_event_id, $return_raw_response = null, string $contentType = self::contentTypes['getEventGuestList'][0])
    {
        return $this->getEventGuestListAsyncWithHttpInfo($version, $account_id, $app_key, $vatom_event_id, $return_raw_response, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getEventGuestListAsyncWithHttpInfo
     *
     * Get Vatom Event Guest List
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_event_id Vatom Event Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEventGuestList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEventGuestListAsyncWithHttpInfo($version, $account_id, $app_key, $vatom_event_id, $return_raw_response = null, string $contentType = self::contentTypes['getEventGuestList'][0])
    {
        $returnType = '';
        $request = $this->getEventGuestListRequest($version, $account_id, $app_key, $vatom_event_id, $return_raw_response, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getEventGuestList'
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_event_id Vatom Event Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEventGuestList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getEventGuestListRequest($version, $account_id, $app_key, $vatom_event_id, $return_raw_response = null, string $contentType = self::contentTypes['getEventGuestList'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling getEventGuestList'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling getEventGuestList'
            );
        }

        // verify the required parameter 'app_key' is set
        if ($app_key === null || (is_array($app_key) && count($app_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_key when calling getEventGuestList'
            );
        }

        // verify the required parameter 'vatom_event_id' is set
        if ($vatom_event_id === null || (is_array($vatom_event_id) && count($vatom_event_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vatom_event_id when calling getEventGuestList'
            );
        }



        $resourcePath = '/api/{version}/vatom/b/events/guests/get';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $app_key,
            'appKey', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vatom_event_id,
            'vatomEventId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_raw_response,
            'returnRawResponse', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getInventory
     *
     * Get Vatom User&#39;s Inventory
     *
     * @param  float $version version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getInventory'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function getInventory($version, $account_id, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['getInventory'][0])
    {
        $this->getInventoryWithHttpInfo($version, $account_id, $vatom_parameters, $return_raw_response, $contentType);
    }

    /**
     * Operation getInventoryWithHttpInfo
     *
     * Get Vatom User&#39;s Inventory
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getInventory'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getInventoryWithHttpInfo($version, $account_id, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['getInventory'][0])
    {
        $request = $this->getInventoryRequest($version, $account_id, $vatom_parameters, $return_raw_response, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation getInventoryAsync
     *
     * Get Vatom User&#39;s Inventory
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getInventory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInventoryAsync($version, $account_id, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['getInventory'][0])
    {
        return $this->getInventoryAsyncWithHttpInfo($version, $account_id, $vatom_parameters, $return_raw_response, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getInventoryAsyncWithHttpInfo
     *
     * Get Vatom User&#39;s Inventory
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getInventory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInventoryAsyncWithHttpInfo($version, $account_id, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['getInventory'][0])
    {
        $returnType = '';
        $request = $this->getInventoryRequest($version, $account_id, $vatom_parameters, $return_raw_response, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getInventory'
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getInventory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getInventoryRequest($version, $account_id, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['getInventory'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling getInventory'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling getInventory'
            );
        }

        // verify the required parameter 'vatom_parameters' is set
        if ($vatom_parameters === null || (is_array($vatom_parameters) && count($vatom_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vatom_parameters when calling getInventory'
            );
        }



        $resourcePath = '/api/{version}/vatom/me/inventory';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vatom_parameters,
            'vatomParameters', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_raw_response,
            'returnRawResponse', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getMyFollowing
     *
     * Get following
     *
     * @param  float $version version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMyFollowing'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function getMyFollowing($version, $account_id, $return_raw_response = null, string $contentType = self::contentTypes['getMyFollowing'][0])
    {
        $this->getMyFollowingWithHttpInfo($version, $account_id, $return_raw_response, $contentType);
    }

    /**
     * Operation getMyFollowingWithHttpInfo
     *
     * Get following
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMyFollowing'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getMyFollowingWithHttpInfo($version, $account_id, $return_raw_response = null, string $contentType = self::contentTypes['getMyFollowing'][0])
    {
        $request = $this->getMyFollowingRequest($version, $account_id, $return_raw_response, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation getMyFollowingAsync
     *
     * Get following
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMyFollowing'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMyFollowingAsync($version, $account_id, $return_raw_response = null, string $contentType = self::contentTypes['getMyFollowing'][0])
    {
        return $this->getMyFollowingAsyncWithHttpInfo($version, $account_id, $return_raw_response, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getMyFollowingAsyncWithHttpInfo
     *
     * Get following
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMyFollowing'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMyFollowingAsyncWithHttpInfo($version, $account_id, $return_raw_response = null, string $contentType = self::contentTypes['getMyFollowing'][0])
    {
        $returnType = '';
        $request = $this->getMyFollowingRequest($version, $account_id, $return_raw_response, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getMyFollowing'
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMyFollowing'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getMyFollowingRequest($version, $account_id, $return_raw_response = null, string $contentType = self::contentTypes['getMyFollowing'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling getMyFollowing'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling getMyFollowing'
            );
        }



        $resourcePath = '/api/{version}/vatom/me/rels/following';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_raw_response,
            'returnRawResponse', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPointsBalance
     *
     * Get Points Balance
     *
     * @param  float $version version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_user_id Vatom User Id (required)
     * @param  string $vatom_campaign_id Vatom Campaign Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPointsBalance'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function getPointsBalance($version, $account_id, $vatom_user_id, $vatom_campaign_id, $return_raw_response = null, string $contentType = self::contentTypes['getPointsBalance'][0])
    {
        $this->getPointsBalanceWithHttpInfo($version, $account_id, $vatom_user_id, $vatom_campaign_id, $return_raw_response, $contentType);
    }

    /**
     * Operation getPointsBalanceWithHttpInfo
     *
     * Get Points Balance
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_user_id Vatom User Id (required)
     * @param  string $vatom_campaign_id Vatom Campaign Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPointsBalance'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPointsBalanceWithHttpInfo($version, $account_id, $vatom_user_id, $vatom_campaign_id, $return_raw_response = null, string $contentType = self::contentTypes['getPointsBalance'][0])
    {
        $request = $this->getPointsBalanceRequest($version, $account_id, $vatom_user_id, $vatom_campaign_id, $return_raw_response, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation getPointsBalanceAsync
     *
     * Get Points Balance
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_user_id Vatom User Id (required)
     * @param  string $vatom_campaign_id Vatom Campaign Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPointsBalance'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPointsBalanceAsync($version, $account_id, $vatom_user_id, $vatom_campaign_id, $return_raw_response = null, string $contentType = self::contentTypes['getPointsBalance'][0])
    {
        return $this->getPointsBalanceAsyncWithHttpInfo($version, $account_id, $vatom_user_id, $vatom_campaign_id, $return_raw_response, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPointsBalanceAsyncWithHttpInfo
     *
     * Get Points Balance
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_user_id Vatom User Id (required)
     * @param  string $vatom_campaign_id Vatom Campaign Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPointsBalance'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPointsBalanceAsyncWithHttpInfo($version, $account_id, $vatom_user_id, $vatom_campaign_id, $return_raw_response = null, string $contentType = self::contentTypes['getPointsBalance'][0])
    {
        $returnType = '';
        $request = $this->getPointsBalanceRequest($version, $account_id, $vatom_user_id, $vatom_campaign_id, $return_raw_response, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPointsBalance'
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_user_id Vatom User Id (required)
     * @param  string $vatom_campaign_id Vatom Campaign Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPointsBalance'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getPointsBalanceRequest($version, $account_id, $vatom_user_id, $vatom_campaign_id, $return_raw_response = null, string $contentType = self::contentTypes['getPointsBalance'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling getPointsBalance'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling getPointsBalance'
            );
        }

        // verify the required parameter 'vatom_user_id' is set
        if ($vatom_user_id === null || (is_array($vatom_user_id) && count($vatom_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vatom_user_id when calling getPointsBalance'
            );
        }

        // verify the required parameter 'vatom_campaign_id' is set
        if ($vatom_campaign_id === null || (is_array($vatom_campaign_id) && count($vatom_campaign_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vatom_campaign_id when calling getPointsBalance'
            );
        }



        $resourcePath = '/api/{version}/vatom/u/campaign/points/get';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vatom_user_id,
            'vatomUserId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vatom_campaign_id,
            'vatomCampaignId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_raw_response,
            'returnRawResponse', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPointsBalanceAsBusiness
     *
     * Get Points Balance as Business
     *
     * @param  float $version version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_user_id Vatom User Id (required)
     * @param  string $vatom_campaign_id Vatom Campaign Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPointsBalanceAsBusiness'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function getPointsBalanceAsBusiness($version, $account_id, $app_key, $vatom_user_id, $vatom_campaign_id, $return_raw_response = null, string $contentType = self::contentTypes['getPointsBalanceAsBusiness'][0])
    {
        $this->getPointsBalanceAsBusinessWithHttpInfo($version, $account_id, $app_key, $vatom_user_id, $vatom_campaign_id, $return_raw_response, $contentType);
    }

    /**
     * Operation getPointsBalanceAsBusinessWithHttpInfo
     *
     * Get Points Balance as Business
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_user_id Vatom User Id (required)
     * @param  string $vatom_campaign_id Vatom Campaign Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPointsBalanceAsBusiness'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPointsBalanceAsBusinessWithHttpInfo($version, $account_id, $app_key, $vatom_user_id, $vatom_campaign_id, $return_raw_response = null, string $contentType = self::contentTypes['getPointsBalanceAsBusiness'][0])
    {
        $request = $this->getPointsBalanceAsBusinessRequest($version, $account_id, $app_key, $vatom_user_id, $vatom_campaign_id, $return_raw_response, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation getPointsBalanceAsBusinessAsync
     *
     * Get Points Balance as Business
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_user_id Vatom User Id (required)
     * @param  string $vatom_campaign_id Vatom Campaign Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPointsBalanceAsBusiness'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPointsBalanceAsBusinessAsync($version, $account_id, $app_key, $vatom_user_id, $vatom_campaign_id, $return_raw_response = null, string $contentType = self::contentTypes['getPointsBalanceAsBusiness'][0])
    {
        return $this->getPointsBalanceAsBusinessAsyncWithHttpInfo($version, $account_id, $app_key, $vatom_user_id, $vatom_campaign_id, $return_raw_response, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPointsBalanceAsBusinessAsyncWithHttpInfo
     *
     * Get Points Balance as Business
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_user_id Vatom User Id (required)
     * @param  string $vatom_campaign_id Vatom Campaign Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPointsBalanceAsBusiness'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPointsBalanceAsBusinessAsyncWithHttpInfo($version, $account_id, $app_key, $vatom_user_id, $vatom_campaign_id, $return_raw_response = null, string $contentType = self::contentTypes['getPointsBalanceAsBusiness'][0])
    {
        $returnType = '';
        $request = $this->getPointsBalanceAsBusinessRequest($version, $account_id, $app_key, $vatom_user_id, $vatom_campaign_id, $return_raw_response, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPointsBalanceAsBusiness'
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_user_id Vatom User Id (required)
     * @param  string $vatom_campaign_id Vatom Campaign Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPointsBalanceAsBusiness'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getPointsBalanceAsBusinessRequest($version, $account_id, $app_key, $vatom_user_id, $vatom_campaign_id, $return_raw_response = null, string $contentType = self::contentTypes['getPointsBalanceAsBusiness'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling getPointsBalanceAsBusiness'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling getPointsBalanceAsBusiness'
            );
        }

        // verify the required parameter 'app_key' is set
        if ($app_key === null || (is_array($app_key) && count($app_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_key when calling getPointsBalanceAsBusiness'
            );
        }

        // verify the required parameter 'vatom_user_id' is set
        if ($vatom_user_id === null || (is_array($vatom_user_id) && count($vatom_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vatom_user_id when calling getPointsBalanceAsBusiness'
            );
        }

        // verify the required parameter 'vatom_campaign_id' is set
        if ($vatom_campaign_id === null || (is_array($vatom_campaign_id) && count($vatom_campaign_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vatom_campaign_id when calling getPointsBalanceAsBusiness'
            );
        }



        $resourcePath = '/api/{version}/vatom/b/campaign/u/points/get';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $app_key,
            'appKey', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vatom_user_id,
            'vatomUserId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vatom_campaign_id,
            'vatomCampaignId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_raw_response,
            'returnRawResponse', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSpace
     *
     * Get Vatom Space
     *
     * @param  float $version version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_space_id Vatom Space Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSpace'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function getSpace($version, $account_id, $app_key, $vatom_space_id, $return_raw_response = null, string $contentType = self::contentTypes['getSpace'][0])
    {
        $this->getSpaceWithHttpInfo($version, $account_id, $app_key, $vatom_space_id, $return_raw_response, $contentType);
    }

    /**
     * Operation getSpaceWithHttpInfo
     *
     * Get Vatom Space
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_space_id Vatom Space Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSpace'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSpaceWithHttpInfo($version, $account_id, $app_key, $vatom_space_id, $return_raw_response = null, string $contentType = self::contentTypes['getSpace'][0])
    {
        $request = $this->getSpaceRequest($version, $account_id, $app_key, $vatom_space_id, $return_raw_response, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation getSpaceAsync
     *
     * Get Vatom Space
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_space_id Vatom Space Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSpaceAsync($version, $account_id, $app_key, $vatom_space_id, $return_raw_response = null, string $contentType = self::contentTypes['getSpace'][0])
    {
        return $this->getSpaceAsyncWithHttpInfo($version, $account_id, $app_key, $vatom_space_id, $return_raw_response, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSpaceAsyncWithHttpInfo
     *
     * Get Vatom Space
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_space_id Vatom Space Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSpaceAsyncWithHttpInfo($version, $account_id, $app_key, $vatom_space_id, $return_raw_response = null, string $contentType = self::contentTypes['getSpace'][0])
    {
        $returnType = '';
        $request = $this->getSpaceRequest($version, $account_id, $app_key, $vatom_space_id, $return_raw_response, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSpace'
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_space_id Vatom Space Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getSpaceRequest($version, $account_id, $app_key, $vatom_space_id, $return_raw_response = null, string $contentType = self::contentTypes['getSpace'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling getSpace'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling getSpace'
            );
        }

        // verify the required parameter 'app_key' is set
        if ($app_key === null || (is_array($app_key) && count($app_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_key when calling getSpace'
            );
        }

        // verify the required parameter 'vatom_space_id' is set
        if ($vatom_space_id === null || (is_array($vatom_space_id) && count($vatom_space_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vatom_space_id when calling getSpace'
            );
        }



        $resourcePath = '/api/{version}/vatom/b/spaces/get';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $app_key,
            'appKey', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vatom_space_id,
            'vatomSpaceId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_raw_response,
            'returnRawResponse', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getUserCoinsAsBusiness
     *
     * Get the coins for a user (as a Business)
     *
     * @param  float $version version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_user_id Vatom User Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserCoinsAsBusiness'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function getUserCoinsAsBusiness($version, $account_id, $vatom_user_id, $app_key, $return_raw_response = null, string $contentType = self::contentTypes['getUserCoinsAsBusiness'][0])
    {
        $this->getUserCoinsAsBusinessWithHttpInfo($version, $account_id, $vatom_user_id, $app_key, $return_raw_response, $contentType);
    }

    /**
     * Operation getUserCoinsAsBusinessWithHttpInfo
     *
     * Get the coins for a user (as a Business)
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_user_id Vatom User Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserCoinsAsBusiness'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getUserCoinsAsBusinessWithHttpInfo($version, $account_id, $vatom_user_id, $app_key, $return_raw_response = null, string $contentType = self::contentTypes['getUserCoinsAsBusiness'][0])
    {
        $request = $this->getUserCoinsAsBusinessRequest($version, $account_id, $vatom_user_id, $app_key, $return_raw_response, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation getUserCoinsAsBusinessAsync
     *
     * Get the coins for a user (as a Business)
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_user_id Vatom User Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserCoinsAsBusiness'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUserCoinsAsBusinessAsync($version, $account_id, $vatom_user_id, $app_key, $return_raw_response = null, string $contentType = self::contentTypes['getUserCoinsAsBusiness'][0])
    {
        return $this->getUserCoinsAsBusinessAsyncWithHttpInfo($version, $account_id, $vatom_user_id, $app_key, $return_raw_response, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getUserCoinsAsBusinessAsyncWithHttpInfo
     *
     * Get the coins for a user (as a Business)
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_user_id Vatom User Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserCoinsAsBusiness'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUserCoinsAsBusinessAsyncWithHttpInfo($version, $account_id, $vatom_user_id, $app_key, $return_raw_response = null, string $contentType = self::contentTypes['getUserCoinsAsBusiness'][0])
    {
        $returnType = '';
        $request = $this->getUserCoinsAsBusinessRequest($version, $account_id, $vatom_user_id, $app_key, $return_raw_response, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getUserCoinsAsBusiness'
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_user_id Vatom User Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserCoinsAsBusiness'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getUserCoinsAsBusinessRequest($version, $account_id, $vatom_user_id, $app_key, $return_raw_response = null, string $contentType = self::contentTypes['getUserCoinsAsBusiness'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling getUserCoinsAsBusiness'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling getUserCoinsAsBusiness'
            );
        }

        // verify the required parameter 'vatom_user_id' is set
        if ($vatom_user_id === null || (is_array($vatom_user_id) && count($vatom_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vatom_user_id when calling getUserCoinsAsBusiness'
            );
        }

        // verify the required parameter 'app_key' is set
        if ($app_key === null || (is_array($app_key) && count($app_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_key when calling getUserCoinsAsBusiness'
            );
        }



        $resourcePath = '/api/{version}/vatom/b/users/coins/get';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vatom_user_id,
            'vatomUserId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $app_key,
            'appKey', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_raw_response,
            'returnRawResponse', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getUserCoinsBalance
     *
     * Gets the coins balance for a Vatom User
     *
     * @param  float $version version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_user_id Vatom User Id (required)
     * @param  string|null $vatom_parameters Vatom Parameters (optional)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserCoinsBalance'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function getUserCoinsBalance($version, $account_id, $vatom_user_id, $vatom_parameters = null, $return_raw_response = null, string $contentType = self::contentTypes['getUserCoinsBalance'][0])
    {
        $this->getUserCoinsBalanceWithHttpInfo($version, $account_id, $vatom_user_id, $vatom_parameters, $return_raw_response, $contentType);
    }

    /**
     * Operation getUserCoinsBalanceWithHttpInfo
     *
     * Gets the coins balance for a Vatom User
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_user_id Vatom User Id (required)
     * @param  string|null $vatom_parameters Vatom Parameters (optional)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserCoinsBalance'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getUserCoinsBalanceWithHttpInfo($version, $account_id, $vatom_user_id, $vatom_parameters = null, $return_raw_response = null, string $contentType = self::contentTypes['getUserCoinsBalance'][0])
    {
        $request = $this->getUserCoinsBalanceRequest($version, $account_id, $vatom_user_id, $vatom_parameters, $return_raw_response, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation getUserCoinsBalanceAsync
     *
     * Gets the coins balance for a Vatom User
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_user_id Vatom User Id (required)
     * @param  string|null $vatom_parameters Vatom Parameters (optional)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserCoinsBalance'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUserCoinsBalanceAsync($version, $account_id, $vatom_user_id, $vatom_parameters = null, $return_raw_response = null, string $contentType = self::contentTypes['getUserCoinsBalance'][0])
    {
        return $this->getUserCoinsBalanceAsyncWithHttpInfo($version, $account_id, $vatom_user_id, $vatom_parameters, $return_raw_response, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getUserCoinsBalanceAsyncWithHttpInfo
     *
     * Gets the coins balance for a Vatom User
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_user_id Vatom User Id (required)
     * @param  string|null $vatom_parameters Vatom Parameters (optional)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserCoinsBalance'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUserCoinsBalanceAsyncWithHttpInfo($version, $account_id, $vatom_user_id, $vatom_parameters = null, $return_raw_response = null, string $contentType = self::contentTypes['getUserCoinsBalance'][0])
    {
        $returnType = '';
        $request = $this->getUserCoinsBalanceRequest($version, $account_id, $vatom_user_id, $vatom_parameters, $return_raw_response, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getUserCoinsBalance'
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_user_id Vatom User Id (required)
     * @param  string|null $vatom_parameters Vatom Parameters (optional)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserCoinsBalance'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getUserCoinsBalanceRequest($version, $account_id, $vatom_user_id, $vatom_parameters = null, $return_raw_response = null, string $contentType = self::contentTypes['getUserCoinsBalance'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling getUserCoinsBalance'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling getUserCoinsBalance'
            );
        }

        // verify the required parameter 'vatom_user_id' is set
        if ($vatom_user_id === null || (is_array($vatom_user_id) && count($vatom_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vatom_user_id when calling getUserCoinsBalance'
            );
        }




        $resourcePath = '/api/{version}/vatom/u/coins/get';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vatom_user_id,
            'vatomUserId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vatom_parameters,
            'vatomParameters', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_raw_response,
            'returnRawResponse', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getUserFollowers
     *
     * Get user followers
     *
     * @param  float $version version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_user_id Vatom User Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserFollowers'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function getUserFollowers($version, $account_id, $vatom_user_id, $return_raw_response = null, string $contentType = self::contentTypes['getUserFollowers'][0])
    {
        $this->getUserFollowersWithHttpInfo($version, $account_id, $vatom_user_id, $return_raw_response, $contentType);
    }

    /**
     * Operation getUserFollowersWithHttpInfo
     *
     * Get user followers
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_user_id Vatom User Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserFollowers'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getUserFollowersWithHttpInfo($version, $account_id, $vatom_user_id, $return_raw_response = null, string $contentType = self::contentTypes['getUserFollowers'][0])
    {
        $request = $this->getUserFollowersRequest($version, $account_id, $vatom_user_id, $return_raw_response, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation getUserFollowersAsync
     *
     * Get user followers
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_user_id Vatom User Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserFollowers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUserFollowersAsync($version, $account_id, $vatom_user_id, $return_raw_response = null, string $contentType = self::contentTypes['getUserFollowers'][0])
    {
        return $this->getUserFollowersAsyncWithHttpInfo($version, $account_id, $vatom_user_id, $return_raw_response, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getUserFollowersAsyncWithHttpInfo
     *
     * Get user followers
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_user_id Vatom User Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserFollowers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUserFollowersAsyncWithHttpInfo($version, $account_id, $vatom_user_id, $return_raw_response = null, string $contentType = self::contentTypes['getUserFollowers'][0])
    {
        $returnType = '';
        $request = $this->getUserFollowersRequest($version, $account_id, $vatom_user_id, $return_raw_response, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getUserFollowers'
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_user_id Vatom User Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserFollowers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getUserFollowersRequest($version, $account_id, $vatom_user_id, $return_raw_response = null, string $contentType = self::contentTypes['getUserFollowers'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling getUserFollowers'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling getUserFollowers'
            );
        }

        // verify the required parameter 'vatom_user_id' is set
        if ($vatom_user_id === null || (is_array($vatom_user_id) && count($vatom_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vatom_user_id when calling getUserFollowers'
            );
        }



        $resourcePath = '/api/{version}/vatom/users/rels/followers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vatom_user_id,
            'vatomUserId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_raw_response,
            'returnRawResponse', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getUserFollowing
     *
     * Get user following
     *
     * @param  float $version version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_user_id Vatom User Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserFollowing'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function getUserFollowing($version, $account_id, $vatom_user_id, $return_raw_response = null, string $contentType = self::contentTypes['getUserFollowing'][0])
    {
        $this->getUserFollowingWithHttpInfo($version, $account_id, $vatom_user_id, $return_raw_response, $contentType);
    }

    /**
     * Operation getUserFollowingWithHttpInfo
     *
     * Get user following
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_user_id Vatom User Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserFollowing'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getUserFollowingWithHttpInfo($version, $account_id, $vatom_user_id, $return_raw_response = null, string $contentType = self::contentTypes['getUserFollowing'][0])
    {
        $request = $this->getUserFollowingRequest($version, $account_id, $vatom_user_id, $return_raw_response, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation getUserFollowingAsync
     *
     * Get user following
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_user_id Vatom User Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserFollowing'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUserFollowingAsync($version, $account_id, $vatom_user_id, $return_raw_response = null, string $contentType = self::contentTypes['getUserFollowing'][0])
    {
        return $this->getUserFollowingAsyncWithHttpInfo($version, $account_id, $vatom_user_id, $return_raw_response, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getUserFollowingAsyncWithHttpInfo
     *
     * Get user following
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_user_id Vatom User Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserFollowing'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUserFollowingAsyncWithHttpInfo($version, $account_id, $vatom_user_id, $return_raw_response = null, string $contentType = self::contentTypes['getUserFollowing'][0])
    {
        $returnType = '';
        $request = $this->getUserFollowingRequest($version, $account_id, $vatom_user_id, $return_raw_response, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getUserFollowing'
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_user_id Vatom User Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserFollowing'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getUserFollowingRequest($version, $account_id, $vatom_user_id, $return_raw_response = null, string $contentType = self::contentTypes['getUserFollowing'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling getUserFollowing'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling getUserFollowing'
            );
        }

        // verify the required parameter 'vatom_user_id' is set
        if ($vatom_user_id === null || (is_array($vatom_user_id) && count($vatom_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vatom_user_id when calling getUserFollowing'
            );
        }



        $resourcePath = '/api/{version}/vatom/users/rels/following';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vatom_user_id,
            'vatomUserId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_raw_response,
            'returnRawResponse', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getUserInfo
     *
     * Get User Info
     *
     * @param  float $version version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_user_id Vatom User Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserInfo'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function getUserInfo($version, $account_id, $vatom_user_id, $return_raw_response = null, string $contentType = self::contentTypes['getUserInfo'][0])
    {
        $this->getUserInfoWithHttpInfo($version, $account_id, $vatom_user_id, $return_raw_response, $contentType);
    }

    /**
     * Operation getUserInfoWithHttpInfo
     *
     * Get User Info
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_user_id Vatom User Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserInfo'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getUserInfoWithHttpInfo($version, $account_id, $vatom_user_id, $return_raw_response = null, string $contentType = self::contentTypes['getUserInfo'][0])
    {
        $request = $this->getUserInfoRequest($version, $account_id, $vatom_user_id, $return_raw_response, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation getUserInfoAsync
     *
     * Get User Info
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_user_id Vatom User Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserInfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUserInfoAsync($version, $account_id, $vatom_user_id, $return_raw_response = null, string $contentType = self::contentTypes['getUserInfo'][0])
    {
        return $this->getUserInfoAsyncWithHttpInfo($version, $account_id, $vatom_user_id, $return_raw_response, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getUserInfoAsyncWithHttpInfo
     *
     * Get User Info
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_user_id Vatom User Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserInfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUserInfoAsyncWithHttpInfo($version, $account_id, $vatom_user_id, $return_raw_response = null, string $contentType = self::contentTypes['getUserInfo'][0])
    {
        $returnType = '';
        $request = $this->getUserInfoRequest($version, $account_id, $vatom_user_id, $return_raw_response, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getUserInfo'
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_user_id Vatom User Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserInfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getUserInfoRequest($version, $account_id, $vatom_user_id, $return_raw_response = null, string $contentType = self::contentTypes['getUserInfo'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling getUserInfo'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling getUserInfo'
            );
        }

        // verify the required parameter 'vatom_user_id' is set
        if ($vatom_user_id === null || (is_array($vatom_user_id) && count($vatom_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vatom_user_id when calling getUserInfo'
            );
        }



        $resourcePath = '/api/{version}/vatom/user/get';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vatom_user_id,
            'vatomUserId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_raw_response,
            'returnRawResponse', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getUserProfile
     *
     * Get Vatom User Profile
     *
     * @param  float $version version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserProfile'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function getUserProfile($version, $account_id, $return_raw_response = null, string $contentType = self::contentTypes['getUserProfile'][0])
    {
        $this->getUserProfileWithHttpInfo($version, $account_id, $return_raw_response, $contentType);
    }

    /**
     * Operation getUserProfileWithHttpInfo
     *
     * Get Vatom User Profile
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserProfile'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getUserProfileWithHttpInfo($version, $account_id, $return_raw_response = null, string $contentType = self::contentTypes['getUserProfile'][0])
    {
        $request = $this->getUserProfileRequest($version, $account_id, $return_raw_response, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation getUserProfileAsync
     *
     * Get Vatom User Profile
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUserProfileAsync($version, $account_id, $return_raw_response = null, string $contentType = self::contentTypes['getUserProfile'][0])
    {
        return $this->getUserProfileAsyncWithHttpInfo($version, $account_id, $return_raw_response, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getUserProfileAsyncWithHttpInfo
     *
     * Get Vatom User Profile
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUserProfileAsyncWithHttpInfo($version, $account_id, $return_raw_response = null, string $contentType = self::contentTypes['getUserProfile'][0])
    {
        $returnType = '';
        $request = $this->getUserProfileRequest($version, $account_id, $return_raw_response, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getUserProfile'
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getUserProfileRequest($version, $account_id, $return_raw_response = null, string $contentType = self::contentTypes['getUserProfile'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling getUserProfile'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling getUserProfile'
            );
        }



        $resourcePath = '/api/{version}/vatom/me/get';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_raw_response,
            'returnRawResponse', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getVatomEvent
     *
     * Get Vatom Event
     *
     * @param  float $version version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_event_id Vatom Event Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVatomEvent'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function getVatomEvent($version, $account_id, $app_key, $vatom_event_id, $return_raw_response = null, string $contentType = self::contentTypes['getVatomEvent'][0])
    {
        $this->getVatomEventWithHttpInfo($version, $account_id, $app_key, $vatom_event_id, $return_raw_response, $contentType);
    }

    /**
     * Operation getVatomEventWithHttpInfo
     *
     * Get Vatom Event
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_event_id Vatom Event Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVatomEvent'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getVatomEventWithHttpInfo($version, $account_id, $app_key, $vatom_event_id, $return_raw_response = null, string $contentType = self::contentTypes['getVatomEvent'][0])
    {
        $request = $this->getVatomEventRequest($version, $account_id, $app_key, $vatom_event_id, $return_raw_response, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation getVatomEventAsync
     *
     * Get Vatom Event
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_event_id Vatom Event Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVatomEvent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVatomEventAsync($version, $account_id, $app_key, $vatom_event_id, $return_raw_response = null, string $contentType = self::contentTypes['getVatomEvent'][0])
    {
        return $this->getVatomEventAsyncWithHttpInfo($version, $account_id, $app_key, $vatom_event_id, $return_raw_response, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getVatomEventAsyncWithHttpInfo
     *
     * Get Vatom Event
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_event_id Vatom Event Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVatomEvent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVatomEventAsyncWithHttpInfo($version, $account_id, $app_key, $vatom_event_id, $return_raw_response = null, string $contentType = self::contentTypes['getVatomEvent'][0])
    {
        $returnType = '';
        $request = $this->getVatomEventRequest($version, $account_id, $app_key, $vatom_event_id, $return_raw_response, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getVatomEvent'
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_event_id Vatom Event Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVatomEvent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getVatomEventRequest($version, $account_id, $app_key, $vatom_event_id, $return_raw_response = null, string $contentType = self::contentTypes['getVatomEvent'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling getVatomEvent'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling getVatomEvent'
            );
        }

        // verify the required parameter 'app_key' is set
        if ($app_key === null || (is_array($app_key) && count($app_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_key when calling getVatomEvent'
            );
        }

        // verify the required parameter 'vatom_event_id' is set
        if ($vatom_event_id === null || (is_array($vatom_event_id) && count($vatom_event_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vatom_event_id when calling getVatomEvent'
            );
        }



        $resourcePath = '/api/{version}/vatom/b/events/get';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $app_key,
            'appKey', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vatom_event_id,
            'vatomEventId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_raw_response,
            'returnRawResponse', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getVatomNFT
     *
     * Get Vatom NFT Details
     *
     * @param  float $version version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_id Vatom NFT Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVatomNFT'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function getVatomNFT($version, $account_id, $vatom_id, $return_raw_response = null, string $contentType = self::contentTypes['getVatomNFT'][0])
    {
        $this->getVatomNFTWithHttpInfo($version, $account_id, $vatom_id, $return_raw_response, $contentType);
    }

    /**
     * Operation getVatomNFTWithHttpInfo
     *
     * Get Vatom NFT Details
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_id Vatom NFT Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVatomNFT'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getVatomNFTWithHttpInfo($version, $account_id, $vatom_id, $return_raw_response = null, string $contentType = self::contentTypes['getVatomNFT'][0])
    {
        $request = $this->getVatomNFTRequest($version, $account_id, $vatom_id, $return_raw_response, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation getVatomNFTAsync
     *
     * Get Vatom NFT Details
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_id Vatom NFT Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVatomNFT'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVatomNFTAsync($version, $account_id, $vatom_id, $return_raw_response = null, string $contentType = self::contentTypes['getVatomNFT'][0])
    {
        return $this->getVatomNFTAsyncWithHttpInfo($version, $account_id, $vatom_id, $return_raw_response, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getVatomNFTAsyncWithHttpInfo
     *
     * Get Vatom NFT Details
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_id Vatom NFT Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVatomNFT'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVatomNFTAsyncWithHttpInfo($version, $account_id, $vatom_id, $return_raw_response = null, string $contentType = self::contentTypes['getVatomNFT'][0])
    {
        $returnType = '';
        $request = $this->getVatomNFTRequest($version, $account_id, $vatom_id, $return_raw_response, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getVatomNFT'
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_id Vatom NFT Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVatomNFT'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getVatomNFTRequest($version, $account_id, $vatom_id, $return_raw_response = null, string $contentType = self::contentTypes['getVatomNFT'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling getVatomNFT'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling getVatomNFT'
            );
        }

        // verify the required parameter 'vatom_id' is set
        if ($vatom_id === null || (is_array($vatom_id) && count($vatom_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vatom_id when calling getVatomNFT'
            );
        }



        $resourcePath = '/api/{version}/vatom/vatoms/get';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vatom_id,
            'vatomId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_raw_response,
            'returnRawResponse', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listCommunities
     *
     * List Vatom Communities
     *
     * @param  float $version version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string|null $vatom_parameters Vatom Parameters (optional)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCommunities'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function listCommunities($version, $account_id, $app_key, $vatom_parameters = null, $return_raw_response = null, string $contentType = self::contentTypes['listCommunities'][0])
    {
        $this->listCommunitiesWithHttpInfo($version, $account_id, $app_key, $vatom_parameters, $return_raw_response, $contentType);
    }

    /**
     * Operation listCommunitiesWithHttpInfo
     *
     * List Vatom Communities
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string|null $vatom_parameters Vatom Parameters (optional)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCommunities'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function listCommunitiesWithHttpInfo($version, $account_id, $app_key, $vatom_parameters = null, $return_raw_response = null, string $contentType = self::contentTypes['listCommunities'][0])
    {
        $request = $this->listCommunitiesRequest($version, $account_id, $app_key, $vatom_parameters, $return_raw_response, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation listCommunitiesAsync
     *
     * List Vatom Communities
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string|null $vatom_parameters Vatom Parameters (optional)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCommunities'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCommunitiesAsync($version, $account_id, $app_key, $vatom_parameters = null, $return_raw_response = null, string $contentType = self::contentTypes['listCommunities'][0])
    {
        return $this->listCommunitiesAsyncWithHttpInfo($version, $account_id, $app_key, $vatom_parameters, $return_raw_response, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listCommunitiesAsyncWithHttpInfo
     *
     * List Vatom Communities
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string|null $vatom_parameters Vatom Parameters (optional)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCommunities'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCommunitiesAsyncWithHttpInfo($version, $account_id, $app_key, $vatom_parameters = null, $return_raw_response = null, string $contentType = self::contentTypes['listCommunities'][0])
    {
        $returnType = '';
        $request = $this->listCommunitiesRequest($version, $account_id, $app_key, $vatom_parameters, $return_raw_response, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listCommunities'
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string|null $vatom_parameters Vatom Parameters (optional)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCommunities'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listCommunitiesRequest($version, $account_id, $app_key, $vatom_parameters = null, $return_raw_response = null, string $contentType = self::contentTypes['listCommunities'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling listCommunities'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling listCommunities'
            );
        }

        // verify the required parameter 'app_key' is set
        if ($app_key === null || (is_array($app_key) && count($app_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_key when calling listCommunities'
            );
        }




        $resourcePath = '/api/{version}/vatom/b/communities/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $app_key,
            'appKey', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vatom_parameters,
            'vatomParameters', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_raw_response,
            'returnRawResponse', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listEvents
     *
     * List Vatom Events
     *
     * @param  float $version version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string|null $vatom_parameters Vatom Parameters (optional)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEvents'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function listEvents($version, $account_id, $app_key, $vatom_parameters = null, $return_raw_response = null, string $contentType = self::contentTypes['listEvents'][0])
    {
        $this->listEventsWithHttpInfo($version, $account_id, $app_key, $vatom_parameters, $return_raw_response, $contentType);
    }

    /**
     * Operation listEventsWithHttpInfo
     *
     * List Vatom Events
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string|null $vatom_parameters Vatom Parameters (optional)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEvents'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function listEventsWithHttpInfo($version, $account_id, $app_key, $vatom_parameters = null, $return_raw_response = null, string $contentType = self::contentTypes['listEvents'][0])
    {
        $request = $this->listEventsRequest($version, $account_id, $app_key, $vatom_parameters, $return_raw_response, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation listEventsAsync
     *
     * List Vatom Events
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string|null $vatom_parameters Vatom Parameters (optional)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEvents'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listEventsAsync($version, $account_id, $app_key, $vatom_parameters = null, $return_raw_response = null, string $contentType = self::contentTypes['listEvents'][0])
    {
        return $this->listEventsAsyncWithHttpInfo($version, $account_id, $app_key, $vatom_parameters, $return_raw_response, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listEventsAsyncWithHttpInfo
     *
     * List Vatom Events
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string|null $vatom_parameters Vatom Parameters (optional)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEvents'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listEventsAsyncWithHttpInfo($version, $account_id, $app_key, $vatom_parameters = null, $return_raw_response = null, string $contentType = self::contentTypes['listEvents'][0])
    {
        $returnType = '';
        $request = $this->listEventsRequest($version, $account_id, $app_key, $vatom_parameters, $return_raw_response, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listEvents'
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string|null $vatom_parameters Vatom Parameters (optional)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEvents'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listEventsRequest($version, $account_id, $app_key, $vatom_parameters = null, $return_raw_response = null, string $contentType = self::contentTypes['listEvents'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling listEvents'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling listEvents'
            );
        }

        // verify the required parameter 'app_key' is set
        if ($app_key === null || (is_array($app_key) && count($app_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_key when calling listEvents'
            );
        }




        $resourcePath = '/api/{version}/vatom/b/events/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $app_key,
            'appKey', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vatom_parameters,
            'vatomParameters', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_raw_response,
            'returnRawResponse', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listSpaces
     *
     * List Vatom Spaces
     *
     * @param  float $version version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string|null $vatom_parameters Vatom Parameters (optional)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listSpaces'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function listSpaces($version, $account_id, $app_key, $vatom_parameters = null, $return_raw_response = null, string $contentType = self::contentTypes['listSpaces'][0])
    {
        $this->listSpacesWithHttpInfo($version, $account_id, $app_key, $vatom_parameters, $return_raw_response, $contentType);
    }

    /**
     * Operation listSpacesWithHttpInfo
     *
     * List Vatom Spaces
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string|null $vatom_parameters Vatom Parameters (optional)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listSpaces'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function listSpacesWithHttpInfo($version, $account_id, $app_key, $vatom_parameters = null, $return_raw_response = null, string $contentType = self::contentTypes['listSpaces'][0])
    {
        $request = $this->listSpacesRequest($version, $account_id, $app_key, $vatom_parameters, $return_raw_response, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation listSpacesAsync
     *
     * List Vatom Spaces
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string|null $vatom_parameters Vatom Parameters (optional)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listSpaces'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listSpacesAsync($version, $account_id, $app_key, $vatom_parameters = null, $return_raw_response = null, string $contentType = self::contentTypes['listSpaces'][0])
    {
        return $this->listSpacesAsyncWithHttpInfo($version, $account_id, $app_key, $vatom_parameters, $return_raw_response, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listSpacesAsyncWithHttpInfo
     *
     * List Vatom Spaces
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string|null $vatom_parameters Vatom Parameters (optional)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listSpaces'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listSpacesAsyncWithHttpInfo($version, $account_id, $app_key, $vatom_parameters = null, $return_raw_response = null, string $contentType = self::contentTypes['listSpaces'][0])
    {
        $returnType = '';
        $request = $this->listSpacesRequest($version, $account_id, $app_key, $vatom_parameters, $return_raw_response, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listSpaces'
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string|null $vatom_parameters Vatom Parameters (optional)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listSpaces'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listSpacesRequest($version, $account_id, $app_key, $vatom_parameters = null, $return_raw_response = null, string $contentType = self::contentTypes['listSpaces'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling listSpaces'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling listSpaces'
            );
        }

        // verify the required parameter 'app_key' is set
        if ($app_key === null || (is_array($app_key) && count($app_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_key when calling listSpaces'
            );
        }




        $resourcePath = '/api/{version}/vatom/b/spaces/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $app_key,
            'appKey', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vatom_parameters,
            'vatomParameters', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_raw_response,
            'returnRawResponse', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listUserCoinTransactions
     *
     * List Coin Transactions for a Vatom User
     *
     * @param  float $version version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_user_id Vatom User Id (required)
     * @param  string|null $vatom_parameters Vatom Parameters (optional)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listUserCoinTransactions'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function listUserCoinTransactions($version, $account_id, $vatom_user_id, $vatom_parameters = null, $return_raw_response = null, string $contentType = self::contentTypes['listUserCoinTransactions'][0])
    {
        $this->listUserCoinTransactionsWithHttpInfo($version, $account_id, $vatom_user_id, $vatom_parameters, $return_raw_response, $contentType);
    }

    /**
     * Operation listUserCoinTransactionsWithHttpInfo
     *
     * List Coin Transactions for a Vatom User
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_user_id Vatom User Id (required)
     * @param  string|null $vatom_parameters Vatom Parameters (optional)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listUserCoinTransactions'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function listUserCoinTransactionsWithHttpInfo($version, $account_id, $vatom_user_id, $vatom_parameters = null, $return_raw_response = null, string $contentType = self::contentTypes['listUserCoinTransactions'][0])
    {
        $request = $this->listUserCoinTransactionsRequest($version, $account_id, $vatom_user_id, $vatom_parameters, $return_raw_response, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation listUserCoinTransactionsAsync
     *
     * List Coin Transactions for a Vatom User
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_user_id Vatom User Id (required)
     * @param  string|null $vatom_parameters Vatom Parameters (optional)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listUserCoinTransactions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listUserCoinTransactionsAsync($version, $account_id, $vatom_user_id, $vatom_parameters = null, $return_raw_response = null, string $contentType = self::contentTypes['listUserCoinTransactions'][0])
    {
        return $this->listUserCoinTransactionsAsyncWithHttpInfo($version, $account_id, $vatom_user_id, $vatom_parameters, $return_raw_response, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listUserCoinTransactionsAsyncWithHttpInfo
     *
     * List Coin Transactions for a Vatom User
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_user_id Vatom User Id (required)
     * @param  string|null $vatom_parameters Vatom Parameters (optional)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listUserCoinTransactions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listUserCoinTransactionsAsyncWithHttpInfo($version, $account_id, $vatom_user_id, $vatom_parameters = null, $return_raw_response = null, string $contentType = self::contentTypes['listUserCoinTransactions'][0])
    {
        $returnType = '';
        $request = $this->listUserCoinTransactionsRequest($version, $account_id, $vatom_user_id, $vatom_parameters, $return_raw_response, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listUserCoinTransactions'
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_user_id Vatom User Id (required)
     * @param  string|null $vatom_parameters Vatom Parameters (optional)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listUserCoinTransactions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listUserCoinTransactionsRequest($version, $account_id, $vatom_user_id, $vatom_parameters = null, $return_raw_response = null, string $contentType = self::contentTypes['listUserCoinTransactions'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling listUserCoinTransactions'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling listUserCoinTransactions'
            );
        }

        // verify the required parameter 'vatom_user_id' is set
        if ($vatom_user_id === null || (is_array($vatom_user_id) && count($vatom_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vatom_user_id when calling listUserCoinTransactions'
            );
        }




        $resourcePath = '/api/{version}/vatom/u/coins/txns/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vatom_user_id,
            'vatomUserId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vatom_parameters,
            'vatomParameters', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_raw_response,
            'returnRawResponse', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listUserCoinTransactionsAsBusiness
     *
     * List coin transactions for a user (as a Business)
     *
     * @param  float $version version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_user_id Vatom User Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string|null $vatom_parameters Vatom Parameters (optional)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listUserCoinTransactionsAsBusiness'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function listUserCoinTransactionsAsBusiness($version, $account_id, $vatom_user_id, $app_key, $vatom_parameters = null, $return_raw_response = null, string $contentType = self::contentTypes['listUserCoinTransactionsAsBusiness'][0])
    {
        $this->listUserCoinTransactionsAsBusinessWithHttpInfo($version, $account_id, $vatom_user_id, $app_key, $vatom_parameters, $return_raw_response, $contentType);
    }

    /**
     * Operation listUserCoinTransactionsAsBusinessWithHttpInfo
     *
     * List coin transactions for a user (as a Business)
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_user_id Vatom User Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string|null $vatom_parameters Vatom Parameters (optional)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listUserCoinTransactionsAsBusiness'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function listUserCoinTransactionsAsBusinessWithHttpInfo($version, $account_id, $vatom_user_id, $app_key, $vatom_parameters = null, $return_raw_response = null, string $contentType = self::contentTypes['listUserCoinTransactionsAsBusiness'][0])
    {
        $request = $this->listUserCoinTransactionsAsBusinessRequest($version, $account_id, $vatom_user_id, $app_key, $vatom_parameters, $return_raw_response, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation listUserCoinTransactionsAsBusinessAsync
     *
     * List coin transactions for a user (as a Business)
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_user_id Vatom User Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string|null $vatom_parameters Vatom Parameters (optional)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listUserCoinTransactionsAsBusiness'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listUserCoinTransactionsAsBusinessAsync($version, $account_id, $vatom_user_id, $app_key, $vatom_parameters = null, $return_raw_response = null, string $contentType = self::contentTypes['listUserCoinTransactionsAsBusiness'][0])
    {
        return $this->listUserCoinTransactionsAsBusinessAsyncWithHttpInfo($version, $account_id, $vatom_user_id, $app_key, $vatom_parameters, $return_raw_response, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listUserCoinTransactionsAsBusinessAsyncWithHttpInfo
     *
     * List coin transactions for a user (as a Business)
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_user_id Vatom User Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string|null $vatom_parameters Vatom Parameters (optional)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listUserCoinTransactionsAsBusiness'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listUserCoinTransactionsAsBusinessAsyncWithHttpInfo($version, $account_id, $vatom_user_id, $app_key, $vatom_parameters = null, $return_raw_response = null, string $contentType = self::contentTypes['listUserCoinTransactionsAsBusiness'][0])
    {
        $returnType = '';
        $request = $this->listUserCoinTransactionsAsBusinessRequest($version, $account_id, $vatom_user_id, $app_key, $vatom_parameters, $return_raw_response, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listUserCoinTransactionsAsBusiness'
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_user_id Vatom User Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string|null $vatom_parameters Vatom Parameters (optional)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listUserCoinTransactionsAsBusiness'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listUserCoinTransactionsAsBusinessRequest($version, $account_id, $vatom_user_id, $app_key, $vatom_parameters = null, $return_raw_response = null, string $contentType = self::contentTypes['listUserCoinTransactionsAsBusiness'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling listUserCoinTransactionsAsBusiness'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling listUserCoinTransactionsAsBusiness'
            );
        }

        // verify the required parameter 'vatom_user_id' is set
        if ($vatom_user_id === null || (is_array($vatom_user_id) && count($vatom_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vatom_user_id when calling listUserCoinTransactionsAsBusiness'
            );
        }

        // verify the required parameter 'app_key' is set
        if ($app_key === null || (is_array($app_key) && count($app_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_key when calling listUserCoinTransactionsAsBusiness'
            );
        }




        $resourcePath = '/api/{version}/vatom/b/users/coins/txns/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vatom_user_id,
            'vatomUserId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $app_key,
            'appKey', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vatom_parameters,
            'vatomParameters', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_raw_response,
            'returnRawResponse', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation performActionOnNFT
     *
     * Perform Action on NFT
     *
     * @param  float $version version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_id Vatom NFT Id (required)
     * @param  string $vatom_action Vatom Action (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['performActionOnNFT'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function performActionOnNFT($version, $account_id, $vatom_id, $vatom_action, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['performActionOnNFT'][0])
    {
        $this->performActionOnNFTWithHttpInfo($version, $account_id, $vatom_id, $vatom_action, $vatom_parameters, $return_raw_response, $contentType);
    }

    /**
     * Operation performActionOnNFTWithHttpInfo
     *
     * Perform Action on NFT
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_id Vatom NFT Id (required)
     * @param  string $vatom_action Vatom Action (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['performActionOnNFT'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function performActionOnNFTWithHttpInfo($version, $account_id, $vatom_id, $vatom_action, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['performActionOnNFT'][0])
    {
        $request = $this->performActionOnNFTRequest($version, $account_id, $vatom_id, $vatom_action, $vatom_parameters, $return_raw_response, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation performActionOnNFTAsync
     *
     * Perform Action on NFT
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_id Vatom NFT Id (required)
     * @param  string $vatom_action Vatom Action (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['performActionOnNFT'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function performActionOnNFTAsync($version, $account_id, $vatom_id, $vatom_action, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['performActionOnNFT'][0])
    {
        return $this->performActionOnNFTAsyncWithHttpInfo($version, $account_id, $vatom_id, $vatom_action, $vatom_parameters, $return_raw_response, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation performActionOnNFTAsyncWithHttpInfo
     *
     * Perform Action on NFT
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_id Vatom NFT Id (required)
     * @param  string $vatom_action Vatom Action (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['performActionOnNFT'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function performActionOnNFTAsyncWithHttpInfo($version, $account_id, $vatom_id, $vatom_action, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['performActionOnNFT'][0])
    {
        $returnType = '';
        $request = $this->performActionOnNFTRequest($version, $account_id, $vatom_id, $vatom_action, $vatom_parameters, $return_raw_response, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'performActionOnNFT'
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_id Vatom NFT Id (required)
     * @param  string $vatom_action Vatom Action (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['performActionOnNFT'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function performActionOnNFTRequest($version, $account_id, $vatom_id, $vatom_action, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['performActionOnNFT'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling performActionOnNFT'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling performActionOnNFT'
            );
        }

        // verify the required parameter 'vatom_id' is set
        if ($vatom_id === null || (is_array($vatom_id) && count($vatom_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vatom_id when calling performActionOnNFT'
            );
        }

        // verify the required parameter 'vatom_action' is set
        if ($vatom_action === null || (is_array($vatom_action) && count($vatom_action) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vatom_action when calling performActionOnNFT'
            );
        }

        // verify the required parameter 'vatom_parameters' is set
        if ($vatom_parameters === null || (is_array($vatom_parameters) && count($vatom_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vatom_parameters when calling performActionOnNFT'
            );
        }



        $resourcePath = '/api/{version}/vatom/me/vatoms/actions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vatom_id,
            'vatomId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vatom_action,
            'vatomAction', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vatom_parameters,
            'vatomParameters', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_raw_response,
            'returnRawResponse', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation redeemNFT
     *
     * Redeem NFT
     *
     * @param  float $version version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['redeemNFT'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function redeemNFT($version, $account_id, $app_key, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['redeemNFT'][0])
    {
        $this->redeemNFTWithHttpInfo($version, $account_id, $app_key, $vatom_parameters, $return_raw_response, $contentType);
    }

    /**
     * Operation redeemNFTWithHttpInfo
     *
     * Redeem NFT
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['redeemNFT'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function redeemNFTWithHttpInfo($version, $account_id, $app_key, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['redeemNFT'][0])
    {
        $request = $this->redeemNFTRequest($version, $account_id, $app_key, $vatom_parameters, $return_raw_response, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation redeemNFTAsync
     *
     * Redeem NFT
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['redeemNFT'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function redeemNFTAsync($version, $account_id, $app_key, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['redeemNFT'][0])
    {
        return $this->redeemNFTAsyncWithHttpInfo($version, $account_id, $app_key, $vatom_parameters, $return_raw_response, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation redeemNFTAsyncWithHttpInfo
     *
     * Redeem NFT
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['redeemNFT'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function redeemNFTAsyncWithHttpInfo($version, $account_id, $app_key, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['redeemNFT'][0])
    {
        $returnType = '';
        $request = $this->redeemNFTRequest($version, $account_id, $app_key, $vatom_parameters, $return_raw_response, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'redeemNFT'
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['redeemNFT'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function redeemNFTRequest($version, $account_id, $app_key, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['redeemNFT'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling redeemNFT'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling redeemNFT'
            );
        }

        // verify the required parameter 'app_key' is set
        if ($app_key === null || (is_array($app_key) && count($app_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_key when calling redeemNFT'
            );
        }

        // verify the required parameter 'vatom_parameters' is set
        if ($vatom_parameters === null || (is_array($vatom_parameters) && count($vatom_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vatom_parameters when calling redeemNFT'
            );
        }



        $resourcePath = '/api/{version}/vatom/b/redemptions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $app_key,
            'appKey', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vatom_parameters,
            'vatomParameters', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_raw_response,
            'returnRawResponse', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation redeemUserCoinsAsBusiness
     *
     * Redeem the coins for a user (as a Business)
     *
     * @param  float $version version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_user_id Vatom User Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['redeemUserCoinsAsBusiness'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function redeemUserCoinsAsBusiness($version, $account_id, $vatom_user_id, $app_key, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['redeemUserCoinsAsBusiness'][0])
    {
        $this->redeemUserCoinsAsBusinessWithHttpInfo($version, $account_id, $vatom_user_id, $app_key, $vatom_parameters, $return_raw_response, $contentType);
    }

    /**
     * Operation redeemUserCoinsAsBusinessWithHttpInfo
     *
     * Redeem the coins for a user (as a Business)
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_user_id Vatom User Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['redeemUserCoinsAsBusiness'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function redeemUserCoinsAsBusinessWithHttpInfo($version, $account_id, $vatom_user_id, $app_key, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['redeemUserCoinsAsBusiness'][0])
    {
        $request = $this->redeemUserCoinsAsBusinessRequest($version, $account_id, $vatom_user_id, $app_key, $vatom_parameters, $return_raw_response, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation redeemUserCoinsAsBusinessAsync
     *
     * Redeem the coins for a user (as a Business)
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_user_id Vatom User Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['redeemUserCoinsAsBusiness'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function redeemUserCoinsAsBusinessAsync($version, $account_id, $vatom_user_id, $app_key, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['redeemUserCoinsAsBusiness'][0])
    {
        return $this->redeemUserCoinsAsBusinessAsyncWithHttpInfo($version, $account_id, $vatom_user_id, $app_key, $vatom_parameters, $return_raw_response, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation redeemUserCoinsAsBusinessAsyncWithHttpInfo
     *
     * Redeem the coins for a user (as a Business)
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_user_id Vatom User Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['redeemUserCoinsAsBusiness'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function redeemUserCoinsAsBusinessAsyncWithHttpInfo($version, $account_id, $vatom_user_id, $app_key, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['redeemUserCoinsAsBusiness'][0])
    {
        $returnType = '';
        $request = $this->redeemUserCoinsAsBusinessRequest($version, $account_id, $vatom_user_id, $app_key, $vatom_parameters, $return_raw_response, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'redeemUserCoinsAsBusiness'
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_user_id Vatom User Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['redeemUserCoinsAsBusiness'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function redeemUserCoinsAsBusinessRequest($version, $account_id, $vatom_user_id, $app_key, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['redeemUserCoinsAsBusiness'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling redeemUserCoinsAsBusiness'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling redeemUserCoinsAsBusiness'
            );
        }

        // verify the required parameter 'vatom_user_id' is set
        if ($vatom_user_id === null || (is_array($vatom_user_id) && count($vatom_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vatom_user_id when calling redeemUserCoinsAsBusiness'
            );
        }

        // verify the required parameter 'app_key' is set
        if ($app_key === null || (is_array($app_key) && count($app_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_key when calling redeemUserCoinsAsBusiness'
            );
        }

        // verify the required parameter 'vatom_parameters' is set
        if ($vatom_parameters === null || (is_array($vatom_parameters) && count($vatom_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vatom_parameters when calling redeemUserCoinsAsBusiness'
            );
        }



        $resourcePath = '/api/{version}/vatom/b/users/coins/redeem';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vatom_user_id,
            'vatomUserId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $app_key,
            'appKey', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vatom_parameters,
            'vatomParameters', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_raw_response,
            'returnRawResponse', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchBusinesses
     *
     * Search for Vatom Businesses
     *
     * @param  float $version version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string|null $vatom_parameters Vatom Parameters (optional)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchBusinesses'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function searchBusinesses($version, $account_id, $vatom_parameters = null, $return_raw_response = null, string $contentType = self::contentTypes['searchBusinesses'][0])
    {
        $this->searchBusinessesWithHttpInfo($version, $account_id, $vatom_parameters, $return_raw_response, $contentType);
    }

    /**
     * Operation searchBusinessesWithHttpInfo
     *
     * Search for Vatom Businesses
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string|null $vatom_parameters Vatom Parameters (optional)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchBusinesses'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchBusinessesWithHttpInfo($version, $account_id, $vatom_parameters = null, $return_raw_response = null, string $contentType = self::contentTypes['searchBusinesses'][0])
    {
        $request = $this->searchBusinessesRequest($version, $account_id, $vatom_parameters, $return_raw_response, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation searchBusinessesAsync
     *
     * Search for Vatom Businesses
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string|null $vatom_parameters Vatom Parameters (optional)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchBusinesses'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchBusinessesAsync($version, $account_id, $vatom_parameters = null, $return_raw_response = null, string $contentType = self::contentTypes['searchBusinesses'][0])
    {
        return $this->searchBusinessesAsyncWithHttpInfo($version, $account_id, $vatom_parameters, $return_raw_response, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchBusinessesAsyncWithHttpInfo
     *
     * Search for Vatom Businesses
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string|null $vatom_parameters Vatom Parameters (optional)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchBusinesses'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchBusinessesAsyncWithHttpInfo($version, $account_id, $vatom_parameters = null, $return_raw_response = null, string $contentType = self::contentTypes['searchBusinesses'][0])
    {
        $returnType = '';
        $request = $this->searchBusinessesRequest($version, $account_id, $vatom_parameters, $return_raw_response, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchBusinesses'
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string|null $vatom_parameters Vatom Parameters (optional)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchBusinesses'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function searchBusinessesRequest($version, $account_id, $vatom_parameters = null, $return_raw_response = null, string $contentType = self::contentTypes['searchBusinesses'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling searchBusinesses'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling searchBusinesses'
            );
        }




        $resourcePath = '/api/{version}/vatom/b/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vatom_parameters,
            'vatomParameters', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_raw_response,
            'returnRawResponse', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchCampaignGroups
     *
     * Search Campaign Groups
     *
     * @param  float $version version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchCampaignGroups'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function searchCampaignGroups($version, $account_id, $app_key, $return_raw_response = null, string $contentType = self::contentTypes['searchCampaignGroups'][0])
    {
        $this->searchCampaignGroupsWithHttpInfo($version, $account_id, $app_key, $return_raw_response, $contentType);
    }

    /**
     * Operation searchCampaignGroupsWithHttpInfo
     *
     * Search Campaign Groups
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchCampaignGroups'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchCampaignGroupsWithHttpInfo($version, $account_id, $app_key, $return_raw_response = null, string $contentType = self::contentTypes['searchCampaignGroups'][0])
    {
        $request = $this->searchCampaignGroupsRequest($version, $account_id, $app_key, $return_raw_response, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation searchCampaignGroupsAsync
     *
     * Search Campaign Groups
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchCampaignGroups'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchCampaignGroupsAsync($version, $account_id, $app_key, $return_raw_response = null, string $contentType = self::contentTypes['searchCampaignGroups'][0])
    {
        return $this->searchCampaignGroupsAsyncWithHttpInfo($version, $account_id, $app_key, $return_raw_response, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchCampaignGroupsAsyncWithHttpInfo
     *
     * Search Campaign Groups
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchCampaignGroups'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchCampaignGroupsAsyncWithHttpInfo($version, $account_id, $app_key, $return_raw_response = null, string $contentType = self::contentTypes['searchCampaignGroups'][0])
    {
        $returnType = '';
        $request = $this->searchCampaignGroupsRequest($version, $account_id, $app_key, $return_raw_response, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchCampaignGroups'
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchCampaignGroups'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function searchCampaignGroupsRequest($version, $account_id, $app_key, $return_raw_response = null, string $contentType = self::contentTypes['searchCampaignGroups'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling searchCampaignGroups'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling searchCampaignGroups'
            );
        }

        // verify the required parameter 'app_key' is set
        if ($app_key === null || (is_array($app_key) && count($app_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_key when calling searchCampaignGroups'
            );
        }



        $resourcePath = '/api/{version}/vatom/b/campaign-groups/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $app_key,
            'appKey', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_raw_response,
            'returnRawResponse', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchIdentities
     *
     * Search User Identities
     *
     * @param  float $version version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchIdentities'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function searchIdentities($version, $account_id, $return_raw_response = null, string $contentType = self::contentTypes['searchIdentities'][0])
    {
        $this->searchIdentitiesWithHttpInfo($version, $account_id, $return_raw_response, $contentType);
    }

    /**
     * Operation searchIdentitiesWithHttpInfo
     *
     * Search User Identities
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchIdentities'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchIdentitiesWithHttpInfo($version, $account_id, $return_raw_response = null, string $contentType = self::contentTypes['searchIdentities'][0])
    {
        $request = $this->searchIdentitiesRequest($version, $account_id, $return_raw_response, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation searchIdentitiesAsync
     *
     * Search User Identities
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchIdentities'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchIdentitiesAsync($version, $account_id, $return_raw_response = null, string $contentType = self::contentTypes['searchIdentities'][0])
    {
        return $this->searchIdentitiesAsyncWithHttpInfo($version, $account_id, $return_raw_response, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchIdentitiesAsyncWithHttpInfo
     *
     * Search User Identities
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchIdentities'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchIdentitiesAsyncWithHttpInfo($version, $account_id, $return_raw_response = null, string $contentType = self::contentTypes['searchIdentities'][0])
    {
        $returnType = '';
        $request = $this->searchIdentitiesRequest($version, $account_id, $return_raw_response, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchIdentities'
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchIdentities'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function searchIdentitiesRequest($version, $account_id, $return_raw_response = null, string $contentType = self::contentTypes['searchIdentities'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling searchIdentities'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling searchIdentities'
            );
        }



        $resourcePath = '/api/{version}/vatom/me/identities/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_raw_response,
            'returnRawResponse', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchInventory
     *
     * Search Vatom User&#39;s Inventory
     *
     * @param  float $version version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string|null $vatom_parameters Vatom Parameters (optional)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchInventory'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function searchInventory($version, $account_id, $vatom_parameters = null, $return_raw_response = null, string $contentType = self::contentTypes['searchInventory'][0])
    {
        $this->searchInventoryWithHttpInfo($version, $account_id, $vatom_parameters, $return_raw_response, $contentType);
    }

    /**
     * Operation searchInventoryWithHttpInfo
     *
     * Search Vatom User&#39;s Inventory
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string|null $vatom_parameters Vatom Parameters (optional)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchInventory'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchInventoryWithHttpInfo($version, $account_id, $vatom_parameters = null, $return_raw_response = null, string $contentType = self::contentTypes['searchInventory'][0])
    {
        $request = $this->searchInventoryRequest($version, $account_id, $vatom_parameters, $return_raw_response, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation searchInventoryAsync
     *
     * Search Vatom User&#39;s Inventory
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string|null $vatom_parameters Vatom Parameters (optional)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchInventory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchInventoryAsync($version, $account_id, $vatom_parameters = null, $return_raw_response = null, string $contentType = self::contentTypes['searchInventory'][0])
    {
        return $this->searchInventoryAsyncWithHttpInfo($version, $account_id, $vatom_parameters, $return_raw_response, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchInventoryAsyncWithHttpInfo
     *
     * Search Vatom User&#39;s Inventory
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string|null $vatom_parameters Vatom Parameters (optional)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchInventory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchInventoryAsyncWithHttpInfo($version, $account_id, $vatom_parameters = null, $return_raw_response = null, string $contentType = self::contentTypes['searchInventory'][0])
    {
        $returnType = '';
        $request = $this->searchInventoryRequest($version, $account_id, $vatom_parameters, $return_raw_response, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchInventory'
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string|null $vatom_parameters Vatom Parameters (optional)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchInventory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function searchInventoryRequest($version, $account_id, $vatom_parameters = null, $return_raw_response = null, string $contentType = self::contentTypes['searchInventory'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling searchInventory'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling searchInventory'
            );
        }




        $resourcePath = '/api/{version}/vatom/user-inventory/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vatom_parameters,
            'vatomParameters', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_raw_response,
            'returnRawResponse', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation sendNFT
     *
     * Send NFT
     *
     * @param  float $version version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_campaign_id Vatom Campaign Id (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendNFT'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function sendNFT($version, $account_id, $app_key, $vatom_campaign_id, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['sendNFT'][0])
    {
        $this->sendNFTWithHttpInfo($version, $account_id, $app_key, $vatom_campaign_id, $vatom_parameters, $return_raw_response, $contentType);
    }

    /**
     * Operation sendNFTWithHttpInfo
     *
     * Send NFT
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_campaign_id Vatom Campaign Id (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendNFT'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function sendNFTWithHttpInfo($version, $account_id, $app_key, $vatom_campaign_id, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['sendNFT'][0])
    {
        $request = $this->sendNFTRequest($version, $account_id, $app_key, $vatom_campaign_id, $vatom_parameters, $return_raw_response, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation sendNFTAsync
     *
     * Send NFT
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_campaign_id Vatom Campaign Id (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendNFT'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sendNFTAsync($version, $account_id, $app_key, $vatom_campaign_id, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['sendNFT'][0])
    {
        return $this->sendNFTAsyncWithHttpInfo($version, $account_id, $app_key, $vatom_campaign_id, $vatom_parameters, $return_raw_response, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation sendNFTAsyncWithHttpInfo
     *
     * Send NFT
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_campaign_id Vatom Campaign Id (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendNFT'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sendNFTAsyncWithHttpInfo($version, $account_id, $app_key, $vatom_campaign_id, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['sendNFT'][0])
    {
        $returnType = '';
        $request = $this->sendNFTRequest($version, $account_id, $app_key, $vatom_campaign_id, $vatom_parameters, $return_raw_response, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'sendNFT'
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_campaign_id Vatom Campaign Id (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendNFT'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function sendNFTRequest($version, $account_id, $app_key, $vatom_campaign_id, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['sendNFT'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling sendNFT'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling sendNFT'
            );
        }

        // verify the required parameter 'app_key' is set
        if ($app_key === null || (is_array($app_key) && count($app_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_key when calling sendNFT'
            );
        }

        // verify the required parameter 'vatom_campaign_id' is set
        if ($vatom_campaign_id === null || (is_array($vatom_campaign_id) && count($vatom_campaign_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vatom_campaign_id when calling sendNFT'
            );
        }

        // verify the required parameter 'vatom_parameters' is set
        if ($vatom_parameters === null || (is_array($vatom_parameters) && count($vatom_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vatom_parameters when calling sendNFT'
            );
        }



        $resourcePath = '/api/{version}/vatom/b/campaigns/send';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $app_key,
            'appKey', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vatom_campaign_id,
            'vatomCampaignId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vatom_parameters,
            'vatomParameters', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_raw_response,
            'returnRawResponse', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setPointsBalanceAsBusiness
     *
     * Set Points Balance as Business
     *
     * @param  float $version version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_user_id Vatom User Id (required)
     * @param  string $vatom_campaign_id Vatom Campaign Id (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setPointsBalanceAsBusiness'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function setPointsBalanceAsBusiness($version, $account_id, $app_key, $vatom_user_id, $vatom_campaign_id, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['setPointsBalanceAsBusiness'][0])
    {
        $this->setPointsBalanceAsBusinessWithHttpInfo($version, $account_id, $app_key, $vatom_user_id, $vatom_campaign_id, $vatom_parameters, $return_raw_response, $contentType);
    }

    /**
     * Operation setPointsBalanceAsBusinessWithHttpInfo
     *
     * Set Points Balance as Business
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_user_id Vatom User Id (required)
     * @param  string $vatom_campaign_id Vatom Campaign Id (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setPointsBalanceAsBusiness'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function setPointsBalanceAsBusinessWithHttpInfo($version, $account_id, $app_key, $vatom_user_id, $vatom_campaign_id, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['setPointsBalanceAsBusiness'][0])
    {
        $request = $this->setPointsBalanceAsBusinessRequest($version, $account_id, $app_key, $vatom_user_id, $vatom_campaign_id, $vatom_parameters, $return_raw_response, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation setPointsBalanceAsBusinessAsync
     *
     * Set Points Balance as Business
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_user_id Vatom User Id (required)
     * @param  string $vatom_campaign_id Vatom Campaign Id (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setPointsBalanceAsBusiness'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setPointsBalanceAsBusinessAsync($version, $account_id, $app_key, $vatom_user_id, $vatom_campaign_id, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['setPointsBalanceAsBusiness'][0])
    {
        return $this->setPointsBalanceAsBusinessAsyncWithHttpInfo($version, $account_id, $app_key, $vatom_user_id, $vatom_campaign_id, $vatom_parameters, $return_raw_response, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setPointsBalanceAsBusinessAsyncWithHttpInfo
     *
     * Set Points Balance as Business
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_user_id Vatom User Id (required)
     * @param  string $vatom_campaign_id Vatom Campaign Id (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setPointsBalanceAsBusiness'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setPointsBalanceAsBusinessAsyncWithHttpInfo($version, $account_id, $app_key, $vatom_user_id, $vatom_campaign_id, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['setPointsBalanceAsBusiness'][0])
    {
        $returnType = '';
        $request = $this->setPointsBalanceAsBusinessRequest($version, $account_id, $app_key, $vatom_user_id, $vatom_campaign_id, $vatom_parameters, $return_raw_response, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setPointsBalanceAsBusiness'
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_user_id Vatom User Id (required)
     * @param  string $vatom_campaign_id Vatom Campaign Id (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setPointsBalanceAsBusiness'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function setPointsBalanceAsBusinessRequest($version, $account_id, $app_key, $vatom_user_id, $vatom_campaign_id, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['setPointsBalanceAsBusiness'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling setPointsBalanceAsBusiness'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling setPointsBalanceAsBusiness'
            );
        }

        // verify the required parameter 'app_key' is set
        if ($app_key === null || (is_array($app_key) && count($app_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_key when calling setPointsBalanceAsBusiness'
            );
        }

        // verify the required parameter 'vatom_user_id' is set
        if ($vatom_user_id === null || (is_array($vatom_user_id) && count($vatom_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vatom_user_id when calling setPointsBalanceAsBusiness'
            );
        }

        // verify the required parameter 'vatom_campaign_id' is set
        if ($vatom_campaign_id === null || (is_array($vatom_campaign_id) && count($vatom_campaign_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vatom_campaign_id when calling setPointsBalanceAsBusiness'
            );
        }

        // verify the required parameter 'vatom_parameters' is set
        if ($vatom_parameters === null || (is_array($vatom_parameters) && count($vatom_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vatom_parameters when calling setPointsBalanceAsBusiness'
            );
        }



        $resourcePath = '/api/{version}/vatom/b/campaign/u/points/update';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $app_key,
            'appKey', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vatom_user_id,
            'vatomUserId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vatom_campaign_id,
            'vatomCampaignId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vatom_parameters,
            'vatomParameters', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_raw_response,
            'returnRawResponse', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation transferUserCoins
     *
     * Transfer coins from Vatom Users
     *
     * @param  float $version version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_user_id Vatom User Id (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transferUserCoins'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function transferUserCoins($version, $account_id, $vatom_user_id, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['transferUserCoins'][0])
    {
        $this->transferUserCoinsWithHttpInfo($version, $account_id, $vatom_user_id, $vatom_parameters, $return_raw_response, $contentType);
    }

    /**
     * Operation transferUserCoinsWithHttpInfo
     *
     * Transfer coins from Vatom Users
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_user_id Vatom User Id (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transferUserCoins'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function transferUserCoinsWithHttpInfo($version, $account_id, $vatom_user_id, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['transferUserCoins'][0])
    {
        $request = $this->transferUserCoinsRequest($version, $account_id, $vatom_user_id, $vatom_parameters, $return_raw_response, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation transferUserCoinsAsync
     *
     * Transfer coins from Vatom Users
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_user_id Vatom User Id (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transferUserCoins'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function transferUserCoinsAsync($version, $account_id, $vatom_user_id, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['transferUserCoins'][0])
    {
        return $this->transferUserCoinsAsyncWithHttpInfo($version, $account_id, $vatom_user_id, $vatom_parameters, $return_raw_response, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation transferUserCoinsAsyncWithHttpInfo
     *
     * Transfer coins from Vatom Users
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_user_id Vatom User Id (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transferUserCoins'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function transferUserCoinsAsyncWithHttpInfo($version, $account_id, $vatom_user_id, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['transferUserCoins'][0])
    {
        $returnType = '';
        $request = $this->transferUserCoinsRequest($version, $account_id, $vatom_user_id, $vatom_parameters, $return_raw_response, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'transferUserCoins'
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_user_id Vatom User Id (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transferUserCoins'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function transferUserCoinsRequest($version, $account_id, $vatom_user_id, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['transferUserCoins'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling transferUserCoins'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling transferUserCoins'
            );
        }

        // verify the required parameter 'vatom_user_id' is set
        if ($vatom_user_id === null || (is_array($vatom_user_id) && count($vatom_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vatom_user_id when calling transferUserCoins'
            );
        }

        // verify the required parameter 'vatom_parameters' is set
        if ($vatom_parameters === null || (is_array($vatom_parameters) && count($vatom_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vatom_parameters when calling transferUserCoins'
            );
        }



        $resourcePath = '/api/{version}/vatom/u/coins/transfer';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vatom_user_id,
            'vatomUserId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vatom_parameters,
            'vatomParameters', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_raw_response,
            'returnRawResponse', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateBusinessCoins
     *
     * Fund coins for a Business
     *
     * @param  float $version version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateBusinessCoins'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function updateBusinessCoins($version, $account_id, $app_key, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['updateBusinessCoins'][0])
    {
        $this->updateBusinessCoinsWithHttpInfo($version, $account_id, $app_key, $vatom_parameters, $return_raw_response, $contentType);
    }

    /**
     * Operation updateBusinessCoinsWithHttpInfo
     *
     * Fund coins for a Business
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateBusinessCoins'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateBusinessCoinsWithHttpInfo($version, $account_id, $app_key, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['updateBusinessCoins'][0])
    {
        $request = $this->updateBusinessCoinsRequest($version, $account_id, $app_key, $vatom_parameters, $return_raw_response, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateBusinessCoinsAsync
     *
     * Fund coins for a Business
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateBusinessCoins'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateBusinessCoinsAsync($version, $account_id, $app_key, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['updateBusinessCoins'][0])
    {
        return $this->updateBusinessCoinsAsyncWithHttpInfo($version, $account_id, $app_key, $vatom_parameters, $return_raw_response, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateBusinessCoinsAsyncWithHttpInfo
     *
     * Fund coins for a Business
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateBusinessCoins'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateBusinessCoinsAsyncWithHttpInfo($version, $account_id, $app_key, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['updateBusinessCoins'][0])
    {
        $returnType = '';
        $request = $this->updateBusinessCoinsRequest($version, $account_id, $app_key, $vatom_parameters, $return_raw_response, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateBusinessCoins'
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateBusinessCoins'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateBusinessCoinsRequest($version, $account_id, $app_key, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['updateBusinessCoins'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling updateBusinessCoins'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling updateBusinessCoins'
            );
        }

        // verify the required parameter 'app_key' is set
        if ($app_key === null || (is_array($app_key) && count($app_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_key when calling updateBusinessCoins'
            );
        }

        // verify the required parameter 'vatom_parameters' is set
        if ($vatom_parameters === null || (is_array($vatom_parameters) && count($vatom_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vatom_parameters when calling updateBusinessCoins'
            );
        }



        $resourcePath = '/api/{version}/vatom/b/coins/update';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $app_key,
            'appKey', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vatom_parameters,
            'vatomParameters', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_raw_response,
            'returnRawResponse', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateEventGuestList
     *
     * Update Vatom Event Guest List
     *
     * @param  float $version version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_event_id Vatom Event Id (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateEventGuestList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function updateEventGuestList($version, $account_id, $app_key, $vatom_event_id, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['updateEventGuestList'][0])
    {
        $this->updateEventGuestListWithHttpInfo($version, $account_id, $app_key, $vatom_event_id, $vatom_parameters, $return_raw_response, $contentType);
    }

    /**
     * Operation updateEventGuestListWithHttpInfo
     *
     * Update Vatom Event Guest List
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_event_id Vatom Event Id (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateEventGuestList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateEventGuestListWithHttpInfo($version, $account_id, $app_key, $vatom_event_id, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['updateEventGuestList'][0])
    {
        $request = $this->updateEventGuestListRequest($version, $account_id, $app_key, $vatom_event_id, $vatom_parameters, $return_raw_response, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateEventGuestListAsync
     *
     * Update Vatom Event Guest List
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_event_id Vatom Event Id (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateEventGuestList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateEventGuestListAsync($version, $account_id, $app_key, $vatom_event_id, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['updateEventGuestList'][0])
    {
        return $this->updateEventGuestListAsyncWithHttpInfo($version, $account_id, $app_key, $vatom_event_id, $vatom_parameters, $return_raw_response, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateEventGuestListAsyncWithHttpInfo
     *
     * Update Vatom Event Guest List
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_event_id Vatom Event Id (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateEventGuestList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateEventGuestListAsyncWithHttpInfo($version, $account_id, $app_key, $vatom_event_id, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['updateEventGuestList'][0])
    {
        $returnType = '';
        $request = $this->updateEventGuestListRequest($version, $account_id, $app_key, $vatom_event_id, $vatom_parameters, $return_raw_response, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateEventGuestList'
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_event_id Vatom Event Id (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateEventGuestList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateEventGuestListRequest($version, $account_id, $app_key, $vatom_event_id, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['updateEventGuestList'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling updateEventGuestList'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling updateEventGuestList'
            );
        }

        // verify the required parameter 'app_key' is set
        if ($app_key === null || (is_array($app_key) && count($app_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_key when calling updateEventGuestList'
            );
        }

        // verify the required parameter 'vatom_event_id' is set
        if ($vatom_event_id === null || (is_array($vatom_event_id) && count($vatom_event_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vatom_event_id when calling updateEventGuestList'
            );
        }

        // verify the required parameter 'vatom_parameters' is set
        if ($vatom_parameters === null || (is_array($vatom_parameters) && count($vatom_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vatom_parameters when calling updateEventGuestList'
            );
        }



        $resourcePath = '/api/{version}/vatom/b/events/guests/update';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $app_key,
            'appKey', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vatom_event_id,
            'vatomEventId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vatom_parameters,
            'vatomParameters', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_raw_response,
            'returnRawResponse', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateSpace
     *
     * Update Vatom Space
     *
     * @param  float $version version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_space_id Vatom Space Id (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateSpace'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function updateSpace($version, $account_id, $app_key, $vatom_space_id, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['updateSpace'][0])
    {
        $this->updateSpaceWithHttpInfo($version, $account_id, $app_key, $vatom_space_id, $vatom_parameters, $return_raw_response, $contentType);
    }

    /**
     * Operation updateSpaceWithHttpInfo
     *
     * Update Vatom Space
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_space_id Vatom Space Id (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateSpace'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateSpaceWithHttpInfo($version, $account_id, $app_key, $vatom_space_id, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['updateSpace'][0])
    {
        $request = $this->updateSpaceRequest($version, $account_id, $app_key, $vatom_space_id, $vatom_parameters, $return_raw_response, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateSpaceAsync
     *
     * Update Vatom Space
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_space_id Vatom Space Id (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateSpaceAsync($version, $account_id, $app_key, $vatom_space_id, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['updateSpace'][0])
    {
        return $this->updateSpaceAsyncWithHttpInfo($version, $account_id, $app_key, $vatom_space_id, $vatom_parameters, $return_raw_response, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateSpaceAsyncWithHttpInfo
     *
     * Update Vatom Space
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_space_id Vatom Space Id (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateSpaceAsyncWithHttpInfo($version, $account_id, $app_key, $vatom_space_id, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['updateSpace'][0])
    {
        $returnType = '';
        $request = $this->updateSpaceRequest($version, $account_id, $app_key, $vatom_space_id, $vatom_parameters, $return_raw_response, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateSpace'
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_space_id Vatom Space Id (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateSpaceRequest($version, $account_id, $app_key, $vatom_space_id, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['updateSpace'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling updateSpace'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling updateSpace'
            );
        }

        // verify the required parameter 'app_key' is set
        if ($app_key === null || (is_array($app_key) && count($app_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_key when calling updateSpace'
            );
        }

        // verify the required parameter 'vatom_space_id' is set
        if ($vatom_space_id === null || (is_array($vatom_space_id) && count($vatom_space_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vatom_space_id when calling updateSpace'
            );
        }

        // verify the required parameter 'vatom_parameters' is set
        if ($vatom_parameters === null || (is_array($vatom_parameters) && count($vatom_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vatom_parameters when calling updateSpace'
            );
        }



        $resourcePath = '/api/{version}/vatom/b/spaces/update';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $app_key,
            'appKey', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vatom_space_id,
            'vatomSpaceId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vatom_parameters,
            'vatomParameters', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_raw_response,
            'returnRawResponse', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateUserCoinsAsBusiness
     *
     * Update the coins for a user (as a Business)
     *
     * @param  float $version version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_user_id Vatom User Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateUserCoinsAsBusiness'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function updateUserCoinsAsBusiness($version, $account_id, $vatom_user_id, $app_key, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['updateUserCoinsAsBusiness'][0])
    {
        $this->updateUserCoinsAsBusinessWithHttpInfo($version, $account_id, $vatom_user_id, $app_key, $vatom_parameters, $return_raw_response, $contentType);
    }

    /**
     * Operation updateUserCoinsAsBusinessWithHttpInfo
     *
     * Update the coins for a user (as a Business)
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_user_id Vatom User Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateUserCoinsAsBusiness'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateUserCoinsAsBusinessWithHttpInfo($version, $account_id, $vatom_user_id, $app_key, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['updateUserCoinsAsBusiness'][0])
    {
        $request = $this->updateUserCoinsAsBusinessRequest($version, $account_id, $vatom_user_id, $app_key, $vatom_parameters, $return_raw_response, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateUserCoinsAsBusinessAsync
     *
     * Update the coins for a user (as a Business)
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_user_id Vatom User Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateUserCoinsAsBusiness'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateUserCoinsAsBusinessAsync($version, $account_id, $vatom_user_id, $app_key, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['updateUserCoinsAsBusiness'][0])
    {
        return $this->updateUserCoinsAsBusinessAsyncWithHttpInfo($version, $account_id, $vatom_user_id, $app_key, $vatom_parameters, $return_raw_response, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateUserCoinsAsBusinessAsyncWithHttpInfo
     *
     * Update the coins for a user (as a Business)
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_user_id Vatom User Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateUserCoinsAsBusiness'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateUserCoinsAsBusinessAsyncWithHttpInfo($version, $account_id, $vatom_user_id, $app_key, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['updateUserCoinsAsBusiness'][0])
    {
        $returnType = '';
        $request = $this->updateUserCoinsAsBusinessRequest($version, $account_id, $vatom_user_id, $app_key, $vatom_parameters, $return_raw_response, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateUserCoinsAsBusiness'
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_user_id Vatom User Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateUserCoinsAsBusiness'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateUserCoinsAsBusinessRequest($version, $account_id, $vatom_user_id, $app_key, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['updateUserCoinsAsBusiness'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling updateUserCoinsAsBusiness'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling updateUserCoinsAsBusiness'
            );
        }

        // verify the required parameter 'vatom_user_id' is set
        if ($vatom_user_id === null || (is_array($vatom_user_id) && count($vatom_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vatom_user_id when calling updateUserCoinsAsBusiness'
            );
        }

        // verify the required parameter 'app_key' is set
        if ($app_key === null || (is_array($app_key) && count($app_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_key when calling updateUserCoinsAsBusiness'
            );
        }

        // verify the required parameter 'vatom_parameters' is set
        if ($vatom_parameters === null || (is_array($vatom_parameters) && count($vatom_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vatom_parameters when calling updateUserCoinsAsBusiness'
            );
        }



        $resourcePath = '/api/{version}/vatom/b/users/coins/update';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vatom_user_id,
            'vatomUserId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $app_key,
            'appKey', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vatom_parameters,
            'vatomParameters', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_raw_response,
            'returnRawResponse', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateUserProfile
     *
     * Update Vatom User Profile
     *
     * @param  float $version version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateUserProfile'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function updateUserProfile($version, $account_id, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['updateUserProfile'][0])
    {
        $this->updateUserProfileWithHttpInfo($version, $account_id, $vatom_parameters, $return_raw_response, $contentType);
    }

    /**
     * Operation updateUserProfileWithHttpInfo
     *
     * Update Vatom User Profile
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateUserProfile'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateUserProfileWithHttpInfo($version, $account_id, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['updateUserProfile'][0])
    {
        $request = $this->updateUserProfileRequest($version, $account_id, $vatom_parameters, $return_raw_response, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateUserProfileAsync
     *
     * Update Vatom User Profile
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateUserProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateUserProfileAsync($version, $account_id, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['updateUserProfile'][0])
    {
        return $this->updateUserProfileAsyncWithHttpInfo($version, $account_id, $vatom_parameters, $return_raw_response, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateUserProfileAsyncWithHttpInfo
     *
     * Update Vatom User Profile
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateUserProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateUserProfileAsyncWithHttpInfo($version, $account_id, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['updateUserProfile'][0])
    {
        $returnType = '';
        $request = $this->updateUserProfileRequest($version, $account_id, $vatom_parameters, $return_raw_response, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateUserProfile'
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateUserProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateUserProfileRequest($version, $account_id, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['updateUserProfile'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling updateUserProfile'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling updateUserProfile'
            );
        }

        // verify the required parameter 'vatom_parameters' is set
        if ($vatom_parameters === null || (is_array($vatom_parameters) && count($vatom_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vatom_parameters when calling updateUserProfile'
            );
        }



        $resourcePath = '/api/{version}/vatom/me/update';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vatom_parameters,
            'vatomParameters', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_raw_response,
            'returnRawResponse', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateVatomEvent
     *
     * Update Vatom Event
     *
     * @param  float $version version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_event_id Vatom Event Id (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateVatomEvent'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function updateVatomEvent($version, $account_id, $app_key, $vatom_event_id, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['updateVatomEvent'][0])
    {
        $this->updateVatomEventWithHttpInfo($version, $account_id, $app_key, $vatom_event_id, $vatom_parameters, $return_raw_response, $contentType);
    }

    /**
     * Operation updateVatomEventWithHttpInfo
     *
     * Update Vatom Event
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_event_id Vatom Event Id (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateVatomEvent'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateVatomEventWithHttpInfo($version, $account_id, $app_key, $vatom_event_id, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['updateVatomEvent'][0])
    {
        $request = $this->updateVatomEventRequest($version, $account_id, $app_key, $vatom_event_id, $vatom_parameters, $return_raw_response, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateVatomEventAsync
     *
     * Update Vatom Event
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_event_id Vatom Event Id (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateVatomEvent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateVatomEventAsync($version, $account_id, $app_key, $vatom_event_id, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['updateVatomEvent'][0])
    {
        return $this->updateVatomEventAsyncWithHttpInfo($version, $account_id, $app_key, $vatom_event_id, $vatom_parameters, $return_raw_response, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateVatomEventAsyncWithHttpInfo
     *
     * Update Vatom Event
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_event_id Vatom Event Id (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateVatomEvent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateVatomEventAsyncWithHttpInfo($version, $account_id, $app_key, $vatom_event_id, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['updateVatomEvent'][0])
    {
        $returnType = '';
        $request = $this->updateVatomEventRequest($version, $account_id, $app_key, $vatom_event_id, $vatom_parameters, $return_raw_response, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateVatomEvent'
     *
     * @param  float $version (required)
     * @param  int $account_id Sirqul Account Id (required)
     * @param  string $app_key Sirqul Application Key (required)
     * @param  string $vatom_event_id Vatom Event Id (required)
     * @param  string $vatom_parameters Vatom Parameters (required)
     * @param  bool|null $return_raw_response Return raw response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateVatomEvent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateVatomEventRequest($version, $account_id, $app_key, $vatom_event_id, $vatom_parameters, $return_raw_response = null, string $contentType = self::contentTypes['updateVatomEvent'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling updateVatomEvent'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling updateVatomEvent'
            );
        }

        // verify the required parameter 'app_key' is set
        if ($app_key === null || (is_array($app_key) && count($app_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_key when calling updateVatomEvent'
            );
        }

        // verify the required parameter 'vatom_event_id' is set
        if ($vatom_event_id === null || (is_array($vatom_event_id) && count($vatom_event_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vatom_event_id when calling updateVatomEvent'
            );
        }

        // verify the required parameter 'vatom_parameters' is set
        if ($vatom_parameters === null || (is_array($vatom_parameters) && count($vatom_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vatom_parameters when calling updateVatomEvent'
            );
        }



        $resourcePath = '/api/{version}/vatom/b/events/update';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $app_key,
            'appKey', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vatom_event_id,
            'vatomEventId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vatom_parameters,
            'vatomParameters', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_raw_response,
            'returnRawResponse', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        if ($this->config->getCertFile()) {
            $options[RequestOptions::CERT] = $this->config->getCertFile();
        }

        if ($this->config->getKeyFile()) {
            $options[RequestOptions::SSL_KEY] = $this->config->getKeyFile();
        }

        return $options;
    }

    private function handleResponseWithDataType(
        string $dataType,
        RequestInterface $request,
        ResponseInterface $response
    ): array {
        if ($dataType === '\SplFileObject') {
            $content = $response->getBody(); //stream goes to serializer
        } else {
            $content = (string) $response->getBody();
            if ($dataType !== 'string') {
                try {
                    $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                } catch (\JsonException $exception) {
                    throw new ApiException(
                        sprintf(
                            'Error JSON decoding server response (%s)',
                            $request->getUri()
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                        $content
                    );
                }
            }
        }

        return [
            ObjectSerializer::deserialize($content, $dataType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    private function responseWithinRangeCode(
        string $rangeCode,
        int $statusCode
    ): bool {
        $left = (int) ($rangeCode[0].'00');
        $right = (int) ($rangeCode[0].'99');

        return $statusCode >= $left && $statusCode <= $right;
    }
}
