<?php
/**
 * AchievementApi
 * PHP version 8.1
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Sirqul IoT Platform
 *
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.20.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\FormDataProcessor;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * AchievementApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class AchievementApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'apiVersionAchievementTierSearchPost' => [
            'application/json',
        ],
        'createAchievement' => [
            'application/json',
        ],
        'createAchievementTier' => [
            'application/json',
        ],
        'deleteAchievement' => [
            'application/json',
        ],
        'deleteAchievementTier' => [
            'application/json',
        ],
        'getAchievement' => [
            'application/json',
        ],
        'getAchievementTier' => [
            'application/json',
        ],
        'getUserAchievements' => [
            'application/json',
        ],
        'listAchievementTags' => [
            'application/json',
        ],
        'listAchievements' => [
            'application/json',
        ],
        'searchAchievements' => [
            'application/json',
        ],
        'updateAchievement' => [
            'application/json',
        ],
        'updateAchievementTier' => [
            'application/json',
        ],
        'updateUserAchievement' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation apiVersionAchievementTierSearchPost
     *
     * Searches an Achievement Tier
     *
     * @param  float $version version (required)
     * @param  string|null $device_id a unique id given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  string|null $app_key the application key (optional)
     * @param  string|null $keyword the keyword used to filter resutls with (this returns results that have the keyword in the title or the description of the achievement tier) (optional)
     * @param  int|null $achievement_type filter results by achievementType (these are exact case sensitive matches) (optional)
     * @param  string|null $rank_type filter results by the rankType (these are the exact case sensitive matches) (optional)
     * @param  string|null $sort_field the field to sort by. See {@link AchievementApiMap} (optional)
     * @param  bool|null $descending determines whether the sort list is in descending or ascending order (of the achievement) (optional)
     * @param  bool|null $descending_goal determines whether the results are in descending or ascending order by the tier goal count (after the initial sort on the achievement) (optional)
     * @param  int|null $start The start of the index for pagination (optional)
     * @param  int|null $limit the limit for pagination (has a hard limit of 1000) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiVersionAchievementTierSearchPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AchievementTierResponse
     */
    public function apiVersionAchievementTierSearchPost($version, $device_id = null, $account_id = null, $app_key = null, $keyword = null, $achievement_type = null, $rank_type = null, $sort_field = null, $descending = null, $descending_goal = null, $start = null, $limit = null, string $contentType = self::contentTypes['apiVersionAchievementTierSearchPost'][0])
    {
        list($response) = $this->apiVersionAchievementTierSearchPostWithHttpInfo($version, $device_id, $account_id, $app_key, $keyword, $achievement_type, $rank_type, $sort_field, $descending, $descending_goal, $start, $limit, $contentType);
        return $response;
    }

    /**
     * Operation apiVersionAchievementTierSearchPostWithHttpInfo
     *
     * Searches an Achievement Tier
     *
     * @param  float $version (required)
     * @param  string|null $device_id a unique id given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  string|null $app_key the application key (optional)
     * @param  string|null $keyword the keyword used to filter resutls with (this returns results that have the keyword in the title or the description of the achievement tier) (optional)
     * @param  int|null $achievement_type filter results by achievementType (these are exact case sensitive matches) (optional)
     * @param  string|null $rank_type filter results by the rankType (these are the exact case sensitive matches) (optional)
     * @param  string|null $sort_field the field to sort by. See {@link AchievementApiMap} (optional)
     * @param  bool|null $descending determines whether the sort list is in descending or ascending order (of the achievement) (optional)
     * @param  bool|null $descending_goal determines whether the results are in descending or ascending order by the tier goal count (after the initial sort on the achievement) (optional)
     * @param  int|null $start The start of the index for pagination (optional)
     * @param  int|null $limit the limit for pagination (has a hard limit of 1000) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiVersionAchievementTierSearchPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AchievementTierResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiVersionAchievementTierSearchPostWithHttpInfo($version, $device_id = null, $account_id = null, $app_key = null, $keyword = null, $achievement_type = null, $rank_type = null, $sort_field = null, $descending = null, $descending_goal = null, $start = null, $limit = null, string $contentType = self::contentTypes['apiVersionAchievementTierSearchPost'][0])
    {
        $request = $this->apiVersionAchievementTierSearchPostRequest($version, $device_id, $account_id, $app_key, $keyword, $achievement_type, $rank_type, $sort_field, $descending, $descending_goal, $start, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\AchievementTierResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\AchievementTierResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AchievementTierResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation apiVersionAchievementTierSearchPostAsync
     *
     * Searches an Achievement Tier
     *
     * @param  float $version (required)
     * @param  string|null $device_id a unique id given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  string|null $app_key the application key (optional)
     * @param  string|null $keyword the keyword used to filter resutls with (this returns results that have the keyword in the title or the description of the achievement tier) (optional)
     * @param  int|null $achievement_type filter results by achievementType (these are exact case sensitive matches) (optional)
     * @param  string|null $rank_type filter results by the rankType (these are the exact case sensitive matches) (optional)
     * @param  string|null $sort_field the field to sort by. See {@link AchievementApiMap} (optional)
     * @param  bool|null $descending determines whether the sort list is in descending or ascending order (of the achievement) (optional)
     * @param  bool|null $descending_goal determines whether the results are in descending or ascending order by the tier goal count (after the initial sort on the achievement) (optional)
     * @param  int|null $start The start of the index for pagination (optional)
     * @param  int|null $limit the limit for pagination (has a hard limit of 1000) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiVersionAchievementTierSearchPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiVersionAchievementTierSearchPostAsync($version, $device_id = null, $account_id = null, $app_key = null, $keyword = null, $achievement_type = null, $rank_type = null, $sort_field = null, $descending = null, $descending_goal = null, $start = null, $limit = null, string $contentType = self::contentTypes['apiVersionAchievementTierSearchPost'][0])
    {
        return $this->apiVersionAchievementTierSearchPostAsyncWithHttpInfo($version, $device_id, $account_id, $app_key, $keyword, $achievement_type, $rank_type, $sort_field, $descending, $descending_goal, $start, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiVersionAchievementTierSearchPostAsyncWithHttpInfo
     *
     * Searches an Achievement Tier
     *
     * @param  float $version (required)
     * @param  string|null $device_id a unique id given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  string|null $app_key the application key (optional)
     * @param  string|null $keyword the keyword used to filter resutls with (this returns results that have the keyword in the title or the description of the achievement tier) (optional)
     * @param  int|null $achievement_type filter results by achievementType (these are exact case sensitive matches) (optional)
     * @param  string|null $rank_type filter results by the rankType (these are the exact case sensitive matches) (optional)
     * @param  string|null $sort_field the field to sort by. See {@link AchievementApiMap} (optional)
     * @param  bool|null $descending determines whether the sort list is in descending or ascending order (of the achievement) (optional)
     * @param  bool|null $descending_goal determines whether the results are in descending or ascending order by the tier goal count (after the initial sort on the achievement) (optional)
     * @param  int|null $start The start of the index for pagination (optional)
     * @param  int|null $limit the limit for pagination (has a hard limit of 1000) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiVersionAchievementTierSearchPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiVersionAchievementTierSearchPostAsyncWithHttpInfo($version, $device_id = null, $account_id = null, $app_key = null, $keyword = null, $achievement_type = null, $rank_type = null, $sort_field = null, $descending = null, $descending_goal = null, $start = null, $limit = null, string $contentType = self::contentTypes['apiVersionAchievementTierSearchPost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\AchievementTierResponse';
        $request = $this->apiVersionAchievementTierSearchPostRequest($version, $device_id, $account_id, $app_key, $keyword, $achievement_type, $rank_type, $sort_field, $descending, $descending_goal, $start, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiVersionAchievementTierSearchPost'
     *
     * @param  float $version (required)
     * @param  string|null $device_id a unique id given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  string|null $app_key the application key (optional)
     * @param  string|null $keyword the keyword used to filter resutls with (this returns results that have the keyword in the title or the description of the achievement tier) (optional)
     * @param  int|null $achievement_type filter results by achievementType (these are exact case sensitive matches) (optional)
     * @param  string|null $rank_type filter results by the rankType (these are the exact case sensitive matches) (optional)
     * @param  string|null $sort_field the field to sort by. See {@link AchievementApiMap} (optional)
     * @param  bool|null $descending determines whether the sort list is in descending or ascending order (of the achievement) (optional)
     * @param  bool|null $descending_goal determines whether the results are in descending or ascending order by the tier goal count (after the initial sort on the achievement) (optional)
     * @param  int|null $start The start of the index for pagination (optional)
     * @param  int|null $limit the limit for pagination (has a hard limit of 1000) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiVersionAchievementTierSearchPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiVersionAchievementTierSearchPostRequest($version, $device_id = null, $account_id = null, $app_key = null, $keyword = null, $achievement_type = null, $rank_type = null, $sort_field = null, $descending = null, $descending_goal = null, $start = null, $limit = null, string $contentType = self::contentTypes['apiVersionAchievementTierSearchPost'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling apiVersionAchievementTierSearchPost'
            );
        }













        $resourcePath = '/api/{version}/achievement/tier/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_id,
            'deviceId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $app_key,
            'appKey', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $keyword,
            'keyword', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $achievement_type,
            'achievementType', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rank_type,
            'rankType', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort_field,
            'sortField', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $descending,
            'descending', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $descending_goal,
            'descendingGoal', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start,
            'start', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createAchievement
     *
     * Create Achievement
     *
     * @param  float $version version (required)
     * @param  string $app_key the application key the achievement is for (required)
     * @param  string $title the title of the achievement (255 character limit) (required)
     * @param  string|null $device_id a unique id given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  string|null $analytics_tag the analytics tag that will trigger when a user&#39;s achievement count gets updated (optional)
     * @param  string|null $description the description of the achievement (optional)
     * @param  string|null $rank_type the rank type for updating leader boards (optional)
     * @param  int|null $rank_increment determines how much the rank count is incremented (optional)
     * @param  int|null $min_increment restrict scores to be above or equal to this minimum value (optional)
     * @param  int|null $max_increment restrict scores to be below or equal to this maximum value (optional)
     * @param  bool|null $validate determines whether the customId on analytics are used to validate a user&#39;s achievement progress. (optional)
     * @param  bool|null $active achievement is active or inactive (optional)
     * @param  string|null $trigger_definition if provided will define what triggers to run after a tier is completed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAchievement'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AchievementResponse
     */
    public function createAchievement($version, $app_key, $title, $device_id = null, $account_id = null, $analytics_tag = null, $description = null, $rank_type = null, $rank_increment = null, $min_increment = null, $max_increment = null, $validate = null, $active = null, $trigger_definition = null, string $contentType = self::contentTypes['createAchievement'][0])
    {
        list($response) = $this->createAchievementWithHttpInfo($version, $app_key, $title, $device_id, $account_id, $analytics_tag, $description, $rank_type, $rank_increment, $min_increment, $max_increment, $validate, $active, $trigger_definition, $contentType);
        return $response;
    }

    /**
     * Operation createAchievementWithHttpInfo
     *
     * Create Achievement
     *
     * @param  float $version (required)
     * @param  string $app_key the application key the achievement is for (required)
     * @param  string $title the title of the achievement (255 character limit) (required)
     * @param  string|null $device_id a unique id given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  string|null $analytics_tag the analytics tag that will trigger when a user&#39;s achievement count gets updated (optional)
     * @param  string|null $description the description of the achievement (optional)
     * @param  string|null $rank_type the rank type for updating leader boards (optional)
     * @param  int|null $rank_increment determines how much the rank count is incremented (optional)
     * @param  int|null $min_increment restrict scores to be above or equal to this minimum value (optional)
     * @param  int|null $max_increment restrict scores to be below or equal to this maximum value (optional)
     * @param  bool|null $validate determines whether the customId on analytics are used to validate a user&#39;s achievement progress. (optional)
     * @param  bool|null $active achievement is active or inactive (optional)
     * @param  string|null $trigger_definition if provided will define what triggers to run after a tier is completed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAchievement'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AchievementResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createAchievementWithHttpInfo($version, $app_key, $title, $device_id = null, $account_id = null, $analytics_tag = null, $description = null, $rank_type = null, $rank_increment = null, $min_increment = null, $max_increment = null, $validate = null, $active = null, $trigger_definition = null, string $contentType = self::contentTypes['createAchievement'][0])
    {
        $request = $this->createAchievementRequest($version, $app_key, $title, $device_id, $account_id, $analytics_tag, $description, $rank_type, $rank_increment, $min_increment, $max_increment, $validate, $active, $trigger_definition, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\AchievementResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\AchievementResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AchievementResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createAchievementAsync
     *
     * Create Achievement
     *
     * @param  float $version (required)
     * @param  string $app_key the application key the achievement is for (required)
     * @param  string $title the title of the achievement (255 character limit) (required)
     * @param  string|null $device_id a unique id given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  string|null $analytics_tag the analytics tag that will trigger when a user&#39;s achievement count gets updated (optional)
     * @param  string|null $description the description of the achievement (optional)
     * @param  string|null $rank_type the rank type for updating leader boards (optional)
     * @param  int|null $rank_increment determines how much the rank count is incremented (optional)
     * @param  int|null $min_increment restrict scores to be above or equal to this minimum value (optional)
     * @param  int|null $max_increment restrict scores to be below or equal to this maximum value (optional)
     * @param  bool|null $validate determines whether the customId on analytics are used to validate a user&#39;s achievement progress. (optional)
     * @param  bool|null $active achievement is active or inactive (optional)
     * @param  string|null $trigger_definition if provided will define what triggers to run after a tier is completed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAchievement'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAchievementAsync($version, $app_key, $title, $device_id = null, $account_id = null, $analytics_tag = null, $description = null, $rank_type = null, $rank_increment = null, $min_increment = null, $max_increment = null, $validate = null, $active = null, $trigger_definition = null, string $contentType = self::contentTypes['createAchievement'][0])
    {
        return $this->createAchievementAsyncWithHttpInfo($version, $app_key, $title, $device_id, $account_id, $analytics_tag, $description, $rank_type, $rank_increment, $min_increment, $max_increment, $validate, $active, $trigger_definition, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createAchievementAsyncWithHttpInfo
     *
     * Create Achievement
     *
     * @param  float $version (required)
     * @param  string $app_key the application key the achievement is for (required)
     * @param  string $title the title of the achievement (255 character limit) (required)
     * @param  string|null $device_id a unique id given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  string|null $analytics_tag the analytics tag that will trigger when a user&#39;s achievement count gets updated (optional)
     * @param  string|null $description the description of the achievement (optional)
     * @param  string|null $rank_type the rank type for updating leader boards (optional)
     * @param  int|null $rank_increment determines how much the rank count is incremented (optional)
     * @param  int|null $min_increment restrict scores to be above or equal to this minimum value (optional)
     * @param  int|null $max_increment restrict scores to be below or equal to this maximum value (optional)
     * @param  bool|null $validate determines whether the customId on analytics are used to validate a user&#39;s achievement progress. (optional)
     * @param  bool|null $active achievement is active or inactive (optional)
     * @param  string|null $trigger_definition if provided will define what triggers to run after a tier is completed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAchievement'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAchievementAsyncWithHttpInfo($version, $app_key, $title, $device_id = null, $account_id = null, $analytics_tag = null, $description = null, $rank_type = null, $rank_increment = null, $min_increment = null, $max_increment = null, $validate = null, $active = null, $trigger_definition = null, string $contentType = self::contentTypes['createAchievement'][0])
    {
        $returnType = '\OpenAPI\Client\Model\AchievementResponse';
        $request = $this->createAchievementRequest($version, $app_key, $title, $device_id, $account_id, $analytics_tag, $description, $rank_type, $rank_increment, $min_increment, $max_increment, $validate, $active, $trigger_definition, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createAchievement'
     *
     * @param  float $version (required)
     * @param  string $app_key the application key the achievement is for (required)
     * @param  string $title the title of the achievement (255 character limit) (required)
     * @param  string|null $device_id a unique id given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  string|null $analytics_tag the analytics tag that will trigger when a user&#39;s achievement count gets updated (optional)
     * @param  string|null $description the description of the achievement (optional)
     * @param  string|null $rank_type the rank type for updating leader boards (optional)
     * @param  int|null $rank_increment determines how much the rank count is incremented (optional)
     * @param  int|null $min_increment restrict scores to be above or equal to this minimum value (optional)
     * @param  int|null $max_increment restrict scores to be below or equal to this maximum value (optional)
     * @param  bool|null $validate determines whether the customId on analytics are used to validate a user&#39;s achievement progress. (optional)
     * @param  bool|null $active achievement is active or inactive (optional)
     * @param  string|null $trigger_definition if provided will define what triggers to run after a tier is completed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAchievement'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createAchievementRequest($version, $app_key, $title, $device_id = null, $account_id = null, $analytics_tag = null, $description = null, $rank_type = null, $rank_increment = null, $min_increment = null, $max_increment = null, $validate = null, $active = null, $trigger_definition = null, string $contentType = self::contentTypes['createAchievement'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling createAchievement'
            );
        }

        // verify the required parameter 'app_key' is set
        if ($app_key === null || (is_array($app_key) && count($app_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_key when calling createAchievement'
            );
        }

        // verify the required parameter 'title' is set
        if ($title === null || (is_array($title) && count($title) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $title when calling createAchievement'
            );
        }













        $resourcePath = '/api/{version}/achievement/create';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_id,
            'deviceId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $app_key,
            'appKey', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $analytics_tag,
            'analyticsTag', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $title,
            'title', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description,
            'description', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rank_type,
            'rankType', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rank_increment,
            'rankIncrement', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_increment,
            'minIncrement', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_increment,
            'maxIncrement', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $validate,
            'validate', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $active,
            'active', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $trigger_definition,
            'triggerDefinition', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createAchievementTier
     *
     * Create Achievement Tier
     *
     * @param  float $version version (required)
     * @param  int $achievement_id the achievement id for adding a new tier (required)
     * @param  bool $score_all_instances score all instances (required)
     * @param  string|null $device_id a unique id given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  \SplFileObject|null $icon achievement tier icon image file (optional)
     * @param  int|null $icon_asset_id the icon assetId, if icon is provided, icon will overrule (optional)
     * @param  string|null $title the title of the achievement tier (optional)
     * @param  string|null $description the description of the achievement tier (optional)
     * @param  int|null $goal_count the count requirement for completing the achievement tier (optional)
     * @param  int|null $mission_id The ID of the mission to associate with the achievement (optional)
     * @param  int|null $game_id The ID of the game to associate with the achievement (optional)
     * @param  int|null $pack_id The ID of the pack to associate with the achievement (optional)
     * @param  int|null $game_level_id The ID of the game level to associate with the achievement (optional)
     * @param  int|null $game_object_id The ID of the game object to associate with the achievement (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAchievementTier'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AchievementTierResponse
     */
    public function createAchievementTier($version, $achievement_id, $score_all_instances, $device_id = null, $account_id = null, $icon = null, $icon_asset_id = null, $title = null, $description = null, $goal_count = null, $mission_id = null, $game_id = null, $pack_id = null, $game_level_id = null, $game_object_id = null, string $contentType = self::contentTypes['createAchievementTier'][0])
    {
        list($response) = $this->createAchievementTierWithHttpInfo($version, $achievement_id, $score_all_instances, $device_id, $account_id, $icon, $icon_asset_id, $title, $description, $goal_count, $mission_id, $game_id, $pack_id, $game_level_id, $game_object_id, $contentType);
        return $response;
    }

    /**
     * Operation createAchievementTierWithHttpInfo
     *
     * Create Achievement Tier
     *
     * @param  float $version (required)
     * @param  int $achievement_id the achievement id for adding a new tier (required)
     * @param  bool $score_all_instances score all instances (required)
     * @param  string|null $device_id a unique id given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  \SplFileObject|null $icon achievement tier icon image file (optional)
     * @param  int|null $icon_asset_id the icon assetId, if icon is provided, icon will overrule (optional)
     * @param  string|null $title the title of the achievement tier (optional)
     * @param  string|null $description the description of the achievement tier (optional)
     * @param  int|null $goal_count the count requirement for completing the achievement tier (optional)
     * @param  int|null $mission_id The ID of the mission to associate with the achievement (optional)
     * @param  int|null $game_id The ID of the game to associate with the achievement (optional)
     * @param  int|null $pack_id The ID of the pack to associate with the achievement (optional)
     * @param  int|null $game_level_id The ID of the game level to associate with the achievement (optional)
     * @param  int|null $game_object_id The ID of the game object to associate with the achievement (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAchievementTier'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AchievementTierResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createAchievementTierWithHttpInfo($version, $achievement_id, $score_all_instances, $device_id = null, $account_id = null, $icon = null, $icon_asset_id = null, $title = null, $description = null, $goal_count = null, $mission_id = null, $game_id = null, $pack_id = null, $game_level_id = null, $game_object_id = null, string $contentType = self::contentTypes['createAchievementTier'][0])
    {
        $request = $this->createAchievementTierRequest($version, $achievement_id, $score_all_instances, $device_id, $account_id, $icon, $icon_asset_id, $title, $description, $goal_count, $mission_id, $game_id, $pack_id, $game_level_id, $game_object_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\AchievementTierResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\AchievementTierResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AchievementTierResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createAchievementTierAsync
     *
     * Create Achievement Tier
     *
     * @param  float $version (required)
     * @param  int $achievement_id the achievement id for adding a new tier (required)
     * @param  bool $score_all_instances score all instances (required)
     * @param  string|null $device_id a unique id given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  \SplFileObject|null $icon achievement tier icon image file (optional)
     * @param  int|null $icon_asset_id the icon assetId, if icon is provided, icon will overrule (optional)
     * @param  string|null $title the title of the achievement tier (optional)
     * @param  string|null $description the description of the achievement tier (optional)
     * @param  int|null $goal_count the count requirement for completing the achievement tier (optional)
     * @param  int|null $mission_id The ID of the mission to associate with the achievement (optional)
     * @param  int|null $game_id The ID of the game to associate with the achievement (optional)
     * @param  int|null $pack_id The ID of the pack to associate with the achievement (optional)
     * @param  int|null $game_level_id The ID of the game level to associate with the achievement (optional)
     * @param  int|null $game_object_id The ID of the game object to associate with the achievement (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAchievementTier'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAchievementTierAsync($version, $achievement_id, $score_all_instances, $device_id = null, $account_id = null, $icon = null, $icon_asset_id = null, $title = null, $description = null, $goal_count = null, $mission_id = null, $game_id = null, $pack_id = null, $game_level_id = null, $game_object_id = null, string $contentType = self::contentTypes['createAchievementTier'][0])
    {
        return $this->createAchievementTierAsyncWithHttpInfo($version, $achievement_id, $score_all_instances, $device_id, $account_id, $icon, $icon_asset_id, $title, $description, $goal_count, $mission_id, $game_id, $pack_id, $game_level_id, $game_object_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createAchievementTierAsyncWithHttpInfo
     *
     * Create Achievement Tier
     *
     * @param  float $version (required)
     * @param  int $achievement_id the achievement id for adding a new tier (required)
     * @param  bool $score_all_instances score all instances (required)
     * @param  string|null $device_id a unique id given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  \SplFileObject|null $icon achievement tier icon image file (optional)
     * @param  int|null $icon_asset_id the icon assetId, if icon is provided, icon will overrule (optional)
     * @param  string|null $title the title of the achievement tier (optional)
     * @param  string|null $description the description of the achievement tier (optional)
     * @param  int|null $goal_count the count requirement for completing the achievement tier (optional)
     * @param  int|null $mission_id The ID of the mission to associate with the achievement (optional)
     * @param  int|null $game_id The ID of the game to associate with the achievement (optional)
     * @param  int|null $pack_id The ID of the pack to associate with the achievement (optional)
     * @param  int|null $game_level_id The ID of the game level to associate with the achievement (optional)
     * @param  int|null $game_object_id The ID of the game object to associate with the achievement (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAchievementTier'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAchievementTierAsyncWithHttpInfo($version, $achievement_id, $score_all_instances, $device_id = null, $account_id = null, $icon = null, $icon_asset_id = null, $title = null, $description = null, $goal_count = null, $mission_id = null, $game_id = null, $pack_id = null, $game_level_id = null, $game_object_id = null, string $contentType = self::contentTypes['createAchievementTier'][0])
    {
        $returnType = '\OpenAPI\Client\Model\AchievementTierResponse';
        $request = $this->createAchievementTierRequest($version, $achievement_id, $score_all_instances, $device_id, $account_id, $icon, $icon_asset_id, $title, $description, $goal_count, $mission_id, $game_id, $pack_id, $game_level_id, $game_object_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createAchievementTier'
     *
     * @param  float $version (required)
     * @param  int $achievement_id the achievement id for adding a new tier (required)
     * @param  bool $score_all_instances score all instances (required)
     * @param  string|null $device_id a unique id given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  \SplFileObject|null $icon achievement tier icon image file (optional)
     * @param  int|null $icon_asset_id the icon assetId, if icon is provided, icon will overrule (optional)
     * @param  string|null $title the title of the achievement tier (optional)
     * @param  string|null $description the description of the achievement tier (optional)
     * @param  int|null $goal_count the count requirement for completing the achievement tier (optional)
     * @param  int|null $mission_id The ID of the mission to associate with the achievement (optional)
     * @param  int|null $game_id The ID of the game to associate with the achievement (optional)
     * @param  int|null $pack_id The ID of the pack to associate with the achievement (optional)
     * @param  int|null $game_level_id The ID of the game level to associate with the achievement (optional)
     * @param  int|null $game_object_id The ID of the game object to associate with the achievement (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAchievementTier'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createAchievementTierRequest($version, $achievement_id, $score_all_instances, $device_id = null, $account_id = null, $icon = null, $icon_asset_id = null, $title = null, $description = null, $goal_count = null, $mission_id = null, $game_id = null, $pack_id = null, $game_level_id = null, $game_object_id = null, string $contentType = self::contentTypes['createAchievementTier'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling createAchievementTier'
            );
        }

        // verify the required parameter 'achievement_id' is set
        if ($achievement_id === null || (is_array($achievement_id) && count($achievement_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $achievement_id when calling createAchievementTier'
            );
        }

        // verify the required parameter 'score_all_instances' is set
        if ($score_all_instances === null || (is_array($score_all_instances) && count($score_all_instances) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $score_all_instances when calling createAchievementTier'
            );
        }














        $resourcePath = '/api/{version}/achievement/tier/create';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_id,
            'deviceId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $achievement_id,
            'achievementId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $icon,
            'icon', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $icon_asset_id,
            'iconAssetId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $title,
            'title', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description,
            'description', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $goal_count,
            'goalCount', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $mission_id,
            'missionId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $game_id,
            'gameId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pack_id,
            'packId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $game_level_id,
            'gameLevelId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $game_object_id,
            'gameObjectId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $score_all_instances,
            'scoreAllInstances', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteAchievement
     *
     * Delete Achievement
     *
     * @param  float $version version (required)
     * @param  int $achievement_id The ID of the achievement (required)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAchievement'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SirqulResponse
     */
    public function deleteAchievement($version, $achievement_id, $account_id = null, string $contentType = self::contentTypes['deleteAchievement'][0])
    {
        list($response) = $this->deleteAchievementWithHttpInfo($version, $achievement_id, $account_id, $contentType);
        return $response;
    }

    /**
     * Operation deleteAchievementWithHttpInfo
     *
     * Delete Achievement
     *
     * @param  float $version (required)
     * @param  int $achievement_id The ID of the achievement (required)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAchievement'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SirqulResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteAchievementWithHttpInfo($version, $achievement_id, $account_id = null, string $contentType = self::contentTypes['deleteAchievement'][0])
    {
        $request = $this->deleteAchievementRequest($version, $achievement_id, $account_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\SirqulResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\SirqulResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SirqulResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteAchievementAsync
     *
     * Delete Achievement
     *
     * @param  float $version (required)
     * @param  int $achievement_id The ID of the achievement (required)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAchievement'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAchievementAsync($version, $achievement_id, $account_id = null, string $contentType = self::contentTypes['deleteAchievement'][0])
    {
        return $this->deleteAchievementAsyncWithHttpInfo($version, $achievement_id, $account_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteAchievementAsyncWithHttpInfo
     *
     * Delete Achievement
     *
     * @param  float $version (required)
     * @param  int $achievement_id The ID of the achievement (required)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAchievement'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAchievementAsyncWithHttpInfo($version, $achievement_id, $account_id = null, string $contentType = self::contentTypes['deleteAchievement'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SirqulResponse';
        $request = $this->deleteAchievementRequest($version, $achievement_id, $account_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteAchievement'
     *
     * @param  float $version (required)
     * @param  int $achievement_id The ID of the achievement (required)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAchievement'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteAchievementRequest($version, $achievement_id, $account_id = null, string $contentType = self::contentTypes['deleteAchievement'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling deleteAchievement'
            );
        }

        // verify the required parameter 'achievement_id' is set
        if ($achievement_id === null || (is_array($achievement_id) && count($achievement_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $achievement_id when calling deleteAchievement'
            );
        }



        $resourcePath = '/api/{version}/achievement/delete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $achievement_id,
            'achievementId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteAchievementTier
     *
     * Delete Achievement Tier
     *
     * @param  float $version version (required)
     * @param  int $achievement_tier_id the achievement id for deletion (required)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAchievementTier'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SirqulResponse
     */
    public function deleteAchievementTier($version, $achievement_tier_id, $account_id = null, string $contentType = self::contentTypes['deleteAchievementTier'][0])
    {
        list($response) = $this->deleteAchievementTierWithHttpInfo($version, $achievement_tier_id, $account_id, $contentType);
        return $response;
    }

    /**
     * Operation deleteAchievementTierWithHttpInfo
     *
     * Delete Achievement Tier
     *
     * @param  float $version (required)
     * @param  int $achievement_tier_id the achievement id for deletion (required)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAchievementTier'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SirqulResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteAchievementTierWithHttpInfo($version, $achievement_tier_id, $account_id = null, string $contentType = self::contentTypes['deleteAchievementTier'][0])
    {
        $request = $this->deleteAchievementTierRequest($version, $achievement_tier_id, $account_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\SirqulResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\SirqulResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SirqulResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteAchievementTierAsync
     *
     * Delete Achievement Tier
     *
     * @param  float $version (required)
     * @param  int $achievement_tier_id the achievement id for deletion (required)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAchievementTier'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAchievementTierAsync($version, $achievement_tier_id, $account_id = null, string $contentType = self::contentTypes['deleteAchievementTier'][0])
    {
        return $this->deleteAchievementTierAsyncWithHttpInfo($version, $achievement_tier_id, $account_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteAchievementTierAsyncWithHttpInfo
     *
     * Delete Achievement Tier
     *
     * @param  float $version (required)
     * @param  int $achievement_tier_id the achievement id for deletion (required)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAchievementTier'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAchievementTierAsyncWithHttpInfo($version, $achievement_tier_id, $account_id = null, string $contentType = self::contentTypes['deleteAchievementTier'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SirqulResponse';
        $request = $this->deleteAchievementTierRequest($version, $achievement_tier_id, $account_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteAchievementTier'
     *
     * @param  float $version (required)
     * @param  int $achievement_tier_id the achievement id for deletion (required)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAchievementTier'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteAchievementTierRequest($version, $achievement_tier_id, $account_id = null, string $contentType = self::contentTypes['deleteAchievementTier'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling deleteAchievementTier'
            );
        }

        // verify the required parameter 'achievement_tier_id' is set
        if ($achievement_tier_id === null || (is_array($achievement_tier_id) && count($achievement_tier_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $achievement_tier_id when calling deleteAchievementTier'
            );
        }



        $resourcePath = '/api/{version}/achievement/tier/delete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $achievement_tier_id,
            'achievementTierId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAchievement
     *
     * Get Achievement
     *
     * @param  float $version version (required)
     * @param  int $achievement_id The ID of the achievement (required)
     * @param  string|null $device_id a unique id given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  string|null $achievement_type achievementType (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAchievement'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AchievementTierResponse
     */
    public function getAchievement($version, $achievement_id, $device_id = null, $account_id = null, $achievement_type = null, string $contentType = self::contentTypes['getAchievement'][0])
    {
        list($response) = $this->getAchievementWithHttpInfo($version, $achievement_id, $device_id, $account_id, $achievement_type, $contentType);
        return $response;
    }

    /**
     * Operation getAchievementWithHttpInfo
     *
     * Get Achievement
     *
     * @param  float $version (required)
     * @param  int $achievement_id The ID of the achievement (required)
     * @param  string|null $device_id a unique id given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  string|null $achievement_type achievementType (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAchievement'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AchievementTierResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAchievementWithHttpInfo($version, $achievement_id, $device_id = null, $account_id = null, $achievement_type = null, string $contentType = self::contentTypes['getAchievement'][0])
    {
        $request = $this->getAchievementRequest($version, $achievement_id, $device_id, $account_id, $achievement_type, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\AchievementTierResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\AchievementTierResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AchievementTierResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getAchievementAsync
     *
     * Get Achievement
     *
     * @param  float $version (required)
     * @param  int $achievement_id The ID of the achievement (required)
     * @param  string|null $device_id a unique id given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  string|null $achievement_type achievementType (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAchievement'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAchievementAsync($version, $achievement_id, $device_id = null, $account_id = null, $achievement_type = null, string $contentType = self::contentTypes['getAchievement'][0])
    {
        return $this->getAchievementAsyncWithHttpInfo($version, $achievement_id, $device_id, $account_id, $achievement_type, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAchievementAsyncWithHttpInfo
     *
     * Get Achievement
     *
     * @param  float $version (required)
     * @param  int $achievement_id The ID of the achievement (required)
     * @param  string|null $device_id a unique id given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  string|null $achievement_type achievementType (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAchievement'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAchievementAsyncWithHttpInfo($version, $achievement_id, $device_id = null, $account_id = null, $achievement_type = null, string $contentType = self::contentTypes['getAchievement'][0])
    {
        $returnType = '\OpenAPI\Client\Model\AchievementTierResponse';
        $request = $this->getAchievementRequest($version, $achievement_id, $device_id, $account_id, $achievement_type, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAchievement'
     *
     * @param  float $version (required)
     * @param  int $achievement_id The ID of the achievement (required)
     * @param  string|null $device_id a unique id given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  string|null $achievement_type achievementType (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAchievement'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAchievementRequest($version, $achievement_id, $device_id = null, $account_id = null, $achievement_type = null, string $contentType = self::contentTypes['getAchievement'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling getAchievement'
            );
        }

        // verify the required parameter 'achievement_id' is set
        if ($achievement_id === null || (is_array($achievement_id) && count($achievement_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $achievement_id when calling getAchievement'
            );
        }





        $resourcePath = '/api/{version}/achievement/get';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_id,
            'deviceId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $achievement_id,
            'achievementId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $achievement_type,
            'achievementType', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAchievementTier
     *
     * Gets an achievement tier
     *
     * @param  float $version version (required)
     * @param  int $account_id the account id of the user (deviceId or accountId required) (required)
     * @param  int $achievement_tier_id the achievement tier id that is being retrieved (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAchievementTier'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AchievementTierResponse
     */
    public function getAchievementTier($version, $account_id, $achievement_tier_id, string $contentType = self::contentTypes['getAchievementTier'][0])
    {
        list($response) = $this->getAchievementTierWithHttpInfo($version, $account_id, $achievement_tier_id, $contentType);
        return $response;
    }

    /**
     * Operation getAchievementTierWithHttpInfo
     *
     * Gets an achievement tier
     *
     * @param  float $version (required)
     * @param  int $account_id the account id of the user (deviceId or accountId required) (required)
     * @param  int $achievement_tier_id the achievement tier id that is being retrieved (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAchievementTier'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AchievementTierResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAchievementTierWithHttpInfo($version, $account_id, $achievement_tier_id, string $contentType = self::contentTypes['getAchievementTier'][0])
    {
        $request = $this->getAchievementTierRequest($version, $account_id, $achievement_tier_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\AchievementTierResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\AchievementTierResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AchievementTierResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getAchievementTierAsync
     *
     * Gets an achievement tier
     *
     * @param  float $version (required)
     * @param  int $account_id the account id of the user (deviceId or accountId required) (required)
     * @param  int $achievement_tier_id the achievement tier id that is being retrieved (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAchievementTier'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAchievementTierAsync($version, $account_id, $achievement_tier_id, string $contentType = self::contentTypes['getAchievementTier'][0])
    {
        return $this->getAchievementTierAsyncWithHttpInfo($version, $account_id, $achievement_tier_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAchievementTierAsyncWithHttpInfo
     *
     * Gets an achievement tier
     *
     * @param  float $version (required)
     * @param  int $account_id the account id of the user (deviceId or accountId required) (required)
     * @param  int $achievement_tier_id the achievement tier id that is being retrieved (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAchievementTier'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAchievementTierAsyncWithHttpInfo($version, $account_id, $achievement_tier_id, string $contentType = self::contentTypes['getAchievementTier'][0])
    {
        $returnType = '\OpenAPI\Client\Model\AchievementTierResponse';
        $request = $this->getAchievementTierRequest($version, $account_id, $achievement_tier_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAchievementTier'
     *
     * @param  float $version (required)
     * @param  int $account_id the account id of the user (deviceId or accountId required) (required)
     * @param  int $achievement_tier_id the achievement tier id that is being retrieved (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAchievementTier'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAchievementTierRequest($version, $account_id, $achievement_tier_id, string $contentType = self::contentTypes['getAchievementTier'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling getAchievementTier'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling getAchievementTier'
            );
        }

        // verify the required parameter 'achievement_tier_id' is set
        if ($achievement_tier_id === null || (is_array($achievement_tier_id) && count($achievement_tier_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $achievement_tier_id when calling getAchievementTier'
            );
        }


        $resourcePath = '/api/{version}/achievement/tier/get';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $achievement_tier_id,
            'achievementTierId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getUserAchievements
     *
     * Get Achievement Progress
     *
     * @param  float $version version (required)
     * @param  bool $return_nulls determines whether to return null fields in the response (required)
     * @param  string $app_key the application key for filtering results by application (required)
     * @param  bool $include_undiscovered determines whether to return achievements that the user has not discovered yet (required)
     * @param  string|null $device_id a unique id given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  string|null $connection_account_email the email of the account to view achievements (optional)
     * @param  int|null $connection_account_id the id of the account to view achievements (optional)
     * @param  string|null $rank_type filter results by achievement rankType (optional)
     * @param  string|null $achievement_type filter results by achievement type (optional)
     * @param  float|null $latitude the current latitude of the user (optional)
     * @param  float|null $longitude the current longitude of the user (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserAchievements'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AchievementProgressResponse[]
     */
    public function getUserAchievements($version, $return_nulls, $app_key, $include_undiscovered, $device_id = null, $account_id = null, $connection_account_email = null, $connection_account_id = null, $rank_type = null, $achievement_type = null, $latitude = null, $longitude = null, string $contentType = self::contentTypes['getUserAchievements'][0])
    {
        list($response) = $this->getUserAchievementsWithHttpInfo($version, $return_nulls, $app_key, $include_undiscovered, $device_id, $account_id, $connection_account_email, $connection_account_id, $rank_type, $achievement_type, $latitude, $longitude, $contentType);
        return $response;
    }

    /**
     * Operation getUserAchievementsWithHttpInfo
     *
     * Get Achievement Progress
     *
     * @param  float $version (required)
     * @param  bool $return_nulls determines whether to return null fields in the response (required)
     * @param  string $app_key the application key for filtering results by application (required)
     * @param  bool $include_undiscovered determines whether to return achievements that the user has not discovered yet (required)
     * @param  string|null $device_id a unique id given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  string|null $connection_account_email the email of the account to view achievements (optional)
     * @param  int|null $connection_account_id the id of the account to view achievements (optional)
     * @param  string|null $rank_type filter results by achievement rankType (optional)
     * @param  string|null $achievement_type filter results by achievement type (optional)
     * @param  float|null $latitude the current latitude of the user (optional)
     * @param  float|null $longitude the current longitude of the user (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserAchievements'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AchievementProgressResponse[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getUserAchievementsWithHttpInfo($version, $return_nulls, $app_key, $include_undiscovered, $device_id = null, $account_id = null, $connection_account_email = null, $connection_account_id = null, $rank_type = null, $achievement_type = null, $latitude = null, $longitude = null, string $contentType = self::contentTypes['getUserAchievements'][0])
    {
        $request = $this->getUserAchievementsRequest($version, $return_nulls, $app_key, $include_undiscovered, $device_id, $account_id, $connection_account_email, $connection_account_id, $rank_type, $achievement_type, $latitude, $longitude, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\AchievementProgressResponse[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\AchievementProgressResponse[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AchievementProgressResponse[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getUserAchievementsAsync
     *
     * Get Achievement Progress
     *
     * @param  float $version (required)
     * @param  bool $return_nulls determines whether to return null fields in the response (required)
     * @param  string $app_key the application key for filtering results by application (required)
     * @param  bool $include_undiscovered determines whether to return achievements that the user has not discovered yet (required)
     * @param  string|null $device_id a unique id given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  string|null $connection_account_email the email of the account to view achievements (optional)
     * @param  int|null $connection_account_id the id of the account to view achievements (optional)
     * @param  string|null $rank_type filter results by achievement rankType (optional)
     * @param  string|null $achievement_type filter results by achievement type (optional)
     * @param  float|null $latitude the current latitude of the user (optional)
     * @param  float|null $longitude the current longitude of the user (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserAchievements'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUserAchievementsAsync($version, $return_nulls, $app_key, $include_undiscovered, $device_id = null, $account_id = null, $connection_account_email = null, $connection_account_id = null, $rank_type = null, $achievement_type = null, $latitude = null, $longitude = null, string $contentType = self::contentTypes['getUserAchievements'][0])
    {
        return $this->getUserAchievementsAsyncWithHttpInfo($version, $return_nulls, $app_key, $include_undiscovered, $device_id, $account_id, $connection_account_email, $connection_account_id, $rank_type, $achievement_type, $latitude, $longitude, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getUserAchievementsAsyncWithHttpInfo
     *
     * Get Achievement Progress
     *
     * @param  float $version (required)
     * @param  bool $return_nulls determines whether to return null fields in the response (required)
     * @param  string $app_key the application key for filtering results by application (required)
     * @param  bool $include_undiscovered determines whether to return achievements that the user has not discovered yet (required)
     * @param  string|null $device_id a unique id given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  string|null $connection_account_email the email of the account to view achievements (optional)
     * @param  int|null $connection_account_id the id of the account to view achievements (optional)
     * @param  string|null $rank_type filter results by achievement rankType (optional)
     * @param  string|null $achievement_type filter results by achievement type (optional)
     * @param  float|null $latitude the current latitude of the user (optional)
     * @param  float|null $longitude the current longitude of the user (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserAchievements'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUserAchievementsAsyncWithHttpInfo($version, $return_nulls, $app_key, $include_undiscovered, $device_id = null, $account_id = null, $connection_account_email = null, $connection_account_id = null, $rank_type = null, $achievement_type = null, $latitude = null, $longitude = null, string $contentType = self::contentTypes['getUserAchievements'][0])
    {
        $returnType = '\OpenAPI\Client\Model\AchievementProgressResponse[]';
        $request = $this->getUserAchievementsRequest($version, $return_nulls, $app_key, $include_undiscovered, $device_id, $account_id, $connection_account_email, $connection_account_id, $rank_type, $achievement_type, $latitude, $longitude, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getUserAchievements'
     *
     * @param  float $version (required)
     * @param  bool $return_nulls determines whether to return null fields in the response (required)
     * @param  string $app_key the application key for filtering results by application (required)
     * @param  bool $include_undiscovered determines whether to return achievements that the user has not discovered yet (required)
     * @param  string|null $device_id a unique id given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  string|null $connection_account_email the email of the account to view achievements (optional)
     * @param  int|null $connection_account_id the id of the account to view achievements (optional)
     * @param  string|null $rank_type filter results by achievement rankType (optional)
     * @param  string|null $achievement_type filter results by achievement type (optional)
     * @param  float|null $latitude the current latitude of the user (optional)
     * @param  float|null $longitude the current longitude of the user (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserAchievements'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getUserAchievementsRequest($version, $return_nulls, $app_key, $include_undiscovered, $device_id = null, $account_id = null, $connection_account_email = null, $connection_account_id = null, $rank_type = null, $achievement_type = null, $latitude = null, $longitude = null, string $contentType = self::contentTypes['getUserAchievements'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling getUserAchievements'
            );
        }

        // verify the required parameter 'return_nulls' is set
        if ($return_nulls === null || (is_array($return_nulls) && count($return_nulls) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $return_nulls when calling getUserAchievements'
            );
        }

        // verify the required parameter 'app_key' is set
        if ($app_key === null || (is_array($app_key) && count($app_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_key when calling getUserAchievements'
            );
        }

        // verify the required parameter 'include_undiscovered' is set
        if ($include_undiscovered === null || (is_array($include_undiscovered) && count($include_undiscovered) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $include_undiscovered when calling getUserAchievements'
            );
        }










        $resourcePath = '/api/{version}/achievement/progress/get';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_nulls,
            'returnNulls', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_id,
            'deviceId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $connection_account_email,
            'connectionAccountEmail', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $connection_account_id,
            'connectionAccountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $app_key,
            'appKey', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rank_type,
            'rankType', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $achievement_type,
            'achievementType', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_undiscovered,
            'includeUndiscovered', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $latitude,
            'latitude', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $longitude,
            'longitude', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listAchievementTags
     *
     * List Achievement Tags
     *
     * @param  float $version version (required)
     * @param  string|null $app_key filter results by application key (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listAchievementTags'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SirqulResponse
     */
    public function listAchievementTags($version, $app_key = null, string $contentType = self::contentTypes['listAchievementTags'][0])
    {
        list($response) = $this->listAchievementTagsWithHttpInfo($version, $app_key, $contentType);
        return $response;
    }

    /**
     * Operation listAchievementTagsWithHttpInfo
     *
     * List Achievement Tags
     *
     * @param  float $version (required)
     * @param  string|null $app_key filter results by application key (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listAchievementTags'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SirqulResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listAchievementTagsWithHttpInfo($version, $app_key = null, string $contentType = self::contentTypes['listAchievementTags'][0])
    {
        $request = $this->listAchievementTagsRequest($version, $app_key, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\SirqulResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\SirqulResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SirqulResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listAchievementTagsAsync
     *
     * List Achievement Tags
     *
     * @param  float $version (required)
     * @param  string|null $app_key filter results by application key (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listAchievementTags'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listAchievementTagsAsync($version, $app_key = null, string $contentType = self::contentTypes['listAchievementTags'][0])
    {
        return $this->listAchievementTagsAsyncWithHttpInfo($version, $app_key, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listAchievementTagsAsyncWithHttpInfo
     *
     * List Achievement Tags
     *
     * @param  float $version (required)
     * @param  string|null $app_key filter results by application key (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listAchievementTags'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listAchievementTagsAsyncWithHttpInfo($version, $app_key = null, string $contentType = self::contentTypes['listAchievementTags'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SirqulResponse';
        $request = $this->listAchievementTagsRequest($version, $app_key, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listAchievementTags'
     *
     * @param  float $version (required)
     * @param  string|null $app_key filter results by application key (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listAchievementTags'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listAchievementTagsRequest($version, $app_key = null, string $contentType = self::contentTypes['listAchievementTags'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling listAchievementTags'
            );
        }



        $resourcePath = '/api/{version}/achievement/tag/list';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $app_key,
            'appKey', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listAchievements
     *
     * List Achievements
     *
     * @param  float $version version (required)
     * @param  string $sort_field the field to sort by. See AchievementApiMap (required)
     * @param  bool $descending determines whether the sorted list is in descending or ascending order (required)
     * @param  int $start the start index for pagination (required)
     * @param  int $limit the limit for pagination (has a hard limit of 1000) (required)
     * @param  bool $active_only Filter results to only return active achievements (required)
     * @param  string|null $device_id a unique id given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  string|null $app_key the application key (optional)
     * @param  string|null $keyword the keyword used to filter results with (this returns results that have the keyword in the title or description of the achievement) (optional)
     * @param  string|null $achievement_type filter results by the achievementType (these are exact case sensitive matches) (optional)
     * @param  string|null $rank_type filter results by the rankType (these are exact case sensitive matches) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listAchievements'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AchievementShortResponse[]
     */
    public function listAchievements($version, $sort_field, $descending, $start, $limit, $active_only, $device_id = null, $account_id = null, $app_key = null, $keyword = null, $achievement_type = null, $rank_type = null, string $contentType = self::contentTypes['listAchievements'][0])
    {
        list($response) = $this->listAchievementsWithHttpInfo($version, $sort_field, $descending, $start, $limit, $active_only, $device_id, $account_id, $app_key, $keyword, $achievement_type, $rank_type, $contentType);
        return $response;
    }

    /**
     * Operation listAchievementsWithHttpInfo
     *
     * List Achievements
     *
     * @param  float $version (required)
     * @param  string $sort_field the field to sort by. See AchievementApiMap (required)
     * @param  bool $descending determines whether the sorted list is in descending or ascending order (required)
     * @param  int $start the start index for pagination (required)
     * @param  int $limit the limit for pagination (has a hard limit of 1000) (required)
     * @param  bool $active_only Filter results to only return active achievements (required)
     * @param  string|null $device_id a unique id given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  string|null $app_key the application key (optional)
     * @param  string|null $keyword the keyword used to filter results with (this returns results that have the keyword in the title or description of the achievement) (optional)
     * @param  string|null $achievement_type filter results by the achievementType (these are exact case sensitive matches) (optional)
     * @param  string|null $rank_type filter results by the rankType (these are exact case sensitive matches) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listAchievements'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AchievementShortResponse[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listAchievementsWithHttpInfo($version, $sort_field, $descending, $start, $limit, $active_only, $device_id = null, $account_id = null, $app_key = null, $keyword = null, $achievement_type = null, $rank_type = null, string $contentType = self::contentTypes['listAchievements'][0])
    {
        $request = $this->listAchievementsRequest($version, $sort_field, $descending, $start, $limit, $active_only, $device_id, $account_id, $app_key, $keyword, $achievement_type, $rank_type, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\AchievementShortResponse[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\AchievementShortResponse[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AchievementShortResponse[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listAchievementsAsync
     *
     * List Achievements
     *
     * @param  float $version (required)
     * @param  string $sort_field the field to sort by. See AchievementApiMap (required)
     * @param  bool $descending determines whether the sorted list is in descending or ascending order (required)
     * @param  int $start the start index for pagination (required)
     * @param  int $limit the limit for pagination (has a hard limit of 1000) (required)
     * @param  bool $active_only Filter results to only return active achievements (required)
     * @param  string|null $device_id a unique id given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  string|null $app_key the application key (optional)
     * @param  string|null $keyword the keyword used to filter results with (this returns results that have the keyword in the title or description of the achievement) (optional)
     * @param  string|null $achievement_type filter results by the achievementType (these are exact case sensitive matches) (optional)
     * @param  string|null $rank_type filter results by the rankType (these are exact case sensitive matches) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listAchievements'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listAchievementsAsync($version, $sort_field, $descending, $start, $limit, $active_only, $device_id = null, $account_id = null, $app_key = null, $keyword = null, $achievement_type = null, $rank_type = null, string $contentType = self::contentTypes['listAchievements'][0])
    {
        return $this->listAchievementsAsyncWithHttpInfo($version, $sort_field, $descending, $start, $limit, $active_only, $device_id, $account_id, $app_key, $keyword, $achievement_type, $rank_type, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listAchievementsAsyncWithHttpInfo
     *
     * List Achievements
     *
     * @param  float $version (required)
     * @param  string $sort_field the field to sort by. See AchievementApiMap (required)
     * @param  bool $descending determines whether the sorted list is in descending or ascending order (required)
     * @param  int $start the start index for pagination (required)
     * @param  int $limit the limit for pagination (has a hard limit of 1000) (required)
     * @param  bool $active_only Filter results to only return active achievements (required)
     * @param  string|null $device_id a unique id given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  string|null $app_key the application key (optional)
     * @param  string|null $keyword the keyword used to filter results with (this returns results that have the keyword in the title or description of the achievement) (optional)
     * @param  string|null $achievement_type filter results by the achievementType (these are exact case sensitive matches) (optional)
     * @param  string|null $rank_type filter results by the rankType (these are exact case sensitive matches) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listAchievements'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listAchievementsAsyncWithHttpInfo($version, $sort_field, $descending, $start, $limit, $active_only, $device_id = null, $account_id = null, $app_key = null, $keyword = null, $achievement_type = null, $rank_type = null, string $contentType = self::contentTypes['listAchievements'][0])
    {
        $returnType = '\OpenAPI\Client\Model\AchievementShortResponse[]';
        $request = $this->listAchievementsRequest($version, $sort_field, $descending, $start, $limit, $active_only, $device_id, $account_id, $app_key, $keyword, $achievement_type, $rank_type, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listAchievements'
     *
     * @param  float $version (required)
     * @param  string $sort_field the field to sort by. See AchievementApiMap (required)
     * @param  bool $descending determines whether the sorted list is in descending or ascending order (required)
     * @param  int $start the start index for pagination (required)
     * @param  int $limit the limit for pagination (has a hard limit of 1000) (required)
     * @param  bool $active_only Filter results to only return active achievements (required)
     * @param  string|null $device_id a unique id given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  string|null $app_key the application key (optional)
     * @param  string|null $keyword the keyword used to filter results with (this returns results that have the keyword in the title or description of the achievement) (optional)
     * @param  string|null $achievement_type filter results by the achievementType (these are exact case sensitive matches) (optional)
     * @param  string|null $rank_type filter results by the rankType (these are exact case sensitive matches) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listAchievements'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listAchievementsRequest($version, $sort_field, $descending, $start, $limit, $active_only, $device_id = null, $account_id = null, $app_key = null, $keyword = null, $achievement_type = null, $rank_type = null, string $contentType = self::contentTypes['listAchievements'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling listAchievements'
            );
        }

        // verify the required parameter 'sort_field' is set
        if ($sort_field === null || (is_array($sort_field) && count($sort_field) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sort_field when calling listAchievements'
            );
        }

        // verify the required parameter 'descending' is set
        if ($descending === null || (is_array($descending) && count($descending) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $descending when calling listAchievements'
            );
        }

        // verify the required parameter 'start' is set
        if ($start === null || (is_array($start) && count($start) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $start when calling listAchievements'
            );
        }

        // verify the required parameter 'limit' is set
        if ($limit === null || (is_array($limit) && count($limit) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $limit when calling listAchievements'
            );
        }

        // verify the required parameter 'active_only' is set
        if ($active_only === null || (is_array($active_only) && count($active_only) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $active_only when calling listAchievements'
            );
        }








        $resourcePath = '/api/{version}/achievement/list';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_id,
            'deviceId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $app_key,
            'appKey', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $keyword,
            'keyword', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $achievement_type,
            'achievementType', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rank_type,
            'rankType', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort_field,
            'sortField', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $descending,
            'descending', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start,
            'start', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $active_only,
            'activeOnly', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchAchievements
     *
     * Search Achievements
     *
     * @param  float $version version (required)
     * @param  string $app_key the application key (required)
     * @param  string $sort_field the field to sort by. See AchievementApiMap (required)
     * @param  bool $descending determines whether the sorted list is in descending or ascending order (required)
     * @param  bool $include_tiers return tiers, only applicable for version &gt;3.18 (required)
     * @param  bool $include_inactive_tiers return inactive tiers, only applicable when includeTiers is true, only applicable for version &gt;3.18 (required)
     * @param  int $start the start index for pagination (required)
     * @param  int $limit the limit for pagination (has a hard limit of 1000) (required)
     * @param  string|null $device_id a unique id given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  string|null $keyword the keyword used to filter results with (this returns results that have the keyword in the title or description of the achievement) (optional)
     * @param  string|null $achievement_type filter results by the achievementType (these are exact case sensitive matches) (optional)
     * @param  string|null $rank_type filter results by the rankType (these are exact case sensitive matches) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchAchievements'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AchievementShortResponse[]
     */
    public function searchAchievements($version, $app_key, $sort_field, $descending, $include_tiers, $include_inactive_tiers, $start, $limit, $device_id = null, $account_id = null, $keyword = null, $achievement_type = null, $rank_type = null, string $contentType = self::contentTypes['searchAchievements'][0])
    {
        list($response) = $this->searchAchievementsWithHttpInfo($version, $app_key, $sort_field, $descending, $include_tiers, $include_inactive_tiers, $start, $limit, $device_id, $account_id, $keyword, $achievement_type, $rank_type, $contentType);
        return $response;
    }

    /**
     * Operation searchAchievementsWithHttpInfo
     *
     * Search Achievements
     *
     * @param  float $version (required)
     * @param  string $app_key the application key (required)
     * @param  string $sort_field the field to sort by. See AchievementApiMap (required)
     * @param  bool $descending determines whether the sorted list is in descending or ascending order (required)
     * @param  bool $include_tiers return tiers, only applicable for version &gt;3.18 (required)
     * @param  bool $include_inactive_tiers return inactive tiers, only applicable when includeTiers is true, only applicable for version &gt;3.18 (required)
     * @param  int $start the start index for pagination (required)
     * @param  int $limit the limit for pagination (has a hard limit of 1000) (required)
     * @param  string|null $device_id a unique id given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  string|null $keyword the keyword used to filter results with (this returns results that have the keyword in the title or description of the achievement) (optional)
     * @param  string|null $achievement_type filter results by the achievementType (these are exact case sensitive matches) (optional)
     * @param  string|null $rank_type filter results by the rankType (these are exact case sensitive matches) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchAchievements'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AchievementShortResponse[], HTTP status code, HTTP response headers (array of strings)
     */
    public function searchAchievementsWithHttpInfo($version, $app_key, $sort_field, $descending, $include_tiers, $include_inactive_tiers, $start, $limit, $device_id = null, $account_id = null, $keyword = null, $achievement_type = null, $rank_type = null, string $contentType = self::contentTypes['searchAchievements'][0])
    {
        $request = $this->searchAchievementsRequest($version, $app_key, $sort_field, $descending, $include_tiers, $include_inactive_tiers, $start, $limit, $device_id, $account_id, $keyword, $achievement_type, $rank_type, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\AchievementShortResponse[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\AchievementShortResponse[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AchievementShortResponse[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation searchAchievementsAsync
     *
     * Search Achievements
     *
     * @param  float $version (required)
     * @param  string $app_key the application key (required)
     * @param  string $sort_field the field to sort by. See AchievementApiMap (required)
     * @param  bool $descending determines whether the sorted list is in descending or ascending order (required)
     * @param  bool $include_tiers return tiers, only applicable for version &gt;3.18 (required)
     * @param  bool $include_inactive_tiers return inactive tiers, only applicable when includeTiers is true, only applicable for version &gt;3.18 (required)
     * @param  int $start the start index for pagination (required)
     * @param  int $limit the limit for pagination (has a hard limit of 1000) (required)
     * @param  string|null $device_id a unique id given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  string|null $keyword the keyword used to filter results with (this returns results that have the keyword in the title or description of the achievement) (optional)
     * @param  string|null $achievement_type filter results by the achievementType (these are exact case sensitive matches) (optional)
     * @param  string|null $rank_type filter results by the rankType (these are exact case sensitive matches) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchAchievements'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchAchievementsAsync($version, $app_key, $sort_field, $descending, $include_tiers, $include_inactive_tiers, $start, $limit, $device_id = null, $account_id = null, $keyword = null, $achievement_type = null, $rank_type = null, string $contentType = self::contentTypes['searchAchievements'][0])
    {
        return $this->searchAchievementsAsyncWithHttpInfo($version, $app_key, $sort_field, $descending, $include_tiers, $include_inactive_tiers, $start, $limit, $device_id, $account_id, $keyword, $achievement_type, $rank_type, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchAchievementsAsyncWithHttpInfo
     *
     * Search Achievements
     *
     * @param  float $version (required)
     * @param  string $app_key the application key (required)
     * @param  string $sort_field the field to sort by. See AchievementApiMap (required)
     * @param  bool $descending determines whether the sorted list is in descending or ascending order (required)
     * @param  bool $include_tiers return tiers, only applicable for version &gt;3.18 (required)
     * @param  bool $include_inactive_tiers return inactive tiers, only applicable when includeTiers is true, only applicable for version &gt;3.18 (required)
     * @param  int $start the start index for pagination (required)
     * @param  int $limit the limit for pagination (has a hard limit of 1000) (required)
     * @param  string|null $device_id a unique id given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  string|null $keyword the keyword used to filter results with (this returns results that have the keyword in the title or description of the achievement) (optional)
     * @param  string|null $achievement_type filter results by the achievementType (these are exact case sensitive matches) (optional)
     * @param  string|null $rank_type filter results by the rankType (these are exact case sensitive matches) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchAchievements'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchAchievementsAsyncWithHttpInfo($version, $app_key, $sort_field, $descending, $include_tiers, $include_inactive_tiers, $start, $limit, $device_id = null, $account_id = null, $keyword = null, $achievement_type = null, $rank_type = null, string $contentType = self::contentTypes['searchAchievements'][0])
    {
        $returnType = '\OpenAPI\Client\Model\AchievementShortResponse[]';
        $request = $this->searchAchievementsRequest($version, $app_key, $sort_field, $descending, $include_tiers, $include_inactive_tiers, $start, $limit, $device_id, $account_id, $keyword, $achievement_type, $rank_type, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchAchievements'
     *
     * @param  float $version (required)
     * @param  string $app_key the application key (required)
     * @param  string $sort_field the field to sort by. See AchievementApiMap (required)
     * @param  bool $descending determines whether the sorted list is in descending or ascending order (required)
     * @param  bool $include_tiers return tiers, only applicable for version &gt;3.18 (required)
     * @param  bool $include_inactive_tiers return inactive tiers, only applicable when includeTiers is true, only applicable for version &gt;3.18 (required)
     * @param  int $start the start index for pagination (required)
     * @param  int $limit the limit for pagination (has a hard limit of 1000) (required)
     * @param  string|null $device_id a unique id given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  string|null $keyword the keyword used to filter results with (this returns results that have the keyword in the title or description of the achievement) (optional)
     * @param  string|null $achievement_type filter results by the achievementType (these are exact case sensitive matches) (optional)
     * @param  string|null $rank_type filter results by the rankType (these are exact case sensitive matches) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchAchievements'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function searchAchievementsRequest($version, $app_key, $sort_field, $descending, $include_tiers, $include_inactive_tiers, $start, $limit, $device_id = null, $account_id = null, $keyword = null, $achievement_type = null, $rank_type = null, string $contentType = self::contentTypes['searchAchievements'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling searchAchievements'
            );
        }

        // verify the required parameter 'app_key' is set
        if ($app_key === null || (is_array($app_key) && count($app_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_key when calling searchAchievements'
            );
        }

        // verify the required parameter 'sort_field' is set
        if ($sort_field === null || (is_array($sort_field) && count($sort_field) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sort_field when calling searchAchievements'
            );
        }

        // verify the required parameter 'descending' is set
        if ($descending === null || (is_array($descending) && count($descending) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $descending when calling searchAchievements'
            );
        }

        // verify the required parameter 'include_tiers' is set
        if ($include_tiers === null || (is_array($include_tiers) && count($include_tiers) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $include_tiers when calling searchAchievements'
            );
        }

        // verify the required parameter 'include_inactive_tiers' is set
        if ($include_inactive_tiers === null || (is_array($include_inactive_tiers) && count($include_inactive_tiers) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $include_inactive_tiers when calling searchAchievements'
            );
        }

        // verify the required parameter 'start' is set
        if ($start === null || (is_array($start) && count($start) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $start when calling searchAchievements'
            );
        }

        // verify the required parameter 'limit' is set
        if ($limit === null || (is_array($limit) && count($limit) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $limit when calling searchAchievements'
            );
        }







        $resourcePath = '/api/{version}/achievement/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_id,
            'deviceId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $app_key,
            'appKey', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $keyword,
            'keyword', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $achievement_type,
            'achievementType', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rank_type,
            'rankType', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort_field,
            'sortField', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $descending,
            'descending', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_tiers,
            'includeTiers', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_inactive_tiers,
            'includeInactiveTiers', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start,
            'start', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateAchievement
     *
     * Update Achievement
     *
     * @param  float $version version (required)
     * @param  string|null $device_id a unique id given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  int|null $achievement_id the achievement ID for updating an existing achievement (optional)
     * @param  string|null $analytics_tag the analytics tag that will trigger when a user&#39;s achievement count gets updated (optional)
     * @param  string|null $title the title of the achievement (255 character limit) (optional)
     * @param  string|null $description the description of the achievement (optional)
     * @param  string|null $rank_type the rank type for updating leader boards (optional)
     * @param  int|null $rank_increment determines how much the rank count is incremented (optional)
     * @param  int|null $min_increment restrict scores to be above or equal to this minimum value (optional)
     * @param  bool|null $null_min_increment enable to ignore usage of minIncrement (optional)
     * @param  int|null $max_increment restrict scores to be below or equal to this maximum value (optional)
     * @param  bool|null $null_max_increment enable to ignore usage of maxIncrement (optional)
     * @param  bool|null $validate determines whether the customId on analytics are used to validate a user&#39;s achievement progress. (optional)
     * @param  bool|null $active if it&#39;s active or inactive (optional)
     * @param  string|null $trigger_definition if provided will define what triggers to run after a tier is completed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAchievement'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AchievementResponse
     */
    public function updateAchievement($version, $device_id = null, $account_id = null, $achievement_id = null, $analytics_tag = null, $title = null, $description = null, $rank_type = null, $rank_increment = null, $min_increment = null, $null_min_increment = null, $max_increment = null, $null_max_increment = null, $validate = null, $active = null, $trigger_definition = null, string $contentType = self::contentTypes['updateAchievement'][0])
    {
        list($response) = $this->updateAchievementWithHttpInfo($version, $device_id, $account_id, $achievement_id, $analytics_tag, $title, $description, $rank_type, $rank_increment, $min_increment, $null_min_increment, $max_increment, $null_max_increment, $validate, $active, $trigger_definition, $contentType);
        return $response;
    }

    /**
     * Operation updateAchievementWithHttpInfo
     *
     * Update Achievement
     *
     * @param  float $version (required)
     * @param  string|null $device_id a unique id given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  int|null $achievement_id the achievement ID for updating an existing achievement (optional)
     * @param  string|null $analytics_tag the analytics tag that will trigger when a user&#39;s achievement count gets updated (optional)
     * @param  string|null $title the title of the achievement (255 character limit) (optional)
     * @param  string|null $description the description of the achievement (optional)
     * @param  string|null $rank_type the rank type for updating leader boards (optional)
     * @param  int|null $rank_increment determines how much the rank count is incremented (optional)
     * @param  int|null $min_increment restrict scores to be above or equal to this minimum value (optional)
     * @param  bool|null $null_min_increment enable to ignore usage of minIncrement (optional)
     * @param  int|null $max_increment restrict scores to be below or equal to this maximum value (optional)
     * @param  bool|null $null_max_increment enable to ignore usage of maxIncrement (optional)
     * @param  bool|null $validate determines whether the customId on analytics are used to validate a user&#39;s achievement progress. (optional)
     * @param  bool|null $active if it&#39;s active or inactive (optional)
     * @param  string|null $trigger_definition if provided will define what triggers to run after a tier is completed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAchievement'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AchievementResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateAchievementWithHttpInfo($version, $device_id = null, $account_id = null, $achievement_id = null, $analytics_tag = null, $title = null, $description = null, $rank_type = null, $rank_increment = null, $min_increment = null, $null_min_increment = null, $max_increment = null, $null_max_increment = null, $validate = null, $active = null, $trigger_definition = null, string $contentType = self::contentTypes['updateAchievement'][0])
    {
        $request = $this->updateAchievementRequest($version, $device_id, $account_id, $achievement_id, $analytics_tag, $title, $description, $rank_type, $rank_increment, $min_increment, $null_min_increment, $max_increment, $null_max_increment, $validate, $active, $trigger_definition, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\AchievementResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\AchievementResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AchievementResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateAchievementAsync
     *
     * Update Achievement
     *
     * @param  float $version (required)
     * @param  string|null $device_id a unique id given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  int|null $achievement_id the achievement ID for updating an existing achievement (optional)
     * @param  string|null $analytics_tag the analytics tag that will trigger when a user&#39;s achievement count gets updated (optional)
     * @param  string|null $title the title of the achievement (255 character limit) (optional)
     * @param  string|null $description the description of the achievement (optional)
     * @param  string|null $rank_type the rank type for updating leader boards (optional)
     * @param  int|null $rank_increment determines how much the rank count is incremented (optional)
     * @param  int|null $min_increment restrict scores to be above or equal to this minimum value (optional)
     * @param  bool|null $null_min_increment enable to ignore usage of minIncrement (optional)
     * @param  int|null $max_increment restrict scores to be below or equal to this maximum value (optional)
     * @param  bool|null $null_max_increment enable to ignore usage of maxIncrement (optional)
     * @param  bool|null $validate determines whether the customId on analytics are used to validate a user&#39;s achievement progress. (optional)
     * @param  bool|null $active if it&#39;s active or inactive (optional)
     * @param  string|null $trigger_definition if provided will define what triggers to run after a tier is completed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAchievement'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAchievementAsync($version, $device_id = null, $account_id = null, $achievement_id = null, $analytics_tag = null, $title = null, $description = null, $rank_type = null, $rank_increment = null, $min_increment = null, $null_min_increment = null, $max_increment = null, $null_max_increment = null, $validate = null, $active = null, $trigger_definition = null, string $contentType = self::contentTypes['updateAchievement'][0])
    {
        return $this->updateAchievementAsyncWithHttpInfo($version, $device_id, $account_id, $achievement_id, $analytics_tag, $title, $description, $rank_type, $rank_increment, $min_increment, $null_min_increment, $max_increment, $null_max_increment, $validate, $active, $trigger_definition, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateAchievementAsyncWithHttpInfo
     *
     * Update Achievement
     *
     * @param  float $version (required)
     * @param  string|null $device_id a unique id given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  int|null $achievement_id the achievement ID for updating an existing achievement (optional)
     * @param  string|null $analytics_tag the analytics tag that will trigger when a user&#39;s achievement count gets updated (optional)
     * @param  string|null $title the title of the achievement (255 character limit) (optional)
     * @param  string|null $description the description of the achievement (optional)
     * @param  string|null $rank_type the rank type for updating leader boards (optional)
     * @param  int|null $rank_increment determines how much the rank count is incremented (optional)
     * @param  int|null $min_increment restrict scores to be above or equal to this minimum value (optional)
     * @param  bool|null $null_min_increment enable to ignore usage of minIncrement (optional)
     * @param  int|null $max_increment restrict scores to be below or equal to this maximum value (optional)
     * @param  bool|null $null_max_increment enable to ignore usage of maxIncrement (optional)
     * @param  bool|null $validate determines whether the customId on analytics are used to validate a user&#39;s achievement progress. (optional)
     * @param  bool|null $active if it&#39;s active or inactive (optional)
     * @param  string|null $trigger_definition if provided will define what triggers to run after a tier is completed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAchievement'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAchievementAsyncWithHttpInfo($version, $device_id = null, $account_id = null, $achievement_id = null, $analytics_tag = null, $title = null, $description = null, $rank_type = null, $rank_increment = null, $min_increment = null, $null_min_increment = null, $max_increment = null, $null_max_increment = null, $validate = null, $active = null, $trigger_definition = null, string $contentType = self::contentTypes['updateAchievement'][0])
    {
        $returnType = '\OpenAPI\Client\Model\AchievementResponse';
        $request = $this->updateAchievementRequest($version, $device_id, $account_id, $achievement_id, $analytics_tag, $title, $description, $rank_type, $rank_increment, $min_increment, $null_min_increment, $max_increment, $null_max_increment, $validate, $active, $trigger_definition, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateAchievement'
     *
     * @param  float $version (required)
     * @param  string|null $device_id a unique id given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  int|null $achievement_id the achievement ID for updating an existing achievement (optional)
     * @param  string|null $analytics_tag the analytics tag that will trigger when a user&#39;s achievement count gets updated (optional)
     * @param  string|null $title the title of the achievement (255 character limit) (optional)
     * @param  string|null $description the description of the achievement (optional)
     * @param  string|null $rank_type the rank type for updating leader boards (optional)
     * @param  int|null $rank_increment determines how much the rank count is incremented (optional)
     * @param  int|null $min_increment restrict scores to be above or equal to this minimum value (optional)
     * @param  bool|null $null_min_increment enable to ignore usage of minIncrement (optional)
     * @param  int|null $max_increment restrict scores to be below or equal to this maximum value (optional)
     * @param  bool|null $null_max_increment enable to ignore usage of maxIncrement (optional)
     * @param  bool|null $validate determines whether the customId on analytics are used to validate a user&#39;s achievement progress. (optional)
     * @param  bool|null $active if it&#39;s active or inactive (optional)
     * @param  string|null $trigger_definition if provided will define what triggers to run after a tier is completed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAchievement'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateAchievementRequest($version, $device_id = null, $account_id = null, $achievement_id = null, $analytics_tag = null, $title = null, $description = null, $rank_type = null, $rank_increment = null, $min_increment = null, $null_min_increment = null, $max_increment = null, $null_max_increment = null, $validate = null, $active = null, $trigger_definition = null, string $contentType = self::contentTypes['updateAchievement'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling updateAchievement'
            );
        }

















        $resourcePath = '/api/{version}/achievement/update';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_id,
            'deviceId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $achievement_id,
            'achievementId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $analytics_tag,
            'analyticsTag', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $title,
            'title', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description,
            'description', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rank_type,
            'rankType', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rank_increment,
            'rankIncrement', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_increment,
            'minIncrement', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $null_min_increment,
            'nullMinIncrement', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_increment,
            'maxIncrement', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $null_max_increment,
            'nullMaxIncrement', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $validate,
            'validate', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $active,
            'active', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $trigger_definition,
            'triggerDefinition', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateAchievementTier
     *
     * Update Achievement Tier
     *
     * @param  float $version version (required)
     * @param  int $achievement_tier_id the achievement tier id for updating (required)
     * @param  string|null $device_id a unique id given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  \SplFileObject|null $icon achievement tier icon image file (optional)
     * @param  int|null $icon_asset_id the icon assetId, if icon is provided, icon will overrule (optional)
     * @param  string|null $title the title of the achievement tier (optional)
     * @param  string|null $description the description of the achievement tier (optional)
     * @param  int|null $goal_count the count requirement for completing the achievement tier (optional)
     * @param  int|null $mission_id The ID of the mission to associate with the achievement (optional)
     * @param  int|null $game_id The ID of the game to associate with the achievement (optional)
     * @param  int|null $pack_id The ID of the pack to associate with the achievement (optional)
     * @param  int|null $game_level_id The ID of the game level to associate with the achievement (optional)
     * @param  int|null $game_object_id The ID of the game object to associate with the achievement (optional)
     * @param  bool|null $score_all_instances score all instances (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAchievementTier'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AchievementTierResponse
     */
    public function updateAchievementTier($version, $achievement_tier_id, $device_id = null, $account_id = null, $icon = null, $icon_asset_id = null, $title = null, $description = null, $goal_count = null, $mission_id = null, $game_id = null, $pack_id = null, $game_level_id = null, $game_object_id = null, $score_all_instances = null, string $contentType = self::contentTypes['updateAchievementTier'][0])
    {
        list($response) = $this->updateAchievementTierWithHttpInfo($version, $achievement_tier_id, $device_id, $account_id, $icon, $icon_asset_id, $title, $description, $goal_count, $mission_id, $game_id, $pack_id, $game_level_id, $game_object_id, $score_all_instances, $contentType);
        return $response;
    }

    /**
     * Operation updateAchievementTierWithHttpInfo
     *
     * Update Achievement Tier
     *
     * @param  float $version (required)
     * @param  int $achievement_tier_id the achievement tier id for updating (required)
     * @param  string|null $device_id a unique id given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  \SplFileObject|null $icon achievement tier icon image file (optional)
     * @param  int|null $icon_asset_id the icon assetId, if icon is provided, icon will overrule (optional)
     * @param  string|null $title the title of the achievement tier (optional)
     * @param  string|null $description the description of the achievement tier (optional)
     * @param  int|null $goal_count the count requirement for completing the achievement tier (optional)
     * @param  int|null $mission_id The ID of the mission to associate with the achievement (optional)
     * @param  int|null $game_id The ID of the game to associate with the achievement (optional)
     * @param  int|null $pack_id The ID of the pack to associate with the achievement (optional)
     * @param  int|null $game_level_id The ID of the game level to associate with the achievement (optional)
     * @param  int|null $game_object_id The ID of the game object to associate with the achievement (optional)
     * @param  bool|null $score_all_instances score all instances (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAchievementTier'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AchievementTierResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateAchievementTierWithHttpInfo($version, $achievement_tier_id, $device_id = null, $account_id = null, $icon = null, $icon_asset_id = null, $title = null, $description = null, $goal_count = null, $mission_id = null, $game_id = null, $pack_id = null, $game_level_id = null, $game_object_id = null, $score_all_instances = null, string $contentType = self::contentTypes['updateAchievementTier'][0])
    {
        $request = $this->updateAchievementTierRequest($version, $achievement_tier_id, $device_id, $account_id, $icon, $icon_asset_id, $title, $description, $goal_count, $mission_id, $game_id, $pack_id, $game_level_id, $game_object_id, $score_all_instances, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\AchievementTierResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\AchievementTierResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AchievementTierResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateAchievementTierAsync
     *
     * Update Achievement Tier
     *
     * @param  float $version (required)
     * @param  int $achievement_tier_id the achievement tier id for updating (required)
     * @param  string|null $device_id a unique id given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  \SplFileObject|null $icon achievement tier icon image file (optional)
     * @param  int|null $icon_asset_id the icon assetId, if icon is provided, icon will overrule (optional)
     * @param  string|null $title the title of the achievement tier (optional)
     * @param  string|null $description the description of the achievement tier (optional)
     * @param  int|null $goal_count the count requirement for completing the achievement tier (optional)
     * @param  int|null $mission_id The ID of the mission to associate with the achievement (optional)
     * @param  int|null $game_id The ID of the game to associate with the achievement (optional)
     * @param  int|null $pack_id The ID of the pack to associate with the achievement (optional)
     * @param  int|null $game_level_id The ID of the game level to associate with the achievement (optional)
     * @param  int|null $game_object_id The ID of the game object to associate with the achievement (optional)
     * @param  bool|null $score_all_instances score all instances (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAchievementTier'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAchievementTierAsync($version, $achievement_tier_id, $device_id = null, $account_id = null, $icon = null, $icon_asset_id = null, $title = null, $description = null, $goal_count = null, $mission_id = null, $game_id = null, $pack_id = null, $game_level_id = null, $game_object_id = null, $score_all_instances = null, string $contentType = self::contentTypes['updateAchievementTier'][0])
    {
        return $this->updateAchievementTierAsyncWithHttpInfo($version, $achievement_tier_id, $device_id, $account_id, $icon, $icon_asset_id, $title, $description, $goal_count, $mission_id, $game_id, $pack_id, $game_level_id, $game_object_id, $score_all_instances, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateAchievementTierAsyncWithHttpInfo
     *
     * Update Achievement Tier
     *
     * @param  float $version (required)
     * @param  int $achievement_tier_id the achievement tier id for updating (required)
     * @param  string|null $device_id a unique id given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  \SplFileObject|null $icon achievement tier icon image file (optional)
     * @param  int|null $icon_asset_id the icon assetId, if icon is provided, icon will overrule (optional)
     * @param  string|null $title the title of the achievement tier (optional)
     * @param  string|null $description the description of the achievement tier (optional)
     * @param  int|null $goal_count the count requirement for completing the achievement tier (optional)
     * @param  int|null $mission_id The ID of the mission to associate with the achievement (optional)
     * @param  int|null $game_id The ID of the game to associate with the achievement (optional)
     * @param  int|null $pack_id The ID of the pack to associate with the achievement (optional)
     * @param  int|null $game_level_id The ID of the game level to associate with the achievement (optional)
     * @param  int|null $game_object_id The ID of the game object to associate with the achievement (optional)
     * @param  bool|null $score_all_instances score all instances (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAchievementTier'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAchievementTierAsyncWithHttpInfo($version, $achievement_tier_id, $device_id = null, $account_id = null, $icon = null, $icon_asset_id = null, $title = null, $description = null, $goal_count = null, $mission_id = null, $game_id = null, $pack_id = null, $game_level_id = null, $game_object_id = null, $score_all_instances = null, string $contentType = self::contentTypes['updateAchievementTier'][0])
    {
        $returnType = '\OpenAPI\Client\Model\AchievementTierResponse';
        $request = $this->updateAchievementTierRequest($version, $achievement_tier_id, $device_id, $account_id, $icon, $icon_asset_id, $title, $description, $goal_count, $mission_id, $game_id, $pack_id, $game_level_id, $game_object_id, $score_all_instances, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateAchievementTier'
     *
     * @param  float $version (required)
     * @param  int $achievement_tier_id the achievement tier id for updating (required)
     * @param  string|null $device_id a unique id given by the device (deviceId or accountId required) (optional)
     * @param  int|null $account_id the account id of the user (deviceId or accountId required) (optional)
     * @param  \SplFileObject|null $icon achievement tier icon image file (optional)
     * @param  int|null $icon_asset_id the icon assetId, if icon is provided, icon will overrule (optional)
     * @param  string|null $title the title of the achievement tier (optional)
     * @param  string|null $description the description of the achievement tier (optional)
     * @param  int|null $goal_count the count requirement for completing the achievement tier (optional)
     * @param  int|null $mission_id The ID of the mission to associate with the achievement (optional)
     * @param  int|null $game_id The ID of the game to associate with the achievement (optional)
     * @param  int|null $pack_id The ID of the pack to associate with the achievement (optional)
     * @param  int|null $game_level_id The ID of the game level to associate with the achievement (optional)
     * @param  int|null $game_object_id The ID of the game object to associate with the achievement (optional)
     * @param  bool|null $score_all_instances score all instances (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAchievementTier'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateAchievementTierRequest($version, $achievement_tier_id, $device_id = null, $account_id = null, $icon = null, $icon_asset_id = null, $title = null, $description = null, $goal_count = null, $mission_id = null, $game_id = null, $pack_id = null, $game_level_id = null, $game_object_id = null, $score_all_instances = null, string $contentType = self::contentTypes['updateAchievementTier'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling updateAchievementTier'
            );
        }

        // verify the required parameter 'achievement_tier_id' is set
        if ($achievement_tier_id === null || (is_array($achievement_tier_id) && count($achievement_tier_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $achievement_tier_id when calling updateAchievementTier'
            );
        }















        $resourcePath = '/api/{version}/achievement/tier/update';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_id,
            'deviceId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $achievement_tier_id,
            'achievementTierId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $icon,
            'icon', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $icon_asset_id,
            'iconAssetId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $title,
            'title', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description,
            'description', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $goal_count,
            'goalCount', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $mission_id,
            'missionId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $game_id,
            'gameId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pack_id,
            'packId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $game_level_id,
            'gameLevelId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $game_object_id,
            'gameObjectId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $score_all_instances,
            'scoreAllInstances', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateUserAchievement
     *
     * Update Achievement Progress
     *
     * @param  float $version version (required)
     * @param  int $account_id the account id of the user (required)
     * @param  int|null $achievement_id the achievement id (achievementId or tag required) (optional)
     * @param  string|null $tag the analytic tag to identify an achievement (achievementId or tag required) (optional)
     * @param  int|null $custom_id a custom identifier used for validation (optional)
     * @param  int|null $increment the amount to increment an achievement progress by (if no increment is sent in, the server defaults to using the achievement&#39;s rankIncrement value) (optional)
     * @param  int|null $start_date a custom start date that the client can set (not yet used in server logic) (optional)
     * @param  int|null $end_date a custom end date that the client can set (not yet used in server logic) (optional)
     * @param  bool|null $return_progress determines whether to return the achievement progress response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateUserAchievement'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SirqulResponse
     */
    public function updateUserAchievement($version, $account_id, $achievement_id = null, $tag = null, $custom_id = null, $increment = null, $start_date = null, $end_date = null, $return_progress = null, string $contentType = self::contentTypes['updateUserAchievement'][0])
    {
        list($response) = $this->updateUserAchievementWithHttpInfo($version, $account_id, $achievement_id, $tag, $custom_id, $increment, $start_date, $end_date, $return_progress, $contentType);
        return $response;
    }

    /**
     * Operation updateUserAchievementWithHttpInfo
     *
     * Update Achievement Progress
     *
     * @param  float $version (required)
     * @param  int $account_id the account id of the user (required)
     * @param  int|null $achievement_id the achievement id (achievementId or tag required) (optional)
     * @param  string|null $tag the analytic tag to identify an achievement (achievementId or tag required) (optional)
     * @param  int|null $custom_id a custom identifier used for validation (optional)
     * @param  int|null $increment the amount to increment an achievement progress by (if no increment is sent in, the server defaults to using the achievement&#39;s rankIncrement value) (optional)
     * @param  int|null $start_date a custom start date that the client can set (not yet used in server logic) (optional)
     * @param  int|null $end_date a custom end date that the client can set (not yet used in server logic) (optional)
     * @param  bool|null $return_progress determines whether to return the achievement progress response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateUserAchievement'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SirqulResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateUserAchievementWithHttpInfo($version, $account_id, $achievement_id = null, $tag = null, $custom_id = null, $increment = null, $start_date = null, $end_date = null, $return_progress = null, string $contentType = self::contentTypes['updateUserAchievement'][0])
    {
        $request = $this->updateUserAchievementRequest($version, $account_id, $achievement_id, $tag, $custom_id, $increment, $start_date, $end_date, $return_progress, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\SirqulResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\SirqulResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SirqulResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateUserAchievementAsync
     *
     * Update Achievement Progress
     *
     * @param  float $version (required)
     * @param  int $account_id the account id of the user (required)
     * @param  int|null $achievement_id the achievement id (achievementId or tag required) (optional)
     * @param  string|null $tag the analytic tag to identify an achievement (achievementId or tag required) (optional)
     * @param  int|null $custom_id a custom identifier used for validation (optional)
     * @param  int|null $increment the amount to increment an achievement progress by (if no increment is sent in, the server defaults to using the achievement&#39;s rankIncrement value) (optional)
     * @param  int|null $start_date a custom start date that the client can set (not yet used in server logic) (optional)
     * @param  int|null $end_date a custom end date that the client can set (not yet used in server logic) (optional)
     * @param  bool|null $return_progress determines whether to return the achievement progress response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateUserAchievement'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateUserAchievementAsync($version, $account_id, $achievement_id = null, $tag = null, $custom_id = null, $increment = null, $start_date = null, $end_date = null, $return_progress = null, string $contentType = self::contentTypes['updateUserAchievement'][0])
    {
        return $this->updateUserAchievementAsyncWithHttpInfo($version, $account_id, $achievement_id, $tag, $custom_id, $increment, $start_date, $end_date, $return_progress, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateUserAchievementAsyncWithHttpInfo
     *
     * Update Achievement Progress
     *
     * @param  float $version (required)
     * @param  int $account_id the account id of the user (required)
     * @param  int|null $achievement_id the achievement id (achievementId or tag required) (optional)
     * @param  string|null $tag the analytic tag to identify an achievement (achievementId or tag required) (optional)
     * @param  int|null $custom_id a custom identifier used for validation (optional)
     * @param  int|null $increment the amount to increment an achievement progress by (if no increment is sent in, the server defaults to using the achievement&#39;s rankIncrement value) (optional)
     * @param  int|null $start_date a custom start date that the client can set (not yet used in server logic) (optional)
     * @param  int|null $end_date a custom end date that the client can set (not yet used in server logic) (optional)
     * @param  bool|null $return_progress determines whether to return the achievement progress response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateUserAchievement'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateUserAchievementAsyncWithHttpInfo($version, $account_id, $achievement_id = null, $tag = null, $custom_id = null, $increment = null, $start_date = null, $end_date = null, $return_progress = null, string $contentType = self::contentTypes['updateUserAchievement'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SirqulResponse';
        $request = $this->updateUserAchievementRequest($version, $account_id, $achievement_id, $tag, $custom_id, $increment, $start_date, $end_date, $return_progress, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateUserAchievement'
     *
     * @param  float $version (required)
     * @param  int $account_id the account id of the user (required)
     * @param  int|null $achievement_id the achievement id (achievementId or tag required) (optional)
     * @param  string|null $tag the analytic tag to identify an achievement (achievementId or tag required) (optional)
     * @param  int|null $custom_id a custom identifier used for validation (optional)
     * @param  int|null $increment the amount to increment an achievement progress by (if no increment is sent in, the server defaults to using the achievement&#39;s rankIncrement value) (optional)
     * @param  int|null $start_date a custom start date that the client can set (not yet used in server logic) (optional)
     * @param  int|null $end_date a custom end date that the client can set (not yet used in server logic) (optional)
     * @param  bool|null $return_progress determines whether to return the achievement progress response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateUserAchievement'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateUserAchievementRequest($version, $account_id, $achievement_id = null, $tag = null, $custom_id = null, $increment = null, $start_date = null, $end_date = null, $return_progress = null, string $contentType = self::contentTypes['updateUserAchievement'][0])
    {

        // verify the required parameter 'version' is set
        if ($version === null || (is_array($version) && count($version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling updateUserAchievement'
            );
        }

        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling updateUserAchievement'
            );
        }









        $resourcePath = '/api/{version}/achievement/progress/update';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'accountId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $achievement_id,
            'achievementId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $custom_id,
            'customId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $increment,
            'increment', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'startDate', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'endDate', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_progress,
            'returnProgress', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        if ($this->config->getCertFile()) {
            $options[RequestOptions::CERT] = $this->config->getCertFile();
        }

        if ($this->config->getKeyFile()) {
            $options[RequestOptions::SSL_KEY] = $this->config->getKeyFile();
        }

        return $options;
    }

    private function handleResponseWithDataType(
        string $dataType,
        RequestInterface $request,
        ResponseInterface $response
    ): array {
        if ($dataType === '\SplFileObject') {
            $content = $response->getBody(); //stream goes to serializer
        } else {
            $content = (string) $response->getBody();
            if ($dataType !== 'string') {
                try {
                    $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                } catch (\JsonException $exception) {
                    throw new ApiException(
                        sprintf(
                            'Error JSON decoding server response (%s)',
                            $request->getUri()
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                        $content
                    );
                }
            }
        }

        return [
            ObjectSerializer::deserialize($content, $dataType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    private function responseWithinRangeCode(
        string $rangeCode,
        int $statusCode
    ): bool {
        $left = (int) ($rangeCode[0].'00');
        $right = (int) ($rangeCode[0].'99');

        return $statusCode >= $left && $statusCode <= $right;
    }
}
