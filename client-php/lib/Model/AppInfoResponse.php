<?php
/**
 * AppInfoResponse
 *
 * PHP version 8.1
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Sirqul IoT Platform
 *
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.20.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Model;

use \ArrayAccess;
use \OpenAPI\Client\ObjectSerializer;

/**
 * AppInfoResponse Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<string, mixed>
 */
class AppInfoResponse implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'AppInfoResponse';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'points' => 'int',
        'tickets_available' => 'int',
        'tickets_earned' => 'int',
        'tickets_purchased' => 'int',
        'tickets_used' => 'int',
        'rank' => 'string',
        'max_points' => 'int',
        'max_tickets' => 'int',
        'point_to_ticket_modifier' => 'float',
        'scoring_type' => 'string',
        'purchase_item_list_response' => '\OpenAPI\Client\Model\PurchaseItemListResponse',
        'terms_accepted_date' => 'int',
        'requires_terms_acceptance' => 'bool',
        'completed_achievements' => '\OpenAPI\Client\Model\AchievementProgressResponse[]',
        'wip_achievements' => '\OpenAPI\Client\Model\AchievementProgressResponse[]',
        'app_blob' => 'string',
        'enable_push' => 'bool',
        'enable_sms' => 'bool',
        'enable_email' => 'bool',
        'ticket_counts' => '\OpenAPI\Client\Model\TicketCountResponse[]'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'points' => 'int64',
        'tickets_available' => 'int64',
        'tickets_earned' => 'int64',
        'tickets_purchased' => 'int64',
        'tickets_used' => 'int64',
        'rank' => null,
        'max_points' => 'int64',
        'max_tickets' => 'int64',
        'point_to_ticket_modifier' => 'float',
        'scoring_type' => null,
        'purchase_item_list_response' => null,
        'terms_accepted_date' => 'int64',
        'requires_terms_acceptance' => null,
        'completed_achievements' => null,
        'wip_achievements' => null,
        'app_blob' => null,
        'enable_push' => null,
        'enable_sms' => null,
        'enable_email' => null,
        'ticket_counts' => null
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var boolean[]
      */
    protected static array $openAPINullables = [
        'points' => false,
        'tickets_available' => false,
        'tickets_earned' => false,
        'tickets_purchased' => false,
        'tickets_used' => false,
        'rank' => false,
        'max_points' => false,
        'max_tickets' => false,
        'point_to_ticket_modifier' => false,
        'scoring_type' => false,
        'purchase_item_list_response' => false,
        'terms_accepted_date' => false,
        'requires_terms_acceptance' => false,
        'completed_achievements' => false,
        'wip_achievements' => false,
        'app_blob' => false,
        'enable_push' => false,
        'enable_sms' => false,
        'enable_email' => false,
        'ticket_counts' => false
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var boolean[]
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return boolean[]
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Setter - Array of nullable field names deliberately set to null
     *
     * @param boolean[] $openAPINullablesSetToNull
     */
    private function setOpenAPINullablesSetToNull(array $openAPINullablesSetToNull): void
    {
        $this->openAPINullablesSetToNull = $openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'points' => 'points',
        'tickets_available' => 'ticketsAvailable',
        'tickets_earned' => 'ticketsEarned',
        'tickets_purchased' => 'ticketsPurchased',
        'tickets_used' => 'ticketsUsed',
        'rank' => 'rank',
        'max_points' => 'maxPoints',
        'max_tickets' => 'maxTickets',
        'point_to_ticket_modifier' => 'pointToTicketModifier',
        'scoring_type' => 'scoringType',
        'purchase_item_list_response' => 'purchaseItemListResponse',
        'terms_accepted_date' => 'termsAcceptedDate',
        'requires_terms_acceptance' => 'requiresTermsAcceptance',
        'completed_achievements' => 'completedAchievements',
        'wip_achievements' => 'wipAchievements',
        'app_blob' => 'appBlob',
        'enable_push' => 'enablePush',
        'enable_sms' => 'enableSMS',
        'enable_email' => 'enableEmail',
        'ticket_counts' => 'ticketCounts'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'points' => 'setPoints',
        'tickets_available' => 'setTicketsAvailable',
        'tickets_earned' => 'setTicketsEarned',
        'tickets_purchased' => 'setTicketsPurchased',
        'tickets_used' => 'setTicketsUsed',
        'rank' => 'setRank',
        'max_points' => 'setMaxPoints',
        'max_tickets' => 'setMaxTickets',
        'point_to_ticket_modifier' => 'setPointToTicketModifier',
        'scoring_type' => 'setScoringType',
        'purchase_item_list_response' => 'setPurchaseItemListResponse',
        'terms_accepted_date' => 'setTermsAcceptedDate',
        'requires_terms_acceptance' => 'setRequiresTermsAcceptance',
        'completed_achievements' => 'setCompletedAchievements',
        'wip_achievements' => 'setWipAchievements',
        'app_blob' => 'setAppBlob',
        'enable_push' => 'setEnablePush',
        'enable_sms' => 'setEnableSms',
        'enable_email' => 'setEnableEmail',
        'ticket_counts' => 'setTicketCounts'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'points' => 'getPoints',
        'tickets_available' => 'getTicketsAvailable',
        'tickets_earned' => 'getTicketsEarned',
        'tickets_purchased' => 'getTicketsPurchased',
        'tickets_used' => 'getTicketsUsed',
        'rank' => 'getRank',
        'max_points' => 'getMaxPoints',
        'max_tickets' => 'getMaxTickets',
        'point_to_ticket_modifier' => 'getPointToTicketModifier',
        'scoring_type' => 'getScoringType',
        'purchase_item_list_response' => 'getPurchaseItemListResponse',
        'terms_accepted_date' => 'getTermsAcceptedDate',
        'requires_terms_acceptance' => 'getRequiresTermsAcceptance',
        'completed_achievements' => 'getCompletedAchievements',
        'wip_achievements' => 'getWipAchievements',
        'app_blob' => 'getAppBlob',
        'enable_push' => 'getEnablePush',
        'enable_sms' => 'getEnableSms',
        'enable_email' => 'getEnableEmail',
        'ticket_counts' => 'getTicketCounts'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    public const SCORING_TYPE_GAME_LEVEL = 'GAME_LEVEL';
    public const SCORING_TYPE_GAME_OBJECT = 'GAME_OBJECT';

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getScoringTypeAllowableValues()
    {
        return [
            self::SCORING_TYPE_GAME_LEVEL,
            self::SCORING_TYPE_GAME_OBJECT,
        ];
    }

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[]|null $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(?array $data = null)
    {
        $this->setIfExists('points', $data ?? [], null);
        $this->setIfExists('tickets_available', $data ?? [], null);
        $this->setIfExists('tickets_earned', $data ?? [], null);
        $this->setIfExists('tickets_purchased', $data ?? [], null);
        $this->setIfExists('tickets_used', $data ?? [], null);
        $this->setIfExists('rank', $data ?? [], null);
        $this->setIfExists('max_points', $data ?? [], null);
        $this->setIfExists('max_tickets', $data ?? [], null);
        $this->setIfExists('point_to_ticket_modifier', $data ?? [], null);
        $this->setIfExists('scoring_type', $data ?? [], null);
        $this->setIfExists('purchase_item_list_response', $data ?? [], null);
        $this->setIfExists('terms_accepted_date', $data ?? [], null);
        $this->setIfExists('requires_terms_acceptance', $data ?? [], null);
        $this->setIfExists('completed_achievements', $data ?? [], null);
        $this->setIfExists('wip_achievements', $data ?? [], null);
        $this->setIfExists('app_blob', $data ?? [], null);
        $this->setIfExists('enable_push', $data ?? [], null);
        $this->setIfExists('enable_sms', $data ?? [], null);
        $this->setIfExists('enable_email', $data ?? [], null);
        $this->setIfExists('ticket_counts', $data ?? [], null);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        $allowedValues = $this->getScoringTypeAllowableValues();
        if (!is_null($this->container['scoring_type']) && !in_array($this->container['scoring_type'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'scoring_type', must be one of '%s'",
                $this->container['scoring_type'],
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets points
     *
     * @return int|null
     */
    public function getPoints()
    {
        return $this->container['points'];
    }

    /**
     * Sets points
     *
     * @param int|null $points points
     *
     * @return self
     */
    public function setPoints($points)
    {
        if (is_null($points)) {
            throw new \InvalidArgumentException('non-nullable points cannot be null');
        }
        $this->container['points'] = $points;

        return $this;
    }

    /**
     * Gets tickets_available
     *
     * @return int|null
     */
    public function getTicketsAvailable()
    {
        return $this->container['tickets_available'];
    }

    /**
     * Sets tickets_available
     *
     * @param int|null $tickets_available tickets_available
     *
     * @return self
     */
    public function setTicketsAvailable($tickets_available)
    {
        if (is_null($tickets_available)) {
            throw new \InvalidArgumentException('non-nullable tickets_available cannot be null');
        }
        $this->container['tickets_available'] = $tickets_available;

        return $this;
    }

    /**
     * Gets tickets_earned
     *
     * @return int|null
     */
    public function getTicketsEarned()
    {
        return $this->container['tickets_earned'];
    }

    /**
     * Sets tickets_earned
     *
     * @param int|null $tickets_earned tickets_earned
     *
     * @return self
     */
    public function setTicketsEarned($tickets_earned)
    {
        if (is_null($tickets_earned)) {
            throw new \InvalidArgumentException('non-nullable tickets_earned cannot be null');
        }
        $this->container['tickets_earned'] = $tickets_earned;

        return $this;
    }

    /**
     * Gets tickets_purchased
     *
     * @return int|null
     */
    public function getTicketsPurchased()
    {
        return $this->container['tickets_purchased'];
    }

    /**
     * Sets tickets_purchased
     *
     * @param int|null $tickets_purchased tickets_purchased
     *
     * @return self
     */
    public function setTicketsPurchased($tickets_purchased)
    {
        if (is_null($tickets_purchased)) {
            throw new \InvalidArgumentException('non-nullable tickets_purchased cannot be null');
        }
        $this->container['tickets_purchased'] = $tickets_purchased;

        return $this;
    }

    /**
     * Gets tickets_used
     *
     * @return int|null
     */
    public function getTicketsUsed()
    {
        return $this->container['tickets_used'];
    }

    /**
     * Sets tickets_used
     *
     * @param int|null $tickets_used tickets_used
     *
     * @return self
     */
    public function setTicketsUsed($tickets_used)
    {
        if (is_null($tickets_used)) {
            throw new \InvalidArgumentException('non-nullable tickets_used cannot be null');
        }
        $this->container['tickets_used'] = $tickets_used;

        return $this;
    }

    /**
     * Gets rank
     *
     * @return string|null
     */
    public function getRank()
    {
        return $this->container['rank'];
    }

    /**
     * Sets rank
     *
     * @param string|null $rank rank
     *
     * @return self
     */
    public function setRank($rank)
    {
        if (is_null($rank)) {
            throw new \InvalidArgumentException('non-nullable rank cannot be null');
        }
        $this->container['rank'] = $rank;

        return $this;
    }

    /**
     * Gets max_points
     *
     * @return int|null
     */
    public function getMaxPoints()
    {
        return $this->container['max_points'];
    }

    /**
     * Sets max_points
     *
     * @param int|null $max_points max_points
     *
     * @return self
     */
    public function setMaxPoints($max_points)
    {
        if (is_null($max_points)) {
            throw new \InvalidArgumentException('non-nullable max_points cannot be null');
        }
        $this->container['max_points'] = $max_points;

        return $this;
    }

    /**
     * Gets max_tickets
     *
     * @return int|null
     */
    public function getMaxTickets()
    {
        return $this->container['max_tickets'];
    }

    /**
     * Sets max_tickets
     *
     * @param int|null $max_tickets max_tickets
     *
     * @return self
     */
    public function setMaxTickets($max_tickets)
    {
        if (is_null($max_tickets)) {
            throw new \InvalidArgumentException('non-nullable max_tickets cannot be null');
        }
        $this->container['max_tickets'] = $max_tickets;

        return $this;
    }

    /**
     * Gets point_to_ticket_modifier
     *
     * @return float|null
     */
    public function getPointToTicketModifier()
    {
        return $this->container['point_to_ticket_modifier'];
    }

    /**
     * Sets point_to_ticket_modifier
     *
     * @param float|null $point_to_ticket_modifier point_to_ticket_modifier
     *
     * @return self
     */
    public function setPointToTicketModifier($point_to_ticket_modifier)
    {
        if (is_null($point_to_ticket_modifier)) {
            throw new \InvalidArgumentException('non-nullable point_to_ticket_modifier cannot be null');
        }
        $this->container['point_to_ticket_modifier'] = $point_to_ticket_modifier;

        return $this;
    }

    /**
     * Gets scoring_type
     *
     * @return string|null
     */
    public function getScoringType()
    {
        return $this->container['scoring_type'];
    }

    /**
     * Sets scoring_type
     *
     * @param string|null $scoring_type scoring_type
     *
     * @return self
     */
    public function setScoringType($scoring_type)
    {
        if (is_null($scoring_type)) {
            throw new \InvalidArgumentException('non-nullable scoring_type cannot be null');
        }
        $allowedValues = $this->getScoringTypeAllowableValues();
        if (!in_array($scoring_type, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'scoring_type', must be one of '%s'",
                    $scoring_type,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['scoring_type'] = $scoring_type;

        return $this;
    }

    /**
     * Gets purchase_item_list_response
     *
     * @return \OpenAPI\Client\Model\PurchaseItemListResponse|null
     */
    public function getPurchaseItemListResponse()
    {
        return $this->container['purchase_item_list_response'];
    }

    /**
     * Sets purchase_item_list_response
     *
     * @param \OpenAPI\Client\Model\PurchaseItemListResponse|null $purchase_item_list_response purchase_item_list_response
     *
     * @return self
     */
    public function setPurchaseItemListResponse($purchase_item_list_response)
    {
        if (is_null($purchase_item_list_response)) {
            throw new \InvalidArgumentException('non-nullable purchase_item_list_response cannot be null');
        }
        $this->container['purchase_item_list_response'] = $purchase_item_list_response;

        return $this;
    }

    /**
     * Gets terms_accepted_date
     *
     * @return int|null
     */
    public function getTermsAcceptedDate()
    {
        return $this->container['terms_accepted_date'];
    }

    /**
     * Sets terms_accepted_date
     *
     * @param int|null $terms_accepted_date terms_accepted_date
     *
     * @return self
     */
    public function setTermsAcceptedDate($terms_accepted_date)
    {
        if (is_null($terms_accepted_date)) {
            throw new \InvalidArgumentException('non-nullable terms_accepted_date cannot be null');
        }
        $this->container['terms_accepted_date'] = $terms_accepted_date;

        return $this;
    }

    /**
     * Gets requires_terms_acceptance
     *
     * @return bool|null
     */
    public function getRequiresTermsAcceptance()
    {
        return $this->container['requires_terms_acceptance'];
    }

    /**
     * Sets requires_terms_acceptance
     *
     * @param bool|null $requires_terms_acceptance requires_terms_acceptance
     *
     * @return self
     */
    public function setRequiresTermsAcceptance($requires_terms_acceptance)
    {
        if (is_null($requires_terms_acceptance)) {
            throw new \InvalidArgumentException('non-nullable requires_terms_acceptance cannot be null');
        }
        $this->container['requires_terms_acceptance'] = $requires_terms_acceptance;

        return $this;
    }

    /**
     * Gets completed_achievements
     *
     * @return \OpenAPI\Client\Model\AchievementProgressResponse[]|null
     */
    public function getCompletedAchievements()
    {
        return $this->container['completed_achievements'];
    }

    /**
     * Sets completed_achievements
     *
     * @param \OpenAPI\Client\Model\AchievementProgressResponse[]|null $completed_achievements completed_achievements
     *
     * @return self
     */
    public function setCompletedAchievements($completed_achievements)
    {
        if (is_null($completed_achievements)) {
            throw new \InvalidArgumentException('non-nullable completed_achievements cannot be null');
        }
        $this->container['completed_achievements'] = $completed_achievements;

        return $this;
    }

    /**
     * Gets wip_achievements
     *
     * @return \OpenAPI\Client\Model\AchievementProgressResponse[]|null
     */
    public function getWipAchievements()
    {
        return $this->container['wip_achievements'];
    }

    /**
     * Sets wip_achievements
     *
     * @param \OpenAPI\Client\Model\AchievementProgressResponse[]|null $wip_achievements wip_achievements
     *
     * @return self
     */
    public function setWipAchievements($wip_achievements)
    {
        if (is_null($wip_achievements)) {
            throw new \InvalidArgumentException('non-nullable wip_achievements cannot be null');
        }
        $this->container['wip_achievements'] = $wip_achievements;

        return $this;
    }

    /**
     * Gets app_blob
     *
     * @return string|null
     */
    public function getAppBlob()
    {
        return $this->container['app_blob'];
    }

    /**
     * Sets app_blob
     *
     * @param string|null $app_blob app_blob
     *
     * @return self
     */
    public function setAppBlob($app_blob)
    {
        if (is_null($app_blob)) {
            throw new \InvalidArgumentException('non-nullable app_blob cannot be null');
        }
        $this->container['app_blob'] = $app_blob;

        return $this;
    }

    /**
     * Gets enable_push
     *
     * @return bool|null
     */
    public function getEnablePush()
    {
        return $this->container['enable_push'];
    }

    /**
     * Sets enable_push
     *
     * @param bool|null $enable_push enable_push
     *
     * @return self
     */
    public function setEnablePush($enable_push)
    {
        if (is_null($enable_push)) {
            throw new \InvalidArgumentException('non-nullable enable_push cannot be null');
        }
        $this->container['enable_push'] = $enable_push;

        return $this;
    }

    /**
     * Gets enable_sms
     *
     * @return bool|null
     */
    public function getEnableSms()
    {
        return $this->container['enable_sms'];
    }

    /**
     * Sets enable_sms
     *
     * @param bool|null $enable_sms enable_sms
     *
     * @return self
     */
    public function setEnableSms($enable_sms)
    {
        if (is_null($enable_sms)) {
            throw new \InvalidArgumentException('non-nullable enable_sms cannot be null');
        }
        $this->container['enable_sms'] = $enable_sms;

        return $this;
    }

    /**
     * Gets enable_email
     *
     * @return bool|null
     */
    public function getEnableEmail()
    {
        return $this->container['enable_email'];
    }

    /**
     * Sets enable_email
     *
     * @param bool|null $enable_email enable_email
     *
     * @return self
     */
    public function setEnableEmail($enable_email)
    {
        if (is_null($enable_email)) {
            throw new \InvalidArgumentException('non-nullable enable_email cannot be null');
        }
        $this->container['enable_email'] = $enable_email;

        return $this;
    }

    /**
     * Gets ticket_counts
     *
     * @return \OpenAPI\Client\Model\TicketCountResponse[]|null
     */
    public function getTicketCounts()
    {
        return $this->container['ticket_counts'];
    }

    /**
     * Sets ticket_counts
     *
     * @param \OpenAPI\Client\Model\TicketCountResponse[]|null $ticket_counts ticket_counts
     *
     * @return self
     */
    public function setTicketCounts($ticket_counts)
    {
        if (is_null($ticket_counts)) {
            throw new \InvalidArgumentException('non-nullable ticket_counts cannot be null');
        }
        $this->container['ticket_counts'] = $ticket_counts;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer|string $offset Offset
     *
     * @return boolean
     */
    public function offsetExists(mixed $offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer|string $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet(mixed $offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer|string $offset Offset
     *
     * @return void
     */
    public function offsetUnset(mixed $offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


