/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import org.openapitools.client.models.ProfileResponse
import org.openapitools.client.models.SirqulResponse
import org.openapitools.client.models.ThirdPartyCredentialResponse
import org.openapitools.client.models.ThirdPartyNetworkResponse
import org.openapitools.client.models.ThirdPartyNetworkShortResponse

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

open class ThirdPartyCredentialsApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://dev.sirqul.com/api/3.18")
        }
    }

    /**
     * POST /thirdparty/credential/create
     * Create Credential
     * This endpoint creates a third-party login for a Sirqul account. A third party login is a way for external systems (Third Party Networks) to link their own user accounts with a Sirqul account.   The thirdPartyId parameter is used to determine if the user already exists in Sirqul or not. This parameter needs to be unique for each user in the Third Party Network (identified by the networkUID parameter). Note that subsequent calls will update the user&#39;s third-party login credentials for the user with the same thirdPartyId and networkUID combination.    The thirdPartyToken parameter acts as a shared secret and used by client applications to log users into Sirqul without providing a Sirqul username and password. 
     * @param thirdPartyId the third party user account id
     * @param thirdPartyToken the access token to authenticate with (ex: username or fb token or phone number)
     * @param networkUID the access provider to authenticate against
     * @param appKey the application key
     * @param accountId the unique id of the account that needs authenticating (optional for PHONE_V2) (optional)
     * @param deviceId the unique id of the device making the request (optional)
     * @param sessionId the session id for the request (optional)
     * @param thirdPartyName the third party user&#39;s display name (optional)
     * @param emailAddress optional email address associated with the third party account (optional)
     * @param signinOnlyMode when true will error out if can&#39;t find any accounts matching (signin only) (optional, default to false)
     * @param responseFilters this determines how much of the profile should be returned, see ProfileFilters (optional)
     * @param latitude the latitude of the user (optional)
     * @param longitude the longitude of the user (optional)
     * @param metaData External custom client defined data (optional)
     * @param thirdPartyRefreshToken optional refresh token for the third party (optional)
     * @param audienceIdsToAdd audience ids to add to the account (optional)
     * @param audienceIdsToRemove audience ids to remove from the account (optional)
     * @return ProfileResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createCredential(thirdPartyId: kotlin.String, thirdPartyToken: kotlin.String, networkUID: kotlin.String, appKey: kotlin.String, accountId: kotlin.Long? = null, deviceId: kotlin.String? = null, sessionId: kotlin.String? = null, thirdPartyName: kotlin.String? = null, emailAddress: kotlin.String? = null, signinOnlyMode: kotlin.Boolean? = false, responseFilters: kotlin.String? = null, latitude: kotlin.Double? = null, longitude: kotlin.Double? = null, metaData: kotlin.String? = null, thirdPartyRefreshToken: kotlin.String? = null, audienceIdsToAdd: kotlin.String? = null, audienceIdsToRemove: kotlin.String? = null) : ProfileResponse {
        val localVarResponse = createCredentialWithHttpInfo(thirdPartyId = thirdPartyId, thirdPartyToken = thirdPartyToken, networkUID = networkUID, appKey = appKey, accountId = accountId, deviceId = deviceId, sessionId = sessionId, thirdPartyName = thirdPartyName, emailAddress = emailAddress, signinOnlyMode = signinOnlyMode, responseFilters = responseFilters, latitude = latitude, longitude = longitude, metaData = metaData, thirdPartyRefreshToken = thirdPartyRefreshToken, audienceIdsToAdd = audienceIdsToAdd, audienceIdsToRemove = audienceIdsToRemove)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ProfileResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /thirdparty/credential/create
     * Create Credential
     * This endpoint creates a third-party login for a Sirqul account. A third party login is a way for external systems (Third Party Networks) to link their own user accounts with a Sirqul account.   The thirdPartyId parameter is used to determine if the user already exists in Sirqul or not. This parameter needs to be unique for each user in the Third Party Network (identified by the networkUID parameter). Note that subsequent calls will update the user&#39;s third-party login credentials for the user with the same thirdPartyId and networkUID combination.    The thirdPartyToken parameter acts as a shared secret and used by client applications to log users into Sirqul without providing a Sirqul username and password. 
     * @param thirdPartyId the third party user account id
     * @param thirdPartyToken the access token to authenticate with (ex: username or fb token or phone number)
     * @param networkUID the access provider to authenticate against
     * @param appKey the application key
     * @param accountId the unique id of the account that needs authenticating (optional for PHONE_V2) (optional)
     * @param deviceId the unique id of the device making the request (optional)
     * @param sessionId the session id for the request (optional)
     * @param thirdPartyName the third party user&#39;s display name (optional)
     * @param emailAddress optional email address associated with the third party account (optional)
     * @param signinOnlyMode when true will error out if can&#39;t find any accounts matching (signin only) (optional, default to false)
     * @param responseFilters this determines how much of the profile should be returned, see ProfileFilters (optional)
     * @param latitude the latitude of the user (optional)
     * @param longitude the longitude of the user (optional)
     * @param metaData External custom client defined data (optional)
     * @param thirdPartyRefreshToken optional refresh token for the third party (optional)
     * @param audienceIdsToAdd audience ids to add to the account (optional)
     * @param audienceIdsToRemove audience ids to remove from the account (optional)
     * @return ApiResponse<ProfileResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createCredentialWithHttpInfo(thirdPartyId: kotlin.String, thirdPartyToken: kotlin.String, networkUID: kotlin.String, appKey: kotlin.String, accountId: kotlin.Long?, deviceId: kotlin.String?, sessionId: kotlin.String?, thirdPartyName: kotlin.String?, emailAddress: kotlin.String?, signinOnlyMode: kotlin.Boolean?, responseFilters: kotlin.String?, latitude: kotlin.Double?, longitude: kotlin.Double?, metaData: kotlin.String?, thirdPartyRefreshToken: kotlin.String?, audienceIdsToAdd: kotlin.String?, audienceIdsToRemove: kotlin.String?) : ApiResponse<ProfileResponse?> {
        val localVariableConfig = createCredentialRequestConfig(thirdPartyId = thirdPartyId, thirdPartyToken = thirdPartyToken, networkUID = networkUID, appKey = appKey, accountId = accountId, deviceId = deviceId, sessionId = sessionId, thirdPartyName = thirdPartyName, emailAddress = emailAddress, signinOnlyMode = signinOnlyMode, responseFilters = responseFilters, latitude = latitude, longitude = longitude, metaData = metaData, thirdPartyRefreshToken = thirdPartyRefreshToken, audienceIdsToAdd = audienceIdsToAdd, audienceIdsToRemove = audienceIdsToRemove)

        return request<Unit, ProfileResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createCredential
     *
     * @param thirdPartyId the third party user account id
     * @param thirdPartyToken the access token to authenticate with (ex: username or fb token or phone number)
     * @param networkUID the access provider to authenticate against
     * @param appKey the application key
     * @param accountId the unique id of the account that needs authenticating (optional for PHONE_V2) (optional)
     * @param deviceId the unique id of the device making the request (optional)
     * @param sessionId the session id for the request (optional)
     * @param thirdPartyName the third party user&#39;s display name (optional)
     * @param emailAddress optional email address associated with the third party account (optional)
     * @param signinOnlyMode when true will error out if can&#39;t find any accounts matching (signin only) (optional, default to false)
     * @param responseFilters this determines how much of the profile should be returned, see ProfileFilters (optional)
     * @param latitude the latitude of the user (optional)
     * @param longitude the longitude of the user (optional)
     * @param metaData External custom client defined data (optional)
     * @param thirdPartyRefreshToken optional refresh token for the third party (optional)
     * @param audienceIdsToAdd audience ids to add to the account (optional)
     * @param audienceIdsToRemove audience ids to remove from the account (optional)
     * @return RequestConfig
     */
    fun createCredentialRequestConfig(thirdPartyId: kotlin.String, thirdPartyToken: kotlin.String, networkUID: kotlin.String, appKey: kotlin.String, accountId: kotlin.Long?, deviceId: kotlin.String?, sessionId: kotlin.String?, thirdPartyName: kotlin.String?, emailAddress: kotlin.String?, signinOnlyMode: kotlin.Boolean?, responseFilters: kotlin.String?, latitude: kotlin.Double?, longitude: kotlin.Double?, metaData: kotlin.String?, thirdPartyRefreshToken: kotlin.String?, audienceIdsToAdd: kotlin.String?, audienceIdsToRemove: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (sessionId != null) {
                    put("sessionId", listOf(sessionId.toString()))
                }
                put("thirdPartyId", listOf(thirdPartyId.toString()))
                if (thirdPartyName != null) {
                    put("thirdPartyName", listOf(thirdPartyName.toString()))
                }
                put("thirdPartyToken", listOf(thirdPartyToken.toString()))
                put("networkUID", listOf(networkUID.toString()))
                put("appKey", listOf(appKey.toString()))
                if (emailAddress != null) {
                    put("emailAddress", listOf(emailAddress.toString()))
                }
                if (signinOnlyMode != null) {
                    put("signinOnlyMode", listOf(signinOnlyMode.toString()))
                }
                if (responseFilters != null) {
                    put("responseFilters", listOf(responseFilters.toString()))
                }
                if (latitude != null) {
                    put("latitude", listOf(latitude.toString()))
                }
                if (longitude != null) {
                    put("longitude", listOf(longitude.toString()))
                }
                if (metaData != null) {
                    put("metaData", listOf(metaData.toString()))
                }
                if (thirdPartyRefreshToken != null) {
                    put("thirdPartyRefreshToken", listOf(thirdPartyRefreshToken.toString()))
                }
                if (audienceIdsToAdd != null) {
                    put("audienceIdsToAdd", listOf(audienceIdsToAdd.toString()))
                }
                if (audienceIdsToRemove != null) {
                    put("audienceIdsToRemove", listOf(audienceIdsToRemove.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/thirdparty/credential/create",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /thirdparty/network/create
     * Create Network
     * Creates a custom third party network.
     * @param accountId The account id making the request
     * @param name The name of the network
     * @param enableIntrospection Whether the network uses introspection calls
     * @param description The description of the network (optional)
     * @param introspectionMethod HTTP method to use for introspection calls (e.g., GET, POST) (optional)
     * @param introspectionURL The HTTP URL of the introspection call (optional)
     * @param introspectionParams The parameters of the introspection call (optional)
     * @param requiredRootField Required response params (optional)
     * @param enableMFA Whether this network uses MFA (optional)
     * @param sizeMFA Size of the MFA token (optional)
     * @param shelfLifeMFA Shelf life (seconds) of the MFA token (optional)
     * @param oauthTokenURL OAuth token endpoint URL (optional)
     * @param oauthPrivateKey OAuth private key file (multipart) (optional)
     * @param oauthPublicKey OAuth public key file (multipart) (optional)
     * @param oauthClientId OAuth client id (optional)
     * @param oauthSecretKey OAuth secret key (optional)
     * @param body  (optional)
     * @return ThirdPartyNetworkResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createNetwork(accountId: kotlin.Long, name: kotlin.String, enableIntrospection: kotlin.Boolean, description: kotlin.String? = null, introspectionMethod: kotlin.String? = null, introspectionURL: kotlin.String? = null, introspectionParams: kotlin.String? = null, requiredRootField: kotlin.String? = null, enableMFA: kotlin.Boolean? = null, sizeMFA: kotlin.Int? = null, shelfLifeMFA: kotlin.Int? = null, oauthTokenURL: kotlin.String? = null, oauthPrivateKey: java.io.File? = null, oauthPublicKey: java.io.File? = null, oauthClientId: kotlin.String? = null, oauthSecretKey: kotlin.String? = null, body: kotlin.String? = null) : ThirdPartyNetworkResponse {
        val localVarResponse = createNetworkWithHttpInfo(accountId = accountId, name = name, enableIntrospection = enableIntrospection, description = description, introspectionMethod = introspectionMethod, introspectionURL = introspectionURL, introspectionParams = introspectionParams, requiredRootField = requiredRootField, enableMFA = enableMFA, sizeMFA = sizeMFA, shelfLifeMFA = shelfLifeMFA, oauthTokenURL = oauthTokenURL, oauthPrivateKey = oauthPrivateKey, oauthPublicKey = oauthPublicKey, oauthClientId = oauthClientId, oauthSecretKey = oauthSecretKey, body = body)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ThirdPartyNetworkResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /thirdparty/network/create
     * Create Network
     * Creates a custom third party network.
     * @param accountId The account id making the request
     * @param name The name of the network
     * @param enableIntrospection Whether the network uses introspection calls
     * @param description The description of the network (optional)
     * @param introspectionMethod HTTP method to use for introspection calls (e.g., GET, POST) (optional)
     * @param introspectionURL The HTTP URL of the introspection call (optional)
     * @param introspectionParams The parameters of the introspection call (optional)
     * @param requiredRootField Required response params (optional)
     * @param enableMFA Whether this network uses MFA (optional)
     * @param sizeMFA Size of the MFA token (optional)
     * @param shelfLifeMFA Shelf life (seconds) of the MFA token (optional)
     * @param oauthTokenURL OAuth token endpoint URL (optional)
     * @param oauthPrivateKey OAuth private key file (multipart) (optional)
     * @param oauthPublicKey OAuth public key file (multipart) (optional)
     * @param oauthClientId OAuth client id (optional)
     * @param oauthSecretKey OAuth secret key (optional)
     * @param body  (optional)
     * @return ApiResponse<ThirdPartyNetworkResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createNetworkWithHttpInfo(accountId: kotlin.Long, name: kotlin.String, enableIntrospection: kotlin.Boolean, description: kotlin.String?, introspectionMethod: kotlin.String?, introspectionURL: kotlin.String?, introspectionParams: kotlin.String?, requiredRootField: kotlin.String?, enableMFA: kotlin.Boolean?, sizeMFA: kotlin.Int?, shelfLifeMFA: kotlin.Int?, oauthTokenURL: kotlin.String?, oauthPrivateKey: java.io.File?, oauthPublicKey: java.io.File?, oauthClientId: kotlin.String?, oauthSecretKey: kotlin.String?, body: kotlin.String?) : ApiResponse<ThirdPartyNetworkResponse?> {
        val localVariableConfig = createNetworkRequestConfig(accountId = accountId, name = name, enableIntrospection = enableIntrospection, description = description, introspectionMethod = introspectionMethod, introspectionURL = introspectionURL, introspectionParams = introspectionParams, requiredRootField = requiredRootField, enableMFA = enableMFA, sizeMFA = sizeMFA, shelfLifeMFA = shelfLifeMFA, oauthTokenURL = oauthTokenURL, oauthPrivateKey = oauthPrivateKey, oauthPublicKey = oauthPublicKey, oauthClientId = oauthClientId, oauthSecretKey = oauthSecretKey, body = body)

        return request<kotlin.String, ThirdPartyNetworkResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createNetwork
     *
     * @param accountId The account id making the request
     * @param name The name of the network
     * @param enableIntrospection Whether the network uses introspection calls
     * @param description The description of the network (optional)
     * @param introspectionMethod HTTP method to use for introspection calls (e.g., GET, POST) (optional)
     * @param introspectionURL The HTTP URL of the introspection call (optional)
     * @param introspectionParams The parameters of the introspection call (optional)
     * @param requiredRootField Required response params (optional)
     * @param enableMFA Whether this network uses MFA (optional)
     * @param sizeMFA Size of the MFA token (optional)
     * @param shelfLifeMFA Shelf life (seconds) of the MFA token (optional)
     * @param oauthTokenURL OAuth token endpoint URL (optional)
     * @param oauthPrivateKey OAuth private key file (multipart) (optional)
     * @param oauthPublicKey OAuth public key file (multipart) (optional)
     * @param oauthClientId OAuth client id (optional)
     * @param oauthSecretKey OAuth secret key (optional)
     * @param body  (optional)
     * @return RequestConfig
     */
    fun createNetworkRequestConfig(accountId: kotlin.Long, name: kotlin.String, enableIntrospection: kotlin.Boolean, description: kotlin.String?, introspectionMethod: kotlin.String?, introspectionURL: kotlin.String?, introspectionParams: kotlin.String?, requiredRootField: kotlin.String?, enableMFA: kotlin.Boolean?, sizeMFA: kotlin.Int?, shelfLifeMFA: kotlin.Int?, oauthTokenURL: kotlin.String?, oauthPrivateKey: java.io.File?, oauthPublicKey: java.io.File?, oauthClientId: kotlin.String?, oauthSecretKey: kotlin.String?, body: kotlin.String?) : RequestConfig<kotlin.String> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("name", listOf(name.toString()))
                if (description != null) {
                    put("description", listOf(description.toString()))
                }
                put("enableIntrospection", listOf(enableIntrospection.toString()))
                if (introspectionMethod != null) {
                    put("introspectionMethod", listOf(introspectionMethod.toString()))
                }
                if (introspectionURL != null) {
                    put("introspectionURL", listOf(introspectionURL.toString()))
                }
                if (introspectionParams != null) {
                    put("introspectionParams", listOf(introspectionParams.toString()))
                }
                if (requiredRootField != null) {
                    put("requiredRootField", listOf(requiredRootField.toString()))
                }
                if (enableMFA != null) {
                    put("enableMFA", listOf(enableMFA.toString()))
                }
                if (sizeMFA != null) {
                    put("sizeMFA", listOf(sizeMFA.toString()))
                }
                if (shelfLifeMFA != null) {
                    put("shelfLifeMFA", listOf(shelfLifeMFA.toString()))
                }
                if (oauthTokenURL != null) {
                    put("oauthTokenURL", listOf(oauthTokenURL.toString()))
                }
                if (oauthPrivateKey != null) {
                    put("oauthPrivateKey", listOf(oauthPrivateKey.toString()))
                }
                if (oauthPublicKey != null) {
                    put("oauthPublicKey", listOf(oauthPublicKey.toString()))
                }
                if (oauthClientId != null) {
                    put("oauthClientId", listOf(oauthClientId.toString()))
                }
                if (oauthSecretKey != null) {
                    put("oauthSecretKey", listOf(oauthSecretKey.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/thirdparty/network/create",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /thirdparty/credential/delete
     * Delete Credential
     * Delete a third party network on a Sirqul account.
     * @param accountId The account id of the user
     * @param networkUID The third party network identifier
     * @param thirdPartyId The third party user id
     * @param appKey the application key
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteCredential(accountId: kotlin.Long, networkUID: kotlin.String, thirdPartyId: kotlin.String, appKey: kotlin.String) : SirqulResponse {
        val localVarResponse = deleteCredentialWithHttpInfo(accountId = accountId, networkUID = networkUID, thirdPartyId = thirdPartyId, appKey = appKey)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /thirdparty/credential/delete
     * Delete Credential
     * Delete a third party network on a Sirqul account.
     * @param accountId The account id of the user
     * @param networkUID The third party network identifier
     * @param thirdPartyId The third party user id
     * @param appKey the application key
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteCredentialWithHttpInfo(accountId: kotlin.Long, networkUID: kotlin.String, thirdPartyId: kotlin.String, appKey: kotlin.String) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = deleteCredentialRequestConfig(accountId = accountId, networkUID = networkUID, thirdPartyId = thirdPartyId, appKey = appKey)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteCredential
     *
     * @param accountId The account id of the user
     * @param networkUID The third party network identifier
     * @param thirdPartyId The third party user id
     * @param appKey the application key
     * @return RequestConfig
     */
    fun deleteCredentialRequestConfig(accountId: kotlin.Long, networkUID: kotlin.String, thirdPartyId: kotlin.String, appKey: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("networkUID", listOf(networkUID.toString()))
                put("thirdPartyId", listOf(thirdPartyId.toString()))
                put("appKey", listOf(appKey.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/thirdparty/credential/delete",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /thirdparty/network/delete
     * Delete Network
     * Marks a custom third party network as deleted. Only the network owners and managers have access to this.
     * @param accountId the id of the logged in user
     * @param networkUID The unique identifier for the third party network defined by Sirqul
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteNetwork(accountId: kotlin.Long, networkUID: kotlin.String) : SirqulResponse {
        val localVarResponse = deleteNetworkWithHttpInfo(accountId = accountId, networkUID = networkUID)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /thirdparty/network/delete
     * Delete Network
     * Marks a custom third party network as deleted. Only the network owners and managers have access to this.
     * @param accountId the id of the logged in user
     * @param networkUID The unique identifier for the third party network defined by Sirqul
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteNetworkWithHttpInfo(accountId: kotlin.Long, networkUID: kotlin.String) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = deleteNetworkRequestConfig(accountId = accountId, networkUID = networkUID)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteNetwork
     *
     * @param accountId the id of the logged in user
     * @param networkUID The unique identifier for the third party network defined by Sirqul
     * @return RequestConfig
     */
    fun deleteNetworkRequestConfig(accountId: kotlin.Long, networkUID: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("networkUID", listOf(networkUID.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/thirdparty/network/delete",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /thirdparty/credential/get
     * Get Credential
     * Gets the account information given a third party token.
     * @param networkUID the access provider to authenticate against
     * @param appKey the application key
     * @param accountId the unique account id of a specific account that will be bound to the third-party credentials (optional)
     * @param deviceId the unique id of the device making the request (optional)
     * @param sessionId the session id for the request (optional)
     * @param thirdPartyCredentialId the third-party credentials id from the response of the credential/create step (optional)
     * @param thirdPartyToken the access token to authenticate with (optional)
     * @param thirdPartySecret the secret code to authenticate with (used for MFA) (optional)
     * @param createNewAccount flag to force creation of a new account when no accountId is passed and user chooses not to use listed accounts (optional, default to false)
     * @param responseFilters this determines how much of the profile should be returned, see ProfileFilters (optional)
     * @param latitude the latitude of the user (optional)
     * @param longitude the longitude of the user (optional)
     * @param audienceIdsToAdd audience ids to add to the account (optional)
     * @param audienceIdsToRemove audience ids to remove from the account (optional)
     * @param referralAccountId account id of the referrer (inviter-invitee relationship) (optional)
     * @return ProfileResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getCredential(networkUID: kotlin.String, appKey: kotlin.String, accountId: kotlin.Long? = null, deviceId: kotlin.String? = null, sessionId: kotlin.String? = null, thirdPartyCredentialId: kotlin.Long? = null, thirdPartyToken: kotlin.String? = null, thirdPartySecret: kotlin.String? = null, createNewAccount: kotlin.Boolean? = false, responseFilters: kotlin.String? = null, latitude: kotlin.Double? = null, longitude: kotlin.Double? = null, audienceIdsToAdd: kotlin.String? = null, audienceIdsToRemove: kotlin.String? = null, referralAccountId: kotlin.Long? = null) : ProfileResponse {
        val localVarResponse = getCredentialWithHttpInfo(networkUID = networkUID, appKey = appKey, accountId = accountId, deviceId = deviceId, sessionId = sessionId, thirdPartyCredentialId = thirdPartyCredentialId, thirdPartyToken = thirdPartyToken, thirdPartySecret = thirdPartySecret, createNewAccount = createNewAccount, responseFilters = responseFilters, latitude = latitude, longitude = longitude, audienceIdsToAdd = audienceIdsToAdd, audienceIdsToRemove = audienceIdsToRemove, referralAccountId = referralAccountId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ProfileResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /thirdparty/credential/get
     * Get Credential
     * Gets the account information given a third party token.
     * @param networkUID the access provider to authenticate against
     * @param appKey the application key
     * @param accountId the unique account id of a specific account that will be bound to the third-party credentials (optional)
     * @param deviceId the unique id of the device making the request (optional)
     * @param sessionId the session id for the request (optional)
     * @param thirdPartyCredentialId the third-party credentials id from the response of the credential/create step (optional)
     * @param thirdPartyToken the access token to authenticate with (optional)
     * @param thirdPartySecret the secret code to authenticate with (used for MFA) (optional)
     * @param createNewAccount flag to force creation of a new account when no accountId is passed and user chooses not to use listed accounts (optional, default to false)
     * @param responseFilters this determines how much of the profile should be returned, see ProfileFilters (optional)
     * @param latitude the latitude of the user (optional)
     * @param longitude the longitude of the user (optional)
     * @param audienceIdsToAdd audience ids to add to the account (optional)
     * @param audienceIdsToRemove audience ids to remove from the account (optional)
     * @param referralAccountId account id of the referrer (inviter-invitee relationship) (optional)
     * @return ApiResponse<ProfileResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getCredentialWithHttpInfo(networkUID: kotlin.String, appKey: kotlin.String, accountId: kotlin.Long?, deviceId: kotlin.String?, sessionId: kotlin.String?, thirdPartyCredentialId: kotlin.Long?, thirdPartyToken: kotlin.String?, thirdPartySecret: kotlin.String?, createNewAccount: kotlin.Boolean?, responseFilters: kotlin.String?, latitude: kotlin.Double?, longitude: kotlin.Double?, audienceIdsToAdd: kotlin.String?, audienceIdsToRemove: kotlin.String?, referralAccountId: kotlin.Long?) : ApiResponse<ProfileResponse?> {
        val localVariableConfig = getCredentialRequestConfig(networkUID = networkUID, appKey = appKey, accountId = accountId, deviceId = deviceId, sessionId = sessionId, thirdPartyCredentialId = thirdPartyCredentialId, thirdPartyToken = thirdPartyToken, thirdPartySecret = thirdPartySecret, createNewAccount = createNewAccount, responseFilters = responseFilters, latitude = latitude, longitude = longitude, audienceIdsToAdd = audienceIdsToAdd, audienceIdsToRemove = audienceIdsToRemove, referralAccountId = referralAccountId)

        return request<Unit, ProfileResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getCredential
     *
     * @param networkUID the access provider to authenticate against
     * @param appKey the application key
     * @param accountId the unique account id of a specific account that will be bound to the third-party credentials (optional)
     * @param deviceId the unique id of the device making the request (optional)
     * @param sessionId the session id for the request (optional)
     * @param thirdPartyCredentialId the third-party credentials id from the response of the credential/create step (optional)
     * @param thirdPartyToken the access token to authenticate with (optional)
     * @param thirdPartySecret the secret code to authenticate with (used for MFA) (optional)
     * @param createNewAccount flag to force creation of a new account when no accountId is passed and user chooses not to use listed accounts (optional, default to false)
     * @param responseFilters this determines how much of the profile should be returned, see ProfileFilters (optional)
     * @param latitude the latitude of the user (optional)
     * @param longitude the longitude of the user (optional)
     * @param audienceIdsToAdd audience ids to add to the account (optional)
     * @param audienceIdsToRemove audience ids to remove from the account (optional)
     * @param referralAccountId account id of the referrer (inviter-invitee relationship) (optional)
     * @return RequestConfig
     */
    fun getCredentialRequestConfig(networkUID: kotlin.String, appKey: kotlin.String, accountId: kotlin.Long?, deviceId: kotlin.String?, sessionId: kotlin.String?, thirdPartyCredentialId: kotlin.Long?, thirdPartyToken: kotlin.String?, thirdPartySecret: kotlin.String?, createNewAccount: kotlin.Boolean?, responseFilters: kotlin.String?, latitude: kotlin.Double?, longitude: kotlin.Double?, audienceIdsToAdd: kotlin.String?, audienceIdsToRemove: kotlin.String?, referralAccountId: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (sessionId != null) {
                    put("sessionId", listOf(sessionId.toString()))
                }
                if (thirdPartyCredentialId != null) {
                    put("thirdPartyCredentialId", listOf(thirdPartyCredentialId.toString()))
                }
                if (thirdPartyToken != null) {
                    put("thirdPartyToken", listOf(thirdPartyToken.toString()))
                }
                if (thirdPartySecret != null) {
                    put("thirdPartySecret", listOf(thirdPartySecret.toString()))
                }
                if (createNewAccount != null) {
                    put("createNewAccount", listOf(createNewAccount.toString()))
                }
                put("networkUID", listOf(networkUID.toString()))
                put("appKey", listOf(appKey.toString()))
                if (responseFilters != null) {
                    put("responseFilters", listOf(responseFilters.toString()))
                }
                if (latitude != null) {
                    put("latitude", listOf(latitude.toString()))
                }
                if (longitude != null) {
                    put("longitude", listOf(longitude.toString()))
                }
                if (audienceIdsToAdd != null) {
                    put("audienceIdsToAdd", listOf(audienceIdsToAdd.toString()))
                }
                if (audienceIdsToRemove != null) {
                    put("audienceIdsToRemove", listOf(audienceIdsToRemove.toString()))
                }
                if (referralAccountId != null) {
                    put("referralAccountId", listOf(referralAccountId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/thirdparty/credential/get",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /thirdparty/network/get
     * Get Network
     * Get the details of a third party network. Only the network owners and managers have access to this.
     * @param accountId The account id making the request
     * @param networkUID The unique identifier for the third party network defined by Sirqul
     * @return ThirdPartyNetworkResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getNetwork(accountId: kotlin.Long, networkUID: kotlin.String) : ThirdPartyNetworkResponse {
        val localVarResponse = getNetworkWithHttpInfo(accountId = accountId, networkUID = networkUID)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ThirdPartyNetworkResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /thirdparty/network/get
     * Get Network
     * Get the details of a third party network. Only the network owners and managers have access to this.
     * @param accountId The account id making the request
     * @param networkUID The unique identifier for the third party network defined by Sirqul
     * @return ApiResponse<ThirdPartyNetworkResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getNetworkWithHttpInfo(accountId: kotlin.Long, networkUID: kotlin.String) : ApiResponse<ThirdPartyNetworkResponse?> {
        val localVariableConfig = getNetworkRequestConfig(accountId = accountId, networkUID = networkUID)

        return request<Unit, ThirdPartyNetworkResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getNetwork
     *
     * @param accountId The account id making the request
     * @param networkUID The unique identifier for the third party network defined by Sirqul
     * @return RequestConfig
     */
    fun getNetworkRequestConfig(accountId: kotlin.Long, networkUID: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("networkUID", listOf(networkUID.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/thirdparty/network/get",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /thirdparty/credential/search
     * Search Credentials
     * Search on a user&#39;s linked third party networks.
     * @param accountId The account id of the user
     * @param keyword The keyword used to search on the third party name and network string (optional)
     * @param networkUID The network UID to filter results with (optional)
     * @param descending The order to return the search results (optional)
     * @param start The start of the pagination (optional, default to 0)
     * @param limit The limit of the pagination (optional, default to 20)
     * @return kotlin.collections.List<ThirdPartyCredentialResponse>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun searchCredentials(accountId: kotlin.Long, keyword: kotlin.String? = null, networkUID: kotlin.String? = null, descending: kotlin.Boolean? = null, start: kotlin.Int? = 0, limit: kotlin.Int? = 20) : kotlin.collections.List<ThirdPartyCredentialResponse> {
        val localVarResponse = searchCredentialsWithHttpInfo(accountId = accountId, keyword = keyword, networkUID = networkUID, descending = descending, start = start, limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<ThirdPartyCredentialResponse>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /thirdparty/credential/search
     * Search Credentials
     * Search on a user&#39;s linked third party networks.
     * @param accountId The account id of the user
     * @param keyword The keyword used to search on the third party name and network string (optional)
     * @param networkUID The network UID to filter results with (optional)
     * @param descending The order to return the search results (optional)
     * @param start The start of the pagination (optional, default to 0)
     * @param limit The limit of the pagination (optional, default to 20)
     * @return ApiResponse<kotlin.collections.List<ThirdPartyCredentialResponse>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun searchCredentialsWithHttpInfo(accountId: kotlin.Long, keyword: kotlin.String?, networkUID: kotlin.String?, descending: kotlin.Boolean?, start: kotlin.Int?, limit: kotlin.Int?) : ApiResponse<kotlin.collections.List<ThirdPartyCredentialResponse>?> {
        val localVariableConfig = searchCredentialsRequestConfig(accountId = accountId, keyword = keyword, networkUID = networkUID, descending = descending, start = start, limit = limit)

        return request<Unit, kotlin.collections.List<ThirdPartyCredentialResponse>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation searchCredentials
     *
     * @param accountId The account id of the user
     * @param keyword The keyword used to search on the third party name and network string (optional)
     * @param networkUID The network UID to filter results with (optional)
     * @param descending The order to return the search results (optional)
     * @param start The start of the pagination (optional, default to 0)
     * @param limit The limit of the pagination (optional, default to 20)
     * @return RequestConfig
     */
    fun searchCredentialsRequestConfig(accountId: kotlin.Long, keyword: kotlin.String?, networkUID: kotlin.String?, descending: kotlin.Boolean?, start: kotlin.Int?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                if (keyword != null) {
                    put("keyword", listOf(keyword.toString()))
                }
                if (networkUID != null) {
                    put("networkUID", listOf(networkUID.toString()))
                }
                if (descending != null) {
                    put("descending", listOf(descending.toString()))
                }
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/thirdparty/credential/search",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter sortField
     */
     enum class SortFieldSearchNetworks(val value: kotlin.String) {
         @Json(name = "ID") ID("ID"),
         @Json(name = "CREATED") CREATED("CREATED"),
         @Json(name = "UPDATED") UPDATED("UPDATED"),
         @Json(name = "DELETED") DELETED("DELETED"),
         @Json(name = "SEARCH_TAGS") SEARCH_TAGS("SEARCH_TAGS"),
         @Json(name = "ACTIVE") ACTIVE("ACTIVE"),
         @Json(name = "BILLABLE_ENTITY_ID") BILLABLE_ENTITY_ID("BILLABLE_ENTITY_ID"),
         @Json(name = "BILLABLE_ENTITY_NAME") BILLABLE_ENTITY_NAME("BILLABLE_ENTITY_NAME"),
         @Json(name = "RESPONSIBLE_DISPLAY") RESPONSIBLE_DISPLAY("RESPONSIBLE_DISPLAY"),
         @Json(name = "NAME") NAME("NAME"),
         @Json(name = "DESCRIPTION") DESCRIPTION("DESCRIPTION");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /thirdparty/network/search
     * Search Networks
     * Search on supported third party networks and custom networks from external users.
     * @param accountId The account id making the request
     * @param sortField The column to sort the search on, possible values include: UPDATED (default), CREATED, NAME
     * @param descending The order to return the search results
     * @param start The start of the pagination
     * @param limit The limit of the pagination
     * @param activeOnly Return only active results
     * @param keyword The keyword used to search on the network name and description fields (optional)
     * @param filterBillable Determines whether to only return applications that the user has access to (optional)
     * @return kotlin.collections.List<ThirdPartyNetworkShortResponse>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun searchNetworks(accountId: kotlin.Long, sortField: SortFieldSearchNetworks, descending: kotlin.Boolean, start: kotlin.Int, limit: kotlin.Int, activeOnly: kotlin.Boolean, keyword: kotlin.String? = null, filterBillable: kotlin.Boolean? = null) : kotlin.collections.List<ThirdPartyNetworkShortResponse> {
        val localVarResponse = searchNetworksWithHttpInfo(accountId = accountId, sortField = sortField, descending = descending, start = start, limit = limit, activeOnly = activeOnly, keyword = keyword, filterBillable = filterBillable)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<ThirdPartyNetworkShortResponse>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /thirdparty/network/search
     * Search Networks
     * Search on supported third party networks and custom networks from external users.
     * @param accountId The account id making the request
     * @param sortField The column to sort the search on, possible values include: UPDATED (default), CREATED, NAME
     * @param descending The order to return the search results
     * @param start The start of the pagination
     * @param limit The limit of the pagination
     * @param activeOnly Return only active results
     * @param keyword The keyword used to search on the network name and description fields (optional)
     * @param filterBillable Determines whether to only return applications that the user has access to (optional)
     * @return ApiResponse<kotlin.collections.List<ThirdPartyNetworkShortResponse>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun searchNetworksWithHttpInfo(accountId: kotlin.Long, sortField: SortFieldSearchNetworks, descending: kotlin.Boolean, start: kotlin.Int, limit: kotlin.Int, activeOnly: kotlin.Boolean, keyword: kotlin.String?, filterBillable: kotlin.Boolean?) : ApiResponse<kotlin.collections.List<ThirdPartyNetworkShortResponse>?> {
        val localVariableConfig = searchNetworksRequestConfig(accountId = accountId, sortField = sortField, descending = descending, start = start, limit = limit, activeOnly = activeOnly, keyword = keyword, filterBillable = filterBillable)

        return request<Unit, kotlin.collections.List<ThirdPartyNetworkShortResponse>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation searchNetworks
     *
     * @param accountId The account id making the request
     * @param sortField The column to sort the search on, possible values include: UPDATED (default), CREATED, NAME
     * @param descending The order to return the search results
     * @param start The start of the pagination
     * @param limit The limit of the pagination
     * @param activeOnly Return only active results
     * @param keyword The keyword used to search on the network name and description fields (optional)
     * @param filterBillable Determines whether to only return applications that the user has access to (optional)
     * @return RequestConfig
     */
    fun searchNetworksRequestConfig(accountId: kotlin.Long, sortField: SortFieldSearchNetworks, descending: kotlin.Boolean, start: kotlin.Int, limit: kotlin.Int, activeOnly: kotlin.Boolean, keyword: kotlin.String?, filterBillable: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                if (keyword != null) {
                    put("keyword", listOf(keyword.toString()))
                }
                put("sortField", listOf(sortField.value))
                put("descending", listOf(descending.toString()))
                put("start", listOf(start.toString()))
                put("limit", listOf(limit.toString()))
                put("activeOnly", listOf(activeOnly.toString()))
                if (filterBillable != null) {
                    put("filterBillable", listOf(filterBillable.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/thirdparty/network/search",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /thirdparty/credential/mfa/send
     * Send MFA Challenge
     * Sends an MFA challenge (SMS or Email) for networks with MFA enabled.
     * @param networkUID the third party network provider that has MFA enabled
     * @param appKey the application key
     * @param thirdPartyToken the access token to authenticate with (optional)
     * @param thirdPartyCredentialId optional id of the existing third party credential (optional)
     * @param deviceId the unique id of the device making the request (optional)
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sendMFAChallenge(networkUID: kotlin.String, appKey: kotlin.String, thirdPartyToken: kotlin.String? = null, thirdPartyCredentialId: kotlin.Long? = null, deviceId: kotlin.String? = null) : SirqulResponse {
        val localVarResponse = sendMFAChallengeWithHttpInfo(networkUID = networkUID, appKey = appKey, thirdPartyToken = thirdPartyToken, thirdPartyCredentialId = thirdPartyCredentialId, deviceId = deviceId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /thirdparty/credential/mfa/send
     * Send MFA Challenge
     * Sends an MFA challenge (SMS or Email) for networks with MFA enabled.
     * @param networkUID the third party network provider that has MFA enabled
     * @param appKey the application key
     * @param thirdPartyToken the access token to authenticate with (optional)
     * @param thirdPartyCredentialId optional id of the existing third party credential (optional)
     * @param deviceId the unique id of the device making the request (optional)
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sendMFAChallengeWithHttpInfo(networkUID: kotlin.String, appKey: kotlin.String, thirdPartyToken: kotlin.String?, thirdPartyCredentialId: kotlin.Long?, deviceId: kotlin.String?) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = sendMFAChallengeRequestConfig(networkUID = networkUID, appKey = appKey, thirdPartyToken = thirdPartyToken, thirdPartyCredentialId = thirdPartyCredentialId, deviceId = deviceId)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sendMFAChallenge
     *
     * @param networkUID the third party network provider that has MFA enabled
     * @param appKey the application key
     * @param thirdPartyToken the access token to authenticate with (optional)
     * @param thirdPartyCredentialId optional id of the existing third party credential (optional)
     * @param deviceId the unique id of the device making the request (optional)
     * @return RequestConfig
     */
    fun sendMFAChallengeRequestConfig(networkUID: kotlin.String, appKey: kotlin.String, thirdPartyToken: kotlin.String?, thirdPartyCredentialId: kotlin.Long?, deviceId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (thirdPartyToken != null) {
                    put("thirdPartyToken", listOf(thirdPartyToken.toString()))
                }
                if (thirdPartyCredentialId != null) {
                    put("thirdPartyCredentialId", listOf(thirdPartyCredentialId.toString()))
                }
                put("networkUID", listOf(networkUID.toString()))
                put("appKey", listOf(appKey.toString()))
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/thirdparty/credential/mfa/send",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /thirdparty/credential/update
     * Update Credential
     * Updates a third-party login for an account.
     * @param networkUID the access provider to authenticate against
     * @param thirdPartyId the third party user account id
     * @param appKey the application key
     * @param deviceId the unique id of the device making the request (optional)
     * @param thirdPartyName the third party user name (optional)
     * @param thirdPartyToken the access token to authenticate with (ex: username or fb token) (optional)
     * @param responseFilters this determines how much of the profile should be returned, see ProfileFilters (optional)
     * @param metaData External custom client defined data (optional)
     * @param thirdPartyRefreshToken optional refresh token for the third party (optional)
     * @return ProfileResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updateCredential(networkUID: kotlin.String, thirdPartyId: kotlin.String, appKey: kotlin.String, deviceId: kotlin.String? = null, thirdPartyName: kotlin.String? = null, thirdPartyToken: kotlin.String? = null, responseFilters: kotlin.String? = null, metaData: kotlin.String? = null, thirdPartyRefreshToken: kotlin.String? = null) : ProfileResponse {
        val localVarResponse = updateCredentialWithHttpInfo(networkUID = networkUID, thirdPartyId = thirdPartyId, appKey = appKey, deviceId = deviceId, thirdPartyName = thirdPartyName, thirdPartyToken = thirdPartyToken, responseFilters = responseFilters, metaData = metaData, thirdPartyRefreshToken = thirdPartyRefreshToken)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ProfileResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /thirdparty/credential/update
     * Update Credential
     * Updates a third-party login for an account.
     * @param networkUID the access provider to authenticate against
     * @param thirdPartyId the third party user account id
     * @param appKey the application key
     * @param deviceId the unique id of the device making the request (optional)
     * @param thirdPartyName the third party user name (optional)
     * @param thirdPartyToken the access token to authenticate with (ex: username or fb token) (optional)
     * @param responseFilters this determines how much of the profile should be returned, see ProfileFilters (optional)
     * @param metaData External custom client defined data (optional)
     * @param thirdPartyRefreshToken optional refresh token for the third party (optional)
     * @return ApiResponse<ProfileResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun updateCredentialWithHttpInfo(networkUID: kotlin.String, thirdPartyId: kotlin.String, appKey: kotlin.String, deviceId: kotlin.String?, thirdPartyName: kotlin.String?, thirdPartyToken: kotlin.String?, responseFilters: kotlin.String?, metaData: kotlin.String?, thirdPartyRefreshToken: kotlin.String?) : ApiResponse<ProfileResponse?> {
        val localVariableConfig = updateCredentialRequestConfig(networkUID = networkUID, thirdPartyId = thirdPartyId, appKey = appKey, deviceId = deviceId, thirdPartyName = thirdPartyName, thirdPartyToken = thirdPartyToken, responseFilters = responseFilters, metaData = metaData, thirdPartyRefreshToken = thirdPartyRefreshToken)

        return request<Unit, ProfileResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateCredential
     *
     * @param networkUID the access provider to authenticate against
     * @param thirdPartyId the third party user account id
     * @param appKey the application key
     * @param deviceId the unique id of the device making the request (optional)
     * @param thirdPartyName the third party user name (optional)
     * @param thirdPartyToken the access token to authenticate with (ex: username or fb token) (optional)
     * @param responseFilters this determines how much of the profile should be returned, see ProfileFilters (optional)
     * @param metaData External custom client defined data (optional)
     * @param thirdPartyRefreshToken optional refresh token for the third party (optional)
     * @return RequestConfig
     */
    fun updateCredentialRequestConfig(networkUID: kotlin.String, thirdPartyId: kotlin.String, appKey: kotlin.String, deviceId: kotlin.String?, thirdPartyName: kotlin.String?, thirdPartyToken: kotlin.String?, responseFilters: kotlin.String?, metaData: kotlin.String?, thirdPartyRefreshToken: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                put("networkUID", listOf(networkUID.toString()))
                put("thirdPartyId", listOf(thirdPartyId.toString()))
                if (thirdPartyName != null) {
                    put("thirdPartyName", listOf(thirdPartyName.toString()))
                }
                if (thirdPartyToken != null) {
                    put("thirdPartyToken", listOf(thirdPartyToken.toString()))
                }
                put("appKey", listOf(appKey.toString()))
                if (responseFilters != null) {
                    put("responseFilters", listOf(responseFilters.toString()))
                }
                if (metaData != null) {
                    put("metaData", listOf(metaData.toString()))
                }
                if (thirdPartyRefreshToken != null) {
                    put("thirdPartyRefreshToken", listOf(thirdPartyRefreshToken.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/thirdparty/credential/update",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /thirdparty/network/update
     * Update Network
     * Updates a custom third party network. Only the network owners and managers have access to this.
     * @param accountId The account id making the request
     * @param networkUID The unique identifier for the third party network defined by Sirqul
     * @param name The name of the network (optional)
     * @param description The description of the network (optional)
     * @param enableIntrospection Whether the network uses introspection calls (optional)
     * @param introspectionMethod HTTP method to use for introspection calls (e.g., GET, POST) (optional)
     * @param introspectionURL The HTTP URL of the introspection call (optional)
     * @param introspectionParams The parameters of the introspection call (optional)
     * @param requiredRootField Required response params (optional)
     * @param enableMFA Whether this network uses MFA (optional)
     * @param sizeMFA Size of the MFA token (optional)
     * @param shelfLifeMFA Shelf life (seconds) of the MFA token (optional)
     * @param oauthTokenURL OAuth token endpoint URL (optional)
     * @param oauthPrivateKey OAuth private key file (multipart) (optional)
     * @param oauthPublicKey OAuth public key file (multipart) (optional)
     * @param oauthClientId OAuth client id (optional)
     * @param oauthSecretKey OAuth secret key (optional)
     * @param body  (optional)
     * @return ThirdPartyNetworkResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updateNetwork(accountId: kotlin.Long, networkUID: kotlin.String, name: kotlin.String? = null, description: kotlin.String? = null, enableIntrospection: kotlin.Boolean? = null, introspectionMethod: kotlin.String? = null, introspectionURL: kotlin.String? = null, introspectionParams: kotlin.String? = null, requiredRootField: kotlin.String? = null, enableMFA: kotlin.Boolean? = null, sizeMFA: kotlin.Int? = null, shelfLifeMFA: kotlin.Int? = null, oauthTokenURL: kotlin.String? = null, oauthPrivateKey: java.io.File? = null, oauthPublicKey: java.io.File? = null, oauthClientId: kotlin.String? = null, oauthSecretKey: kotlin.String? = null, body: kotlin.String? = null) : ThirdPartyNetworkResponse {
        val localVarResponse = updateNetworkWithHttpInfo(accountId = accountId, networkUID = networkUID, name = name, description = description, enableIntrospection = enableIntrospection, introspectionMethod = introspectionMethod, introspectionURL = introspectionURL, introspectionParams = introspectionParams, requiredRootField = requiredRootField, enableMFA = enableMFA, sizeMFA = sizeMFA, shelfLifeMFA = shelfLifeMFA, oauthTokenURL = oauthTokenURL, oauthPrivateKey = oauthPrivateKey, oauthPublicKey = oauthPublicKey, oauthClientId = oauthClientId, oauthSecretKey = oauthSecretKey, body = body)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ThirdPartyNetworkResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /thirdparty/network/update
     * Update Network
     * Updates a custom third party network. Only the network owners and managers have access to this.
     * @param accountId The account id making the request
     * @param networkUID The unique identifier for the third party network defined by Sirqul
     * @param name The name of the network (optional)
     * @param description The description of the network (optional)
     * @param enableIntrospection Whether the network uses introspection calls (optional)
     * @param introspectionMethod HTTP method to use for introspection calls (e.g., GET, POST) (optional)
     * @param introspectionURL The HTTP URL of the introspection call (optional)
     * @param introspectionParams The parameters of the introspection call (optional)
     * @param requiredRootField Required response params (optional)
     * @param enableMFA Whether this network uses MFA (optional)
     * @param sizeMFA Size of the MFA token (optional)
     * @param shelfLifeMFA Shelf life (seconds) of the MFA token (optional)
     * @param oauthTokenURL OAuth token endpoint URL (optional)
     * @param oauthPrivateKey OAuth private key file (multipart) (optional)
     * @param oauthPublicKey OAuth public key file (multipart) (optional)
     * @param oauthClientId OAuth client id (optional)
     * @param oauthSecretKey OAuth secret key (optional)
     * @param body  (optional)
     * @return ApiResponse<ThirdPartyNetworkResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun updateNetworkWithHttpInfo(accountId: kotlin.Long, networkUID: kotlin.String, name: kotlin.String?, description: kotlin.String?, enableIntrospection: kotlin.Boolean?, introspectionMethod: kotlin.String?, introspectionURL: kotlin.String?, introspectionParams: kotlin.String?, requiredRootField: kotlin.String?, enableMFA: kotlin.Boolean?, sizeMFA: kotlin.Int?, shelfLifeMFA: kotlin.Int?, oauthTokenURL: kotlin.String?, oauthPrivateKey: java.io.File?, oauthPublicKey: java.io.File?, oauthClientId: kotlin.String?, oauthSecretKey: kotlin.String?, body: kotlin.String?) : ApiResponse<ThirdPartyNetworkResponse?> {
        val localVariableConfig = updateNetworkRequestConfig(accountId = accountId, networkUID = networkUID, name = name, description = description, enableIntrospection = enableIntrospection, introspectionMethod = introspectionMethod, introspectionURL = introspectionURL, introspectionParams = introspectionParams, requiredRootField = requiredRootField, enableMFA = enableMFA, sizeMFA = sizeMFA, shelfLifeMFA = shelfLifeMFA, oauthTokenURL = oauthTokenURL, oauthPrivateKey = oauthPrivateKey, oauthPublicKey = oauthPublicKey, oauthClientId = oauthClientId, oauthSecretKey = oauthSecretKey, body = body)

        return request<kotlin.String, ThirdPartyNetworkResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateNetwork
     *
     * @param accountId The account id making the request
     * @param networkUID The unique identifier for the third party network defined by Sirqul
     * @param name The name of the network (optional)
     * @param description The description of the network (optional)
     * @param enableIntrospection Whether the network uses introspection calls (optional)
     * @param introspectionMethod HTTP method to use for introspection calls (e.g., GET, POST) (optional)
     * @param introspectionURL The HTTP URL of the introspection call (optional)
     * @param introspectionParams The parameters of the introspection call (optional)
     * @param requiredRootField Required response params (optional)
     * @param enableMFA Whether this network uses MFA (optional)
     * @param sizeMFA Size of the MFA token (optional)
     * @param shelfLifeMFA Shelf life (seconds) of the MFA token (optional)
     * @param oauthTokenURL OAuth token endpoint URL (optional)
     * @param oauthPrivateKey OAuth private key file (multipart) (optional)
     * @param oauthPublicKey OAuth public key file (multipart) (optional)
     * @param oauthClientId OAuth client id (optional)
     * @param oauthSecretKey OAuth secret key (optional)
     * @param body  (optional)
     * @return RequestConfig
     */
    fun updateNetworkRequestConfig(accountId: kotlin.Long, networkUID: kotlin.String, name: kotlin.String?, description: kotlin.String?, enableIntrospection: kotlin.Boolean?, introspectionMethod: kotlin.String?, introspectionURL: kotlin.String?, introspectionParams: kotlin.String?, requiredRootField: kotlin.String?, enableMFA: kotlin.Boolean?, sizeMFA: kotlin.Int?, shelfLifeMFA: kotlin.Int?, oauthTokenURL: kotlin.String?, oauthPrivateKey: java.io.File?, oauthPublicKey: java.io.File?, oauthClientId: kotlin.String?, oauthSecretKey: kotlin.String?, body: kotlin.String?) : RequestConfig<kotlin.String> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("networkUID", listOf(networkUID.toString()))
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (description != null) {
                    put("description", listOf(description.toString()))
                }
                if (enableIntrospection != null) {
                    put("enableIntrospection", listOf(enableIntrospection.toString()))
                }
                if (introspectionMethod != null) {
                    put("introspectionMethod", listOf(introspectionMethod.toString()))
                }
                if (introspectionURL != null) {
                    put("introspectionURL", listOf(introspectionURL.toString()))
                }
                if (introspectionParams != null) {
                    put("introspectionParams", listOf(introspectionParams.toString()))
                }
                if (requiredRootField != null) {
                    put("requiredRootField", listOf(requiredRootField.toString()))
                }
                if (enableMFA != null) {
                    put("enableMFA", listOf(enableMFA.toString()))
                }
                if (sizeMFA != null) {
                    put("sizeMFA", listOf(sizeMFA.toString()))
                }
                if (shelfLifeMFA != null) {
                    put("shelfLifeMFA", listOf(shelfLifeMFA.toString()))
                }
                if (oauthTokenURL != null) {
                    put("oauthTokenURL", listOf(oauthTokenURL.toString()))
                }
                if (oauthPrivateKey != null) {
                    put("oauthPrivateKey", listOf(oauthPrivateKey.toString()))
                }
                if (oauthPublicKey != null) {
                    put("oauthPublicKey", listOf(oauthPublicKey.toString()))
                }
                if (oauthClientId != null) {
                    put("oauthClientId", listOf(oauthClientId.toString()))
                }
                if (oauthSecretKey != null) {
                    put("oauthSecretKey", listOf(oauthSecretKey.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/thirdparty/network/update",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
