/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import org.openapitools.client.models.SirqulResponse
import org.openapitools.client.models.TriggerResponse

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

open class TriggerApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://dev.sirqul.com/api/3.18")
        }
    }

    /**
     * enum for parameter visibility
     */
     enum class VisibilityCreateTrigger(val value: kotlin.String) {
         @Json(name = "PUBLIC") PUBLIC("PUBLIC"),
         @Json(name = "PRIVATE") PRIVATE("PRIVATE"),
         @Json(name = "FRIENDS") FRIENDS("FRIENDS");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * POST /trigger/create
     * Create Trigger
     * Create a trigger
     * @param accountId The logged in user
     * @param name The name of the trigger
     * @param appKey The application to target (optional)
     * @param groupingId Client defined identifier for grouping triggers (optional)
     * @param endpointURL The URL for making an HTTP call (optional)
     * @param payload The parameters for making an HTTP call (optional)
     * @param scheduledDate The date and time of the next trigger (optional)
     * @param startDate The starting date of the trigger (optional)
     * @param endDate The ending date of the trigger (optional)
     * @param cronExpression The cron expression that represents the trigger&#39;s schedule (optional)
     * @param conditionalInput Json input representing conditional logic that has to be met before running the trigger (optional)
     * @param visibility The determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited) (optional)
     * @param active Sets whether the Trigger is active or not (inactive Triggers are not processed) (optional, default to true)
     * @return TriggerResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createTrigger(accountId: kotlin.Long, name: kotlin.String, appKey: kotlin.String? = null, groupingId: kotlin.String? = null, endpointURL: kotlin.String? = null, payload: kotlin.String? = null, scheduledDate: kotlin.Long? = null, startDate: kotlin.Long? = null, endDate: kotlin.Long? = null, cronExpression: kotlin.String? = null, conditionalInput: kotlin.String? = null, visibility: VisibilityCreateTrigger? = null, active: kotlin.Boolean? = true) : TriggerResponse {
        val localVarResponse = createTriggerWithHttpInfo(accountId = accountId, name = name, appKey = appKey, groupingId = groupingId, endpointURL = endpointURL, payload = payload, scheduledDate = scheduledDate, startDate = startDate, endDate = endDate, cronExpression = cronExpression, conditionalInput = conditionalInput, visibility = visibility, active = active)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TriggerResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /trigger/create
     * Create Trigger
     * Create a trigger
     * @param accountId The logged in user
     * @param name The name of the trigger
     * @param appKey The application to target (optional)
     * @param groupingId Client defined identifier for grouping triggers (optional)
     * @param endpointURL The URL for making an HTTP call (optional)
     * @param payload The parameters for making an HTTP call (optional)
     * @param scheduledDate The date and time of the next trigger (optional)
     * @param startDate The starting date of the trigger (optional)
     * @param endDate The ending date of the trigger (optional)
     * @param cronExpression The cron expression that represents the trigger&#39;s schedule (optional)
     * @param conditionalInput Json input representing conditional logic that has to be met before running the trigger (optional)
     * @param visibility The determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited) (optional)
     * @param active Sets whether the Trigger is active or not (inactive Triggers are not processed) (optional, default to true)
     * @return ApiResponse<TriggerResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createTriggerWithHttpInfo(accountId: kotlin.Long, name: kotlin.String, appKey: kotlin.String?, groupingId: kotlin.String?, endpointURL: kotlin.String?, payload: kotlin.String?, scheduledDate: kotlin.Long?, startDate: kotlin.Long?, endDate: kotlin.Long?, cronExpression: kotlin.String?, conditionalInput: kotlin.String?, visibility: VisibilityCreateTrigger?, active: kotlin.Boolean?) : ApiResponse<TriggerResponse?> {
        val localVariableConfig = createTriggerRequestConfig(accountId = accountId, name = name, appKey = appKey, groupingId = groupingId, endpointURL = endpointURL, payload = payload, scheduledDate = scheduledDate, startDate = startDate, endDate = endDate, cronExpression = cronExpression, conditionalInput = conditionalInput, visibility = visibility, active = active)

        return request<Unit, TriggerResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createTrigger
     *
     * @param accountId The logged in user
     * @param name The name of the trigger
     * @param appKey The application to target (optional)
     * @param groupingId Client defined identifier for grouping triggers (optional)
     * @param endpointURL The URL for making an HTTP call (optional)
     * @param payload The parameters for making an HTTP call (optional)
     * @param scheduledDate The date and time of the next trigger (optional)
     * @param startDate The starting date of the trigger (optional)
     * @param endDate The ending date of the trigger (optional)
     * @param cronExpression The cron expression that represents the trigger&#39;s schedule (optional)
     * @param conditionalInput Json input representing conditional logic that has to be met before running the trigger (optional)
     * @param visibility The determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited) (optional)
     * @param active Sets whether the Trigger is active or not (inactive Triggers are not processed) (optional, default to true)
     * @return RequestConfig
     */
    fun createTriggerRequestConfig(accountId: kotlin.Long, name: kotlin.String, appKey: kotlin.String?, groupingId: kotlin.String?, endpointURL: kotlin.String?, payload: kotlin.String?, scheduledDate: kotlin.Long?, startDate: kotlin.Long?, endDate: kotlin.Long?, cronExpression: kotlin.String?, conditionalInput: kotlin.String?, visibility: VisibilityCreateTrigger?, active: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("name", listOf(name.toString()))
                if (appKey != null) {
                    put("appKey", listOf(appKey.toString()))
                }
                if (groupingId != null) {
                    put("groupingId", listOf(groupingId.toString()))
                }
                if (endpointURL != null) {
                    put("endpointURL", listOf(endpointURL.toString()))
                }
                if (payload != null) {
                    put("payload", listOf(payload.toString()))
                }
                if (scheduledDate != null) {
                    put("scheduledDate", listOf(scheduledDate.toString()))
                }
                if (startDate != null) {
                    put("startDate", listOf(startDate.toString()))
                }
                if (endDate != null) {
                    put("endDate", listOf(endDate.toString()))
                }
                if (cronExpression != null) {
                    put("cronExpression", listOf(cronExpression.toString()))
                }
                if (conditionalInput != null) {
                    put("conditionalInput", listOf(conditionalInput.toString()))
                }
                if (visibility != null) {
                    put("visibility", listOf(visibility.value))
                }
                if (active != null) {
                    put("active", listOf(active.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/trigger/create",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /trigger/delete
     * Delete Trigger
     * Mark a trigger as deleted.
     * @param accountId The logged in user.
     * @param triggerId The id of the trigger to delete.
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteTrigger(accountId: kotlin.Long, triggerId: kotlin.Long) : SirqulResponse {
        val localVarResponse = deleteTriggerWithHttpInfo(accountId = accountId, triggerId = triggerId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /trigger/delete
     * Delete Trigger
     * Mark a trigger as deleted.
     * @param accountId The logged in user.
     * @param triggerId The id of the trigger to delete.
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteTriggerWithHttpInfo(accountId: kotlin.Long, triggerId: kotlin.Long) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = deleteTriggerRequestConfig(accountId = accountId, triggerId = triggerId)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteTrigger
     *
     * @param accountId The logged in user.
     * @param triggerId The id of the trigger to delete.
     * @return RequestConfig
     */
    fun deleteTriggerRequestConfig(accountId: kotlin.Long, triggerId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("triggerId", listOf(triggerId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/trigger/delete",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /trigger/get
     * Get Trigger
     * Get a trigger
     * @param accountId The logged in user.
     * @param triggerId The id of the Trigger to return.
     * @return TriggerResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getTrigger(accountId: kotlin.Long, triggerId: kotlin.Long) : TriggerResponse {
        val localVarResponse = getTriggerWithHttpInfo(accountId = accountId, triggerId = triggerId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TriggerResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /trigger/get
     * Get Trigger
     * Get a trigger
     * @param accountId The logged in user.
     * @param triggerId The id of the Trigger to return.
     * @return ApiResponse<TriggerResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getTriggerWithHttpInfo(accountId: kotlin.Long, triggerId: kotlin.Long) : ApiResponse<TriggerResponse?> {
        val localVariableConfig = getTriggerRequestConfig(accountId = accountId, triggerId = triggerId)

        return request<Unit, TriggerResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getTrigger
     *
     * @param accountId The logged in user.
     * @param triggerId The id of the Trigger to return.
     * @return RequestConfig
     */
    fun getTriggerRequestConfig(accountId: kotlin.Long, triggerId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("triggerId", listOf(triggerId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/trigger/get",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /trigger/search
     * Search Triggers
     * Search for triggers
     * @param accountId The logged in user.
     * @param groupingId Filter results by a grouping identifier defined by the client (optional)
     * @param filter A comma separated list of filters. * MINE - Return triggers that the user has created * SHARED - Return triggers that have been shared to the user * FOLLOWER - Return triggers that have been created by the user&#39;&#39;s followers (the content needs to have been APPROVED or FEATURED) * FOLLOWING - Return triggers that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED) * PUBLIC - Return all PUBLIC triggers that have been APPROVED or FEATURED * ALL_PUBLIC - Return all PUBLIC triggers regardless of whether they are approved or not (ignores the approval status) * LIKED - Return all triggers that the user has liked * FEATURED - Return all triggers that have been featured * PENDING - Return all pending triggers  (optional, default to "MINE")
     * @param statuses Filter results by status (comma separated list). Values include: NEW, ERROR, COMPLETE, PROCESSING, TEMPLATE (optional, default to "NEW,ERROR,COMPLETE,PROCESSING")
     * @param templateTypes Template Types (optional)
     * @param appKey Filter the list by a specific application (optional)
     * @param keyword Keyword search on the trigger names. (optional)
     * @param sortField The field to sort by. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, SCHEDULED_DATE, START_DATE, END_DATE (optional, default to "CREATED")
     * @param descending Determines whether the sorted list is in descending or ascending order (optional, default to true)
     * @param start Start the result set at some index. (optional, default to 0)
     * @param limit Limit the result to some number. (optional, default to 20)
     * @param activeOnly Determines whether to return only active results (optional, default to true)
     * @return kotlin.collections.List<TriggerResponse>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun searchTriggers(accountId: kotlin.Long, groupingId: kotlin.String? = null, filter: kotlin.String? = "MINE", statuses: kotlin.String? = "NEW,ERROR,COMPLETE,PROCESSING", templateTypes: kotlin.String? = null, appKey: kotlin.String? = null, keyword: kotlin.String? = null, sortField: kotlin.String? = "CREATED", descending: kotlin.Boolean? = true, start: kotlin.Int? = 0, limit: kotlin.Int? = 20, activeOnly: kotlin.Boolean? = true) : kotlin.collections.List<TriggerResponse> {
        val localVarResponse = searchTriggersWithHttpInfo(accountId = accountId, groupingId = groupingId, filter = filter, statuses = statuses, templateTypes = templateTypes, appKey = appKey, keyword = keyword, sortField = sortField, descending = descending, start = start, limit = limit, activeOnly = activeOnly)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<TriggerResponse>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /trigger/search
     * Search Triggers
     * Search for triggers
     * @param accountId The logged in user.
     * @param groupingId Filter results by a grouping identifier defined by the client (optional)
     * @param filter A comma separated list of filters. * MINE - Return triggers that the user has created * SHARED - Return triggers that have been shared to the user * FOLLOWER - Return triggers that have been created by the user&#39;&#39;s followers (the content needs to have been APPROVED or FEATURED) * FOLLOWING - Return triggers that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED) * PUBLIC - Return all PUBLIC triggers that have been APPROVED or FEATURED * ALL_PUBLIC - Return all PUBLIC triggers regardless of whether they are approved or not (ignores the approval status) * LIKED - Return all triggers that the user has liked * FEATURED - Return all triggers that have been featured * PENDING - Return all pending triggers  (optional, default to "MINE")
     * @param statuses Filter results by status (comma separated list). Values include: NEW, ERROR, COMPLETE, PROCESSING, TEMPLATE (optional, default to "NEW,ERROR,COMPLETE,PROCESSING")
     * @param templateTypes Template Types (optional)
     * @param appKey Filter the list by a specific application (optional)
     * @param keyword Keyword search on the trigger names. (optional)
     * @param sortField The field to sort by. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, SCHEDULED_DATE, START_DATE, END_DATE (optional, default to "CREATED")
     * @param descending Determines whether the sorted list is in descending or ascending order (optional, default to true)
     * @param start Start the result set at some index. (optional, default to 0)
     * @param limit Limit the result to some number. (optional, default to 20)
     * @param activeOnly Determines whether to return only active results (optional, default to true)
     * @return ApiResponse<kotlin.collections.List<TriggerResponse>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun searchTriggersWithHttpInfo(accountId: kotlin.Long, groupingId: kotlin.String?, filter: kotlin.String?, statuses: kotlin.String?, templateTypes: kotlin.String?, appKey: kotlin.String?, keyword: kotlin.String?, sortField: kotlin.String?, descending: kotlin.Boolean?, start: kotlin.Int?, limit: kotlin.Int?, activeOnly: kotlin.Boolean?) : ApiResponse<kotlin.collections.List<TriggerResponse>?> {
        val localVariableConfig = searchTriggersRequestConfig(accountId = accountId, groupingId = groupingId, filter = filter, statuses = statuses, templateTypes = templateTypes, appKey = appKey, keyword = keyword, sortField = sortField, descending = descending, start = start, limit = limit, activeOnly = activeOnly)

        return request<Unit, kotlin.collections.List<TriggerResponse>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation searchTriggers
     *
     * @param accountId The logged in user.
     * @param groupingId Filter results by a grouping identifier defined by the client (optional)
     * @param filter A comma separated list of filters. * MINE - Return triggers that the user has created * SHARED - Return triggers that have been shared to the user * FOLLOWER - Return triggers that have been created by the user&#39;&#39;s followers (the content needs to have been APPROVED or FEATURED) * FOLLOWING - Return triggers that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED) * PUBLIC - Return all PUBLIC triggers that have been APPROVED or FEATURED * ALL_PUBLIC - Return all PUBLIC triggers regardless of whether they are approved or not (ignores the approval status) * LIKED - Return all triggers that the user has liked * FEATURED - Return all triggers that have been featured * PENDING - Return all pending triggers  (optional, default to "MINE")
     * @param statuses Filter results by status (comma separated list). Values include: NEW, ERROR, COMPLETE, PROCESSING, TEMPLATE (optional, default to "NEW,ERROR,COMPLETE,PROCESSING")
     * @param templateTypes Template Types (optional)
     * @param appKey Filter the list by a specific application (optional)
     * @param keyword Keyword search on the trigger names. (optional)
     * @param sortField The field to sort by. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, SCHEDULED_DATE, START_DATE, END_DATE (optional, default to "CREATED")
     * @param descending Determines whether the sorted list is in descending or ascending order (optional, default to true)
     * @param start Start the result set at some index. (optional, default to 0)
     * @param limit Limit the result to some number. (optional, default to 20)
     * @param activeOnly Determines whether to return only active results (optional, default to true)
     * @return RequestConfig
     */
    fun searchTriggersRequestConfig(accountId: kotlin.Long, groupingId: kotlin.String?, filter: kotlin.String?, statuses: kotlin.String?, templateTypes: kotlin.String?, appKey: kotlin.String?, keyword: kotlin.String?, sortField: kotlin.String?, descending: kotlin.Boolean?, start: kotlin.Int?, limit: kotlin.Int?, activeOnly: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                if (groupingId != null) {
                    put("groupingId", listOf(groupingId.toString()))
                }
                if (filter != null) {
                    put("filter", listOf(filter.toString()))
                }
                if (statuses != null) {
                    put("statuses", listOf(statuses.toString()))
                }
                if (templateTypes != null) {
                    put("templateTypes", listOf(templateTypes.toString()))
                }
                if (appKey != null) {
                    put("appKey", listOf(appKey.toString()))
                }
                if (keyword != null) {
                    put("keyword", listOf(keyword.toString()))
                }
                if (sortField != null) {
                    put("sortField", listOf(sortField.toString()))
                }
                if (descending != null) {
                    put("descending", listOf(descending.toString()))
                }
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (activeOnly != null) {
                    put("activeOnly", listOf(activeOnly.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/trigger/search",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter visibility
     */
     enum class VisibilityUpdateTrigger(val value: kotlin.String) {
         @Json(name = "PUBLIC") PUBLIC("PUBLIC"),
         @Json(name = "PRIVATE") PRIVATE("PRIVATE"),
         @Json(name = "FRIENDS") FRIENDS("FRIENDS");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * POST /trigger/update
     * Update Trigger
     * Update a trigger
     * @param triggerId The trigger to update
     * @param accountId The logged in user
     * @param name The name of the trigger (optional)
     * @param appKey The application to target (optional)
     * @param groupingId Client defined identifier for grouping triggers (optional)
     * @param endpointURL The URL for making an HTTP call (optional)
     * @param payload The parameters for making an HTTP call (optional)
     * @param scheduledDate The date and time of the next trigger (optional)
     * @param startDate The starting date of the trigger (optional)
     * @param endDate The ending date of the trigger (optional)
     * @param cronExpression The cron expression that represents the trigger&#39;s schedule (optional)
     * @param conditionalInput Json input representing conditional logic that has to be met before running the trigger (optional)
     * @param visibility The determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited) (optional)
     * @param active Sets whether the Trigger is active or not (inactive Triggers are not processed) (optional)
     * @return TriggerResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updateTrigger(triggerId: kotlin.Long, accountId: kotlin.Long, name: kotlin.String? = null, appKey: kotlin.String? = null, groupingId: kotlin.String? = null, endpointURL: kotlin.String? = null, payload: kotlin.String? = null, scheduledDate: kotlin.Long? = null, startDate: kotlin.Long? = null, endDate: kotlin.Long? = null, cronExpression: kotlin.String? = null, conditionalInput: kotlin.String? = null, visibility: VisibilityUpdateTrigger? = null, active: kotlin.Boolean? = null) : TriggerResponse {
        val localVarResponse = updateTriggerWithHttpInfo(triggerId = triggerId, accountId = accountId, name = name, appKey = appKey, groupingId = groupingId, endpointURL = endpointURL, payload = payload, scheduledDate = scheduledDate, startDate = startDate, endDate = endDate, cronExpression = cronExpression, conditionalInput = conditionalInput, visibility = visibility, active = active)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TriggerResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /trigger/update
     * Update Trigger
     * Update a trigger
     * @param triggerId The trigger to update
     * @param accountId The logged in user
     * @param name The name of the trigger (optional)
     * @param appKey The application to target (optional)
     * @param groupingId Client defined identifier for grouping triggers (optional)
     * @param endpointURL The URL for making an HTTP call (optional)
     * @param payload The parameters for making an HTTP call (optional)
     * @param scheduledDate The date and time of the next trigger (optional)
     * @param startDate The starting date of the trigger (optional)
     * @param endDate The ending date of the trigger (optional)
     * @param cronExpression The cron expression that represents the trigger&#39;s schedule (optional)
     * @param conditionalInput Json input representing conditional logic that has to be met before running the trigger (optional)
     * @param visibility The determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited) (optional)
     * @param active Sets whether the Trigger is active or not (inactive Triggers are not processed) (optional)
     * @return ApiResponse<TriggerResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun updateTriggerWithHttpInfo(triggerId: kotlin.Long, accountId: kotlin.Long, name: kotlin.String?, appKey: kotlin.String?, groupingId: kotlin.String?, endpointURL: kotlin.String?, payload: kotlin.String?, scheduledDate: kotlin.Long?, startDate: kotlin.Long?, endDate: kotlin.Long?, cronExpression: kotlin.String?, conditionalInput: kotlin.String?, visibility: VisibilityUpdateTrigger?, active: kotlin.Boolean?) : ApiResponse<TriggerResponse?> {
        val localVariableConfig = updateTriggerRequestConfig(triggerId = triggerId, accountId = accountId, name = name, appKey = appKey, groupingId = groupingId, endpointURL = endpointURL, payload = payload, scheduledDate = scheduledDate, startDate = startDate, endDate = endDate, cronExpression = cronExpression, conditionalInput = conditionalInput, visibility = visibility, active = active)

        return request<Unit, TriggerResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateTrigger
     *
     * @param triggerId The trigger to update
     * @param accountId The logged in user
     * @param name The name of the trigger (optional)
     * @param appKey The application to target (optional)
     * @param groupingId Client defined identifier for grouping triggers (optional)
     * @param endpointURL The URL for making an HTTP call (optional)
     * @param payload The parameters for making an HTTP call (optional)
     * @param scheduledDate The date and time of the next trigger (optional)
     * @param startDate The starting date of the trigger (optional)
     * @param endDate The ending date of the trigger (optional)
     * @param cronExpression The cron expression that represents the trigger&#39;s schedule (optional)
     * @param conditionalInput Json input representing conditional logic that has to be met before running the trigger (optional)
     * @param visibility The determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited) (optional)
     * @param active Sets whether the Trigger is active or not (inactive Triggers are not processed) (optional)
     * @return RequestConfig
     */
    fun updateTriggerRequestConfig(triggerId: kotlin.Long, accountId: kotlin.Long, name: kotlin.String?, appKey: kotlin.String?, groupingId: kotlin.String?, endpointURL: kotlin.String?, payload: kotlin.String?, scheduledDate: kotlin.Long?, startDate: kotlin.Long?, endDate: kotlin.Long?, cronExpression: kotlin.String?, conditionalInput: kotlin.String?, visibility: VisibilityUpdateTrigger?, active: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("triggerId", listOf(triggerId.toString()))
                put("accountId", listOf(accountId.toString()))
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (appKey != null) {
                    put("appKey", listOf(appKey.toString()))
                }
                if (groupingId != null) {
                    put("groupingId", listOf(groupingId.toString()))
                }
                if (endpointURL != null) {
                    put("endpointURL", listOf(endpointURL.toString()))
                }
                if (payload != null) {
                    put("payload", listOf(payload.toString()))
                }
                if (scheduledDate != null) {
                    put("scheduledDate", listOf(scheduledDate.toString()))
                }
                if (startDate != null) {
                    put("startDate", listOf(startDate.toString()))
                }
                if (endDate != null) {
                    put("endDate", listOf(endDate.toString()))
                }
                if (cronExpression != null) {
                    put("cronExpression", listOf(cronExpression.toString()))
                }
                if (conditionalInput != null) {
                    put("conditionalInput", listOf(conditionalInput.toString()))
                }
                if (visibility != null) {
                    put("visibility", listOf(visibility.value))
                }
                if (active != null) {
                    put("active", listOf(active.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/trigger/update",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
