/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import org.openapitools.client.models.EmployeeResponse
import org.openapitools.client.models.SirqulResponse

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

open class EmployeeApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://dev.sirqul.com/api/3.18")
        }
    }

    /**
     * POST /employee/assign
     * Assign Employee
     * Assign An existing account to be an employee
     * @param accountId The account id of the logged in user
     * @param managerAccountId The account id of the manager to assign under
     * @param employeeAccountId The account id of the user to be assigned as employee
     * @param role The role to assign to the employee (e.g. RETAILER or RETAILER_LIMITED) (optional)
     * @return EmployeeResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun assignEmployee(accountId: kotlin.Long, managerAccountId: kotlin.Long, employeeAccountId: kotlin.Long, role: kotlin.String? = null) : EmployeeResponse {
        val localVarResponse = assignEmployeeWithHttpInfo(accountId = accountId, managerAccountId = managerAccountId, employeeAccountId = employeeAccountId, role = role)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EmployeeResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /employee/assign
     * Assign Employee
     * Assign An existing account to be an employee
     * @param accountId The account id of the logged in user
     * @param managerAccountId The account id of the manager to assign under
     * @param employeeAccountId The account id of the user to be assigned as employee
     * @param role The role to assign to the employee (e.g. RETAILER or RETAILER_LIMITED) (optional)
     * @return ApiResponse<EmployeeResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun assignEmployeeWithHttpInfo(accountId: kotlin.Long, managerAccountId: kotlin.Long, employeeAccountId: kotlin.Long, role: kotlin.String?) : ApiResponse<EmployeeResponse?> {
        val localVariableConfig = assignEmployeeRequestConfig(accountId = accountId, managerAccountId = managerAccountId, employeeAccountId = employeeAccountId, role = role)

        return request<Unit, EmployeeResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation assignEmployee
     *
     * @param accountId The account id of the logged in user
     * @param managerAccountId The account id of the manager to assign under
     * @param employeeAccountId The account id of the user to be assigned as employee
     * @param role The role to assign to the employee (e.g. RETAILER or RETAILER_LIMITED) (optional)
     * @return RequestConfig
     */
    fun assignEmployeeRequestConfig(accountId: kotlin.Long, managerAccountId: kotlin.Long, employeeAccountId: kotlin.Long, role: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("managerAccountId", listOf(managerAccountId.toString()))
                put("employeeAccountId", listOf(employeeAccountId.toString()))
                if (role != null) {
                    put("role", listOf(role.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/employee/assign",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /employee/assignToLocation
     * Assign Employee to Location
     * Assign or unassign the account to a retailer location.
     * @param accountId The account id of the logged in user
     * @param retailerLocationId The retailer location to apply the change to
     * @param employeeAccountId The account id of the user to apply the change to (optional)
     * @param assign If true (default) assign to the location, otherwise remove from the retailer (optional, default to true)
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun assignToLocationEmployee(accountId: kotlin.Long, retailerLocationId: kotlin.Long, employeeAccountId: kotlin.Long? = null, assign: kotlin.Boolean? = true) : SirqulResponse {
        val localVarResponse = assignToLocationEmployeeWithHttpInfo(accountId = accountId, retailerLocationId = retailerLocationId, employeeAccountId = employeeAccountId, assign = assign)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /employee/assignToLocation
     * Assign Employee to Location
     * Assign or unassign the account to a retailer location.
     * @param accountId The account id of the logged in user
     * @param retailerLocationId The retailer location to apply the change to
     * @param employeeAccountId The account id of the user to apply the change to (optional)
     * @param assign If true (default) assign to the location, otherwise remove from the retailer (optional, default to true)
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun assignToLocationEmployeeWithHttpInfo(accountId: kotlin.Long, retailerLocationId: kotlin.Long, employeeAccountId: kotlin.Long?, assign: kotlin.Boolean?) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = assignToLocationEmployeeRequestConfig(accountId = accountId, retailerLocationId = retailerLocationId, employeeAccountId = employeeAccountId, assign = assign)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation assignToLocationEmployee
     *
     * @param accountId The account id of the logged in user
     * @param retailerLocationId The retailer location to apply the change to
     * @param employeeAccountId The account id of the user to apply the change to (optional)
     * @param assign If true (default) assign to the location, otherwise remove from the retailer (optional, default to true)
     * @return RequestConfig
     */
    fun assignToLocationEmployeeRequestConfig(accountId: kotlin.Long, retailerLocationId: kotlin.Long, employeeAccountId: kotlin.Long?, assign: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                if (employeeAccountId != null) {
                    put("employeeAccountId", listOf(employeeAccountId.toString()))
                }
                put("retailerLocationId", listOf(retailerLocationId.toString()))
                if (assign != null) {
                    put("assign", listOf(assign.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/employee/assignToLocation",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter gender
     */
     enum class GenderCreateEmployee(val value: kotlin.String) {
         @Json(name = "MALE") MALE("MALE"),
         @Json(name = "FEMALE") FEMALE("FEMALE"),
         @Json(name = "ANY") ANY("ANY");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * POST /employee/create
     * Create Employee
     * Create a new account record with the provided information.
     * @param accountId The account id of the logged in user
     * @param managerAccountId The account id of the manager to assign under
     * @param username The username/email for the new user. This must be unique across the entire the system.
     * @param password The password for the new user
     * @param name a name field (optional)
     * @param prefixName The name prefix; Mr, Mrs, etc (optional)
     * @param firstName The first name (optional)
     * @param middleName The middle name (optional)
     * @param lastName The last name (optional)
     * @param suffixName The name suffix; Jr, Sr, III, etc (optional)
     * @param title The title of the user (optional)
     * @param aboutUs Additional about/biography text (optional)
     * @param assetId the asset id to set the user&#39;s profile image (optional)
     * @param gender The gender (optional)
     * @param homePhone The home phone number (optional)
     * @param cellPhone The cellular phone number (optional)
     * @param cellPhoneCarrier The cellular service provider. This is required for sending SMS. Leave this empty if the provider is not on the list of supported carriers. (optional)
     * @param businessPhone The business phone number (optional)
     * @param emailAddress The user&#39;s contact email address (NOT the username) (optional)
     * @param streetAddress The street address of the user&#39;s contact location (optional)
     * @param streetAddress2 Additional address information (such as a suite number, floor number, building name, or PO Box) (optional)
     * @param city The city of the user&#39;s contact location (optional)
     * @param state The state of the user&#39;s contact location (optional)
     * @param zipcode The zipcode of the user&#39;s contact location (optional)
     * @param country The country of the user&#39;s contact location (optional)
     * @param role The role; RETAILER or RETAILER_LIMITED, defaulted to RETAILER_LIMITED (optional)
     * @param retailerLocationIds the retailer location IDs the employee is associated with (optional)
     * @param settingsAppKey Determines whether to return the application settings for the employee for a particular application (optional)
     * @param appBlob external custom client defined data (per Application) (optional)
     * @param assignedDeviceId The device id to assign to the user (used for IPS beacon tracking) (optional)
     * @return EmployeeResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createEmployee(accountId: kotlin.Long, managerAccountId: kotlin.Long, username: kotlin.String, password: kotlin.String, name: kotlin.String? = null, prefixName: kotlin.String? = null, firstName: kotlin.String? = null, middleName: kotlin.String? = null, lastName: kotlin.String? = null, suffixName: kotlin.String? = null, title: kotlin.String? = null, aboutUs: kotlin.String? = null, assetId: kotlin.Long? = null, gender: GenderCreateEmployee? = null, homePhone: kotlin.String? = null, cellPhone: kotlin.String? = null, cellPhoneCarrier: kotlin.String? = null, businessPhone: kotlin.String? = null, emailAddress: kotlin.String? = null, streetAddress: kotlin.String? = null, streetAddress2: kotlin.String? = null, city: kotlin.String? = null, state: kotlin.String? = null, zipcode: kotlin.String? = null, country: kotlin.String? = null, role: kotlin.String? = null, retailerLocationIds: kotlin.String? = null, settingsAppKey: kotlin.String? = null, appBlob: kotlin.String? = null, assignedDeviceId: kotlin.String? = null) : EmployeeResponse {
        val localVarResponse = createEmployeeWithHttpInfo(accountId = accountId, managerAccountId = managerAccountId, username = username, password = password, name = name, prefixName = prefixName, firstName = firstName, middleName = middleName, lastName = lastName, suffixName = suffixName, title = title, aboutUs = aboutUs, assetId = assetId, gender = gender, homePhone = homePhone, cellPhone = cellPhone, cellPhoneCarrier = cellPhoneCarrier, businessPhone = businessPhone, emailAddress = emailAddress, streetAddress = streetAddress, streetAddress2 = streetAddress2, city = city, state = state, zipcode = zipcode, country = country, role = role, retailerLocationIds = retailerLocationIds, settingsAppKey = settingsAppKey, appBlob = appBlob, assignedDeviceId = assignedDeviceId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EmployeeResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /employee/create
     * Create Employee
     * Create a new account record with the provided information.
     * @param accountId The account id of the logged in user
     * @param managerAccountId The account id of the manager to assign under
     * @param username The username/email for the new user. This must be unique across the entire the system.
     * @param password The password for the new user
     * @param name a name field (optional)
     * @param prefixName The name prefix; Mr, Mrs, etc (optional)
     * @param firstName The first name (optional)
     * @param middleName The middle name (optional)
     * @param lastName The last name (optional)
     * @param suffixName The name suffix; Jr, Sr, III, etc (optional)
     * @param title The title of the user (optional)
     * @param aboutUs Additional about/biography text (optional)
     * @param assetId the asset id to set the user&#39;s profile image (optional)
     * @param gender The gender (optional)
     * @param homePhone The home phone number (optional)
     * @param cellPhone The cellular phone number (optional)
     * @param cellPhoneCarrier The cellular service provider. This is required for sending SMS. Leave this empty if the provider is not on the list of supported carriers. (optional)
     * @param businessPhone The business phone number (optional)
     * @param emailAddress The user&#39;s contact email address (NOT the username) (optional)
     * @param streetAddress The street address of the user&#39;s contact location (optional)
     * @param streetAddress2 Additional address information (such as a suite number, floor number, building name, or PO Box) (optional)
     * @param city The city of the user&#39;s contact location (optional)
     * @param state The state of the user&#39;s contact location (optional)
     * @param zipcode The zipcode of the user&#39;s contact location (optional)
     * @param country The country of the user&#39;s contact location (optional)
     * @param role The role; RETAILER or RETAILER_LIMITED, defaulted to RETAILER_LIMITED (optional)
     * @param retailerLocationIds the retailer location IDs the employee is associated with (optional)
     * @param settingsAppKey Determines whether to return the application settings for the employee for a particular application (optional)
     * @param appBlob external custom client defined data (per Application) (optional)
     * @param assignedDeviceId The device id to assign to the user (used for IPS beacon tracking) (optional)
     * @return ApiResponse<EmployeeResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createEmployeeWithHttpInfo(accountId: kotlin.Long, managerAccountId: kotlin.Long, username: kotlin.String, password: kotlin.String, name: kotlin.String?, prefixName: kotlin.String?, firstName: kotlin.String?, middleName: kotlin.String?, lastName: kotlin.String?, suffixName: kotlin.String?, title: kotlin.String?, aboutUs: kotlin.String?, assetId: kotlin.Long?, gender: GenderCreateEmployee?, homePhone: kotlin.String?, cellPhone: kotlin.String?, cellPhoneCarrier: kotlin.String?, businessPhone: kotlin.String?, emailAddress: kotlin.String?, streetAddress: kotlin.String?, streetAddress2: kotlin.String?, city: kotlin.String?, state: kotlin.String?, zipcode: kotlin.String?, country: kotlin.String?, role: kotlin.String?, retailerLocationIds: kotlin.String?, settingsAppKey: kotlin.String?, appBlob: kotlin.String?, assignedDeviceId: kotlin.String?) : ApiResponse<EmployeeResponse?> {
        val localVariableConfig = createEmployeeRequestConfig(accountId = accountId, managerAccountId = managerAccountId, username = username, password = password, name = name, prefixName = prefixName, firstName = firstName, middleName = middleName, lastName = lastName, suffixName = suffixName, title = title, aboutUs = aboutUs, assetId = assetId, gender = gender, homePhone = homePhone, cellPhone = cellPhone, cellPhoneCarrier = cellPhoneCarrier, businessPhone = businessPhone, emailAddress = emailAddress, streetAddress = streetAddress, streetAddress2 = streetAddress2, city = city, state = state, zipcode = zipcode, country = country, role = role, retailerLocationIds = retailerLocationIds, settingsAppKey = settingsAppKey, appBlob = appBlob, assignedDeviceId = assignedDeviceId)

        return request<Unit, EmployeeResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createEmployee
     *
     * @param accountId The account id of the logged in user
     * @param managerAccountId The account id of the manager to assign under
     * @param username The username/email for the new user. This must be unique across the entire the system.
     * @param password The password for the new user
     * @param name a name field (optional)
     * @param prefixName The name prefix; Mr, Mrs, etc (optional)
     * @param firstName The first name (optional)
     * @param middleName The middle name (optional)
     * @param lastName The last name (optional)
     * @param suffixName The name suffix; Jr, Sr, III, etc (optional)
     * @param title The title of the user (optional)
     * @param aboutUs Additional about/biography text (optional)
     * @param assetId the asset id to set the user&#39;s profile image (optional)
     * @param gender The gender (optional)
     * @param homePhone The home phone number (optional)
     * @param cellPhone The cellular phone number (optional)
     * @param cellPhoneCarrier The cellular service provider. This is required for sending SMS. Leave this empty if the provider is not on the list of supported carriers. (optional)
     * @param businessPhone The business phone number (optional)
     * @param emailAddress The user&#39;s contact email address (NOT the username) (optional)
     * @param streetAddress The street address of the user&#39;s contact location (optional)
     * @param streetAddress2 Additional address information (such as a suite number, floor number, building name, or PO Box) (optional)
     * @param city The city of the user&#39;s contact location (optional)
     * @param state The state of the user&#39;s contact location (optional)
     * @param zipcode The zipcode of the user&#39;s contact location (optional)
     * @param country The country of the user&#39;s contact location (optional)
     * @param role The role; RETAILER or RETAILER_LIMITED, defaulted to RETAILER_LIMITED (optional)
     * @param retailerLocationIds the retailer location IDs the employee is associated with (optional)
     * @param settingsAppKey Determines whether to return the application settings for the employee for a particular application (optional)
     * @param appBlob external custom client defined data (per Application) (optional)
     * @param assignedDeviceId The device id to assign to the user (used for IPS beacon tracking) (optional)
     * @return RequestConfig
     */
    fun createEmployeeRequestConfig(accountId: kotlin.Long, managerAccountId: kotlin.Long, username: kotlin.String, password: kotlin.String, name: kotlin.String?, prefixName: kotlin.String?, firstName: kotlin.String?, middleName: kotlin.String?, lastName: kotlin.String?, suffixName: kotlin.String?, title: kotlin.String?, aboutUs: kotlin.String?, assetId: kotlin.Long?, gender: GenderCreateEmployee?, homePhone: kotlin.String?, cellPhone: kotlin.String?, cellPhoneCarrier: kotlin.String?, businessPhone: kotlin.String?, emailAddress: kotlin.String?, streetAddress: kotlin.String?, streetAddress2: kotlin.String?, city: kotlin.String?, state: kotlin.String?, zipcode: kotlin.String?, country: kotlin.String?, role: kotlin.String?, retailerLocationIds: kotlin.String?, settingsAppKey: kotlin.String?, appBlob: kotlin.String?, assignedDeviceId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("managerAccountId", listOf(managerAccountId.toString()))
                put("username", listOf(username.toString()))
                put("password", listOf(password.toString()))
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (prefixName != null) {
                    put("prefixName", listOf(prefixName.toString()))
                }
                if (firstName != null) {
                    put("firstName", listOf(firstName.toString()))
                }
                if (middleName != null) {
                    put("middleName", listOf(middleName.toString()))
                }
                if (lastName != null) {
                    put("lastName", listOf(lastName.toString()))
                }
                if (suffixName != null) {
                    put("suffixName", listOf(suffixName.toString()))
                }
                if (title != null) {
                    put("title", listOf(title.toString()))
                }
                if (aboutUs != null) {
                    put("aboutUs", listOf(aboutUs.toString()))
                }
                if (assetId != null) {
                    put("assetId", listOf(assetId.toString()))
                }
                if (gender != null) {
                    put("gender", listOf(gender.value))
                }
                if (homePhone != null) {
                    put("homePhone", listOf(homePhone.toString()))
                }
                if (cellPhone != null) {
                    put("cellPhone", listOf(cellPhone.toString()))
                }
                if (cellPhoneCarrier != null) {
                    put("cellPhoneCarrier", listOf(cellPhoneCarrier.toString()))
                }
                if (businessPhone != null) {
                    put("businessPhone", listOf(businessPhone.toString()))
                }
                if (emailAddress != null) {
                    put("emailAddress", listOf(emailAddress.toString()))
                }
                if (streetAddress != null) {
                    put("streetAddress", listOf(streetAddress.toString()))
                }
                if (streetAddress2 != null) {
                    put("streetAddress2", listOf(streetAddress2.toString()))
                }
                if (city != null) {
                    put("city", listOf(city.toString()))
                }
                if (state != null) {
                    put("state", listOf(state.toString()))
                }
                if (zipcode != null) {
                    put("zipcode", listOf(zipcode.toString()))
                }
                if (country != null) {
                    put("country", listOf(country.toString()))
                }
                if (role != null) {
                    put("role", listOf(role.toString()))
                }
                if (retailerLocationIds != null) {
                    put("retailerLocationIds", listOf(retailerLocationIds.toString()))
                }
                if (settingsAppKey != null) {
                    put("settingsAppKey", listOf(settingsAppKey.toString()))
                }
                if (appBlob != null) {
                    put("appBlob", listOf(appBlob.toString()))
                }
                if (assignedDeviceId != null) {
                    put("assignedDeviceId", listOf(assignedDeviceId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/employee/create",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /employee/delete
     * Delete Employee
     * Set the deleted date field which marks the record as deleted.
     * @param accountId the id of the logged in user
     * @param employeeAccountId the id of the employee to delete
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteEmployee(accountId: kotlin.Long, employeeAccountId: kotlin.Long) : SirqulResponse {
        val localVarResponse = deleteEmployeeWithHttpInfo(accountId = accountId, employeeAccountId = employeeAccountId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /employee/delete
     * Delete Employee
     * Set the deleted date field which marks the record as deleted.
     * @param accountId the id of the logged in user
     * @param employeeAccountId the id of the employee to delete
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteEmployeeWithHttpInfo(accountId: kotlin.Long, employeeAccountId: kotlin.Long) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = deleteEmployeeRequestConfig(accountId = accountId, employeeAccountId = employeeAccountId)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteEmployee
     *
     * @param accountId the id of the logged in user
     * @param employeeAccountId the id of the employee to delete
     * @return RequestConfig
     */
    fun deleteEmployeeRequestConfig(accountId: kotlin.Long, employeeAccountId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("employeeAccountId", listOf(employeeAccountId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/employee/delete",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /employee/get
     * Get Employee
     * Get the account record for the account id provided.
     * @param accountId the id of logged in user
     * @param employeeAccountId the id of the employee account to get
     * @param settingsAppKey Determines whether to return the application settings for the employee for a particular application (optional)
     * @return EmployeeResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getEmployee(accountId: kotlin.Long, employeeAccountId: kotlin.Long, settingsAppKey: kotlin.String? = null) : EmployeeResponse {
        val localVarResponse = getEmployeeWithHttpInfo(accountId = accountId, employeeAccountId = employeeAccountId, settingsAppKey = settingsAppKey)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EmployeeResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /employee/get
     * Get Employee
     * Get the account record for the account id provided.
     * @param accountId the id of logged in user
     * @param employeeAccountId the id of the employee account to get
     * @param settingsAppKey Determines whether to return the application settings for the employee for a particular application (optional)
     * @return ApiResponse<EmployeeResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getEmployeeWithHttpInfo(accountId: kotlin.Long, employeeAccountId: kotlin.Long, settingsAppKey: kotlin.String?) : ApiResponse<EmployeeResponse?> {
        val localVariableConfig = getEmployeeRequestConfig(accountId = accountId, employeeAccountId = employeeAccountId, settingsAppKey = settingsAppKey)

        return request<Unit, EmployeeResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getEmployee
     *
     * @param accountId the id of logged in user
     * @param employeeAccountId the id of the employee account to get
     * @param settingsAppKey Determines whether to return the application settings for the employee for a particular application (optional)
     * @return RequestConfig
     */
    fun getEmployeeRequestConfig(accountId: kotlin.Long, employeeAccountId: kotlin.Long, settingsAppKey: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("employeeAccountId", listOf(employeeAccountId.toString()))
                if (settingsAppKey != null) {
                    put("settingsAppKey", listOf(settingsAppKey.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/employee/get",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter sortField
     */
     enum class SortFieldSearchEmployees(val value: kotlin.String) {
         @Json(name = "ID") ID("ID"),
         @Json(name = "DISPLAY") DISPLAY("DISPLAY"),
         @Json(name = "CREATED") CREATED("CREATED"),
         @Json(name = "UPDATED") UPDATED("UPDATED"),
         @Json(name = "ACTIVE") ACTIVE("ACTIVE"),
         @Json(name = "DELETED") DELETED("DELETED"),
         @Json(name = "LAST_LOGGED_IN") LAST_LOGGED_IN("LAST_LOGGED_IN"),
         @Json(name = "CONTACT_EMAIL") CONTACT_EMAIL("CONTACT_EMAIL"),
         @Json(name = "ACCOUNT_TYPE") ACCOUNT_TYPE("ACCOUNT_TYPE"),
         @Json(name = "RETAILER_LOCATION_NAME") RETAILER_LOCATION_NAME("RETAILER_LOCATION_NAME"),
         @Json(name = "RETAILER_NAME") RETAILER_NAME("RETAILER_NAME");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * POST /employee/search
     * Search Employees
     * Use the accountId to determine the associated BillableEntity. From there get a list of all accounts associated as managers/employees.
     * @param accountId The account id of the logged in user
     * @param role The role to limit the search to: RETAILER or RETAILER_LIMITED. Leave empty to search on both roles. (optional)
     * @param retailerId Filters employees by retailer (optional)
     * @param retailerLocationId Filter employees by retailer locations (optional)
     * @param q Deprecated parameter (optional)
     * @param keyword an optional keyword to search on; ignored if empty (optional)
     * @param sortField The field to sort by. Possible values include: DISPLAY, CREATED, UPDATED, ACTIVE, DELETED, LAST_LOGGED_IN, CONTACT_EMAIL, RETAILER_LOCATION_NAME, RETAILER_NAME (optional)
     * @param descending Determines whether the sorted list is in descending or ascending order (optional, default to false)
     * @param i Deprecated parameter (optional)
     * @param start Start the result set at some index (optional, default to 0)
     * @param l Deprecated parameter (optional)
     * @param limit Limit the result to some number (optional, default to 20)
     * @param activeOnly Filter results to only return active employees (optional, default to true)
     * @param managedOnly Filter results to only employees that you manage (optional)
     * @param settingsAppKey Determines whether to return the application settings for the employee for a particular application (optional)
     * @param categoryIds Comma separated list of category ids to filter results (optional)
     * @param query Legacy/reporting query parameter used for formatting employee responses (optional)
     * @return kotlin.collections.List<EmployeeResponse>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun searchEmployees(accountId: kotlin.Long, role: kotlin.String? = null, retailerId: kotlin.Long? = null, retailerLocationId: kotlin.Long? = null, q: kotlin.String? = null, keyword: kotlin.String? = null, sortField: SortFieldSearchEmployees? = null, descending: kotlin.Boolean? = false, i: kotlin.Int? = null, start: kotlin.Int? = 0, l: kotlin.Int? = null, limit: kotlin.Int? = 20, activeOnly: kotlin.Boolean? = true, managedOnly: kotlin.Boolean? = null, settingsAppKey: kotlin.String? = null, categoryIds: kotlin.String? = null, query: kotlin.String? = null) : kotlin.collections.List<EmployeeResponse> {
        val localVarResponse = searchEmployeesWithHttpInfo(accountId = accountId, role = role, retailerId = retailerId, retailerLocationId = retailerLocationId, q = q, keyword = keyword, sortField = sortField, descending = descending, i = i, start = start, l = l, limit = limit, activeOnly = activeOnly, managedOnly = managedOnly, settingsAppKey = settingsAppKey, categoryIds = categoryIds, query = query)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<EmployeeResponse>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /employee/search
     * Search Employees
     * Use the accountId to determine the associated BillableEntity. From there get a list of all accounts associated as managers/employees.
     * @param accountId The account id of the logged in user
     * @param role The role to limit the search to: RETAILER or RETAILER_LIMITED. Leave empty to search on both roles. (optional)
     * @param retailerId Filters employees by retailer (optional)
     * @param retailerLocationId Filter employees by retailer locations (optional)
     * @param q Deprecated parameter (optional)
     * @param keyword an optional keyword to search on; ignored if empty (optional)
     * @param sortField The field to sort by. Possible values include: DISPLAY, CREATED, UPDATED, ACTIVE, DELETED, LAST_LOGGED_IN, CONTACT_EMAIL, RETAILER_LOCATION_NAME, RETAILER_NAME (optional)
     * @param descending Determines whether the sorted list is in descending or ascending order (optional, default to false)
     * @param i Deprecated parameter (optional)
     * @param start Start the result set at some index (optional, default to 0)
     * @param l Deprecated parameter (optional)
     * @param limit Limit the result to some number (optional, default to 20)
     * @param activeOnly Filter results to only return active employees (optional, default to true)
     * @param managedOnly Filter results to only employees that you manage (optional)
     * @param settingsAppKey Determines whether to return the application settings for the employee for a particular application (optional)
     * @param categoryIds Comma separated list of category ids to filter results (optional)
     * @param query Legacy/reporting query parameter used for formatting employee responses (optional)
     * @return ApiResponse<kotlin.collections.List<EmployeeResponse>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun searchEmployeesWithHttpInfo(accountId: kotlin.Long, role: kotlin.String?, retailerId: kotlin.Long?, retailerLocationId: kotlin.Long?, q: kotlin.String?, keyword: kotlin.String?, sortField: SortFieldSearchEmployees?, descending: kotlin.Boolean?, i: kotlin.Int?, start: kotlin.Int?, l: kotlin.Int?, limit: kotlin.Int?, activeOnly: kotlin.Boolean?, managedOnly: kotlin.Boolean?, settingsAppKey: kotlin.String?, categoryIds: kotlin.String?, query: kotlin.String?) : ApiResponse<kotlin.collections.List<EmployeeResponse>?> {
        val localVariableConfig = searchEmployeesRequestConfig(accountId = accountId, role = role, retailerId = retailerId, retailerLocationId = retailerLocationId, q = q, keyword = keyword, sortField = sortField, descending = descending, i = i, start = start, l = l, limit = limit, activeOnly = activeOnly, managedOnly = managedOnly, settingsAppKey = settingsAppKey, categoryIds = categoryIds, query = query)

        return request<Unit, kotlin.collections.List<EmployeeResponse>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation searchEmployees
     *
     * @param accountId The account id of the logged in user
     * @param role The role to limit the search to: RETAILER or RETAILER_LIMITED. Leave empty to search on both roles. (optional)
     * @param retailerId Filters employees by retailer (optional)
     * @param retailerLocationId Filter employees by retailer locations (optional)
     * @param q Deprecated parameter (optional)
     * @param keyword an optional keyword to search on; ignored if empty (optional)
     * @param sortField The field to sort by. Possible values include: DISPLAY, CREATED, UPDATED, ACTIVE, DELETED, LAST_LOGGED_IN, CONTACT_EMAIL, RETAILER_LOCATION_NAME, RETAILER_NAME (optional)
     * @param descending Determines whether the sorted list is in descending or ascending order (optional, default to false)
     * @param i Deprecated parameter (optional)
     * @param start Start the result set at some index (optional, default to 0)
     * @param l Deprecated parameter (optional)
     * @param limit Limit the result to some number (optional, default to 20)
     * @param activeOnly Filter results to only return active employees (optional, default to true)
     * @param managedOnly Filter results to only employees that you manage (optional)
     * @param settingsAppKey Determines whether to return the application settings for the employee for a particular application (optional)
     * @param categoryIds Comma separated list of category ids to filter results (optional)
     * @param query Legacy/reporting query parameter used for formatting employee responses (optional)
     * @return RequestConfig
     */
    fun searchEmployeesRequestConfig(accountId: kotlin.Long, role: kotlin.String?, retailerId: kotlin.Long?, retailerLocationId: kotlin.Long?, q: kotlin.String?, keyword: kotlin.String?, sortField: SortFieldSearchEmployees?, descending: kotlin.Boolean?, i: kotlin.Int?, start: kotlin.Int?, l: kotlin.Int?, limit: kotlin.Int?, activeOnly: kotlin.Boolean?, managedOnly: kotlin.Boolean?, settingsAppKey: kotlin.String?, categoryIds: kotlin.String?, query: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                if (role != null) {
                    put("role", listOf(role.toString()))
                }
                if (retailerId != null) {
                    put("retailerId", listOf(retailerId.toString()))
                }
                if (retailerLocationId != null) {
                    put("retailerLocationId", listOf(retailerLocationId.toString()))
                }
                if (q != null) {
                    put("q", listOf(q.toString()))
                }
                if (keyword != null) {
                    put("keyword", listOf(keyword.toString()))
                }
                if (sortField != null) {
                    put("sortField", listOf(sortField.value))
                }
                if (descending != null) {
                    put("descending", listOf(descending.toString()))
                }
                if (i != null) {
                    put("_i", listOf(i.toString()))
                }
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (l != null) {
                    put("_l", listOf(l.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (activeOnly != null) {
                    put("activeOnly", listOf(activeOnly.toString()))
                }
                if (managedOnly != null) {
                    put("managedOnly", listOf(managedOnly.toString()))
                }
                if (settingsAppKey != null) {
                    put("settingsAppKey", listOf(settingsAppKey.toString()))
                }
                if (categoryIds != null) {
                    put("categoryIds", listOf(categoryIds.toString()))
                }
                if (query != null) {
                    put("query", listOf(query.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/employee/search",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /employee/unassign
     * Unassign Employee
     * Unassign An existing account to be an employee
     * @param accountId The account id of the logged in user
     * @param employeeAccountId The account id of the user to be unassigned
     * @return EmployeeResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun unassignEmployee(accountId: kotlin.Long, employeeAccountId: kotlin.Long) : EmployeeResponse {
        val localVarResponse = unassignEmployeeWithHttpInfo(accountId = accountId, employeeAccountId = employeeAccountId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EmployeeResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /employee/unassign
     * Unassign Employee
     * Unassign An existing account to be an employee
     * @param accountId The account id of the logged in user
     * @param employeeAccountId The account id of the user to be unassigned
     * @return ApiResponse<EmployeeResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun unassignEmployeeWithHttpInfo(accountId: kotlin.Long, employeeAccountId: kotlin.Long) : ApiResponse<EmployeeResponse?> {
        val localVariableConfig = unassignEmployeeRequestConfig(accountId = accountId, employeeAccountId = employeeAccountId)

        return request<Unit, EmployeeResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation unassignEmployee
     *
     * @param accountId The account id of the logged in user
     * @param employeeAccountId The account id of the user to be unassigned
     * @return RequestConfig
     */
    fun unassignEmployeeRequestConfig(accountId: kotlin.Long, employeeAccountId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("employeeAccountId", listOf(employeeAccountId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/employee/unassign",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter gender
     */
     enum class GenderUpdateEmployee(val value: kotlin.String) {
         @Json(name = "MALE") MALE("MALE"),
         @Json(name = "FEMALE") FEMALE("FEMALE"),
         @Json(name = "ANY") ANY("ANY");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * POST /employee/update
     * Update Employee
     * Update the account record with the provided information.
     * @param accountId The account id of the logged in user
     * @param employeeAccountId the id of the employee account
     * @param managerAccountId The account id of the manager to assign under (optional)
     * @param name a name field (optional)
     * @param prefixName The name prefix; Mr, Mrs, etc (optional)
     * @param firstName The first name (optional)
     * @param middleName The middle name (optional)
     * @param lastName The last name (optional)
     * @param suffixName The name suffix; Jr, Sr, III, etc (optional)
     * @param title The title of the user (optional)
     * @param assetId the asset id to set the user&#39;s profile image (optional)
     * @param gender The gender {MALE, FEMALE, ANY} (optional)
     * @param homePhone The home phone number (optional)
     * @param cellPhone The cellular phone number (optional)
     * @param cellPhoneCarrier The cellular service provider. This is required for sending SMS. Leave this empty if the provider is not on the list of supported carriers. Supported Carriers: {ATT, QWEST, T_MOBILE, VERIZON, SPRINT, VIRIGIN_MOBILE, NEXTEL, ALLTEL, METRO_PCS, POWERTEL, BOOST_MOBILE, SUNCOM, TRACFONE, US_CELLULAR} (optional)
     * @param businessPhone The business phone number (optional)
     * @param emailAddress The user&#39;s contact email address (NOT the username) (optional)
     * @param streetAddress The street address of the user&#39;s contact location (optional)
     * @param streetAddress2 Additional address information (such as a suite number, floor number, building name, or PO Box) (optional)
     * @param city The city of the user&#39;s contact location (optional)
     * @param state The state of the user&#39;s contact location (optional)
     * @param zipcode The zipcode of the user&#39;s contact location (optional)
     * @param country The country of the user&#39;s contact location (optional)
     * @param role The role; RETAILER or RETAILER_LIMITED, defaulted to RETAILER_LIMITED (optional)
     * @param active Sets whether the employee is active or inactive (optional)
     * @param password Sets the password for the employee (optional)
     * @param retailerLocationIds Sets which retailer locations the employee is assigned to (optional)
     * @param settingsAppKey Determines whether to return the application settings for the employee for a particular application (optional)
     * @param appBlob external custom client defined data (per Application) (optional)
     * @param assignedDeviceId The device id to assign to the user (used for IPS beacon tracking) (optional)
     * @return EmployeeResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updateEmployee(accountId: kotlin.Long, employeeAccountId: kotlin.Long, managerAccountId: kotlin.Long? = null, name: kotlin.String? = null, prefixName: kotlin.String? = null, firstName: kotlin.String? = null, middleName: kotlin.String? = null, lastName: kotlin.String? = null, suffixName: kotlin.String? = null, title: kotlin.String? = null, assetId: kotlin.Long? = null, gender: GenderUpdateEmployee? = null, homePhone: kotlin.String? = null, cellPhone: kotlin.String? = null, cellPhoneCarrier: kotlin.String? = null, businessPhone: kotlin.String? = null, emailAddress: kotlin.String? = null, streetAddress: kotlin.String? = null, streetAddress2: kotlin.String? = null, city: kotlin.String? = null, state: kotlin.String? = null, zipcode: kotlin.String? = null, country: kotlin.String? = null, role: kotlin.String? = null, active: kotlin.Boolean? = null, password: kotlin.String? = null, retailerLocationIds: kotlin.String? = null, settingsAppKey: kotlin.String? = null, appBlob: kotlin.String? = null, assignedDeviceId: kotlin.String? = null) : EmployeeResponse {
        val localVarResponse = updateEmployeeWithHttpInfo(accountId = accountId, employeeAccountId = employeeAccountId, managerAccountId = managerAccountId, name = name, prefixName = prefixName, firstName = firstName, middleName = middleName, lastName = lastName, suffixName = suffixName, title = title, assetId = assetId, gender = gender, homePhone = homePhone, cellPhone = cellPhone, cellPhoneCarrier = cellPhoneCarrier, businessPhone = businessPhone, emailAddress = emailAddress, streetAddress = streetAddress, streetAddress2 = streetAddress2, city = city, state = state, zipcode = zipcode, country = country, role = role, active = active, password = password, retailerLocationIds = retailerLocationIds, settingsAppKey = settingsAppKey, appBlob = appBlob, assignedDeviceId = assignedDeviceId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EmployeeResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /employee/update
     * Update Employee
     * Update the account record with the provided information.
     * @param accountId The account id of the logged in user
     * @param employeeAccountId the id of the employee account
     * @param managerAccountId The account id of the manager to assign under (optional)
     * @param name a name field (optional)
     * @param prefixName The name prefix; Mr, Mrs, etc (optional)
     * @param firstName The first name (optional)
     * @param middleName The middle name (optional)
     * @param lastName The last name (optional)
     * @param suffixName The name suffix; Jr, Sr, III, etc (optional)
     * @param title The title of the user (optional)
     * @param assetId the asset id to set the user&#39;s profile image (optional)
     * @param gender The gender {MALE, FEMALE, ANY} (optional)
     * @param homePhone The home phone number (optional)
     * @param cellPhone The cellular phone number (optional)
     * @param cellPhoneCarrier The cellular service provider. This is required for sending SMS. Leave this empty if the provider is not on the list of supported carriers. Supported Carriers: {ATT, QWEST, T_MOBILE, VERIZON, SPRINT, VIRIGIN_MOBILE, NEXTEL, ALLTEL, METRO_PCS, POWERTEL, BOOST_MOBILE, SUNCOM, TRACFONE, US_CELLULAR} (optional)
     * @param businessPhone The business phone number (optional)
     * @param emailAddress The user&#39;s contact email address (NOT the username) (optional)
     * @param streetAddress The street address of the user&#39;s contact location (optional)
     * @param streetAddress2 Additional address information (such as a suite number, floor number, building name, or PO Box) (optional)
     * @param city The city of the user&#39;s contact location (optional)
     * @param state The state of the user&#39;s contact location (optional)
     * @param zipcode The zipcode of the user&#39;s contact location (optional)
     * @param country The country of the user&#39;s contact location (optional)
     * @param role The role; RETAILER or RETAILER_LIMITED, defaulted to RETAILER_LIMITED (optional)
     * @param active Sets whether the employee is active or inactive (optional)
     * @param password Sets the password for the employee (optional)
     * @param retailerLocationIds Sets which retailer locations the employee is assigned to (optional)
     * @param settingsAppKey Determines whether to return the application settings for the employee for a particular application (optional)
     * @param appBlob external custom client defined data (per Application) (optional)
     * @param assignedDeviceId The device id to assign to the user (used for IPS beacon tracking) (optional)
     * @return ApiResponse<EmployeeResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun updateEmployeeWithHttpInfo(accountId: kotlin.Long, employeeAccountId: kotlin.Long, managerAccountId: kotlin.Long?, name: kotlin.String?, prefixName: kotlin.String?, firstName: kotlin.String?, middleName: kotlin.String?, lastName: kotlin.String?, suffixName: kotlin.String?, title: kotlin.String?, assetId: kotlin.Long?, gender: GenderUpdateEmployee?, homePhone: kotlin.String?, cellPhone: kotlin.String?, cellPhoneCarrier: kotlin.String?, businessPhone: kotlin.String?, emailAddress: kotlin.String?, streetAddress: kotlin.String?, streetAddress2: kotlin.String?, city: kotlin.String?, state: kotlin.String?, zipcode: kotlin.String?, country: kotlin.String?, role: kotlin.String?, active: kotlin.Boolean?, password: kotlin.String?, retailerLocationIds: kotlin.String?, settingsAppKey: kotlin.String?, appBlob: kotlin.String?, assignedDeviceId: kotlin.String?) : ApiResponse<EmployeeResponse?> {
        val localVariableConfig = updateEmployeeRequestConfig(accountId = accountId, employeeAccountId = employeeAccountId, managerAccountId = managerAccountId, name = name, prefixName = prefixName, firstName = firstName, middleName = middleName, lastName = lastName, suffixName = suffixName, title = title, assetId = assetId, gender = gender, homePhone = homePhone, cellPhone = cellPhone, cellPhoneCarrier = cellPhoneCarrier, businessPhone = businessPhone, emailAddress = emailAddress, streetAddress = streetAddress, streetAddress2 = streetAddress2, city = city, state = state, zipcode = zipcode, country = country, role = role, active = active, password = password, retailerLocationIds = retailerLocationIds, settingsAppKey = settingsAppKey, appBlob = appBlob, assignedDeviceId = assignedDeviceId)

        return request<Unit, EmployeeResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateEmployee
     *
     * @param accountId The account id of the logged in user
     * @param employeeAccountId the id of the employee account
     * @param managerAccountId The account id of the manager to assign under (optional)
     * @param name a name field (optional)
     * @param prefixName The name prefix; Mr, Mrs, etc (optional)
     * @param firstName The first name (optional)
     * @param middleName The middle name (optional)
     * @param lastName The last name (optional)
     * @param suffixName The name suffix; Jr, Sr, III, etc (optional)
     * @param title The title of the user (optional)
     * @param assetId the asset id to set the user&#39;s profile image (optional)
     * @param gender The gender {MALE, FEMALE, ANY} (optional)
     * @param homePhone The home phone number (optional)
     * @param cellPhone The cellular phone number (optional)
     * @param cellPhoneCarrier The cellular service provider. This is required for sending SMS. Leave this empty if the provider is not on the list of supported carriers. Supported Carriers: {ATT, QWEST, T_MOBILE, VERIZON, SPRINT, VIRIGIN_MOBILE, NEXTEL, ALLTEL, METRO_PCS, POWERTEL, BOOST_MOBILE, SUNCOM, TRACFONE, US_CELLULAR} (optional)
     * @param businessPhone The business phone number (optional)
     * @param emailAddress The user&#39;s contact email address (NOT the username) (optional)
     * @param streetAddress The street address of the user&#39;s contact location (optional)
     * @param streetAddress2 Additional address information (such as a suite number, floor number, building name, or PO Box) (optional)
     * @param city The city of the user&#39;s contact location (optional)
     * @param state The state of the user&#39;s contact location (optional)
     * @param zipcode The zipcode of the user&#39;s contact location (optional)
     * @param country The country of the user&#39;s contact location (optional)
     * @param role The role; RETAILER or RETAILER_LIMITED, defaulted to RETAILER_LIMITED (optional)
     * @param active Sets whether the employee is active or inactive (optional)
     * @param password Sets the password for the employee (optional)
     * @param retailerLocationIds Sets which retailer locations the employee is assigned to (optional)
     * @param settingsAppKey Determines whether to return the application settings for the employee for a particular application (optional)
     * @param appBlob external custom client defined data (per Application) (optional)
     * @param assignedDeviceId The device id to assign to the user (used for IPS beacon tracking) (optional)
     * @return RequestConfig
     */
    fun updateEmployeeRequestConfig(accountId: kotlin.Long, employeeAccountId: kotlin.Long, managerAccountId: kotlin.Long?, name: kotlin.String?, prefixName: kotlin.String?, firstName: kotlin.String?, middleName: kotlin.String?, lastName: kotlin.String?, suffixName: kotlin.String?, title: kotlin.String?, assetId: kotlin.Long?, gender: GenderUpdateEmployee?, homePhone: kotlin.String?, cellPhone: kotlin.String?, cellPhoneCarrier: kotlin.String?, businessPhone: kotlin.String?, emailAddress: kotlin.String?, streetAddress: kotlin.String?, streetAddress2: kotlin.String?, city: kotlin.String?, state: kotlin.String?, zipcode: kotlin.String?, country: kotlin.String?, role: kotlin.String?, active: kotlin.Boolean?, password: kotlin.String?, retailerLocationIds: kotlin.String?, settingsAppKey: kotlin.String?, appBlob: kotlin.String?, assignedDeviceId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("employeeAccountId", listOf(employeeAccountId.toString()))
                if (managerAccountId != null) {
                    put("managerAccountId", listOf(managerAccountId.toString()))
                }
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (prefixName != null) {
                    put("prefixName", listOf(prefixName.toString()))
                }
                if (firstName != null) {
                    put("firstName", listOf(firstName.toString()))
                }
                if (middleName != null) {
                    put("middleName", listOf(middleName.toString()))
                }
                if (lastName != null) {
                    put("lastName", listOf(lastName.toString()))
                }
                if (suffixName != null) {
                    put("suffixName", listOf(suffixName.toString()))
                }
                if (title != null) {
                    put("title", listOf(title.toString()))
                }
                if (assetId != null) {
                    put("assetId", listOf(assetId.toString()))
                }
                if (gender != null) {
                    put("gender", listOf(gender.value))
                }
                if (homePhone != null) {
                    put("homePhone", listOf(homePhone.toString()))
                }
                if (cellPhone != null) {
                    put("cellPhone", listOf(cellPhone.toString()))
                }
                if (cellPhoneCarrier != null) {
                    put("cellPhoneCarrier", listOf(cellPhoneCarrier.toString()))
                }
                if (businessPhone != null) {
                    put("businessPhone", listOf(businessPhone.toString()))
                }
                if (emailAddress != null) {
                    put("emailAddress", listOf(emailAddress.toString()))
                }
                if (streetAddress != null) {
                    put("streetAddress", listOf(streetAddress.toString()))
                }
                if (streetAddress2 != null) {
                    put("streetAddress2", listOf(streetAddress2.toString()))
                }
                if (city != null) {
                    put("city", listOf(city.toString()))
                }
                if (state != null) {
                    put("state", listOf(state.toString()))
                }
                if (zipcode != null) {
                    put("zipcode", listOf(zipcode.toString()))
                }
                if (country != null) {
                    put("country", listOf(country.toString()))
                }
                if (role != null) {
                    put("role", listOf(role.toString()))
                }
                if (active != null) {
                    put("active", listOf(active.toString()))
                }
                if (password != null) {
                    put("password", listOf(password.toString()))
                }
                if (retailerLocationIds != null) {
                    put("retailerLocationIds", listOf(retailerLocationIds.toString()))
                }
                if (settingsAppKey != null) {
                    put("settingsAppKey", listOf(settingsAppKey.toString()))
                }
                if (appBlob != null) {
                    put("appBlob", listOf(appBlob.toString()))
                }
                if (assignedDeviceId != null) {
                    put("assignedDeviceId", listOf(assignedDeviceId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/employee/update",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
