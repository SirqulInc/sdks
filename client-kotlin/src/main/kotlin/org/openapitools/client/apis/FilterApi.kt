/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import org.openapitools.client.models.FilterResponse
import org.openapitools.client.models.FilterTreeResponse
import org.openapitools.client.models.SirqulResponse

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

open class FilterApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://dev.sirqul.com/api/3.18")
        }
    }

    /**
     * POST /filter/create
     * Create Filter
     * Create a filter
     * @param accountId The account id of the user (must have permissions to the target application)
     * @param name The name of the filter
     * @param appKey The appKey of the application to assign the filter to, if not provided then the filter will be applied to the global application (if the account has permissions) (optional)
     * @param parentFilterId The ID of the parent filter, if not provided then the parent filter will be null (optional)
     * @param description The description of the filter (optional)
     * @param externalId A string identifier used by client applications to store external information (optional)
     * @param externalType A string type used by client applications to store external information (optional)
     * @param active Sets whether the filter is active or inactive (hidden from consumers) (optional)
     * @param metaData external custom client defined data (optional)
     * @return FilterTreeResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createFilter(accountId: kotlin.Long, name: kotlin.String, appKey: kotlin.String? = null, parentFilterId: kotlin.Long? = null, description: kotlin.String? = null, externalId: kotlin.String? = null, externalType: kotlin.String? = null, active: kotlin.Boolean? = null, metaData: kotlin.String? = null) : FilterTreeResponse {
        val localVarResponse = createFilterWithHttpInfo(accountId = accountId, name = name, appKey = appKey, parentFilterId = parentFilterId, description = description, externalId = externalId, externalType = externalType, active = active, metaData = metaData)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FilterTreeResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /filter/create
     * Create Filter
     * Create a filter
     * @param accountId The account id of the user (must have permissions to the target application)
     * @param name The name of the filter
     * @param appKey The appKey of the application to assign the filter to, if not provided then the filter will be applied to the global application (if the account has permissions) (optional)
     * @param parentFilterId The ID of the parent filter, if not provided then the parent filter will be null (optional)
     * @param description The description of the filter (optional)
     * @param externalId A string identifier used by client applications to store external information (optional)
     * @param externalType A string type used by client applications to store external information (optional)
     * @param active Sets whether the filter is active or inactive (hidden from consumers) (optional)
     * @param metaData external custom client defined data (optional)
     * @return ApiResponse<FilterTreeResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createFilterWithHttpInfo(accountId: kotlin.Long, name: kotlin.String, appKey: kotlin.String?, parentFilterId: kotlin.Long?, description: kotlin.String?, externalId: kotlin.String?, externalType: kotlin.String?, active: kotlin.Boolean?, metaData: kotlin.String?) : ApiResponse<FilterTreeResponse?> {
        val localVariableConfig = createFilterRequestConfig(accountId = accountId, name = name, appKey = appKey, parentFilterId = parentFilterId, description = description, externalId = externalId, externalType = externalType, active = active, metaData = metaData)

        return request<Unit, FilterTreeResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createFilter
     *
     * @param accountId The account id of the user (must have permissions to the target application)
     * @param name The name of the filter
     * @param appKey The appKey of the application to assign the filter to, if not provided then the filter will be applied to the global application (if the account has permissions) (optional)
     * @param parentFilterId The ID of the parent filter, if not provided then the parent filter will be null (optional)
     * @param description The description of the filter (optional)
     * @param externalId A string identifier used by client applications to store external information (optional)
     * @param externalType A string type used by client applications to store external information (optional)
     * @param active Sets whether the filter is active or inactive (hidden from consumers) (optional)
     * @param metaData external custom client defined data (optional)
     * @return RequestConfig
     */
    fun createFilterRequestConfig(accountId: kotlin.Long, name: kotlin.String, appKey: kotlin.String?, parentFilterId: kotlin.Long?, description: kotlin.String?, externalId: kotlin.String?, externalType: kotlin.String?, active: kotlin.Boolean?, metaData: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                if (appKey != null) {
                    put("appKey", listOf(appKey.toString()))
                }
                if (parentFilterId != null) {
                    put("parentFilterId", listOf(parentFilterId.toString()))
                }
                put("name", listOf(name.toString()))
                if (description != null) {
                    put("description", listOf(description.toString()))
                }
                if (externalId != null) {
                    put("externalId", listOf(externalId.toString()))
                }
                if (externalType != null) {
                    put("externalType", listOf(externalType.toString()))
                }
                if (active != null) {
                    put("active", listOf(active.toString()))
                }
                if (metaData != null) {
                    put("metaData", listOf(metaData.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/filter/create",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /filter/delete
     * Delete Filter
     * Delete a filter.
     * @param accountId The account id of the user (must have permissions to the filter&#39;s assigned application)
     * @param filterId The ID of the filter to delete
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteFilter(accountId: kotlin.Long, filterId: kotlin.Long) : SirqulResponse {
        val localVarResponse = deleteFilterWithHttpInfo(accountId = accountId, filterId = filterId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /filter/delete
     * Delete Filter
     * Delete a filter.
     * @param accountId The account id of the user (must have permissions to the filter&#39;s assigned application)
     * @param filterId The ID of the filter to delete
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteFilterWithHttpInfo(accountId: kotlin.Long, filterId: kotlin.Long) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = deleteFilterRequestConfig(accountId = accountId, filterId = filterId)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteFilter
     *
     * @param accountId The account id of the user (must have permissions to the filter&#39;s assigned application)
     * @param filterId The ID of the filter to delete
     * @return RequestConfig
     */
    fun deleteFilterRequestConfig(accountId: kotlin.Long, filterId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("filterId", listOf(filterId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/filter/delete",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /filter/get
     * Get Filter
     * Get the details of a specific filter. Recursively include all child filters and their children.
     * @param filterId the id of the filter to get
     * @return FilterTreeResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getFilter(filterId: kotlin.Long) : FilterTreeResponse {
        val localVarResponse = getFilterWithHttpInfo(filterId = filterId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FilterTreeResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /filter/get
     * Get Filter
     * Get the details of a specific filter. Recursively include all child filters and their children.
     * @param filterId the id of the filter to get
     * @return ApiResponse<FilterTreeResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getFilterWithHttpInfo(filterId: kotlin.Long) : ApiResponse<FilterTreeResponse?> {
        val localVariableConfig = getFilterRequestConfig(filterId = filterId)

        return request<Unit, FilterTreeResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getFilter
     *
     * @param filterId the id of the filter to get
     * @return RequestConfig
     */
    fun getFilterRequestConfig(filterId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("filterId", listOf(filterId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/filter/get",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter responseGroup
     */
     enum class ResponseGroupSearchFilters(val value: kotlin.String) {
         @Json(name = "ALL") ALL("ALL"),
         @Json(name = "GLOBAL") GLOBAL("GLOBAL"),
         @Json(name = "MINE") MINE("MINE");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter sortField
     */
     enum class SortFieldSearchFilters(val value: kotlin.String) {
         @Json(name = "ID") ID("ID"),
         @Json(name = "CREATED") CREATED("CREATED"),
         @Json(name = "UPDATED") UPDATED("UPDATED"),
         @Json(name = "DELETED") DELETED("DELETED"),
         @Json(name = "SEARCH_TAGS") SEARCH_TAGS("SEARCH_TAGS"),
         @Json(name = "ACTIVE") ACTIVE("ACTIVE"),
         @Json(name = "NAME") NAME("NAME"),
         @Json(name = "DISPLAY") DISPLAY("DISPLAY");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /filter/search
     * Search Filters
     * Search for filters.
     * @param accountId The account id of the user (optional)
     * @param keyword The string to search on (optional)
     * @param appKey the appKey of the application to retrieve filters for (optional)
     * @param responseGroup The group of filters to return: ALL, GLOBAL or MINE. ALL returns both global and application specific matches, GLOBAL only returns global matches, and MINE only returns the application specific matches. If not provided search on the application provided. (optional)
     * @param rootOnly Restrict the search to only those filters with no parent filter assigned. (optional)
     * @param sortField The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, DISPLAY (optional, default to SortField.DISPLAY)
     * @param descending The order to return the search results (optional, default to false)
     * @param start The record to begin the return set on (optional, default to 0)
     * @param limit The number of records to return (optional, default to 20)
     * @param activeOnly Determines whether to return only active categories (optional, default to true)
     * @return kotlin.collections.List<FilterResponse>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun searchFilters(accountId: kotlin.Long? = null, keyword: kotlin.String? = null, appKey: kotlin.String? = null, responseGroup: ResponseGroupSearchFilters? = null, rootOnly: kotlin.Boolean? = null, sortField: SortFieldSearchFilters? = SortFieldSearchFilters.DISPLAY, descending: kotlin.Boolean? = false, start: kotlin.Int? = 0, limit: kotlin.Int? = 20, activeOnly: kotlin.Boolean? = true) : kotlin.collections.List<FilterResponse> {
        val localVarResponse = searchFiltersWithHttpInfo(accountId = accountId, keyword = keyword, appKey = appKey, responseGroup = responseGroup, rootOnly = rootOnly, sortField = sortField, descending = descending, start = start, limit = limit, activeOnly = activeOnly)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<FilterResponse>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /filter/search
     * Search Filters
     * Search for filters.
     * @param accountId The account id of the user (optional)
     * @param keyword The string to search on (optional)
     * @param appKey the appKey of the application to retrieve filters for (optional)
     * @param responseGroup The group of filters to return: ALL, GLOBAL or MINE. ALL returns both global and application specific matches, GLOBAL only returns global matches, and MINE only returns the application specific matches. If not provided search on the application provided. (optional)
     * @param rootOnly Restrict the search to only those filters with no parent filter assigned. (optional)
     * @param sortField The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, DISPLAY (optional, default to SortField.DISPLAY)
     * @param descending The order to return the search results (optional, default to false)
     * @param start The record to begin the return set on (optional, default to 0)
     * @param limit The number of records to return (optional, default to 20)
     * @param activeOnly Determines whether to return only active categories (optional, default to true)
     * @return ApiResponse<kotlin.collections.List<FilterResponse>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun searchFiltersWithHttpInfo(accountId: kotlin.Long?, keyword: kotlin.String?, appKey: kotlin.String?, responseGroup: ResponseGroupSearchFilters?, rootOnly: kotlin.Boolean?, sortField: SortFieldSearchFilters?, descending: kotlin.Boolean?, start: kotlin.Int?, limit: kotlin.Int?, activeOnly: kotlin.Boolean?) : ApiResponse<kotlin.collections.List<FilterResponse>?> {
        val localVariableConfig = searchFiltersRequestConfig(accountId = accountId, keyword = keyword, appKey = appKey, responseGroup = responseGroup, rootOnly = rootOnly, sortField = sortField, descending = descending, start = start, limit = limit, activeOnly = activeOnly)

        return request<Unit, kotlin.collections.List<FilterResponse>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation searchFilters
     *
     * @param accountId The account id of the user (optional)
     * @param keyword The string to search on (optional)
     * @param appKey the appKey of the application to retrieve filters for (optional)
     * @param responseGroup The group of filters to return: ALL, GLOBAL or MINE. ALL returns both global and application specific matches, GLOBAL only returns global matches, and MINE only returns the application specific matches. If not provided search on the application provided. (optional)
     * @param rootOnly Restrict the search to only those filters with no parent filter assigned. (optional)
     * @param sortField The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, DISPLAY (optional, default to SortField.DISPLAY)
     * @param descending The order to return the search results (optional, default to false)
     * @param start The record to begin the return set on (optional, default to 0)
     * @param limit The number of records to return (optional, default to 20)
     * @param activeOnly Determines whether to return only active categories (optional, default to true)
     * @return RequestConfig
     */
    fun searchFiltersRequestConfig(accountId: kotlin.Long?, keyword: kotlin.String?, appKey: kotlin.String?, responseGroup: ResponseGroupSearchFilters?, rootOnly: kotlin.Boolean?, sortField: SortFieldSearchFilters?, descending: kotlin.Boolean?, start: kotlin.Int?, limit: kotlin.Int?, activeOnly: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (keyword != null) {
                    put("keyword", listOf(keyword.toString()))
                }
                if (appKey != null) {
                    put("appKey", listOf(appKey.toString()))
                }
                if (responseGroup != null) {
                    put("responseGroup", listOf(responseGroup.value))
                }
                if (rootOnly != null) {
                    put("rootOnly", listOf(rootOnly.toString()))
                }
                if (sortField != null) {
                    put("sortField", listOf(sortField.value))
                }
                if (descending != null) {
                    put("descending", listOf(descending.toString()))
                }
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (activeOnly != null) {
                    put("activeOnly", listOf(activeOnly.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/filter/search",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /filter/update
     * Update Filter
     * Update a filter.
     * @param accountId The account id of the user
     * @param filterId The ID of the filter to edit
     * @param parentFilterId The ID of the parent filter, if not provided then the parent filter will be null (optional)
     * @param name The name of the filter (optional)
     * @param description The description of the filter (optional)
     * @param externalId A string identifier used by client applications to store external information (optional)
     * @param externalType A string type used by client applications to store external information (optional)
     * @param active Sets whether the filter is active or inactive (hidden from consumers) (optional)
     * @param metaData external custom client defined data (optional)
     * @return FilterTreeResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updateFilter(accountId: kotlin.Long, filterId: kotlin.Long, parentFilterId: kotlin.Long? = null, name: kotlin.String? = null, description: kotlin.String? = null, externalId: kotlin.String? = null, externalType: kotlin.String? = null, active: kotlin.Boolean? = null, metaData: kotlin.String? = null) : FilterTreeResponse {
        val localVarResponse = updateFilterWithHttpInfo(accountId = accountId, filterId = filterId, parentFilterId = parentFilterId, name = name, description = description, externalId = externalId, externalType = externalType, active = active, metaData = metaData)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FilterTreeResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /filter/update
     * Update Filter
     * Update a filter.
     * @param accountId The account id of the user
     * @param filterId The ID of the filter to edit
     * @param parentFilterId The ID of the parent filter, if not provided then the parent filter will be null (optional)
     * @param name The name of the filter (optional)
     * @param description The description of the filter (optional)
     * @param externalId A string identifier used by client applications to store external information (optional)
     * @param externalType A string type used by client applications to store external information (optional)
     * @param active Sets whether the filter is active or inactive (hidden from consumers) (optional)
     * @param metaData external custom client defined data (optional)
     * @return ApiResponse<FilterTreeResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun updateFilterWithHttpInfo(accountId: kotlin.Long, filterId: kotlin.Long, parentFilterId: kotlin.Long?, name: kotlin.String?, description: kotlin.String?, externalId: kotlin.String?, externalType: kotlin.String?, active: kotlin.Boolean?, metaData: kotlin.String?) : ApiResponse<FilterTreeResponse?> {
        val localVariableConfig = updateFilterRequestConfig(accountId = accountId, filterId = filterId, parentFilterId = parentFilterId, name = name, description = description, externalId = externalId, externalType = externalType, active = active, metaData = metaData)

        return request<Unit, FilterTreeResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateFilter
     *
     * @param accountId The account id of the user
     * @param filterId The ID of the filter to edit
     * @param parentFilterId The ID of the parent filter, if not provided then the parent filter will be null (optional)
     * @param name The name of the filter (optional)
     * @param description The description of the filter (optional)
     * @param externalId A string identifier used by client applications to store external information (optional)
     * @param externalType A string type used by client applications to store external information (optional)
     * @param active Sets whether the filter is active or inactive (hidden from consumers) (optional)
     * @param metaData external custom client defined data (optional)
     * @return RequestConfig
     */
    fun updateFilterRequestConfig(accountId: kotlin.Long, filterId: kotlin.Long, parentFilterId: kotlin.Long?, name: kotlin.String?, description: kotlin.String?, externalId: kotlin.String?, externalType: kotlin.String?, active: kotlin.Boolean?, metaData: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("filterId", listOf(filterId.toString()))
                if (parentFilterId != null) {
                    put("parentFilterId", listOf(parentFilterId.toString()))
                }
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (description != null) {
                    put("description", listOf(description.toString()))
                }
                if (externalId != null) {
                    put("externalId", listOf(externalId.toString()))
                }
                if (externalType != null) {
                    put("externalType", listOf(externalType.toString()))
                }
                if (active != null) {
                    put("active", listOf(active.toString()))
                }
                if (metaData != null) {
                    put("metaData", listOf(metaData.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/filter/update",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
