/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import org.openapitools.client.models.AccountResponse
import org.openapitools.client.models.SearchResponse
import org.openapitools.client.models.SirqulResponse
import org.openapitools.client.models.WrappedResponse

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

open class FavoriteApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://dev.sirqul.com/api/3.18")
        }
    }

    /**
     * POST /favorite/create
     * Create Favorite
     * Adds an offer, offer location, retailer location, or category to your favorites.
     * @param favoritableId The ID of the object to favorite {offerId, offerLocationId, retailerLocationId, categoryId}
     * @param favoritableType The type of the object to favorite {OFFER, OFFER_LOCATION, RETAILER_LOCATION, CATEGORY, ALBUM}
     * @param deviceId The unique ID given by the device (deviceId or accountId required) (optional)
     * @param accountId The account ID of the user (deviceId or accountId required) (optional)
     * @param latitude The current latitude of the user (optional)
     * @param longitude The current longitude of the user (optional)
     * @return WrappedResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun addFavorite(favoritableId: kotlin.Long, favoritableType: kotlin.String, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, latitude: kotlin.Double? = null, longitude: kotlin.Double? = null) : WrappedResponse {
        val localVarResponse = addFavoriteWithHttpInfo(favoritableId = favoritableId, favoritableType = favoritableType, deviceId = deviceId, accountId = accountId, latitude = latitude, longitude = longitude)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as WrappedResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /favorite/create
     * Create Favorite
     * Adds an offer, offer location, retailer location, or category to your favorites.
     * @param favoritableId The ID of the object to favorite {offerId, offerLocationId, retailerLocationId, categoryId}
     * @param favoritableType The type of the object to favorite {OFFER, OFFER_LOCATION, RETAILER_LOCATION, CATEGORY, ALBUM}
     * @param deviceId The unique ID given by the device (deviceId or accountId required) (optional)
     * @param accountId The account ID of the user (deviceId or accountId required) (optional)
     * @param latitude The current latitude of the user (optional)
     * @param longitude The current longitude of the user (optional)
     * @return ApiResponse<WrappedResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun addFavoriteWithHttpInfo(favoritableId: kotlin.Long, favoritableType: kotlin.String, deviceId: kotlin.String?, accountId: kotlin.Long?, latitude: kotlin.Double?, longitude: kotlin.Double?) : ApiResponse<WrappedResponse?> {
        val localVariableConfig = addFavoriteRequestConfig(favoritableId = favoritableId, favoritableType = favoritableType, deviceId = deviceId, accountId = accountId, latitude = latitude, longitude = longitude)

        return request<Unit, WrappedResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation addFavorite
     *
     * @param favoritableId The ID of the object to favorite {offerId, offerLocationId, retailerLocationId, categoryId}
     * @param favoritableType The type of the object to favorite {OFFER, OFFER_LOCATION, RETAILER_LOCATION, CATEGORY, ALBUM}
     * @param deviceId The unique ID given by the device (deviceId or accountId required) (optional)
     * @param accountId The account ID of the user (deviceId or accountId required) (optional)
     * @param latitude The current latitude of the user (optional)
     * @param longitude The current longitude of the user (optional)
     * @return RequestConfig
     */
    fun addFavoriteRequestConfig(favoritableId: kotlin.Long, favoritableType: kotlin.String, deviceId: kotlin.String?, accountId: kotlin.Long?, latitude: kotlin.Double?, longitude: kotlin.Double?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                put("favoritableId", listOf(favoritableId.toString()))
                put("favoritableType", listOf(favoritableType.toString()))
                if (latitude != null) {
                    put("latitude", listOf(latitude.toString()))
                }
                if (longitude != null) {
                    put("longitude", listOf(longitude.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/favorite/create",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /favorite/delete
     * Delete Favorite
     * Removes a favorited item from the user&#39;s favorites list.
     * @param deviceId The unique ID given by the device (deviceId or accountId required) (optional)
     * @param accountId The account ID of the user (deviceId or accountId required) (optional)
     * @param favoriteId The ID of the favorite reference record (only optional if favoritableId &amp; favoritableType is pass in instead) (optional)
     * @param favoritableId The ID of the object to un-favorite {offerId, offerLocationId, retailerLocationId, categoryId} (this is required if favoriteId is NOT passed in) (optional)
     * @param favoritableType The type of the object to un-favorite {OFFER, OFFER_LOCATION, RETAILER_LOCATION, CATEGORY} (this is required if favoriteId is NOT passed in) (optional)
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteFavorite(deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, favoriteId: kotlin.Long? = null, favoritableId: kotlin.Long? = null, favoritableType: kotlin.String? = null) : SirqulResponse {
        val localVarResponse = deleteFavoriteWithHttpInfo(deviceId = deviceId, accountId = accountId, favoriteId = favoriteId, favoritableId = favoritableId, favoritableType = favoritableType)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /favorite/delete
     * Delete Favorite
     * Removes a favorited item from the user&#39;s favorites list.
     * @param deviceId The unique ID given by the device (deviceId or accountId required) (optional)
     * @param accountId The account ID of the user (deviceId or accountId required) (optional)
     * @param favoriteId The ID of the favorite reference record (only optional if favoritableId &amp; favoritableType is pass in instead) (optional)
     * @param favoritableId The ID of the object to un-favorite {offerId, offerLocationId, retailerLocationId, categoryId} (this is required if favoriteId is NOT passed in) (optional)
     * @param favoritableType The type of the object to un-favorite {OFFER, OFFER_LOCATION, RETAILER_LOCATION, CATEGORY} (this is required if favoriteId is NOT passed in) (optional)
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteFavoriteWithHttpInfo(deviceId: kotlin.String?, accountId: kotlin.Long?, favoriteId: kotlin.Long?, favoritableId: kotlin.Long?, favoritableType: kotlin.String?) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = deleteFavoriteRequestConfig(deviceId = deviceId, accountId = accountId, favoriteId = favoriteId, favoritableId = favoritableId, favoritableType = favoritableType)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteFavorite
     *
     * @param deviceId The unique ID given by the device (deviceId or accountId required) (optional)
     * @param accountId The account ID of the user (deviceId or accountId required) (optional)
     * @param favoriteId The ID of the favorite reference record (only optional if favoritableId &amp; favoritableType is pass in instead) (optional)
     * @param favoritableId The ID of the object to un-favorite {offerId, offerLocationId, retailerLocationId, categoryId} (this is required if favoriteId is NOT passed in) (optional)
     * @param favoritableType The type of the object to un-favorite {OFFER, OFFER_LOCATION, RETAILER_LOCATION, CATEGORY} (this is required if favoriteId is NOT passed in) (optional)
     * @return RequestConfig
     */
    fun deleteFavoriteRequestConfig(deviceId: kotlin.String?, accountId: kotlin.Long?, favoriteId: kotlin.Long?, favoritableId: kotlin.Long?, favoritableType: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (favoriteId != null) {
                    put("favoriteId", listOf(favoriteId.toString()))
                }
                if (favoritableId != null) {
                    put("favoritableId", listOf(favoritableId.toString()))
                }
                if (favoritableType != null) {
                    put("favoritableType", listOf(favoritableType.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/favorite/delete",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /favorite/get
     * Get Favorite
     * Retrieves a single favorited item.
     * @param favoriteId The ID of the favorite reference record
     * @param deviceId The unique ID given by the device (deviceId or accountId required) (optional)
     * @param accountId The account ID of the user (deviceId or accountId required) (optional)
     * @param latitude The current latitude of the user (optional)
     * @param longitude The current longitude of the user (optional)
     * @return WrappedResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getFavorite(favoriteId: kotlin.Long, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, latitude: kotlin.Double? = null, longitude: kotlin.Double? = null) : WrappedResponse {
        val localVarResponse = getFavoriteWithHttpInfo(favoriteId = favoriteId, deviceId = deviceId, accountId = accountId, latitude = latitude, longitude = longitude)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as WrappedResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /favorite/get
     * Get Favorite
     * Retrieves a single favorited item.
     * @param favoriteId The ID of the favorite reference record
     * @param deviceId The unique ID given by the device (deviceId or accountId required) (optional)
     * @param accountId The account ID of the user (deviceId or accountId required) (optional)
     * @param latitude The current latitude of the user (optional)
     * @param longitude The current longitude of the user (optional)
     * @return ApiResponse<WrappedResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getFavoriteWithHttpInfo(favoriteId: kotlin.Long, deviceId: kotlin.String?, accountId: kotlin.Long?, latitude: kotlin.Double?, longitude: kotlin.Double?) : ApiResponse<WrappedResponse?> {
        val localVariableConfig = getFavoriteRequestConfig(favoriteId = favoriteId, deviceId = deviceId, accountId = accountId, latitude = latitude, longitude = longitude)

        return request<Unit, WrappedResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getFavorite
     *
     * @param favoriteId The ID of the favorite reference record
     * @param deviceId The unique ID given by the device (deviceId or accountId required) (optional)
     * @param accountId The account ID of the user (deviceId or accountId required) (optional)
     * @param latitude The current latitude of the user (optional)
     * @param longitude The current longitude of the user (optional)
     * @return RequestConfig
     */
    fun getFavoriteRequestConfig(favoriteId: kotlin.Long, deviceId: kotlin.String?, accountId: kotlin.Long?, latitude: kotlin.Double?, longitude: kotlin.Double?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                put("favoriteId", listOf(favoriteId.toString()))
                if (latitude != null) {
                    put("latitude", listOf(latitude.toString()))
                }
                if (longitude != null) {
                    put("longitude", listOf(longitude.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/favorite/get",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter sortField
     */
     enum class SortFieldSearchFavorites(val value: kotlin.String) {
         @Json(name = "ID") ID("ID"),
         @Json(name = "CREATED") CREATED("CREATED"),
         @Json(name = "UPDATED") UPDATED("UPDATED"),
         @Json(name = "DELETED") DELETED("DELETED"),
         @Json(name = "SEARCH_TAGS") SEARCH_TAGS("SEARCH_TAGS"),
         @Json(name = "ACTIVE") ACTIVE("ACTIVE"),
         @Json(name = "DISPLAY") DISPLAY("DISPLAY");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /favorite/search
     * Search Favorites
     * Searches on the user&#39;s favorites.
     * @param favoritableType The type of the object to favorite {OFFER, OFFER_LOCATION, RETAILER_LOCATION, CATEGORY}
     * @param sortField Determines what to sort the results by {CREATED, UPDATED, DISPLAY}
     * @param descending Determines whether the results are in descending order
     * @param start The start index for pagination
     * @param limit The limit for pagination (there is a hard limit of 1000)
     * @param activeOnly Determines whether to only return active favorites
     * @param returnFullResponse Determines whether to return a detailed version of the response list
     * @param deviceId The unique ID given by the device (deviceId or accountId required) (optional)
     * @param accountId The account ID of the user (deviceId or accountId required) (optional)
     * @param connectionAccountId The ID of an account the user would like to view favorites for (optional)
     * @param secondaryType  (optional)
     * @param keyword The keyword to search for (optional)
     * @param latitude The current latitude of the user (optional)
     * @param longitude The current longitude of the user (optional)
     * @return SearchResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun searchFavorites(favoritableType: kotlin.String, sortField: SortFieldSearchFavorites, descending: kotlin.Boolean, start: kotlin.Int, limit: kotlin.Int, activeOnly: kotlin.Boolean, returnFullResponse: kotlin.Boolean, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, connectionAccountId: kotlin.Long? = null, secondaryType: kotlin.String? = null, keyword: kotlin.String? = null, latitude: kotlin.Double? = null, longitude: kotlin.Double? = null) : SearchResponse {
        val localVarResponse = searchFavoritesWithHttpInfo(favoritableType = favoritableType, sortField = sortField, descending = descending, start = start, limit = limit, activeOnly = activeOnly, returnFullResponse = returnFullResponse, deviceId = deviceId, accountId = accountId, connectionAccountId = connectionAccountId, secondaryType = secondaryType, keyword = keyword, latitude = latitude, longitude = longitude)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SearchResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /favorite/search
     * Search Favorites
     * Searches on the user&#39;s favorites.
     * @param favoritableType The type of the object to favorite {OFFER, OFFER_LOCATION, RETAILER_LOCATION, CATEGORY}
     * @param sortField Determines what to sort the results by {CREATED, UPDATED, DISPLAY}
     * @param descending Determines whether the results are in descending order
     * @param start The start index for pagination
     * @param limit The limit for pagination (there is a hard limit of 1000)
     * @param activeOnly Determines whether to only return active favorites
     * @param returnFullResponse Determines whether to return a detailed version of the response list
     * @param deviceId The unique ID given by the device (deviceId or accountId required) (optional)
     * @param accountId The account ID of the user (deviceId or accountId required) (optional)
     * @param connectionAccountId The ID of an account the user would like to view favorites for (optional)
     * @param secondaryType  (optional)
     * @param keyword The keyword to search for (optional)
     * @param latitude The current latitude of the user (optional)
     * @param longitude The current longitude of the user (optional)
     * @return ApiResponse<SearchResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun searchFavoritesWithHttpInfo(favoritableType: kotlin.String, sortField: SortFieldSearchFavorites, descending: kotlin.Boolean, start: kotlin.Int, limit: kotlin.Int, activeOnly: kotlin.Boolean, returnFullResponse: kotlin.Boolean, deviceId: kotlin.String?, accountId: kotlin.Long?, connectionAccountId: kotlin.Long?, secondaryType: kotlin.String?, keyword: kotlin.String?, latitude: kotlin.Double?, longitude: kotlin.Double?) : ApiResponse<SearchResponse?> {
        val localVariableConfig = searchFavoritesRequestConfig(favoritableType = favoritableType, sortField = sortField, descending = descending, start = start, limit = limit, activeOnly = activeOnly, returnFullResponse = returnFullResponse, deviceId = deviceId, accountId = accountId, connectionAccountId = connectionAccountId, secondaryType = secondaryType, keyword = keyword, latitude = latitude, longitude = longitude)

        return request<Unit, SearchResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation searchFavorites
     *
     * @param favoritableType The type of the object to favorite {OFFER, OFFER_LOCATION, RETAILER_LOCATION, CATEGORY}
     * @param sortField Determines what to sort the results by {CREATED, UPDATED, DISPLAY}
     * @param descending Determines whether the results are in descending order
     * @param start The start index for pagination
     * @param limit The limit for pagination (there is a hard limit of 1000)
     * @param activeOnly Determines whether to only return active favorites
     * @param returnFullResponse Determines whether to return a detailed version of the response list
     * @param deviceId The unique ID given by the device (deviceId or accountId required) (optional)
     * @param accountId The account ID of the user (deviceId or accountId required) (optional)
     * @param connectionAccountId The ID of an account the user would like to view favorites for (optional)
     * @param secondaryType  (optional)
     * @param keyword The keyword to search for (optional)
     * @param latitude The current latitude of the user (optional)
     * @param longitude The current longitude of the user (optional)
     * @return RequestConfig
     */
    fun searchFavoritesRequestConfig(favoritableType: kotlin.String, sortField: SortFieldSearchFavorites, descending: kotlin.Boolean, start: kotlin.Int, limit: kotlin.Int, activeOnly: kotlin.Boolean, returnFullResponse: kotlin.Boolean, deviceId: kotlin.String?, accountId: kotlin.Long?, connectionAccountId: kotlin.Long?, secondaryType: kotlin.String?, keyword: kotlin.String?, latitude: kotlin.Double?, longitude: kotlin.Double?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (connectionAccountId != null) {
                    put("connectionAccountId", listOf(connectionAccountId.toString()))
                }
                put("favoritableType", listOf(favoritableType.toString()))
                if (secondaryType != null) {
                    put("secondaryType", listOf(secondaryType.toString()))
                }
                if (keyword != null) {
                    put("keyword", listOf(keyword.toString()))
                }
                put("sortField", listOf(sortField.value))
                put("descending", listOf(descending.toString()))
                put("start", listOf(start.toString()))
                put("limit", listOf(limit.toString()))
                put("activeOnly", listOf(activeOnly.toString()))
                put("returnFullResponse", listOf(returnFullResponse.toString()))
                if (latitude != null) {
                    put("latitude", listOf(latitude.toString()))
                }
                if (longitude != null) {
                    put("longitude", listOf(longitude.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/favorite/search",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /favorite/whois
     * Who has Favorited
     * Searches for everyone that has favorited an item
     * @param favoritableId The ID of the favoritableType to search on
     * @param favoritableType The type of the object to favorite {OFFER, OFFER_LOCATION, RETAILER_LOCATION, CATEGORY}
     * @param start The start index for pagination
     * @param limit The limit for pagination
     * @param deviceId The unique ID given by the device (deviceId or accountId required) (optional)
     * @param accountId The account ID of the user (deviceId or accountId required) (optional)
     * @param latitude The current latitude of the user (optional)
     * @param longitude The current longitude of the user (optional)
     * @param keyword The keyword to limit that account list (optional)
     * @return kotlin.collections.List<AccountResponse>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun whoHasFavorited(favoritableId: kotlin.Long, favoritableType: kotlin.String, start: kotlin.Int, limit: kotlin.Int, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, latitude: kotlin.Double? = null, longitude: kotlin.Double? = null, keyword: kotlin.String? = null) : kotlin.collections.List<AccountResponse> {
        val localVarResponse = whoHasFavoritedWithHttpInfo(favoritableId = favoritableId, favoritableType = favoritableType, start = start, limit = limit, deviceId = deviceId, accountId = accountId, latitude = latitude, longitude = longitude, keyword = keyword)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<AccountResponse>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /favorite/whois
     * Who has Favorited
     * Searches for everyone that has favorited an item
     * @param favoritableId The ID of the favoritableType to search on
     * @param favoritableType The type of the object to favorite {OFFER, OFFER_LOCATION, RETAILER_LOCATION, CATEGORY}
     * @param start The start index for pagination
     * @param limit The limit for pagination
     * @param deviceId The unique ID given by the device (deviceId or accountId required) (optional)
     * @param accountId The account ID of the user (deviceId or accountId required) (optional)
     * @param latitude The current latitude of the user (optional)
     * @param longitude The current longitude of the user (optional)
     * @param keyword The keyword to limit that account list (optional)
     * @return ApiResponse<kotlin.collections.List<AccountResponse>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun whoHasFavoritedWithHttpInfo(favoritableId: kotlin.Long, favoritableType: kotlin.String, start: kotlin.Int, limit: kotlin.Int, deviceId: kotlin.String?, accountId: kotlin.Long?, latitude: kotlin.Double?, longitude: kotlin.Double?, keyword: kotlin.String?) : ApiResponse<kotlin.collections.List<AccountResponse>?> {
        val localVariableConfig = whoHasFavoritedRequestConfig(favoritableId = favoritableId, favoritableType = favoritableType, start = start, limit = limit, deviceId = deviceId, accountId = accountId, latitude = latitude, longitude = longitude, keyword = keyword)

        return request<Unit, kotlin.collections.List<AccountResponse>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation whoHasFavorited
     *
     * @param favoritableId The ID of the favoritableType to search on
     * @param favoritableType The type of the object to favorite {OFFER, OFFER_LOCATION, RETAILER_LOCATION, CATEGORY}
     * @param start The start index for pagination
     * @param limit The limit for pagination
     * @param deviceId The unique ID given by the device (deviceId or accountId required) (optional)
     * @param accountId The account ID of the user (deviceId or accountId required) (optional)
     * @param latitude The current latitude of the user (optional)
     * @param longitude The current longitude of the user (optional)
     * @param keyword The keyword to limit that account list (optional)
     * @return RequestConfig
     */
    fun whoHasFavoritedRequestConfig(favoritableId: kotlin.Long, favoritableType: kotlin.String, start: kotlin.Int, limit: kotlin.Int, deviceId: kotlin.String?, accountId: kotlin.Long?, latitude: kotlin.Double?, longitude: kotlin.Double?, keyword: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (latitude != null) {
                    put("latitude", listOf(latitude.toString()))
                }
                if (longitude != null) {
                    put("longitude", listOf(longitude.toString()))
                }
                put("favoritableId", listOf(favoritableId.toString()))
                put("favoritableType", listOf(favoritableType.toString()))
                if (keyword != null) {
                    put("keyword", listOf(keyword.toString()))
                }
                put("start", listOf(start.toString()))
                put("limit", listOf(limit.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/favorite/whois",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
