/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import org.openapitools.client.models.RegionLegSummary
import org.openapitools.client.models.ReportBatchResponse
import org.openapitools.client.models.ReportRegionLegSummaryBatchResponse
import org.openapitools.client.models.ReportResponse
import org.openapitools.client.models.SirqulResponse

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

open class ReportingApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://dev.sirqul.com/api/3.18")
        }
    }

    /**
     * enum for parameter status
     */
     enum class StatusCreateBatch(val value: kotlin.String) {
         @Json(name = "NEW") NEW("NEW"),
         @Json(name = "ERROR") ERROR("ERROR"),
         @Json(name = "COMPLETE") COMPLETE("COMPLETE"),
         @Json(name = "PARSE_ERROR") PARSE_ERROR("PARSE_ERROR"),
         @Json(name = "PROCESSING") PROCESSING("PROCESSING"),
         @Json(name = "DUPLICATE") DUPLICATE("DUPLICATE"),
         @Json(name = "SAVEONLY") SAVEONLY("SAVEONLY");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * POST /report/batch/create
     * Create Offline Report
     * Create an entry for the batch for offline report
     * @param accountId The account id of the user for passing account related params
     * @param status the status of the report
     * @param previewLimit the limit on how much you can preview of the batch report
     * @param appKey The application key for passing application related params (optional)
     * @param endpoint  (optional)
     * @param parameters a json structure list of the parameter values, example: &#x60;&#x60;&#x60;json {   \&quot;string\&quot;:\&quot;value\&quot;,    \&quot;number\&quot;:3.345,   \&quot;date\&quot;:\&quot;2014-05-01 00:00:00\&quot; } &#x60;&#x60;&#x60;  (optional)
     * @param name name of the batch report (optional)
     * @param startDate the start date of the batch report (optional)
     * @param endDate the end date of the batch report (optional)
     * @param description the description of the batch report (optional)
     * @param pageUrl  (optional)
     * @return ReportBatchResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createBatch(accountId: kotlin.Long, status: StatusCreateBatch, previewLimit: kotlin.Int, appKey: kotlin.String? = null, endpoint: kotlin.String? = null, parameters: kotlin.String? = null, name: kotlin.String? = null, startDate: kotlin.Long? = null, endDate: kotlin.Long? = null, description: kotlin.String? = null, pageUrl: kotlin.String? = null) : ReportBatchResponse {
        val localVarResponse = createBatchWithHttpInfo(accountId = accountId, status = status, previewLimit = previewLimit, appKey = appKey, endpoint = endpoint, parameters = parameters, name = name, startDate = startDate, endDate = endDate, description = description, pageUrl = pageUrl)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ReportBatchResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /report/batch/create
     * Create Offline Report
     * Create an entry for the batch for offline report
     * @param accountId The account id of the user for passing account related params
     * @param status the status of the report
     * @param previewLimit the limit on how much you can preview of the batch report
     * @param appKey The application key for passing application related params (optional)
     * @param endpoint  (optional)
     * @param parameters a json structure list of the parameter values, example: &#x60;&#x60;&#x60;json {   \&quot;string\&quot;:\&quot;value\&quot;,    \&quot;number\&quot;:3.345,   \&quot;date\&quot;:\&quot;2014-05-01 00:00:00\&quot; } &#x60;&#x60;&#x60;  (optional)
     * @param name name of the batch report (optional)
     * @param startDate the start date of the batch report (optional)
     * @param endDate the end date of the batch report (optional)
     * @param description the description of the batch report (optional)
     * @param pageUrl  (optional)
     * @return ApiResponse<ReportBatchResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createBatchWithHttpInfo(accountId: kotlin.Long, status: StatusCreateBatch, previewLimit: kotlin.Int, appKey: kotlin.String?, endpoint: kotlin.String?, parameters: kotlin.String?, name: kotlin.String?, startDate: kotlin.Long?, endDate: kotlin.Long?, description: kotlin.String?, pageUrl: kotlin.String?) : ApiResponse<ReportBatchResponse?> {
        val localVariableConfig = createBatchRequestConfig(accountId = accountId, status = status, previewLimit = previewLimit, appKey = appKey, endpoint = endpoint, parameters = parameters, name = name, startDate = startDate, endDate = endDate, description = description, pageUrl = pageUrl)

        return request<Unit, ReportBatchResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createBatch
     *
     * @param accountId The account id of the user for passing account related params
     * @param status the status of the report
     * @param previewLimit the limit on how much you can preview of the batch report
     * @param appKey The application key for passing application related params (optional)
     * @param endpoint  (optional)
     * @param parameters a json structure list of the parameter values, example: &#x60;&#x60;&#x60;json {   \&quot;string\&quot;:\&quot;value\&quot;,    \&quot;number\&quot;:3.345,   \&quot;date\&quot;:\&quot;2014-05-01 00:00:00\&quot; } &#x60;&#x60;&#x60;  (optional)
     * @param name name of the batch report (optional)
     * @param startDate the start date of the batch report (optional)
     * @param endDate the end date of the batch report (optional)
     * @param description the description of the batch report (optional)
     * @param pageUrl  (optional)
     * @return RequestConfig
     */
    fun createBatchRequestConfig(accountId: kotlin.Long, status: StatusCreateBatch, previewLimit: kotlin.Int, appKey: kotlin.String?, endpoint: kotlin.String?, parameters: kotlin.String?, name: kotlin.String?, startDate: kotlin.Long?, endDate: kotlin.Long?, description: kotlin.String?, pageUrl: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                if (appKey != null) {
                    put("appKey", listOf(appKey.toString()))
                }
                put("status", listOf(status.value))
                if (endpoint != null) {
                    put("endpoint", listOf(endpoint.toString()))
                }
                if (parameters != null) {
                    put("parameters", listOf(parameters.toString()))
                }
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (startDate != null) {
                    put("startDate", listOf(startDate.toString()))
                }
                if (endDate != null) {
                    put("endDate", listOf(endDate.toString()))
                }
                if (description != null) {
                    put("description", listOf(description.toString()))
                }
                put("previewLimit", listOf(previewLimit.toString()))
                if (pageUrl != null) {
                    put("pageUrl", listOf(pageUrl.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/report/batch/create",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /report/region/summary/batch
     * Create Offline Report
     * Create an entry for the batch for offline report
     * @param body  (optional)
     * @return ReportRegionLegSummaryBatchResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createRegionLegSummaryBatch(body: kotlin.collections.List<RegionLegSummary>? = null) : ReportRegionLegSummaryBatchResponse {
        val localVarResponse = createRegionLegSummaryBatchWithHttpInfo(body = body)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ReportRegionLegSummaryBatchResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /report/region/summary/batch
     * Create Offline Report
     * Create an entry for the batch for offline report
     * @param body  (optional)
     * @return ApiResponse<ReportRegionLegSummaryBatchResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createRegionLegSummaryBatchWithHttpInfo(body: kotlin.collections.List<RegionLegSummary>?) : ApiResponse<ReportRegionLegSummaryBatchResponse?> {
        val localVariableConfig = createRegionLegSummaryBatchRequestConfig(body = body)

        return request<kotlin.collections.List<RegionLegSummary>, ReportRegionLegSummaryBatchResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createRegionLegSummaryBatch
     *
     * @param body  (optional)
     * @return RequestConfig
     */
    fun createRegionLegSummaryBatchRequestConfig(body: kotlin.collections.List<RegionLegSummary>?) : RequestConfig<kotlin.collections.List<RegionLegSummary>> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/report/region/summary/batch",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /report/batch/delete
     * Delete Offline Report
     * Deletes a batch report.
     * @param accountId the id of the account
     * @param batchId the id of the batch to delete
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteBatch(accountId: kotlin.Long, batchId: kotlin.Long) : SirqulResponse {
        val localVarResponse = deleteBatchWithHttpInfo(accountId = accountId, batchId = batchId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /report/batch/delete
     * Delete Offline Report
     * Deletes a batch report.
     * @param accountId the id of the account
     * @param batchId the id of the batch to delete
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteBatchWithHttpInfo(accountId: kotlin.Long, batchId: kotlin.Long) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = deleteBatchRequestConfig(accountId = accountId, batchId = batchId)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteBatch
     *
     * @param accountId the id of the account
     * @param batchId the id of the batch to delete
     * @return RequestConfig
     */
    fun deleteBatchRequestConfig(accountId: kotlin.Long, batchId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("batchId", listOf(batchId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/report/batch/delete",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /report/batch/get
     * Get Offline Report
     * Checks status of batch report.
     * @param accountId the id of the logged in user
     * @param batchId returned by /report/batch/create
     * @param allResults whether to return all batch results or not
     * @return ReportBatchResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getReportBatch(accountId: kotlin.Long, batchId: kotlin.Long, allResults: kotlin.Boolean) : ReportBatchResponse {
        val localVarResponse = getReportBatchWithHttpInfo(accountId = accountId, batchId = batchId, allResults = allResults)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ReportBatchResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /report/batch/get
     * Get Offline Report
     * Checks status of batch report.
     * @param accountId the id of the logged in user
     * @param batchId returned by /report/batch/create
     * @param allResults whether to return all batch results or not
     * @return ApiResponse<ReportBatchResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getReportBatchWithHttpInfo(accountId: kotlin.Long, batchId: kotlin.Long, allResults: kotlin.Boolean) : ApiResponse<ReportBatchResponse?> {
        val localVariableConfig = getReportBatchRequestConfig(accountId = accountId, batchId = batchId, allResults = allResults)

        return request<Unit, ReportBatchResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getReportBatch
     *
     * @param accountId the id of the logged in user
     * @param batchId returned by /report/batch/create
     * @param allResults whether to return all batch results or not
     * @return RequestConfig
     */
    fun getReportBatchRequestConfig(accountId: kotlin.Long, batchId: kotlin.Long, allResults: kotlin.Boolean) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("batchId", listOf(batchId.toString()))
                put("allResults", listOf(allResults.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/report/batch/get",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter responseFormat
     */
     enum class ResponseFormatRunReport(val value: kotlin.String) {
         @Json(name = "HTML") HTML("HTML"),
         @Json(name = "XML") XML("XML"),
         @Json(name = "JSON") JSON("JSON"),
         @Json(name = "CSV") CSV("CSV");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * POST /report/run
     * Run Report
     *  This endpoint allows you to run a set of predefined reports that can be used to understand your users&#39; behavior as well as trends within your application.
     * @param desc If true then descending order, false is ascending
     * @param accountId The account id of the user for passing account related params (optional)
     * @param query The named identifier of the query (optional)
     * @param parameters Parameter values used in the query in JSON format, example: &#x60;&#x60;&#x60;json {   \&quot;string\&quot;:\&quot;value\&quot;,    \&quot;number\&quot;:3.345,   \&quot;date\&quot;:\&quot;2014-05-01 00:00:00\&quot; } &#x60;&#x60;&#x60;  (optional)
     * @param order The order to use, must be a column name (see response results for list of column names) (optional)
     * @param start The start of the pagination (optional)
     * @param limit The limit of the pagination (optional)
     * @param responseFormat Determines what response format to return. Options are: JSON or CSV (optional)
     * @return ReportResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun runReport(desc: kotlin.Boolean, accountId: kotlin.Long? = null, query: kotlin.String? = null, parameters: kotlin.String? = null, order: kotlin.String? = null, start: kotlin.Long? = null, limit: kotlin.Long? = null, responseFormat: ResponseFormatRunReport? = null) : ReportResponse {
        val localVarResponse = runReportWithHttpInfo(desc = desc, accountId = accountId, query = query, parameters = parameters, order = order, start = start, limit = limit, responseFormat = responseFormat)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ReportResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /report/run
     * Run Report
     *  This endpoint allows you to run a set of predefined reports that can be used to understand your users&#39; behavior as well as trends within your application.
     * @param desc If true then descending order, false is ascending
     * @param accountId The account id of the user for passing account related params (optional)
     * @param query The named identifier of the query (optional)
     * @param parameters Parameter values used in the query in JSON format, example: &#x60;&#x60;&#x60;json {   \&quot;string\&quot;:\&quot;value\&quot;,    \&quot;number\&quot;:3.345,   \&quot;date\&quot;:\&quot;2014-05-01 00:00:00\&quot; } &#x60;&#x60;&#x60;  (optional)
     * @param order The order to use, must be a column name (see response results for list of column names) (optional)
     * @param start The start of the pagination (optional)
     * @param limit The limit of the pagination (optional)
     * @param responseFormat Determines what response format to return. Options are: JSON or CSV (optional)
     * @return ApiResponse<ReportResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun runReportWithHttpInfo(desc: kotlin.Boolean, accountId: kotlin.Long?, query: kotlin.String?, parameters: kotlin.String?, order: kotlin.String?, start: kotlin.Long?, limit: kotlin.Long?, responseFormat: ResponseFormatRunReport?) : ApiResponse<ReportResponse?> {
        val localVariableConfig = runReportRequestConfig(desc = desc, accountId = accountId, query = query, parameters = parameters, order = order, start = start, limit = limit, responseFormat = responseFormat)

        return request<Unit, ReportResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation runReport
     *
     * @param desc If true then descending order, false is ascending
     * @param accountId The account id of the user for passing account related params (optional)
     * @param query The named identifier of the query (optional)
     * @param parameters Parameter values used in the query in JSON format, example: &#x60;&#x60;&#x60;json {   \&quot;string\&quot;:\&quot;value\&quot;,    \&quot;number\&quot;:3.345,   \&quot;date\&quot;:\&quot;2014-05-01 00:00:00\&quot; } &#x60;&#x60;&#x60;  (optional)
     * @param order The order to use, must be a column name (see response results for list of column names) (optional)
     * @param start The start of the pagination (optional)
     * @param limit The limit of the pagination (optional)
     * @param responseFormat Determines what response format to return. Options are: JSON or CSV (optional)
     * @return RequestConfig
     */
    fun runReportRequestConfig(desc: kotlin.Boolean, accountId: kotlin.Long?, query: kotlin.String?, parameters: kotlin.String?, order: kotlin.String?, start: kotlin.Long?, limit: kotlin.Long?, responseFormat: ResponseFormatRunReport?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (query != null) {
                    put("query", listOf(query.toString()))
                }
                if (parameters != null) {
                    put("parameters", listOf(parameters.toString()))
                }
                if (order != null) {
                    put("order", listOf(order.toString()))
                }
                put("desc", listOf(desc.toString()))
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (responseFormat != null) {
                    put("responseFormat", listOf(responseFormat.value))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/report/run",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter status
     */
     enum class StatusSearchBatch(val value: kotlin.String) {
         @Json(name = "NEW") NEW("NEW"),
         @Json(name = "ERROR") ERROR("ERROR"),
         @Json(name = "COMPLETE") COMPLETE("COMPLETE"),
         @Json(name = "PARSE_ERROR") PARSE_ERROR("PARSE_ERROR"),
         @Json(name = "PROCESSING") PROCESSING("PROCESSING"),
         @Json(name = "DUPLICATE") DUPLICATE("DUPLICATE"),
         @Json(name = "SAVEONLY") SAVEONLY("SAVEONLY");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /report/batch/search
     * Search Offline Reports
     * Retrieves batches for a user..
     * @param accountId the id of the account logged in
     * @param start the start of the index and/or pagination
     * @param limit the limit of the index and/or pagination
     * @param names the names of the report batch to search on (optional)
     * @param appKey the application key (optional)
     * @param status the report batch status (optional)
     * @param globalAppSearch the global app to search on (optional)
     * @param startDate the start date of the report batch to search on (optional)
     * @param endDate the end date of the report batch to search on (optional)
     * @return kotlin.collections.List<ReportBatchResponse>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun searchBatch(accountId: kotlin.Long, start: kotlin.Int, limit: kotlin.Int, names: kotlin.String? = null, appKey: kotlin.String? = null, status: StatusSearchBatch? = null, globalAppSearch: kotlin.Boolean? = null, startDate: kotlin.Long? = null, endDate: kotlin.Long? = null) : kotlin.collections.List<ReportBatchResponse> {
        val localVarResponse = searchBatchWithHttpInfo(accountId = accountId, start = start, limit = limit, names = names, appKey = appKey, status = status, globalAppSearch = globalAppSearch, startDate = startDate, endDate = endDate)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<ReportBatchResponse>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /report/batch/search
     * Search Offline Reports
     * Retrieves batches for a user..
     * @param accountId the id of the account logged in
     * @param start the start of the index and/or pagination
     * @param limit the limit of the index and/or pagination
     * @param names the names of the report batch to search on (optional)
     * @param appKey the application key (optional)
     * @param status the report batch status (optional)
     * @param globalAppSearch the global app to search on (optional)
     * @param startDate the start date of the report batch to search on (optional)
     * @param endDate the end date of the report batch to search on (optional)
     * @return ApiResponse<kotlin.collections.List<ReportBatchResponse>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun searchBatchWithHttpInfo(accountId: kotlin.Long, start: kotlin.Int, limit: kotlin.Int, names: kotlin.String?, appKey: kotlin.String?, status: StatusSearchBatch?, globalAppSearch: kotlin.Boolean?, startDate: kotlin.Long?, endDate: kotlin.Long?) : ApiResponse<kotlin.collections.List<ReportBatchResponse>?> {
        val localVariableConfig = searchBatchRequestConfig(accountId = accountId, start = start, limit = limit, names = names, appKey = appKey, status = status, globalAppSearch = globalAppSearch, startDate = startDate, endDate = endDate)

        return request<Unit, kotlin.collections.List<ReportBatchResponse>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation searchBatch
     *
     * @param accountId the id of the account logged in
     * @param start the start of the index and/or pagination
     * @param limit the limit of the index and/or pagination
     * @param names the names of the report batch to search on (optional)
     * @param appKey the application key (optional)
     * @param status the report batch status (optional)
     * @param globalAppSearch the global app to search on (optional)
     * @param startDate the start date of the report batch to search on (optional)
     * @param endDate the end date of the report batch to search on (optional)
     * @return RequestConfig
     */
    fun searchBatchRequestConfig(accountId: kotlin.Long, start: kotlin.Int, limit: kotlin.Int, names: kotlin.String?, appKey: kotlin.String?, status: StatusSearchBatch?, globalAppSearch: kotlin.Boolean?, startDate: kotlin.Long?, endDate: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                if (names != null) {
                    put("names", listOf(names.toString()))
                }
                if (appKey != null) {
                    put("appKey", listOf(appKey.toString()))
                }
                if (status != null) {
                    put("status", listOf(status.value))
                }
                if (globalAppSearch != null) {
                    put("globalAppSearch", listOf(globalAppSearch.toString()))
                }
                if (startDate != null) {
                    put("startDate", listOf(startDate.toString()))
                }
                if (endDate != null) {
                    put("endDate", listOf(endDate.toString()))
                }
                put("start", listOf(start.toString()))
                put("limit", listOf(limit.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/report/batch/search",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
