/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import org.openapitools.client.models.AccountLoginResponse
import org.openapitools.client.models.RetailerFullResponse
import org.openapitools.client.models.RetailerResponse
import org.openapitools.client.models.SirqulResponse

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

open class RetailerApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://dev.sirqul.com/api/3.18")
        }
    }

    /**
     * enum for parameter visibility
     */
     enum class VisibilityCreateRetailer(val value: kotlin.String) {
         @Json(name = "PUBLIC") PUBLIC("PUBLIC"),
         @Json(name = "PRIVATE") PRIVATE("PRIVATE"),
         @Json(name = "FRIENDS") FRIENDS("FRIENDS");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter responseFormat
     */
     enum class ResponseFormatCreateRetailer(val value: kotlin.String) {
         @Json(name = "HTML") HTML("HTML"),
         @Json(name = "XML") XML("XML"),
         @Json(name = "JSON") JSON("JSON"),
         @Json(name = "CSV") CSV("CSV");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * POST /retailer/create
     * Create Retailer
     * Create a retailer record. A billable entity must be created first before a retailer record can be made.
     * @param name The name of the retailer
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param streetAddress The street address of the retailer (optional)
     * @param streetAddress2 Additional address information (such as a suite number, floor number, building name, or PO Box) (optional)
     * @param city The city of the retailer (optional)
     * @param state The state of the retailer (optional)
     * @param postalCode The postal code of the retailer (optional)
     * @param country the country of the retailer (optional)
     * @param businessPhone The business phone number of the retailer (optional)
     * @param businessPhoneExt The business phone extension of the retailer (optional)
     * @param website The website of the retailer (optional)
     * @param email The email of the retailer (optional)
     * @param facebookUrl The facebook URL of the retailer (optional)
     * @param twitterUrl The twitter URL of the retailer (optional)
     * @param logo The retailer logo sent as a multipart binary file (you can optionally use logoAssetId if the asset has already been uploaded before) (optional)
     * @param logoAssetId The retailer logo asset id (optional)
     * @param picture1 Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture1AssetId if the asset has already been uploaded before) (optional)
     * @param picture1AssetId An asset id (optional)
     * @param picture2 Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture2AssetId if the asset has already been uploaded before) (optional)
     * @param picture2AssetId An asset id (optional)
     * @param categoryIds Comma separated list of category IDs used to filter retailers by categories (optional)
     * @param categoryIdsToAdd Comma separated list of category IDs to add to the retailer (optional)
     * @param categoryIdsToRemove Comma separated list of category IDs to remove from the retailer (optional)
     * @param filterIds Comma separated list of filter IDs used to filter retailers (optional)
     * @param latitude the latitude of the retailer (optional)
     * @param longitude the longitude of the retailer (optional)
     * @param metaData External custom client defined data (optional)
     * @param searchTags External custom search keywords (optional)
     * @param retailerType External custom type identifier (optional)
     * @param visibility  (optional)
     * @param createDefaultLocation Determines whether to create a default location using the retailer information (optional)
     * @param responseFormat The format of the returned response {JSON // default , HTML // for Dojo support when uploading assets} (optional)
     * @return RetailerFullResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createRetailer(name: kotlin.String, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, streetAddress: kotlin.String? = null, streetAddress2: kotlin.String? = null, city: kotlin.String? = null, state: kotlin.String? = null, postalCode: kotlin.String? = null, country: kotlin.String? = null, businessPhone: kotlin.String? = null, businessPhoneExt: kotlin.String? = null, website: kotlin.String? = null, email: kotlin.String? = null, facebookUrl: kotlin.String? = null, twitterUrl: kotlin.String? = null, logo: java.io.File? = null, logoAssetId: kotlin.Long? = null, picture1: java.io.File? = null, picture1AssetId: kotlin.Long? = null, picture2: java.io.File? = null, picture2AssetId: kotlin.Long? = null, categoryIds: kotlin.String? = null, categoryIdsToAdd: kotlin.String? = null, categoryIdsToRemove: kotlin.String? = null, filterIds: kotlin.String? = null, latitude: kotlin.Double? = null, longitude: kotlin.Double? = null, metaData: kotlin.String? = null, searchTags: kotlin.String? = null, retailerType: kotlin.String? = null, visibility: VisibilityCreateRetailer? = null, createDefaultLocation: kotlin.Boolean? = null, responseFormat: ResponseFormatCreateRetailer? = null) : RetailerFullResponse {
        val localVarResponse = createRetailerWithHttpInfo(name = name, deviceId = deviceId, accountId = accountId, streetAddress = streetAddress, streetAddress2 = streetAddress2, city = city, state = state, postalCode = postalCode, country = country, businessPhone = businessPhone, businessPhoneExt = businessPhoneExt, website = website, email = email, facebookUrl = facebookUrl, twitterUrl = twitterUrl, logo = logo, logoAssetId = logoAssetId, picture1 = picture1, picture1AssetId = picture1AssetId, picture2 = picture2, picture2AssetId = picture2AssetId, categoryIds = categoryIds, categoryIdsToAdd = categoryIdsToAdd, categoryIdsToRemove = categoryIdsToRemove, filterIds = filterIds, latitude = latitude, longitude = longitude, metaData = metaData, searchTags = searchTags, retailerType = retailerType, visibility = visibility, createDefaultLocation = createDefaultLocation, responseFormat = responseFormat)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RetailerFullResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /retailer/create
     * Create Retailer
     * Create a retailer record. A billable entity must be created first before a retailer record can be made.
     * @param name The name of the retailer
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param streetAddress The street address of the retailer (optional)
     * @param streetAddress2 Additional address information (such as a suite number, floor number, building name, or PO Box) (optional)
     * @param city The city of the retailer (optional)
     * @param state The state of the retailer (optional)
     * @param postalCode The postal code of the retailer (optional)
     * @param country the country of the retailer (optional)
     * @param businessPhone The business phone number of the retailer (optional)
     * @param businessPhoneExt The business phone extension of the retailer (optional)
     * @param website The website of the retailer (optional)
     * @param email The email of the retailer (optional)
     * @param facebookUrl The facebook URL of the retailer (optional)
     * @param twitterUrl The twitter URL of the retailer (optional)
     * @param logo The retailer logo sent as a multipart binary file (you can optionally use logoAssetId if the asset has already been uploaded before) (optional)
     * @param logoAssetId The retailer logo asset id (optional)
     * @param picture1 Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture1AssetId if the asset has already been uploaded before) (optional)
     * @param picture1AssetId An asset id (optional)
     * @param picture2 Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture2AssetId if the asset has already been uploaded before) (optional)
     * @param picture2AssetId An asset id (optional)
     * @param categoryIds Comma separated list of category IDs used to filter retailers by categories (optional)
     * @param categoryIdsToAdd Comma separated list of category IDs to add to the retailer (optional)
     * @param categoryIdsToRemove Comma separated list of category IDs to remove from the retailer (optional)
     * @param filterIds Comma separated list of filter IDs used to filter retailers (optional)
     * @param latitude the latitude of the retailer (optional)
     * @param longitude the longitude of the retailer (optional)
     * @param metaData External custom client defined data (optional)
     * @param searchTags External custom search keywords (optional)
     * @param retailerType External custom type identifier (optional)
     * @param visibility  (optional)
     * @param createDefaultLocation Determines whether to create a default location using the retailer information (optional)
     * @param responseFormat The format of the returned response {JSON // default , HTML // for Dojo support when uploading assets} (optional)
     * @return ApiResponse<RetailerFullResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createRetailerWithHttpInfo(name: kotlin.String, deviceId: kotlin.String?, accountId: kotlin.Long?, streetAddress: kotlin.String?, streetAddress2: kotlin.String?, city: kotlin.String?, state: kotlin.String?, postalCode: kotlin.String?, country: kotlin.String?, businessPhone: kotlin.String?, businessPhoneExt: kotlin.String?, website: kotlin.String?, email: kotlin.String?, facebookUrl: kotlin.String?, twitterUrl: kotlin.String?, logo: java.io.File?, logoAssetId: kotlin.Long?, picture1: java.io.File?, picture1AssetId: kotlin.Long?, picture2: java.io.File?, picture2AssetId: kotlin.Long?, categoryIds: kotlin.String?, categoryIdsToAdd: kotlin.String?, categoryIdsToRemove: kotlin.String?, filterIds: kotlin.String?, latitude: kotlin.Double?, longitude: kotlin.Double?, metaData: kotlin.String?, searchTags: kotlin.String?, retailerType: kotlin.String?, visibility: VisibilityCreateRetailer?, createDefaultLocation: kotlin.Boolean?, responseFormat: ResponseFormatCreateRetailer?) : ApiResponse<RetailerFullResponse?> {
        val localVariableConfig = createRetailerRequestConfig(name = name, deviceId = deviceId, accountId = accountId, streetAddress = streetAddress, streetAddress2 = streetAddress2, city = city, state = state, postalCode = postalCode, country = country, businessPhone = businessPhone, businessPhoneExt = businessPhoneExt, website = website, email = email, facebookUrl = facebookUrl, twitterUrl = twitterUrl, logo = logo, logoAssetId = logoAssetId, picture1 = picture1, picture1AssetId = picture1AssetId, picture2 = picture2, picture2AssetId = picture2AssetId, categoryIds = categoryIds, categoryIdsToAdd = categoryIdsToAdd, categoryIdsToRemove = categoryIdsToRemove, filterIds = filterIds, latitude = latitude, longitude = longitude, metaData = metaData, searchTags = searchTags, retailerType = retailerType, visibility = visibility, createDefaultLocation = createDefaultLocation, responseFormat = responseFormat)

        return request<Unit, RetailerFullResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createRetailer
     *
     * @param name The name of the retailer
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param streetAddress The street address of the retailer (optional)
     * @param streetAddress2 Additional address information (such as a suite number, floor number, building name, or PO Box) (optional)
     * @param city The city of the retailer (optional)
     * @param state The state of the retailer (optional)
     * @param postalCode The postal code of the retailer (optional)
     * @param country the country of the retailer (optional)
     * @param businessPhone The business phone number of the retailer (optional)
     * @param businessPhoneExt The business phone extension of the retailer (optional)
     * @param website The website of the retailer (optional)
     * @param email The email of the retailer (optional)
     * @param facebookUrl The facebook URL of the retailer (optional)
     * @param twitterUrl The twitter URL of the retailer (optional)
     * @param logo The retailer logo sent as a multipart binary file (you can optionally use logoAssetId if the asset has already been uploaded before) (optional)
     * @param logoAssetId The retailer logo asset id (optional)
     * @param picture1 Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture1AssetId if the asset has already been uploaded before) (optional)
     * @param picture1AssetId An asset id (optional)
     * @param picture2 Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture2AssetId if the asset has already been uploaded before) (optional)
     * @param picture2AssetId An asset id (optional)
     * @param categoryIds Comma separated list of category IDs used to filter retailers by categories (optional)
     * @param categoryIdsToAdd Comma separated list of category IDs to add to the retailer (optional)
     * @param categoryIdsToRemove Comma separated list of category IDs to remove from the retailer (optional)
     * @param filterIds Comma separated list of filter IDs used to filter retailers (optional)
     * @param latitude the latitude of the retailer (optional)
     * @param longitude the longitude of the retailer (optional)
     * @param metaData External custom client defined data (optional)
     * @param searchTags External custom search keywords (optional)
     * @param retailerType External custom type identifier (optional)
     * @param visibility  (optional)
     * @param createDefaultLocation Determines whether to create a default location using the retailer information (optional)
     * @param responseFormat The format of the returned response {JSON // default , HTML // for Dojo support when uploading assets} (optional)
     * @return RequestConfig
     */
    fun createRetailerRequestConfig(name: kotlin.String, deviceId: kotlin.String?, accountId: kotlin.Long?, streetAddress: kotlin.String?, streetAddress2: kotlin.String?, city: kotlin.String?, state: kotlin.String?, postalCode: kotlin.String?, country: kotlin.String?, businessPhone: kotlin.String?, businessPhoneExt: kotlin.String?, website: kotlin.String?, email: kotlin.String?, facebookUrl: kotlin.String?, twitterUrl: kotlin.String?, logo: java.io.File?, logoAssetId: kotlin.Long?, picture1: java.io.File?, picture1AssetId: kotlin.Long?, picture2: java.io.File?, picture2AssetId: kotlin.Long?, categoryIds: kotlin.String?, categoryIdsToAdd: kotlin.String?, categoryIdsToRemove: kotlin.String?, filterIds: kotlin.String?, latitude: kotlin.Double?, longitude: kotlin.Double?, metaData: kotlin.String?, searchTags: kotlin.String?, retailerType: kotlin.String?, visibility: VisibilityCreateRetailer?, createDefaultLocation: kotlin.Boolean?, responseFormat: ResponseFormatCreateRetailer?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                put("name", listOf(name.toString()))
                if (streetAddress != null) {
                    put("streetAddress", listOf(streetAddress.toString()))
                }
                if (streetAddress2 != null) {
                    put("streetAddress2", listOf(streetAddress2.toString()))
                }
                if (city != null) {
                    put("city", listOf(city.toString()))
                }
                if (state != null) {
                    put("state", listOf(state.toString()))
                }
                if (postalCode != null) {
                    put("postalCode", listOf(postalCode.toString()))
                }
                if (country != null) {
                    put("country", listOf(country.toString()))
                }
                if (businessPhone != null) {
                    put("businessPhone", listOf(businessPhone.toString()))
                }
                if (businessPhoneExt != null) {
                    put("businessPhoneExt", listOf(businessPhoneExt.toString()))
                }
                if (website != null) {
                    put("website", listOf(website.toString()))
                }
                if (email != null) {
                    put("email", listOf(email.toString()))
                }
                if (facebookUrl != null) {
                    put("facebookUrl", listOf(facebookUrl.toString()))
                }
                if (twitterUrl != null) {
                    put("twitterUrl", listOf(twitterUrl.toString()))
                }
                if (logo != null) {
                    put("logo", listOf(logo.toString()))
                }
                if (logoAssetId != null) {
                    put("logoAssetId", listOf(logoAssetId.toString()))
                }
                if (picture1 != null) {
                    put("picture1", listOf(picture1.toString()))
                }
                if (picture1AssetId != null) {
                    put("picture1AssetId", listOf(picture1AssetId.toString()))
                }
                if (picture2 != null) {
                    put("picture2", listOf(picture2.toString()))
                }
                if (picture2AssetId != null) {
                    put("picture2AssetId", listOf(picture2AssetId.toString()))
                }
                if (categoryIds != null) {
                    put("categoryIds", listOf(categoryIds.toString()))
                }
                if (categoryIdsToAdd != null) {
                    put("categoryIdsToAdd", listOf(categoryIdsToAdd.toString()))
                }
                if (categoryIdsToRemove != null) {
                    put("categoryIdsToRemove", listOf(categoryIdsToRemove.toString()))
                }
                if (filterIds != null) {
                    put("filterIds", listOf(filterIds.toString()))
                }
                if (latitude != null) {
                    put("latitude", listOf(latitude.toString()))
                }
                if (longitude != null) {
                    put("longitude", listOf(longitude.toString()))
                }
                if (metaData != null) {
                    put("metaData", listOf(metaData.toString()))
                }
                if (searchTags != null) {
                    put("searchTags", listOf(searchTags.toString()))
                }
                if (retailerType != null) {
                    put("retailerType", listOf(retailerType.toString()))
                }
                if (visibility != null) {
                    put("visibility", listOf(visibility.value))
                }
                if (createDefaultLocation != null) {
                    put("createDefaultLocation", listOf(createDefaultLocation.toString()))
                }
                if (responseFormat != null) {
                    put("responseFormat", listOf(responseFormat.value))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/retailer/create",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /retailer/delete
     * Delete Retailer
     * Set the deleted timestamp to current time.
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account used to perform the delete, must have rights to edit the retailer. (optional)
     * @param retailerId The ID of the retailer to be deleted (optional)
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteRetailer(deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, retailerId: kotlin.Long? = null) : SirqulResponse {
        val localVarResponse = deleteRetailerWithHttpInfo(deviceId = deviceId, accountId = accountId, retailerId = retailerId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /retailer/delete
     * Delete Retailer
     * Set the deleted timestamp to current time.
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account used to perform the delete, must have rights to edit the retailer. (optional)
     * @param retailerId The ID of the retailer to be deleted (optional)
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteRetailerWithHttpInfo(deviceId: kotlin.String?, accountId: kotlin.Long?, retailerId: kotlin.Long?) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = deleteRetailerRequestConfig(deviceId = deviceId, accountId = accountId, retailerId = retailerId)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteRetailer
     *
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account used to perform the delete, must have rights to edit the retailer. (optional)
     * @param retailerId The ID of the retailer to be deleted (optional)
     * @return RequestConfig
     */
    fun deleteRetailerRequestConfig(deviceId: kotlin.String?, accountId: kotlin.Long?, retailerId: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (retailerId != null) {
                    put("retailerId", listOf(retailerId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/retailer/delete",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /retailer/get
     * Get Retailer
     * Gets a retailer. Only the owner and the employees of a retailer have access to view its information.
     * @param retailerId the ID of the retailer
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param includeCounts Determines whether to include counts in the response (default true) (optional)
     * @return RetailerFullResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getRetailer(retailerId: kotlin.Long, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, includeCounts: kotlin.Boolean? = null) : RetailerFullResponse {
        val localVarResponse = getRetailerWithHttpInfo(retailerId = retailerId, deviceId = deviceId, accountId = accountId, includeCounts = includeCounts)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RetailerFullResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /retailer/get
     * Get Retailer
     * Gets a retailer. Only the owner and the employees of a retailer have access to view its information.
     * @param retailerId the ID of the retailer
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param includeCounts Determines whether to include counts in the response (default true) (optional)
     * @return ApiResponse<RetailerFullResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getRetailerWithHttpInfo(retailerId: kotlin.Long, deviceId: kotlin.String?, accountId: kotlin.Long?, includeCounts: kotlin.Boolean?) : ApiResponse<RetailerFullResponse?> {
        val localVariableConfig = getRetailerRequestConfig(retailerId = retailerId, deviceId = deviceId, accountId = accountId, includeCounts = includeCounts)

        return request<Unit, RetailerFullResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getRetailer
     *
     * @param retailerId the ID of the retailer
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param includeCounts Determines whether to include counts in the response (default true) (optional)
     * @return RequestConfig
     */
    fun getRetailerRequestConfig(retailerId: kotlin.Long, deviceId: kotlin.String?, accountId: kotlin.Long?, includeCounts: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                put("retailerId", listOf(retailerId.toString()))
                if (includeCounts != null) {
                    put("includeCounts", listOf(includeCounts.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/retailer/get",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter visibility
     */
     enum class VisibilityGetRetailers(val value: kotlin.String) {
         @Json(name = "PUBLIC") PUBLIC("PUBLIC"),
         @Json(name = "PRIVATE") PRIVATE("PRIVATE"),
         @Json(name = "FRIENDS") FRIENDS("FRIENDS");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter sortField
     */
     enum class SortFieldGetRetailers(val value: kotlin.String) {
         @Json(name = "ID") ID("ID"),
         @Json(name = "CREATED") CREATED("CREATED"),
         @Json(name = "UPDATED") UPDATED("UPDATED"),
         @Json(name = "DELETED") DELETED("DELETED"),
         @Json(name = "SEARCH_TAGS") SEARCH_TAGS("SEARCH_TAGS"),
         @Json(name = "ACTIVE") ACTIVE("ACTIVE"),
         @Json(name = "BILLABLE_ENTITY_ID") BILLABLE_ENTITY_ID("BILLABLE_ENTITY_ID"),
         @Json(name = "BILLABLE_ENTITY_NAME") BILLABLE_ENTITY_NAME("BILLABLE_ENTITY_NAME"),
         @Json(name = "RESPONSIBLE_DISPLAY") RESPONSIBLE_DISPLAY("RESPONSIBLE_DISPLAY"),
         @Json(name = "ADDRESS_STREET") ADDRESS_STREET("ADDRESS_STREET"),
         @Json(name = "ADDRESS_CITY") ADDRESS_CITY("ADDRESS_CITY"),
         @Json(name = "ADDRESS_STATE") ADDRESS_STATE("ADDRESS_STATE"),
         @Json(name = "ADDRESS_POSTAL_CODE") ADDRESS_POSTAL_CODE("ADDRESS_POSTAL_CODE"),
         @Json(name = "ADDRESS_COUNTRY") ADDRESS_COUNTRY("ADDRESS_COUNTRY"),
         @Json(name = "FILTERS") FILTERS("FILTERS"),
         @Json(name = "CATEGORIES") CATEGORIES("CATEGORIES"),
         @Json(name = "VISIBILITY") VISIBILITY("VISIBILITY"),
         @Json(name = "NAME") NAME("NAME");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /retailer/search
     * Search Retailers
     * earches on retailers that the account has access to.
     * @param visibility 
     * @param sortField The column to sort the search on
     * @param descending The order to return the search results
     * @param start The record to begin the return set on
     * @param limit The number of records to return
     * @param activeOnly Return only active results
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param q This parameter is deprecated. (optional)
     * @param keyword The keyword used to search (optional)
     * @param categoryIds the categories that the retailer is associated with (optional)
     * @param filterIds the filters that the retailer is associated with (optional)
     * @param i This parameter is deprecated. (optional)
     * @param l This parameter is deprecated. (optional)
     * @return kotlin.collections.List<RetailerResponse>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getRetailers(visibility: VisibilityGetRetailers, sortField: SortFieldGetRetailers, descending: kotlin.Boolean, start: kotlin.Int, limit: kotlin.Int, activeOnly: kotlin.Boolean, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, q: kotlin.String? = null, keyword: kotlin.String? = null, categoryIds: kotlin.String? = null, filterIds: kotlin.String? = null, i: kotlin.Int? = null, l: kotlin.Int? = null) : kotlin.collections.List<RetailerResponse> {
        val localVarResponse = getRetailersWithHttpInfo(visibility = visibility, sortField = sortField, descending = descending, start = start, limit = limit, activeOnly = activeOnly, deviceId = deviceId, accountId = accountId, q = q, keyword = keyword, categoryIds = categoryIds, filterIds = filterIds, i = i, l = l)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<RetailerResponse>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /retailer/search
     * Search Retailers
     * earches on retailers that the account has access to.
     * @param visibility 
     * @param sortField The column to sort the search on
     * @param descending The order to return the search results
     * @param start The record to begin the return set on
     * @param limit The number of records to return
     * @param activeOnly Return only active results
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param q This parameter is deprecated. (optional)
     * @param keyword The keyword used to search (optional)
     * @param categoryIds the categories that the retailer is associated with (optional)
     * @param filterIds the filters that the retailer is associated with (optional)
     * @param i This parameter is deprecated. (optional)
     * @param l This parameter is deprecated. (optional)
     * @return ApiResponse<kotlin.collections.List<RetailerResponse>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getRetailersWithHttpInfo(visibility: VisibilityGetRetailers, sortField: SortFieldGetRetailers, descending: kotlin.Boolean, start: kotlin.Int, limit: kotlin.Int, activeOnly: kotlin.Boolean, deviceId: kotlin.String?, accountId: kotlin.Long?, q: kotlin.String?, keyword: kotlin.String?, categoryIds: kotlin.String?, filterIds: kotlin.String?, i: kotlin.Int?, l: kotlin.Int?) : ApiResponse<kotlin.collections.List<RetailerResponse>?> {
        val localVariableConfig = getRetailersRequestConfig(visibility = visibility, sortField = sortField, descending = descending, start = start, limit = limit, activeOnly = activeOnly, deviceId = deviceId, accountId = accountId, q = q, keyword = keyword, categoryIds = categoryIds, filterIds = filterIds, i = i, l = l)

        return request<Unit, kotlin.collections.List<RetailerResponse>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getRetailers
     *
     * @param visibility 
     * @param sortField The column to sort the search on
     * @param descending The order to return the search results
     * @param start The record to begin the return set on
     * @param limit The number of records to return
     * @param activeOnly Return only active results
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param q This parameter is deprecated. (optional)
     * @param keyword The keyword used to search (optional)
     * @param categoryIds the categories that the retailer is associated with (optional)
     * @param filterIds the filters that the retailer is associated with (optional)
     * @param i This parameter is deprecated. (optional)
     * @param l This parameter is deprecated. (optional)
     * @return RequestConfig
     */
    fun getRetailersRequestConfig(visibility: VisibilityGetRetailers, sortField: SortFieldGetRetailers, descending: kotlin.Boolean, start: kotlin.Int, limit: kotlin.Int, activeOnly: kotlin.Boolean, deviceId: kotlin.String?, accountId: kotlin.Long?, q: kotlin.String?, keyword: kotlin.String?, categoryIds: kotlin.String?, filterIds: kotlin.String?, i: kotlin.Int?, l: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (q != null) {
                    put("q", listOf(q.toString()))
                }
                if (keyword != null) {
                    put("keyword", listOf(keyword.toString()))
                }
                if (categoryIds != null) {
                    put("categoryIds", listOf(categoryIds.toString()))
                }
                if (filterIds != null) {
                    put("filterIds", listOf(filterIds.toString()))
                }
                put("visibility", listOf(visibility.value))
                put("sortField", listOf(sortField.value))
                put("descending", listOf(descending.toString()))
                if (i != null) {
                    put("_i", listOf(i.toString()))
                }
                put("start", listOf(start.toString()))
                if (l != null) {
                    put("_l", listOf(l.toString()))
                }
                put("limit", listOf(limit.toString()))
                put("activeOnly", listOf(activeOnly.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/retailer/search",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /retailer/login
     * Login Retailer
     * Retailer login check.
     * @param username the user&#39;s email address they used to sign-up
     * @param password the password
     * @param deviceId the device id (optional) (optional)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @param appKey the application key (optional)
     * @return AccountLoginResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun retailerLoginCheck(username: kotlin.String, password: kotlin.String, deviceId: kotlin.String? = null, latitude: kotlin.Double? = null, longitude: kotlin.Double? = null, appKey: kotlin.String? = null) : AccountLoginResponse {
        val localVarResponse = retailerLoginCheckWithHttpInfo(username = username, password = password, deviceId = deviceId, latitude = latitude, longitude = longitude, appKey = appKey)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AccountLoginResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /retailer/login
     * Login Retailer
     * Retailer login check.
     * @param username the user&#39;s email address they used to sign-up
     * @param password the password
     * @param deviceId the device id (optional) (optional)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @param appKey the application key (optional)
     * @return ApiResponse<AccountLoginResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun retailerLoginCheckWithHttpInfo(username: kotlin.String, password: kotlin.String, deviceId: kotlin.String?, latitude: kotlin.Double?, longitude: kotlin.Double?, appKey: kotlin.String?) : ApiResponse<AccountLoginResponse?> {
        val localVariableConfig = retailerLoginCheckRequestConfig(username = username, password = password, deviceId = deviceId, latitude = latitude, longitude = longitude, appKey = appKey)

        return request<Unit, AccountLoginResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation retailerLoginCheck
     *
     * @param username the user&#39;s email address they used to sign-up
     * @param password the password
     * @param deviceId the device id (optional) (optional)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @param appKey the application key (optional)
     * @return RequestConfig
     */
    fun retailerLoginCheckRequestConfig(username: kotlin.String, password: kotlin.String, deviceId: kotlin.String?, latitude: kotlin.Double?, longitude: kotlin.Double?, appKey: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("username", listOf(username.toString()))
                put("password", listOf(password.toString()))
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (latitude != null) {
                    put("latitude", listOf(latitude.toString()))
                }
                if (longitude != null) {
                    put("longitude", listOf(longitude.toString()))
                }
                if (appKey != null) {
                    put("appKey", listOf(appKey.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/retailer/login",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter visibility
     */
     enum class VisibilityUpdateRetailer(val value: kotlin.String) {
         @Json(name = "PUBLIC") PUBLIC("PUBLIC"),
         @Json(name = "PRIVATE") PRIVATE("PRIVATE"),
         @Json(name = "FRIENDS") FRIENDS("FRIENDS");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter responseFormat
     */
     enum class ResponseFormatUpdateRetailer(val value: kotlin.String) {
         @Json(name = "HTML") HTML("HTML"),
         @Json(name = "XML") XML("XML"),
         @Json(name = "JSON") JSON("JSON"),
         @Json(name = "CSV") CSV("CSV");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * POST /retailer/update
     * Update Retailer
     * Update a retailer record. Only the owner and the employees of the retailer have access to update its information.
     * @param retailerId The ID of the retailer to update
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param name The name of the retailer (optional)
     * @param streetAddress The street address of the retailer (optional)
     * @param streetAddress2 Additional address information (such as a suite number, floor number, building name, or PO Box) (optional)
     * @param city The city of the retailer (optional)
     * @param state The state of the retailer (optional)
     * @param postalCode The postal code of the retailer (optional)
     * @param country the country of the retailer (optional)
     * @param businessPhone The business phone of the retailer (optional)
     * @param businessPhoneExt The business phone extension of the retailer (optional)
     * @param website The website of the retailer (optional)
     * @param email The email of the retailer (optional)
     * @param facebookUrl The facebook URL of the retailer (optional)
     * @param twitterUrl The twitter URL of the retailer (optional)
     * @param logo The retailer logo sent as a multipart binary file (you can optionally use logoAssetId if the asset has already been uploaded before) (optional)
     * @param logoAssetId The retailer logo asset id (optional)
     * @param picture1 Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture1AssetId if the asset has already been uploaded before) (optional)
     * @param picture1AssetId An asset id (optional)
     * @param picture2 Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture2AssetId if the asset has already been uploaded before) (optional)
     * @param picture2AssetId An asset id (optional)
     * @param categoryIds Comma separated list of category IDs used to filter retailers by categories (optional)
     * @param filterIds Comma separated list of filter IDs used to filter retailers (optional)
     * @param latitude the latitude of the retailer (optional)
     * @param longitude the longitude of the retailer (optional)
     * @param metaData External custom client defined data (optional)
     * @param searchTags External custom search keywords (optional)
     * @param retailerType External custom type identifier (optional)
     * @param visibility  (optional)
     * @param active Sets whether the retailer is active or inactive (hidden from consumers) (optional)
     * @param responseFormat The format of the returned response {JSON // default , HTML // for Dojo support when uploading assets} (optional)
     * @return RetailerFullResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updateRetailer(retailerId: kotlin.Long, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, name: kotlin.String? = null, streetAddress: kotlin.String? = null, streetAddress2: kotlin.String? = null, city: kotlin.String? = null, state: kotlin.String? = null, postalCode: kotlin.String? = null, country: kotlin.String? = null, businessPhone: kotlin.String? = null, businessPhoneExt: kotlin.String? = null, website: kotlin.String? = null, email: kotlin.String? = null, facebookUrl: kotlin.String? = null, twitterUrl: kotlin.String? = null, logo: java.io.File? = null, logoAssetId: kotlin.Long? = null, picture1: java.io.File? = null, picture1AssetId: kotlin.Long? = null, picture2: java.io.File? = null, picture2AssetId: kotlin.Long? = null, categoryIds: kotlin.String? = null, filterIds: kotlin.String? = null, latitude: kotlin.Double? = null, longitude: kotlin.Double? = null, metaData: kotlin.String? = null, searchTags: kotlin.String? = null, retailerType: kotlin.String? = null, visibility: VisibilityUpdateRetailer? = null, active: kotlin.Boolean? = null, responseFormat: ResponseFormatUpdateRetailer? = null) : RetailerFullResponse {
        val localVarResponse = updateRetailerWithHttpInfo(retailerId = retailerId, deviceId = deviceId, accountId = accountId, name = name, streetAddress = streetAddress, streetAddress2 = streetAddress2, city = city, state = state, postalCode = postalCode, country = country, businessPhone = businessPhone, businessPhoneExt = businessPhoneExt, website = website, email = email, facebookUrl = facebookUrl, twitterUrl = twitterUrl, logo = logo, logoAssetId = logoAssetId, picture1 = picture1, picture1AssetId = picture1AssetId, picture2 = picture2, picture2AssetId = picture2AssetId, categoryIds = categoryIds, filterIds = filterIds, latitude = latitude, longitude = longitude, metaData = metaData, searchTags = searchTags, retailerType = retailerType, visibility = visibility, active = active, responseFormat = responseFormat)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RetailerFullResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /retailer/update
     * Update Retailer
     * Update a retailer record. Only the owner and the employees of the retailer have access to update its information.
     * @param retailerId The ID of the retailer to update
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param name The name of the retailer (optional)
     * @param streetAddress The street address of the retailer (optional)
     * @param streetAddress2 Additional address information (such as a suite number, floor number, building name, or PO Box) (optional)
     * @param city The city of the retailer (optional)
     * @param state The state of the retailer (optional)
     * @param postalCode The postal code of the retailer (optional)
     * @param country the country of the retailer (optional)
     * @param businessPhone The business phone of the retailer (optional)
     * @param businessPhoneExt The business phone extension of the retailer (optional)
     * @param website The website of the retailer (optional)
     * @param email The email of the retailer (optional)
     * @param facebookUrl The facebook URL of the retailer (optional)
     * @param twitterUrl The twitter URL of the retailer (optional)
     * @param logo The retailer logo sent as a multipart binary file (you can optionally use logoAssetId if the asset has already been uploaded before) (optional)
     * @param logoAssetId The retailer logo asset id (optional)
     * @param picture1 Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture1AssetId if the asset has already been uploaded before) (optional)
     * @param picture1AssetId An asset id (optional)
     * @param picture2 Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture2AssetId if the asset has already been uploaded before) (optional)
     * @param picture2AssetId An asset id (optional)
     * @param categoryIds Comma separated list of category IDs used to filter retailers by categories (optional)
     * @param filterIds Comma separated list of filter IDs used to filter retailers (optional)
     * @param latitude the latitude of the retailer (optional)
     * @param longitude the longitude of the retailer (optional)
     * @param metaData External custom client defined data (optional)
     * @param searchTags External custom search keywords (optional)
     * @param retailerType External custom type identifier (optional)
     * @param visibility  (optional)
     * @param active Sets whether the retailer is active or inactive (hidden from consumers) (optional)
     * @param responseFormat The format of the returned response {JSON // default , HTML // for Dojo support when uploading assets} (optional)
     * @return ApiResponse<RetailerFullResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun updateRetailerWithHttpInfo(retailerId: kotlin.Long, deviceId: kotlin.String?, accountId: kotlin.Long?, name: kotlin.String?, streetAddress: kotlin.String?, streetAddress2: kotlin.String?, city: kotlin.String?, state: kotlin.String?, postalCode: kotlin.String?, country: kotlin.String?, businessPhone: kotlin.String?, businessPhoneExt: kotlin.String?, website: kotlin.String?, email: kotlin.String?, facebookUrl: kotlin.String?, twitterUrl: kotlin.String?, logo: java.io.File?, logoAssetId: kotlin.Long?, picture1: java.io.File?, picture1AssetId: kotlin.Long?, picture2: java.io.File?, picture2AssetId: kotlin.Long?, categoryIds: kotlin.String?, filterIds: kotlin.String?, latitude: kotlin.Double?, longitude: kotlin.Double?, metaData: kotlin.String?, searchTags: kotlin.String?, retailerType: kotlin.String?, visibility: VisibilityUpdateRetailer?, active: kotlin.Boolean?, responseFormat: ResponseFormatUpdateRetailer?) : ApiResponse<RetailerFullResponse?> {
        val localVariableConfig = updateRetailerRequestConfig(retailerId = retailerId, deviceId = deviceId, accountId = accountId, name = name, streetAddress = streetAddress, streetAddress2 = streetAddress2, city = city, state = state, postalCode = postalCode, country = country, businessPhone = businessPhone, businessPhoneExt = businessPhoneExt, website = website, email = email, facebookUrl = facebookUrl, twitterUrl = twitterUrl, logo = logo, logoAssetId = logoAssetId, picture1 = picture1, picture1AssetId = picture1AssetId, picture2 = picture2, picture2AssetId = picture2AssetId, categoryIds = categoryIds, filterIds = filterIds, latitude = latitude, longitude = longitude, metaData = metaData, searchTags = searchTags, retailerType = retailerType, visibility = visibility, active = active, responseFormat = responseFormat)

        return request<Unit, RetailerFullResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateRetailer
     *
     * @param retailerId The ID of the retailer to update
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param name The name of the retailer (optional)
     * @param streetAddress The street address of the retailer (optional)
     * @param streetAddress2 Additional address information (such as a suite number, floor number, building name, or PO Box) (optional)
     * @param city The city of the retailer (optional)
     * @param state The state of the retailer (optional)
     * @param postalCode The postal code of the retailer (optional)
     * @param country the country of the retailer (optional)
     * @param businessPhone The business phone of the retailer (optional)
     * @param businessPhoneExt The business phone extension of the retailer (optional)
     * @param website The website of the retailer (optional)
     * @param email The email of the retailer (optional)
     * @param facebookUrl The facebook URL of the retailer (optional)
     * @param twitterUrl The twitter URL of the retailer (optional)
     * @param logo The retailer logo sent as a multipart binary file (you can optionally use logoAssetId if the asset has already been uploaded before) (optional)
     * @param logoAssetId The retailer logo asset id (optional)
     * @param picture1 Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture1AssetId if the asset has already been uploaded before) (optional)
     * @param picture1AssetId An asset id (optional)
     * @param picture2 Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture2AssetId if the asset has already been uploaded before) (optional)
     * @param picture2AssetId An asset id (optional)
     * @param categoryIds Comma separated list of category IDs used to filter retailers by categories (optional)
     * @param filterIds Comma separated list of filter IDs used to filter retailers (optional)
     * @param latitude the latitude of the retailer (optional)
     * @param longitude the longitude of the retailer (optional)
     * @param metaData External custom client defined data (optional)
     * @param searchTags External custom search keywords (optional)
     * @param retailerType External custom type identifier (optional)
     * @param visibility  (optional)
     * @param active Sets whether the retailer is active or inactive (hidden from consumers) (optional)
     * @param responseFormat The format of the returned response {JSON // default , HTML // for Dojo support when uploading assets} (optional)
     * @return RequestConfig
     */
    fun updateRetailerRequestConfig(retailerId: kotlin.Long, deviceId: kotlin.String?, accountId: kotlin.Long?, name: kotlin.String?, streetAddress: kotlin.String?, streetAddress2: kotlin.String?, city: kotlin.String?, state: kotlin.String?, postalCode: kotlin.String?, country: kotlin.String?, businessPhone: kotlin.String?, businessPhoneExt: kotlin.String?, website: kotlin.String?, email: kotlin.String?, facebookUrl: kotlin.String?, twitterUrl: kotlin.String?, logo: java.io.File?, logoAssetId: kotlin.Long?, picture1: java.io.File?, picture1AssetId: kotlin.Long?, picture2: java.io.File?, picture2AssetId: kotlin.Long?, categoryIds: kotlin.String?, filterIds: kotlin.String?, latitude: kotlin.Double?, longitude: kotlin.Double?, metaData: kotlin.String?, searchTags: kotlin.String?, retailerType: kotlin.String?, visibility: VisibilityUpdateRetailer?, active: kotlin.Boolean?, responseFormat: ResponseFormatUpdateRetailer?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                put("retailerId", listOf(retailerId.toString()))
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (streetAddress != null) {
                    put("streetAddress", listOf(streetAddress.toString()))
                }
                if (streetAddress2 != null) {
                    put("streetAddress2", listOf(streetAddress2.toString()))
                }
                if (city != null) {
                    put("city", listOf(city.toString()))
                }
                if (state != null) {
                    put("state", listOf(state.toString()))
                }
                if (postalCode != null) {
                    put("postalCode", listOf(postalCode.toString()))
                }
                if (country != null) {
                    put("country", listOf(country.toString()))
                }
                if (businessPhone != null) {
                    put("businessPhone", listOf(businessPhone.toString()))
                }
                if (businessPhoneExt != null) {
                    put("businessPhoneExt", listOf(businessPhoneExt.toString()))
                }
                if (website != null) {
                    put("website", listOf(website.toString()))
                }
                if (email != null) {
                    put("email", listOf(email.toString()))
                }
                if (facebookUrl != null) {
                    put("facebookUrl", listOf(facebookUrl.toString()))
                }
                if (twitterUrl != null) {
                    put("twitterUrl", listOf(twitterUrl.toString()))
                }
                if (logo != null) {
                    put("logo", listOf(logo.toString()))
                }
                if (logoAssetId != null) {
                    put("logoAssetId", listOf(logoAssetId.toString()))
                }
                if (picture1 != null) {
                    put("picture1", listOf(picture1.toString()))
                }
                if (picture1AssetId != null) {
                    put("picture1AssetId", listOf(picture1AssetId.toString()))
                }
                if (picture2 != null) {
                    put("picture2", listOf(picture2.toString()))
                }
                if (picture2AssetId != null) {
                    put("picture2AssetId", listOf(picture2AssetId.toString()))
                }
                if (categoryIds != null) {
                    put("categoryIds", listOf(categoryIds.toString()))
                }
                if (filterIds != null) {
                    put("filterIds", listOf(filterIds.toString()))
                }
                if (latitude != null) {
                    put("latitude", listOf(latitude.toString()))
                }
                if (longitude != null) {
                    put("longitude", listOf(longitude.toString()))
                }
                if (metaData != null) {
                    put("metaData", listOf(metaData.toString()))
                }
                if (searchTags != null) {
                    put("searchTags", listOf(searchTags.toString()))
                }
                if (retailerType != null) {
                    put("retailerType", listOf(retailerType.toString()))
                }
                if (visibility != null) {
                    put("visibility", listOf(visibility.value))
                }
                if (active != null) {
                    put("active", listOf(active.toString()))
                }
                if (responseFormat != null) {
                    put("responseFormat", listOf(responseFormat.value))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/retailer/update",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
