/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import org.openapitools.client.models.OrsonAiAddMovieResponse
import org.openapitools.client.models.OrsonAiBatchResponse
import org.openapitools.client.models.OrsonAiEmotionsResponse
import org.openapitools.client.models.OrsonAiProtoResponse
import org.openapitools.client.models.OrsonAiSTTResponse
import org.openapitools.client.models.OrsonAiTTSResponse
import org.openapitools.client.models.OrsonAiTechTuneResponse
import org.openapitools.client.models.OrsonAiTopicsResponse
import org.openapitools.client.models.OrsonAiVoiceCanvasResponse
import org.openapitools.client.models.OrsonEpisodeResponse
import org.openapitools.client.models.OrsonRenderResponse

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

open class OrsonApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://dev.sirqul.com/api/3.18")
        }
    }

    /**
     * POST /orson/ai/addMovie
     * Add Movie
     * Add a movie to be indexed for Topics. Indexing a movie analyses the content and incorporates it into the topics model for future /topics calls. This does not store the movie file long-term.
     * @param accountId Sirqul Account Id
     * @param movieName Movie Name
     * @param thirdPartyAccountId A third-party account id that is meaningful to your systems (optional)
     * @param tags A user defined list (comma-delimited) of tags associated with the movie (optional)
     * @param file An uploaded recording to analyze (Currently limited to 10MB) (optional)
     * @param url A recording file to download and analyze (Size limit: 1GB) (optional)
     * @param paramCallback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
     * @return OrsonAiAddMovieResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun addMovie(accountId: kotlin.Long, movieName: kotlin.String, thirdPartyAccountId: kotlin.String? = null, tags: kotlin.String? = null, file: java.io.File? = null, url: kotlin.String? = null, paramCallback: kotlin.String? = null) : OrsonAiAddMovieResponse {
        val localVarResponse = addMovieWithHttpInfo(accountId = accountId, movieName = movieName, thirdPartyAccountId = thirdPartyAccountId, tags = tags, file = file, url = url, paramCallback = paramCallback)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OrsonAiAddMovieResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /orson/ai/addMovie
     * Add Movie
     * Add a movie to be indexed for Topics. Indexing a movie analyses the content and incorporates it into the topics model for future /topics calls. This does not store the movie file long-term.
     * @param accountId Sirqul Account Id
     * @param movieName Movie Name
     * @param thirdPartyAccountId A third-party account id that is meaningful to your systems (optional)
     * @param tags A user defined list (comma-delimited) of tags associated with the movie (optional)
     * @param file An uploaded recording to analyze (Currently limited to 10MB) (optional)
     * @param url A recording file to download and analyze (Size limit: 1GB) (optional)
     * @param paramCallback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
     * @return ApiResponse<OrsonAiAddMovieResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun addMovieWithHttpInfo(accountId: kotlin.Long, movieName: kotlin.String, thirdPartyAccountId: kotlin.String?, tags: kotlin.String?, file: java.io.File?, url: kotlin.String?, paramCallback: kotlin.String?) : ApiResponse<OrsonAiAddMovieResponse?> {
        val localVariableConfig = addMovieRequestConfig(accountId = accountId, movieName = movieName, thirdPartyAccountId = thirdPartyAccountId, tags = tags, file = file, url = url, paramCallback = paramCallback)

        return request<Unit, OrsonAiAddMovieResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation addMovie
     *
     * @param accountId Sirqul Account Id
     * @param movieName Movie Name
     * @param thirdPartyAccountId A third-party account id that is meaningful to your systems (optional)
     * @param tags A user defined list (comma-delimited) of tags associated with the movie (optional)
     * @param file An uploaded recording to analyze (Currently limited to 10MB) (optional)
     * @param url A recording file to download and analyze (Size limit: 1GB) (optional)
     * @param paramCallback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
     * @return RequestConfig
     */
    fun addMovieRequestConfig(accountId: kotlin.Long, movieName: kotlin.String, thirdPartyAccountId: kotlin.String?, tags: kotlin.String?, file: java.io.File?, url: kotlin.String?, paramCallback: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                if (thirdPartyAccountId != null) {
                    put("thirdPartyAccountId", listOf(thirdPartyAccountId.toString()))
                }
                if (tags != null) {
                    put("tags", listOf(tags.toString()))
                }
                put("movieName", listOf(movieName.toString()))
                if (file != null) {
                    put("file", listOf(file.toString()))
                }
                if (url != null) {
                    put("url", listOf(url.toString()))
                }
                if (paramCallback != null) {
                    put("callback", listOf(paramCallback.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/orson/ai/addMovie",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /orson/ai/docs
     * Search Docs
     * Takes in a text string representing one or more sentences and it returns a list of documents which are related to the provided document.
     * @param accountId Sirqul Account Id
     * @param doc Doc
     * @param returnTopics Return Topics (optional)
     * @param limit Limit (optional)
     * @param offset Offset (optional)
     * @return OrsonAiProtoResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun aiDocs(accountId: kotlin.Long, doc: kotlin.String, returnTopics: kotlin.Boolean? = null, limit: kotlin.Int? = null, offset: kotlin.Int? = null) : OrsonAiProtoResponse {
        val localVarResponse = aiDocsWithHttpInfo(accountId = accountId, doc = doc, returnTopics = returnTopics, limit = limit, offset = offset)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OrsonAiProtoResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /orson/ai/docs
     * Search Docs
     * Takes in a text string representing one or more sentences and it returns a list of documents which are related to the provided document.
     * @param accountId Sirqul Account Id
     * @param doc Doc
     * @param returnTopics Return Topics (optional)
     * @param limit Limit (optional)
     * @param offset Offset (optional)
     * @return ApiResponse<OrsonAiProtoResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun aiDocsWithHttpInfo(accountId: kotlin.Long, doc: kotlin.String, returnTopics: kotlin.Boolean?, limit: kotlin.Int?, offset: kotlin.Int?) : ApiResponse<OrsonAiProtoResponse?> {
        val localVariableConfig = aiDocsRequestConfig(accountId = accountId, doc = doc, returnTopics = returnTopics, limit = limit, offset = offset)

        return request<Unit, OrsonAiProtoResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation aiDocs
     *
     * @param accountId Sirqul Account Id
     * @param doc Doc
     * @param returnTopics Return Topics (optional)
     * @param limit Limit (optional)
     * @param offset Offset (optional)
     * @return RequestConfig
     */
    fun aiDocsRequestConfig(accountId: kotlin.Long, doc: kotlin.String, returnTopics: kotlin.Boolean?, limit: kotlin.Int?, offset: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("doc", listOf(doc.toString()))
                if (returnTopics != null) {
                    put("return_topics", listOf(returnTopics.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/orson/ai/docs",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /orson/ai/img
     * Find images
     * Returns a list of URIs of images that match the text.
     * @param accountId Sirqul Account Id
     * @param text Text
     * @param parseFlag Parse Flag (optional)
     * @param fetchFlag Fetch Flag (optional)
     * @param size Size (optional)
     * @return OrsonAiProtoResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun aiFindImages(accountId: kotlin.Long, text: kotlin.String, parseFlag: kotlin.String? = null, fetchFlag: kotlin.String? = null, size: kotlin.String? = null) : OrsonAiProtoResponse {
        val localVarResponse = aiFindImagesWithHttpInfo(accountId = accountId, text = text, parseFlag = parseFlag, fetchFlag = fetchFlag, size = size)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OrsonAiProtoResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /orson/ai/img
     * Find images
     * Returns a list of URIs of images that match the text.
     * @param accountId Sirqul Account Id
     * @param text Text
     * @param parseFlag Parse Flag (optional)
     * @param fetchFlag Fetch Flag (optional)
     * @param size Size (optional)
     * @return ApiResponse<OrsonAiProtoResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun aiFindImagesWithHttpInfo(accountId: kotlin.Long, text: kotlin.String, parseFlag: kotlin.String?, fetchFlag: kotlin.String?, size: kotlin.String?) : ApiResponse<OrsonAiProtoResponse?> {
        val localVariableConfig = aiFindImagesRequestConfig(accountId = accountId, text = text, parseFlag = parseFlag, fetchFlag = fetchFlag, size = size)

        return request<Unit, OrsonAiProtoResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation aiFindImages
     *
     * @param accountId Sirqul Account Id
     * @param text Text
     * @param parseFlag Parse Flag (optional)
     * @param fetchFlag Fetch Flag (optional)
     * @param size Size (optional)
     * @return RequestConfig
     */
    fun aiFindImagesRequestConfig(accountId: kotlin.Long, text: kotlin.String, parseFlag: kotlin.String?, fetchFlag: kotlin.String?, size: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("text", listOf(text.toString()))
                if (parseFlag != null) {
                    put("parse_flag", listOf(parseFlag.toString()))
                }
                if (fetchFlag != null) {
                    put("fetch_flag", listOf(fetchFlag.toString()))
                }
                if (size != null) {
                    put("size", listOf(size.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/orson/ai/img",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /orson/ai/tags
     * Search Tags
     * Search the tags column of user provided tags using this endpoint.
     * @param accountId Sirqul Account Id
     * @param tags Tags
     * @param conditional Conditional (optional)
     * @param limit Limit (optional)
     * @param offset Offset (optional)
     * @return OrsonAiProtoResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun aiTags(accountId: kotlin.Long, tags: kotlin.String, conditional: kotlin.String? = null, limit: kotlin.Int? = null, offset: kotlin.Int? = null) : OrsonAiProtoResponse {
        val localVarResponse = aiTagsWithHttpInfo(accountId = accountId, tags = tags, conditional = conditional, limit = limit, offset = offset)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OrsonAiProtoResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /orson/ai/tags
     * Search Tags
     * Search the tags column of user provided tags using this endpoint.
     * @param accountId Sirqul Account Id
     * @param tags Tags
     * @param conditional Conditional (optional)
     * @param limit Limit (optional)
     * @param offset Offset (optional)
     * @return ApiResponse<OrsonAiProtoResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun aiTagsWithHttpInfo(accountId: kotlin.Long, tags: kotlin.String, conditional: kotlin.String?, limit: kotlin.Int?, offset: kotlin.Int?) : ApiResponse<OrsonAiProtoResponse?> {
        val localVariableConfig = aiTagsRequestConfig(accountId = accountId, tags = tags, conditional = conditional, limit = limit, offset = offset)

        return request<Unit, OrsonAiProtoResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation aiTags
     *
     * @param accountId Sirqul Account Id
     * @param tags Tags
     * @param conditional Conditional (optional)
     * @param limit Limit (optional)
     * @param offset Offset (optional)
     * @return RequestConfig
     */
    fun aiTagsRequestConfig(accountId: kotlin.Long, tags: kotlin.String, conditional: kotlin.String?, limit: kotlin.Int?, offset: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("tags", listOf(tags.toString()))
                if (conditional != null) {
                    put("conditional", listOf(conditional.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/orson/ai/tags",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /orson/ai/text
     * Search Text
     * Search the movie text column of movie text using this endpoint.
     * @param accountId Sirqul Account Id
     * @param terms Terms
     * @param conditional Conditional (optional)
     * @param limit Limit (optional)
     * @param offset Offset (optional)
     * @return OrsonAiProtoResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun aiText(accountId: kotlin.Long, terms: kotlin.String, conditional: kotlin.String? = null, limit: kotlin.Int? = null, offset: kotlin.Int? = null) : OrsonAiProtoResponse {
        val localVarResponse = aiTextWithHttpInfo(accountId = accountId, terms = terms, conditional = conditional, limit = limit, offset = offset)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OrsonAiProtoResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /orson/ai/text
     * Search Text
     * Search the movie text column of movie text using this endpoint.
     * @param accountId Sirqul Account Id
     * @param terms Terms
     * @param conditional Conditional (optional)
     * @param limit Limit (optional)
     * @param offset Offset (optional)
     * @return ApiResponse<OrsonAiProtoResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun aiTextWithHttpInfo(accountId: kotlin.Long, terms: kotlin.String, conditional: kotlin.String?, limit: kotlin.Int?, offset: kotlin.Int?) : ApiResponse<OrsonAiProtoResponse?> {
        val localVariableConfig = aiTextRequestConfig(accountId = accountId, terms = terms, conditional = conditional, limit = limit, offset = offset)

        return request<Unit, OrsonAiProtoResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation aiText
     *
     * @param accountId Sirqul Account Id
     * @param terms Terms
     * @param conditional Conditional (optional)
     * @param limit Limit (optional)
     * @param offset Offset (optional)
     * @return RequestConfig
     */
    fun aiTextRequestConfig(accountId: kotlin.Long, terms: kotlin.String, conditional: kotlin.String?, limit: kotlin.Int?, offset: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("terms", listOf(terms.toString()))
                if (conditional != null) {
                    put("conditional", listOf(conditional.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/orson/ai/text",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /orson/ai/batch
     * Batch Analysis
     * Run several types of analysis on an audio or video file in a single API call, instead of calling several operations for the same file..
     * @param accountId Sirqul Account Id
     * @param thirdPartyAccountId A third-party account id that is meaningful to your systems (optional)
     * @param limit The number of topics to return (optional)
     * @param operations The comma-delimited list of A/V batch analysis operations to run on this file. Possible values: Transcript,Topics,Emotions (optional)
     * @param file An uploaded recording to analyze (Currently limited to 10MB) (optional)
     * @param url A recording file to download and analyze (Size limit: 1GB) (optional)
     * @param paramCallback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
     * @return OrsonAiBatchResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun batch(accountId: kotlin.Long, thirdPartyAccountId: kotlin.String? = null, limit: kotlin.Int? = null, operations: kotlin.String? = null, file: java.io.File? = null, url: kotlin.String? = null, paramCallback: kotlin.String? = null) : OrsonAiBatchResponse {
        val localVarResponse = batchWithHttpInfo(accountId = accountId, thirdPartyAccountId = thirdPartyAccountId, limit = limit, operations = operations, file = file, url = url, paramCallback = paramCallback)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OrsonAiBatchResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /orson/ai/batch
     * Batch Analysis
     * Run several types of analysis on an audio or video file in a single API call, instead of calling several operations for the same file..
     * @param accountId Sirqul Account Id
     * @param thirdPartyAccountId A third-party account id that is meaningful to your systems (optional)
     * @param limit The number of topics to return (optional)
     * @param operations The comma-delimited list of A/V batch analysis operations to run on this file. Possible values: Transcript,Topics,Emotions (optional)
     * @param file An uploaded recording to analyze (Currently limited to 10MB) (optional)
     * @param url A recording file to download and analyze (Size limit: 1GB) (optional)
     * @param paramCallback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
     * @return ApiResponse<OrsonAiBatchResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun batchWithHttpInfo(accountId: kotlin.Long, thirdPartyAccountId: kotlin.String?, limit: kotlin.Int?, operations: kotlin.String?, file: java.io.File?, url: kotlin.String?, paramCallback: kotlin.String?) : ApiResponse<OrsonAiBatchResponse?> {
        val localVariableConfig = batchRequestConfig(accountId = accountId, thirdPartyAccountId = thirdPartyAccountId, limit = limit, operations = operations, file = file, url = url, paramCallback = paramCallback)

        return request<Unit, OrsonAiBatchResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation batch
     *
     * @param accountId Sirqul Account Id
     * @param thirdPartyAccountId A third-party account id that is meaningful to your systems (optional)
     * @param limit The number of topics to return (optional)
     * @param operations The comma-delimited list of A/V batch analysis operations to run on this file. Possible values: Transcript,Topics,Emotions (optional)
     * @param file An uploaded recording to analyze (Currently limited to 10MB) (optional)
     * @param url A recording file to download and analyze (Size limit: 1GB) (optional)
     * @param paramCallback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
     * @return RequestConfig
     */
    fun batchRequestConfig(accountId: kotlin.Long, thirdPartyAccountId: kotlin.String?, limit: kotlin.Int?, operations: kotlin.String?, file: java.io.File?, url: kotlin.String?, paramCallback: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                if (thirdPartyAccountId != null) {
                    put("thirdPartyAccountId", listOf(thirdPartyAccountId.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (operations != null) {
                    put("operations", listOf(operations.toString()))
                }
                if (file != null) {
                    put("file", listOf(file.toString()))
                }
                if (url != null) {
                    put("url", listOf(url.toString()))
                }
                if (paramCallback != null) {
                    put("callback", listOf(paramCallback.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/orson/ai/batch",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /orson/stories/episodes/instant
     * Creates an instant episode
     * Creates an instant episode for a given StoryStrip by providing all necessary inputs, interview recordings, and pictures, kicking off a render immediately.
     * @param accountId Sirqul Account Id
     * @param `data` Request Data String
     * @return OrsonEpisodeResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createInstantEpisode(accountId: kotlin.Long, `data`: kotlin.String) : OrsonEpisodeResponse {
        val localVarResponse = createInstantEpisodeWithHttpInfo(accountId = accountId, `data` = `data`)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OrsonEpisodeResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /orson/stories/episodes/instant
     * Creates an instant episode
     * Creates an instant episode for a given StoryStrip by providing all necessary inputs, interview recordings, and pictures, kicking off a render immediately.
     * @param accountId Sirqul Account Id
     * @param `data` Request Data String
     * @return ApiResponse<OrsonEpisodeResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createInstantEpisodeWithHttpInfo(accountId: kotlin.Long, `data`: kotlin.String) : ApiResponse<OrsonEpisodeResponse?> {
        val localVariableConfig = createInstantEpisodeRequestConfig(accountId = accountId, `data` = `data`)

        return request<Unit, OrsonEpisodeResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createInstantEpisode
     *
     * @param accountId Sirqul Account Id
     * @param `data` Request Data String
     * @return RequestConfig
     */
    fun createInstantEpisodeRequestConfig(accountId: kotlin.Long, `data`: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("data", listOf(`data`.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/orson/stories/episodes/instant",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /orson/ai/voiceCanvas
     * Create VoiceCanvas images
     * Create VoiceCanvas images for provided text, file upload, or file URL
     * @param accountId Sirqul Account Id
     * @param dimensions Enum: \&quot;256x256\&quot; \&quot;512x512\&quot; \&quot;1024x1024\&quot;
     * @param thirdPartyAccountId A third-party account id that is meaningful to your systems (optional)
     * @param text Provide a transcript or previously extracted topics for image generation (optional)
     * @param file An uploaded recording to analyze (Currently limited to 10MB) (optional)
     * @param url A recording file to download and analyze (Size limit: 1GB) (optional)
     * @param parseFlag When false, uses the raw value from text instead of identifying topics to fetch/generate from (optional)
     * @param fetchFlag When true, fetches images instead of generating them (optional)
     * @param paramCallback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
     * @return OrsonAiVoiceCanvasResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createVoiceCanvas(accountId: kotlin.Long, dimensions: kotlin.String, thirdPartyAccountId: kotlin.String? = null, text: kotlin.String? = null, file: java.io.File? = null, url: kotlin.String? = null, parseFlag: kotlin.Boolean? = null, fetchFlag: kotlin.Boolean? = null, paramCallback: kotlin.String? = null) : OrsonAiVoiceCanvasResponse {
        val localVarResponse = createVoiceCanvasWithHttpInfo(accountId = accountId, dimensions = dimensions, thirdPartyAccountId = thirdPartyAccountId, text = text, file = file, url = url, parseFlag = parseFlag, fetchFlag = fetchFlag, paramCallback = paramCallback)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OrsonAiVoiceCanvasResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /orson/ai/voiceCanvas
     * Create VoiceCanvas images
     * Create VoiceCanvas images for provided text, file upload, or file URL
     * @param accountId Sirqul Account Id
     * @param dimensions Enum: \&quot;256x256\&quot; \&quot;512x512\&quot; \&quot;1024x1024\&quot;
     * @param thirdPartyAccountId A third-party account id that is meaningful to your systems (optional)
     * @param text Provide a transcript or previously extracted topics for image generation (optional)
     * @param file An uploaded recording to analyze (Currently limited to 10MB) (optional)
     * @param url A recording file to download and analyze (Size limit: 1GB) (optional)
     * @param parseFlag When false, uses the raw value from text instead of identifying topics to fetch/generate from (optional)
     * @param fetchFlag When true, fetches images instead of generating them (optional)
     * @param paramCallback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
     * @return ApiResponse<OrsonAiVoiceCanvasResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createVoiceCanvasWithHttpInfo(accountId: kotlin.Long, dimensions: kotlin.String, thirdPartyAccountId: kotlin.String?, text: kotlin.String?, file: java.io.File?, url: kotlin.String?, parseFlag: kotlin.Boolean?, fetchFlag: kotlin.Boolean?, paramCallback: kotlin.String?) : ApiResponse<OrsonAiVoiceCanvasResponse?> {
        val localVariableConfig = createVoiceCanvasRequestConfig(accountId = accountId, dimensions = dimensions, thirdPartyAccountId = thirdPartyAccountId, text = text, file = file, url = url, parseFlag = parseFlag, fetchFlag = fetchFlag, paramCallback = paramCallback)

        return request<Unit, OrsonAiVoiceCanvasResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createVoiceCanvas
     *
     * @param accountId Sirqul Account Id
     * @param dimensions Enum: \&quot;256x256\&quot; \&quot;512x512\&quot; \&quot;1024x1024\&quot;
     * @param thirdPartyAccountId A third-party account id that is meaningful to your systems (optional)
     * @param text Provide a transcript or previously extracted topics for image generation (optional)
     * @param file An uploaded recording to analyze (Currently limited to 10MB) (optional)
     * @param url A recording file to download and analyze (Size limit: 1GB) (optional)
     * @param parseFlag When false, uses the raw value from text instead of identifying topics to fetch/generate from (optional)
     * @param fetchFlag When true, fetches images instead of generating them (optional)
     * @param paramCallback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
     * @return RequestConfig
     */
    fun createVoiceCanvasRequestConfig(accountId: kotlin.Long, dimensions: kotlin.String, thirdPartyAccountId: kotlin.String?, text: kotlin.String?, file: java.io.File?, url: kotlin.String?, parseFlag: kotlin.Boolean?, fetchFlag: kotlin.Boolean?, paramCallback: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                if (thirdPartyAccountId != null) {
                    put("thirdPartyAccountId", listOf(thirdPartyAccountId.toString()))
                }
                put("dimensions", listOf(dimensions.toString()))
                if (text != null) {
                    put("text", listOf(text.toString()))
                }
                if (file != null) {
                    put("file", listOf(file.toString()))
                }
                if (url != null) {
                    put("url", listOf(url.toString()))
                }
                if (parseFlag != null) {
                    put("parseFlag", listOf(parseFlag.toString()))
                }
                if (fetchFlag != null) {
                    put("fetchFlag", listOf(fetchFlag.toString()))
                }
                if (paramCallback != null) {
                    put("callback", listOf(paramCallback.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/orson/ai/voiceCanvas",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /orson/ai/emotion
     * Detect emotions
     * Detects emotions in an audio or video recording.
     * @param accountId Sirqul Account Id
     * @param thirdPartyAccountId A third-party account id that is meaningful to your systems (optional)
     * @param file An uploaded recording to analyze (Currently limited to 10MB) (optional)
     * @param url A recording file to download and analyze (Size limit: 1GB) (optional)
     * @param paramCallback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
     * @return OrsonAiEmotionsResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun emotion(accountId: kotlin.Long, thirdPartyAccountId: kotlin.String? = null, file: java.io.File? = null, url: kotlin.String? = null, paramCallback: kotlin.String? = null) : OrsonAiEmotionsResponse {
        val localVarResponse = emotionWithHttpInfo(accountId = accountId, thirdPartyAccountId = thirdPartyAccountId, file = file, url = url, paramCallback = paramCallback)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OrsonAiEmotionsResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /orson/ai/emotion
     * Detect emotions
     * Detects emotions in an audio or video recording.
     * @param accountId Sirqul Account Id
     * @param thirdPartyAccountId A third-party account id that is meaningful to your systems (optional)
     * @param file An uploaded recording to analyze (Currently limited to 10MB) (optional)
     * @param url A recording file to download and analyze (Size limit: 1GB) (optional)
     * @param paramCallback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
     * @return ApiResponse<OrsonAiEmotionsResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun emotionWithHttpInfo(accountId: kotlin.Long, thirdPartyAccountId: kotlin.String?, file: java.io.File?, url: kotlin.String?, paramCallback: kotlin.String?) : ApiResponse<OrsonAiEmotionsResponse?> {
        val localVariableConfig = emotionRequestConfig(accountId = accountId, thirdPartyAccountId = thirdPartyAccountId, file = file, url = url, paramCallback = paramCallback)

        return request<Unit, OrsonAiEmotionsResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation emotion
     *
     * @param accountId Sirqul Account Id
     * @param thirdPartyAccountId A third-party account id that is meaningful to your systems (optional)
     * @param file An uploaded recording to analyze (Currently limited to 10MB) (optional)
     * @param url A recording file to download and analyze (Size limit: 1GB) (optional)
     * @param paramCallback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
     * @return RequestConfig
     */
    fun emotionRequestConfig(accountId: kotlin.Long, thirdPartyAccountId: kotlin.String?, file: java.io.File?, url: kotlin.String?, paramCallback: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                if (thirdPartyAccountId != null) {
                    put("thirdPartyAccountId", listOf(thirdPartyAccountId.toString()))
                }
                if (file != null) {
                    put("file", listOf(file.toString()))
                }
                if (url != null) {
                    put("url", listOf(url.toString()))
                }
                if (paramCallback != null) {
                    put("callback", listOf(paramCallback.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/orson/ai/emotion",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /orson/ai/addMovie/{requestId}
     * Get Add Movie Result
     * Get the result of an in progress Add Movie request from an earlier POST.
     * @param requestId Orson Request Id
     * @param accountId Sirqul Account Id
     * @return OrsonAiAddMovieResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAddMovieResult(requestId: kotlin.String, accountId: kotlin.Long) : OrsonAiAddMovieResponse {
        val localVarResponse = getAddMovieResultWithHttpInfo(requestId = requestId, accountId = accountId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OrsonAiAddMovieResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /orson/ai/addMovie/{requestId}
     * Get Add Movie Result
     * Get the result of an in progress Add Movie request from an earlier POST.
     * @param requestId Orson Request Id
     * @param accountId Sirqul Account Id
     * @return ApiResponse<OrsonAiAddMovieResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getAddMovieResultWithHttpInfo(requestId: kotlin.String, accountId: kotlin.Long) : ApiResponse<OrsonAiAddMovieResponse?> {
        val localVariableConfig = getAddMovieResultRequestConfig(requestId = requestId, accountId = accountId)

        return request<Unit, OrsonAiAddMovieResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAddMovieResult
     *
     * @param requestId Orson Request Id
     * @param accountId Sirqul Account Id
     * @return RequestConfig
     */
    fun getAddMovieResultRequestConfig(requestId: kotlin.String, accountId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/orson/ai/addMovie/{requestId}".replace("{"+"requestId"+"}", encodeURIComponent(requestId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /orson/ai/batch/{requestId}
     * Get Batch Analysis Results
     * Gets the completed Video Batch results, if done, or an error or status update if not.
     * @param requestId Orson Request Id
     * @param accountId Sirqul Account Id
     * @return OrsonAiBatchResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getBatch(requestId: kotlin.String, accountId: kotlin.Long) : OrsonAiBatchResponse {
        val localVarResponse = getBatchWithHttpInfo(requestId = requestId, accountId = accountId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OrsonAiBatchResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /orson/ai/batch/{requestId}
     * Get Batch Analysis Results
     * Gets the completed Video Batch results, if done, or an error or status update if not.
     * @param requestId Orson Request Id
     * @param accountId Sirqul Account Id
     * @return ApiResponse<OrsonAiBatchResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getBatchWithHttpInfo(requestId: kotlin.String, accountId: kotlin.Long) : ApiResponse<OrsonAiBatchResponse?> {
        val localVariableConfig = getBatchRequestConfig(requestId = requestId, accountId = accountId)

        return request<Unit, OrsonAiBatchResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getBatch
     *
     * @param requestId Orson Request Id
     * @param accountId Sirqul Account Id
     * @return RequestConfig
     */
    fun getBatchRequestConfig(requestId: kotlin.String, accountId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/orson/ai/batch/{requestId}".replace("{"+"requestId"+"}", encodeURIComponent(requestId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /orson/ai/emotion/{requestId}
     * Get Emotion Results
     * Checks the Emotion analysis and returns in progress, results, or error.
     * @param requestId Orson Request Id
     * @param accountId Sirqul Account Id
     * @return OrsonAiEmotionsResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getEmotion(requestId: kotlin.String, accountId: kotlin.Long) : OrsonAiEmotionsResponse {
        val localVarResponse = getEmotionWithHttpInfo(requestId = requestId, accountId = accountId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OrsonAiEmotionsResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /orson/ai/emotion/{requestId}
     * Get Emotion Results
     * Checks the Emotion analysis and returns in progress, results, or error.
     * @param requestId Orson Request Id
     * @param accountId Sirqul Account Id
     * @return ApiResponse<OrsonAiEmotionsResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getEmotionWithHttpInfo(requestId: kotlin.String, accountId: kotlin.Long) : ApiResponse<OrsonAiEmotionsResponse?> {
        val localVariableConfig = getEmotionRequestConfig(requestId = requestId, accountId = accountId)

        return request<Unit, OrsonAiEmotionsResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getEmotion
     *
     * @param requestId Orson Request Id
     * @param accountId Sirqul Account Id
     * @return RequestConfig
     */
    fun getEmotionRequestConfig(requestId: kotlin.String, accountId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/orson/ai/emotion/{requestId}".replace("{"+"requestId"+"}", encodeURIComponent(requestId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /orson/stories/episodes/{episodeId}/status
     * Check episode status
     * Gets a summary of the episode&#39;s status, including any renders.
     * @param episodeId Episode ID
     * @param accountId Sirqul Account Id
     * @return OrsonEpisodeResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getEpisodeStatus(episodeId: kotlin.Long, accountId: kotlin.Long) : OrsonEpisodeResponse {
        val localVarResponse = getEpisodeStatusWithHttpInfo(episodeId = episodeId, accountId = accountId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OrsonEpisodeResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /orson/stories/episodes/{episodeId}/status
     * Check episode status
     * Gets a summary of the episode&#39;s status, including any renders.
     * @param episodeId Episode ID
     * @param accountId Sirqul Account Id
     * @return ApiResponse<OrsonEpisodeResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getEpisodeStatusWithHttpInfo(episodeId: kotlin.Long, accountId: kotlin.Long) : ApiResponse<OrsonEpisodeResponse?> {
        val localVariableConfig = getEpisodeStatusRequestConfig(episodeId = episodeId, accountId = accountId)

        return request<Unit, OrsonEpisodeResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getEpisodeStatus
     *
     * @param episodeId Episode ID
     * @param accountId Sirqul Account Id
     * @return RequestConfig
     */
    fun getEpisodeStatusRequestConfig(episodeId: kotlin.Long, accountId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/orson/stories/episodes/{episodeId}/status".replace("{"+"episodeId"+"}", encodeURIComponent(episodeId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /orson/stories/renders/{renderId}/status
     * Check episode status
     * Gets a summary of the episode&#39;s status, including any renders.
     * @param renderId Render ID
     * @param accountId Sirqul Account Id
     * @return OrsonRenderResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getRenderStatus(renderId: kotlin.String, accountId: kotlin.Long) : OrsonRenderResponse {
        val localVarResponse = getRenderStatusWithHttpInfo(renderId = renderId, accountId = accountId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OrsonRenderResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /orson/stories/renders/{renderId}/status
     * Check episode status
     * Gets a summary of the episode&#39;s status, including any renders.
     * @param renderId Render ID
     * @param accountId Sirqul Account Id
     * @return ApiResponse<OrsonRenderResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getRenderStatusWithHttpInfo(renderId: kotlin.String, accountId: kotlin.Long) : ApiResponse<OrsonRenderResponse?> {
        val localVariableConfig = getRenderStatusRequestConfig(renderId = renderId, accountId = accountId)

        return request<Unit, OrsonRenderResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getRenderStatus
     *
     * @param renderId Render ID
     * @param accountId Sirqul Account Id
     * @return RequestConfig
     */
    fun getRenderStatusRequestConfig(renderId: kotlin.String, accountId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/orson/stories/renders/{renderId}/status".replace("{"+"renderId"+"}", encodeURIComponent(renderId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /orson/ai/stt/{requestId}
     * Get Speach to Text Result
     * The results of the video transcription and optional translation.
     * @param requestId Orson Request Id
     * @param accountId Sirqul Account Id
     * @return OrsonAiSTTResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getSTT(requestId: kotlin.String, accountId: kotlin.Long) : OrsonAiSTTResponse {
        val localVarResponse = getSTTWithHttpInfo(requestId = requestId, accountId = accountId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OrsonAiSTTResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /orson/ai/stt/{requestId}
     * Get Speach to Text Result
     * The results of the video transcription and optional translation.
     * @param requestId Orson Request Id
     * @param accountId Sirqul Account Id
     * @return ApiResponse<OrsonAiSTTResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getSTTWithHttpInfo(requestId: kotlin.String, accountId: kotlin.Long) : ApiResponse<OrsonAiSTTResponse?> {
        val localVariableConfig = getSTTRequestConfig(requestId = requestId, accountId = accountId)

        return request<Unit, OrsonAiSTTResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getSTT
     *
     * @param requestId Orson Request Id
     * @param accountId Sirqul Account Id
     * @return RequestConfig
     */
    fun getSTTRequestConfig(requestId: kotlin.String, accountId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/orson/ai/stt/{requestId}".replace("{"+"requestId"+"}", encodeURIComponent(requestId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /orson/ai/tts/{requestId}
     * Get Text to Speach Result
     * Check the status of an in progress Text-to-Speech call or download the result.
     * @param requestId Orson Request Id
     * @param accountId Sirqul Account Id
     * @return OrsonAiTTSResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getTTS(requestId: kotlin.String, accountId: kotlin.Long) : OrsonAiTTSResponse {
        val localVarResponse = getTTSWithHttpInfo(requestId = requestId, accountId = accountId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OrsonAiTTSResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /orson/ai/tts/{requestId}
     * Get Text to Speach Result
     * Check the status of an in progress Text-to-Speech call or download the result.
     * @param requestId Orson Request Id
     * @param accountId Sirqul Account Id
     * @return ApiResponse<OrsonAiTTSResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getTTSWithHttpInfo(requestId: kotlin.String, accountId: kotlin.Long) : ApiResponse<OrsonAiTTSResponse?> {
        val localVariableConfig = getTTSRequestConfig(requestId = requestId, accountId = accountId)

        return request<Unit, OrsonAiTTSResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getTTS
     *
     * @param requestId Orson Request Id
     * @param accountId Sirqul Account Id
     * @return RequestConfig
     */
    fun getTTSRequestConfig(requestId: kotlin.String, accountId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/orson/ai/tts/{requestId}".replace("{"+"requestId"+"}", encodeURIComponent(requestId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /orson/ai/techTune/{requestId}
     * Get TechTune Results
     * Get a result or continue waiting for a pending request for TechTune analysis.
     * @param requestId Orson Request Id
     * @param accountId Sirqul Account Id
     * @return OrsonAiTechTuneResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getTechTune(requestId: kotlin.String, accountId: kotlin.Long) : OrsonAiTechTuneResponse {
        val localVarResponse = getTechTuneWithHttpInfo(requestId = requestId, accountId = accountId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OrsonAiTechTuneResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /orson/ai/techTune/{requestId}
     * Get TechTune Results
     * Get a result or continue waiting for a pending request for TechTune analysis.
     * @param requestId Orson Request Id
     * @param accountId Sirqul Account Id
     * @return ApiResponse<OrsonAiTechTuneResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getTechTuneWithHttpInfo(requestId: kotlin.String, accountId: kotlin.Long) : ApiResponse<OrsonAiTechTuneResponse?> {
        val localVariableConfig = getTechTuneRequestConfig(requestId = requestId, accountId = accountId)

        return request<Unit, OrsonAiTechTuneResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getTechTune
     *
     * @param requestId Orson Request Id
     * @param accountId Sirqul Account Id
     * @return RequestConfig
     */
    fun getTechTuneRequestConfig(requestId: kotlin.String, accountId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/orson/ai/techTune/{requestId}".replace("{"+"requestId"+"}", encodeURIComponent(requestId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /orson/ai/topics/{requestId}
     * Get Topics
     * Get the result of an in progress Topics Analysis from an earlier POST.
     * @param requestId Orson Request Id
     * @param accountId Sirqul Account Id
     * @return OrsonAiTopicsResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getTopics(requestId: kotlin.String, accountId: kotlin.Long) : OrsonAiTopicsResponse {
        val localVarResponse = getTopicsWithHttpInfo(requestId = requestId, accountId = accountId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OrsonAiTopicsResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /orson/ai/topics/{requestId}
     * Get Topics
     * Get the result of an in progress Topics Analysis from an earlier POST.
     * @param requestId Orson Request Id
     * @param accountId Sirqul Account Id
     * @return ApiResponse<OrsonAiTopicsResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getTopicsWithHttpInfo(requestId: kotlin.String, accountId: kotlin.Long) : ApiResponse<OrsonAiTopicsResponse?> {
        val localVariableConfig = getTopicsRequestConfig(requestId = requestId, accountId = accountId)

        return request<Unit, OrsonAiTopicsResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getTopics
     *
     * @param requestId Orson Request Id
     * @param accountId Sirqul Account Id
     * @return RequestConfig
     */
    fun getTopicsRequestConfig(requestId: kotlin.String, accountId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/orson/ai/topics/{requestId}".replace("{"+"requestId"+"}", encodeURIComponent(requestId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /orson/ai/voiceCanvas/{requestId}
     * Get VoiceCanvas images
     * Get a result or continue waiting for a pending request for VoiceCanvas Images.
     * @param requestId Orson Request Id
     * @param accountId Sirqul Account Id
     * @return OrsonAiVoiceCanvasResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getVoiceCanvas(requestId: kotlin.String, accountId: kotlin.Long) : OrsonAiVoiceCanvasResponse {
        val localVarResponse = getVoiceCanvasWithHttpInfo(requestId = requestId, accountId = accountId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OrsonAiVoiceCanvasResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /orson/ai/voiceCanvas/{requestId}
     * Get VoiceCanvas images
     * Get a result or continue waiting for a pending request for VoiceCanvas Images.
     * @param requestId Orson Request Id
     * @param accountId Sirqul Account Id
     * @return ApiResponse<OrsonAiVoiceCanvasResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getVoiceCanvasWithHttpInfo(requestId: kotlin.String, accountId: kotlin.Long) : ApiResponse<OrsonAiVoiceCanvasResponse?> {
        val localVariableConfig = getVoiceCanvasRequestConfig(requestId = requestId, accountId = accountId)

        return request<Unit, OrsonAiVoiceCanvasResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getVoiceCanvas
     *
     * @param requestId Orson Request Id
     * @param accountId Sirqul Account Id
     * @return RequestConfig
     */
    fun getVoiceCanvasRequestConfig(requestId: kotlin.String, accountId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/orson/ai/voiceCanvas/{requestId}".replace("{"+"requestId"+"}", encodeURIComponent(requestId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /orson/stories/renders
     * Starts a StoryStitch video render
     * Starts a StoryStitch video render to produce your final video, returning the status details.
     * @param accountId Sirqul Account Id
     * @param `data` Request Data String
     * @return OrsonRenderResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun startVideoRender(accountId: kotlin.Long, `data`: kotlin.String) : OrsonRenderResponse {
        val localVarResponse = startVideoRenderWithHttpInfo(accountId = accountId, `data` = `data`)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OrsonRenderResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /orson/stories/renders
     * Starts a StoryStitch video render
     * Starts a StoryStitch video render to produce your final video, returning the status details.
     * @param accountId Sirqul Account Id
     * @param `data` Request Data String
     * @return ApiResponse<OrsonRenderResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun startVideoRenderWithHttpInfo(accountId: kotlin.Long, `data`: kotlin.String) : ApiResponse<OrsonRenderResponse?> {
        val localVariableConfig = startVideoRenderRequestConfig(accountId = accountId, `data` = `data`)

        return request<Unit, OrsonRenderResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation startVideoRender
     *
     * @param accountId Sirqul Account Id
     * @param `data` Request Data String
     * @return RequestConfig
     */
    fun startVideoRenderRequestConfig(accountId: kotlin.Long, `data`: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("data", listOf(`data`.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/orson/stories/renders",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /orson/ai/stt
     * Speach to Text
     * Accepts a movie URL or uploaded file and transcribes it. You also have the option to translate it into one of our additional supported languages.
     * @param accountId Sirqul Account Id
     * @param thirdPartyAccountId A third-party account id that is meaningful to your systems (optional)
     * @param sourceLanguage Source Language (optional)
     * @param targetLanguage Target Language (optional)
     * @param file An uploaded recording to analyze (Currently limited to 10MB) (optional)
     * @param url A recording file to download and analyze (Size limit: 1GB) (optional)
     * @param paramCallback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
     * @return OrsonAiSTTResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stt(accountId: kotlin.Long, thirdPartyAccountId: kotlin.String? = null, sourceLanguage: kotlin.String? = null, targetLanguage: kotlin.String? = null, file: java.io.File? = null, url: kotlin.String? = null, paramCallback: kotlin.String? = null) : OrsonAiSTTResponse {
        val localVarResponse = sttWithHttpInfo(accountId = accountId, thirdPartyAccountId = thirdPartyAccountId, sourceLanguage = sourceLanguage, targetLanguage = targetLanguage, file = file, url = url, paramCallback = paramCallback)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OrsonAiSTTResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /orson/ai/stt
     * Speach to Text
     * Accepts a movie URL or uploaded file and transcribes it. You also have the option to translate it into one of our additional supported languages.
     * @param accountId Sirqul Account Id
     * @param thirdPartyAccountId A third-party account id that is meaningful to your systems (optional)
     * @param sourceLanguage Source Language (optional)
     * @param targetLanguage Target Language (optional)
     * @param file An uploaded recording to analyze (Currently limited to 10MB) (optional)
     * @param url A recording file to download and analyze (Size limit: 1GB) (optional)
     * @param paramCallback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
     * @return ApiResponse<OrsonAiSTTResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sttWithHttpInfo(accountId: kotlin.Long, thirdPartyAccountId: kotlin.String?, sourceLanguage: kotlin.String?, targetLanguage: kotlin.String?, file: java.io.File?, url: kotlin.String?, paramCallback: kotlin.String?) : ApiResponse<OrsonAiSTTResponse?> {
        val localVariableConfig = sttRequestConfig(accountId = accountId, thirdPartyAccountId = thirdPartyAccountId, sourceLanguage = sourceLanguage, targetLanguage = targetLanguage, file = file, url = url, paramCallback = paramCallback)

        return request<Unit, OrsonAiSTTResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stt
     *
     * @param accountId Sirqul Account Id
     * @param thirdPartyAccountId A third-party account id that is meaningful to your systems (optional)
     * @param sourceLanguage Source Language (optional)
     * @param targetLanguage Target Language (optional)
     * @param file An uploaded recording to analyze (Currently limited to 10MB) (optional)
     * @param url A recording file to download and analyze (Size limit: 1GB) (optional)
     * @param paramCallback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
     * @return RequestConfig
     */
    fun sttRequestConfig(accountId: kotlin.Long, thirdPartyAccountId: kotlin.String?, sourceLanguage: kotlin.String?, targetLanguage: kotlin.String?, file: java.io.File?, url: kotlin.String?, paramCallback: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                if (thirdPartyAccountId != null) {
                    put("thirdPartyAccountId", listOf(thirdPartyAccountId.toString()))
                }
                if (sourceLanguage != null) {
                    put("sourceLanguage", listOf(sourceLanguage.toString()))
                }
                if (targetLanguage != null) {
                    put("targetLanguage", listOf(targetLanguage.toString()))
                }
                if (file != null) {
                    put("file", listOf(file.toString()))
                }
                if (url != null) {
                    put("url", listOf(url.toString()))
                }
                if (paramCallback != null) {
                    put("callback", listOf(paramCallback.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/orson/ai/stt",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /orson/ai/topics
     * Summarize Topics
     * Takes in a string of text sentences (also known as a document) and returns a list of associated topics and their proximity score.
     * @param accountId Sirqul Account Id
     * @param thirdPartyAccountId A third-party account id that is meaningful to your systems (optional)
     * @param doc The text to get topics for. (optional)
     * @param file An uploaded recording to analyze (Currently limited to 10MB) (optional)
     * @param url A recording file to download and analyze (Size limit: 1GB) (optional)
     * @param limit The number of results to return (optional)
     * @param offset The starting offset into the total result set to start from (optional)
     * @param paramCallback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
     * @return OrsonAiTopicsResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun summarizeTopics(accountId: kotlin.Long, thirdPartyAccountId: kotlin.String? = null, doc: kotlin.String? = null, file: java.io.File? = null, url: kotlin.String? = null, limit: kotlin.Int? = null, offset: kotlin.Int? = null, paramCallback: kotlin.String? = null) : OrsonAiTopicsResponse {
        val localVarResponse = summarizeTopicsWithHttpInfo(accountId = accountId, thirdPartyAccountId = thirdPartyAccountId, doc = doc, file = file, url = url, limit = limit, offset = offset, paramCallback = paramCallback)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OrsonAiTopicsResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /orson/ai/topics
     * Summarize Topics
     * Takes in a string of text sentences (also known as a document) and returns a list of associated topics and their proximity score.
     * @param accountId Sirqul Account Id
     * @param thirdPartyAccountId A third-party account id that is meaningful to your systems (optional)
     * @param doc The text to get topics for. (optional)
     * @param file An uploaded recording to analyze (Currently limited to 10MB) (optional)
     * @param url A recording file to download and analyze (Size limit: 1GB) (optional)
     * @param limit The number of results to return (optional)
     * @param offset The starting offset into the total result set to start from (optional)
     * @param paramCallback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
     * @return ApiResponse<OrsonAiTopicsResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun summarizeTopicsWithHttpInfo(accountId: kotlin.Long, thirdPartyAccountId: kotlin.String?, doc: kotlin.String?, file: java.io.File?, url: kotlin.String?, limit: kotlin.Int?, offset: kotlin.Int?, paramCallback: kotlin.String?) : ApiResponse<OrsonAiTopicsResponse?> {
        val localVariableConfig = summarizeTopicsRequestConfig(accountId = accountId, thirdPartyAccountId = thirdPartyAccountId, doc = doc, file = file, url = url, limit = limit, offset = offset, paramCallback = paramCallback)

        return request<Unit, OrsonAiTopicsResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation summarizeTopics
     *
     * @param accountId Sirqul Account Id
     * @param thirdPartyAccountId A third-party account id that is meaningful to your systems (optional)
     * @param doc The text to get topics for. (optional)
     * @param file An uploaded recording to analyze (Currently limited to 10MB) (optional)
     * @param url A recording file to download and analyze (Size limit: 1GB) (optional)
     * @param limit The number of results to return (optional)
     * @param offset The starting offset into the total result set to start from (optional)
     * @param paramCallback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
     * @return RequestConfig
     */
    fun summarizeTopicsRequestConfig(accountId: kotlin.Long, thirdPartyAccountId: kotlin.String?, doc: kotlin.String?, file: java.io.File?, url: kotlin.String?, limit: kotlin.Int?, offset: kotlin.Int?, paramCallback: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                if (thirdPartyAccountId != null) {
                    put("thirdPartyAccountId", listOf(thirdPartyAccountId.toString()))
                }
                if (doc != null) {
                    put("doc", listOf(doc.toString()))
                }
                if (file != null) {
                    put("file", listOf(file.toString()))
                }
                if (url != null) {
                    put("url", listOf(url.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
                if (paramCallback != null) {
                    put("callback", listOf(paramCallback.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/orson/ai/topics",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /orson/ai/techTune
     * Detect Technical Issues
     * Analyses a movie file to detect technical issues, such as too few people in frame.
     * @param accountId Sirqul Account Id
     * @param numFacesExpected Number of expected faces
     * @param thirdPartyAccountId A third-party account id that is meaningful to your systems (optional)
     * @param file An uploaded recording to analyze (Currently limited to 10MB) (optional)
     * @param url A recording file to download and analyze (Size limit: 1GB) (optional)
     * @param paramCallback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
     * @return OrsonAiTechTuneResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun techTune(accountId: kotlin.Long, numFacesExpected: kotlin.Int, thirdPartyAccountId: kotlin.String? = null, file: java.io.File? = null, url: kotlin.String? = null, paramCallback: kotlin.String? = null) : OrsonAiTechTuneResponse {
        val localVarResponse = techTuneWithHttpInfo(accountId = accountId, numFacesExpected = numFacesExpected, thirdPartyAccountId = thirdPartyAccountId, file = file, url = url, paramCallback = paramCallback)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OrsonAiTechTuneResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /orson/ai/techTune
     * Detect Technical Issues
     * Analyses a movie file to detect technical issues, such as too few people in frame.
     * @param accountId Sirqul Account Id
     * @param numFacesExpected Number of expected faces
     * @param thirdPartyAccountId A third-party account id that is meaningful to your systems (optional)
     * @param file An uploaded recording to analyze (Currently limited to 10MB) (optional)
     * @param url A recording file to download and analyze (Size limit: 1GB) (optional)
     * @param paramCallback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
     * @return ApiResponse<OrsonAiTechTuneResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun techTuneWithHttpInfo(accountId: kotlin.Long, numFacesExpected: kotlin.Int, thirdPartyAccountId: kotlin.String?, file: java.io.File?, url: kotlin.String?, paramCallback: kotlin.String?) : ApiResponse<OrsonAiTechTuneResponse?> {
        val localVariableConfig = techTuneRequestConfig(accountId = accountId, numFacesExpected = numFacesExpected, thirdPartyAccountId = thirdPartyAccountId, file = file, url = url, paramCallback = paramCallback)

        return request<Unit, OrsonAiTechTuneResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation techTune
     *
     * @param accountId Sirqul Account Id
     * @param numFacesExpected Number of expected faces
     * @param thirdPartyAccountId A third-party account id that is meaningful to your systems (optional)
     * @param file An uploaded recording to analyze (Currently limited to 10MB) (optional)
     * @param url A recording file to download and analyze (Size limit: 1GB) (optional)
     * @param paramCallback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
     * @return RequestConfig
     */
    fun techTuneRequestConfig(accountId: kotlin.Long, numFacesExpected: kotlin.Int, thirdPartyAccountId: kotlin.String?, file: java.io.File?, url: kotlin.String?, paramCallback: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                if (thirdPartyAccountId != null) {
                    put("thirdPartyAccountId", listOf(thirdPartyAccountId.toString()))
                }
                put("numFacesExpected", listOf(numFacesExpected.toString()))
                if (file != null) {
                    put("file", listOf(file.toString()))
                }
                if (url != null) {
                    put("url", listOf(url.toString()))
                }
                if (paramCallback != null) {
                    put("callback", listOf(paramCallback.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/orson/ai/techTune",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /orson/ai/tts
     * Text to Speach
     * Creates an audio file for the given text, with the option of language and voice selection.
     * @param accountId Sirqul Account Id
     * @param text Text
     * @param thirdPartyAccountId A third-party account id that is meaningful to your systems (optional)
     * @param language The language to use for the speaker and incoming text (optional)
     * @param voice A language-specific voice to use, or picks the language default if not provided (optional)
     * @param paramCallback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
     * @return OrsonAiTTSResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun tts(accountId: kotlin.Long, text: kotlin.String, thirdPartyAccountId: kotlin.String? = null, language: kotlin.String? = null, voice: kotlin.String? = null, paramCallback: kotlin.String? = null) : OrsonAiTTSResponse {
        val localVarResponse = ttsWithHttpInfo(accountId = accountId, text = text, thirdPartyAccountId = thirdPartyAccountId, language = language, voice = voice, paramCallback = paramCallback)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OrsonAiTTSResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /orson/ai/tts
     * Text to Speach
     * Creates an audio file for the given text, with the option of language and voice selection.
     * @param accountId Sirqul Account Id
     * @param text Text
     * @param thirdPartyAccountId A third-party account id that is meaningful to your systems (optional)
     * @param language The language to use for the speaker and incoming text (optional)
     * @param voice A language-specific voice to use, or picks the language default if not provided (optional)
     * @param paramCallback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
     * @return ApiResponse<OrsonAiTTSResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun ttsWithHttpInfo(accountId: kotlin.Long, text: kotlin.String, thirdPartyAccountId: kotlin.String?, language: kotlin.String?, voice: kotlin.String?, paramCallback: kotlin.String?) : ApiResponse<OrsonAiTTSResponse?> {
        val localVariableConfig = ttsRequestConfig(accountId = accountId, text = text, thirdPartyAccountId = thirdPartyAccountId, language = language, voice = voice, paramCallback = paramCallback)

        return request<Unit, OrsonAiTTSResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation tts
     *
     * @param accountId Sirqul Account Id
     * @param text Text
     * @param thirdPartyAccountId A third-party account id that is meaningful to your systems (optional)
     * @param language The language to use for the speaker and incoming text (optional)
     * @param voice A language-specific voice to use, or picks the language default if not provided (optional)
     * @param paramCallback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
     * @return RequestConfig
     */
    fun ttsRequestConfig(accountId: kotlin.Long, text: kotlin.String, thirdPartyAccountId: kotlin.String?, language: kotlin.String?, voice: kotlin.String?, paramCallback: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                if (thirdPartyAccountId != null) {
                    put("thirdPartyAccountId", listOf(thirdPartyAccountId.toString()))
                }
                put("text", listOf(text.toString()))
                if (language != null) {
                    put("language", listOf(language.toString()))
                }
                if (voice != null) {
                    put("voice", listOf(voice.toString()))
                }
                if (paramCallback != null) {
                    put("callback", listOf(paramCallback.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/orson/ai/tts",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
