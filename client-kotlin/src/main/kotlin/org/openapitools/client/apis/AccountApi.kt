/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import org.openapitools.client.models.AccountLoginResponse
import org.openapitools.client.models.AssetListResponse
import org.openapitools.client.models.ProfileInfoResponse
import org.openapitools.client.models.ProfileResponse
import org.openapitools.client.models.SirqulResponse
import org.openapitools.client.models.UserLocationSearchResponse
import org.openapitools.client.models.UserSettingsResponse

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

open class AccountApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://dev.sirqul.com/api/3.18")
        }
    }

    /**
     * GET /account/search
     * Search Accounts by Location
     * Search accounts by their location. This only searches on users that have location data. Use ConnectionApi to perform a regular search on accounts.
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param q Deprecated - legacy query parameter (optional)
     * @param keyword An optional keyword to search on, will be ignore if empty (NOT implemented yet) (optional)
     * @param postalCode The postal code to search on, either postalCode or the user&#39;s exact location is required (optional)
     * @param latitude The latitude of the user, either postalCode or the user&#39;s exact location is required (optional)
     * @param longitude The longitude of the user, either postalCode or the user&#39;s exact location is required (optional)
     * @param appKey The application key (optional)
     * @param range The range to search on (optional, default to 10.0)
     * @param locationLastUpdated Searches for user&#39;s that has updated their location since this date (optional)
     * @param gender The preferred gender (optional)
     * @param minAge The preferred min age (optional)
     * @param maxAge The preferred max age (optional)
     * @param companionshipIndex The preferred companionship index (optional)
     * @param i this is the start index of a query (optional)
     * @param start Start of the pagination (optional, default to 0)
     * @param l this is the limit index of a query (optional)
     * @param limit Limit of the pagination (optional, default to 100)
     * @param searchMode Search mode to use for index searches (e.g. CLOUDINDEX, OPENSEARCH) (optional)
     * @param sortField Sorting field for results (default: DISTANCE) (optional)
     * @param descending Whether to sort descending (default: false) (optional)
     * @param roles Roles to filter on (optional)
     * @param tags Tags to filter on (optional)
     * @param experience The experience to filter on (optional)
     * @param categoryIds The category ids to filter on (comma separated) (optional)
     * @param audienceIds The audience ids to filter on (comma separated) (optional)
     * @param audienceOperator Operator used to combine audience filters (default: AND) (optional, default to "AND")
     * @param updateCurrentLocation Whether to use the given lat &amp; long to update the user&#39;s current location (optional, default to false)
     * @param updatePreferredSettings Whether to use the given parameters to update the user&#39;s preferred settings (optional, default to false)
     * @param showExactLocations Determines whether to always display user exact locations (optional, default to true)
     * @param showConnectionToSearcher Return connection of the accounts in the result to the passed in account if there exists any (optional, default to false)
     * @param flagCountMinimum Return any results that have a minimum of the specified flag count (even ones that have met the flag threshold) (optional)
     * @param verifiedUserOnly Returns only verified users (optional)
     * @param contentAdminOnly Returns only content admin users (optional)
     * @return UserLocationSearchResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun accountLocationSearch(deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, q: kotlin.String? = null, keyword: kotlin.String? = null, postalCode: kotlin.String? = null, latitude: kotlin.Double? = null, longitude: kotlin.Double? = null, appKey: kotlin.String? = null, range: kotlin.Double? = 10.0, locationLastUpdated: kotlin.Long? = null, gender: kotlin.String? = null, minAge: kotlin.Int? = null, maxAge: kotlin.Int? = null, companionshipIndex: kotlin.Int? = null, i: kotlin.Int? = null, start: kotlin.Int? = 0, l: kotlin.Int? = null, limit: kotlin.Int? = 100, searchMode: kotlin.String? = null, sortField: kotlin.String? = null, descending: kotlin.Boolean? = null, roles: kotlin.String? = null, tags: kotlin.String? = null, experience: kotlin.String? = null, categoryIds: kotlin.String? = null, audienceIds: kotlin.String? = null, audienceOperator: kotlin.String? = "AND", updateCurrentLocation: kotlin.Boolean? = false, updatePreferredSettings: kotlin.Boolean? = false, showExactLocations: kotlin.Boolean? = true, showConnectionToSearcher: kotlin.Boolean? = false, flagCountMinimum: kotlin.Long? = null, verifiedUserOnly: kotlin.Boolean? = null, contentAdminOnly: kotlin.Boolean? = null) : UserLocationSearchResponse {
        val localVarResponse = accountLocationSearchWithHttpInfo(deviceId = deviceId, accountId = accountId, q = q, keyword = keyword, postalCode = postalCode, latitude = latitude, longitude = longitude, appKey = appKey, range = range, locationLastUpdated = locationLastUpdated, gender = gender, minAge = minAge, maxAge = maxAge, companionshipIndex = companionshipIndex, i = i, start = start, l = l, limit = limit, searchMode = searchMode, sortField = sortField, descending = descending, roles = roles, tags = tags, experience = experience, categoryIds = categoryIds, audienceIds = audienceIds, audienceOperator = audienceOperator, updateCurrentLocation = updateCurrentLocation, updatePreferredSettings = updatePreferredSettings, showExactLocations = showExactLocations, showConnectionToSearcher = showConnectionToSearcher, flagCountMinimum = flagCountMinimum, verifiedUserOnly = verifiedUserOnly, contentAdminOnly = contentAdminOnly)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UserLocationSearchResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /account/search
     * Search Accounts by Location
     * Search accounts by their location. This only searches on users that have location data. Use ConnectionApi to perform a regular search on accounts.
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param q Deprecated - legacy query parameter (optional)
     * @param keyword An optional keyword to search on, will be ignore if empty (NOT implemented yet) (optional)
     * @param postalCode The postal code to search on, either postalCode or the user&#39;s exact location is required (optional)
     * @param latitude The latitude of the user, either postalCode or the user&#39;s exact location is required (optional)
     * @param longitude The longitude of the user, either postalCode or the user&#39;s exact location is required (optional)
     * @param appKey The application key (optional)
     * @param range The range to search on (optional, default to 10.0)
     * @param locationLastUpdated Searches for user&#39;s that has updated their location since this date (optional)
     * @param gender The preferred gender (optional)
     * @param minAge The preferred min age (optional)
     * @param maxAge The preferred max age (optional)
     * @param companionshipIndex The preferred companionship index (optional)
     * @param i this is the start index of a query (optional)
     * @param start Start of the pagination (optional, default to 0)
     * @param l this is the limit index of a query (optional)
     * @param limit Limit of the pagination (optional, default to 100)
     * @param searchMode Search mode to use for index searches (e.g. CLOUDINDEX, OPENSEARCH) (optional)
     * @param sortField Sorting field for results (default: DISTANCE) (optional)
     * @param descending Whether to sort descending (default: false) (optional)
     * @param roles Roles to filter on (optional)
     * @param tags Tags to filter on (optional)
     * @param experience The experience to filter on (optional)
     * @param categoryIds The category ids to filter on (comma separated) (optional)
     * @param audienceIds The audience ids to filter on (comma separated) (optional)
     * @param audienceOperator Operator used to combine audience filters (default: AND) (optional, default to "AND")
     * @param updateCurrentLocation Whether to use the given lat &amp; long to update the user&#39;s current location (optional, default to false)
     * @param updatePreferredSettings Whether to use the given parameters to update the user&#39;s preferred settings (optional, default to false)
     * @param showExactLocations Determines whether to always display user exact locations (optional, default to true)
     * @param showConnectionToSearcher Return connection of the accounts in the result to the passed in account if there exists any (optional, default to false)
     * @param flagCountMinimum Return any results that have a minimum of the specified flag count (even ones that have met the flag threshold) (optional)
     * @param verifiedUserOnly Returns only verified users (optional)
     * @param contentAdminOnly Returns only content admin users (optional)
     * @return ApiResponse<UserLocationSearchResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun accountLocationSearchWithHttpInfo(deviceId: kotlin.String?, accountId: kotlin.Long?, q: kotlin.String?, keyword: kotlin.String?, postalCode: kotlin.String?, latitude: kotlin.Double?, longitude: kotlin.Double?, appKey: kotlin.String?, range: kotlin.Double?, locationLastUpdated: kotlin.Long?, gender: kotlin.String?, minAge: kotlin.Int?, maxAge: kotlin.Int?, companionshipIndex: kotlin.Int?, i: kotlin.Int?, start: kotlin.Int?, l: kotlin.Int?, limit: kotlin.Int?, searchMode: kotlin.String?, sortField: kotlin.String?, descending: kotlin.Boolean?, roles: kotlin.String?, tags: kotlin.String?, experience: kotlin.String?, categoryIds: kotlin.String?, audienceIds: kotlin.String?, audienceOperator: kotlin.String?, updateCurrentLocation: kotlin.Boolean?, updatePreferredSettings: kotlin.Boolean?, showExactLocations: kotlin.Boolean?, showConnectionToSearcher: kotlin.Boolean?, flagCountMinimum: kotlin.Long?, verifiedUserOnly: kotlin.Boolean?, contentAdminOnly: kotlin.Boolean?) : ApiResponse<UserLocationSearchResponse?> {
        val localVariableConfig = accountLocationSearchRequestConfig(deviceId = deviceId, accountId = accountId, q = q, keyword = keyword, postalCode = postalCode, latitude = latitude, longitude = longitude, appKey = appKey, range = range, locationLastUpdated = locationLastUpdated, gender = gender, minAge = minAge, maxAge = maxAge, companionshipIndex = companionshipIndex, i = i, start = start, l = l, limit = limit, searchMode = searchMode, sortField = sortField, descending = descending, roles = roles, tags = tags, experience = experience, categoryIds = categoryIds, audienceIds = audienceIds, audienceOperator = audienceOperator, updateCurrentLocation = updateCurrentLocation, updatePreferredSettings = updatePreferredSettings, showExactLocations = showExactLocations, showConnectionToSearcher = showConnectionToSearcher, flagCountMinimum = flagCountMinimum, verifiedUserOnly = verifiedUserOnly, contentAdminOnly = contentAdminOnly)

        return request<Unit, UserLocationSearchResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation accountLocationSearch
     *
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param q Deprecated - legacy query parameter (optional)
     * @param keyword An optional keyword to search on, will be ignore if empty (NOT implemented yet) (optional)
     * @param postalCode The postal code to search on, either postalCode or the user&#39;s exact location is required (optional)
     * @param latitude The latitude of the user, either postalCode or the user&#39;s exact location is required (optional)
     * @param longitude The longitude of the user, either postalCode or the user&#39;s exact location is required (optional)
     * @param appKey The application key (optional)
     * @param range The range to search on (optional, default to 10.0)
     * @param locationLastUpdated Searches for user&#39;s that has updated their location since this date (optional)
     * @param gender The preferred gender (optional)
     * @param minAge The preferred min age (optional)
     * @param maxAge The preferred max age (optional)
     * @param companionshipIndex The preferred companionship index (optional)
     * @param i this is the start index of a query (optional)
     * @param start Start of the pagination (optional, default to 0)
     * @param l this is the limit index of a query (optional)
     * @param limit Limit of the pagination (optional, default to 100)
     * @param searchMode Search mode to use for index searches (e.g. CLOUDINDEX, OPENSEARCH) (optional)
     * @param sortField Sorting field for results (default: DISTANCE) (optional)
     * @param descending Whether to sort descending (default: false) (optional)
     * @param roles Roles to filter on (optional)
     * @param tags Tags to filter on (optional)
     * @param experience The experience to filter on (optional)
     * @param categoryIds The category ids to filter on (comma separated) (optional)
     * @param audienceIds The audience ids to filter on (comma separated) (optional)
     * @param audienceOperator Operator used to combine audience filters (default: AND) (optional, default to "AND")
     * @param updateCurrentLocation Whether to use the given lat &amp; long to update the user&#39;s current location (optional, default to false)
     * @param updatePreferredSettings Whether to use the given parameters to update the user&#39;s preferred settings (optional, default to false)
     * @param showExactLocations Determines whether to always display user exact locations (optional, default to true)
     * @param showConnectionToSearcher Return connection of the accounts in the result to the passed in account if there exists any (optional, default to false)
     * @param flagCountMinimum Return any results that have a minimum of the specified flag count (even ones that have met the flag threshold) (optional)
     * @param verifiedUserOnly Returns only verified users (optional)
     * @param contentAdminOnly Returns only content admin users (optional)
     * @return RequestConfig
     */
    fun accountLocationSearchRequestConfig(deviceId: kotlin.String?, accountId: kotlin.Long?, q: kotlin.String?, keyword: kotlin.String?, postalCode: kotlin.String?, latitude: kotlin.Double?, longitude: kotlin.Double?, appKey: kotlin.String?, range: kotlin.Double?, locationLastUpdated: kotlin.Long?, gender: kotlin.String?, minAge: kotlin.Int?, maxAge: kotlin.Int?, companionshipIndex: kotlin.Int?, i: kotlin.Int?, start: kotlin.Int?, l: kotlin.Int?, limit: kotlin.Int?, searchMode: kotlin.String?, sortField: kotlin.String?, descending: kotlin.Boolean?, roles: kotlin.String?, tags: kotlin.String?, experience: kotlin.String?, categoryIds: kotlin.String?, audienceIds: kotlin.String?, audienceOperator: kotlin.String?, updateCurrentLocation: kotlin.Boolean?, updatePreferredSettings: kotlin.Boolean?, showExactLocations: kotlin.Boolean?, showConnectionToSearcher: kotlin.Boolean?, flagCountMinimum: kotlin.Long?, verifiedUserOnly: kotlin.Boolean?, contentAdminOnly: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (q != null) {
                    put("q", listOf(q.toString()))
                }
                if (keyword != null) {
                    put("keyword", listOf(keyword.toString()))
                }
                if (postalCode != null) {
                    put("postalCode", listOf(postalCode.toString()))
                }
                if (latitude != null) {
                    put("latitude", listOf(latitude.toString()))
                }
                if (longitude != null) {
                    put("longitude", listOf(longitude.toString()))
                }
                if (appKey != null) {
                    put("appKey", listOf(appKey.toString()))
                }
                if (range != null) {
                    put("range", listOf(range.toString()))
                }
                if (locationLastUpdated != null) {
                    put("locationLastUpdated", listOf(locationLastUpdated.toString()))
                }
                if (gender != null) {
                    put("gender", listOf(gender.toString()))
                }
                if (minAge != null) {
                    put("minAge", listOf(minAge.toString()))
                }
                if (maxAge != null) {
                    put("maxAge", listOf(maxAge.toString()))
                }
                if (companionshipIndex != null) {
                    put("companionshipIndex", listOf(companionshipIndex.toString()))
                }
                if (i != null) {
                    put("_i", listOf(i.toString()))
                }
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (l != null) {
                    put("_l", listOf(l.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (searchMode != null) {
                    put("searchMode", listOf(searchMode.toString()))
                }
                if (sortField != null) {
                    put("sortField", listOf(sortField.toString()))
                }
                if (descending != null) {
                    put("descending", listOf(descending.toString()))
                }
                if (roles != null) {
                    put("roles", listOf(roles.toString()))
                }
                if (tags != null) {
                    put("tags", listOf(tags.toString()))
                }
                if (experience != null) {
                    put("experience", listOf(experience.toString()))
                }
                if (categoryIds != null) {
                    put("categoryIds", listOf(categoryIds.toString()))
                }
                if (audienceIds != null) {
                    put("audienceIds", listOf(audienceIds.toString()))
                }
                if (audienceOperator != null) {
                    put("audienceOperator", listOf(audienceOperator.toString()))
                }
                if (updateCurrentLocation != null) {
                    put("updateCurrentLocation", listOf(updateCurrentLocation.toString()))
                }
                if (updatePreferredSettings != null) {
                    put("updatePreferredSettings", listOf(updatePreferredSettings.toString()))
                }
                if (showExactLocations != null) {
                    put("showExactLocations", listOf(showExactLocations.toString()))
                }
                if (showConnectionToSearcher != null) {
                    put("showConnectionToSearcher", listOf(showConnectionToSearcher.toString()))
                }
                if (flagCountMinimum != null) {
                    put("flagCountMinimum", listOf(flagCountMinimum.toString()))
                }
                if (verifiedUserOnly != null) {
                    put("verifiedUserOnly", listOf(verifiedUserOnly.toString()))
                }
                if (contentAdminOnly != null) {
                    put("contentAdminOnly", listOf(contentAdminOnly.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/account/search",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /account/block
     * Block Account
     * Moves or removes an account into the user&#39;s blocked group.
     * @param accountIdBeingBlocked The id of the account to be blocked/unblocked
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param blockFlagValue Determines whether the account is blocked or unblocked (optional, default to true)
     * @param removeFromGroupsIfBlocked Determines whether the account is removed from all other groups if blocked (optional, default to false)
     * @param latitude The current latitude of the user (optional)
     * @param longitude The current longitude of the user (optional)
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun blockAccount(accountIdBeingBlocked: kotlin.Long, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, blockFlagValue: kotlin.Boolean? = true, removeFromGroupsIfBlocked: kotlin.Boolean? = false, latitude: kotlin.Double? = null, longitude: kotlin.Double? = null) : SirqulResponse {
        val localVarResponse = blockAccountWithHttpInfo(accountIdBeingBlocked = accountIdBeingBlocked, deviceId = deviceId, accountId = accountId, blockFlagValue = blockFlagValue, removeFromGroupsIfBlocked = removeFromGroupsIfBlocked, latitude = latitude, longitude = longitude)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /account/block
     * Block Account
     * Moves or removes an account into the user&#39;s blocked group.
     * @param accountIdBeingBlocked The id of the account to be blocked/unblocked
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param blockFlagValue Determines whether the account is blocked or unblocked (optional, default to true)
     * @param removeFromGroupsIfBlocked Determines whether the account is removed from all other groups if blocked (optional, default to false)
     * @param latitude The current latitude of the user (optional)
     * @param longitude The current longitude of the user (optional)
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun blockAccountWithHttpInfo(accountIdBeingBlocked: kotlin.Long, deviceId: kotlin.String?, accountId: kotlin.Long?, blockFlagValue: kotlin.Boolean?, removeFromGroupsIfBlocked: kotlin.Boolean?, latitude: kotlin.Double?, longitude: kotlin.Double?) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = blockAccountRequestConfig(accountIdBeingBlocked = accountIdBeingBlocked, deviceId = deviceId, accountId = accountId, blockFlagValue = blockFlagValue, removeFromGroupsIfBlocked = removeFromGroupsIfBlocked, latitude = latitude, longitude = longitude)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation blockAccount
     *
     * @param accountIdBeingBlocked The id of the account to be blocked/unblocked
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param blockFlagValue Determines whether the account is blocked or unblocked (optional, default to true)
     * @param removeFromGroupsIfBlocked Determines whether the account is removed from all other groups if blocked (optional, default to false)
     * @param latitude The current latitude of the user (optional)
     * @param longitude The current longitude of the user (optional)
     * @return RequestConfig
     */
    fun blockAccountRequestConfig(accountIdBeingBlocked: kotlin.Long, deviceId: kotlin.String?, accountId: kotlin.Long?, blockFlagValue: kotlin.Boolean?, removeFromGroupsIfBlocked: kotlin.Boolean?, latitude: kotlin.Double?, longitude: kotlin.Double?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                put("accountIdBeingBlocked", listOf(accountIdBeingBlocked.toString()))
                if (blockFlagValue != null) {
                    put("blockFlagValue", listOf(blockFlagValue.toString()))
                }
                if (removeFromGroupsIfBlocked != null) {
                    put("removeFromGroupsIfBlocked", listOf(removeFromGroupsIfBlocked.toString()))
                }
                if (latitude != null) {
                    put("latitude", listOf(latitude.toString()))
                }
                if (longitude != null) {
                    put("longitude", listOf(longitude.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/account/block",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /account/create
     * Create Account
     * Create a new account by role.
     * @param username The access token to authenticate with (ex: username)
     * @param password The secret to authenticate with (ex: password)
     * @param name The full name of the user. If this parameter is NOT empty, the following parameters will be ignored: prefixName, firstName, middleName, lastName, and suffixName (optional)
     * @param prefixName If the parameter &#39;name&#39; is empty or not present, this field will be used to set the prefix of the user&#39;s name (optional)
     * @param firstName If the parameter &#39;name&#39; is empty or not present, this field will be used to set the user&#39;s first name (optional)
     * @param middleName If the parameter &#39;name&#39; is empty or not present, this field will be used to set the user&#39;s middle name (optional)
     * @param lastName If the parameter &#39;name&#39; is empty or not present, this field will be used to set the user&#39;s last name (optional)
     * @param suffixName If the parameter &#39;name&#39; is empty or not present, this field will be used to set the suffix of the user&#39;s name (optional)
     * @param title This field will be used to set the user&#39;s job title (optional)
     * @param deviceId The unique id of the device making the request (optional)
     * @param deviceIdType The type of device id (this is defined by the client), ie. MAC_ADDRESS, APPLE_UDID, etc (optional)
     * @param emailAddress The user&#39;s contact email address (NOT the username) (optional)
     * @param assetId The asset id to set the user&#39;s profile image (optional)
     * @param streetAddress The street address of the user&#39;s contact location (optional)
     * @param zipcode The zipcode of the user&#39;s contact location (optional)
     * @param gender The gender of the user (AudienceGender) (optional)
     * @param birthday The birthday date of the user in UTC milliseconds (optional)
     * @param homePhone The home phone number (optional)
     * @param cellPhone The cellular phone number (optional)
     * @param cellPhoneCarrier The cellular service provider (optional)
     * @param businessPhone The business phone number (optional)
     * @param role The account role (default: MEMBER) (optional)
     * @param platforms Comma separated list of development platforms (optional)
     * @param tags Search tags (optional)
     * @param aboutUs About us information (optional)
     * @param gameExperience Game experience of the user (optional)
     * @param categoryIds A list of category ids that represent interests and associations (optional)
     * @param hometown The user&#39;s hometown (optional)
     * @param height The user&#39;s height (optional)
     * @param heightIndex The user&#39;s height in a numerical value that can be used for ordering/searching (optional)
     * @param ethnicity The user&#39;s ethnicity (optional)
     * @param bodyType The user&#39;s body type (optional)
     * @param maritalStatus The user&#39;s marital status (optional)
     * @param children The user&#39;s children status (optional)
     * @param religion The user&#39;s religion (optional)
     * @param education The user&#39;s education (optional)
     * @param educationIndex The user&#39;s education in a numerical value that can be used for ordering/searching (optional)
     * @param smoke The user&#39;s smoke status (optional)
     * @param drink The user&#39;s drink status (optional)
     * @param companionship The user&#39;s companionship status (optional)
     * @param companionshipIndex The user&#39;s companionship index (optional)
     * @param preferredMinAge The preferred minimum age in the account location search (optional)
     * @param preferredMaxAge The preferred maximum age in the account location search (optional)
     * @param preferredMinHeight The preferred minimum height in the account location search (optional)
     * @param preferredMaxHeight The preferred maximum height in the account location search (optional)
     * @param preferredGender The preferred gender in the account location search (optional)
     * @param preferredEducation The preferred education in the account location search (optional)
     * @param preferredEducationIndex The preferred education in a numerical value that can be used for ordering/searching (optional)
     * @param preferredBodyType The preferred body type in the account location search (optional)
     * @param preferredEthnicity The preferred ethnicity in the account location search (optional)
     * @param preferredLocation The preferred location in the account location search (optional)
     * @param preferredLocationRange The preferred location range in the account location search (optional)
     * @param latitude The current latitude of the user (optional)
     * @param longitude The current longitude of the user (optional)
     * @param acceptedTerms Accepted Terms (optional)
     * @param inviteToken The inviteToken that the referrer used for this account to sign up (optional)
     * @param referralAccountId The accountId of the referrer (used if there is no inviteToken) (optional)
     * @param sendValidation Whether to send validation email (optional)
     * @param gameType Deprecated: use appKey (optional)
     * @param appKey The application key (optional)
     * @param appVersion The application version (optional)
     * @param responseType Returns an AccountLoginResponse if \&quot;AccountLoginResponse\&quot; is passed in (optional)
     * @param audienceIdsToAdd Comma separated list of audience ids to assign to the user (optional)
     * @param appBlob Application blob data (optional)
     * @param appEnablePush Enable push for the app (optional)
     * @param appEnableSMS Enable SMS for the app (optional)
     * @param appEnableEmail Enable email for the app (optional)
     * @param locationVisibility Location visibility setting (optional)
     * @param homeLatitude Home latitude (optional)
     * @param homeLongitude Home longitude (optional)
     * @param appNickname The nickname used in the application for this account (optional)
     * @param personalAudienceId Personal audience id to associate with this account (optional)
     * @return AccountLoginResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createAccount(username: kotlin.String, password: kotlin.String, name: kotlin.String? = null, prefixName: kotlin.String? = null, firstName: kotlin.String? = null, middleName: kotlin.String? = null, lastName: kotlin.String? = null, suffixName: kotlin.String? = null, title: kotlin.String? = null, deviceId: kotlin.String? = null, deviceIdType: kotlin.String? = null, emailAddress: kotlin.String? = null, assetId: kotlin.Long? = null, streetAddress: kotlin.String? = null, zipcode: kotlin.String? = null, gender: kotlin.String? = null, birthday: kotlin.Long? = null, homePhone: kotlin.String? = null, cellPhone: kotlin.String? = null, cellPhoneCarrier: kotlin.String? = null, businessPhone: kotlin.String? = null, role: kotlin.String? = null, platforms: kotlin.String? = null, tags: kotlin.String? = null, aboutUs: kotlin.String? = null, gameExperience: kotlin.String? = null, categoryIds: kotlin.String? = null, hometown: kotlin.String? = null, height: kotlin.String? = null, heightIndex: kotlin.Int? = null, ethnicity: kotlin.String? = null, bodyType: kotlin.String? = null, maritalStatus: kotlin.String? = null, children: kotlin.String? = null, religion: kotlin.String? = null, education: kotlin.String? = null, educationIndex: kotlin.Int? = null, smoke: kotlin.String? = null, drink: kotlin.String? = null, companionship: kotlin.String? = null, companionshipIndex: kotlin.Int? = null, preferredMinAge: kotlin.Int? = null, preferredMaxAge: kotlin.Int? = null, preferredMinHeight: kotlin.Int? = null, preferredMaxHeight: kotlin.Int? = null, preferredGender: kotlin.String? = null, preferredEducation: kotlin.String? = null, preferredEducationIndex: kotlin.Int? = null, preferredBodyType: kotlin.String? = null, preferredEthnicity: kotlin.String? = null, preferredLocation: kotlin.String? = null, preferredLocationRange: kotlin.Double? = null, latitude: kotlin.Double? = null, longitude: kotlin.Double? = null, acceptedTerms: kotlin.Boolean? = null, inviteToken: kotlin.String? = null, referralAccountId: kotlin.Long? = null, sendValidation: kotlin.Boolean? = null, gameType: kotlin.String? = null, appKey: kotlin.String? = null, appVersion: kotlin.String? = null, responseType: kotlin.String? = null, audienceIdsToAdd: kotlin.String? = null, appBlob: kotlin.String? = null, appEnablePush: kotlin.Boolean? = null, appEnableSMS: kotlin.Boolean? = null, appEnableEmail: kotlin.Boolean? = null, locationVisibility: kotlin.String? = null, homeLatitude: kotlin.Double? = null, homeLongitude: kotlin.Double? = null, appNickname: kotlin.String? = null, personalAudienceId: kotlin.Long? = null) : AccountLoginResponse {
        val localVarResponse = createAccountWithHttpInfo(username = username, password = password, name = name, prefixName = prefixName, firstName = firstName, middleName = middleName, lastName = lastName, suffixName = suffixName, title = title, deviceId = deviceId, deviceIdType = deviceIdType, emailAddress = emailAddress, assetId = assetId, streetAddress = streetAddress, zipcode = zipcode, gender = gender, birthday = birthday, homePhone = homePhone, cellPhone = cellPhone, cellPhoneCarrier = cellPhoneCarrier, businessPhone = businessPhone, role = role, platforms = platforms, tags = tags, aboutUs = aboutUs, gameExperience = gameExperience, categoryIds = categoryIds, hometown = hometown, height = height, heightIndex = heightIndex, ethnicity = ethnicity, bodyType = bodyType, maritalStatus = maritalStatus, children = children, religion = religion, education = education, educationIndex = educationIndex, smoke = smoke, drink = drink, companionship = companionship, companionshipIndex = companionshipIndex, preferredMinAge = preferredMinAge, preferredMaxAge = preferredMaxAge, preferredMinHeight = preferredMinHeight, preferredMaxHeight = preferredMaxHeight, preferredGender = preferredGender, preferredEducation = preferredEducation, preferredEducationIndex = preferredEducationIndex, preferredBodyType = preferredBodyType, preferredEthnicity = preferredEthnicity, preferredLocation = preferredLocation, preferredLocationRange = preferredLocationRange, latitude = latitude, longitude = longitude, acceptedTerms = acceptedTerms, inviteToken = inviteToken, referralAccountId = referralAccountId, sendValidation = sendValidation, gameType = gameType, appKey = appKey, appVersion = appVersion, responseType = responseType, audienceIdsToAdd = audienceIdsToAdd, appBlob = appBlob, appEnablePush = appEnablePush, appEnableSMS = appEnableSMS, appEnableEmail = appEnableEmail, locationVisibility = locationVisibility, homeLatitude = homeLatitude, homeLongitude = homeLongitude, appNickname = appNickname, personalAudienceId = personalAudienceId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AccountLoginResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /account/create
     * Create Account
     * Create a new account by role.
     * @param username The access token to authenticate with (ex: username)
     * @param password The secret to authenticate with (ex: password)
     * @param name The full name of the user. If this parameter is NOT empty, the following parameters will be ignored: prefixName, firstName, middleName, lastName, and suffixName (optional)
     * @param prefixName If the parameter &#39;name&#39; is empty or not present, this field will be used to set the prefix of the user&#39;s name (optional)
     * @param firstName If the parameter &#39;name&#39; is empty or not present, this field will be used to set the user&#39;s first name (optional)
     * @param middleName If the parameter &#39;name&#39; is empty or not present, this field will be used to set the user&#39;s middle name (optional)
     * @param lastName If the parameter &#39;name&#39; is empty or not present, this field will be used to set the user&#39;s last name (optional)
     * @param suffixName If the parameter &#39;name&#39; is empty or not present, this field will be used to set the suffix of the user&#39;s name (optional)
     * @param title This field will be used to set the user&#39;s job title (optional)
     * @param deviceId The unique id of the device making the request (optional)
     * @param deviceIdType The type of device id (this is defined by the client), ie. MAC_ADDRESS, APPLE_UDID, etc (optional)
     * @param emailAddress The user&#39;s contact email address (NOT the username) (optional)
     * @param assetId The asset id to set the user&#39;s profile image (optional)
     * @param streetAddress The street address of the user&#39;s contact location (optional)
     * @param zipcode The zipcode of the user&#39;s contact location (optional)
     * @param gender The gender of the user (AudienceGender) (optional)
     * @param birthday The birthday date of the user in UTC milliseconds (optional)
     * @param homePhone The home phone number (optional)
     * @param cellPhone The cellular phone number (optional)
     * @param cellPhoneCarrier The cellular service provider (optional)
     * @param businessPhone The business phone number (optional)
     * @param role The account role (default: MEMBER) (optional)
     * @param platforms Comma separated list of development platforms (optional)
     * @param tags Search tags (optional)
     * @param aboutUs About us information (optional)
     * @param gameExperience Game experience of the user (optional)
     * @param categoryIds A list of category ids that represent interests and associations (optional)
     * @param hometown The user&#39;s hometown (optional)
     * @param height The user&#39;s height (optional)
     * @param heightIndex The user&#39;s height in a numerical value that can be used for ordering/searching (optional)
     * @param ethnicity The user&#39;s ethnicity (optional)
     * @param bodyType The user&#39;s body type (optional)
     * @param maritalStatus The user&#39;s marital status (optional)
     * @param children The user&#39;s children status (optional)
     * @param religion The user&#39;s religion (optional)
     * @param education The user&#39;s education (optional)
     * @param educationIndex The user&#39;s education in a numerical value that can be used for ordering/searching (optional)
     * @param smoke The user&#39;s smoke status (optional)
     * @param drink The user&#39;s drink status (optional)
     * @param companionship The user&#39;s companionship status (optional)
     * @param companionshipIndex The user&#39;s companionship index (optional)
     * @param preferredMinAge The preferred minimum age in the account location search (optional)
     * @param preferredMaxAge The preferred maximum age in the account location search (optional)
     * @param preferredMinHeight The preferred minimum height in the account location search (optional)
     * @param preferredMaxHeight The preferred maximum height in the account location search (optional)
     * @param preferredGender The preferred gender in the account location search (optional)
     * @param preferredEducation The preferred education in the account location search (optional)
     * @param preferredEducationIndex The preferred education in a numerical value that can be used for ordering/searching (optional)
     * @param preferredBodyType The preferred body type in the account location search (optional)
     * @param preferredEthnicity The preferred ethnicity in the account location search (optional)
     * @param preferredLocation The preferred location in the account location search (optional)
     * @param preferredLocationRange The preferred location range in the account location search (optional)
     * @param latitude The current latitude of the user (optional)
     * @param longitude The current longitude of the user (optional)
     * @param acceptedTerms Accepted Terms (optional)
     * @param inviteToken The inviteToken that the referrer used for this account to sign up (optional)
     * @param referralAccountId The accountId of the referrer (used if there is no inviteToken) (optional)
     * @param sendValidation Whether to send validation email (optional)
     * @param gameType Deprecated: use appKey (optional)
     * @param appKey The application key (optional)
     * @param appVersion The application version (optional)
     * @param responseType Returns an AccountLoginResponse if \&quot;AccountLoginResponse\&quot; is passed in (optional)
     * @param audienceIdsToAdd Comma separated list of audience ids to assign to the user (optional)
     * @param appBlob Application blob data (optional)
     * @param appEnablePush Enable push for the app (optional)
     * @param appEnableSMS Enable SMS for the app (optional)
     * @param appEnableEmail Enable email for the app (optional)
     * @param locationVisibility Location visibility setting (optional)
     * @param homeLatitude Home latitude (optional)
     * @param homeLongitude Home longitude (optional)
     * @param appNickname The nickname used in the application for this account (optional)
     * @param personalAudienceId Personal audience id to associate with this account (optional)
     * @return ApiResponse<AccountLoginResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createAccountWithHttpInfo(username: kotlin.String, password: kotlin.String, name: kotlin.String?, prefixName: kotlin.String?, firstName: kotlin.String?, middleName: kotlin.String?, lastName: kotlin.String?, suffixName: kotlin.String?, title: kotlin.String?, deviceId: kotlin.String?, deviceIdType: kotlin.String?, emailAddress: kotlin.String?, assetId: kotlin.Long?, streetAddress: kotlin.String?, zipcode: kotlin.String?, gender: kotlin.String?, birthday: kotlin.Long?, homePhone: kotlin.String?, cellPhone: kotlin.String?, cellPhoneCarrier: kotlin.String?, businessPhone: kotlin.String?, role: kotlin.String?, platforms: kotlin.String?, tags: kotlin.String?, aboutUs: kotlin.String?, gameExperience: kotlin.String?, categoryIds: kotlin.String?, hometown: kotlin.String?, height: kotlin.String?, heightIndex: kotlin.Int?, ethnicity: kotlin.String?, bodyType: kotlin.String?, maritalStatus: kotlin.String?, children: kotlin.String?, religion: kotlin.String?, education: kotlin.String?, educationIndex: kotlin.Int?, smoke: kotlin.String?, drink: kotlin.String?, companionship: kotlin.String?, companionshipIndex: kotlin.Int?, preferredMinAge: kotlin.Int?, preferredMaxAge: kotlin.Int?, preferredMinHeight: kotlin.Int?, preferredMaxHeight: kotlin.Int?, preferredGender: kotlin.String?, preferredEducation: kotlin.String?, preferredEducationIndex: kotlin.Int?, preferredBodyType: kotlin.String?, preferredEthnicity: kotlin.String?, preferredLocation: kotlin.String?, preferredLocationRange: kotlin.Double?, latitude: kotlin.Double?, longitude: kotlin.Double?, acceptedTerms: kotlin.Boolean?, inviteToken: kotlin.String?, referralAccountId: kotlin.Long?, sendValidation: kotlin.Boolean?, gameType: kotlin.String?, appKey: kotlin.String?, appVersion: kotlin.String?, responseType: kotlin.String?, audienceIdsToAdd: kotlin.String?, appBlob: kotlin.String?, appEnablePush: kotlin.Boolean?, appEnableSMS: kotlin.Boolean?, appEnableEmail: kotlin.Boolean?, locationVisibility: kotlin.String?, homeLatitude: kotlin.Double?, homeLongitude: kotlin.Double?, appNickname: kotlin.String?, personalAudienceId: kotlin.Long?) : ApiResponse<AccountLoginResponse?> {
        val localVariableConfig = createAccountRequestConfig(username = username, password = password, name = name, prefixName = prefixName, firstName = firstName, middleName = middleName, lastName = lastName, suffixName = suffixName, title = title, deviceId = deviceId, deviceIdType = deviceIdType, emailAddress = emailAddress, assetId = assetId, streetAddress = streetAddress, zipcode = zipcode, gender = gender, birthday = birthday, homePhone = homePhone, cellPhone = cellPhone, cellPhoneCarrier = cellPhoneCarrier, businessPhone = businessPhone, role = role, platforms = platforms, tags = tags, aboutUs = aboutUs, gameExperience = gameExperience, categoryIds = categoryIds, hometown = hometown, height = height, heightIndex = heightIndex, ethnicity = ethnicity, bodyType = bodyType, maritalStatus = maritalStatus, children = children, religion = religion, education = education, educationIndex = educationIndex, smoke = smoke, drink = drink, companionship = companionship, companionshipIndex = companionshipIndex, preferredMinAge = preferredMinAge, preferredMaxAge = preferredMaxAge, preferredMinHeight = preferredMinHeight, preferredMaxHeight = preferredMaxHeight, preferredGender = preferredGender, preferredEducation = preferredEducation, preferredEducationIndex = preferredEducationIndex, preferredBodyType = preferredBodyType, preferredEthnicity = preferredEthnicity, preferredLocation = preferredLocation, preferredLocationRange = preferredLocationRange, latitude = latitude, longitude = longitude, acceptedTerms = acceptedTerms, inviteToken = inviteToken, referralAccountId = referralAccountId, sendValidation = sendValidation, gameType = gameType, appKey = appKey, appVersion = appVersion, responseType = responseType, audienceIdsToAdd = audienceIdsToAdd, appBlob = appBlob, appEnablePush = appEnablePush, appEnableSMS = appEnableSMS, appEnableEmail = appEnableEmail, locationVisibility = locationVisibility, homeLatitude = homeLatitude, homeLongitude = homeLongitude, appNickname = appNickname, personalAudienceId = personalAudienceId)

        return request<Unit, AccountLoginResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createAccount
     *
     * @param username The access token to authenticate with (ex: username)
     * @param password The secret to authenticate with (ex: password)
     * @param name The full name of the user. If this parameter is NOT empty, the following parameters will be ignored: prefixName, firstName, middleName, lastName, and suffixName (optional)
     * @param prefixName If the parameter &#39;name&#39; is empty or not present, this field will be used to set the prefix of the user&#39;s name (optional)
     * @param firstName If the parameter &#39;name&#39; is empty or not present, this field will be used to set the user&#39;s first name (optional)
     * @param middleName If the parameter &#39;name&#39; is empty or not present, this field will be used to set the user&#39;s middle name (optional)
     * @param lastName If the parameter &#39;name&#39; is empty or not present, this field will be used to set the user&#39;s last name (optional)
     * @param suffixName If the parameter &#39;name&#39; is empty or not present, this field will be used to set the suffix of the user&#39;s name (optional)
     * @param title This field will be used to set the user&#39;s job title (optional)
     * @param deviceId The unique id of the device making the request (optional)
     * @param deviceIdType The type of device id (this is defined by the client), ie. MAC_ADDRESS, APPLE_UDID, etc (optional)
     * @param emailAddress The user&#39;s contact email address (NOT the username) (optional)
     * @param assetId The asset id to set the user&#39;s profile image (optional)
     * @param streetAddress The street address of the user&#39;s contact location (optional)
     * @param zipcode The zipcode of the user&#39;s contact location (optional)
     * @param gender The gender of the user (AudienceGender) (optional)
     * @param birthday The birthday date of the user in UTC milliseconds (optional)
     * @param homePhone The home phone number (optional)
     * @param cellPhone The cellular phone number (optional)
     * @param cellPhoneCarrier The cellular service provider (optional)
     * @param businessPhone The business phone number (optional)
     * @param role The account role (default: MEMBER) (optional)
     * @param platforms Comma separated list of development platforms (optional)
     * @param tags Search tags (optional)
     * @param aboutUs About us information (optional)
     * @param gameExperience Game experience of the user (optional)
     * @param categoryIds A list of category ids that represent interests and associations (optional)
     * @param hometown The user&#39;s hometown (optional)
     * @param height The user&#39;s height (optional)
     * @param heightIndex The user&#39;s height in a numerical value that can be used for ordering/searching (optional)
     * @param ethnicity The user&#39;s ethnicity (optional)
     * @param bodyType The user&#39;s body type (optional)
     * @param maritalStatus The user&#39;s marital status (optional)
     * @param children The user&#39;s children status (optional)
     * @param religion The user&#39;s religion (optional)
     * @param education The user&#39;s education (optional)
     * @param educationIndex The user&#39;s education in a numerical value that can be used for ordering/searching (optional)
     * @param smoke The user&#39;s smoke status (optional)
     * @param drink The user&#39;s drink status (optional)
     * @param companionship The user&#39;s companionship status (optional)
     * @param companionshipIndex The user&#39;s companionship index (optional)
     * @param preferredMinAge The preferred minimum age in the account location search (optional)
     * @param preferredMaxAge The preferred maximum age in the account location search (optional)
     * @param preferredMinHeight The preferred minimum height in the account location search (optional)
     * @param preferredMaxHeight The preferred maximum height in the account location search (optional)
     * @param preferredGender The preferred gender in the account location search (optional)
     * @param preferredEducation The preferred education in the account location search (optional)
     * @param preferredEducationIndex The preferred education in a numerical value that can be used for ordering/searching (optional)
     * @param preferredBodyType The preferred body type in the account location search (optional)
     * @param preferredEthnicity The preferred ethnicity in the account location search (optional)
     * @param preferredLocation The preferred location in the account location search (optional)
     * @param preferredLocationRange The preferred location range in the account location search (optional)
     * @param latitude The current latitude of the user (optional)
     * @param longitude The current longitude of the user (optional)
     * @param acceptedTerms Accepted Terms (optional)
     * @param inviteToken The inviteToken that the referrer used for this account to sign up (optional)
     * @param referralAccountId The accountId of the referrer (used if there is no inviteToken) (optional)
     * @param sendValidation Whether to send validation email (optional)
     * @param gameType Deprecated: use appKey (optional)
     * @param appKey The application key (optional)
     * @param appVersion The application version (optional)
     * @param responseType Returns an AccountLoginResponse if \&quot;AccountLoginResponse\&quot; is passed in (optional)
     * @param audienceIdsToAdd Comma separated list of audience ids to assign to the user (optional)
     * @param appBlob Application blob data (optional)
     * @param appEnablePush Enable push for the app (optional)
     * @param appEnableSMS Enable SMS for the app (optional)
     * @param appEnableEmail Enable email for the app (optional)
     * @param locationVisibility Location visibility setting (optional)
     * @param homeLatitude Home latitude (optional)
     * @param homeLongitude Home longitude (optional)
     * @param appNickname The nickname used in the application for this account (optional)
     * @param personalAudienceId Personal audience id to associate with this account (optional)
     * @return RequestConfig
     */
    fun createAccountRequestConfig(username: kotlin.String, password: kotlin.String, name: kotlin.String?, prefixName: kotlin.String?, firstName: kotlin.String?, middleName: kotlin.String?, lastName: kotlin.String?, suffixName: kotlin.String?, title: kotlin.String?, deviceId: kotlin.String?, deviceIdType: kotlin.String?, emailAddress: kotlin.String?, assetId: kotlin.Long?, streetAddress: kotlin.String?, zipcode: kotlin.String?, gender: kotlin.String?, birthday: kotlin.Long?, homePhone: kotlin.String?, cellPhone: kotlin.String?, cellPhoneCarrier: kotlin.String?, businessPhone: kotlin.String?, role: kotlin.String?, platforms: kotlin.String?, tags: kotlin.String?, aboutUs: kotlin.String?, gameExperience: kotlin.String?, categoryIds: kotlin.String?, hometown: kotlin.String?, height: kotlin.String?, heightIndex: kotlin.Int?, ethnicity: kotlin.String?, bodyType: kotlin.String?, maritalStatus: kotlin.String?, children: kotlin.String?, religion: kotlin.String?, education: kotlin.String?, educationIndex: kotlin.Int?, smoke: kotlin.String?, drink: kotlin.String?, companionship: kotlin.String?, companionshipIndex: kotlin.Int?, preferredMinAge: kotlin.Int?, preferredMaxAge: kotlin.Int?, preferredMinHeight: kotlin.Int?, preferredMaxHeight: kotlin.Int?, preferredGender: kotlin.String?, preferredEducation: kotlin.String?, preferredEducationIndex: kotlin.Int?, preferredBodyType: kotlin.String?, preferredEthnicity: kotlin.String?, preferredLocation: kotlin.String?, preferredLocationRange: kotlin.Double?, latitude: kotlin.Double?, longitude: kotlin.Double?, acceptedTerms: kotlin.Boolean?, inviteToken: kotlin.String?, referralAccountId: kotlin.Long?, sendValidation: kotlin.Boolean?, gameType: kotlin.String?, appKey: kotlin.String?, appVersion: kotlin.String?, responseType: kotlin.String?, audienceIdsToAdd: kotlin.String?, appBlob: kotlin.String?, appEnablePush: kotlin.Boolean?, appEnableSMS: kotlin.Boolean?, appEnableEmail: kotlin.Boolean?, locationVisibility: kotlin.String?, homeLatitude: kotlin.Double?, homeLongitude: kotlin.Double?, appNickname: kotlin.String?, personalAudienceId: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (prefixName != null) {
                    put("prefixName", listOf(prefixName.toString()))
                }
                if (firstName != null) {
                    put("firstName", listOf(firstName.toString()))
                }
                if (middleName != null) {
                    put("middleName", listOf(middleName.toString()))
                }
                if (lastName != null) {
                    put("lastName", listOf(lastName.toString()))
                }
                if (suffixName != null) {
                    put("suffixName", listOf(suffixName.toString()))
                }
                if (title != null) {
                    put("title", listOf(title.toString()))
                }
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (deviceIdType != null) {
                    put("deviceIdType", listOf(deviceIdType.toString()))
                }
                put("username", listOf(username.toString()))
                put("password", listOf(password.toString()))
                if (emailAddress != null) {
                    put("emailAddress", listOf(emailAddress.toString()))
                }
                if (assetId != null) {
                    put("assetId", listOf(assetId.toString()))
                }
                if (streetAddress != null) {
                    put("streetAddress", listOf(streetAddress.toString()))
                }
                if (zipcode != null) {
                    put("zipcode", listOf(zipcode.toString()))
                }
                if (gender != null) {
                    put("gender", listOf(gender.toString()))
                }
                if (birthday != null) {
                    put("birthday", listOf(birthday.toString()))
                }
                if (homePhone != null) {
                    put("homePhone", listOf(homePhone.toString()))
                }
                if (cellPhone != null) {
                    put("cellPhone", listOf(cellPhone.toString()))
                }
                if (cellPhoneCarrier != null) {
                    put("cellPhoneCarrier", listOf(cellPhoneCarrier.toString()))
                }
                if (businessPhone != null) {
                    put("businessPhone", listOf(businessPhone.toString()))
                }
                if (role != null) {
                    put("role", listOf(role.toString()))
                }
                if (platforms != null) {
                    put("platforms", listOf(platforms.toString()))
                }
                if (tags != null) {
                    put("tags", listOf(tags.toString()))
                }
                if (aboutUs != null) {
                    put("aboutUs", listOf(aboutUs.toString()))
                }
                if (gameExperience != null) {
                    put("gameExperience", listOf(gameExperience.toString()))
                }
                if (categoryIds != null) {
                    put("categoryIds", listOf(categoryIds.toString()))
                }
                if (hometown != null) {
                    put("hometown", listOf(hometown.toString()))
                }
                if (height != null) {
                    put("height", listOf(height.toString()))
                }
                if (heightIndex != null) {
                    put("heightIndex", listOf(heightIndex.toString()))
                }
                if (ethnicity != null) {
                    put("ethnicity", listOf(ethnicity.toString()))
                }
                if (bodyType != null) {
                    put("bodyType", listOf(bodyType.toString()))
                }
                if (maritalStatus != null) {
                    put("maritalStatus", listOf(maritalStatus.toString()))
                }
                if (children != null) {
                    put("children", listOf(children.toString()))
                }
                if (religion != null) {
                    put("religion", listOf(religion.toString()))
                }
                if (education != null) {
                    put("education", listOf(education.toString()))
                }
                if (educationIndex != null) {
                    put("educationIndex", listOf(educationIndex.toString()))
                }
                if (smoke != null) {
                    put("smoke", listOf(smoke.toString()))
                }
                if (drink != null) {
                    put("drink", listOf(drink.toString()))
                }
                if (companionship != null) {
                    put("companionship", listOf(companionship.toString()))
                }
                if (companionshipIndex != null) {
                    put("companionshipIndex", listOf(companionshipIndex.toString()))
                }
                if (preferredMinAge != null) {
                    put("preferredMinAge", listOf(preferredMinAge.toString()))
                }
                if (preferredMaxAge != null) {
                    put("preferredMaxAge", listOf(preferredMaxAge.toString()))
                }
                if (preferredMinHeight != null) {
                    put("preferredMinHeight", listOf(preferredMinHeight.toString()))
                }
                if (preferredMaxHeight != null) {
                    put("preferredMaxHeight", listOf(preferredMaxHeight.toString()))
                }
                if (preferredGender != null) {
                    put("preferredGender", listOf(preferredGender.toString()))
                }
                if (preferredEducation != null) {
                    put("preferredEducation", listOf(preferredEducation.toString()))
                }
                if (preferredEducationIndex != null) {
                    put("preferredEducationIndex", listOf(preferredEducationIndex.toString()))
                }
                if (preferredBodyType != null) {
                    put("preferredBodyType", listOf(preferredBodyType.toString()))
                }
                if (preferredEthnicity != null) {
                    put("preferredEthnicity", listOf(preferredEthnicity.toString()))
                }
                if (preferredLocation != null) {
                    put("preferredLocation", listOf(preferredLocation.toString()))
                }
                if (preferredLocationRange != null) {
                    put("preferredLocationRange", listOf(preferredLocationRange.toString()))
                }
                if (latitude != null) {
                    put("latitude", listOf(latitude.toString()))
                }
                if (longitude != null) {
                    put("longitude", listOf(longitude.toString()))
                }
                if (acceptedTerms != null) {
                    put("acceptedTerms", listOf(acceptedTerms.toString()))
                }
                if (inviteToken != null) {
                    put("inviteToken", listOf(inviteToken.toString()))
                }
                if (referralAccountId != null) {
                    put("referralAccountId", listOf(referralAccountId.toString()))
                }
                if (sendValidation != null) {
                    put("sendValidation", listOf(sendValidation.toString()))
                }
                if (gameType != null) {
                    put("gameType", listOf(gameType.toString()))
                }
                if (appKey != null) {
                    put("appKey", listOf(appKey.toString()))
                }
                if (appVersion != null) {
                    put("appVersion", listOf(appVersion.toString()))
                }
                if (responseType != null) {
                    put("responseType", listOf(responseType.toString()))
                }
                if (audienceIdsToAdd != null) {
                    put("audienceIdsToAdd", listOf(audienceIdsToAdd.toString()))
                }
                if (appBlob != null) {
                    put("appBlob", listOf(appBlob.toString()))
                }
                if (appEnablePush != null) {
                    put("appEnablePush", listOf(appEnablePush.toString()))
                }
                if (appEnableSMS != null) {
                    put("appEnableSMS", listOf(appEnableSMS.toString()))
                }
                if (appEnableEmail != null) {
                    put("appEnableEmail", listOf(appEnableEmail.toString()))
                }
                if (locationVisibility != null) {
                    put("locationVisibility", listOf(locationVisibility.toString()))
                }
                if (homeLatitude != null) {
                    put("homeLatitude", listOf(homeLatitude.toString()))
                }
                if (homeLongitude != null) {
                    put("homeLongitude", listOf(homeLongitude.toString()))
                }
                if (appNickname != null) {
                    put("appNickname", listOf(appNickname.toString()))
                }
                if (personalAudienceId != null) {
                    put("personalAudienceId", listOf(personalAudienceId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/account/create",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /account/profile/update
     * Update Account
     * Edit the user&#39;s profile information
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param connectionAccountId The account id used to edit another person&#39;s account (optional)
     * @param role The account role to change to (optional)
     * @param assetId The asset id to set the user&#39;s profile image (optional)
     * @param name The full name of the user. If this parameter is NOT empty, the  following parameters will be ignored: prefixName, firstName, middleName,  lastName, and suffixName  (optional)
     * @param prefixName If the parameter &#39;name&#39; is empty or not present, this field will be used to set the prefix of the user&#39;s name (optional)
     * @param firstName If the parameter &#39;name&#39; is empty or not present, this field will be used to set the user&#39;s first name (optional)
     * @param middleName If the parameter &#39;name&#39; is empty or not present, this field will be used to set the user&#39;s middle name (optional)
     * @param lastName If the parameter &#39;name&#39; is empty or not present, this field will be used to set the user&#39;s last name (optional)
     * @param suffixName If the parameter &#39;name&#39; is empty or not present, this field will be used to set the suffix of the user&#39;s name (optional)
     * @param title This field will be used to set the user&#39;s job title (optional)
     * @param gender The gender of the user AudienceGender (optional)
     * @param age This is deperecated, use the birthday parameter (optional)
     * @param birthday The birthday date of the user in UTC milliseconds (optional)
     * @param homePhone The home phone number (optional)
     * @param cellPhone The cellular phone number (optional)
     * @param cellPhoneCarrier The cellular service provider (optional)
     * @param businessPhone The business phone number (optional)
     * @param emailAddress The user&#39;s contact email address (NOT the username) (optional)
     * @param streetAddress The street address of the user&#39;s contact location (optional)
     * @param streetAddress2 Additional address information (such as a suite number, floor number, building name, or PO Box) (optional)
     * @param city The city of the user&#39;s contact location (optional)
     * @param state The state of the user&#39;s contact location (optional)
     * @param zipcode The zipcode of the user&#39;s contact location (optional)
     * @param country The country of the user&#39;s contact location (optional)
     * @param makeProfileInfoPublic Allow anyone to view the user&#39;s personal profile (optional)
     * @param makeGameInfoPublic Allow anyone to view the user&#39;s game/app info (optional)
     * @param makeFriendsInfoPublic Allow anyone to view the user&#39;s friends list (optional)
     * @param hometown The user&#39;s hometown (optional)
     * @param height The user&#39;s height (optional)
     * @param heightIndex The user&#39;s height in a numerical value that can be used for ordering/searching (optional)
     * @param ethnicity The user&#39;s ethnicity (optional)
     * @param bodyType The user&#39;s body type (optional)
     * @param maritalStatus The user&#39;s marital status (optional)
     * @param children The user&#39;s children status (optional)
     * @param religion The user&#39;s religion (optional)
     * @param education The user&#39;s education (optional)
     * @param educationIndex The user&#39;s education in a numerical value that can be used for ordering/searching (optional)
     * @param smoke The user&#39;s smoke status (optional)
     * @param drink The user&#39;s drink status (optional)
     * @param companionship The user&#39;s companionship status (optional)
     * @param companionshipIndex The user&#39;s companionship index (optional)
     * @param preferredMinAge The preferred minimum age in the account location search (optional)
     * @param preferredMaxAge The preferred maximum age in the account location search (optional)
     * @param preferredMinHeight The preferred minimum height in the account location search (optional)
     * @param preferredMaxHeight The preferred maximum height in the account location search (optional)
     * @param preferredGender The preferred gender in the account location search (optional)
     * @param preferredEducation The preferred education in the account location search (optional)
     * @param preferredEducationIndex The preferred education in a numerical value that can be used for ordering/searching (optional)
     * @param preferredBodyType The preferred body type in the account location search (optional)
     * @param preferredEthnicity The preferred ethnicity in the account location search (optional)
     * @param preferredLocation The preferred education in the account location search (optional)
     * @param preferredLocationRange The preferred location range in the account location search (optional)
     * @param platforms Platforms (optional)
     * @param tags Tags (optional)
     * @param aboutUs About Us (optional)
     * @param matchToken Match Token (optional)
     * @param gameExperience Game Experience (optional)
     * @param categories Deprecated use categoryIds (optional)
     * @param categoryIds A list of category ids that represent interests and associations (optional)
     * @param responseFilters A comma separated list of ProfileFilters for filtering the returned response data (optional, default to "PROFILE,PROFILE_CONTACT")
     * @param showAsZipcode The user&#39;s preference if they want to be shown by zipcode on a map (optional)
     * @param showExactLocation The user&#39;s preference if they want to be shown by their exact location on a map (optional)
     * @param showOthersExactLocation The user&#39;s preference if they want to see others exact location on a map (optional)
     * @param acceptedTerms Accepted Terms (optional)
     * @param locationVisibility Location Visibility (optional)
     * @param appBlob App Blob (optional)
     * @param appEnablePush App Enable Push (optional)
     * @param appEnableSMS App Enable SMS (optional)
     * @param appEnableEmail App Enable Email (optional)
     * @param gameType Game Type (optional)
     * @param appKey The application key (optional)
     * @param latitude The current latitude of the user (optional)
     * @param longitude The current longitude of the user (optional)
     * @param returnProfile Return Profile (optional)
     * @param audienceIdsToAdd Audience Ids to add (optional)
     * @param audienceIdsToRemove Audience Ids to remove (optional)
     * @param referralAccountId The account id of the referrer (optional)
     * @param appNickname App nickname (optional)
     * @param personalAudienceId Personal Audience (optional)
     * @param nonGuestUsername The user&#39;s username to update with if they currently have a guest username (optional)
     * @return ProfileInfoResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun editAccount(deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, connectionAccountId: kotlin.Long? = null, role: kotlin.String? = null, assetId: kotlin.Long? = null, name: kotlin.String? = null, prefixName: kotlin.String? = null, firstName: kotlin.String? = null, middleName: kotlin.String? = null, lastName: kotlin.String? = null, suffixName: kotlin.String? = null, title: kotlin.String? = null, gender: kotlin.String? = null, age: kotlin.Int? = null, birthday: kotlin.Long? = null, homePhone: kotlin.String? = null, cellPhone: kotlin.String? = null, cellPhoneCarrier: kotlin.String? = null, businessPhone: kotlin.String? = null, emailAddress: kotlin.String? = null, streetAddress: kotlin.String? = null, streetAddress2: kotlin.String? = null, city: kotlin.String? = null, state: kotlin.String? = null, zipcode: kotlin.String? = null, country: kotlin.String? = null, makeProfileInfoPublic: kotlin.Boolean? = null, makeGameInfoPublic: kotlin.Boolean? = null, makeFriendsInfoPublic: kotlin.Boolean? = null, hometown: kotlin.String? = null, height: kotlin.String? = null, heightIndex: kotlin.Int? = null, ethnicity: kotlin.String? = null, bodyType: kotlin.String? = null, maritalStatus: kotlin.String? = null, children: kotlin.String? = null, religion: kotlin.String? = null, education: kotlin.String? = null, educationIndex: kotlin.Int? = null, smoke: kotlin.String? = null, drink: kotlin.String? = null, companionship: kotlin.String? = null, companionshipIndex: kotlin.Int? = null, preferredMinAge: kotlin.Int? = null, preferredMaxAge: kotlin.Int? = null, preferredMinHeight: kotlin.Int? = null, preferredMaxHeight: kotlin.Int? = null, preferredGender: kotlin.String? = null, preferredEducation: kotlin.String? = null, preferredEducationIndex: kotlin.Int? = null, preferredBodyType: kotlin.String? = null, preferredEthnicity: kotlin.String? = null, preferredLocation: kotlin.String? = null, preferredLocationRange: kotlin.Double? = null, platforms: kotlin.String? = null, tags: kotlin.String? = null, aboutUs: kotlin.String? = null, matchToken: kotlin.String? = null, gameExperience: kotlin.String? = null, categories: kotlin.String? = null, categoryIds: kotlin.String? = null, responseFilters: kotlin.String? = "PROFILE,PROFILE_CONTACT", showAsZipcode: kotlin.Boolean? = null, showExactLocation: kotlin.Boolean? = null, showOthersExactLocation: kotlin.Boolean? = null, acceptedTerms: kotlin.Boolean? = null, locationVisibility: kotlin.String? = null, appBlob: kotlin.String? = null, appEnablePush: kotlin.Boolean? = null, appEnableSMS: kotlin.Boolean? = null, appEnableEmail: kotlin.Boolean? = null, gameType: kotlin.String? = null, appKey: kotlin.String? = null, latitude: kotlin.Double? = null, longitude: kotlin.Double? = null, returnProfile: kotlin.Boolean? = null, audienceIdsToAdd: kotlin.String? = null, audienceIdsToRemove: kotlin.String? = null, referralAccountId: kotlin.Long? = null, appNickname: kotlin.String? = null, personalAudienceId: kotlin.Long? = null, nonGuestUsername: kotlin.String? = null) : ProfileInfoResponse {
        val localVarResponse = editAccountWithHttpInfo(deviceId = deviceId, accountId = accountId, connectionAccountId = connectionAccountId, role = role, assetId = assetId, name = name, prefixName = prefixName, firstName = firstName, middleName = middleName, lastName = lastName, suffixName = suffixName, title = title, gender = gender, age = age, birthday = birthday, homePhone = homePhone, cellPhone = cellPhone, cellPhoneCarrier = cellPhoneCarrier, businessPhone = businessPhone, emailAddress = emailAddress, streetAddress = streetAddress, streetAddress2 = streetAddress2, city = city, state = state, zipcode = zipcode, country = country, makeProfileInfoPublic = makeProfileInfoPublic, makeGameInfoPublic = makeGameInfoPublic, makeFriendsInfoPublic = makeFriendsInfoPublic, hometown = hometown, height = height, heightIndex = heightIndex, ethnicity = ethnicity, bodyType = bodyType, maritalStatus = maritalStatus, children = children, religion = religion, education = education, educationIndex = educationIndex, smoke = smoke, drink = drink, companionship = companionship, companionshipIndex = companionshipIndex, preferredMinAge = preferredMinAge, preferredMaxAge = preferredMaxAge, preferredMinHeight = preferredMinHeight, preferredMaxHeight = preferredMaxHeight, preferredGender = preferredGender, preferredEducation = preferredEducation, preferredEducationIndex = preferredEducationIndex, preferredBodyType = preferredBodyType, preferredEthnicity = preferredEthnicity, preferredLocation = preferredLocation, preferredLocationRange = preferredLocationRange, platforms = platforms, tags = tags, aboutUs = aboutUs, matchToken = matchToken, gameExperience = gameExperience, categories = categories, categoryIds = categoryIds, responseFilters = responseFilters, showAsZipcode = showAsZipcode, showExactLocation = showExactLocation, showOthersExactLocation = showOthersExactLocation, acceptedTerms = acceptedTerms, locationVisibility = locationVisibility, appBlob = appBlob, appEnablePush = appEnablePush, appEnableSMS = appEnableSMS, appEnableEmail = appEnableEmail, gameType = gameType, appKey = appKey, latitude = latitude, longitude = longitude, returnProfile = returnProfile, audienceIdsToAdd = audienceIdsToAdd, audienceIdsToRemove = audienceIdsToRemove, referralAccountId = referralAccountId, appNickname = appNickname, personalAudienceId = personalAudienceId, nonGuestUsername = nonGuestUsername)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ProfileInfoResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /account/profile/update
     * Update Account
     * Edit the user&#39;s profile information
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param connectionAccountId The account id used to edit another person&#39;s account (optional)
     * @param role The account role to change to (optional)
     * @param assetId The asset id to set the user&#39;s profile image (optional)
     * @param name The full name of the user. If this parameter is NOT empty, the  following parameters will be ignored: prefixName, firstName, middleName,  lastName, and suffixName  (optional)
     * @param prefixName If the parameter &#39;name&#39; is empty or not present, this field will be used to set the prefix of the user&#39;s name (optional)
     * @param firstName If the parameter &#39;name&#39; is empty or not present, this field will be used to set the user&#39;s first name (optional)
     * @param middleName If the parameter &#39;name&#39; is empty or not present, this field will be used to set the user&#39;s middle name (optional)
     * @param lastName If the parameter &#39;name&#39; is empty or not present, this field will be used to set the user&#39;s last name (optional)
     * @param suffixName If the parameter &#39;name&#39; is empty or not present, this field will be used to set the suffix of the user&#39;s name (optional)
     * @param title This field will be used to set the user&#39;s job title (optional)
     * @param gender The gender of the user AudienceGender (optional)
     * @param age This is deperecated, use the birthday parameter (optional)
     * @param birthday The birthday date of the user in UTC milliseconds (optional)
     * @param homePhone The home phone number (optional)
     * @param cellPhone The cellular phone number (optional)
     * @param cellPhoneCarrier The cellular service provider (optional)
     * @param businessPhone The business phone number (optional)
     * @param emailAddress The user&#39;s contact email address (NOT the username) (optional)
     * @param streetAddress The street address of the user&#39;s contact location (optional)
     * @param streetAddress2 Additional address information (such as a suite number, floor number, building name, or PO Box) (optional)
     * @param city The city of the user&#39;s contact location (optional)
     * @param state The state of the user&#39;s contact location (optional)
     * @param zipcode The zipcode of the user&#39;s contact location (optional)
     * @param country The country of the user&#39;s contact location (optional)
     * @param makeProfileInfoPublic Allow anyone to view the user&#39;s personal profile (optional)
     * @param makeGameInfoPublic Allow anyone to view the user&#39;s game/app info (optional)
     * @param makeFriendsInfoPublic Allow anyone to view the user&#39;s friends list (optional)
     * @param hometown The user&#39;s hometown (optional)
     * @param height The user&#39;s height (optional)
     * @param heightIndex The user&#39;s height in a numerical value that can be used for ordering/searching (optional)
     * @param ethnicity The user&#39;s ethnicity (optional)
     * @param bodyType The user&#39;s body type (optional)
     * @param maritalStatus The user&#39;s marital status (optional)
     * @param children The user&#39;s children status (optional)
     * @param religion The user&#39;s religion (optional)
     * @param education The user&#39;s education (optional)
     * @param educationIndex The user&#39;s education in a numerical value that can be used for ordering/searching (optional)
     * @param smoke The user&#39;s smoke status (optional)
     * @param drink The user&#39;s drink status (optional)
     * @param companionship The user&#39;s companionship status (optional)
     * @param companionshipIndex The user&#39;s companionship index (optional)
     * @param preferredMinAge The preferred minimum age in the account location search (optional)
     * @param preferredMaxAge The preferred maximum age in the account location search (optional)
     * @param preferredMinHeight The preferred minimum height in the account location search (optional)
     * @param preferredMaxHeight The preferred maximum height in the account location search (optional)
     * @param preferredGender The preferred gender in the account location search (optional)
     * @param preferredEducation The preferred education in the account location search (optional)
     * @param preferredEducationIndex The preferred education in a numerical value that can be used for ordering/searching (optional)
     * @param preferredBodyType The preferred body type in the account location search (optional)
     * @param preferredEthnicity The preferred ethnicity in the account location search (optional)
     * @param preferredLocation The preferred education in the account location search (optional)
     * @param preferredLocationRange The preferred location range in the account location search (optional)
     * @param platforms Platforms (optional)
     * @param tags Tags (optional)
     * @param aboutUs About Us (optional)
     * @param matchToken Match Token (optional)
     * @param gameExperience Game Experience (optional)
     * @param categories Deprecated use categoryIds (optional)
     * @param categoryIds A list of category ids that represent interests and associations (optional)
     * @param responseFilters A comma separated list of ProfileFilters for filtering the returned response data (optional, default to "PROFILE,PROFILE_CONTACT")
     * @param showAsZipcode The user&#39;s preference if they want to be shown by zipcode on a map (optional)
     * @param showExactLocation The user&#39;s preference if they want to be shown by their exact location on a map (optional)
     * @param showOthersExactLocation The user&#39;s preference if they want to see others exact location on a map (optional)
     * @param acceptedTerms Accepted Terms (optional)
     * @param locationVisibility Location Visibility (optional)
     * @param appBlob App Blob (optional)
     * @param appEnablePush App Enable Push (optional)
     * @param appEnableSMS App Enable SMS (optional)
     * @param appEnableEmail App Enable Email (optional)
     * @param gameType Game Type (optional)
     * @param appKey The application key (optional)
     * @param latitude The current latitude of the user (optional)
     * @param longitude The current longitude of the user (optional)
     * @param returnProfile Return Profile (optional)
     * @param audienceIdsToAdd Audience Ids to add (optional)
     * @param audienceIdsToRemove Audience Ids to remove (optional)
     * @param referralAccountId The account id of the referrer (optional)
     * @param appNickname App nickname (optional)
     * @param personalAudienceId Personal Audience (optional)
     * @param nonGuestUsername The user&#39;s username to update with if they currently have a guest username (optional)
     * @return ApiResponse<ProfileInfoResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun editAccountWithHttpInfo(deviceId: kotlin.String?, accountId: kotlin.Long?, connectionAccountId: kotlin.Long?, role: kotlin.String?, assetId: kotlin.Long?, name: kotlin.String?, prefixName: kotlin.String?, firstName: kotlin.String?, middleName: kotlin.String?, lastName: kotlin.String?, suffixName: kotlin.String?, title: kotlin.String?, gender: kotlin.String?, age: kotlin.Int?, birthday: kotlin.Long?, homePhone: kotlin.String?, cellPhone: kotlin.String?, cellPhoneCarrier: kotlin.String?, businessPhone: kotlin.String?, emailAddress: kotlin.String?, streetAddress: kotlin.String?, streetAddress2: kotlin.String?, city: kotlin.String?, state: kotlin.String?, zipcode: kotlin.String?, country: kotlin.String?, makeProfileInfoPublic: kotlin.Boolean?, makeGameInfoPublic: kotlin.Boolean?, makeFriendsInfoPublic: kotlin.Boolean?, hometown: kotlin.String?, height: kotlin.String?, heightIndex: kotlin.Int?, ethnicity: kotlin.String?, bodyType: kotlin.String?, maritalStatus: kotlin.String?, children: kotlin.String?, religion: kotlin.String?, education: kotlin.String?, educationIndex: kotlin.Int?, smoke: kotlin.String?, drink: kotlin.String?, companionship: kotlin.String?, companionshipIndex: kotlin.Int?, preferredMinAge: kotlin.Int?, preferredMaxAge: kotlin.Int?, preferredMinHeight: kotlin.Int?, preferredMaxHeight: kotlin.Int?, preferredGender: kotlin.String?, preferredEducation: kotlin.String?, preferredEducationIndex: kotlin.Int?, preferredBodyType: kotlin.String?, preferredEthnicity: kotlin.String?, preferredLocation: kotlin.String?, preferredLocationRange: kotlin.Double?, platforms: kotlin.String?, tags: kotlin.String?, aboutUs: kotlin.String?, matchToken: kotlin.String?, gameExperience: kotlin.String?, categories: kotlin.String?, categoryIds: kotlin.String?, responseFilters: kotlin.String?, showAsZipcode: kotlin.Boolean?, showExactLocation: kotlin.Boolean?, showOthersExactLocation: kotlin.Boolean?, acceptedTerms: kotlin.Boolean?, locationVisibility: kotlin.String?, appBlob: kotlin.String?, appEnablePush: kotlin.Boolean?, appEnableSMS: kotlin.Boolean?, appEnableEmail: kotlin.Boolean?, gameType: kotlin.String?, appKey: kotlin.String?, latitude: kotlin.Double?, longitude: kotlin.Double?, returnProfile: kotlin.Boolean?, audienceIdsToAdd: kotlin.String?, audienceIdsToRemove: kotlin.String?, referralAccountId: kotlin.Long?, appNickname: kotlin.String?, personalAudienceId: kotlin.Long?, nonGuestUsername: kotlin.String?) : ApiResponse<ProfileInfoResponse?> {
        val localVariableConfig = editAccountRequestConfig(deviceId = deviceId, accountId = accountId, connectionAccountId = connectionAccountId, role = role, assetId = assetId, name = name, prefixName = prefixName, firstName = firstName, middleName = middleName, lastName = lastName, suffixName = suffixName, title = title, gender = gender, age = age, birthday = birthday, homePhone = homePhone, cellPhone = cellPhone, cellPhoneCarrier = cellPhoneCarrier, businessPhone = businessPhone, emailAddress = emailAddress, streetAddress = streetAddress, streetAddress2 = streetAddress2, city = city, state = state, zipcode = zipcode, country = country, makeProfileInfoPublic = makeProfileInfoPublic, makeGameInfoPublic = makeGameInfoPublic, makeFriendsInfoPublic = makeFriendsInfoPublic, hometown = hometown, height = height, heightIndex = heightIndex, ethnicity = ethnicity, bodyType = bodyType, maritalStatus = maritalStatus, children = children, religion = religion, education = education, educationIndex = educationIndex, smoke = smoke, drink = drink, companionship = companionship, companionshipIndex = companionshipIndex, preferredMinAge = preferredMinAge, preferredMaxAge = preferredMaxAge, preferredMinHeight = preferredMinHeight, preferredMaxHeight = preferredMaxHeight, preferredGender = preferredGender, preferredEducation = preferredEducation, preferredEducationIndex = preferredEducationIndex, preferredBodyType = preferredBodyType, preferredEthnicity = preferredEthnicity, preferredLocation = preferredLocation, preferredLocationRange = preferredLocationRange, platforms = platforms, tags = tags, aboutUs = aboutUs, matchToken = matchToken, gameExperience = gameExperience, categories = categories, categoryIds = categoryIds, responseFilters = responseFilters, showAsZipcode = showAsZipcode, showExactLocation = showExactLocation, showOthersExactLocation = showOthersExactLocation, acceptedTerms = acceptedTerms, locationVisibility = locationVisibility, appBlob = appBlob, appEnablePush = appEnablePush, appEnableSMS = appEnableSMS, appEnableEmail = appEnableEmail, gameType = gameType, appKey = appKey, latitude = latitude, longitude = longitude, returnProfile = returnProfile, audienceIdsToAdd = audienceIdsToAdd, audienceIdsToRemove = audienceIdsToRemove, referralAccountId = referralAccountId, appNickname = appNickname, personalAudienceId = personalAudienceId, nonGuestUsername = nonGuestUsername)

        return request<Unit, ProfileInfoResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation editAccount
     *
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param connectionAccountId The account id used to edit another person&#39;s account (optional)
     * @param role The account role to change to (optional)
     * @param assetId The asset id to set the user&#39;s profile image (optional)
     * @param name The full name of the user. If this parameter is NOT empty, the  following parameters will be ignored: prefixName, firstName, middleName,  lastName, and suffixName  (optional)
     * @param prefixName If the parameter &#39;name&#39; is empty or not present, this field will be used to set the prefix of the user&#39;s name (optional)
     * @param firstName If the parameter &#39;name&#39; is empty or not present, this field will be used to set the user&#39;s first name (optional)
     * @param middleName If the parameter &#39;name&#39; is empty or not present, this field will be used to set the user&#39;s middle name (optional)
     * @param lastName If the parameter &#39;name&#39; is empty or not present, this field will be used to set the user&#39;s last name (optional)
     * @param suffixName If the parameter &#39;name&#39; is empty or not present, this field will be used to set the suffix of the user&#39;s name (optional)
     * @param title This field will be used to set the user&#39;s job title (optional)
     * @param gender The gender of the user AudienceGender (optional)
     * @param age This is deperecated, use the birthday parameter (optional)
     * @param birthday The birthday date of the user in UTC milliseconds (optional)
     * @param homePhone The home phone number (optional)
     * @param cellPhone The cellular phone number (optional)
     * @param cellPhoneCarrier The cellular service provider (optional)
     * @param businessPhone The business phone number (optional)
     * @param emailAddress The user&#39;s contact email address (NOT the username) (optional)
     * @param streetAddress The street address of the user&#39;s contact location (optional)
     * @param streetAddress2 Additional address information (such as a suite number, floor number, building name, or PO Box) (optional)
     * @param city The city of the user&#39;s contact location (optional)
     * @param state The state of the user&#39;s contact location (optional)
     * @param zipcode The zipcode of the user&#39;s contact location (optional)
     * @param country The country of the user&#39;s contact location (optional)
     * @param makeProfileInfoPublic Allow anyone to view the user&#39;s personal profile (optional)
     * @param makeGameInfoPublic Allow anyone to view the user&#39;s game/app info (optional)
     * @param makeFriendsInfoPublic Allow anyone to view the user&#39;s friends list (optional)
     * @param hometown The user&#39;s hometown (optional)
     * @param height The user&#39;s height (optional)
     * @param heightIndex The user&#39;s height in a numerical value that can be used for ordering/searching (optional)
     * @param ethnicity The user&#39;s ethnicity (optional)
     * @param bodyType The user&#39;s body type (optional)
     * @param maritalStatus The user&#39;s marital status (optional)
     * @param children The user&#39;s children status (optional)
     * @param religion The user&#39;s religion (optional)
     * @param education The user&#39;s education (optional)
     * @param educationIndex The user&#39;s education in a numerical value that can be used for ordering/searching (optional)
     * @param smoke The user&#39;s smoke status (optional)
     * @param drink The user&#39;s drink status (optional)
     * @param companionship The user&#39;s companionship status (optional)
     * @param companionshipIndex The user&#39;s companionship index (optional)
     * @param preferredMinAge The preferred minimum age in the account location search (optional)
     * @param preferredMaxAge The preferred maximum age in the account location search (optional)
     * @param preferredMinHeight The preferred minimum height in the account location search (optional)
     * @param preferredMaxHeight The preferred maximum height in the account location search (optional)
     * @param preferredGender The preferred gender in the account location search (optional)
     * @param preferredEducation The preferred education in the account location search (optional)
     * @param preferredEducationIndex The preferred education in a numerical value that can be used for ordering/searching (optional)
     * @param preferredBodyType The preferred body type in the account location search (optional)
     * @param preferredEthnicity The preferred ethnicity in the account location search (optional)
     * @param preferredLocation The preferred education in the account location search (optional)
     * @param preferredLocationRange The preferred location range in the account location search (optional)
     * @param platforms Platforms (optional)
     * @param tags Tags (optional)
     * @param aboutUs About Us (optional)
     * @param matchToken Match Token (optional)
     * @param gameExperience Game Experience (optional)
     * @param categories Deprecated use categoryIds (optional)
     * @param categoryIds A list of category ids that represent interests and associations (optional)
     * @param responseFilters A comma separated list of ProfileFilters for filtering the returned response data (optional, default to "PROFILE,PROFILE_CONTACT")
     * @param showAsZipcode The user&#39;s preference if they want to be shown by zipcode on a map (optional)
     * @param showExactLocation The user&#39;s preference if they want to be shown by their exact location on a map (optional)
     * @param showOthersExactLocation The user&#39;s preference if they want to see others exact location on a map (optional)
     * @param acceptedTerms Accepted Terms (optional)
     * @param locationVisibility Location Visibility (optional)
     * @param appBlob App Blob (optional)
     * @param appEnablePush App Enable Push (optional)
     * @param appEnableSMS App Enable SMS (optional)
     * @param appEnableEmail App Enable Email (optional)
     * @param gameType Game Type (optional)
     * @param appKey The application key (optional)
     * @param latitude The current latitude of the user (optional)
     * @param longitude The current longitude of the user (optional)
     * @param returnProfile Return Profile (optional)
     * @param audienceIdsToAdd Audience Ids to add (optional)
     * @param audienceIdsToRemove Audience Ids to remove (optional)
     * @param referralAccountId The account id of the referrer (optional)
     * @param appNickname App nickname (optional)
     * @param personalAudienceId Personal Audience (optional)
     * @param nonGuestUsername The user&#39;s username to update with if they currently have a guest username (optional)
     * @return RequestConfig
     */
    fun editAccountRequestConfig(deviceId: kotlin.String?, accountId: kotlin.Long?, connectionAccountId: kotlin.Long?, role: kotlin.String?, assetId: kotlin.Long?, name: kotlin.String?, prefixName: kotlin.String?, firstName: kotlin.String?, middleName: kotlin.String?, lastName: kotlin.String?, suffixName: kotlin.String?, title: kotlin.String?, gender: kotlin.String?, age: kotlin.Int?, birthday: kotlin.Long?, homePhone: kotlin.String?, cellPhone: kotlin.String?, cellPhoneCarrier: kotlin.String?, businessPhone: kotlin.String?, emailAddress: kotlin.String?, streetAddress: kotlin.String?, streetAddress2: kotlin.String?, city: kotlin.String?, state: kotlin.String?, zipcode: kotlin.String?, country: kotlin.String?, makeProfileInfoPublic: kotlin.Boolean?, makeGameInfoPublic: kotlin.Boolean?, makeFriendsInfoPublic: kotlin.Boolean?, hometown: kotlin.String?, height: kotlin.String?, heightIndex: kotlin.Int?, ethnicity: kotlin.String?, bodyType: kotlin.String?, maritalStatus: kotlin.String?, children: kotlin.String?, religion: kotlin.String?, education: kotlin.String?, educationIndex: kotlin.Int?, smoke: kotlin.String?, drink: kotlin.String?, companionship: kotlin.String?, companionshipIndex: kotlin.Int?, preferredMinAge: kotlin.Int?, preferredMaxAge: kotlin.Int?, preferredMinHeight: kotlin.Int?, preferredMaxHeight: kotlin.Int?, preferredGender: kotlin.String?, preferredEducation: kotlin.String?, preferredEducationIndex: kotlin.Int?, preferredBodyType: kotlin.String?, preferredEthnicity: kotlin.String?, preferredLocation: kotlin.String?, preferredLocationRange: kotlin.Double?, platforms: kotlin.String?, tags: kotlin.String?, aboutUs: kotlin.String?, matchToken: kotlin.String?, gameExperience: kotlin.String?, categories: kotlin.String?, categoryIds: kotlin.String?, responseFilters: kotlin.String?, showAsZipcode: kotlin.Boolean?, showExactLocation: kotlin.Boolean?, showOthersExactLocation: kotlin.Boolean?, acceptedTerms: kotlin.Boolean?, locationVisibility: kotlin.String?, appBlob: kotlin.String?, appEnablePush: kotlin.Boolean?, appEnableSMS: kotlin.Boolean?, appEnableEmail: kotlin.Boolean?, gameType: kotlin.String?, appKey: kotlin.String?, latitude: kotlin.Double?, longitude: kotlin.Double?, returnProfile: kotlin.Boolean?, audienceIdsToAdd: kotlin.String?, audienceIdsToRemove: kotlin.String?, referralAccountId: kotlin.Long?, appNickname: kotlin.String?, personalAudienceId: kotlin.Long?, nonGuestUsername: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (connectionAccountId != null) {
                    put("connectionAccountId", listOf(connectionAccountId.toString()))
                }
                if (role != null) {
                    put("role", listOf(role.toString()))
                }
                if (assetId != null) {
                    put("assetId", listOf(assetId.toString()))
                }
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (prefixName != null) {
                    put("prefixName", listOf(prefixName.toString()))
                }
                if (firstName != null) {
                    put("firstName", listOf(firstName.toString()))
                }
                if (middleName != null) {
                    put("middleName", listOf(middleName.toString()))
                }
                if (lastName != null) {
                    put("lastName", listOf(lastName.toString()))
                }
                if (suffixName != null) {
                    put("suffixName", listOf(suffixName.toString()))
                }
                if (title != null) {
                    put("title", listOf(title.toString()))
                }
                if (gender != null) {
                    put("gender", listOf(gender.toString()))
                }
                if (age != null) {
                    put("age", listOf(age.toString()))
                }
                if (birthday != null) {
                    put("birthday", listOf(birthday.toString()))
                }
                if (homePhone != null) {
                    put("homePhone", listOf(homePhone.toString()))
                }
                if (cellPhone != null) {
                    put("cellPhone", listOf(cellPhone.toString()))
                }
                if (cellPhoneCarrier != null) {
                    put("cellPhoneCarrier", listOf(cellPhoneCarrier.toString()))
                }
                if (businessPhone != null) {
                    put("businessPhone", listOf(businessPhone.toString()))
                }
                if (emailAddress != null) {
                    put("emailAddress", listOf(emailAddress.toString()))
                }
                if (streetAddress != null) {
                    put("streetAddress", listOf(streetAddress.toString()))
                }
                if (streetAddress2 != null) {
                    put("streetAddress2", listOf(streetAddress2.toString()))
                }
                if (city != null) {
                    put("city", listOf(city.toString()))
                }
                if (state != null) {
                    put("state", listOf(state.toString()))
                }
                if (zipcode != null) {
                    put("zipcode", listOf(zipcode.toString()))
                }
                if (country != null) {
                    put("country", listOf(country.toString()))
                }
                if (makeProfileInfoPublic != null) {
                    put("makeProfileInfoPublic", listOf(makeProfileInfoPublic.toString()))
                }
                if (makeGameInfoPublic != null) {
                    put("makeGameInfoPublic", listOf(makeGameInfoPublic.toString()))
                }
                if (makeFriendsInfoPublic != null) {
                    put("makeFriendsInfoPublic", listOf(makeFriendsInfoPublic.toString()))
                }
                if (hometown != null) {
                    put("hometown", listOf(hometown.toString()))
                }
                if (height != null) {
                    put("height", listOf(height.toString()))
                }
                if (heightIndex != null) {
                    put("heightIndex", listOf(heightIndex.toString()))
                }
                if (ethnicity != null) {
                    put("ethnicity", listOf(ethnicity.toString()))
                }
                if (bodyType != null) {
                    put("bodyType", listOf(bodyType.toString()))
                }
                if (maritalStatus != null) {
                    put("maritalStatus", listOf(maritalStatus.toString()))
                }
                if (children != null) {
                    put("children", listOf(children.toString()))
                }
                if (religion != null) {
                    put("religion", listOf(religion.toString()))
                }
                if (education != null) {
                    put("education", listOf(education.toString()))
                }
                if (educationIndex != null) {
                    put("educationIndex", listOf(educationIndex.toString()))
                }
                if (smoke != null) {
                    put("smoke", listOf(smoke.toString()))
                }
                if (drink != null) {
                    put("drink", listOf(drink.toString()))
                }
                if (companionship != null) {
                    put("companionship", listOf(companionship.toString()))
                }
                if (companionshipIndex != null) {
                    put("companionshipIndex", listOf(companionshipIndex.toString()))
                }
                if (preferredMinAge != null) {
                    put("preferredMinAge", listOf(preferredMinAge.toString()))
                }
                if (preferredMaxAge != null) {
                    put("preferredMaxAge", listOf(preferredMaxAge.toString()))
                }
                if (preferredMinHeight != null) {
                    put("preferredMinHeight", listOf(preferredMinHeight.toString()))
                }
                if (preferredMaxHeight != null) {
                    put("preferredMaxHeight", listOf(preferredMaxHeight.toString()))
                }
                if (preferredGender != null) {
                    put("preferredGender", listOf(preferredGender.toString()))
                }
                if (preferredEducation != null) {
                    put("preferredEducation", listOf(preferredEducation.toString()))
                }
                if (preferredEducationIndex != null) {
                    put("preferredEducationIndex", listOf(preferredEducationIndex.toString()))
                }
                if (preferredBodyType != null) {
                    put("preferredBodyType", listOf(preferredBodyType.toString()))
                }
                if (preferredEthnicity != null) {
                    put("preferredEthnicity", listOf(preferredEthnicity.toString()))
                }
                if (preferredLocation != null) {
                    put("preferredLocation", listOf(preferredLocation.toString()))
                }
                if (preferredLocationRange != null) {
                    put("preferredLocationRange", listOf(preferredLocationRange.toString()))
                }
                if (platforms != null) {
                    put("platforms", listOf(platforms.toString()))
                }
                if (tags != null) {
                    put("tags", listOf(tags.toString()))
                }
                if (aboutUs != null) {
                    put("aboutUs", listOf(aboutUs.toString()))
                }
                if (matchToken != null) {
                    put("matchToken", listOf(matchToken.toString()))
                }
                if (gameExperience != null) {
                    put("gameExperience", listOf(gameExperience.toString()))
                }
                if (categories != null) {
                    put("categories", listOf(categories.toString()))
                }
                if (categoryIds != null) {
                    put("categoryIds", listOf(categoryIds.toString()))
                }
                if (responseFilters != null) {
                    put("responseFilters", listOf(responseFilters.toString()))
                }
                if (showAsZipcode != null) {
                    put("showAsZipcode", listOf(showAsZipcode.toString()))
                }
                if (showExactLocation != null) {
                    put("showExactLocation", listOf(showExactLocation.toString()))
                }
                if (showOthersExactLocation != null) {
                    put("showOthersExactLocation", listOf(showOthersExactLocation.toString()))
                }
                if (acceptedTerms != null) {
                    put("acceptedTerms", listOf(acceptedTerms.toString()))
                }
                if (locationVisibility != null) {
                    put("locationVisibility", listOf(locationVisibility.toString()))
                }
                if (appBlob != null) {
                    put("appBlob", listOf(appBlob.toString()))
                }
                if (appEnablePush != null) {
                    put("appEnablePush", listOf(appEnablePush.toString()))
                }
                if (appEnableSMS != null) {
                    put("appEnableSMS", listOf(appEnableSMS.toString()))
                }
                if (appEnableEmail != null) {
                    put("appEnableEmail", listOf(appEnableEmail.toString()))
                }
                if (gameType != null) {
                    put("gameType", listOf(gameType.toString()))
                }
                if (appKey != null) {
                    put("appKey", listOf(appKey.toString()))
                }
                if (latitude != null) {
                    put("latitude", listOf(latitude.toString()))
                }
                if (longitude != null) {
                    put("longitude", listOf(longitude.toString()))
                }
                if (returnProfile != null) {
                    put("returnProfile", listOf(returnProfile.toString()))
                }
                if (audienceIdsToAdd != null) {
                    put("audienceIdsToAdd", listOf(audienceIdsToAdd.toString()))
                }
                if (audienceIdsToRemove != null) {
                    put("audienceIdsToRemove", listOf(audienceIdsToRemove.toString()))
                }
                if (referralAccountId != null) {
                    put("referralAccountId", listOf(referralAccountId.toString()))
                }
                if (appNickname != null) {
                    put("appNickname", listOf(appNickname.toString()))
                }
                if (personalAudienceId != null) {
                    put("personalAudienceId", listOf(personalAudienceId.toString()))
                }
                if (nonGuestUsername != null) {
                    put("nonGuestUsername", listOf(nonGuestUsername.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/account/profile/update",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /account/username/update
     * Update Username and Email
     * Update account&#39;s own username and/or emailAddress
     * @param deviceId The device id (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param emailAddress the user&#39;s contact email address (NOT the username) which is also used for email validation (optional)
     * @param username the user&#39;s username to update with if they currently have a guest username (optional)
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun editUsername(deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, emailAddress: kotlin.String? = null, username: kotlin.String? = null) : SirqulResponse {
        val localVarResponse = editUsernameWithHttpInfo(deviceId = deviceId, accountId = accountId, emailAddress = emailAddress, username = username)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /account/username/update
     * Update Username and Email
     * Update account&#39;s own username and/or emailAddress
     * @param deviceId The device id (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param emailAddress the user&#39;s contact email address (NOT the username) which is also used for email validation (optional)
     * @param username the user&#39;s username to update with if they currently have a guest username (optional)
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun editUsernameWithHttpInfo(deviceId: kotlin.String?, accountId: kotlin.Long?, emailAddress: kotlin.String?, username: kotlin.String?) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = editUsernameRequestConfig(deviceId = deviceId, accountId = accountId, emailAddress = emailAddress, username = username)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation editUsername
     *
     * @param deviceId The device id (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param emailAddress the user&#39;s contact email address (NOT the username) which is also used for email validation (optional)
     * @param username the user&#39;s username to update with if they currently have a guest username (optional)
     * @return RequestConfig
     */
    fun editUsernameRequestConfig(deviceId: kotlin.String?, accountId: kotlin.Long?, emailAddress: kotlin.String?, username: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (emailAddress != null) {
                    put("emailAddress", listOf(emailAddress.toString()))
                }
                if (username != null) {
                    put("username", listOf(username.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/account/username/update",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /account/profile/get
     * Get Account
     * Gets a user&#39;s account profile. Application settings and account settings will also be returned for the owner of the account.
     * @param returnNulls Return Nulls (optional, default to false)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param connectionAccountEmail Connection Account Email (optional)
     * @param connectionAccountId The account id used to view another person&#39;s account (optional, default to 0L)
     * @param responseFilters A comma separated list of ProfileFilters for filtering the returned response data (optional, default to "PROFILE")
     * @param gameType Game Type (optional)
     * @param appKey The application key (optional)
     * @param purchaseType Purchase Type (optional, default to "SIRQUL")
     * @param updateViewedDate Determines whether to track if a person has viewed someone&#39;s profile (optional, default to false)
     * @param latitude Latitude used to update the user&#39;s current location (optional)
     * @param longitude Longitude used to update the user&#39;s current location (optional)
     * @return ProfileResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAccount(returnNulls: kotlin.Boolean? = false, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, connectionAccountEmail: kotlin.String? = null, connectionAccountId: kotlin.Long? = 0L, responseFilters: kotlin.String? = "PROFILE", gameType: kotlin.String? = null, appKey: kotlin.String? = null, purchaseType: kotlin.String? = "SIRQUL", updateViewedDate: kotlin.Boolean? = false, latitude: kotlin.Double? = null, longitude: kotlin.Double? = null) : ProfileResponse {
        val localVarResponse = getAccountWithHttpInfo(returnNulls = returnNulls, deviceId = deviceId, accountId = accountId, connectionAccountEmail = connectionAccountEmail, connectionAccountId = connectionAccountId, responseFilters = responseFilters, gameType = gameType, appKey = appKey, purchaseType = purchaseType, updateViewedDate = updateViewedDate, latitude = latitude, longitude = longitude)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ProfileResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /account/profile/get
     * Get Account
     * Gets a user&#39;s account profile. Application settings and account settings will also be returned for the owner of the account.
     * @param returnNulls Return Nulls (optional, default to false)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param connectionAccountEmail Connection Account Email (optional)
     * @param connectionAccountId The account id used to view another person&#39;s account (optional, default to 0L)
     * @param responseFilters A comma separated list of ProfileFilters for filtering the returned response data (optional, default to "PROFILE")
     * @param gameType Game Type (optional)
     * @param appKey The application key (optional)
     * @param purchaseType Purchase Type (optional, default to "SIRQUL")
     * @param updateViewedDate Determines whether to track if a person has viewed someone&#39;s profile (optional, default to false)
     * @param latitude Latitude used to update the user&#39;s current location (optional)
     * @param longitude Longitude used to update the user&#39;s current location (optional)
     * @return ApiResponse<ProfileResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getAccountWithHttpInfo(returnNulls: kotlin.Boolean?, deviceId: kotlin.String?, accountId: kotlin.Long?, connectionAccountEmail: kotlin.String?, connectionAccountId: kotlin.Long?, responseFilters: kotlin.String?, gameType: kotlin.String?, appKey: kotlin.String?, purchaseType: kotlin.String?, updateViewedDate: kotlin.Boolean?, latitude: kotlin.Double?, longitude: kotlin.Double?) : ApiResponse<ProfileResponse?> {
        val localVariableConfig = getAccountRequestConfig(returnNulls = returnNulls, deviceId = deviceId, accountId = accountId, connectionAccountEmail = connectionAccountEmail, connectionAccountId = connectionAccountId, responseFilters = responseFilters, gameType = gameType, appKey = appKey, purchaseType = purchaseType, updateViewedDate = updateViewedDate, latitude = latitude, longitude = longitude)

        return request<Unit, ProfileResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAccount
     *
     * @param returnNulls Return Nulls (optional, default to false)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param connectionAccountEmail Connection Account Email (optional)
     * @param connectionAccountId The account id used to view another person&#39;s account (optional, default to 0L)
     * @param responseFilters A comma separated list of ProfileFilters for filtering the returned response data (optional, default to "PROFILE")
     * @param gameType Game Type (optional)
     * @param appKey The application key (optional)
     * @param purchaseType Purchase Type (optional, default to "SIRQUL")
     * @param updateViewedDate Determines whether to track if a person has viewed someone&#39;s profile (optional, default to false)
     * @param latitude Latitude used to update the user&#39;s current location (optional)
     * @param longitude Longitude used to update the user&#39;s current location (optional)
     * @return RequestConfig
     */
    fun getAccountRequestConfig(returnNulls: kotlin.Boolean?, deviceId: kotlin.String?, accountId: kotlin.Long?, connectionAccountEmail: kotlin.String?, connectionAccountId: kotlin.Long?, responseFilters: kotlin.String?, gameType: kotlin.String?, appKey: kotlin.String?, purchaseType: kotlin.String?, updateViewedDate: kotlin.Boolean?, latitude: kotlin.Double?, longitude: kotlin.Double?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (returnNulls != null) {
                    put("returnNulls", listOf(returnNulls.toString()))
                }
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (connectionAccountEmail != null) {
                    put("connectionAccountEmail", listOf(connectionAccountEmail.toString()))
                }
                if (connectionAccountId != null) {
                    put("connectionAccountId", listOf(connectionAccountId.toString()))
                }
                if (responseFilters != null) {
                    put("responseFilters", listOf(responseFilters.toString()))
                }
                if (gameType != null) {
                    put("gameType", listOf(gameType.toString()))
                }
                if (appKey != null) {
                    put("appKey", listOf(appKey.toString()))
                }
                if (purchaseType != null) {
                    put("purchaseType", listOf(purchaseType.toString()))
                }
                if (updateViewedDate != null) {
                    put("updateViewedDate", listOf(updateViewedDate.toString()))
                }
                if (latitude != null) {
                    put("latitude", listOf(latitude.toString()))
                }
                if (longitude != null) {
                    put("longitude", listOf(longitude.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/account/profile/get",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /account/profile/assets
     * Get Profile Assets
     * Get a list of assets a person has ever uploaded. Filters the list based on parameters.
     * @param returnNulls Determines whether to return null fields in the response (optional, default to false)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param ownerId The account id of the person the user wants to view (optional)
     * @param mediaTypes Comma separated list of MediaType (optional)
     * @param mimeTypes Comma separated list of mime types (optional)
     * @param sortField Determines what the returning list will be sorted by (see AssetApiMap) (optional, default to "CREATED")
     * @param descending Determines whether to return the resulting list in descending or ascending order (optional, default to true)
     * @param latitude Latitude used to update the user&#39;s current location (optional)
     * @param longitude Longitude used to update the user&#39;s current location (optional)
     * @param i _i (optional)
     * @param start Start of the pagination (optional, default to 0)
     * @param l _l (optional)
     * @param limit Limit of the pagination (optional, default to 0)
     * @return AssetListResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getProfileAssets(returnNulls: kotlin.Boolean? = false, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, ownerId: kotlin.Long? = null, mediaTypes: kotlin.String? = null, mimeTypes: kotlin.String? = null, sortField: kotlin.String? = "CREATED", descending: kotlin.Boolean? = true, latitude: kotlin.Double? = null, longitude: kotlin.Double? = null, i: kotlin.Int? = null, start: kotlin.Int? = 0, l: kotlin.Int? = null, limit: kotlin.Int? = 0) : AssetListResponse {
        val localVarResponse = getProfileAssetsWithHttpInfo(returnNulls = returnNulls, deviceId = deviceId, accountId = accountId, ownerId = ownerId, mediaTypes = mediaTypes, mimeTypes = mimeTypes, sortField = sortField, descending = descending, latitude = latitude, longitude = longitude, i = i, start = start, l = l, limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AssetListResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /account/profile/assets
     * Get Profile Assets
     * Get a list of assets a person has ever uploaded. Filters the list based on parameters.
     * @param returnNulls Determines whether to return null fields in the response (optional, default to false)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param ownerId The account id of the person the user wants to view (optional)
     * @param mediaTypes Comma separated list of MediaType (optional)
     * @param mimeTypes Comma separated list of mime types (optional)
     * @param sortField Determines what the returning list will be sorted by (see AssetApiMap) (optional, default to "CREATED")
     * @param descending Determines whether to return the resulting list in descending or ascending order (optional, default to true)
     * @param latitude Latitude used to update the user&#39;s current location (optional)
     * @param longitude Longitude used to update the user&#39;s current location (optional)
     * @param i _i (optional)
     * @param start Start of the pagination (optional, default to 0)
     * @param l _l (optional)
     * @param limit Limit of the pagination (optional, default to 0)
     * @return ApiResponse<AssetListResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getProfileAssetsWithHttpInfo(returnNulls: kotlin.Boolean?, deviceId: kotlin.String?, accountId: kotlin.Long?, ownerId: kotlin.Long?, mediaTypes: kotlin.String?, mimeTypes: kotlin.String?, sortField: kotlin.String?, descending: kotlin.Boolean?, latitude: kotlin.Double?, longitude: kotlin.Double?, i: kotlin.Int?, start: kotlin.Int?, l: kotlin.Int?, limit: kotlin.Int?) : ApiResponse<AssetListResponse?> {
        val localVariableConfig = getProfileAssetsRequestConfig(returnNulls = returnNulls, deviceId = deviceId, accountId = accountId, ownerId = ownerId, mediaTypes = mediaTypes, mimeTypes = mimeTypes, sortField = sortField, descending = descending, latitude = latitude, longitude = longitude, i = i, start = start, l = l, limit = limit)

        return request<Unit, AssetListResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getProfileAssets
     *
     * @param returnNulls Determines whether to return null fields in the response (optional, default to false)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param ownerId The account id of the person the user wants to view (optional)
     * @param mediaTypes Comma separated list of MediaType (optional)
     * @param mimeTypes Comma separated list of mime types (optional)
     * @param sortField Determines what the returning list will be sorted by (see AssetApiMap) (optional, default to "CREATED")
     * @param descending Determines whether to return the resulting list in descending or ascending order (optional, default to true)
     * @param latitude Latitude used to update the user&#39;s current location (optional)
     * @param longitude Longitude used to update the user&#39;s current location (optional)
     * @param i _i (optional)
     * @param start Start of the pagination (optional, default to 0)
     * @param l _l (optional)
     * @param limit Limit of the pagination (optional, default to 0)
     * @return RequestConfig
     */
    fun getProfileAssetsRequestConfig(returnNulls: kotlin.Boolean?, deviceId: kotlin.String?, accountId: kotlin.Long?, ownerId: kotlin.Long?, mediaTypes: kotlin.String?, mimeTypes: kotlin.String?, sortField: kotlin.String?, descending: kotlin.Boolean?, latitude: kotlin.Double?, longitude: kotlin.Double?, i: kotlin.Int?, start: kotlin.Int?, l: kotlin.Int?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (returnNulls != null) {
                    put("returnNulls", listOf(returnNulls.toString()))
                }
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (ownerId != null) {
                    put("ownerId", listOf(ownerId.toString()))
                }
                if (mediaTypes != null) {
                    put("mediaTypes", listOf(mediaTypes.toString()))
                }
                if (mimeTypes != null) {
                    put("mimeTypes", listOf(mimeTypes.toString()))
                }
                if (sortField != null) {
                    put("sortField", listOf(sortField.toString()))
                }
                if (descending != null) {
                    put("descending", listOf(descending.toString()))
                }
                if (latitude != null) {
                    put("latitude", listOf(latitude.toString()))
                }
                if (longitude != null) {
                    put("longitude", listOf(longitude.toString()))
                }
                if (i != null) {
                    put("_i", listOf(i.toString()))
                }
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (l != null) {
                    put("_l", listOf(l.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/account/profile/assets",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /account/referral/list
     * Search Accounts
     * Gets a user&#39;s account profile and their referral List.
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param appKey The application key (optional)
     * @param retrieveType one of these option - GET_CHILDREN will get all accounts that had signed up using the current account invite link - GET_ANCESTOR will get all accounts that referred the current account and it&#39;s parents, recursively - GET_ALL will get all of the above (optional)
     * @param levelLimit level limit for children and ancestors of current account, starts from current account (optional)
     * @param ancestorLevelLimit level limit for ancestors, will override levelLimit if this is set (optional)
     * @param childrenLevelLimit level limit for children, will override levelLimit if this is set (optional)
     * @param ancestorListStart pagination start for children list (optional)
     * @param ancestorListLimit pagination limit for children list (optional)
     * @param childrenListStart pagination start for children list (optional)
     * @param childrenListLimit pagination limit for children list (optional)
     * @param childrenChildren if true, on each item in ancestor and children list, return the childrenTotalNumber and ancestorTotalNumber for that item (optional, default to true)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getReferralList(accountId: kotlin.Long? = null, appKey: kotlin.String? = null, retrieveType: kotlin.String? = null, levelLimit: java.math.BigDecimal? = null, ancestorLevelLimit: java.math.BigDecimal? = null, childrenLevelLimit: java.math.BigDecimal? = null, ancestorListStart: java.math.BigDecimal? = null, ancestorListLimit: java.math.BigDecimal? = null, childrenListStart: java.math.BigDecimal? = null, childrenListLimit: java.math.BigDecimal? = null, childrenChildren: kotlin.Boolean? = true) : Unit {
        val localVarResponse = getReferralListWithHttpInfo(accountId = accountId, appKey = appKey, retrieveType = retrieveType, levelLimit = levelLimit, ancestorLevelLimit = ancestorLevelLimit, childrenLevelLimit = childrenLevelLimit, ancestorListStart = ancestorListStart, ancestorListLimit = ancestorListLimit, childrenListStart = childrenListStart, childrenListLimit = childrenListLimit, childrenChildren = childrenChildren)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /account/referral/list
     * Search Accounts
     * Gets a user&#39;s account profile and their referral List.
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param appKey The application key (optional)
     * @param retrieveType one of these option - GET_CHILDREN will get all accounts that had signed up using the current account invite link - GET_ANCESTOR will get all accounts that referred the current account and it&#39;s parents, recursively - GET_ALL will get all of the above (optional)
     * @param levelLimit level limit for children and ancestors of current account, starts from current account (optional)
     * @param ancestorLevelLimit level limit for ancestors, will override levelLimit if this is set (optional)
     * @param childrenLevelLimit level limit for children, will override levelLimit if this is set (optional)
     * @param ancestorListStart pagination start for children list (optional)
     * @param ancestorListLimit pagination limit for children list (optional)
     * @param childrenListStart pagination start for children list (optional)
     * @param childrenListLimit pagination limit for children list (optional)
     * @param childrenChildren if true, on each item in ancestor and children list, return the childrenTotalNumber and ancestorTotalNumber for that item (optional, default to true)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun getReferralListWithHttpInfo(accountId: kotlin.Long?, appKey: kotlin.String?, retrieveType: kotlin.String?, levelLimit: java.math.BigDecimal?, ancestorLevelLimit: java.math.BigDecimal?, childrenLevelLimit: java.math.BigDecimal?, ancestorListStart: java.math.BigDecimal?, ancestorListLimit: java.math.BigDecimal?, childrenListStart: java.math.BigDecimal?, childrenListLimit: java.math.BigDecimal?, childrenChildren: kotlin.Boolean?) : ApiResponse<Unit?> {
        val localVariableConfig = getReferralListRequestConfig(accountId = accountId, appKey = appKey, retrieveType = retrieveType, levelLimit = levelLimit, ancestorLevelLimit = ancestorLevelLimit, childrenLevelLimit = childrenLevelLimit, ancestorListStart = ancestorListStart, ancestorListLimit = ancestorListLimit, childrenListStart = childrenListStart, childrenListLimit = childrenListLimit, childrenChildren = childrenChildren)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getReferralList
     *
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param appKey The application key (optional)
     * @param retrieveType one of these option - GET_CHILDREN will get all accounts that had signed up using the current account invite link - GET_ANCESTOR will get all accounts that referred the current account and it&#39;s parents, recursively - GET_ALL will get all of the above (optional)
     * @param levelLimit level limit for children and ancestors of current account, starts from current account (optional)
     * @param ancestorLevelLimit level limit for ancestors, will override levelLimit if this is set (optional)
     * @param childrenLevelLimit level limit for children, will override levelLimit if this is set (optional)
     * @param ancestorListStart pagination start for children list (optional)
     * @param ancestorListLimit pagination limit for children list (optional)
     * @param childrenListStart pagination start for children list (optional)
     * @param childrenListLimit pagination limit for children list (optional)
     * @param childrenChildren if true, on each item in ancestor and children list, return the childrenTotalNumber and ancestorTotalNumber for that item (optional, default to true)
     * @return RequestConfig
     */
    fun getReferralListRequestConfig(accountId: kotlin.Long?, appKey: kotlin.String?, retrieveType: kotlin.String?, levelLimit: java.math.BigDecimal?, ancestorLevelLimit: java.math.BigDecimal?, childrenLevelLimit: java.math.BigDecimal?, ancestorListStart: java.math.BigDecimal?, ancestorListLimit: java.math.BigDecimal?, childrenListStart: java.math.BigDecimal?, childrenListLimit: java.math.BigDecimal?, childrenChildren: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (appKey != null) {
                    put("appKey", listOf(appKey.toString()))
                }
                if (retrieveType != null) {
                    put("retrieveType", listOf(retrieveType.toString()))
                }
                if (levelLimit != null) {
                    put("levelLimit", listOf(levelLimit.toString()))
                }
                if (ancestorLevelLimit != null) {
                    put("ancestorLevelLimit", listOf(ancestorLevelLimit.toString()))
                }
                if (childrenLevelLimit != null) {
                    put("childrenLevelLimit", listOf(childrenLevelLimit.toString()))
                }
                if (ancestorListStart != null) {
                    put("ancestorListStart", listOf(ancestorListStart.toString()))
                }
                if (ancestorListLimit != null) {
                    put("ancestorListLimit", listOf(ancestorListLimit.toString()))
                }
                if (childrenListStart != null) {
                    put("childrenListStart", listOf(childrenListStart.toString()))
                }
                if (childrenListLimit != null) {
                    put("childrenListLimit", listOf(childrenListLimit.toString()))
                }
                if (childrenChildren != null) {
                    put("childrenChildren", listOf(childrenChildren.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/account/referral/list",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /account/settings/get
     * Get Account Settings
     * Get the account settings for a user
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param latitude The current latitude of the user (optional)
     * @param longitude The current longitude of the user (optional)
     * @return UserSettingsResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getSettings(deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, latitude: kotlin.Double? = null, longitude: kotlin.Double? = null) : UserSettingsResponse {
        val localVarResponse = getSettingsWithHttpInfo(deviceId = deviceId, accountId = accountId, latitude = latitude, longitude = longitude)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UserSettingsResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /account/settings/get
     * Get Account Settings
     * Get the account settings for a user
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param latitude The current latitude of the user (optional)
     * @param longitude The current longitude of the user (optional)
     * @return ApiResponse<UserSettingsResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getSettingsWithHttpInfo(deviceId: kotlin.String?, accountId: kotlin.Long?, latitude: kotlin.Double?, longitude: kotlin.Double?) : ApiResponse<UserSettingsResponse?> {
        val localVariableConfig = getSettingsRequestConfig(deviceId = deviceId, accountId = accountId, latitude = latitude, longitude = longitude)

        return request<Unit, UserSettingsResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getSettings
     *
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param latitude The current latitude of the user (optional)
     * @param longitude The current longitude of the user (optional)
     * @return RequestConfig
     */
    fun getSettingsRequestConfig(deviceId: kotlin.String?, accountId: kotlin.Long?, latitude: kotlin.Double?, longitude: kotlin.Double?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (latitude != null) {
                    put("latitude", listOf(latitude.toString()))
                }
                if (longitude != null) {
                    put("longitude", listOf(longitude.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/account/settings/get",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /account/login/delegate
     * Login as Account
     * A login service that supports logging in as someone else (accounts that the user manages). Intended for internal use for now.
     * @param accessToken 
     * @param appKey 
     * @param deviceId  (optional)
     * @param accessTokenSecret  (optional)
     * @param delegatedAccountId  (optional)
     * @param delegatedUsername  (optional)
     * @param networkUID The access provider to authenticate against (default: USERNAME). Supported values: FACEBOOK, TWITTER, USERNAME, PHONE (optional, default to "USERNAME")
     * @param ageRestriction Checks user&#39;s birthday to see if they meet an age requirement. If the user is under age, an error message is returned. (optional, default to 0)
     * @param responseFilters This determines how much of the profile should be returned, see ProfileFilters (optional, default to "PROFILE")
     * @param latitude  (optional)
     * @param longitude  (optional)
     * @return ProfileResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun loginDelegate(accessToken: kotlin.String, appKey: kotlin.String, deviceId: kotlin.String? = null, accessTokenSecret: kotlin.String? = null, delegatedAccountId: kotlin.Long? = null, delegatedUsername: kotlin.String? = null, networkUID: kotlin.String? = "USERNAME", ageRestriction: kotlin.Int? = 0, responseFilters: kotlin.String? = "PROFILE", latitude: kotlin.Double? = null, longitude: kotlin.Double? = null) : ProfileResponse {
        val localVarResponse = loginDelegateWithHttpInfo(accessToken = accessToken, appKey = appKey, deviceId = deviceId, accessTokenSecret = accessTokenSecret, delegatedAccountId = delegatedAccountId, delegatedUsername = delegatedUsername, networkUID = networkUID, ageRestriction = ageRestriction, responseFilters = responseFilters, latitude = latitude, longitude = longitude)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ProfileResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /account/login/delegate
     * Login as Account
     * A login service that supports logging in as someone else (accounts that the user manages). Intended for internal use for now.
     * @param accessToken 
     * @param appKey 
     * @param deviceId  (optional)
     * @param accessTokenSecret  (optional)
     * @param delegatedAccountId  (optional)
     * @param delegatedUsername  (optional)
     * @param networkUID The access provider to authenticate against (default: USERNAME). Supported values: FACEBOOK, TWITTER, USERNAME, PHONE (optional, default to "USERNAME")
     * @param ageRestriction Checks user&#39;s birthday to see if they meet an age requirement. If the user is under age, an error message is returned. (optional, default to 0)
     * @param responseFilters This determines how much of the profile should be returned, see ProfileFilters (optional, default to "PROFILE")
     * @param latitude  (optional)
     * @param longitude  (optional)
     * @return ApiResponse<ProfileResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun loginDelegateWithHttpInfo(accessToken: kotlin.String, appKey: kotlin.String, deviceId: kotlin.String?, accessTokenSecret: kotlin.String?, delegatedAccountId: kotlin.Long?, delegatedUsername: kotlin.String?, networkUID: kotlin.String?, ageRestriction: kotlin.Int?, responseFilters: kotlin.String?, latitude: kotlin.Double?, longitude: kotlin.Double?) : ApiResponse<ProfileResponse?> {
        val localVariableConfig = loginDelegateRequestConfig(accessToken = accessToken, appKey = appKey, deviceId = deviceId, accessTokenSecret = accessTokenSecret, delegatedAccountId = delegatedAccountId, delegatedUsername = delegatedUsername, networkUID = networkUID, ageRestriction = ageRestriction, responseFilters = responseFilters, latitude = latitude, longitude = longitude)

        return request<Unit, ProfileResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation loginDelegate
     *
     * @param accessToken 
     * @param appKey 
     * @param deviceId  (optional)
     * @param accessTokenSecret  (optional)
     * @param delegatedAccountId  (optional)
     * @param delegatedUsername  (optional)
     * @param networkUID The access provider to authenticate against (default: USERNAME). Supported values: FACEBOOK, TWITTER, USERNAME, PHONE (optional, default to "USERNAME")
     * @param ageRestriction Checks user&#39;s birthday to see if they meet an age requirement. If the user is under age, an error message is returned. (optional, default to 0)
     * @param responseFilters This determines how much of the profile should be returned, see ProfileFilters (optional, default to "PROFILE")
     * @param latitude  (optional)
     * @param longitude  (optional)
     * @return RequestConfig
     */
    fun loginDelegateRequestConfig(accessToken: kotlin.String, appKey: kotlin.String, deviceId: kotlin.String?, accessTokenSecret: kotlin.String?, delegatedAccountId: kotlin.Long?, delegatedUsername: kotlin.String?, networkUID: kotlin.String?, ageRestriction: kotlin.Int?, responseFilters: kotlin.String?, latitude: kotlin.Double?, longitude: kotlin.Double?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                put("accessToken", listOf(accessToken.toString()))
                if (accessTokenSecret != null) {
                    put("accessTokenSecret", listOf(accessTokenSecret.toString()))
                }
                if (delegatedAccountId != null) {
                    put("delegatedAccountId", listOf(delegatedAccountId.toString()))
                }
                if (delegatedUsername != null) {
                    put("delegatedUsername", listOf(delegatedUsername.toString()))
                }
                if (networkUID != null) {
                    put("networkUID", listOf(networkUID.toString()))
                }
                put("appKey", listOf(appKey.toString()))
                if (ageRestriction != null) {
                    put("ageRestriction", listOf(ageRestriction.toString()))
                }
                if (responseFilters != null) {
                    put("responseFilters", listOf(responseFilters.toString()))
                }
                if (latitude != null) {
                    put("latitude", listOf(latitude.toString()))
                }
                if (longitude != null) {
                    put("longitude", listOf(longitude.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/account/login/delegate",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /account/login
     * Login Account
     * General login service that supports various authentication methods. Currently supports Facebook, Twitter, Sirqul Username, and Sirqul Phone by default. Can also support custom networks created using the {@link ThirdPartyApi}
     * @param accessToken The access token to authenticate with (ex: username or fb token)
     * @param networkUID The access provider to authenticate against. This can be custom  networks created using the ThirdPartyApi as well. Supported values by default  include: FACEBOOK, TWITTER, USERNAME, PHONE  (default to "USERNAME")
     * @param appKey The application key
     * @param deviceId The unique id of the device making the request (optional)
     * @param deviceIdType The type of device id (this is defined by the client), ie. MAC_ADDRESS, APPLE_UDID, etc (optional)
     * @param accessTokenSecret The secret to authenticate with (ex: password) (optional)
     * @param ageRestriction Checks user&#39;s birthday to see if they meet an age requirement. If the user is under age, an error message is returned. (optional, default to 0)
     * @param responseFilters This determines how much of the profile should be returned, see ProfileFilters (optional, default to "PROFILE")
     * @param latitude Used to update the user&#39;s current location (optional)
     * @param longitude Used to update the user&#39;s current location (optional)
     * @param emailMatch Option to check for email if username doesn&#39;t match, also support multiple accounts (optional, default to false)
     * @param chosenAccountId Chosen account Id sent from the app - pass in the 2nd request to choose an account from multiple accounts matching the email - use one of the account id from the previous request (optional, default to 0L)
     * @param thirdPartyCredentialId Third-party credential Id, pass in the 2nd request to choose an account from multiple accounts matching the email - use the id from the previous call ThirdPartyCredential object (optional, default to 0L)
     * @return ProfileResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun loginGeneral(accessToken: kotlin.String, networkUID: kotlin.String = "USERNAME", appKey: kotlin.String, deviceId: kotlin.String? = null, deviceIdType: kotlin.String? = null, accessTokenSecret: kotlin.String? = null, ageRestriction: kotlin.Int? = 0, responseFilters: kotlin.String? = "PROFILE", latitude: kotlin.Double? = null, longitude: kotlin.Double? = null, emailMatch: kotlin.Boolean? = false, chosenAccountId: kotlin.Long? = 0L, thirdPartyCredentialId: kotlin.Long? = 0L) : ProfileResponse {
        val localVarResponse = loginGeneralWithHttpInfo(accessToken = accessToken, networkUID = networkUID, appKey = appKey, deviceId = deviceId, deviceIdType = deviceIdType, accessTokenSecret = accessTokenSecret, ageRestriction = ageRestriction, responseFilters = responseFilters, latitude = latitude, longitude = longitude, emailMatch = emailMatch, chosenAccountId = chosenAccountId, thirdPartyCredentialId = thirdPartyCredentialId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ProfileResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /account/login
     * Login Account
     * General login service that supports various authentication methods. Currently supports Facebook, Twitter, Sirqul Username, and Sirqul Phone by default. Can also support custom networks created using the {@link ThirdPartyApi}
     * @param accessToken The access token to authenticate with (ex: username or fb token)
     * @param networkUID The access provider to authenticate against. This can be custom  networks created using the ThirdPartyApi as well. Supported values by default  include: FACEBOOK, TWITTER, USERNAME, PHONE  (default to "USERNAME")
     * @param appKey The application key
     * @param deviceId The unique id of the device making the request (optional)
     * @param deviceIdType The type of device id (this is defined by the client), ie. MAC_ADDRESS, APPLE_UDID, etc (optional)
     * @param accessTokenSecret The secret to authenticate with (ex: password) (optional)
     * @param ageRestriction Checks user&#39;s birthday to see if they meet an age requirement. If the user is under age, an error message is returned. (optional, default to 0)
     * @param responseFilters This determines how much of the profile should be returned, see ProfileFilters (optional, default to "PROFILE")
     * @param latitude Used to update the user&#39;s current location (optional)
     * @param longitude Used to update the user&#39;s current location (optional)
     * @param emailMatch Option to check for email if username doesn&#39;t match, also support multiple accounts (optional, default to false)
     * @param chosenAccountId Chosen account Id sent from the app - pass in the 2nd request to choose an account from multiple accounts matching the email - use one of the account id from the previous request (optional, default to 0L)
     * @param thirdPartyCredentialId Third-party credential Id, pass in the 2nd request to choose an account from multiple accounts matching the email - use the id from the previous call ThirdPartyCredential object (optional, default to 0L)
     * @return ApiResponse<ProfileResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun loginGeneralWithHttpInfo(accessToken: kotlin.String, networkUID: kotlin.String, appKey: kotlin.String, deviceId: kotlin.String?, deviceIdType: kotlin.String?, accessTokenSecret: kotlin.String?, ageRestriction: kotlin.Int?, responseFilters: kotlin.String?, latitude: kotlin.Double?, longitude: kotlin.Double?, emailMatch: kotlin.Boolean?, chosenAccountId: kotlin.Long?, thirdPartyCredentialId: kotlin.Long?) : ApiResponse<ProfileResponse?> {
        val localVariableConfig = loginGeneralRequestConfig(accessToken = accessToken, networkUID = networkUID, appKey = appKey, deviceId = deviceId, deviceIdType = deviceIdType, accessTokenSecret = accessTokenSecret, ageRestriction = ageRestriction, responseFilters = responseFilters, latitude = latitude, longitude = longitude, emailMatch = emailMatch, chosenAccountId = chosenAccountId, thirdPartyCredentialId = thirdPartyCredentialId)

        return request<Unit, ProfileResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation loginGeneral
     *
     * @param accessToken The access token to authenticate with (ex: username or fb token)
     * @param networkUID The access provider to authenticate against. This can be custom  networks created using the ThirdPartyApi as well. Supported values by default  include: FACEBOOK, TWITTER, USERNAME, PHONE  (default to "USERNAME")
     * @param appKey The application key
     * @param deviceId The unique id of the device making the request (optional)
     * @param deviceIdType The type of device id (this is defined by the client), ie. MAC_ADDRESS, APPLE_UDID, etc (optional)
     * @param accessTokenSecret The secret to authenticate with (ex: password) (optional)
     * @param ageRestriction Checks user&#39;s birthday to see if they meet an age requirement. If the user is under age, an error message is returned. (optional, default to 0)
     * @param responseFilters This determines how much of the profile should be returned, see ProfileFilters (optional, default to "PROFILE")
     * @param latitude Used to update the user&#39;s current location (optional)
     * @param longitude Used to update the user&#39;s current location (optional)
     * @param emailMatch Option to check for email if username doesn&#39;t match, also support multiple accounts (optional, default to false)
     * @param chosenAccountId Chosen account Id sent from the app - pass in the 2nd request to choose an account from multiple accounts matching the email - use one of the account id from the previous request (optional, default to 0L)
     * @param thirdPartyCredentialId Third-party credential Id, pass in the 2nd request to choose an account from multiple accounts matching the email - use the id from the previous call ThirdPartyCredential object (optional, default to 0L)
     * @return RequestConfig
     */
    fun loginGeneralRequestConfig(accessToken: kotlin.String, networkUID: kotlin.String, appKey: kotlin.String, deviceId: kotlin.String?, deviceIdType: kotlin.String?, accessTokenSecret: kotlin.String?, ageRestriction: kotlin.Int?, responseFilters: kotlin.String?, latitude: kotlin.Double?, longitude: kotlin.Double?, emailMatch: kotlin.Boolean?, chosenAccountId: kotlin.Long?, thirdPartyCredentialId: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (deviceIdType != null) {
                    put("deviceIdType", listOf(deviceIdType.toString()))
                }
                put("accessToken", listOf(accessToken.toString()))
                if (accessTokenSecret != null) {
                    put("accessTokenSecret", listOf(accessTokenSecret.toString()))
                }
                put("networkUID", listOf(networkUID.toString()))
                put("appKey", listOf(appKey.toString()))
                if (ageRestriction != null) {
                    put("ageRestriction", listOf(ageRestriction.toString()))
                }
                if (responseFilters != null) {
                    put("responseFilters", listOf(responseFilters.toString()))
                }
                if (latitude != null) {
                    put("latitude", listOf(latitude.toString()))
                }
                if (longitude != null) {
                    put("longitude", listOf(longitude.toString()))
                }
                if (emailMatch != null) {
                    put("emailMatch", listOf(emailMatch.toString()))
                }
                if (chosenAccountId != null) {
                    put("chosenAccountId", listOf(chosenAccountId.toString()))
                }
                if (thirdPartyCredentialId != null) {
                    put("thirdPartyCredentialId", listOf(thirdPartyCredentialId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/account/login",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /account/get
     * Login Account (Username)
     * Login to system with an account
     * @param username the user&#39;s email address they used to sign-up
     * @param password the password
     * @param deviceId the device id (optional)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @param app the app (optional)
     * @param gameType This parameter is deprecated. This is deprecated, use appKey. (optional)
     * @param appKey the application key (optional)
     * @param returnProfile the profile to return (optional)
     * @param responseFilters a comma separated list of ProfileFilters for filtering the returned response data (optional)
     * @return ProfileResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun loginUsername(username: kotlin.String, password: kotlin.String, deviceId: kotlin.String? = null, latitude: kotlin.Double? = null, longitude: kotlin.Double? = null, app: kotlin.String? = null, gameType: kotlin.String? = null, appKey: kotlin.String? = null, returnProfile: kotlin.Boolean? = null, responseFilters: kotlin.String? = null) : ProfileResponse {
        val localVarResponse = loginUsernameWithHttpInfo(username = username, password = password, deviceId = deviceId, latitude = latitude, longitude = longitude, app = app, gameType = gameType, appKey = appKey, returnProfile = returnProfile, responseFilters = responseFilters)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ProfileResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /account/get
     * Login Account (Username)
     * Login to system with an account
     * @param username the user&#39;s email address they used to sign-up
     * @param password the password
     * @param deviceId the device id (optional)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @param app the app (optional)
     * @param gameType This parameter is deprecated. This is deprecated, use appKey. (optional)
     * @param appKey the application key (optional)
     * @param returnProfile the profile to return (optional)
     * @param responseFilters a comma separated list of ProfileFilters for filtering the returned response data (optional)
     * @return ApiResponse<ProfileResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun loginUsernameWithHttpInfo(username: kotlin.String, password: kotlin.String, deviceId: kotlin.String?, latitude: kotlin.Double?, longitude: kotlin.Double?, app: kotlin.String?, gameType: kotlin.String?, appKey: kotlin.String?, returnProfile: kotlin.Boolean?, responseFilters: kotlin.String?) : ApiResponse<ProfileResponse?> {
        val localVariableConfig = loginUsernameRequestConfig(username = username, password = password, deviceId = deviceId, latitude = latitude, longitude = longitude, app = app, gameType = gameType, appKey = appKey, returnProfile = returnProfile, responseFilters = responseFilters)

        return request<Unit, ProfileResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation loginUsername
     *
     * @param username the user&#39;s email address they used to sign-up
     * @param password the password
     * @param deviceId the device id (optional)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @param app the app (optional)
     * @param gameType This parameter is deprecated. This is deprecated, use appKey. (optional)
     * @param appKey the application key (optional)
     * @param returnProfile the profile to return (optional)
     * @param responseFilters a comma separated list of ProfileFilters for filtering the returned response data (optional)
     * @return RequestConfig
     */
    fun loginUsernameRequestConfig(username: kotlin.String, password: kotlin.String, deviceId: kotlin.String?, latitude: kotlin.Double?, longitude: kotlin.Double?, app: kotlin.String?, gameType: kotlin.String?, appKey: kotlin.String?, returnProfile: kotlin.Boolean?, responseFilters: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                put("username", listOf(username.toString()))
                put("password", listOf(password.toString()))
                if (latitude != null) {
                    put("latitude", listOf(latitude.toString()))
                }
                if (longitude != null) {
                    put("longitude", listOf(longitude.toString()))
                }
                if (app != null) {
                    put("app", listOf(app.toString()))
                }
                if (gameType != null) {
                    put("gameType", listOf(gameType.toString()))
                }
                if (appKey != null) {
                    put("appKey", listOf(appKey.toString()))
                }
                if (returnProfile != null) {
                    put("returnProfile", listOf(returnProfile.toString()))
                }
                if (responseFilters != null) {
                    put("responseFilters", listOf(responseFilters.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/account/get",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /account/logout
     * Logout Account
     * Cleans up the users data for logging out.
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param deviceIdType Device Id Type (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param latitude The current latitude of the user (optional)
     * @param longitude The current longitude of the user (optional)
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun logout(deviceId: kotlin.String? = null, deviceIdType: kotlin.String? = null, accountId: kotlin.Long? = null, latitude: kotlin.Double? = null, longitude: kotlin.Double? = null) : SirqulResponse {
        val localVarResponse = logoutWithHttpInfo(deviceId = deviceId, deviceIdType = deviceIdType, accountId = accountId, latitude = latitude, longitude = longitude)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /account/logout
     * Logout Account
     * Cleans up the users data for logging out.
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param deviceIdType Device Id Type (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param latitude The current latitude of the user (optional)
     * @param longitude The current longitude of the user (optional)
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun logoutWithHttpInfo(deviceId: kotlin.String?, deviceIdType: kotlin.String?, accountId: kotlin.Long?, latitude: kotlin.Double?, longitude: kotlin.Double?) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = logoutRequestConfig(deviceId = deviceId, deviceIdType = deviceIdType, accountId = accountId, latitude = latitude, longitude = longitude)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation logout
     *
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param deviceIdType Device Id Type (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param latitude The current latitude of the user (optional)
     * @param longitude The current longitude of the user (optional)
     * @return RequestConfig
     */
    fun logoutRequestConfig(deviceId: kotlin.String?, deviceIdType: kotlin.String?, accountId: kotlin.Long?, latitude: kotlin.Double?, longitude: kotlin.Double?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (deviceIdType != null) {
                    put("deviceIdType", listOf(deviceIdType.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (latitude != null) {
                    put("latitude", listOf(latitude.toString()))
                }
                if (longitude != null) {
                    put("longitude", listOf(longitude.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/account/logout",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /account/merge
     * Merge Account
     * Merges the analytics, achievements, leaderboards of two accounts.
     * @param mergeAccountId The id of the account to being merged
     * @param appKey The application key
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun mergeAccount(mergeAccountId: kotlin.Long, appKey: kotlin.String, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null) : SirqulResponse {
        val localVarResponse = mergeAccountWithHttpInfo(mergeAccountId = mergeAccountId, appKey = appKey, deviceId = deviceId, accountId = accountId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /account/merge
     * Merge Account
     * Merges the analytics, achievements, leaderboards of two accounts.
     * @param mergeAccountId The id of the account to being merged
     * @param appKey The application key
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun mergeAccountWithHttpInfo(mergeAccountId: kotlin.Long, appKey: kotlin.String, deviceId: kotlin.String?, accountId: kotlin.Long?) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = mergeAccountRequestConfig(mergeAccountId = mergeAccountId, appKey = appKey, deviceId = deviceId, accountId = accountId)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation mergeAccount
     *
     * @param mergeAccountId The id of the account to being merged
     * @param appKey The application key
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @return RequestConfig
     */
    fun mergeAccountRequestConfig(mergeAccountId: kotlin.Long, appKey: kotlin.String, deviceId: kotlin.String?, accountId: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                put("mergeAccountId", listOf(mergeAccountId.toString()))
                put("appKey", listOf(appKey.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/account/merge",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /account/passwordchange
     * Update Password
     * Update the account password.
     * @param accountId The account to update
     * @param oldPassword The current password, used to validate access
     * @param newPassword The new password to set, cannot be empty
     * @param confirmPassword The new password to confirm, must match newPassword
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun passwordChange(accountId: kotlin.Long, oldPassword: kotlin.String, newPassword: kotlin.String, confirmPassword: kotlin.String) : SirqulResponse {
        val localVarResponse = passwordChangeWithHttpInfo(accountId = accountId, oldPassword = oldPassword, newPassword = newPassword, confirmPassword = confirmPassword)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /account/passwordchange
     * Update Password
     * Update the account password.
     * @param accountId The account to update
     * @param oldPassword The current password, used to validate access
     * @param newPassword The new password to set, cannot be empty
     * @param confirmPassword The new password to confirm, must match newPassword
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun passwordChangeWithHttpInfo(accountId: kotlin.Long, oldPassword: kotlin.String, newPassword: kotlin.String, confirmPassword: kotlin.String) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = passwordChangeRequestConfig(accountId = accountId, oldPassword = oldPassword, newPassword = newPassword, confirmPassword = confirmPassword)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation passwordChange
     *
     * @param accountId The account to update
     * @param oldPassword The current password, used to validate access
     * @param newPassword The new password to set, cannot be empty
     * @param confirmPassword The new password to confirm, must match newPassword
     * @return RequestConfig
     */
    fun passwordChangeRequestConfig(accountId: kotlin.Long, oldPassword: kotlin.String, newPassword: kotlin.String, confirmPassword: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("oldPassword", listOf(oldPassword.toString()))
                put("newPassword", listOf(newPassword.toString()))
                put("confirmPassword", listOf(confirmPassword.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/account/passwordchange",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /account/passwordreset
     * Reset Password
     * Reset the account password. The token must be valid and not expired. Use the RequestPasswordReset end point to request a token.
     * @param token The token associated with the account to update, good for 24 hours
     * @param password The new password to set, cannot be empty
     * @param confirm The new password to confirm, must match newPassword
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun passwordReset(token: kotlin.String, password: kotlin.String, confirm: kotlin.String) : SirqulResponse {
        val localVarResponse = passwordResetWithHttpInfo(token = token, password = password, confirm = confirm)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /account/passwordreset
     * Reset Password
     * Reset the account password. The token must be valid and not expired. Use the RequestPasswordReset end point to request a token.
     * @param token The token associated with the account to update, good for 24 hours
     * @param password The new password to set, cannot be empty
     * @param confirm The new password to confirm, must match newPassword
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun passwordResetWithHttpInfo(token: kotlin.String, password: kotlin.String, confirm: kotlin.String) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = passwordResetRequestConfig(token = token, password = password, confirm = confirm)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation passwordReset
     *
     * @param token The token associated with the account to update, good for 24 hours
     * @param password The new password to set, cannot be empty
     * @param confirm The new password to confirm, must match newPassword
     * @return RequestConfig
     */
    fun passwordResetRequestConfig(token: kotlin.String, password: kotlin.String, confirm: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("token", listOf(token.toString()))
                put("password", listOf(password.toString()))
                put("confirm", listOf(confirm.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/account/passwordreset",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /account/requestpasswordreset
     * Request Password Reset
     * Request that an account password be reset. The account is looked up by email address and then a link is sent via email to that account with a reset token. The token is valid for 24 hours.
     * @param email The email/username of the account
     * @param from this is the sender email (optional, default to "Sirqul")
     * @param domain this is the domain (like dev.sirqul.com) used to generate the password reset link (optional)
     * @param subUrl this is the the subUrl (like resetpassword) used to generate a password reset link (optional)
     * @param referer this is used to generate a password reset link (optional, default to "http://dev.sirqul.com/resetpassword")
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun requestPasswordReset(email: kotlin.String, from: kotlin.String? = "Sirqul", domain: kotlin.String? = null, subUrl: kotlin.String? = null, referer: kotlin.String? = "http://dev.sirqul.com/resetpassword") : SirqulResponse {
        val localVarResponse = requestPasswordResetWithHttpInfo(email = email, from = from, domain = domain, subUrl = subUrl, referer = referer)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /account/requestpasswordreset
     * Request Password Reset
     * Request that an account password be reset. The account is looked up by email address and then a link is sent via email to that account with a reset token. The token is valid for 24 hours.
     * @param email The email/username of the account
     * @param from this is the sender email (optional, default to "Sirqul")
     * @param domain this is the domain (like dev.sirqul.com) used to generate the password reset link (optional)
     * @param subUrl this is the the subUrl (like resetpassword) used to generate a password reset link (optional)
     * @param referer this is used to generate a password reset link (optional, default to "http://dev.sirqul.com/resetpassword")
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun requestPasswordResetWithHttpInfo(email: kotlin.String, from: kotlin.String?, domain: kotlin.String?, subUrl: kotlin.String?, referer: kotlin.String?) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = requestPasswordResetRequestConfig(email = email, from = from, domain = domain, subUrl = subUrl, referer = referer)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation requestPasswordReset
     *
     * @param email The email/username of the account
     * @param from this is the sender email (optional, default to "Sirqul")
     * @param domain this is the domain (like dev.sirqul.com) used to generate the password reset link (optional)
     * @param subUrl this is the the subUrl (like resetpassword) used to generate a password reset link (optional)
     * @param referer this is used to generate a password reset link (optional, default to "http://dev.sirqul.com/resetpassword")
     * @return RequestConfig
     */
    fun requestPasswordResetRequestConfig(email: kotlin.String, from: kotlin.String?, domain: kotlin.String?, subUrl: kotlin.String?, referer: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("email", listOf(email.toString()))
                if (from != null) {
                    put("from", listOf(from.toString()))
                }
                if (domain != null) {
                    put("domain", listOf(domain.toString()))
                }
                if (subUrl != null) {
                    put("subUrl", listOf(subUrl.toString()))
                }
                if (referer != null) {
                    put("referer", listOf(referer.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/account/requestpasswordreset",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /account/requestValidateAccount
     * Send Validation Request
     * Send an email to validate a user&#39;s account.
     * @param accountId The account id of the user
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun requestValidateAccount(accountId: kotlin.Long) : SirqulResponse {
        val localVarResponse = requestValidateAccountWithHttpInfo(accountId = accountId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /account/requestValidateAccount
     * Send Validation Request
     * Send an email to validate a user&#39;s account.
     * @param accountId The account id of the user
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun requestValidateAccountWithHttpInfo(accountId: kotlin.Long) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = requestValidateAccountRequestConfig(accountId = accountId)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation requestValidateAccount
     *
     * @param accountId The account id of the user
     * @return RequestConfig
     */
    fun requestValidateAccountRequestConfig(accountId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/account/requestValidateAccount",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter gender
     */
     enum class GenderSearchAccounts(val value: kotlin.String) {
         @Json(name = "MALE") MALE("MALE"),
         @Json(name = "FEMALE") FEMALE("FEMALE"),
         @Json(name = "ANY") ANY("ANY");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter gameExperience
     */
     enum class GameExperienceSearchAccounts(val value: kotlin.String) {
         @Json(name = "ANY") ANY("ANY"),
         @Json(name = "NEW") NEW("NEW"),
         @Json(name = "BEGINNER") BEGINNER("BEGINNER"),
         @Json(name = "INTERMEDIATE") INTERMEDIATE("INTERMEDIATE"),
         @Json(name = "EXPERT") EXPERT("EXPERT");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /account/profile/search
     * Search Accounts
     * Search for account profiles.
     * @param accountId The id of the account requesting
     * @param appKey The application key
     * @param keyword The keyword for for querying the account (optional)
     * @param latitude the latitude (optional)
     * @param longitude the longitude (optional)
     * @param radius the radius (optional, default to 5.0)
     * @param gender the user&#39;s gender (optional)
     * @param gameExperience the user&#39;s Game Experience (optional)
     * @param age the user&#39;s age (optional)
     * @param categoryIds the user&#39;s Category Ids (optional)
     * @param returnNulls Return Nulls (optional, default to true)
     * @param responseFilters A comma separated list of ProfileFilters for filtering the returned response data (optional, default to "PROFILE")
     * @param purchaseType A comma separated list of PurchaseType (optional, default to "SIRQUL")
     * @param sortField The field to sort by (optional, default to "id")
     * @param descending The order to return the results. Default is false, which will return the results in ascending order. (optional, default to false)
     * @param start The index into the record set to start with. (optional, default to 0)
     * @param limit The total number of record to return. (optional, default to 20)
     * @param activeOnly Determines whether to return only active results. Default is false. (optional, default to false)
     * @return kotlin.collections.List<ProfileResponse>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun searchAccounts(accountId: kotlin.Long, appKey: kotlin.String, keyword: kotlin.String? = null, latitude: kotlin.Double? = null, longitude: kotlin.Double? = null, radius: kotlin.Double? = 5.0, gender: GenderSearchAccounts? = null, gameExperience: GameExperienceSearchAccounts? = null, age: kotlin.Int? = null, categoryIds: kotlin.String? = null, returnNulls: kotlin.Boolean? = true, responseFilters: kotlin.String? = "PROFILE", purchaseType: kotlin.String? = "SIRQUL", sortField: kotlin.String? = "id", descending: kotlin.Boolean? = false, start: kotlin.Int? = 0, limit: kotlin.Int? = 20, activeOnly: kotlin.Boolean? = false) : kotlin.collections.List<ProfileResponse> {
        val localVarResponse = searchAccountsWithHttpInfo(accountId = accountId, appKey = appKey, keyword = keyword, latitude = latitude, longitude = longitude, radius = radius, gender = gender, gameExperience = gameExperience, age = age, categoryIds = categoryIds, returnNulls = returnNulls, responseFilters = responseFilters, purchaseType = purchaseType, sortField = sortField, descending = descending, start = start, limit = limit, activeOnly = activeOnly)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<ProfileResponse>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /account/profile/search
     * Search Accounts
     * Search for account profiles.
     * @param accountId The id of the account requesting
     * @param appKey The application key
     * @param keyword The keyword for for querying the account (optional)
     * @param latitude the latitude (optional)
     * @param longitude the longitude (optional)
     * @param radius the radius (optional, default to 5.0)
     * @param gender the user&#39;s gender (optional)
     * @param gameExperience the user&#39;s Game Experience (optional)
     * @param age the user&#39;s age (optional)
     * @param categoryIds the user&#39;s Category Ids (optional)
     * @param returnNulls Return Nulls (optional, default to true)
     * @param responseFilters A comma separated list of ProfileFilters for filtering the returned response data (optional, default to "PROFILE")
     * @param purchaseType A comma separated list of PurchaseType (optional, default to "SIRQUL")
     * @param sortField The field to sort by (optional, default to "id")
     * @param descending The order to return the results. Default is false, which will return the results in ascending order. (optional, default to false)
     * @param start The index into the record set to start with. (optional, default to 0)
     * @param limit The total number of record to return. (optional, default to 20)
     * @param activeOnly Determines whether to return only active results. Default is false. (optional, default to false)
     * @return ApiResponse<kotlin.collections.List<ProfileResponse>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun searchAccountsWithHttpInfo(accountId: kotlin.Long, appKey: kotlin.String, keyword: kotlin.String?, latitude: kotlin.Double?, longitude: kotlin.Double?, radius: kotlin.Double?, gender: GenderSearchAccounts?, gameExperience: GameExperienceSearchAccounts?, age: kotlin.Int?, categoryIds: kotlin.String?, returnNulls: kotlin.Boolean?, responseFilters: kotlin.String?, purchaseType: kotlin.String?, sortField: kotlin.String?, descending: kotlin.Boolean?, start: kotlin.Int?, limit: kotlin.Int?, activeOnly: kotlin.Boolean?) : ApiResponse<kotlin.collections.List<ProfileResponse>?> {
        val localVariableConfig = searchAccountsRequestConfig(accountId = accountId, appKey = appKey, keyword = keyword, latitude = latitude, longitude = longitude, radius = radius, gender = gender, gameExperience = gameExperience, age = age, categoryIds = categoryIds, returnNulls = returnNulls, responseFilters = responseFilters, purchaseType = purchaseType, sortField = sortField, descending = descending, start = start, limit = limit, activeOnly = activeOnly)

        return request<Unit, kotlin.collections.List<ProfileResponse>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation searchAccounts
     *
     * @param accountId The id of the account requesting
     * @param appKey The application key
     * @param keyword The keyword for for querying the account (optional)
     * @param latitude the latitude (optional)
     * @param longitude the longitude (optional)
     * @param radius the radius (optional, default to 5.0)
     * @param gender the user&#39;s gender (optional)
     * @param gameExperience the user&#39;s Game Experience (optional)
     * @param age the user&#39;s age (optional)
     * @param categoryIds the user&#39;s Category Ids (optional)
     * @param returnNulls Return Nulls (optional, default to true)
     * @param responseFilters A comma separated list of ProfileFilters for filtering the returned response data (optional, default to "PROFILE")
     * @param purchaseType A comma separated list of PurchaseType (optional, default to "SIRQUL")
     * @param sortField The field to sort by (optional, default to "id")
     * @param descending The order to return the results. Default is false, which will return the results in ascending order. (optional, default to false)
     * @param start The index into the record set to start with. (optional, default to 0)
     * @param limit The total number of record to return. (optional, default to 20)
     * @param activeOnly Determines whether to return only active results. Default is false. (optional, default to false)
     * @return RequestConfig
     */
    fun searchAccountsRequestConfig(accountId: kotlin.Long, appKey: kotlin.String, keyword: kotlin.String?, latitude: kotlin.Double?, longitude: kotlin.Double?, radius: kotlin.Double?, gender: GenderSearchAccounts?, gameExperience: GameExperienceSearchAccounts?, age: kotlin.Int?, categoryIds: kotlin.String?, returnNulls: kotlin.Boolean?, responseFilters: kotlin.String?, purchaseType: kotlin.String?, sortField: kotlin.String?, descending: kotlin.Boolean?, start: kotlin.Int?, limit: kotlin.Int?, activeOnly: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("appKey", listOf(appKey.toString()))
                if (keyword != null) {
                    put("keyword", listOf(keyword.toString()))
                }
                if (latitude != null) {
                    put("latitude", listOf(latitude.toString()))
                }
                if (longitude != null) {
                    put("longitude", listOf(longitude.toString()))
                }
                if (radius != null) {
                    put("radius", listOf(radius.toString()))
                }
                if (gender != null) {
                    put("gender", listOf(gender.value))
                }
                if (gameExperience != null) {
                    put("gameExperience", listOf(gameExperience.value))
                }
                if (age != null) {
                    put("age", listOf(age.toString()))
                }
                if (categoryIds != null) {
                    put("categoryIds", listOf(categoryIds.toString()))
                }
                if (returnNulls != null) {
                    put("returnNulls", listOf(returnNulls.toString()))
                }
                if (responseFilters != null) {
                    put("responseFilters", listOf(responseFilters.toString()))
                }
                if (purchaseType != null) {
                    put("purchaseType", listOf(purchaseType.toString()))
                }
                if (sortField != null) {
                    put("sortField", listOf(sortField.toString()))
                }
                if (descending != null) {
                    put("descending", listOf(descending.toString()))
                }
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (activeOnly != null) {
                    put("activeOnly", listOf(activeOnly.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/account/profile/search",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /account/login/validate
     * Login Account (Encrypted Username)
     * ogin with encrypted user-name and password.
     * @param username The user&#39;s encrypted email address they used to sign-up
     * @param password The encrypted password
     * @param gameType The application key
     * @param deviceId The device id (optional)
     * @param charsetName Charset Name (optional, default to "UTF-8")
     * @param latitude The current latitude of the user (optional)
     * @param longitude The current longitude of the user (optional)
     * @param returnProfile Return Profile (optional, default to false)
     * @param responseFilters A comma separated list of ProfileFilters for filtering the returned response data (optional, default to "PROFILE")
     * @return ProfileResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun secureLogin(username: kotlin.String, password: kotlin.String, gameType: kotlin.String, deviceId: kotlin.String? = null, charsetName: kotlin.String? = "UTF-8", latitude: kotlin.Double? = null, longitude: kotlin.Double? = null, returnProfile: kotlin.Boolean? = false, responseFilters: kotlin.String? = "PROFILE") : ProfileResponse {
        val localVarResponse = secureLoginWithHttpInfo(username = username, password = password, gameType = gameType, deviceId = deviceId, charsetName = charsetName, latitude = latitude, longitude = longitude, returnProfile = returnProfile, responseFilters = responseFilters)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ProfileResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /account/login/validate
     * Login Account (Encrypted Username)
     * ogin with encrypted user-name and password.
     * @param username The user&#39;s encrypted email address they used to sign-up
     * @param password The encrypted password
     * @param gameType The application key
     * @param deviceId The device id (optional)
     * @param charsetName Charset Name (optional, default to "UTF-8")
     * @param latitude The current latitude of the user (optional)
     * @param longitude The current longitude of the user (optional)
     * @param returnProfile Return Profile (optional, default to false)
     * @param responseFilters A comma separated list of ProfileFilters for filtering the returned response data (optional, default to "PROFILE")
     * @return ApiResponse<ProfileResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun secureLoginWithHttpInfo(username: kotlin.String, password: kotlin.String, gameType: kotlin.String, deviceId: kotlin.String?, charsetName: kotlin.String?, latitude: kotlin.Double?, longitude: kotlin.Double?, returnProfile: kotlin.Boolean?, responseFilters: kotlin.String?) : ApiResponse<ProfileResponse?> {
        val localVariableConfig = secureLoginRequestConfig(username = username, password = password, gameType = gameType, deviceId = deviceId, charsetName = charsetName, latitude = latitude, longitude = longitude, returnProfile = returnProfile, responseFilters = responseFilters)

        return request<Unit, ProfileResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation secureLogin
     *
     * @param username The user&#39;s encrypted email address they used to sign-up
     * @param password The encrypted password
     * @param gameType The application key
     * @param deviceId The device id (optional)
     * @param charsetName Charset Name (optional, default to "UTF-8")
     * @param latitude The current latitude of the user (optional)
     * @param longitude The current longitude of the user (optional)
     * @param returnProfile Return Profile (optional, default to false)
     * @param responseFilters A comma separated list of ProfileFilters for filtering the returned response data (optional, default to "PROFILE")
     * @return RequestConfig
     */
    fun secureLoginRequestConfig(username: kotlin.String, password: kotlin.String, gameType: kotlin.String, deviceId: kotlin.String?, charsetName: kotlin.String?, latitude: kotlin.Double?, longitude: kotlin.Double?, returnProfile: kotlin.Boolean?, responseFilters: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                put("username", listOf(username.toString()))
                put("password", listOf(password.toString()))
                put("gameType", listOf(gameType.toString()))
                if (charsetName != null) {
                    put("charsetName", listOf(charsetName.toString()))
                }
                if (latitude != null) {
                    put("latitude", listOf(latitude.toString()))
                }
                if (longitude != null) {
                    put("longitude", listOf(longitude.toString()))
                }
                if (returnProfile != null) {
                    put("returnProfile", listOf(returnProfile.toString()))
                }
                if (responseFilters != null) {
                    put("responseFilters", listOf(responseFilters.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/account/login/validate",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /account/create/validate
     * Create Account (Encrypted Username)
     * Create a new account by role (with encrypted user-name and password)
     * @param deviceId The device id
     * @param username The encrypted email of the user, this is what will be used when they login
     * @param password The encrypted password of the user
     * @param name The full name of the user. If this parameter is not empty, the  following parameters will be ignored: prefixName, firstName, middleName,  lastName, and suffixName  (optional)
     * @param inviteToken the inviteToken that the referrer use for this account to sign up (optional)
     * @param prefixName If the parameter &#39;name&#39; is empty or not present, this field will be used to set the prefix of the user&#39;s name (optional)
     * @param firstName If the parameter &#39;name&#39; is empty or not present, this field will be used to set the user&#39;s first name (optional)
     * @param middleName If the parameter &#39;name&#39; is empty or not present, this field will be used to set the user&#39;s middle name (optional)
     * @param lastName If the parameter &#39;name&#39; is empty or not present, this field will be used to set the user&#39;s last name (optional)
     * @param suffixName If the parameter &#39;name&#39; is empty or not present, this field will be used to set the suffix of the user&#39;s name (optional)
     * @param title Title (optional)
     * @param deviceIdType Device Id Type (optional)
     * @param emailAddress The user&#39;s contact email address (NOT the username) which is also used for email validation (optional)
     * @param assetId The asset id to set the user&#39;s profile image (optional)
     * @param address the user&#39;s address (optional)
     * @param zipcode The street zipcode of the user&#39;s contact location (optional)
     * @param gender The gender of the user AudienceGender (optional)
     * @param birthday The birthday date of the user in milliseconds (optional)
     * @param homePhone the user&#39;s home phone number (optional)
     * @param cellPhone the user&#39;s cell phone number (optional)
     * @param cellPhoneCarrier the user&#39;s Cell Phone Carrier (optional)
     * @param businessPhone the user&#39;s Business Phone Number (optional)
     * @param role The type of account being created {RETAILER, MEMBER, DEVELOPER, GUEST (optional, default to "MEMBER")
     * @param platforms Comma separated list of development platforms: MAC, WINDOWS, IOS, ANDROID, WINDOWSPHONE, KINDLE, UNITY3D, COCOS2D, HTML5, FACEBOOK (optional)
     * @param tags Search tags (optional)
     * @param aboutUs About Us information (optional)
     * @param gameExperience Game experience level of the user {ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT (optional)
     * @param categoryIds A list of category ids that represent interests and associations (optional)
     * @param hometown The user&#39;s hometown (optional)
     * @param height The user&#39;s height (optional)
     * @param heightIndex The user&#39;s height in a numerical value that can be used for ordering/searching (optional)
     * @param ethnicity The user&#39;s ethnicity (optional)
     * @param bodyType The user&#39;s body type (optional)
     * @param maritalStatus The user&#39;s maritial status (optional)
     * @param children The user&#39;s children status (optional)
     * @param religion The user&#39;s religion (optional)
     * @param education The user&#39;s education (optional)
     * @param educationIndex The user&#39;s education in a numerical value that can be used for ordering/searching (optional)
     * @param smoke The user&#39;s smoke status (optional)
     * @param drink The user&#39;s drink status (optional)
     * @param companionship The user&#39;s companionship status (optional)
     * @param companionshipIndex The user&#39;s companionship index (optional)
     * @param preferredMinAge The preferred minimum age in the account location search (optional)
     * @param preferredMaxAge The preferred maximum age in the account location search (optional)
     * @param preferredMinHeight The preferred minimum height in the account location search (optional)
     * @param preferredMaxHeight The preferred maximum height in the account location search (optional)
     * @param preferredGender The preferred gender in the account location search (optional)
     * @param preferredEducation The preferred education in the account location search (optional)
     * @param preferredEducationIndex The preferred education in a numerical value that can be used for ordering/searching (optional)
     * @param preferredBodyType The preferred body type in the account location search (optional)
     * @param preferredEthnicity The preferred ethnicity in the account location search (optional)
     * @param preferredLocation The preferred education in the account location search (optional)
     * @param preferredLocationRange The preferred location range in the account location search (optional)
     * @param latitude The current latitude of the user (optional)
     * @param longitude The current longitude of the user (optional)
     * @param acceptedTerms Accepted Terms (optional, default to true)
     * @param charsetName Charset Name (optional, default to "UTF-8")
     * @param gameType Game Type (optional)
     * @param appKey The application key (optional)
     * @param appVersion App Version (optional)
     * @param responseType Response Type (optional)
     * @return ProfileInfoResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun secureSignup(deviceId: kotlin.String, username: kotlin.String, password: kotlin.String, name: kotlin.String? = null, inviteToken: kotlin.String? = null, prefixName: kotlin.String? = null, firstName: kotlin.String? = null, middleName: kotlin.String? = null, lastName: kotlin.String? = null, suffixName: kotlin.String? = null, title: kotlin.String? = null, deviceIdType: kotlin.String? = null, emailAddress: kotlin.String? = null, assetId: kotlin.Long? = null, address: kotlin.String? = null, zipcode: kotlin.String? = null, gender: kotlin.String? = null, birthday: kotlin.Long? = null, homePhone: kotlin.String? = null, cellPhone: kotlin.String? = null, cellPhoneCarrier: kotlin.String? = null, businessPhone: kotlin.String? = null, role: kotlin.String? = "MEMBER", platforms: kotlin.String? = null, tags: kotlin.String? = null, aboutUs: kotlin.String? = null, gameExperience: kotlin.String? = null, categoryIds: kotlin.String? = null, hometown: kotlin.String? = null, height: kotlin.String? = null, heightIndex: kotlin.Int? = null, ethnicity: kotlin.String? = null, bodyType: kotlin.String? = null, maritalStatus: kotlin.String? = null, children: kotlin.String? = null, religion: kotlin.String? = null, education: kotlin.String? = null, educationIndex: kotlin.Int? = null, smoke: kotlin.String? = null, drink: kotlin.String? = null, companionship: kotlin.String? = null, companionshipIndex: kotlin.Int? = null, preferredMinAge: kotlin.Int? = null, preferredMaxAge: kotlin.Int? = null, preferredMinHeight: kotlin.Int? = null, preferredMaxHeight: kotlin.Int? = null, preferredGender: kotlin.String? = null, preferredEducation: kotlin.String? = null, preferredEducationIndex: kotlin.Int? = null, preferredBodyType: kotlin.String? = null, preferredEthnicity: kotlin.String? = null, preferredLocation: kotlin.String? = null, preferredLocationRange: kotlin.Double? = null, latitude: kotlin.Double? = null, longitude: kotlin.Double? = null, acceptedTerms: kotlin.Boolean? = true, charsetName: kotlin.String? = "UTF-8", gameType: kotlin.String? = null, appKey: kotlin.String? = null, appVersion: kotlin.String? = null, responseType: kotlin.String? = null) : ProfileInfoResponse {
        val localVarResponse = secureSignupWithHttpInfo(deviceId = deviceId, username = username, password = password, name = name, inviteToken = inviteToken, prefixName = prefixName, firstName = firstName, middleName = middleName, lastName = lastName, suffixName = suffixName, title = title, deviceIdType = deviceIdType, emailAddress = emailAddress, assetId = assetId, address = address, zipcode = zipcode, gender = gender, birthday = birthday, homePhone = homePhone, cellPhone = cellPhone, cellPhoneCarrier = cellPhoneCarrier, businessPhone = businessPhone, role = role, platforms = platforms, tags = tags, aboutUs = aboutUs, gameExperience = gameExperience, categoryIds = categoryIds, hometown = hometown, height = height, heightIndex = heightIndex, ethnicity = ethnicity, bodyType = bodyType, maritalStatus = maritalStatus, children = children, religion = religion, education = education, educationIndex = educationIndex, smoke = smoke, drink = drink, companionship = companionship, companionshipIndex = companionshipIndex, preferredMinAge = preferredMinAge, preferredMaxAge = preferredMaxAge, preferredMinHeight = preferredMinHeight, preferredMaxHeight = preferredMaxHeight, preferredGender = preferredGender, preferredEducation = preferredEducation, preferredEducationIndex = preferredEducationIndex, preferredBodyType = preferredBodyType, preferredEthnicity = preferredEthnicity, preferredLocation = preferredLocation, preferredLocationRange = preferredLocationRange, latitude = latitude, longitude = longitude, acceptedTerms = acceptedTerms, charsetName = charsetName, gameType = gameType, appKey = appKey, appVersion = appVersion, responseType = responseType)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ProfileInfoResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /account/create/validate
     * Create Account (Encrypted Username)
     * Create a new account by role (with encrypted user-name and password)
     * @param deviceId The device id
     * @param username The encrypted email of the user, this is what will be used when they login
     * @param password The encrypted password of the user
     * @param name The full name of the user. If this parameter is not empty, the  following parameters will be ignored: prefixName, firstName, middleName,  lastName, and suffixName  (optional)
     * @param inviteToken the inviteToken that the referrer use for this account to sign up (optional)
     * @param prefixName If the parameter &#39;name&#39; is empty or not present, this field will be used to set the prefix of the user&#39;s name (optional)
     * @param firstName If the parameter &#39;name&#39; is empty or not present, this field will be used to set the user&#39;s first name (optional)
     * @param middleName If the parameter &#39;name&#39; is empty or not present, this field will be used to set the user&#39;s middle name (optional)
     * @param lastName If the parameter &#39;name&#39; is empty or not present, this field will be used to set the user&#39;s last name (optional)
     * @param suffixName If the parameter &#39;name&#39; is empty or not present, this field will be used to set the suffix of the user&#39;s name (optional)
     * @param title Title (optional)
     * @param deviceIdType Device Id Type (optional)
     * @param emailAddress The user&#39;s contact email address (NOT the username) which is also used for email validation (optional)
     * @param assetId The asset id to set the user&#39;s profile image (optional)
     * @param address the user&#39;s address (optional)
     * @param zipcode The street zipcode of the user&#39;s contact location (optional)
     * @param gender The gender of the user AudienceGender (optional)
     * @param birthday The birthday date of the user in milliseconds (optional)
     * @param homePhone the user&#39;s home phone number (optional)
     * @param cellPhone the user&#39;s cell phone number (optional)
     * @param cellPhoneCarrier the user&#39;s Cell Phone Carrier (optional)
     * @param businessPhone the user&#39;s Business Phone Number (optional)
     * @param role The type of account being created {RETAILER, MEMBER, DEVELOPER, GUEST (optional, default to "MEMBER")
     * @param platforms Comma separated list of development platforms: MAC, WINDOWS, IOS, ANDROID, WINDOWSPHONE, KINDLE, UNITY3D, COCOS2D, HTML5, FACEBOOK (optional)
     * @param tags Search tags (optional)
     * @param aboutUs About Us information (optional)
     * @param gameExperience Game experience level of the user {ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT (optional)
     * @param categoryIds A list of category ids that represent interests and associations (optional)
     * @param hometown The user&#39;s hometown (optional)
     * @param height The user&#39;s height (optional)
     * @param heightIndex The user&#39;s height in a numerical value that can be used for ordering/searching (optional)
     * @param ethnicity The user&#39;s ethnicity (optional)
     * @param bodyType The user&#39;s body type (optional)
     * @param maritalStatus The user&#39;s maritial status (optional)
     * @param children The user&#39;s children status (optional)
     * @param religion The user&#39;s religion (optional)
     * @param education The user&#39;s education (optional)
     * @param educationIndex The user&#39;s education in a numerical value that can be used for ordering/searching (optional)
     * @param smoke The user&#39;s smoke status (optional)
     * @param drink The user&#39;s drink status (optional)
     * @param companionship The user&#39;s companionship status (optional)
     * @param companionshipIndex The user&#39;s companionship index (optional)
     * @param preferredMinAge The preferred minimum age in the account location search (optional)
     * @param preferredMaxAge The preferred maximum age in the account location search (optional)
     * @param preferredMinHeight The preferred minimum height in the account location search (optional)
     * @param preferredMaxHeight The preferred maximum height in the account location search (optional)
     * @param preferredGender The preferred gender in the account location search (optional)
     * @param preferredEducation The preferred education in the account location search (optional)
     * @param preferredEducationIndex The preferred education in a numerical value that can be used for ordering/searching (optional)
     * @param preferredBodyType The preferred body type in the account location search (optional)
     * @param preferredEthnicity The preferred ethnicity in the account location search (optional)
     * @param preferredLocation The preferred education in the account location search (optional)
     * @param preferredLocationRange The preferred location range in the account location search (optional)
     * @param latitude The current latitude of the user (optional)
     * @param longitude The current longitude of the user (optional)
     * @param acceptedTerms Accepted Terms (optional, default to true)
     * @param charsetName Charset Name (optional, default to "UTF-8")
     * @param gameType Game Type (optional)
     * @param appKey The application key (optional)
     * @param appVersion App Version (optional)
     * @param responseType Response Type (optional)
     * @return ApiResponse<ProfileInfoResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun secureSignupWithHttpInfo(deviceId: kotlin.String, username: kotlin.String, password: kotlin.String, name: kotlin.String?, inviteToken: kotlin.String?, prefixName: kotlin.String?, firstName: kotlin.String?, middleName: kotlin.String?, lastName: kotlin.String?, suffixName: kotlin.String?, title: kotlin.String?, deviceIdType: kotlin.String?, emailAddress: kotlin.String?, assetId: kotlin.Long?, address: kotlin.String?, zipcode: kotlin.String?, gender: kotlin.String?, birthday: kotlin.Long?, homePhone: kotlin.String?, cellPhone: kotlin.String?, cellPhoneCarrier: kotlin.String?, businessPhone: kotlin.String?, role: kotlin.String?, platforms: kotlin.String?, tags: kotlin.String?, aboutUs: kotlin.String?, gameExperience: kotlin.String?, categoryIds: kotlin.String?, hometown: kotlin.String?, height: kotlin.String?, heightIndex: kotlin.Int?, ethnicity: kotlin.String?, bodyType: kotlin.String?, maritalStatus: kotlin.String?, children: kotlin.String?, religion: kotlin.String?, education: kotlin.String?, educationIndex: kotlin.Int?, smoke: kotlin.String?, drink: kotlin.String?, companionship: kotlin.String?, companionshipIndex: kotlin.Int?, preferredMinAge: kotlin.Int?, preferredMaxAge: kotlin.Int?, preferredMinHeight: kotlin.Int?, preferredMaxHeight: kotlin.Int?, preferredGender: kotlin.String?, preferredEducation: kotlin.String?, preferredEducationIndex: kotlin.Int?, preferredBodyType: kotlin.String?, preferredEthnicity: kotlin.String?, preferredLocation: kotlin.String?, preferredLocationRange: kotlin.Double?, latitude: kotlin.Double?, longitude: kotlin.Double?, acceptedTerms: kotlin.Boolean?, charsetName: kotlin.String?, gameType: kotlin.String?, appKey: kotlin.String?, appVersion: kotlin.String?, responseType: kotlin.String?) : ApiResponse<ProfileInfoResponse?> {
        val localVariableConfig = secureSignupRequestConfig(deviceId = deviceId, username = username, password = password, name = name, inviteToken = inviteToken, prefixName = prefixName, firstName = firstName, middleName = middleName, lastName = lastName, suffixName = suffixName, title = title, deviceIdType = deviceIdType, emailAddress = emailAddress, assetId = assetId, address = address, zipcode = zipcode, gender = gender, birthday = birthday, homePhone = homePhone, cellPhone = cellPhone, cellPhoneCarrier = cellPhoneCarrier, businessPhone = businessPhone, role = role, platforms = platforms, tags = tags, aboutUs = aboutUs, gameExperience = gameExperience, categoryIds = categoryIds, hometown = hometown, height = height, heightIndex = heightIndex, ethnicity = ethnicity, bodyType = bodyType, maritalStatus = maritalStatus, children = children, religion = religion, education = education, educationIndex = educationIndex, smoke = smoke, drink = drink, companionship = companionship, companionshipIndex = companionshipIndex, preferredMinAge = preferredMinAge, preferredMaxAge = preferredMaxAge, preferredMinHeight = preferredMinHeight, preferredMaxHeight = preferredMaxHeight, preferredGender = preferredGender, preferredEducation = preferredEducation, preferredEducationIndex = preferredEducationIndex, preferredBodyType = preferredBodyType, preferredEthnicity = preferredEthnicity, preferredLocation = preferredLocation, preferredLocationRange = preferredLocationRange, latitude = latitude, longitude = longitude, acceptedTerms = acceptedTerms, charsetName = charsetName, gameType = gameType, appKey = appKey, appVersion = appVersion, responseType = responseType)

        return request<Unit, ProfileInfoResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation secureSignup
     *
     * @param deviceId The device id
     * @param username The encrypted email of the user, this is what will be used when they login
     * @param password The encrypted password of the user
     * @param name The full name of the user. If this parameter is not empty, the  following parameters will be ignored: prefixName, firstName, middleName,  lastName, and suffixName  (optional)
     * @param inviteToken the inviteToken that the referrer use for this account to sign up (optional)
     * @param prefixName If the parameter &#39;name&#39; is empty or not present, this field will be used to set the prefix of the user&#39;s name (optional)
     * @param firstName If the parameter &#39;name&#39; is empty or not present, this field will be used to set the user&#39;s first name (optional)
     * @param middleName If the parameter &#39;name&#39; is empty or not present, this field will be used to set the user&#39;s middle name (optional)
     * @param lastName If the parameter &#39;name&#39; is empty or not present, this field will be used to set the user&#39;s last name (optional)
     * @param suffixName If the parameter &#39;name&#39; is empty or not present, this field will be used to set the suffix of the user&#39;s name (optional)
     * @param title Title (optional)
     * @param deviceIdType Device Id Type (optional)
     * @param emailAddress The user&#39;s contact email address (NOT the username) which is also used for email validation (optional)
     * @param assetId The asset id to set the user&#39;s profile image (optional)
     * @param address the user&#39;s address (optional)
     * @param zipcode The street zipcode of the user&#39;s contact location (optional)
     * @param gender The gender of the user AudienceGender (optional)
     * @param birthday The birthday date of the user in milliseconds (optional)
     * @param homePhone the user&#39;s home phone number (optional)
     * @param cellPhone the user&#39;s cell phone number (optional)
     * @param cellPhoneCarrier the user&#39;s Cell Phone Carrier (optional)
     * @param businessPhone the user&#39;s Business Phone Number (optional)
     * @param role The type of account being created {RETAILER, MEMBER, DEVELOPER, GUEST (optional, default to "MEMBER")
     * @param platforms Comma separated list of development platforms: MAC, WINDOWS, IOS, ANDROID, WINDOWSPHONE, KINDLE, UNITY3D, COCOS2D, HTML5, FACEBOOK (optional)
     * @param tags Search tags (optional)
     * @param aboutUs About Us information (optional)
     * @param gameExperience Game experience level of the user {ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT (optional)
     * @param categoryIds A list of category ids that represent interests and associations (optional)
     * @param hometown The user&#39;s hometown (optional)
     * @param height The user&#39;s height (optional)
     * @param heightIndex The user&#39;s height in a numerical value that can be used for ordering/searching (optional)
     * @param ethnicity The user&#39;s ethnicity (optional)
     * @param bodyType The user&#39;s body type (optional)
     * @param maritalStatus The user&#39;s maritial status (optional)
     * @param children The user&#39;s children status (optional)
     * @param religion The user&#39;s religion (optional)
     * @param education The user&#39;s education (optional)
     * @param educationIndex The user&#39;s education in a numerical value that can be used for ordering/searching (optional)
     * @param smoke The user&#39;s smoke status (optional)
     * @param drink The user&#39;s drink status (optional)
     * @param companionship The user&#39;s companionship status (optional)
     * @param companionshipIndex The user&#39;s companionship index (optional)
     * @param preferredMinAge The preferred minimum age in the account location search (optional)
     * @param preferredMaxAge The preferred maximum age in the account location search (optional)
     * @param preferredMinHeight The preferred minimum height in the account location search (optional)
     * @param preferredMaxHeight The preferred maximum height in the account location search (optional)
     * @param preferredGender The preferred gender in the account location search (optional)
     * @param preferredEducation The preferred education in the account location search (optional)
     * @param preferredEducationIndex The preferred education in a numerical value that can be used for ordering/searching (optional)
     * @param preferredBodyType The preferred body type in the account location search (optional)
     * @param preferredEthnicity The preferred ethnicity in the account location search (optional)
     * @param preferredLocation The preferred education in the account location search (optional)
     * @param preferredLocationRange The preferred location range in the account location search (optional)
     * @param latitude The current latitude of the user (optional)
     * @param longitude The current longitude of the user (optional)
     * @param acceptedTerms Accepted Terms (optional, default to true)
     * @param charsetName Charset Name (optional, default to "UTF-8")
     * @param gameType Game Type (optional)
     * @param appKey The application key (optional)
     * @param appVersion App Version (optional)
     * @param responseType Response Type (optional)
     * @return RequestConfig
     */
    fun secureSignupRequestConfig(deviceId: kotlin.String, username: kotlin.String, password: kotlin.String, name: kotlin.String?, inviteToken: kotlin.String?, prefixName: kotlin.String?, firstName: kotlin.String?, middleName: kotlin.String?, lastName: kotlin.String?, suffixName: kotlin.String?, title: kotlin.String?, deviceIdType: kotlin.String?, emailAddress: kotlin.String?, assetId: kotlin.Long?, address: kotlin.String?, zipcode: kotlin.String?, gender: kotlin.String?, birthday: kotlin.Long?, homePhone: kotlin.String?, cellPhone: kotlin.String?, cellPhoneCarrier: kotlin.String?, businessPhone: kotlin.String?, role: kotlin.String?, platforms: kotlin.String?, tags: kotlin.String?, aboutUs: kotlin.String?, gameExperience: kotlin.String?, categoryIds: kotlin.String?, hometown: kotlin.String?, height: kotlin.String?, heightIndex: kotlin.Int?, ethnicity: kotlin.String?, bodyType: kotlin.String?, maritalStatus: kotlin.String?, children: kotlin.String?, religion: kotlin.String?, education: kotlin.String?, educationIndex: kotlin.Int?, smoke: kotlin.String?, drink: kotlin.String?, companionship: kotlin.String?, companionshipIndex: kotlin.Int?, preferredMinAge: kotlin.Int?, preferredMaxAge: kotlin.Int?, preferredMinHeight: kotlin.Int?, preferredMaxHeight: kotlin.Int?, preferredGender: kotlin.String?, preferredEducation: kotlin.String?, preferredEducationIndex: kotlin.Int?, preferredBodyType: kotlin.String?, preferredEthnicity: kotlin.String?, preferredLocation: kotlin.String?, preferredLocationRange: kotlin.Double?, latitude: kotlin.Double?, longitude: kotlin.Double?, acceptedTerms: kotlin.Boolean?, charsetName: kotlin.String?, gameType: kotlin.String?, appKey: kotlin.String?, appVersion: kotlin.String?, responseType: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (inviteToken != null) {
                    put("inviteToken", listOf(inviteToken.toString()))
                }
                if (prefixName != null) {
                    put("prefixName", listOf(prefixName.toString()))
                }
                if (firstName != null) {
                    put("firstName", listOf(firstName.toString()))
                }
                if (middleName != null) {
                    put("middleName", listOf(middleName.toString()))
                }
                if (lastName != null) {
                    put("lastName", listOf(lastName.toString()))
                }
                if (suffixName != null) {
                    put("suffixName", listOf(suffixName.toString()))
                }
                if (title != null) {
                    put("title", listOf(title.toString()))
                }
                put("deviceId", listOf(deviceId.toString()))
                if (deviceIdType != null) {
                    put("deviceIdType", listOf(deviceIdType.toString()))
                }
                put("username", listOf(username.toString()))
                put("password", listOf(password.toString()))
                if (emailAddress != null) {
                    put("emailAddress", listOf(emailAddress.toString()))
                }
                if (assetId != null) {
                    put("assetId", listOf(assetId.toString()))
                }
                if (address != null) {
                    put("address", listOf(address.toString()))
                }
                if (zipcode != null) {
                    put("zipcode", listOf(zipcode.toString()))
                }
                if (gender != null) {
                    put("gender", listOf(gender.toString()))
                }
                if (birthday != null) {
                    put("birthday", listOf(birthday.toString()))
                }
                if (homePhone != null) {
                    put("homePhone", listOf(homePhone.toString()))
                }
                if (cellPhone != null) {
                    put("cellPhone", listOf(cellPhone.toString()))
                }
                if (cellPhoneCarrier != null) {
                    put("cellPhoneCarrier", listOf(cellPhoneCarrier.toString()))
                }
                if (businessPhone != null) {
                    put("businessPhone", listOf(businessPhone.toString()))
                }
                if (role != null) {
                    put("role", listOf(role.toString()))
                }
                if (platforms != null) {
                    put("platforms", listOf(platforms.toString()))
                }
                if (tags != null) {
                    put("tags", listOf(tags.toString()))
                }
                if (aboutUs != null) {
                    put("aboutUs", listOf(aboutUs.toString()))
                }
                if (gameExperience != null) {
                    put("gameExperience", listOf(gameExperience.toString()))
                }
                if (categoryIds != null) {
                    put("categoryIds", listOf(categoryIds.toString()))
                }
                if (hometown != null) {
                    put("hometown", listOf(hometown.toString()))
                }
                if (height != null) {
                    put("height", listOf(height.toString()))
                }
                if (heightIndex != null) {
                    put("heightIndex", listOf(heightIndex.toString()))
                }
                if (ethnicity != null) {
                    put("ethnicity", listOf(ethnicity.toString()))
                }
                if (bodyType != null) {
                    put("bodyType", listOf(bodyType.toString()))
                }
                if (maritalStatus != null) {
                    put("maritalStatus", listOf(maritalStatus.toString()))
                }
                if (children != null) {
                    put("children", listOf(children.toString()))
                }
                if (religion != null) {
                    put("religion", listOf(religion.toString()))
                }
                if (education != null) {
                    put("education", listOf(education.toString()))
                }
                if (educationIndex != null) {
                    put("educationIndex", listOf(educationIndex.toString()))
                }
                if (smoke != null) {
                    put("smoke", listOf(smoke.toString()))
                }
                if (drink != null) {
                    put("drink", listOf(drink.toString()))
                }
                if (companionship != null) {
                    put("companionship", listOf(companionship.toString()))
                }
                if (companionshipIndex != null) {
                    put("companionshipIndex", listOf(companionshipIndex.toString()))
                }
                if (preferredMinAge != null) {
                    put("preferredMinAge", listOf(preferredMinAge.toString()))
                }
                if (preferredMaxAge != null) {
                    put("preferredMaxAge", listOf(preferredMaxAge.toString()))
                }
                if (preferredMinHeight != null) {
                    put("preferredMinHeight", listOf(preferredMinHeight.toString()))
                }
                if (preferredMaxHeight != null) {
                    put("preferredMaxHeight", listOf(preferredMaxHeight.toString()))
                }
                if (preferredGender != null) {
                    put("preferredGender", listOf(preferredGender.toString()))
                }
                if (preferredEducation != null) {
                    put("preferredEducation", listOf(preferredEducation.toString()))
                }
                if (preferredEducationIndex != null) {
                    put("preferredEducationIndex", listOf(preferredEducationIndex.toString()))
                }
                if (preferredBodyType != null) {
                    put("preferredBodyType", listOf(preferredBodyType.toString()))
                }
                if (preferredEthnicity != null) {
                    put("preferredEthnicity", listOf(preferredEthnicity.toString()))
                }
                if (preferredLocation != null) {
                    put("preferredLocation", listOf(preferredLocation.toString()))
                }
                if (preferredLocationRange != null) {
                    put("preferredLocationRange", listOf(preferredLocationRange.toString()))
                }
                if (latitude != null) {
                    put("latitude", listOf(latitude.toString()))
                }
                if (longitude != null) {
                    put("longitude", listOf(longitude.toString()))
                }
                if (acceptedTerms != null) {
                    put("acceptedTerms", listOf(acceptedTerms.toString()))
                }
                if (charsetName != null) {
                    put("charsetName", listOf(charsetName.toString()))
                }
                if (gameType != null) {
                    put("gameType", listOf(gameType.toString()))
                }
                if (appKey != null) {
                    put("appKey", listOf(appKey.toString()))
                }
                if (appVersion != null) {
                    put("appVersion", listOf(appVersion.toString()))
                }
                if (responseType != null) {
                    put("responseType", listOf(responseType.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/account/create/validate",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /consumer/profile/matchToken
     * Save Match Token
     * Save user&#39;s match token to be used for profile match making
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param matchToken A string of numbers (optional)
     * @param gameType Game Type (deprecated) (optional, default to "BOOPY")
     * @param appKey The application key (optional)
     * @param latitude The current latitude of the user (optional)
     * @param longitude The current longitude of the user (optional)
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun setMatchToken(deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, matchToken: kotlin.String? = null, gameType: kotlin.String? = "BOOPY", appKey: kotlin.String? = null, latitude: kotlin.Double? = null, longitude: kotlin.Double? = null) : SirqulResponse {
        val localVarResponse = setMatchTokenWithHttpInfo(deviceId = deviceId, accountId = accountId, matchToken = matchToken, gameType = gameType, appKey = appKey, latitude = latitude, longitude = longitude)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /consumer/profile/matchToken
     * Save Match Token
     * Save user&#39;s match token to be used for profile match making
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param matchToken A string of numbers (optional)
     * @param gameType Game Type (deprecated) (optional, default to "BOOPY")
     * @param appKey The application key (optional)
     * @param latitude The current latitude of the user (optional)
     * @param longitude The current longitude of the user (optional)
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun setMatchTokenWithHttpInfo(deviceId: kotlin.String?, accountId: kotlin.Long?, matchToken: kotlin.String?, gameType: kotlin.String?, appKey: kotlin.String?, latitude: kotlin.Double?, longitude: kotlin.Double?) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = setMatchTokenRequestConfig(deviceId = deviceId, accountId = accountId, matchToken = matchToken, gameType = gameType, appKey = appKey, latitude = latitude, longitude = longitude)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation setMatchToken
     *
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param matchToken A string of numbers (optional)
     * @param gameType Game Type (deprecated) (optional, default to "BOOPY")
     * @param appKey The application key (optional)
     * @param latitude The current latitude of the user (optional)
     * @param longitude The current longitude of the user (optional)
     * @return RequestConfig
     */
    fun setMatchTokenRequestConfig(deviceId: kotlin.String?, accountId: kotlin.Long?, matchToken: kotlin.String?, gameType: kotlin.String?, appKey: kotlin.String?, latitude: kotlin.Double?, longitude: kotlin.Double?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (matchToken != null) {
                    put("matchToken", listOf(matchToken.toString()))
                }
                if (gameType != null) {
                    put("gameType", listOf(gameType.toString()))
                }
                if (appKey != null) {
                    put("appKey", listOf(appKey.toString()))
                }
                if (latitude != null) {
                    put("latitude", listOf(latitude.toString()))
                }
                if (longitude != null) {
                    put("longitude", listOf(longitude.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/consumer/profile/matchToken",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /account/active/update
     * Update Account Active Status
     * Activate or deactivate an account (requires appropriate permissions).
     * @param accountId the account id of the user (deviceId or accountId required)
     * @param connectionAccountId The account id of the user you want to modify (if this is not set, then the accountId parameter will be used instead)
     * @param active true will activate the user and false will deactivate
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param appKey the application key that the user belongs to (optional)
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updateActveStatus(accountId: kotlin.Long, connectionAccountId: kotlin.Long, active: kotlin.Boolean, deviceId: kotlin.String? = null, appKey: kotlin.String? = null) : SirqulResponse {
        val localVarResponse = updateActveStatusWithHttpInfo(accountId = accountId, connectionAccountId = connectionAccountId, active = active, deviceId = deviceId, appKey = appKey)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /account/active/update
     * Update Account Active Status
     * Activate or deactivate an account (requires appropriate permissions).
     * @param accountId the account id of the user (deviceId or accountId required)
     * @param connectionAccountId The account id of the user you want to modify (if this is not set, then the accountId parameter will be used instead)
     * @param active true will activate the user and false will deactivate
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param appKey the application key that the user belongs to (optional)
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun updateActveStatusWithHttpInfo(accountId: kotlin.Long, connectionAccountId: kotlin.Long, active: kotlin.Boolean, deviceId: kotlin.String?, appKey: kotlin.String?) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = updateActveStatusRequestConfig(accountId = accountId, connectionAccountId = connectionAccountId, active = active, deviceId = deviceId, appKey = appKey)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateActveStatus
     *
     * @param accountId the account id of the user (deviceId or accountId required)
     * @param connectionAccountId The account id of the user you want to modify (if this is not set, then the accountId parameter will be used instead)
     * @param active true will activate the user and false will deactivate
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param appKey the application key that the user belongs to (optional)
     * @return RequestConfig
     */
    fun updateActveStatusRequestConfig(accountId: kotlin.Long, connectionAccountId: kotlin.Long, active: kotlin.Boolean, deviceId: kotlin.String?, appKey: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                put("accountId", listOf(accountId.toString()))
                put("connectionAccountId", listOf(connectionAccountId.toString()))
                if (appKey != null) {
                    put("appKey", listOf(appKey.toString()))
                }
                put("active", listOf(active.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/account/active/update",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /account/location/update
     * Update Location
     * Update the account location
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param latitude The current latitude of the user (optional)
     * @param longitude The current longitude of the user (optional)
     * @param clientTime The time of the update (optional)
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updateLocation(deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, latitude: kotlin.Double? = null, longitude: kotlin.Double? = null, clientTime: kotlin.Long? = null) : SirqulResponse {
        val localVarResponse = updateLocationWithHttpInfo(deviceId = deviceId, accountId = accountId, latitude = latitude, longitude = longitude, clientTime = clientTime)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /account/location/update
     * Update Location
     * Update the account location
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param latitude The current latitude of the user (optional)
     * @param longitude The current longitude of the user (optional)
     * @param clientTime The time of the update (optional)
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun updateLocationWithHttpInfo(deviceId: kotlin.String?, accountId: kotlin.Long?, latitude: kotlin.Double?, longitude: kotlin.Double?, clientTime: kotlin.Long?) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = updateLocationRequestConfig(deviceId = deviceId, accountId = accountId, latitude = latitude, longitude = longitude, clientTime = clientTime)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateLocation
     *
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param latitude The current latitude of the user (optional)
     * @param longitude The current longitude of the user (optional)
     * @param clientTime The time of the update (optional)
     * @return RequestConfig
     */
    fun updateLocationRequestConfig(deviceId: kotlin.String?, accountId: kotlin.Long?, latitude: kotlin.Double?, longitude: kotlin.Double?, clientTime: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (latitude != null) {
                    put("latitude", listOf(latitude.toString()))
                }
                if (longitude != null) {
                    put("longitude", listOf(longitude.toString()))
                }
                if (clientTime != null) {
                    put("clientTime", listOf(clientTime.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/account/location/update",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /account/settings/update
     * Update Account Settings
     * Update the account settings for a user
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param blockedNotifications The notifications to be blocked (optional)
     * @param suggestionMethod How suggestions are to be sent (APNS, MOBILE_NOTIFICATION, SMS) (optional)
     * @param suggestionCount How many suggestions to receive per time frame (optional)
     * @param suggestionTimeFrame The time frame in seconds, 3600 would be a 1 hour time frame (optional)
     * @param showOthersExactLocation Show Others Exact Location (optional)
     * @param showAsZipcode Show As Zipcode (optional)
     * @param showExactLocation Show Exact Location (optional)
     * @param favoriteVisibility Show favorites (optional)
     * @param latitude The current latitude of the user (optional)
     * @param longitude The current longitude of the user (optional)
     * @return UserSettingsResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updateSettings(deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, blockedNotifications: kotlin.String? = null, suggestionMethod: kotlin.String? = null, suggestionCount: kotlin.Int? = null, suggestionTimeFrame: kotlin.Int? = null, showOthersExactLocation: kotlin.Boolean? = null, showAsZipcode: kotlin.Boolean? = null, showExactLocation: kotlin.Boolean? = null, favoriteVisibility: kotlin.String? = null, latitude: kotlin.Double? = null, longitude: kotlin.Double? = null) : UserSettingsResponse {
        val localVarResponse = updateSettingsWithHttpInfo(deviceId = deviceId, accountId = accountId, blockedNotifications = blockedNotifications, suggestionMethod = suggestionMethod, suggestionCount = suggestionCount, suggestionTimeFrame = suggestionTimeFrame, showOthersExactLocation = showOthersExactLocation, showAsZipcode = showAsZipcode, showExactLocation = showExactLocation, favoriteVisibility = favoriteVisibility, latitude = latitude, longitude = longitude)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UserSettingsResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /account/settings/update
     * Update Account Settings
     * Update the account settings for a user
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param blockedNotifications The notifications to be blocked (optional)
     * @param suggestionMethod How suggestions are to be sent (APNS, MOBILE_NOTIFICATION, SMS) (optional)
     * @param suggestionCount How many suggestions to receive per time frame (optional)
     * @param suggestionTimeFrame The time frame in seconds, 3600 would be a 1 hour time frame (optional)
     * @param showOthersExactLocation Show Others Exact Location (optional)
     * @param showAsZipcode Show As Zipcode (optional)
     * @param showExactLocation Show Exact Location (optional)
     * @param favoriteVisibility Show favorites (optional)
     * @param latitude The current latitude of the user (optional)
     * @param longitude The current longitude of the user (optional)
     * @return ApiResponse<UserSettingsResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun updateSettingsWithHttpInfo(deviceId: kotlin.String?, accountId: kotlin.Long?, blockedNotifications: kotlin.String?, suggestionMethod: kotlin.String?, suggestionCount: kotlin.Int?, suggestionTimeFrame: kotlin.Int?, showOthersExactLocation: kotlin.Boolean?, showAsZipcode: kotlin.Boolean?, showExactLocation: kotlin.Boolean?, favoriteVisibility: kotlin.String?, latitude: kotlin.Double?, longitude: kotlin.Double?) : ApiResponse<UserSettingsResponse?> {
        val localVariableConfig = updateSettingsRequestConfig(deviceId = deviceId, accountId = accountId, blockedNotifications = blockedNotifications, suggestionMethod = suggestionMethod, suggestionCount = suggestionCount, suggestionTimeFrame = suggestionTimeFrame, showOthersExactLocation = showOthersExactLocation, showAsZipcode = showAsZipcode, showExactLocation = showExactLocation, favoriteVisibility = favoriteVisibility, latitude = latitude, longitude = longitude)

        return request<Unit, UserSettingsResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateSettings
     *
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param blockedNotifications The notifications to be blocked (optional)
     * @param suggestionMethod How suggestions are to be sent (APNS, MOBILE_NOTIFICATION, SMS) (optional)
     * @param suggestionCount How many suggestions to receive per time frame (optional)
     * @param suggestionTimeFrame The time frame in seconds, 3600 would be a 1 hour time frame (optional)
     * @param showOthersExactLocation Show Others Exact Location (optional)
     * @param showAsZipcode Show As Zipcode (optional)
     * @param showExactLocation Show Exact Location (optional)
     * @param favoriteVisibility Show favorites (optional)
     * @param latitude The current latitude of the user (optional)
     * @param longitude The current longitude of the user (optional)
     * @return RequestConfig
     */
    fun updateSettingsRequestConfig(deviceId: kotlin.String?, accountId: kotlin.Long?, blockedNotifications: kotlin.String?, suggestionMethod: kotlin.String?, suggestionCount: kotlin.Int?, suggestionTimeFrame: kotlin.Int?, showOthersExactLocation: kotlin.Boolean?, showAsZipcode: kotlin.Boolean?, showExactLocation: kotlin.Boolean?, favoriteVisibility: kotlin.String?, latitude: kotlin.Double?, longitude: kotlin.Double?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (blockedNotifications != null) {
                    put("blockedNotifications", listOf(blockedNotifications.toString()))
                }
                if (suggestionMethod != null) {
                    put("suggestionMethod", listOf(suggestionMethod.toString()))
                }
                if (suggestionCount != null) {
                    put("suggestionCount", listOf(suggestionCount.toString()))
                }
                if (suggestionTimeFrame != null) {
                    put("suggestionTimeFrame", listOf(suggestionTimeFrame.toString()))
                }
                if (showOthersExactLocation != null) {
                    put("showOthersExactLocation", listOf(showOthersExactLocation.toString()))
                }
                if (showAsZipcode != null) {
                    put("showAsZipcode", listOf(showAsZipcode.toString()))
                }
                if (showExactLocation != null) {
                    put("showExactLocation", listOf(showExactLocation.toString()))
                }
                if (favoriteVisibility != null) {
                    put("favoriteVisibility", listOf(favoriteVisibility.toString()))
                }
                if (latitude != null) {
                    put("latitude", listOf(latitude.toString()))
                }
                if (longitude != null) {
                    put("longitude", listOf(longitude.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/account/settings/update",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /account/validateAccountSignup
     * Save Validation Status
     * Validate the account&#39;s email address. The token must be valid and not expired. Use the RequestValidateAccount end point to request a new token.
     * @param token The token associated with the account to update, good for 24 hours
     * @return AccountLoginResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun validateAccountSignup(token: kotlin.String) : AccountLoginResponse {
        val localVarResponse = validateAccountSignupWithHttpInfo(token = token)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AccountLoginResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /account/validateAccountSignup
     * Save Validation Status
     * Validate the account&#39;s email address. The token must be valid and not expired. Use the RequestValidateAccount end point to request a new token.
     * @param token The token associated with the account to update, good for 24 hours
     * @return ApiResponse<AccountLoginResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun validateAccountSignupWithHttpInfo(token: kotlin.String) : ApiResponse<AccountLoginResponse?> {
        val localVariableConfig = validateAccountSignupRequestConfig(token = token)

        return request<Unit, AccountLoginResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation validateAccountSignup
     *
     * @param token The token associated with the account to update, good for 24 hours
     * @return RequestConfig
     */
    fun validateAccountSignupRequestConfig(token: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("token", listOf(token.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/account/validateAccountSignup",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /account/validatepasswordreset
     * Validate Password Reset Token
     * Validate the password reset token. The token must be valid and not expired. Use the RequestPasswordReset end point to request a token. The user receives and email with the reset page, therefore it should be validated before bwing used to reset the password.
     * @param token The token associated with the account to update, good for 24 hours
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun validatePasswordReset(token: kotlin.String) : SirqulResponse {
        val localVarResponse = validatePasswordResetWithHttpInfo(token = token)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /account/validatepasswordreset
     * Validate Password Reset Token
     * Validate the password reset token. The token must be valid and not expired. Use the RequestPasswordReset end point to request a token. The user receives and email with the reset page, therefore it should be validated before bwing used to reset the password.
     * @param token The token associated with the account to update, good for 24 hours
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun validatePasswordResetWithHttpInfo(token: kotlin.String) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = validatePasswordResetRequestConfig(token = token)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation validatePasswordReset
     *
     * @param token The token associated with the account to update, good for 24 hours
     * @return RequestConfig
     */
    fun validatePasswordResetRequestConfig(token: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("token", listOf(token.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/account/validatepasswordreset",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
