/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import org.openapitools.client.models.Direction
import org.openapitools.client.models.Route
import org.openapitools.client.models.Shipment
import org.openapitools.client.models.Stop

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

open class RouteApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost")
        }
    }

    /**
     * POST /api/{version}/route/{routeId}/approve
     * Approve Route
     * Approve a route
     * @param version 
     * @param routeId the id of the route to approve
     * @return Route
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun approveRoute(version: java.math.BigDecimal, routeId: kotlin.Long) : Route {
        val localVarResponse = approveRouteWithHttpInfo(version = version, routeId = routeId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Route
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/{version}/route/{routeId}/approve
     * Approve Route
     * Approve a route
     * @param version 
     * @param routeId the id of the route to approve
     * @return ApiResponse<Route?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun approveRouteWithHttpInfo(version: java.math.BigDecimal, routeId: kotlin.Long) : ApiResponse<Route?> {
        val localVariableConfig = approveRouteRequestConfig(version = version, routeId = routeId)

        return request<Unit, Route>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation approveRoute
     *
     * @param version 
     * @param routeId the id of the route to approve
     * @return RequestConfig
     */
    fun approveRouteRequestConfig(version: java.math.BigDecimal, routeId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/{version}/route/{routeId}/approve".replace("{"+"version"+"}", encodeURIComponent(version.toString())).replace("{"+"routeId"+"}", encodeURIComponent(routeId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/{version}/route/{routeId}/copy
     * Copy Route
     * Make an copy of the given route with optional overriding properties
     * @param version 
     * @param routeId the id of the route to duplicate
     * @param body  (optional)
     * @return Route
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun copyRoute(version: java.math.BigDecimal, routeId: kotlin.Long, body: Route? = null) : Route {
        val localVarResponse = copyRouteWithHttpInfo(version = version, routeId = routeId, body = body)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Route
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/{version}/route/{routeId}/copy
     * Copy Route
     * Make an copy of the given route with optional overriding properties
     * @param version 
     * @param routeId the id of the route to duplicate
     * @param body  (optional)
     * @return ApiResponse<Route?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun copyRouteWithHttpInfo(version: java.math.BigDecimal, routeId: kotlin.Long, body: Route?) : ApiResponse<Route?> {
        val localVariableConfig = copyRouteRequestConfig(version = version, routeId = routeId, body = body)

        return request<Route, Route>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation copyRoute
     *
     * @param version 
     * @param routeId the id of the route to duplicate
     * @param body  (optional)
     * @return RequestConfig
     */
    fun copyRouteRequestConfig(version: java.math.BigDecimal, routeId: kotlin.Long, body: Route?) : RequestConfig<Route> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/{version}/route/{routeId}/copy".replace("{"+"version"+"}", encodeURIComponent(version.toString())).replace("{"+"routeId"+"}", encodeURIComponent(routeId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/{version}/route
     * Create Route
     * Create new route
     * @param version 
     * @param body  (optional)
     * @return Route
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createRoute(version: java.math.BigDecimal, body: Route? = null) : Route {
        val localVarResponse = createRouteWithHttpInfo(version = version, body = body)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Route
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/{version}/route
     * Create Route
     * Create new route
     * @param version 
     * @param body  (optional)
     * @return ApiResponse<Route?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createRouteWithHttpInfo(version: java.math.BigDecimal, body: Route?) : ApiResponse<Route?> {
        val localVariableConfig = createRouteRequestConfig(version = version, body = body)

        return request<Route, Route>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createRoute
     *
     * @param version 
     * @param body  (optional)
     * @return RequestConfig
     */
    fun createRouteRequestConfig(version: java.math.BigDecimal, body: Route?) : RequestConfig<Route> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/{version}/route".replace("{"+"version"+"}", encodeURIComponent(version.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * PUT /api/{version}/route/{routeId}/directions
     * Update Route Directions
     * Regenerate the directions of a route
     * @param version 
     * @param routeId the id of the route to update directions for
     * @return kotlin.collections.List<Direction>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createRouteDirections(version: java.math.BigDecimal, routeId: kotlin.Long) : kotlin.collections.List<Direction> {
        val localVarResponse = createRouteDirectionsWithHttpInfo(version = version, routeId = routeId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<Direction>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * PUT /api/{version}/route/{routeId}/directions
     * Update Route Directions
     * Regenerate the directions of a route
     * @param version 
     * @param routeId the id of the route to update directions for
     * @return ApiResponse<kotlin.collections.List<Direction>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createRouteDirectionsWithHttpInfo(version: java.math.BigDecimal, routeId: kotlin.Long) : ApiResponse<kotlin.collections.List<Direction>?> {
        val localVariableConfig = createRouteDirectionsRequestConfig(version = version, routeId = routeId)

        return request<Unit, kotlin.collections.List<Direction>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createRouteDirections
     *
     * @param version 
     * @param routeId the id of the route to update directions for
     * @return RequestConfig
     */
    fun createRouteDirectionsRequestConfig(version: java.math.BigDecimal, routeId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/{version}/route/{routeId}/directions".replace("{"+"version"+"}", encodeURIComponent(version.toString())).replace("{"+"routeId"+"}", encodeURIComponent(routeId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * PUT /api/{version}/route/{routeId}/polyline
     * Create Route Polyline
     * Update the polyline of the requested route
     * @param version 
     * @param routeId the id of the route to create a polyline for
     * @return Route
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createRoutePolyline(version: java.math.BigDecimal, routeId: kotlin.Long) : Route {
        val localVarResponse = createRoutePolylineWithHttpInfo(version = version, routeId = routeId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Route
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * PUT /api/{version}/route/{routeId}/polyline
     * Create Route Polyline
     * Update the polyline of the requested route
     * @param version 
     * @param routeId the id of the route to create a polyline for
     * @return ApiResponse<Route?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createRoutePolylineWithHttpInfo(version: java.math.BigDecimal, routeId: kotlin.Long) : ApiResponse<Route?> {
        val localVariableConfig = createRoutePolylineRequestConfig(version = version, routeId = routeId)

        return request<Unit, Route>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createRoutePolyline
     *
     * @param version 
     * @param routeId the id of the route to create a polyline for
     * @return RequestConfig
     */
    fun createRoutePolylineRequestConfig(version: java.math.BigDecimal, routeId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/{version}/route/{routeId}/polyline".replace("{"+"version"+"}", encodeURIComponent(version.toString())).replace("{"+"routeId"+"}", encodeURIComponent(routeId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * DELETE /api/{version}/route/{routeId}
     * Delete Route
     * Delete an existing route
     * @param version 
     * @param routeId the id of the route
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteRoute(version: java.math.BigDecimal, routeId: kotlin.Long) : Unit {
        val localVarResponse = deleteRouteWithHttpInfo(version = version, routeId = routeId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * DELETE /api/{version}/route/{routeId}
     * Delete Route
     * Delete an existing route
     * @param version 
     * @param routeId the id of the route
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteRouteWithHttpInfo(version: java.math.BigDecimal, routeId: kotlin.Long) : ApiResponse<Unit?> {
        val localVariableConfig = deleteRouteRequestConfig(version = version, routeId = routeId)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteRoute
     *
     * @param version 
     * @param routeId the id of the route
     * @return RequestConfig
     */
    fun deleteRouteRequestConfig(version: java.math.BigDecimal, routeId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/{version}/route/{routeId}".replace("{"+"version"+"}", encodeURIComponent(version.toString())).replace("{"+"routeId"+"}", encodeURIComponent(routeId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/{version}/route/{routeId}/disapprove
     * Disapprove Route
     * Disapprove a route
     * @param version 
     * @param routeId the id of the route to reject
     * @return Route
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun disapproveRoute(version: java.math.BigDecimal, routeId: kotlin.Long) : Route {
        val localVarResponse = disapproveRouteWithHttpInfo(version = version, routeId = routeId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Route
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/{version}/route/{routeId}/disapprove
     * Disapprove Route
     * Disapprove a route
     * @param version 
     * @param routeId the id of the route to reject
     * @return ApiResponse<Route?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun disapproveRouteWithHttpInfo(version: java.math.BigDecimal, routeId: kotlin.Long) : ApiResponse<Route?> {
        val localVariableConfig = disapproveRouteRequestConfig(version = version, routeId = routeId)

        return request<Unit, Route>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation disapproveRoute
     *
     * @param version 
     * @param routeId the id of the route to reject
     * @return RequestConfig
     */
    fun disapproveRouteRequestConfig(version: java.math.BigDecimal, routeId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/{version}/route/{routeId}/disapprove".replace("{"+"version"+"}", encodeURIComponent(version.toString())).replace("{"+"routeId"+"}", encodeURIComponent(routeId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /api/{version}/route/{routeId}
     * Get Route
     * Get an existing route
     * @param version 
     * @param routeId the id of the route to get
     * @param showInheritedProperties return inherited properties from parent or not
     * @return Route
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getRoute(version: java.math.BigDecimal, routeId: kotlin.Long, showInheritedProperties: kotlin.Boolean) : Route {
        val localVarResponse = getRouteWithHttpInfo(version = version, routeId = routeId, showInheritedProperties = showInheritedProperties)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Route
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/{version}/route/{routeId}
     * Get Route
     * Get an existing route
     * @param version 
     * @param routeId the id of the route to get
     * @param showInheritedProperties return inherited properties from parent or not
     * @return ApiResponse<Route?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getRouteWithHttpInfo(version: java.math.BigDecimal, routeId: kotlin.Long, showInheritedProperties: kotlin.Boolean) : ApiResponse<Route?> {
        val localVariableConfig = getRouteRequestConfig(version = version, routeId = routeId, showInheritedProperties = showInheritedProperties)

        return request<Unit, Route>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getRoute
     *
     * @param version 
     * @param routeId the id of the route to get
     * @param showInheritedProperties return inherited properties from parent or not
     * @return RequestConfig
     */
    fun getRouteRequestConfig(version: java.math.BigDecimal, routeId: kotlin.Long, showInheritedProperties: kotlin.Boolean) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("showInheritedProperties", listOf(showInheritedProperties.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/{version}/route/{routeId}".replace("{"+"version"+"}", encodeURIComponent(version.toString())).replace("{"+"routeId"+"}", encodeURIComponent(routeId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /api/{version}/route/{routeId}/directions
     * Get Route Directions
     * Get the directions of a route
     * @param version 
     * @param routeId the id of the route to get directions for
     * @return kotlin.collections.List<Direction>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getRouteDirections(version: java.math.BigDecimal, routeId: kotlin.Long) : kotlin.collections.List<Direction> {
        val localVarResponse = getRouteDirectionsWithHttpInfo(version = version, routeId = routeId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<Direction>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/{version}/route/{routeId}/directions
     * Get Route Directions
     * Get the directions of a route
     * @param version 
     * @param routeId the id of the route to get directions for
     * @return ApiResponse<kotlin.collections.List<Direction>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getRouteDirectionsWithHttpInfo(version: java.math.BigDecimal, routeId: kotlin.Long) : ApiResponse<kotlin.collections.List<Direction>?> {
        val localVariableConfig = getRouteDirectionsRequestConfig(version = version, routeId = routeId)

        return request<Unit, kotlin.collections.List<Direction>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getRouteDirections
     *
     * @param version 
     * @param routeId the id of the route to get directions for
     * @return RequestConfig
     */
    fun getRouteDirectionsRequestConfig(version: java.math.BigDecimal, routeId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/{version}/route/{routeId}/directions".replace("{"+"version"+"}", encodeURIComponent(version.toString())).replace("{"+"routeId"+"}", encodeURIComponent(routeId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /api/{version}/route/{routeId}/shipments
     * Get Route Shipments
     * Get the shipments on the requested route
     * @param version 
     * @param routeId the id of the route to get shipments for
     * @return kotlin.collections.List<Shipment>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getRouteShipments(version: java.math.BigDecimal, routeId: kotlin.Long) : kotlin.collections.List<Shipment> {
        val localVarResponse = getRouteShipmentsWithHttpInfo(version = version, routeId = routeId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<Shipment>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/{version}/route/{routeId}/shipments
     * Get Route Shipments
     * Get the shipments on the requested route
     * @param version 
     * @param routeId the id of the route to get shipments for
     * @return ApiResponse<kotlin.collections.List<Shipment>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getRouteShipmentsWithHttpInfo(version: java.math.BigDecimal, routeId: kotlin.Long) : ApiResponse<kotlin.collections.List<Shipment>?> {
        val localVariableConfig = getRouteShipmentsRequestConfig(version = version, routeId = routeId)

        return request<Unit, kotlin.collections.List<Shipment>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getRouteShipments
     *
     * @param version 
     * @param routeId the id of the route to get shipments for
     * @return RequestConfig
     */
    fun getRouteShipmentsRequestConfig(version: java.math.BigDecimal, routeId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/{version}/route/{routeId}/shipments".replace("{"+"version"+"}", encodeURIComponent(version.toString())).replace("{"+"routeId"+"}", encodeURIComponent(routeId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /api/{version}/route/{routeId}/stop/{stopId}
     * Get Route Stop
     * Get the specific stop on a route
     * @param version 
     * @param routeId the id of the route to get stops for
     * @param stopId the id of the specific stop on the route
     * @return Stop
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getRouteStop(version: java.math.BigDecimal, routeId: kotlin.Long, stopId: kotlin.Long) : Stop {
        val localVarResponse = getRouteStopWithHttpInfo(version = version, routeId = routeId, stopId = stopId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Stop
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/{version}/route/{routeId}/stop/{stopId}
     * Get Route Stop
     * Get the specific stop on a route
     * @param version 
     * @param routeId the id of the route to get stops for
     * @param stopId the id of the specific stop on the route
     * @return ApiResponse<Stop?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getRouteStopWithHttpInfo(version: java.math.BigDecimal, routeId: kotlin.Long, stopId: kotlin.Long) : ApiResponse<Stop?> {
        val localVariableConfig = getRouteStopRequestConfig(version = version, routeId = routeId, stopId = stopId)

        return request<Unit, Stop>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getRouteStop
     *
     * @param version 
     * @param routeId the id of the route to get stops for
     * @param stopId the id of the specific stop on the route
     * @return RequestConfig
     */
    fun getRouteStopRequestConfig(version: java.math.BigDecimal, routeId: kotlin.Long, stopId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/{version}/route/{routeId}/stop/{stopId}".replace("{"+"version"+"}", encodeURIComponent(version.toString())).replace("{"+"routeId"+"}", encodeURIComponent(routeId.toString())).replace("{"+"stopId"+"}", encodeURIComponent(stopId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /api/{version}/route/{routeId}/stops
     * Get Route Stops
     * The stops of the route requested
     * @param version 
     * @param routeId the id of the route
     * @param confirmedOnly only get stops that have been confirmed or not
     * @return kotlin.collections.List<Stop>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getRouteStops(version: java.math.BigDecimal, routeId: kotlin.Long, confirmedOnly: kotlin.Boolean) : kotlin.collections.List<Stop> {
        val localVarResponse = getRouteStopsWithHttpInfo(version = version, routeId = routeId, confirmedOnly = confirmedOnly)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<Stop>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/{version}/route/{routeId}/stops
     * Get Route Stops
     * The stops of the route requested
     * @param version 
     * @param routeId the id of the route
     * @param confirmedOnly only get stops that have been confirmed or not
     * @return ApiResponse<kotlin.collections.List<Stop>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getRouteStopsWithHttpInfo(version: java.math.BigDecimal, routeId: kotlin.Long, confirmedOnly: kotlin.Boolean) : ApiResponse<kotlin.collections.List<Stop>?> {
        val localVariableConfig = getRouteStopsRequestConfig(version = version, routeId = routeId, confirmedOnly = confirmedOnly)

        return request<Unit, kotlin.collections.List<Stop>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getRouteStops
     *
     * @param version 
     * @param routeId the id of the route
     * @param confirmedOnly only get stops that have been confirmed or not
     * @return RequestConfig
     */
    fun getRouteStopsRequestConfig(version: java.math.BigDecimal, routeId: kotlin.Long, confirmedOnly: kotlin.Boolean) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("confirmedOnly", listOf(confirmedOnly.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/{version}/route/{routeId}/stops".replace("{"+"version"+"}", encodeURIComponent(version.toString())).replace("{"+"routeId"+"}", encodeURIComponent(routeId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /api/{version}/route/{routeId}/stop/{stopId}/shipments
     * Get Shipments At Stop
     * Get the list of shipments on the requested route at a stop
     * @param version 
     * @param routeId the id of the route
     * @param stopId the id of the stop to get shipments on
     * @return kotlin.collections.List<Shipment>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getShipmentsAtStop(version: java.math.BigDecimal, routeId: kotlin.Long, stopId: kotlin.Long) : kotlin.collections.List<Shipment> {
        val localVarResponse = getShipmentsAtStopWithHttpInfo(version = version, routeId = routeId, stopId = stopId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<Shipment>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/{version}/route/{routeId}/stop/{stopId}/shipments
     * Get Shipments At Stop
     * Get the list of shipments on the requested route at a stop
     * @param version 
     * @param routeId the id of the route
     * @param stopId the id of the stop to get shipments on
     * @return ApiResponse<kotlin.collections.List<Shipment>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getShipmentsAtStopWithHttpInfo(version: java.math.BigDecimal, routeId: kotlin.Long, stopId: kotlin.Long) : ApiResponse<kotlin.collections.List<Shipment>?> {
        val localVariableConfig = getShipmentsAtStopRequestConfig(version = version, routeId = routeId, stopId = stopId)

        return request<Unit, kotlin.collections.List<Shipment>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getShipmentsAtStop
     *
     * @param version 
     * @param routeId the id of the route
     * @param stopId the id of the stop to get shipments on
     * @return RequestConfig
     */
    fun getShipmentsAtStopRequestConfig(version: java.math.BigDecimal, routeId: kotlin.Long, stopId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/{version}/route/{routeId}/stop/{stopId}/shipments".replace("{"+"version"+"}", encodeURIComponent(version.toString())).replace("{"+"routeId"+"}", encodeURIComponent(routeId.toString())).replace("{"+"stopId"+"}", encodeURIComponent(stopId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/{version}/route/{routeId}/optimize
     * Optimize Route
     * Optimize a route. The optimization method based on how the server is configured.
     * @param version 
     * @param routeId the id of the route to optimize
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun optimizeRoute(version: java.math.BigDecimal, routeId: kotlin.Long) : Unit {
        val localVarResponse = optimizeRouteWithHttpInfo(version = version, routeId = routeId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/{version}/route/{routeId}/optimize
     * Optimize Route
     * Optimize a route. The optimization method based on how the server is configured.
     * @param version 
     * @param routeId the id of the route to optimize
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun optimizeRouteWithHttpInfo(version: java.math.BigDecimal, routeId: kotlin.Long) : ApiResponse<Unit?> {
        val localVariableConfig = optimizeRouteRequestConfig(version = version, routeId = routeId)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation optimizeRoute
     *
     * @param version 
     * @param routeId the id of the route to optimize
     * @return RequestConfig
     */
    fun optimizeRouteRequestConfig(version: java.math.BigDecimal, routeId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/{version}/route/{routeId}/optimize".replace("{"+"version"+"}", encodeURIComponent(version.toString())).replace("{"+"routeId"+"}", encodeURIComponent(routeId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * DELETE /api/{version}/route/{routeId}/stop/{stopId}
     * Delete Stop
     * Delete a stop on a route
     * @param version 
     * @param routeId the id of the route
     * @param stopId the id of the specific stop to delete on the route
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun removeStop(version: java.math.BigDecimal, routeId: kotlin.Long, stopId: kotlin.Long) : Unit {
        val localVarResponse = removeStopWithHttpInfo(version = version, routeId = routeId, stopId = stopId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * DELETE /api/{version}/route/{routeId}/stop/{stopId}
     * Delete Stop
     * Delete a stop on a route
     * @param version 
     * @param routeId the id of the route
     * @param stopId the id of the specific stop to delete on the route
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun removeStopWithHttpInfo(version: java.math.BigDecimal, routeId: kotlin.Long, stopId: kotlin.Long) : ApiResponse<Unit?> {
        val localVariableConfig = removeStopRequestConfig(version = version, routeId = routeId, stopId = stopId)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation removeStop
     *
     * @param version 
     * @param routeId the id of the route
     * @param stopId the id of the specific stop to delete on the route
     * @return RequestConfig
     */
    fun removeStopRequestConfig(version: java.math.BigDecimal, routeId: kotlin.Long, stopId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/{version}/route/{routeId}/stop/{stopId}".replace("{"+"version"+"}", encodeURIComponent(version.toString())).replace("{"+"routeId"+"}", encodeURIComponent(routeId.toString())).replace("{"+"stopId"+"}", encodeURIComponent(stopId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * PATCH /api/{version}/route/{routeId}/stops/reorder
     * Reorder Route Stops
     * Reordering the stops on the route with and update route distance, time, direction, and polyline
     * @param version 
     * @param routeId the id of the route
     * @param body  (optional)
     * @return kotlin.collections.List<Stop>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun reorderRouteStopsPatch(version: java.math.BigDecimal, routeId: kotlin.Long, body: kotlin.collections.List<Stop>? = null) : kotlin.collections.List<Stop> {
        val localVarResponse = reorderRouteStopsPatchWithHttpInfo(version = version, routeId = routeId, body = body)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<Stop>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * PATCH /api/{version}/route/{routeId}/stops/reorder
     * Reorder Route Stops
     * Reordering the stops on the route with and update route distance, time, direction, and polyline
     * @param version 
     * @param routeId the id of the route
     * @param body  (optional)
     * @return ApiResponse<kotlin.collections.List<Stop>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun reorderRouteStopsPatchWithHttpInfo(version: java.math.BigDecimal, routeId: kotlin.Long, body: kotlin.collections.List<Stop>?) : ApiResponse<kotlin.collections.List<Stop>?> {
        val localVariableConfig = reorderRouteStopsPatchRequestConfig(version = version, routeId = routeId, body = body)

        return request<kotlin.collections.List<Stop>, kotlin.collections.List<Stop>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation reorderRouteStopsPatch
     *
     * @param version 
     * @param routeId the id of the route
     * @param body  (optional)
     * @return RequestConfig
     */
    fun reorderRouteStopsPatchRequestConfig(version: java.math.BigDecimal, routeId: kotlin.Long, body: kotlin.collections.List<Stop>?) : RequestConfig<kotlin.collections.List<Stop>> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/api/{version}/route/{routeId}/stops/reorder".replace("{"+"version"+"}", encodeURIComponent(version.toString())).replace("{"+"routeId"+"}", encodeURIComponent(routeId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/{version}/route/{routeId}/stops/reorder
     * Reorder Route Stops
     * Reordering the stops on the route with and update route distance, time, direction, and polyline
     * @param version 
     * @param routeId the id of the route
     * @param body  (optional)
     * @return kotlin.collections.List<Stop>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun reorderRouteStopsPost(version: java.math.BigDecimal, routeId: kotlin.Long, body: kotlin.collections.List<Stop>? = null) : kotlin.collections.List<Stop> {
        val localVarResponse = reorderRouteStopsPostWithHttpInfo(version = version, routeId = routeId, body = body)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<Stop>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/{version}/route/{routeId}/stops/reorder
     * Reorder Route Stops
     * Reordering the stops on the route with and update route distance, time, direction, and polyline
     * @param version 
     * @param routeId the id of the route
     * @param body  (optional)
     * @return ApiResponse<kotlin.collections.List<Stop>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun reorderRouteStopsPostWithHttpInfo(version: java.math.BigDecimal, routeId: kotlin.Long, body: kotlin.collections.List<Stop>?) : ApiResponse<kotlin.collections.List<Stop>?> {
        val localVariableConfig = reorderRouteStopsPostRequestConfig(version = version, routeId = routeId, body = body)

        return request<kotlin.collections.List<Stop>, kotlin.collections.List<Stop>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation reorderRouteStopsPost
     *
     * @param version 
     * @param routeId the id of the route
     * @param body  (optional)
     * @return RequestConfig
     */
    fun reorderRouteStopsPostRequestConfig(version: java.math.BigDecimal, routeId: kotlin.Long, body: kotlin.collections.List<Stop>?) : RequestConfig<kotlin.collections.List<Stop>> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/{version}/route/{routeId}/stops/reorder".replace("{"+"version"+"}", encodeURIComponent(version.toString())).replace("{"+"routeId"+"}", encodeURIComponent(routeId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /api/{version}/route
     * Search Routes
     * Search for routes.
     * @param version 
     * @param sortField The field to sort by
     * @param descending Determines whether the sorted list is in descending or ascending order
     * @param start The start index for pagination
     * @param limit The limit for pagination
     * @param activeOnly Return only active results
     * @param includesEmpty Include empty routes or not
     * @param rootOnly Only return root instance routes
     * @param showInheritedProperties Display root route properties
     * @param hubId Filter results by service hub (optional)
     * @param programId Filter results by program (optional)
     * @param scheduledStart The start date to filter the results by (optional)
     * @param scheduledEnd The end date to filter the results by (optional)
     * @param updatedStart The lower bound of updated date (optional)
     * @param updatedEnd The upper bound of updated date (optional)
     * @param featured The route is featured or not (optional)
     * @param seatCount Has at least this many seat available (optional)
     * @param approved Has been approved or not (optional)
     * @param started Has started or not (optional)
     * @param completed Has completed or not (optional)
     * @param valid Is valid or not (optional)
     * @param parentId If it is a recurring route based on the parent route (optional)
     * @return kotlin.collections.List<Route>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun searchRoutes(version: java.math.BigDecimal, sortField: kotlin.String, descending: kotlin.Boolean, start: kotlin.Int, limit: kotlin.Int, activeOnly: kotlin.Boolean, includesEmpty: kotlin.Boolean, rootOnly: kotlin.Boolean, showInheritedProperties: kotlin.Boolean, hubId: kotlin.Long? = null, programId: kotlin.Long? = null, scheduledStart: kotlin.Long? = null, scheduledEnd: kotlin.Long? = null, updatedStart: kotlin.Long? = null, updatedEnd: kotlin.Long? = null, featured: kotlin.Boolean? = null, seatCount: kotlin.Int? = null, approved: kotlin.Boolean? = null, started: kotlin.Boolean? = null, completed: kotlin.Boolean? = null, valid: kotlin.Boolean? = null, parentId: kotlin.Long? = null) : kotlin.collections.List<Route> {
        val localVarResponse = searchRoutesWithHttpInfo(version = version, sortField = sortField, descending = descending, start = start, limit = limit, activeOnly = activeOnly, includesEmpty = includesEmpty, rootOnly = rootOnly, showInheritedProperties = showInheritedProperties, hubId = hubId, programId = programId, scheduledStart = scheduledStart, scheduledEnd = scheduledEnd, updatedStart = updatedStart, updatedEnd = updatedEnd, featured = featured, seatCount = seatCount, approved = approved, started = started, completed = completed, valid = valid, parentId = parentId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<Route>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/{version}/route
     * Search Routes
     * Search for routes.
     * @param version 
     * @param sortField The field to sort by
     * @param descending Determines whether the sorted list is in descending or ascending order
     * @param start The start index for pagination
     * @param limit The limit for pagination
     * @param activeOnly Return only active results
     * @param includesEmpty Include empty routes or not
     * @param rootOnly Only return root instance routes
     * @param showInheritedProperties Display root route properties
     * @param hubId Filter results by service hub (optional)
     * @param programId Filter results by program (optional)
     * @param scheduledStart The start date to filter the results by (optional)
     * @param scheduledEnd The end date to filter the results by (optional)
     * @param updatedStart The lower bound of updated date (optional)
     * @param updatedEnd The upper bound of updated date (optional)
     * @param featured The route is featured or not (optional)
     * @param seatCount Has at least this many seat available (optional)
     * @param approved Has been approved or not (optional)
     * @param started Has started or not (optional)
     * @param completed Has completed or not (optional)
     * @param valid Is valid or not (optional)
     * @param parentId If it is a recurring route based on the parent route (optional)
     * @return ApiResponse<kotlin.collections.List<Route>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun searchRoutesWithHttpInfo(version: java.math.BigDecimal, sortField: kotlin.String, descending: kotlin.Boolean, start: kotlin.Int, limit: kotlin.Int, activeOnly: kotlin.Boolean, includesEmpty: kotlin.Boolean, rootOnly: kotlin.Boolean, showInheritedProperties: kotlin.Boolean, hubId: kotlin.Long?, programId: kotlin.Long?, scheduledStart: kotlin.Long?, scheduledEnd: kotlin.Long?, updatedStart: kotlin.Long?, updatedEnd: kotlin.Long?, featured: kotlin.Boolean?, seatCount: kotlin.Int?, approved: kotlin.Boolean?, started: kotlin.Boolean?, completed: kotlin.Boolean?, valid: kotlin.Boolean?, parentId: kotlin.Long?) : ApiResponse<kotlin.collections.List<Route>?> {
        val localVariableConfig = searchRoutesRequestConfig(version = version, sortField = sortField, descending = descending, start = start, limit = limit, activeOnly = activeOnly, includesEmpty = includesEmpty, rootOnly = rootOnly, showInheritedProperties = showInheritedProperties, hubId = hubId, programId = programId, scheduledStart = scheduledStart, scheduledEnd = scheduledEnd, updatedStart = updatedStart, updatedEnd = updatedEnd, featured = featured, seatCount = seatCount, approved = approved, started = started, completed = completed, valid = valid, parentId = parentId)

        return request<Unit, kotlin.collections.List<Route>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation searchRoutes
     *
     * @param version 
     * @param sortField The field to sort by
     * @param descending Determines whether the sorted list is in descending or ascending order
     * @param start The start index for pagination
     * @param limit The limit for pagination
     * @param activeOnly Return only active results
     * @param includesEmpty Include empty routes or not
     * @param rootOnly Only return root instance routes
     * @param showInheritedProperties Display root route properties
     * @param hubId Filter results by service hub (optional)
     * @param programId Filter results by program (optional)
     * @param scheduledStart The start date to filter the results by (optional)
     * @param scheduledEnd The end date to filter the results by (optional)
     * @param updatedStart The lower bound of updated date (optional)
     * @param updatedEnd The upper bound of updated date (optional)
     * @param featured The route is featured or not (optional)
     * @param seatCount Has at least this many seat available (optional)
     * @param approved Has been approved or not (optional)
     * @param started Has started or not (optional)
     * @param completed Has completed or not (optional)
     * @param valid Is valid or not (optional)
     * @param parentId If it is a recurring route based on the parent route (optional)
     * @return RequestConfig
     */
    fun searchRoutesRequestConfig(version: java.math.BigDecimal, sortField: kotlin.String, descending: kotlin.Boolean, start: kotlin.Int, limit: kotlin.Int, activeOnly: kotlin.Boolean, includesEmpty: kotlin.Boolean, rootOnly: kotlin.Boolean, showInheritedProperties: kotlin.Boolean, hubId: kotlin.Long?, programId: kotlin.Long?, scheduledStart: kotlin.Long?, scheduledEnd: kotlin.Long?, updatedStart: kotlin.Long?, updatedEnd: kotlin.Long?, featured: kotlin.Boolean?, seatCount: kotlin.Int?, approved: kotlin.Boolean?, started: kotlin.Boolean?, completed: kotlin.Boolean?, valid: kotlin.Boolean?, parentId: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (hubId != null) {
                    put("hubId", listOf(hubId.toString()))
                }
                if (programId != null) {
                    put("programId", listOf(programId.toString()))
                }
                if (scheduledStart != null) {
                    put("scheduledStart", listOf(scheduledStart.toString()))
                }
                if (scheduledEnd != null) {
                    put("scheduledEnd", listOf(scheduledEnd.toString()))
                }
                if (updatedStart != null) {
                    put("updatedStart", listOf(updatedStart.toString()))
                }
                if (updatedEnd != null) {
                    put("updatedEnd", listOf(updatedEnd.toString()))
                }
                if (featured != null) {
                    put("featured", listOf(featured.toString()))
                }
                if (seatCount != null) {
                    put("seatCount", listOf(seatCount.toString()))
                }
                if (approved != null) {
                    put("approved", listOf(approved.toString()))
                }
                if (started != null) {
                    put("started", listOf(started.toString()))
                }
                if (completed != null) {
                    put("completed", listOf(completed.toString()))
                }
                if (valid != null) {
                    put("valid", listOf(valid.toString()))
                }
                if (parentId != null) {
                    put("parentId", listOf(parentId.toString()))
                }
                put("sortField", listOf(sortField.toString()))
                put("descending", listOf(descending.toString()))
                put("start", listOf(start.toString()))
                put("limit", listOf(limit.toString()))
                put("activeOnly", listOf(activeOnly.toString()))
                put("includesEmpty", listOf(includesEmpty.toString()))
                put("rootOnly", listOf(rootOnly.toString()))
                put("showInheritedProperties", listOf(showInheritedProperties.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/{version}/route".replace("{"+"version"+"}", encodeURIComponent(version.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/{version}/route/{id}/driver/{driverId}
     * Set Driver
     * Update the driver of the route.
     * @param version 
     * @param id the id of the route
     * @param driverId the id of the driver
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun setDriver(version: java.math.BigDecimal, id: kotlin.Long, driverId: kotlin.Long) : Unit {
        val localVarResponse = setDriverWithHttpInfo(version = version, id = id, driverId = driverId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/{version}/route/{id}/driver/{driverId}
     * Set Driver
     * Update the driver of the route.
     * @param version 
     * @param id the id of the route
     * @param driverId the id of the driver
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun setDriverWithHttpInfo(version: java.math.BigDecimal, id: kotlin.Long, driverId: kotlin.Long) : ApiResponse<Unit?> {
        val localVariableConfig = setDriverRequestConfig(version = version, id = id, driverId = driverId)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation setDriver
     *
     * @param version 
     * @param id the id of the route
     * @param driverId the id of the driver
     * @return RequestConfig
     */
    fun setDriverRequestConfig(version: java.math.BigDecimal, id: kotlin.Long, driverId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/{version}/route/{id}/driver/{driverId}".replace("{"+"version"+"}", encodeURIComponent(version.toString())).replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"driverId"+"}", encodeURIComponent(driverId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * PUT /api/{version}/route/{routeId}
     * Update Route
     * Update an existing route
     * @param version 
     * @param routeId the id of the route
     * @param body  (optional)
     * @return Route
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updateRoute(version: java.math.BigDecimal, routeId: kotlin.Long, body: Route? = null) : Route {
        val localVarResponse = updateRouteWithHttpInfo(version = version, routeId = routeId, body = body)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Route
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * PUT /api/{version}/route/{routeId}
     * Update Route
     * Update an existing route
     * @param version 
     * @param routeId the id of the route
     * @param body  (optional)
     * @return ApiResponse<Route?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun updateRouteWithHttpInfo(version: java.math.BigDecimal, routeId: kotlin.Long, body: Route?) : ApiResponse<Route?> {
        val localVariableConfig = updateRouteRequestConfig(version = version, routeId = routeId, body = body)

        return request<Route, Route>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateRoute
     *
     * @param version 
     * @param routeId the id of the route
     * @param body  (optional)
     * @return RequestConfig
     */
    fun updateRouteRequestConfig(version: java.math.BigDecimal, routeId: kotlin.Long, body: Route?) : RequestConfig<Route> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/{version}/route/{routeId}".replace("{"+"version"+"}", encodeURIComponent(version.toString())).replace("{"+"routeId"+"}", encodeURIComponent(routeId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * PUT /api/{version}/route/{routeId}/stop/{stopId}
     * Update Route Stop
     * Update a stop on a specified route
     * @param version 
     * @param routeId the id of the route to update stops for
     * @param stopId the id of the specific stop to update on the route
     * @param body  (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updateRouteStop(version: java.math.BigDecimal, routeId: kotlin.Long, stopId: kotlin.Long, body: Stop? = null) : Unit {
        val localVarResponse = updateRouteStopWithHttpInfo(version = version, routeId = routeId, stopId = stopId, body = body)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * PUT /api/{version}/route/{routeId}/stop/{stopId}
     * Update Route Stop
     * Update a stop on a specified route
     * @param version 
     * @param routeId the id of the route to update stops for
     * @param stopId the id of the specific stop to update on the route
     * @param body  (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun updateRouteStopWithHttpInfo(version: java.math.BigDecimal, routeId: kotlin.Long, stopId: kotlin.Long, body: Stop?) : ApiResponse<Unit?> {
        val localVariableConfig = updateRouteStopRequestConfig(version = version, routeId = routeId, stopId = stopId, body = body)

        return request<Stop, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateRouteStop
     *
     * @param version 
     * @param routeId the id of the route to update stops for
     * @param stopId the id of the specific stop to update on the route
     * @param body  (optional)
     * @return RequestConfig
     */
    fun updateRouteStopRequestConfig(version: java.math.BigDecimal, routeId: kotlin.Long, stopId: kotlin.Long, body: Stop?) : RequestConfig<Stop> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/{version}/route/{routeId}/stop/{stopId}".replace("{"+"version"+"}", encodeURIComponent(version.toString())).replace("{"+"routeId"+"}", encodeURIComponent(routeId.toString())).replace("{"+"stopId"+"}", encodeURIComponent(stopId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
