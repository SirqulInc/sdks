/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import org.openapitools.client.models.Direction
import org.openapitools.client.models.Route
import org.openapitools.client.models.Shipment
import org.openapitools.client.models.Stop

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

open class RouteApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://dev.sirqul.com/api/3.18")
        }
    }

    /**
     * POST /route/{routeId}/approve
     * Approve Route
     * Approve a route
     * @param routeId the id of the route to approve
     * @return Route
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun approveRoute(routeId: kotlin.Long) : Route {
        val localVarResponse = approveRouteWithHttpInfo(routeId = routeId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Route
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /route/{routeId}/approve
     * Approve Route
     * Approve a route
     * @param routeId the id of the route to approve
     * @return ApiResponse<Route?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun approveRouteWithHttpInfo(routeId: kotlin.Long) : ApiResponse<Route?> {
        val localVariableConfig = approveRouteRequestConfig(routeId = routeId)

        return request<Unit, Route>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation approveRoute
     *
     * @param routeId the id of the route to approve
     * @return RequestConfig
     */
    fun approveRouteRequestConfig(routeId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/route/{routeId}/approve".replace("{"+"routeId"+"}", encodeURIComponent(routeId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /route/{routeId}/copy
     * Copy Route
     * Make an copy of the given route with optional overriding properties
     * @param routeId the id of the route to duplicate
     * @param body  (optional)
     * @return Route
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun copyRoute(routeId: kotlin.Long, body: Route? = null) : Route {
        val localVarResponse = copyRouteWithHttpInfo(routeId = routeId, body = body)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Route
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /route/{routeId}/copy
     * Copy Route
     * Make an copy of the given route with optional overriding properties
     * @param routeId the id of the route to duplicate
     * @param body  (optional)
     * @return ApiResponse<Route?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun copyRouteWithHttpInfo(routeId: kotlin.Long, body: Route?) : ApiResponse<Route?> {
        val localVariableConfig = copyRouteRequestConfig(routeId = routeId, body = body)

        return request<Route, Route>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation copyRoute
     *
     * @param routeId the id of the route to duplicate
     * @param body  (optional)
     * @return RequestConfig
     */
    fun copyRouteRequestConfig(routeId: kotlin.Long, body: Route?) : RequestConfig<Route> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/route/{routeId}/copy".replace("{"+"routeId"+"}", encodeURIComponent(routeId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /route
     * Create Route
     * Create new route
     * @param body  (optional)
     * @return Route
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createRoute(body: Route? = null) : Route {
        val localVarResponse = createRouteWithHttpInfo(body = body)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Route
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /route
     * Create Route
     * Create new route
     * @param body  (optional)
     * @return ApiResponse<Route?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createRouteWithHttpInfo(body: Route?) : ApiResponse<Route?> {
        val localVariableConfig = createRouteRequestConfig(body = body)

        return request<Route, Route>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createRoute
     *
     * @param body  (optional)
     * @return RequestConfig
     */
    fun createRouteRequestConfig(body: Route?) : RequestConfig<Route> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/route",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * PUT /route/{routeId}/directions
     * Update Route Directions
     * Regenerate the directions of a route
     * @param routeId the id of the route to update directions for
     * @return kotlin.collections.List<Direction>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createRouteDirections(routeId: kotlin.Long) : kotlin.collections.List<Direction> {
        val localVarResponse = createRouteDirectionsWithHttpInfo(routeId = routeId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<Direction>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * PUT /route/{routeId}/directions
     * Update Route Directions
     * Regenerate the directions of a route
     * @param routeId the id of the route to update directions for
     * @return ApiResponse<kotlin.collections.List<Direction>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createRouteDirectionsWithHttpInfo(routeId: kotlin.Long) : ApiResponse<kotlin.collections.List<Direction>?> {
        val localVariableConfig = createRouteDirectionsRequestConfig(routeId = routeId)

        return request<Unit, kotlin.collections.List<Direction>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createRouteDirections
     *
     * @param routeId the id of the route to update directions for
     * @return RequestConfig
     */
    fun createRouteDirectionsRequestConfig(routeId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/route/{routeId}/directions".replace("{"+"routeId"+"}", encodeURIComponent(routeId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * PUT /route/{routeId}/polyline
     * Create Route Polyline
     * Update the polyline of the requested route
     * @param routeId the id of the route to create a polyline for
     * @return Route
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createRoutePolyline(routeId: kotlin.Long) : Route {
        val localVarResponse = createRoutePolylineWithHttpInfo(routeId = routeId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Route
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * PUT /route/{routeId}/polyline
     * Create Route Polyline
     * Update the polyline of the requested route
     * @param routeId the id of the route to create a polyline for
     * @return ApiResponse<Route?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createRoutePolylineWithHttpInfo(routeId: kotlin.Long) : ApiResponse<Route?> {
        val localVariableConfig = createRoutePolylineRequestConfig(routeId = routeId)

        return request<Unit, Route>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createRoutePolyline
     *
     * @param routeId the id of the route to create a polyline for
     * @return RequestConfig
     */
    fun createRoutePolylineRequestConfig(routeId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/route/{routeId}/polyline".replace("{"+"routeId"+"}", encodeURIComponent(routeId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * DELETE /route/{routeId}
     * Delete Route
     * Delete an existing route
     * @param routeId the id of the route
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteRoute(routeId: kotlin.Long) : Unit {
        val localVarResponse = deleteRouteWithHttpInfo(routeId = routeId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * DELETE /route/{routeId}
     * Delete Route
     * Delete an existing route
     * @param routeId the id of the route
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteRouteWithHttpInfo(routeId: kotlin.Long) : ApiResponse<Unit?> {
        val localVariableConfig = deleteRouteRequestConfig(routeId = routeId)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteRoute
     *
     * @param routeId the id of the route
     * @return RequestConfig
     */
    fun deleteRouteRequestConfig(routeId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/route/{routeId}".replace("{"+"routeId"+"}", encodeURIComponent(routeId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /route/{routeId}/disapprove
     * Disapprove Route
     * Disapprove a route
     * @param routeId the id of the route to reject
     * @return Route
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun disapproveRoute(routeId: kotlin.Long) : Route {
        val localVarResponse = disapproveRouteWithHttpInfo(routeId = routeId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Route
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /route/{routeId}/disapprove
     * Disapprove Route
     * Disapprove a route
     * @param routeId the id of the route to reject
     * @return ApiResponse<Route?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun disapproveRouteWithHttpInfo(routeId: kotlin.Long) : ApiResponse<Route?> {
        val localVariableConfig = disapproveRouteRequestConfig(routeId = routeId)

        return request<Unit, Route>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation disapproveRoute
     *
     * @param routeId the id of the route to reject
     * @return RequestConfig
     */
    fun disapproveRouteRequestConfig(routeId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/route/{routeId}/disapprove".replace("{"+"routeId"+"}", encodeURIComponent(routeId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /route/{routeId}
     * Get Route
     * Get an existing route
     * @param routeId the id of the route to get
     * @param showInheritedProperties return inherited properties from parent or not
     * @return Route
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getRoute(routeId: kotlin.Long, showInheritedProperties: kotlin.Boolean) : Route {
        val localVarResponse = getRouteWithHttpInfo(routeId = routeId, showInheritedProperties = showInheritedProperties)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Route
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /route/{routeId}
     * Get Route
     * Get an existing route
     * @param routeId the id of the route to get
     * @param showInheritedProperties return inherited properties from parent or not
     * @return ApiResponse<Route?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getRouteWithHttpInfo(routeId: kotlin.Long, showInheritedProperties: kotlin.Boolean) : ApiResponse<Route?> {
        val localVariableConfig = getRouteRequestConfig(routeId = routeId, showInheritedProperties = showInheritedProperties)

        return request<Unit, Route>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getRoute
     *
     * @param routeId the id of the route to get
     * @param showInheritedProperties return inherited properties from parent or not
     * @return RequestConfig
     */
    fun getRouteRequestConfig(routeId: kotlin.Long, showInheritedProperties: kotlin.Boolean) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("showInheritedProperties", listOf(showInheritedProperties.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/route/{routeId}".replace("{"+"routeId"+"}", encodeURIComponent(routeId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /route/{routeId}/directions
     * Get Route Directions
     * Get the directions of a route
     * @param routeId the id of the route to get directions for
     * @return kotlin.collections.List<Direction>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getRouteDirections(routeId: kotlin.Long) : kotlin.collections.List<Direction> {
        val localVarResponse = getRouteDirectionsWithHttpInfo(routeId = routeId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<Direction>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /route/{routeId}/directions
     * Get Route Directions
     * Get the directions of a route
     * @param routeId the id of the route to get directions for
     * @return ApiResponse<kotlin.collections.List<Direction>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getRouteDirectionsWithHttpInfo(routeId: kotlin.Long) : ApiResponse<kotlin.collections.List<Direction>?> {
        val localVariableConfig = getRouteDirectionsRequestConfig(routeId = routeId)

        return request<Unit, kotlin.collections.List<Direction>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getRouteDirections
     *
     * @param routeId the id of the route to get directions for
     * @return RequestConfig
     */
    fun getRouteDirectionsRequestConfig(routeId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/route/{routeId}/directions".replace("{"+"routeId"+"}", encodeURIComponent(routeId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /route/{routeId}/shipments
     * Get Route Shipments
     * Get the shipments on the requested route
     * @param routeId the id of the route to get shipments for
     * @return kotlin.collections.List<Shipment>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getRouteShipments(routeId: kotlin.Long) : kotlin.collections.List<Shipment> {
        val localVarResponse = getRouteShipmentsWithHttpInfo(routeId = routeId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<Shipment>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /route/{routeId}/shipments
     * Get Route Shipments
     * Get the shipments on the requested route
     * @param routeId the id of the route to get shipments for
     * @return ApiResponse<kotlin.collections.List<Shipment>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getRouteShipmentsWithHttpInfo(routeId: kotlin.Long) : ApiResponse<kotlin.collections.List<Shipment>?> {
        val localVariableConfig = getRouteShipmentsRequestConfig(routeId = routeId)

        return request<Unit, kotlin.collections.List<Shipment>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getRouteShipments
     *
     * @param routeId the id of the route to get shipments for
     * @return RequestConfig
     */
    fun getRouteShipmentsRequestConfig(routeId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/route/{routeId}/shipments".replace("{"+"routeId"+"}", encodeURIComponent(routeId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /route/{routeId}/stop/{stopId}
     * Get Route Stop
     * Get the specific stop on a route
     * @param routeId the id of the route to get stops for
     * @param stopId the id of the specific stop on the route
     * @return Stop
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getRouteStop(routeId: kotlin.Long, stopId: kotlin.Long) : Stop {
        val localVarResponse = getRouteStopWithHttpInfo(routeId = routeId, stopId = stopId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Stop
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /route/{routeId}/stop/{stopId}
     * Get Route Stop
     * Get the specific stop on a route
     * @param routeId the id of the route to get stops for
     * @param stopId the id of the specific stop on the route
     * @return ApiResponse<Stop?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getRouteStopWithHttpInfo(routeId: kotlin.Long, stopId: kotlin.Long) : ApiResponse<Stop?> {
        val localVariableConfig = getRouteStopRequestConfig(routeId = routeId, stopId = stopId)

        return request<Unit, Stop>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getRouteStop
     *
     * @param routeId the id of the route to get stops for
     * @param stopId the id of the specific stop on the route
     * @return RequestConfig
     */
    fun getRouteStopRequestConfig(routeId: kotlin.Long, stopId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/route/{routeId}/stop/{stopId}".replace("{"+"routeId"+"}", encodeURIComponent(routeId.toString())).replace("{"+"stopId"+"}", encodeURIComponent(stopId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /route/{routeId}/stops
     * Get Route Stops
     * The stops of the route requested
     * @param routeId the id of the route
     * @param confirmedOnly only get stops that have been confirmed or not
     * @return kotlin.collections.List<Stop>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getRouteStops(routeId: kotlin.Long, confirmedOnly: kotlin.Boolean) : kotlin.collections.List<Stop> {
        val localVarResponse = getRouteStopsWithHttpInfo(routeId = routeId, confirmedOnly = confirmedOnly)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<Stop>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /route/{routeId}/stops
     * Get Route Stops
     * The stops of the route requested
     * @param routeId the id of the route
     * @param confirmedOnly only get stops that have been confirmed or not
     * @return ApiResponse<kotlin.collections.List<Stop>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getRouteStopsWithHttpInfo(routeId: kotlin.Long, confirmedOnly: kotlin.Boolean) : ApiResponse<kotlin.collections.List<Stop>?> {
        val localVariableConfig = getRouteStopsRequestConfig(routeId = routeId, confirmedOnly = confirmedOnly)

        return request<Unit, kotlin.collections.List<Stop>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getRouteStops
     *
     * @param routeId the id of the route
     * @param confirmedOnly only get stops that have been confirmed or not
     * @return RequestConfig
     */
    fun getRouteStopsRequestConfig(routeId: kotlin.Long, confirmedOnly: kotlin.Boolean) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("confirmedOnly", listOf(confirmedOnly.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/route/{routeId}/stops".replace("{"+"routeId"+"}", encodeURIComponent(routeId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /route/{routeId}/stop/{stopId}/shipments
     * Get Shipments At Stop
     * Get the list of shipments on the requested route at a stop
     * @param routeId the id of the route
     * @param stopId the id of the stop to get shipments on
     * @return kotlin.collections.List<Shipment>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getShipmentsAtStop(routeId: kotlin.Long, stopId: kotlin.Long) : kotlin.collections.List<Shipment> {
        val localVarResponse = getShipmentsAtStopWithHttpInfo(routeId = routeId, stopId = stopId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<Shipment>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /route/{routeId}/stop/{stopId}/shipments
     * Get Shipments At Stop
     * Get the list of shipments on the requested route at a stop
     * @param routeId the id of the route
     * @param stopId the id of the stop to get shipments on
     * @return ApiResponse<kotlin.collections.List<Shipment>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getShipmentsAtStopWithHttpInfo(routeId: kotlin.Long, stopId: kotlin.Long) : ApiResponse<kotlin.collections.List<Shipment>?> {
        val localVariableConfig = getShipmentsAtStopRequestConfig(routeId = routeId, stopId = stopId)

        return request<Unit, kotlin.collections.List<Shipment>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getShipmentsAtStop
     *
     * @param routeId the id of the route
     * @param stopId the id of the stop to get shipments on
     * @return RequestConfig
     */
    fun getShipmentsAtStopRequestConfig(routeId: kotlin.Long, stopId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/route/{routeId}/stop/{stopId}/shipments".replace("{"+"routeId"+"}", encodeURIComponent(routeId.toString())).replace("{"+"stopId"+"}", encodeURIComponent(stopId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /route/{routeId}/optimize
     * Optimize Route
     * Optimize a route. The optimization method based on how the server is configured.
     * @param routeId the id of the route to optimize
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun optimizeRoute(routeId: kotlin.Long) : Unit {
        val localVarResponse = optimizeRouteWithHttpInfo(routeId = routeId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /route/{routeId}/optimize
     * Optimize Route
     * Optimize a route. The optimization method based on how the server is configured.
     * @param routeId the id of the route to optimize
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun optimizeRouteWithHttpInfo(routeId: kotlin.Long) : ApiResponse<Unit?> {
        val localVariableConfig = optimizeRouteRequestConfig(routeId = routeId)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation optimizeRoute
     *
     * @param routeId the id of the route to optimize
     * @return RequestConfig
     */
    fun optimizeRouteRequestConfig(routeId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/route/{routeId}/optimize".replace("{"+"routeId"+"}", encodeURIComponent(routeId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * DELETE /route/{routeId}/stop/{stopId}
     * Delete Stop
     * Delete a stop on a route
     * @param routeId the id of the route
     * @param stopId the id of the specific stop to delete on the route
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun removeStop(routeId: kotlin.Long, stopId: kotlin.Long) : Unit {
        val localVarResponse = removeStopWithHttpInfo(routeId = routeId, stopId = stopId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * DELETE /route/{routeId}/stop/{stopId}
     * Delete Stop
     * Delete a stop on a route
     * @param routeId the id of the route
     * @param stopId the id of the specific stop to delete on the route
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun removeStopWithHttpInfo(routeId: kotlin.Long, stopId: kotlin.Long) : ApiResponse<Unit?> {
        val localVariableConfig = removeStopRequestConfig(routeId = routeId, stopId = stopId)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation removeStop
     *
     * @param routeId the id of the route
     * @param stopId the id of the specific stop to delete on the route
     * @return RequestConfig
     */
    fun removeStopRequestConfig(routeId: kotlin.Long, stopId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/route/{routeId}/stop/{stopId}".replace("{"+"routeId"+"}", encodeURIComponent(routeId.toString())).replace("{"+"stopId"+"}", encodeURIComponent(stopId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * PATCH /route/{routeId}/stops/reorder
     * Reorder Route Stops
     * Reordering the stops on the route with and update route distance, time, direction, and polyline
     * @param routeId the id of the route
     * @param body  (optional)
     * @return kotlin.collections.List<Stop>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun reorderRouteStopsPatch(routeId: kotlin.Long, body: kotlin.collections.List<Stop>? = null) : kotlin.collections.List<Stop> {
        val localVarResponse = reorderRouteStopsPatchWithHttpInfo(routeId = routeId, body = body)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<Stop>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * PATCH /route/{routeId}/stops/reorder
     * Reorder Route Stops
     * Reordering the stops on the route with and update route distance, time, direction, and polyline
     * @param routeId the id of the route
     * @param body  (optional)
     * @return ApiResponse<kotlin.collections.List<Stop>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun reorderRouteStopsPatchWithHttpInfo(routeId: kotlin.Long, body: kotlin.collections.List<Stop>?) : ApiResponse<kotlin.collections.List<Stop>?> {
        val localVariableConfig = reorderRouteStopsPatchRequestConfig(routeId = routeId, body = body)

        return request<kotlin.collections.List<Stop>, kotlin.collections.List<Stop>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation reorderRouteStopsPatch
     *
     * @param routeId the id of the route
     * @param body  (optional)
     * @return RequestConfig
     */
    fun reorderRouteStopsPatchRequestConfig(routeId: kotlin.Long, body: kotlin.collections.List<Stop>?) : RequestConfig<kotlin.collections.List<Stop>> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/route/{routeId}/stops/reorder".replace("{"+"routeId"+"}", encodeURIComponent(routeId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /route/{routeId}/stops/reorder
     * Reorder Route Stops
     * Reordering the stops on the route with and update route distance, time, direction, and polyline
     * @param routeId the id of the route
     * @param body  (optional)
     * @return kotlin.collections.List<Stop>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun reorderRouteStopsPost(routeId: kotlin.Long, body: kotlin.collections.List<Stop>? = null) : kotlin.collections.List<Stop> {
        val localVarResponse = reorderRouteStopsPostWithHttpInfo(routeId = routeId, body = body)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<Stop>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /route/{routeId}/stops/reorder
     * Reorder Route Stops
     * Reordering the stops on the route with and update route distance, time, direction, and polyline
     * @param routeId the id of the route
     * @param body  (optional)
     * @return ApiResponse<kotlin.collections.List<Stop>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun reorderRouteStopsPostWithHttpInfo(routeId: kotlin.Long, body: kotlin.collections.List<Stop>?) : ApiResponse<kotlin.collections.List<Stop>?> {
        val localVariableConfig = reorderRouteStopsPostRequestConfig(routeId = routeId, body = body)

        return request<kotlin.collections.List<Stop>, kotlin.collections.List<Stop>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation reorderRouteStopsPost
     *
     * @param routeId the id of the route
     * @param body  (optional)
     * @return RequestConfig
     */
    fun reorderRouteStopsPostRequestConfig(routeId: kotlin.Long, body: kotlin.collections.List<Stop>?) : RequestConfig<kotlin.collections.List<Stop>> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/route/{routeId}/stops/reorder".replace("{"+"routeId"+"}", encodeURIComponent(routeId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /route
     * Search Routes
     * Search for routes.
     * @param sortField The field to sort by
     * @param descending Determines whether the sorted list is in descending or ascending order
     * @param start The start index for pagination
     * @param limit The limit for pagination
     * @param activeOnly Return only active results
     * @param includesEmpty Include empty routes or not
     * @param rootOnly Only return root instance routes
     * @param showInheritedProperties Display root route properties
     * @param hubId Filter results by service hub (optional)
     * @param programId Filter results by program (optional)
     * @param scheduledStart The start date to filter the results by (optional)
     * @param scheduledEnd The end date to filter the results by (optional)
     * @param updatedStart The lower bound of updated date (optional)
     * @param updatedEnd The upper bound of updated date (optional)
     * @param featured The route is featured or not (optional)
     * @param seatCount Has at least this many seat available (optional)
     * @param approved Has been approved or not (optional)
     * @param started Has started or not (optional)
     * @param completed Has completed or not (optional)
     * @param valid Is valid or not (optional)
     * @param parentId If it is a recurring route based on the parent route (optional)
     * @return kotlin.collections.List<Route>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun searchRoutes(sortField: kotlin.String, descending: kotlin.Boolean, start: kotlin.Int, limit: kotlin.Int, activeOnly: kotlin.Boolean, includesEmpty: kotlin.Boolean, rootOnly: kotlin.Boolean, showInheritedProperties: kotlin.Boolean, hubId: kotlin.Long? = null, programId: kotlin.Long? = null, scheduledStart: kotlin.Long? = null, scheduledEnd: kotlin.Long? = null, updatedStart: kotlin.Long? = null, updatedEnd: kotlin.Long? = null, featured: kotlin.Boolean? = null, seatCount: kotlin.Int? = null, approved: kotlin.Boolean? = null, started: kotlin.Boolean? = null, completed: kotlin.Boolean? = null, valid: kotlin.Boolean? = null, parentId: kotlin.Long? = null) : kotlin.collections.List<Route> {
        val localVarResponse = searchRoutesWithHttpInfo(sortField = sortField, descending = descending, start = start, limit = limit, activeOnly = activeOnly, includesEmpty = includesEmpty, rootOnly = rootOnly, showInheritedProperties = showInheritedProperties, hubId = hubId, programId = programId, scheduledStart = scheduledStart, scheduledEnd = scheduledEnd, updatedStart = updatedStart, updatedEnd = updatedEnd, featured = featured, seatCount = seatCount, approved = approved, started = started, completed = completed, valid = valid, parentId = parentId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<Route>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /route
     * Search Routes
     * Search for routes.
     * @param sortField The field to sort by
     * @param descending Determines whether the sorted list is in descending or ascending order
     * @param start The start index for pagination
     * @param limit The limit for pagination
     * @param activeOnly Return only active results
     * @param includesEmpty Include empty routes or not
     * @param rootOnly Only return root instance routes
     * @param showInheritedProperties Display root route properties
     * @param hubId Filter results by service hub (optional)
     * @param programId Filter results by program (optional)
     * @param scheduledStart The start date to filter the results by (optional)
     * @param scheduledEnd The end date to filter the results by (optional)
     * @param updatedStart The lower bound of updated date (optional)
     * @param updatedEnd The upper bound of updated date (optional)
     * @param featured The route is featured or not (optional)
     * @param seatCount Has at least this many seat available (optional)
     * @param approved Has been approved or not (optional)
     * @param started Has started or not (optional)
     * @param completed Has completed or not (optional)
     * @param valid Is valid or not (optional)
     * @param parentId If it is a recurring route based on the parent route (optional)
     * @return ApiResponse<kotlin.collections.List<Route>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun searchRoutesWithHttpInfo(sortField: kotlin.String, descending: kotlin.Boolean, start: kotlin.Int, limit: kotlin.Int, activeOnly: kotlin.Boolean, includesEmpty: kotlin.Boolean, rootOnly: kotlin.Boolean, showInheritedProperties: kotlin.Boolean, hubId: kotlin.Long?, programId: kotlin.Long?, scheduledStart: kotlin.Long?, scheduledEnd: kotlin.Long?, updatedStart: kotlin.Long?, updatedEnd: kotlin.Long?, featured: kotlin.Boolean?, seatCount: kotlin.Int?, approved: kotlin.Boolean?, started: kotlin.Boolean?, completed: kotlin.Boolean?, valid: kotlin.Boolean?, parentId: kotlin.Long?) : ApiResponse<kotlin.collections.List<Route>?> {
        val localVariableConfig = searchRoutesRequestConfig(sortField = sortField, descending = descending, start = start, limit = limit, activeOnly = activeOnly, includesEmpty = includesEmpty, rootOnly = rootOnly, showInheritedProperties = showInheritedProperties, hubId = hubId, programId = programId, scheduledStart = scheduledStart, scheduledEnd = scheduledEnd, updatedStart = updatedStart, updatedEnd = updatedEnd, featured = featured, seatCount = seatCount, approved = approved, started = started, completed = completed, valid = valid, parentId = parentId)

        return request<Unit, kotlin.collections.List<Route>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation searchRoutes
     *
     * @param sortField The field to sort by
     * @param descending Determines whether the sorted list is in descending or ascending order
     * @param start The start index for pagination
     * @param limit The limit for pagination
     * @param activeOnly Return only active results
     * @param includesEmpty Include empty routes or not
     * @param rootOnly Only return root instance routes
     * @param showInheritedProperties Display root route properties
     * @param hubId Filter results by service hub (optional)
     * @param programId Filter results by program (optional)
     * @param scheduledStart The start date to filter the results by (optional)
     * @param scheduledEnd The end date to filter the results by (optional)
     * @param updatedStart The lower bound of updated date (optional)
     * @param updatedEnd The upper bound of updated date (optional)
     * @param featured The route is featured or not (optional)
     * @param seatCount Has at least this many seat available (optional)
     * @param approved Has been approved or not (optional)
     * @param started Has started or not (optional)
     * @param completed Has completed or not (optional)
     * @param valid Is valid or not (optional)
     * @param parentId If it is a recurring route based on the parent route (optional)
     * @return RequestConfig
     */
    fun searchRoutesRequestConfig(sortField: kotlin.String, descending: kotlin.Boolean, start: kotlin.Int, limit: kotlin.Int, activeOnly: kotlin.Boolean, includesEmpty: kotlin.Boolean, rootOnly: kotlin.Boolean, showInheritedProperties: kotlin.Boolean, hubId: kotlin.Long?, programId: kotlin.Long?, scheduledStart: kotlin.Long?, scheduledEnd: kotlin.Long?, updatedStart: kotlin.Long?, updatedEnd: kotlin.Long?, featured: kotlin.Boolean?, seatCount: kotlin.Int?, approved: kotlin.Boolean?, started: kotlin.Boolean?, completed: kotlin.Boolean?, valid: kotlin.Boolean?, parentId: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (hubId != null) {
                    put("hubId", listOf(hubId.toString()))
                }
                if (programId != null) {
                    put("programId", listOf(programId.toString()))
                }
                if (scheduledStart != null) {
                    put("scheduledStart", listOf(scheduledStart.toString()))
                }
                if (scheduledEnd != null) {
                    put("scheduledEnd", listOf(scheduledEnd.toString()))
                }
                if (updatedStart != null) {
                    put("updatedStart", listOf(updatedStart.toString()))
                }
                if (updatedEnd != null) {
                    put("updatedEnd", listOf(updatedEnd.toString()))
                }
                if (featured != null) {
                    put("featured", listOf(featured.toString()))
                }
                if (seatCount != null) {
                    put("seatCount", listOf(seatCount.toString()))
                }
                if (approved != null) {
                    put("approved", listOf(approved.toString()))
                }
                if (started != null) {
                    put("started", listOf(started.toString()))
                }
                if (completed != null) {
                    put("completed", listOf(completed.toString()))
                }
                if (valid != null) {
                    put("valid", listOf(valid.toString()))
                }
                if (parentId != null) {
                    put("parentId", listOf(parentId.toString()))
                }
                put("sortField", listOf(sortField.toString()))
                put("descending", listOf(descending.toString()))
                put("start", listOf(start.toString()))
                put("limit", listOf(limit.toString()))
                put("activeOnly", listOf(activeOnly.toString()))
                put("includesEmpty", listOf(includesEmpty.toString()))
                put("rootOnly", listOf(rootOnly.toString()))
                put("showInheritedProperties", listOf(showInheritedProperties.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/route",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /route/{id}/driver/{driverId}
     * Set Driver
     * Update the driver of the route.
     * @param id the id of the route
     * @param driverId the id of the driver
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun setDriver(id: kotlin.Long, driverId: kotlin.Long) : Unit {
        val localVarResponse = setDriverWithHttpInfo(id = id, driverId = driverId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /route/{id}/driver/{driverId}
     * Set Driver
     * Update the driver of the route.
     * @param id the id of the route
     * @param driverId the id of the driver
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun setDriverWithHttpInfo(id: kotlin.Long, driverId: kotlin.Long) : ApiResponse<Unit?> {
        val localVariableConfig = setDriverRequestConfig(id = id, driverId = driverId)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation setDriver
     *
     * @param id the id of the route
     * @param driverId the id of the driver
     * @return RequestConfig
     */
    fun setDriverRequestConfig(id: kotlin.Long, driverId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/route/{id}/driver/{driverId}".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"driverId"+"}", encodeURIComponent(driverId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * PUT /route/{routeId}
     * Update Route
     * Update an existing route
     * @param routeId the id of the route
     * @param body  (optional)
     * @return Route
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updateRoute(routeId: kotlin.Long, body: Route? = null) : Route {
        val localVarResponse = updateRouteWithHttpInfo(routeId = routeId, body = body)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Route
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * PUT /route/{routeId}
     * Update Route
     * Update an existing route
     * @param routeId the id of the route
     * @param body  (optional)
     * @return ApiResponse<Route?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun updateRouteWithHttpInfo(routeId: kotlin.Long, body: Route?) : ApiResponse<Route?> {
        val localVariableConfig = updateRouteRequestConfig(routeId = routeId, body = body)

        return request<Route, Route>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateRoute
     *
     * @param routeId the id of the route
     * @param body  (optional)
     * @return RequestConfig
     */
    fun updateRouteRequestConfig(routeId: kotlin.Long, body: Route?) : RequestConfig<Route> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/route/{routeId}".replace("{"+"routeId"+"}", encodeURIComponent(routeId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * PUT /route/{routeId}/stop/{stopId}
     * Update Route Stop
     * Update a stop on a specified route
     * @param routeId the id of the route to update stops for
     * @param stopId the id of the specific stop to update on the route
     * @param body  (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updateRouteStop(routeId: kotlin.Long, stopId: kotlin.Long, body: Stop? = null) : Unit {
        val localVarResponse = updateRouteStopWithHttpInfo(routeId = routeId, stopId = stopId, body = body)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * PUT /route/{routeId}/stop/{stopId}
     * Update Route Stop
     * Update a stop on a specified route
     * @param routeId the id of the route to update stops for
     * @param stopId the id of the specific stop to update on the route
     * @param body  (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun updateRouteStopWithHttpInfo(routeId: kotlin.Long, stopId: kotlin.Long, body: Stop?) : ApiResponse<Unit?> {
        val localVariableConfig = updateRouteStopRequestConfig(routeId = routeId, stopId = stopId, body = body)

        return request<Stop, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateRouteStop
     *
     * @param routeId the id of the route to update stops for
     * @param stopId the id of the specific stop to update on the route
     * @param body  (optional)
     * @return RequestConfig
     */
    fun updateRouteStopRequestConfig(routeId: kotlin.Long, stopId: kotlin.Long, body: Stop?) : RequestConfig<Stop> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/route/{routeId}/stop/{stopId}".replace("{"+"routeId"+"}", encodeURIComponent(routeId.toString())).replace("{"+"stopId"+"}", encodeURIComponent(stopId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
