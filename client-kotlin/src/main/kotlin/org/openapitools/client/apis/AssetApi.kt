/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import org.openapitools.client.models.AssetFullResponse
import org.openapitools.client.models.AssetResponse
import org.openapitools.client.models.AssetShortResponse
import org.openapitools.client.models.SirqulResponse

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

open class AssetApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://dev.sirqul.com/api/3.18")
        }
    }

    /**
     * GET /asset/download/{filename}
     * Download Asset
     * Downloads an asset from the server for assets that have been uploaded to the server.
     * @param filename the filename in the following formats: {assetId}-{suffix}.{extension} | {assetId}.{extension} | {assetId}
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun assetDownload(filename: kotlin.String) : SirqulResponse {
        val localVarResponse = assetDownloadWithHttpInfo(filename = filename)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /asset/download/{filename}
     * Download Asset
     * Downloads an asset from the server for assets that have been uploaded to the server.
     * @param filename the filename in the following formats: {assetId}-{suffix}.{extension} | {assetId}.{extension} | {assetId}
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun assetDownloadWithHttpInfo(filename: kotlin.String) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = assetDownloadRequestConfig(filename = filename)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation assetDownload
     *
     * @param filename the filename in the following formats: {assetId}-{suffix}.{extension} | {assetId}.{extension} | {assetId}
     * @return RequestConfig
     */
    fun assetDownloadRequestConfig(filename: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/asset/download/{filename}".replace("{"+"filename"+"}", encodeURIComponent(filename.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter adSize
     */
     enum class AdSizeAssetMorph(val value: kotlin.String) {
         @Json(name = "CONFIG") CONFIG("CONFIG"),
         @Json(name = "BANNER") BANNER("BANNER"),
         @Json(name = "LEADERBOARD") LEADERBOARD("LEADERBOARD"),
         @Json(name = "SKYSCRAPER") SKYSCRAPER("SKYSCRAPER"),
         @Json(name = "VIDEO") VIDEO("VIDEO"),
         @Json(name = "ZIP") ZIP("ZIP"),
         @Json(name = "INTERSTITIAL") INTERSTITIAL("INTERSTITIAL"),
         @Json(name = "CUSTOM1") CUSTOM1("CUSTOM1"),
         @Json(name = "CUSTOM2") CUSTOM2("CUSTOM2"),
         @Json(name = "CUSTOM3") CUSTOM3("CUSTOM3"),
         @Json(name = "CUSTOM4") CUSTOM4("CUSTOM4"),
         @Json(name = "CUSTOM5") CUSTOM5("CUSTOM5"),
         @Json(name = "CUSTOM6") CUSTOM6("CUSTOM6"),
         @Json(name = "CUSTOM7") CUSTOM7("CUSTOM7"),
         @Json(name = "CUSTOM8") CUSTOM8("CUSTOM8"),
         @Json(name = "CUSTOM9") CUSTOM9("CUSTOM9"),
         @Json(name = "CUSTOM10") CUSTOM10("CUSTOM10");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * POST /asset/morph
     * Convert Offer to Creative
     * Converts an offer image + text into a creative image.
     * @param offerId offer id used for inserting offer text/flavor
     * @param adSize the ad size used for selecting a format for the creative image
     * @param creativeId used for inserting the newly created image into (optional)
     * @param width total width of the creative image (optional)
     * @param height total height of the creative image (optional)
     * @param backgroundSize the size of the background (optional)
     * @param template the template to use (optional)
     * @return AssetShortResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun assetMorph(offerId: kotlin.Long, adSize: AdSizeAssetMorph, creativeId: kotlin.Long? = null, width: kotlin.Int? = null, height: kotlin.Int? = null, backgroundSize: kotlin.String? = null, template: kotlin.String? = null) : AssetShortResponse {
        val localVarResponse = assetMorphWithHttpInfo(offerId = offerId, adSize = adSize, creativeId = creativeId, width = width, height = height, backgroundSize = backgroundSize, template = template)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AssetShortResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /asset/morph
     * Convert Offer to Creative
     * Converts an offer image + text into a creative image.
     * @param offerId offer id used for inserting offer text/flavor
     * @param adSize the ad size used for selecting a format for the creative image
     * @param creativeId used for inserting the newly created image into (optional)
     * @param width total width of the creative image (optional)
     * @param height total height of the creative image (optional)
     * @param backgroundSize the size of the background (optional)
     * @param template the template to use (optional)
     * @return ApiResponse<AssetShortResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun assetMorphWithHttpInfo(offerId: kotlin.Long, adSize: AdSizeAssetMorph, creativeId: kotlin.Long?, width: kotlin.Int?, height: kotlin.Int?, backgroundSize: kotlin.String?, template: kotlin.String?) : ApiResponse<AssetShortResponse?> {
        val localVariableConfig = assetMorphRequestConfig(offerId = offerId, adSize = adSize, creativeId = creativeId, width = width, height = height, backgroundSize = backgroundSize, template = template)

        return request<Unit, AssetShortResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation assetMorph
     *
     * @param offerId offer id used for inserting offer text/flavor
     * @param adSize the ad size used for selecting a format for the creative image
     * @param creativeId used for inserting the newly created image into (optional)
     * @param width total width of the creative image (optional)
     * @param height total height of the creative image (optional)
     * @param backgroundSize the size of the background (optional)
     * @param template the template to use (optional)
     * @return RequestConfig
     */
    fun assetMorphRequestConfig(offerId: kotlin.Long, adSize: AdSizeAssetMorph, creativeId: kotlin.Long?, width: kotlin.Int?, height: kotlin.Int?, backgroundSize: kotlin.String?, template: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("offerId", listOf(offerId.toString()))
                if (creativeId != null) {
                    put("creativeId", listOf(creativeId.toString()))
                }
                put("adSize", listOf(adSize.value))
                if (width != null) {
                    put("width", listOf(width.toString()))
                }
                if (height != null) {
                    put("height", listOf(height.toString()))
                }
                if (backgroundSize != null) {
                    put("backgroundSize", listOf(backgroundSize.toString()))
                }
                if (template != null) {
                    put("template", listOf(template.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/asset/morph",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /asset/create
     * Create Asset
     * Uploads an asset to server and returns an asset id which can be used to assign to various objects.
     * @param returnNulls to return nulls (optional)
     * @param deviceId a unique ID given by the device (deviceId or accountId required) (optional)
     * @param accountId the account ID of the user (deviceId or accountId required) (optional)
     * @param albumId the album the asset will be added to (optional) (optional)
     * @param collectionId Deprecated: use collections via the collection endpoints. (optional)
     * @param addToDefaultAlbum Whether to add to a default album (optional)
     * @param addToMediaLibrary Whether to add to the media library (optional)
     * @param versionCode the version code (optional)
     * @param versionName the version name (optional)
     * @param metaData External custom client defined data (optional)
     * @param caption the caption (optional) (optional)
     * @param assetType the asset type (optional)
     * @param approvalStatus approval status for the asset (optional)
     * @param assignedAccountId account id assigned to the asset (optional)
     * @param media a MultipartFile containing the mimetype, etc (optional)
     * @param mediaUrl this can be used if the \&quot;media\&quot; is a link (optional) (optional)
     * @param mediaString the media content as a string (optional) (optional)
     * @param mediaStringFileName file name for mediaString (optional) (optional)
     * @param mediaStringContentType content type for mediaString (optional) (optional)
     * @param mediaHeight the media height (optional) (optional)
     * @param mediaWidth the media width (optional) (optional)
     * @param attachedMedia a MultipartFile containing an asset that the \&quot;media\&quot; file references (optional). Example: to upload a video the \&quot;media\&quot; file should contain a screen capture and the \&quot;attachedMedia\&quot; should be the actual video. (optional)
     * @param attachedMediaUrl this can be used if the \&quot;attachedMedia\&quot; is a link (i.e. a Youtube video, etc) (optional) (optional)
     * @param attachedMediaString attached media content as a string (optional) (optional)
     * @param attachedMediaStringFileName file name for attachedMediaString (optional) (optional)
     * @param attachedMediaStringContentType content type for attachedMediaString (optional) (optional)
     * @param attachedMediaHeight the attached media height (optional) (optional)
     * @param attachedMediaWidth the attached media width (optional) (optional)
     * @param locationDescription the location description (optional) (optional)
     * @param app Deprecated: app parameter (optional)
     * @param appKey the application key (optional)
     * @param searchTags the search tags (optional)
     * @param latitude the latitude (optional) (optional)
     * @param longitude the longitude (optional) (optional)
     * @return AssetResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createAsset(returnNulls: kotlin.Boolean? = null, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, albumId: kotlin.Long? = null, collectionId: kotlin.Long? = null, addToDefaultAlbum: kotlin.String? = null, addToMediaLibrary: kotlin.Boolean? = null, versionCode: kotlin.Int? = null, versionName: kotlin.String? = null, metaData: kotlin.String? = null, caption: kotlin.String? = null, assetType: kotlin.String? = null, approvalStatus: kotlin.String? = null, assignedAccountId: kotlin.Long? = null, media: java.io.File? = null, mediaUrl: kotlin.String? = null, mediaString: kotlin.String? = null, mediaStringFileName: kotlin.String? = null, mediaStringContentType: kotlin.String? = null, mediaHeight: kotlin.Int? = null, mediaWidth: kotlin.Int? = null, attachedMedia: java.io.File? = null, attachedMediaUrl: kotlin.String? = null, attachedMediaString: kotlin.String? = null, attachedMediaStringFileName: kotlin.String? = null, attachedMediaStringContentType: kotlin.String? = null, attachedMediaHeight: kotlin.Int? = null, attachedMediaWidth: kotlin.Int? = null, locationDescription: kotlin.String? = null, app: kotlin.String? = null, appKey: kotlin.String? = null, searchTags: kotlin.String? = null, latitude: kotlin.Double? = null, longitude: kotlin.Double? = null) : AssetResponse {
        val localVarResponse = createAssetWithHttpInfo(returnNulls = returnNulls, deviceId = deviceId, accountId = accountId, albumId = albumId, collectionId = collectionId, addToDefaultAlbum = addToDefaultAlbum, addToMediaLibrary = addToMediaLibrary, versionCode = versionCode, versionName = versionName, metaData = metaData, caption = caption, assetType = assetType, approvalStatus = approvalStatus, assignedAccountId = assignedAccountId, media = media, mediaUrl = mediaUrl, mediaString = mediaString, mediaStringFileName = mediaStringFileName, mediaStringContentType = mediaStringContentType, mediaHeight = mediaHeight, mediaWidth = mediaWidth, attachedMedia = attachedMedia, attachedMediaUrl = attachedMediaUrl, attachedMediaString = attachedMediaString, attachedMediaStringFileName = attachedMediaStringFileName, attachedMediaStringContentType = attachedMediaStringContentType, attachedMediaHeight = attachedMediaHeight, attachedMediaWidth = attachedMediaWidth, locationDescription = locationDescription, app = app, appKey = appKey, searchTags = searchTags, latitude = latitude, longitude = longitude)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AssetResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /asset/create
     * Create Asset
     * Uploads an asset to server and returns an asset id which can be used to assign to various objects.
     * @param returnNulls to return nulls (optional)
     * @param deviceId a unique ID given by the device (deviceId or accountId required) (optional)
     * @param accountId the account ID of the user (deviceId or accountId required) (optional)
     * @param albumId the album the asset will be added to (optional) (optional)
     * @param collectionId Deprecated: use collections via the collection endpoints. (optional)
     * @param addToDefaultAlbum Whether to add to a default album (optional)
     * @param addToMediaLibrary Whether to add to the media library (optional)
     * @param versionCode the version code (optional)
     * @param versionName the version name (optional)
     * @param metaData External custom client defined data (optional)
     * @param caption the caption (optional) (optional)
     * @param assetType the asset type (optional)
     * @param approvalStatus approval status for the asset (optional)
     * @param assignedAccountId account id assigned to the asset (optional)
     * @param media a MultipartFile containing the mimetype, etc (optional)
     * @param mediaUrl this can be used if the \&quot;media\&quot; is a link (optional) (optional)
     * @param mediaString the media content as a string (optional) (optional)
     * @param mediaStringFileName file name for mediaString (optional) (optional)
     * @param mediaStringContentType content type for mediaString (optional) (optional)
     * @param mediaHeight the media height (optional) (optional)
     * @param mediaWidth the media width (optional) (optional)
     * @param attachedMedia a MultipartFile containing an asset that the \&quot;media\&quot; file references (optional). Example: to upload a video the \&quot;media\&quot; file should contain a screen capture and the \&quot;attachedMedia\&quot; should be the actual video. (optional)
     * @param attachedMediaUrl this can be used if the \&quot;attachedMedia\&quot; is a link (i.e. a Youtube video, etc) (optional) (optional)
     * @param attachedMediaString attached media content as a string (optional) (optional)
     * @param attachedMediaStringFileName file name for attachedMediaString (optional) (optional)
     * @param attachedMediaStringContentType content type for attachedMediaString (optional) (optional)
     * @param attachedMediaHeight the attached media height (optional) (optional)
     * @param attachedMediaWidth the attached media width (optional) (optional)
     * @param locationDescription the location description (optional) (optional)
     * @param app Deprecated: app parameter (optional)
     * @param appKey the application key (optional)
     * @param searchTags the search tags (optional)
     * @param latitude the latitude (optional) (optional)
     * @param longitude the longitude (optional) (optional)
     * @return ApiResponse<AssetResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createAssetWithHttpInfo(returnNulls: kotlin.Boolean?, deviceId: kotlin.String?, accountId: kotlin.Long?, albumId: kotlin.Long?, collectionId: kotlin.Long?, addToDefaultAlbum: kotlin.String?, addToMediaLibrary: kotlin.Boolean?, versionCode: kotlin.Int?, versionName: kotlin.String?, metaData: kotlin.String?, caption: kotlin.String?, assetType: kotlin.String?, approvalStatus: kotlin.String?, assignedAccountId: kotlin.Long?, media: java.io.File?, mediaUrl: kotlin.String?, mediaString: kotlin.String?, mediaStringFileName: kotlin.String?, mediaStringContentType: kotlin.String?, mediaHeight: kotlin.Int?, mediaWidth: kotlin.Int?, attachedMedia: java.io.File?, attachedMediaUrl: kotlin.String?, attachedMediaString: kotlin.String?, attachedMediaStringFileName: kotlin.String?, attachedMediaStringContentType: kotlin.String?, attachedMediaHeight: kotlin.Int?, attachedMediaWidth: kotlin.Int?, locationDescription: kotlin.String?, app: kotlin.String?, appKey: kotlin.String?, searchTags: kotlin.String?, latitude: kotlin.Double?, longitude: kotlin.Double?) : ApiResponse<AssetResponse?> {
        val localVariableConfig = createAssetRequestConfig(returnNulls = returnNulls, deviceId = deviceId, accountId = accountId, albumId = albumId, collectionId = collectionId, addToDefaultAlbum = addToDefaultAlbum, addToMediaLibrary = addToMediaLibrary, versionCode = versionCode, versionName = versionName, metaData = metaData, caption = caption, assetType = assetType, approvalStatus = approvalStatus, assignedAccountId = assignedAccountId, media = media, mediaUrl = mediaUrl, mediaString = mediaString, mediaStringFileName = mediaStringFileName, mediaStringContentType = mediaStringContentType, mediaHeight = mediaHeight, mediaWidth = mediaWidth, attachedMedia = attachedMedia, attachedMediaUrl = attachedMediaUrl, attachedMediaString = attachedMediaString, attachedMediaStringFileName = attachedMediaStringFileName, attachedMediaStringContentType = attachedMediaStringContentType, attachedMediaHeight = attachedMediaHeight, attachedMediaWidth = attachedMediaWidth, locationDescription = locationDescription, app = app, appKey = appKey, searchTags = searchTags, latitude = latitude, longitude = longitude)

        return request<Unit, AssetResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createAsset
     *
     * @param returnNulls to return nulls (optional)
     * @param deviceId a unique ID given by the device (deviceId or accountId required) (optional)
     * @param accountId the account ID of the user (deviceId or accountId required) (optional)
     * @param albumId the album the asset will be added to (optional) (optional)
     * @param collectionId Deprecated: use collections via the collection endpoints. (optional)
     * @param addToDefaultAlbum Whether to add to a default album (optional)
     * @param addToMediaLibrary Whether to add to the media library (optional)
     * @param versionCode the version code (optional)
     * @param versionName the version name (optional)
     * @param metaData External custom client defined data (optional)
     * @param caption the caption (optional) (optional)
     * @param assetType the asset type (optional)
     * @param approvalStatus approval status for the asset (optional)
     * @param assignedAccountId account id assigned to the asset (optional)
     * @param media a MultipartFile containing the mimetype, etc (optional)
     * @param mediaUrl this can be used if the \&quot;media\&quot; is a link (optional) (optional)
     * @param mediaString the media content as a string (optional) (optional)
     * @param mediaStringFileName file name for mediaString (optional) (optional)
     * @param mediaStringContentType content type for mediaString (optional) (optional)
     * @param mediaHeight the media height (optional) (optional)
     * @param mediaWidth the media width (optional) (optional)
     * @param attachedMedia a MultipartFile containing an asset that the \&quot;media\&quot; file references (optional). Example: to upload a video the \&quot;media\&quot; file should contain a screen capture and the \&quot;attachedMedia\&quot; should be the actual video. (optional)
     * @param attachedMediaUrl this can be used if the \&quot;attachedMedia\&quot; is a link (i.e. a Youtube video, etc) (optional) (optional)
     * @param attachedMediaString attached media content as a string (optional) (optional)
     * @param attachedMediaStringFileName file name for attachedMediaString (optional) (optional)
     * @param attachedMediaStringContentType content type for attachedMediaString (optional) (optional)
     * @param attachedMediaHeight the attached media height (optional) (optional)
     * @param attachedMediaWidth the attached media width (optional) (optional)
     * @param locationDescription the location description (optional) (optional)
     * @param app Deprecated: app parameter (optional)
     * @param appKey the application key (optional)
     * @param searchTags the search tags (optional)
     * @param latitude the latitude (optional) (optional)
     * @param longitude the longitude (optional) (optional)
     * @return RequestConfig
     */
    fun createAssetRequestConfig(returnNulls: kotlin.Boolean?, deviceId: kotlin.String?, accountId: kotlin.Long?, albumId: kotlin.Long?, collectionId: kotlin.Long?, addToDefaultAlbum: kotlin.String?, addToMediaLibrary: kotlin.Boolean?, versionCode: kotlin.Int?, versionName: kotlin.String?, metaData: kotlin.String?, caption: kotlin.String?, assetType: kotlin.String?, approvalStatus: kotlin.String?, assignedAccountId: kotlin.Long?, media: java.io.File?, mediaUrl: kotlin.String?, mediaString: kotlin.String?, mediaStringFileName: kotlin.String?, mediaStringContentType: kotlin.String?, mediaHeight: kotlin.Int?, mediaWidth: kotlin.Int?, attachedMedia: java.io.File?, attachedMediaUrl: kotlin.String?, attachedMediaString: kotlin.String?, attachedMediaStringFileName: kotlin.String?, attachedMediaStringContentType: kotlin.String?, attachedMediaHeight: kotlin.Int?, attachedMediaWidth: kotlin.Int?, locationDescription: kotlin.String?, app: kotlin.String?, appKey: kotlin.String?, searchTags: kotlin.String?, latitude: kotlin.Double?, longitude: kotlin.Double?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (returnNulls != null) {
                    put("returnNulls", listOf(returnNulls.toString()))
                }
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (albumId != null) {
                    put("albumId", listOf(albumId.toString()))
                }
                if (collectionId != null) {
                    put("collectionId", listOf(collectionId.toString()))
                }
                if (addToDefaultAlbum != null) {
                    put("addToDefaultAlbum", listOf(addToDefaultAlbum.toString()))
                }
                if (addToMediaLibrary != null) {
                    put("addToMediaLibrary", listOf(addToMediaLibrary.toString()))
                }
                if (versionCode != null) {
                    put("versionCode", listOf(versionCode.toString()))
                }
                if (versionName != null) {
                    put("versionName", listOf(versionName.toString()))
                }
                if (metaData != null) {
                    put("metaData", listOf(metaData.toString()))
                }
                if (caption != null) {
                    put("caption", listOf(caption.toString()))
                }
                if (assetType != null) {
                    put("assetType", listOf(assetType.toString()))
                }
                if (approvalStatus != null) {
                    put("approvalStatus", listOf(approvalStatus.toString()))
                }
                if (assignedAccountId != null) {
                    put("assignedAccountId", listOf(assignedAccountId.toString()))
                }
                if (media != null) {
                    put("media", listOf(media.toString()))
                }
                if (mediaUrl != null) {
                    put("mediaUrl", listOf(mediaUrl.toString()))
                }
                if (mediaString != null) {
                    put("mediaString", listOf(mediaString.toString()))
                }
                if (mediaStringFileName != null) {
                    put("mediaStringFileName", listOf(mediaStringFileName.toString()))
                }
                if (mediaStringContentType != null) {
                    put("mediaStringContentType", listOf(mediaStringContentType.toString()))
                }
                if (mediaHeight != null) {
                    put("mediaHeight", listOf(mediaHeight.toString()))
                }
                if (mediaWidth != null) {
                    put("mediaWidth", listOf(mediaWidth.toString()))
                }
                if (attachedMedia != null) {
                    put("attachedMedia", listOf(attachedMedia.toString()))
                }
                if (attachedMediaUrl != null) {
                    put("attachedMediaUrl", listOf(attachedMediaUrl.toString()))
                }
                if (attachedMediaString != null) {
                    put("attachedMediaString", listOf(attachedMediaString.toString()))
                }
                if (attachedMediaStringFileName != null) {
                    put("attachedMediaStringFileName", listOf(attachedMediaStringFileName.toString()))
                }
                if (attachedMediaStringContentType != null) {
                    put("attachedMediaStringContentType", listOf(attachedMediaStringContentType.toString()))
                }
                if (attachedMediaHeight != null) {
                    put("attachedMediaHeight", listOf(attachedMediaHeight.toString()))
                }
                if (attachedMediaWidth != null) {
                    put("attachedMediaWidth", listOf(attachedMediaWidth.toString()))
                }
                if (locationDescription != null) {
                    put("locationDescription", listOf(locationDescription.toString()))
                }
                if (app != null) {
                    put("app", listOf(app.toString()))
                }
                if (appKey != null) {
                    put("appKey", listOf(appKey.toString()))
                }
                if (searchTags != null) {
                    put("searchTags", listOf(searchTags.toString()))
                }
                if (latitude != null) {
                    put("latitude", listOf(latitude.toString()))
                }
                if (longitude != null) {
                    put("longitude", listOf(longitude.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/asset/create",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /asset/delete
     * Delete Asset
     * Delete an asset.
     * @param assetId the id of the asset to delete
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param latitude latitude used to update the user&#39;s current location (optional)
     * @param longitude longitude used to update the user&#39;s current location (optional)
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteAsset(assetId: kotlin.String, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, latitude: kotlin.Double? = null, longitude: kotlin.Double? = null) : SirqulResponse {
        val localVarResponse = deleteAssetWithHttpInfo(assetId = assetId, deviceId = deviceId, accountId = accountId, latitude = latitude, longitude = longitude)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /asset/delete
     * Delete Asset
     * Delete an asset.
     * @param assetId the id of the asset to delete
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param latitude latitude used to update the user&#39;s current location (optional)
     * @param longitude longitude used to update the user&#39;s current location (optional)
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteAssetWithHttpInfo(assetId: kotlin.String, deviceId: kotlin.String?, accountId: kotlin.Long?, latitude: kotlin.Double?, longitude: kotlin.Double?) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = deleteAssetRequestConfig(assetId = assetId, deviceId = deviceId, accountId = accountId, latitude = latitude, longitude = longitude)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteAsset
     *
     * @param assetId the id of the asset to delete
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param latitude latitude used to update the user&#39;s current location (optional)
     * @param longitude longitude used to update the user&#39;s current location (optional)
     * @return RequestConfig
     */
    fun deleteAssetRequestConfig(assetId: kotlin.String, deviceId: kotlin.String?, accountId: kotlin.Long?, latitude: kotlin.Double?, longitude: kotlin.Double?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                put("assetId", listOf(assetId.toString()))
                if (latitude != null) {
                    put("latitude", listOf(latitude.toString()))
                }
                if (longitude != null) {
                    put("longitude", listOf(longitude.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/asset/delete",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /asset/get
     * Get Asset
     * Gets the full asset response including attached likes and notes.
     * @param assetId the asset ID
     * @param deviceId a unique ID given by the device (deviceId or accountId required) (optional)
     * @param accountId the account ID of the user (deviceId or accountId required) (optional)
     * @param noteDescending determines whether the notes on the asset are in descending order (optional, default to false)
     * @return AssetFullResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAsset(assetId: kotlin.Long, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, noteDescending: kotlin.Boolean? = false) : AssetFullResponse {
        val localVarResponse = getAssetWithHttpInfo(assetId = assetId, deviceId = deviceId, accountId = accountId, noteDescending = noteDescending)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AssetFullResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /asset/get
     * Get Asset
     * Gets the full asset response including attached likes and notes.
     * @param assetId the asset ID
     * @param deviceId a unique ID given by the device (deviceId or accountId required) (optional)
     * @param accountId the account ID of the user (deviceId or accountId required) (optional)
     * @param noteDescending determines whether the notes on the asset are in descending order (optional, default to false)
     * @return ApiResponse<AssetFullResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getAssetWithHttpInfo(assetId: kotlin.Long, deviceId: kotlin.String?, accountId: kotlin.Long?, noteDescending: kotlin.Boolean?) : ApiResponse<AssetFullResponse?> {
        val localVariableConfig = getAssetRequestConfig(assetId = assetId, deviceId = deviceId, accountId = accountId, noteDescending = noteDescending)

        return request<Unit, AssetFullResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAsset
     *
     * @param assetId the asset ID
     * @param deviceId a unique ID given by the device (deviceId or accountId required) (optional)
     * @param accountId the account ID of the user (deviceId or accountId required) (optional)
     * @param noteDescending determines whether the notes on the asset are in descending order (optional, default to false)
     * @return RequestConfig
     */
    fun getAssetRequestConfig(assetId: kotlin.Long, deviceId: kotlin.String?, accountId: kotlin.Long?, noteDescending: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                put("assetId", listOf(assetId.toString()))
                if (noteDescending != null) {
                    put("noteDescending", listOf(noteDescending.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/asset/get",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /asset/remove
     * Remove Asset from Collection
     * Remove assets from collections
     * @param assetId the id of the asset to remove
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param albumId the album id to remove the asset from (optional)
     * @param collectionId the collection id to remove the asset from (optional)
     * @param removeFromDefaultAlbums remove from the user&#39;s profile album (optional)
     * @param latitude latitude used to update the user&#39;s current location (optional)
     * @param longitude longitude used to update the user&#39;s current location (optional)
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun removeAsset(assetId: kotlin.String, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, albumId: kotlin.Long? = null, collectionId: kotlin.Long? = null, removeFromDefaultAlbums: kotlin.Boolean? = null, latitude: kotlin.Double? = null, longitude: kotlin.Double? = null) : SirqulResponse {
        val localVarResponse = removeAssetWithHttpInfo(assetId = assetId, deviceId = deviceId, accountId = accountId, albumId = albumId, collectionId = collectionId, removeFromDefaultAlbums = removeFromDefaultAlbums, latitude = latitude, longitude = longitude)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /asset/remove
     * Remove Asset from Collection
     * Remove assets from collections
     * @param assetId the id of the asset to remove
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param albumId the album id to remove the asset from (optional)
     * @param collectionId the collection id to remove the asset from (optional)
     * @param removeFromDefaultAlbums remove from the user&#39;s profile album (optional)
     * @param latitude latitude used to update the user&#39;s current location (optional)
     * @param longitude longitude used to update the user&#39;s current location (optional)
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun removeAssetWithHttpInfo(assetId: kotlin.String, deviceId: kotlin.String?, accountId: kotlin.Long?, albumId: kotlin.Long?, collectionId: kotlin.Long?, removeFromDefaultAlbums: kotlin.Boolean?, latitude: kotlin.Double?, longitude: kotlin.Double?) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = removeAssetRequestConfig(assetId = assetId, deviceId = deviceId, accountId = accountId, albumId = albumId, collectionId = collectionId, removeFromDefaultAlbums = removeFromDefaultAlbums, latitude = latitude, longitude = longitude)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation removeAsset
     *
     * @param assetId the id of the asset to remove
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param albumId the album id to remove the asset from (optional)
     * @param collectionId the collection id to remove the asset from (optional)
     * @param removeFromDefaultAlbums remove from the user&#39;s profile album (optional)
     * @param latitude latitude used to update the user&#39;s current location (optional)
     * @param longitude longitude used to update the user&#39;s current location (optional)
     * @return RequestConfig
     */
    fun removeAssetRequestConfig(assetId: kotlin.String, deviceId: kotlin.String?, accountId: kotlin.Long?, albumId: kotlin.Long?, collectionId: kotlin.Long?, removeFromDefaultAlbums: kotlin.Boolean?, latitude: kotlin.Double?, longitude: kotlin.Double?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (albumId != null) {
                    put("albumId", listOf(albumId.toString()))
                }
                if (collectionId != null) {
                    put("collectionId", listOf(collectionId.toString()))
                }
                put("assetId", listOf(assetId.toString()))
                if (removeFromDefaultAlbums != null) {
                    put("removeFromDefaultAlbums", listOf(removeFromDefaultAlbums.toString()))
                }
                if (latitude != null) {
                    put("latitude", listOf(latitude.toString()))
                }
                if (longitude != null) {
                    put("longitude", listOf(longitude.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/asset/remove",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /asset/search
     * Search Assets
     * Searches for assets
     * @param deviceId a unique ID given by the device (deviceId or accountId required) (optional)
     * @param accountId the account ID of the user (deviceId or accountId required) (optional)
     * @param albumIds comma separated list of album ids to search on (optional)
     * @param assetIds comma separated list of asset ids to search on (optional)
     * @param appKey the application key to filter results by application. (optional)
     * @param mediaType filter results by media type. Possible values include: APPLICATION, IMAGE, AUDIO, VIDEO, MULTIPART, TEXT (optional)
     * @param mimeType filter results by mime type (optional)
     * @param keyword keyword search string (optional)
     * @param versionCode filter results by version code (optional)
     * @param versionName filter results by version name (optional)
     * @param updatedSince return items that have been updated since this date (time-stamp in milliseconds) (optional)
     * @param updatedBefore return items that have been updated before this date (time-stamp in milliseconds) (optional)
     * @param sortField the field to sort by. See AssetApiMap (optional)
     * @param descending determines whether the sorted list is in descending or ascending order (optional)
     * @param searchMediaLibrary determines whether to search on the media library album (optional)
     * @param filterByBillable filter results by billable entity (optional)
     * @param activeOnly if only searching for active assets (optional)
     * @param returnApp determines whether to include the application response as part of the asset response (optional)
     * @param start the start index for pagination (optional)
     * @param limit the limit for pagination (there is a hard limit of 200) (optional)
     * @param searchMode search mode for index (SearchIndexMode) (optional)
     * @param assetType filter by asset type (optional)
     * @param approvalStatus filter by approval status (optional)
     * @param assignedAccountId filter results by an assigned account id (optional)
     * @return kotlin.collections.List<AssetResponse>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun searchAssets(deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, albumIds: kotlin.String? = null, assetIds: kotlin.String? = null, appKey: kotlin.String? = null, mediaType: kotlin.String? = null, mimeType: kotlin.String? = null, keyword: kotlin.String? = null, versionCode: kotlin.Int? = null, versionName: kotlin.String? = null, updatedSince: kotlin.Long? = null, updatedBefore: kotlin.Long? = null, sortField: kotlin.String? = null, descending: kotlin.Boolean? = null, searchMediaLibrary: kotlin.Boolean? = null, filterByBillable: kotlin.Boolean? = null, activeOnly: kotlin.Boolean? = null, returnApp: kotlin.Boolean? = null, start: kotlin.Int? = null, limit: kotlin.Int? = null, searchMode: kotlin.String? = null, assetType: kotlin.String? = null, approvalStatus: kotlin.String? = null, assignedAccountId: kotlin.Long? = null) : kotlin.collections.List<AssetResponse> {
        val localVarResponse = searchAssetsWithHttpInfo(deviceId = deviceId, accountId = accountId, albumIds = albumIds, assetIds = assetIds, appKey = appKey, mediaType = mediaType, mimeType = mimeType, keyword = keyword, versionCode = versionCode, versionName = versionName, updatedSince = updatedSince, updatedBefore = updatedBefore, sortField = sortField, descending = descending, searchMediaLibrary = searchMediaLibrary, filterByBillable = filterByBillable, activeOnly = activeOnly, returnApp = returnApp, start = start, limit = limit, searchMode = searchMode, assetType = assetType, approvalStatus = approvalStatus, assignedAccountId = assignedAccountId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<AssetResponse>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /asset/search
     * Search Assets
     * Searches for assets
     * @param deviceId a unique ID given by the device (deviceId or accountId required) (optional)
     * @param accountId the account ID of the user (deviceId or accountId required) (optional)
     * @param albumIds comma separated list of album ids to search on (optional)
     * @param assetIds comma separated list of asset ids to search on (optional)
     * @param appKey the application key to filter results by application. (optional)
     * @param mediaType filter results by media type. Possible values include: APPLICATION, IMAGE, AUDIO, VIDEO, MULTIPART, TEXT (optional)
     * @param mimeType filter results by mime type (optional)
     * @param keyword keyword search string (optional)
     * @param versionCode filter results by version code (optional)
     * @param versionName filter results by version name (optional)
     * @param updatedSince return items that have been updated since this date (time-stamp in milliseconds) (optional)
     * @param updatedBefore return items that have been updated before this date (time-stamp in milliseconds) (optional)
     * @param sortField the field to sort by. See AssetApiMap (optional)
     * @param descending determines whether the sorted list is in descending or ascending order (optional)
     * @param searchMediaLibrary determines whether to search on the media library album (optional)
     * @param filterByBillable filter results by billable entity (optional)
     * @param activeOnly if only searching for active assets (optional)
     * @param returnApp determines whether to include the application response as part of the asset response (optional)
     * @param start the start index for pagination (optional)
     * @param limit the limit for pagination (there is a hard limit of 200) (optional)
     * @param searchMode search mode for index (SearchIndexMode) (optional)
     * @param assetType filter by asset type (optional)
     * @param approvalStatus filter by approval status (optional)
     * @param assignedAccountId filter results by an assigned account id (optional)
     * @return ApiResponse<kotlin.collections.List<AssetResponse>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun searchAssetsWithHttpInfo(deviceId: kotlin.String?, accountId: kotlin.Long?, albumIds: kotlin.String?, assetIds: kotlin.String?, appKey: kotlin.String?, mediaType: kotlin.String?, mimeType: kotlin.String?, keyword: kotlin.String?, versionCode: kotlin.Int?, versionName: kotlin.String?, updatedSince: kotlin.Long?, updatedBefore: kotlin.Long?, sortField: kotlin.String?, descending: kotlin.Boolean?, searchMediaLibrary: kotlin.Boolean?, filterByBillable: kotlin.Boolean?, activeOnly: kotlin.Boolean?, returnApp: kotlin.Boolean?, start: kotlin.Int?, limit: kotlin.Int?, searchMode: kotlin.String?, assetType: kotlin.String?, approvalStatus: kotlin.String?, assignedAccountId: kotlin.Long?) : ApiResponse<kotlin.collections.List<AssetResponse>?> {
        val localVariableConfig = searchAssetsRequestConfig(deviceId = deviceId, accountId = accountId, albumIds = albumIds, assetIds = assetIds, appKey = appKey, mediaType = mediaType, mimeType = mimeType, keyword = keyword, versionCode = versionCode, versionName = versionName, updatedSince = updatedSince, updatedBefore = updatedBefore, sortField = sortField, descending = descending, searchMediaLibrary = searchMediaLibrary, filterByBillable = filterByBillable, activeOnly = activeOnly, returnApp = returnApp, start = start, limit = limit, searchMode = searchMode, assetType = assetType, approvalStatus = approvalStatus, assignedAccountId = assignedAccountId)

        return request<Unit, kotlin.collections.List<AssetResponse>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation searchAssets
     *
     * @param deviceId a unique ID given by the device (deviceId or accountId required) (optional)
     * @param accountId the account ID of the user (deviceId or accountId required) (optional)
     * @param albumIds comma separated list of album ids to search on (optional)
     * @param assetIds comma separated list of asset ids to search on (optional)
     * @param appKey the application key to filter results by application. (optional)
     * @param mediaType filter results by media type. Possible values include: APPLICATION, IMAGE, AUDIO, VIDEO, MULTIPART, TEXT (optional)
     * @param mimeType filter results by mime type (optional)
     * @param keyword keyword search string (optional)
     * @param versionCode filter results by version code (optional)
     * @param versionName filter results by version name (optional)
     * @param updatedSince return items that have been updated since this date (time-stamp in milliseconds) (optional)
     * @param updatedBefore return items that have been updated before this date (time-stamp in milliseconds) (optional)
     * @param sortField the field to sort by. See AssetApiMap (optional)
     * @param descending determines whether the sorted list is in descending or ascending order (optional)
     * @param searchMediaLibrary determines whether to search on the media library album (optional)
     * @param filterByBillable filter results by billable entity (optional)
     * @param activeOnly if only searching for active assets (optional)
     * @param returnApp determines whether to include the application response as part of the asset response (optional)
     * @param start the start index for pagination (optional)
     * @param limit the limit for pagination (there is a hard limit of 200) (optional)
     * @param searchMode search mode for index (SearchIndexMode) (optional)
     * @param assetType filter by asset type (optional)
     * @param approvalStatus filter by approval status (optional)
     * @param assignedAccountId filter results by an assigned account id (optional)
     * @return RequestConfig
     */
    fun searchAssetsRequestConfig(deviceId: kotlin.String?, accountId: kotlin.Long?, albumIds: kotlin.String?, assetIds: kotlin.String?, appKey: kotlin.String?, mediaType: kotlin.String?, mimeType: kotlin.String?, keyword: kotlin.String?, versionCode: kotlin.Int?, versionName: kotlin.String?, updatedSince: kotlin.Long?, updatedBefore: kotlin.Long?, sortField: kotlin.String?, descending: kotlin.Boolean?, searchMediaLibrary: kotlin.Boolean?, filterByBillable: kotlin.Boolean?, activeOnly: kotlin.Boolean?, returnApp: kotlin.Boolean?, start: kotlin.Int?, limit: kotlin.Int?, searchMode: kotlin.String?, assetType: kotlin.String?, approvalStatus: kotlin.String?, assignedAccountId: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (albumIds != null) {
                    put("albumIds", listOf(albumIds.toString()))
                }
                if (assetIds != null) {
                    put("assetIds", listOf(assetIds.toString()))
                }
                if (appKey != null) {
                    put("appKey", listOf(appKey.toString()))
                }
                if (mediaType != null) {
                    put("mediaType", listOf(mediaType.toString()))
                }
                if (mimeType != null) {
                    put("mimeType", listOf(mimeType.toString()))
                }
                if (keyword != null) {
                    put("keyword", listOf(keyword.toString()))
                }
                if (versionCode != null) {
                    put("versionCode", listOf(versionCode.toString()))
                }
                if (versionName != null) {
                    put("versionName", listOf(versionName.toString()))
                }
                if (updatedSince != null) {
                    put("updatedSince", listOf(updatedSince.toString()))
                }
                if (updatedBefore != null) {
                    put("updatedBefore", listOf(updatedBefore.toString()))
                }
                if (sortField != null) {
                    put("sortField", listOf(sortField.toString()))
                }
                if (descending != null) {
                    put("descending", listOf(descending.toString()))
                }
                if (searchMediaLibrary != null) {
                    put("searchMediaLibrary", listOf(searchMediaLibrary.toString()))
                }
                if (filterByBillable != null) {
                    put("filterByBillable", listOf(filterByBillable.toString()))
                }
                if (activeOnly != null) {
                    put("activeOnly", listOf(activeOnly.toString()))
                }
                if (returnApp != null) {
                    put("returnApp", listOf(returnApp.toString()))
                }
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (searchMode != null) {
                    put("searchMode", listOf(searchMode.toString()))
                }
                if (assetType != null) {
                    put("assetType", listOf(assetType.toString()))
                }
                if (approvalStatus != null) {
                    put("approvalStatus", listOf(approvalStatus.toString()))
                }
                if (assignedAccountId != null) {
                    put("assignedAccountId", listOf(assignedAccountId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/asset/search",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /asset/update
     * Update Asset
     * Updates an asset&#39;s meta data. If an album reference is passed in, the participants with write permissions are allowed to edit the asset. Otherwise, only the asset up-loader has permission to edit the data.
     * @param assetId the ID of the asset to update
     * @param deviceId a unique ID given by the device (deviceId or accountId required) (optional)
     * @param accountId the account ID of the user (deviceId or accountId required) (optional)
     * @param albumId the ID of the album to check user permissions (optional)
     * @param attachedAssetId the ID of the attached asset (optional)
     * @param versionCode the version code (optional)
     * @param versionName the version name (optional)
     * @param metaData External custom client defined data (optional)
     * @param caption the caption (optional)
     * @param assetType the asset type (optional)
     * @param approvalStatus approval status for the asset (optional)
     * @param assignedAccountId account id assigned to the asset (optional)
     * @param media a MultipartFile containing the mimetype, etc (optional)
     * @param mediaUrl this can be used if the \&quot;media\&quot; is a link (optional) (optional)
     * @param mediaString the media content as a string (optional) (optional)
     * @param mediaStringFileName file name for mediaString (optional) (optional)
     * @param mediaStringContentType content type for mediaString (optional) (optional)
     * @param mediaHeight the media height (optional) (optional)
     * @param mediaWidth the media width (optional) (optional)
     * @param attachedMedia a MultipartFile containing an asset that the \&quot;media\&quot; file references (optional). Example: to upload a video the \&quot;media\&quot; file should contain a screen capture and the \&quot;attachedMedia\&quot; should be the actual video. (optional)
     * @param attachedMediaUrl this can be used if the \&quot;attachedMedia\&quot; is a link (i.e. a Youtube video, etc) (optional) (optional)
     * @param attachedMediaString attached media content as a string (optional) (optional)
     * @param attachedMediaStringFileName file name for attachedMediaString (optional) (optional)
     * @param attachedMediaStringContentType content type for attachedMediaString (optional) (optional)
     * @param attachedMediaHeight the attached media height (optional) (optional)
     * @param attachedMediaWidth the attached media width (optional) (optional)
     * @param locationDescription the location description (optional)
     * @param searchTags search tags (optional)
     * @param appKey the application key (optional)
     * @param latitude latitude used to update the asset&#39;s location (optional)
     * @param longitude longitude used to update the asset&#39;s location (optional)
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updateAsset(assetId: kotlin.Long, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, albumId: kotlin.Long? = null, attachedAssetId: kotlin.Long? = null, versionCode: kotlin.Int? = null, versionName: kotlin.String? = null, metaData: kotlin.String? = null, caption: kotlin.String? = null, assetType: kotlin.String? = null, approvalStatus: kotlin.String? = null, assignedAccountId: kotlin.Long? = null, media: java.io.File? = null, mediaUrl: kotlin.String? = null, mediaString: kotlin.String? = null, mediaStringFileName: kotlin.String? = null, mediaStringContentType: kotlin.String? = null, mediaHeight: kotlin.Int? = null, mediaWidth: kotlin.Int? = null, attachedMedia: java.io.File? = null, attachedMediaUrl: kotlin.String? = null, attachedMediaString: kotlin.String? = null, attachedMediaStringFileName: kotlin.String? = null, attachedMediaStringContentType: kotlin.String? = null, attachedMediaHeight: kotlin.Int? = null, attachedMediaWidth: kotlin.Int? = null, locationDescription: kotlin.String? = null, searchTags: kotlin.String? = null, appKey: kotlin.String? = null, latitude: kotlin.Double? = null, longitude: kotlin.Double? = null) : SirqulResponse {
        val localVarResponse = updateAssetWithHttpInfo(assetId = assetId, deviceId = deviceId, accountId = accountId, albumId = albumId, attachedAssetId = attachedAssetId, versionCode = versionCode, versionName = versionName, metaData = metaData, caption = caption, assetType = assetType, approvalStatus = approvalStatus, assignedAccountId = assignedAccountId, media = media, mediaUrl = mediaUrl, mediaString = mediaString, mediaStringFileName = mediaStringFileName, mediaStringContentType = mediaStringContentType, mediaHeight = mediaHeight, mediaWidth = mediaWidth, attachedMedia = attachedMedia, attachedMediaUrl = attachedMediaUrl, attachedMediaString = attachedMediaString, attachedMediaStringFileName = attachedMediaStringFileName, attachedMediaStringContentType = attachedMediaStringContentType, attachedMediaHeight = attachedMediaHeight, attachedMediaWidth = attachedMediaWidth, locationDescription = locationDescription, searchTags = searchTags, appKey = appKey, latitude = latitude, longitude = longitude)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /asset/update
     * Update Asset
     * Updates an asset&#39;s meta data. If an album reference is passed in, the participants with write permissions are allowed to edit the asset. Otherwise, only the asset up-loader has permission to edit the data.
     * @param assetId the ID of the asset to update
     * @param deviceId a unique ID given by the device (deviceId or accountId required) (optional)
     * @param accountId the account ID of the user (deviceId or accountId required) (optional)
     * @param albumId the ID of the album to check user permissions (optional)
     * @param attachedAssetId the ID of the attached asset (optional)
     * @param versionCode the version code (optional)
     * @param versionName the version name (optional)
     * @param metaData External custom client defined data (optional)
     * @param caption the caption (optional)
     * @param assetType the asset type (optional)
     * @param approvalStatus approval status for the asset (optional)
     * @param assignedAccountId account id assigned to the asset (optional)
     * @param media a MultipartFile containing the mimetype, etc (optional)
     * @param mediaUrl this can be used if the \&quot;media\&quot; is a link (optional) (optional)
     * @param mediaString the media content as a string (optional) (optional)
     * @param mediaStringFileName file name for mediaString (optional) (optional)
     * @param mediaStringContentType content type for mediaString (optional) (optional)
     * @param mediaHeight the media height (optional) (optional)
     * @param mediaWidth the media width (optional) (optional)
     * @param attachedMedia a MultipartFile containing an asset that the \&quot;media\&quot; file references (optional). Example: to upload a video the \&quot;media\&quot; file should contain a screen capture and the \&quot;attachedMedia\&quot; should be the actual video. (optional)
     * @param attachedMediaUrl this can be used if the \&quot;attachedMedia\&quot; is a link (i.e. a Youtube video, etc) (optional) (optional)
     * @param attachedMediaString attached media content as a string (optional) (optional)
     * @param attachedMediaStringFileName file name for attachedMediaString (optional) (optional)
     * @param attachedMediaStringContentType content type for attachedMediaString (optional) (optional)
     * @param attachedMediaHeight the attached media height (optional) (optional)
     * @param attachedMediaWidth the attached media width (optional) (optional)
     * @param locationDescription the location description (optional)
     * @param searchTags search tags (optional)
     * @param appKey the application key (optional)
     * @param latitude latitude used to update the asset&#39;s location (optional)
     * @param longitude longitude used to update the asset&#39;s location (optional)
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun updateAssetWithHttpInfo(assetId: kotlin.Long, deviceId: kotlin.String?, accountId: kotlin.Long?, albumId: kotlin.Long?, attachedAssetId: kotlin.Long?, versionCode: kotlin.Int?, versionName: kotlin.String?, metaData: kotlin.String?, caption: kotlin.String?, assetType: kotlin.String?, approvalStatus: kotlin.String?, assignedAccountId: kotlin.Long?, media: java.io.File?, mediaUrl: kotlin.String?, mediaString: kotlin.String?, mediaStringFileName: kotlin.String?, mediaStringContentType: kotlin.String?, mediaHeight: kotlin.Int?, mediaWidth: kotlin.Int?, attachedMedia: java.io.File?, attachedMediaUrl: kotlin.String?, attachedMediaString: kotlin.String?, attachedMediaStringFileName: kotlin.String?, attachedMediaStringContentType: kotlin.String?, attachedMediaHeight: kotlin.Int?, attachedMediaWidth: kotlin.Int?, locationDescription: kotlin.String?, searchTags: kotlin.String?, appKey: kotlin.String?, latitude: kotlin.Double?, longitude: kotlin.Double?) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = updateAssetRequestConfig(assetId = assetId, deviceId = deviceId, accountId = accountId, albumId = albumId, attachedAssetId = attachedAssetId, versionCode = versionCode, versionName = versionName, metaData = metaData, caption = caption, assetType = assetType, approvalStatus = approvalStatus, assignedAccountId = assignedAccountId, media = media, mediaUrl = mediaUrl, mediaString = mediaString, mediaStringFileName = mediaStringFileName, mediaStringContentType = mediaStringContentType, mediaHeight = mediaHeight, mediaWidth = mediaWidth, attachedMedia = attachedMedia, attachedMediaUrl = attachedMediaUrl, attachedMediaString = attachedMediaString, attachedMediaStringFileName = attachedMediaStringFileName, attachedMediaStringContentType = attachedMediaStringContentType, attachedMediaHeight = attachedMediaHeight, attachedMediaWidth = attachedMediaWidth, locationDescription = locationDescription, searchTags = searchTags, appKey = appKey, latitude = latitude, longitude = longitude)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateAsset
     *
     * @param assetId the ID of the asset to update
     * @param deviceId a unique ID given by the device (deviceId or accountId required) (optional)
     * @param accountId the account ID of the user (deviceId or accountId required) (optional)
     * @param albumId the ID of the album to check user permissions (optional)
     * @param attachedAssetId the ID of the attached asset (optional)
     * @param versionCode the version code (optional)
     * @param versionName the version name (optional)
     * @param metaData External custom client defined data (optional)
     * @param caption the caption (optional)
     * @param assetType the asset type (optional)
     * @param approvalStatus approval status for the asset (optional)
     * @param assignedAccountId account id assigned to the asset (optional)
     * @param media a MultipartFile containing the mimetype, etc (optional)
     * @param mediaUrl this can be used if the \&quot;media\&quot; is a link (optional) (optional)
     * @param mediaString the media content as a string (optional) (optional)
     * @param mediaStringFileName file name for mediaString (optional) (optional)
     * @param mediaStringContentType content type for mediaString (optional) (optional)
     * @param mediaHeight the media height (optional) (optional)
     * @param mediaWidth the media width (optional) (optional)
     * @param attachedMedia a MultipartFile containing an asset that the \&quot;media\&quot; file references (optional). Example: to upload a video the \&quot;media\&quot; file should contain a screen capture and the \&quot;attachedMedia\&quot; should be the actual video. (optional)
     * @param attachedMediaUrl this can be used if the \&quot;attachedMedia\&quot; is a link (i.e. a Youtube video, etc) (optional) (optional)
     * @param attachedMediaString attached media content as a string (optional) (optional)
     * @param attachedMediaStringFileName file name for attachedMediaString (optional) (optional)
     * @param attachedMediaStringContentType content type for attachedMediaString (optional) (optional)
     * @param attachedMediaHeight the attached media height (optional) (optional)
     * @param attachedMediaWidth the attached media width (optional) (optional)
     * @param locationDescription the location description (optional)
     * @param searchTags search tags (optional)
     * @param appKey the application key (optional)
     * @param latitude latitude used to update the asset&#39;s location (optional)
     * @param longitude longitude used to update the asset&#39;s location (optional)
     * @return RequestConfig
     */
    fun updateAssetRequestConfig(assetId: kotlin.Long, deviceId: kotlin.String?, accountId: kotlin.Long?, albumId: kotlin.Long?, attachedAssetId: kotlin.Long?, versionCode: kotlin.Int?, versionName: kotlin.String?, metaData: kotlin.String?, caption: kotlin.String?, assetType: kotlin.String?, approvalStatus: kotlin.String?, assignedAccountId: kotlin.Long?, media: java.io.File?, mediaUrl: kotlin.String?, mediaString: kotlin.String?, mediaStringFileName: kotlin.String?, mediaStringContentType: kotlin.String?, mediaHeight: kotlin.Int?, mediaWidth: kotlin.Int?, attachedMedia: java.io.File?, attachedMediaUrl: kotlin.String?, attachedMediaString: kotlin.String?, attachedMediaStringFileName: kotlin.String?, attachedMediaStringContentType: kotlin.String?, attachedMediaHeight: kotlin.Int?, attachedMediaWidth: kotlin.Int?, locationDescription: kotlin.String?, searchTags: kotlin.String?, appKey: kotlin.String?, latitude: kotlin.Double?, longitude: kotlin.Double?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                put("assetId", listOf(assetId.toString()))
                if (albumId != null) {
                    put("albumId", listOf(albumId.toString()))
                }
                if (attachedAssetId != null) {
                    put("attachedAssetId", listOf(attachedAssetId.toString()))
                }
                if (versionCode != null) {
                    put("versionCode", listOf(versionCode.toString()))
                }
                if (versionName != null) {
                    put("versionName", listOf(versionName.toString()))
                }
                if (metaData != null) {
                    put("metaData", listOf(metaData.toString()))
                }
                if (caption != null) {
                    put("caption", listOf(caption.toString()))
                }
                if (assetType != null) {
                    put("assetType", listOf(assetType.toString()))
                }
                if (approvalStatus != null) {
                    put("approvalStatus", listOf(approvalStatus.toString()))
                }
                if (assignedAccountId != null) {
                    put("assignedAccountId", listOf(assignedAccountId.toString()))
                }
                if (media != null) {
                    put("media", listOf(media.toString()))
                }
                if (mediaUrl != null) {
                    put("mediaUrl", listOf(mediaUrl.toString()))
                }
                if (mediaString != null) {
                    put("mediaString", listOf(mediaString.toString()))
                }
                if (mediaStringFileName != null) {
                    put("mediaStringFileName", listOf(mediaStringFileName.toString()))
                }
                if (mediaStringContentType != null) {
                    put("mediaStringContentType", listOf(mediaStringContentType.toString()))
                }
                if (mediaHeight != null) {
                    put("mediaHeight", listOf(mediaHeight.toString()))
                }
                if (mediaWidth != null) {
                    put("mediaWidth", listOf(mediaWidth.toString()))
                }
                if (attachedMedia != null) {
                    put("attachedMedia", listOf(attachedMedia.toString()))
                }
                if (attachedMediaUrl != null) {
                    put("attachedMediaUrl", listOf(attachedMediaUrl.toString()))
                }
                if (attachedMediaString != null) {
                    put("attachedMediaString", listOf(attachedMediaString.toString()))
                }
                if (attachedMediaStringFileName != null) {
                    put("attachedMediaStringFileName", listOf(attachedMediaStringFileName.toString()))
                }
                if (attachedMediaStringContentType != null) {
                    put("attachedMediaStringContentType", listOf(attachedMediaStringContentType.toString()))
                }
                if (attachedMediaHeight != null) {
                    put("attachedMediaHeight", listOf(attachedMediaHeight.toString()))
                }
                if (attachedMediaWidth != null) {
                    put("attachedMediaWidth", listOf(attachedMediaWidth.toString()))
                }
                if (locationDescription != null) {
                    put("locationDescription", listOf(locationDescription.toString()))
                }
                if (searchTags != null) {
                    put("searchTags", listOf(searchTags.toString()))
                }
                if (appKey != null) {
                    put("appKey", listOf(appKey.toString()))
                }
                if (latitude != null) {
                    put("latitude", listOf(latitude.toString()))
                }
                if (longitude != null) {
                    put("longitude", listOf(longitude.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/asset/update",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
