/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import org.openapitools.client.models.BillableEntityResponse
import org.openapitools.client.models.SirqulResponse

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

open class BillableEntityApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://dev.sirqul.com/api/3.18")
        }
    }

    /**
     * POST /billable/create
     * Create Billable
     * reate a billable entity for an account. The creator is assumed to be the responsible account. An account can only have one billable entity
     * @param deviceId The unique device identifier that made the request (either deviceId or accountId must be used) (optional)
     * @param accountId The unique accountId that made the request (either deviceId or accountId must be used) (optional)
     * @param name The name of the entity responsible for billing  (optional)
     * @param streetAddress The street address of the billable entity (optional)
     * @param streetAddress2 Additional address information (such as a suite number, floor number, building name, or PO Box)  (optional)
     * @param city The city of the billable entity (optional)
     * @param state The state of the billable entity (optional)
     * @param postalCode The postal code of the billable entity (optional)
     * @param businessPhone The business phone of the billable entity (optional)
     * @param businessPhoneExt The business phone extension (optional)
     * @param authorizeNetApiKey Authorize Net Api Key (optional)
     * @param authorizeNetTransactionKey Authorize Net Transaction Key (optional)
     * @return BillableEntityResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createBillableEntity(deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, name: kotlin.String? = null, streetAddress: kotlin.String? = null, streetAddress2: kotlin.String? = null, city: kotlin.String? = null, state: kotlin.String? = null, postalCode: kotlin.String? = null, businessPhone: kotlin.String? = null, businessPhoneExt: kotlin.String? = null, authorizeNetApiKey: kotlin.String? = null, authorizeNetTransactionKey: kotlin.String? = null) : BillableEntityResponse {
        val localVarResponse = createBillableEntityWithHttpInfo(deviceId = deviceId, accountId = accountId, name = name, streetAddress = streetAddress, streetAddress2 = streetAddress2, city = city, state = state, postalCode = postalCode, businessPhone = businessPhone, businessPhoneExt = businessPhoneExt, authorizeNetApiKey = authorizeNetApiKey, authorizeNetTransactionKey = authorizeNetTransactionKey)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BillableEntityResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /billable/create
     * Create Billable
     * reate a billable entity for an account. The creator is assumed to be the responsible account. An account can only have one billable entity
     * @param deviceId The unique device identifier that made the request (either deviceId or accountId must be used) (optional)
     * @param accountId The unique accountId that made the request (either deviceId or accountId must be used) (optional)
     * @param name The name of the entity responsible for billing  (optional)
     * @param streetAddress The street address of the billable entity (optional)
     * @param streetAddress2 Additional address information (such as a suite number, floor number, building name, or PO Box)  (optional)
     * @param city The city of the billable entity (optional)
     * @param state The state of the billable entity (optional)
     * @param postalCode The postal code of the billable entity (optional)
     * @param businessPhone The business phone of the billable entity (optional)
     * @param businessPhoneExt The business phone extension (optional)
     * @param authorizeNetApiKey Authorize Net Api Key (optional)
     * @param authorizeNetTransactionKey Authorize Net Transaction Key (optional)
     * @return ApiResponse<BillableEntityResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createBillableEntityWithHttpInfo(deviceId: kotlin.String?, accountId: kotlin.Long?, name: kotlin.String?, streetAddress: kotlin.String?, streetAddress2: kotlin.String?, city: kotlin.String?, state: kotlin.String?, postalCode: kotlin.String?, businessPhone: kotlin.String?, businessPhoneExt: kotlin.String?, authorizeNetApiKey: kotlin.String?, authorizeNetTransactionKey: kotlin.String?) : ApiResponse<BillableEntityResponse?> {
        val localVariableConfig = createBillableEntityRequestConfig(deviceId = deviceId, accountId = accountId, name = name, streetAddress = streetAddress, streetAddress2 = streetAddress2, city = city, state = state, postalCode = postalCode, businessPhone = businessPhone, businessPhoneExt = businessPhoneExt, authorizeNetApiKey = authorizeNetApiKey, authorizeNetTransactionKey = authorizeNetTransactionKey)

        return request<Unit, BillableEntityResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createBillableEntity
     *
     * @param deviceId The unique device identifier that made the request (either deviceId or accountId must be used) (optional)
     * @param accountId The unique accountId that made the request (either deviceId or accountId must be used) (optional)
     * @param name The name of the entity responsible for billing  (optional)
     * @param streetAddress The street address of the billable entity (optional)
     * @param streetAddress2 Additional address information (such as a suite number, floor number, building name, or PO Box)  (optional)
     * @param city The city of the billable entity (optional)
     * @param state The state of the billable entity (optional)
     * @param postalCode The postal code of the billable entity (optional)
     * @param businessPhone The business phone of the billable entity (optional)
     * @param businessPhoneExt The business phone extension (optional)
     * @param authorizeNetApiKey Authorize Net Api Key (optional)
     * @param authorizeNetTransactionKey Authorize Net Transaction Key (optional)
     * @return RequestConfig
     */
    fun createBillableEntityRequestConfig(deviceId: kotlin.String?, accountId: kotlin.Long?, name: kotlin.String?, streetAddress: kotlin.String?, streetAddress2: kotlin.String?, city: kotlin.String?, state: kotlin.String?, postalCode: kotlin.String?, businessPhone: kotlin.String?, businessPhoneExt: kotlin.String?, authorizeNetApiKey: kotlin.String?, authorizeNetTransactionKey: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (streetAddress != null) {
                    put("streetAddress", listOf(streetAddress.toString()))
                }
                if (streetAddress2 != null) {
                    put("streetAddress2", listOf(streetAddress2.toString()))
                }
                if (city != null) {
                    put("city", listOf(city.toString()))
                }
                if (state != null) {
                    put("state", listOf(state.toString()))
                }
                if (postalCode != null) {
                    put("postalCode", listOf(postalCode.toString()))
                }
                if (businessPhone != null) {
                    put("businessPhone", listOf(businessPhone.toString()))
                }
                if (businessPhoneExt != null) {
                    put("businessPhoneExt", listOf(businessPhoneExt.toString()))
                }
                if (authorizeNetApiKey != null) {
                    put("authorizeNetApiKey", listOf(authorizeNetApiKey.toString()))
                }
                if (authorizeNetTransactionKey != null) {
                    put("authorizeNetTransactionKey", listOf(authorizeNetTransactionKey.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/billable/create",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /billable/delete
     * Delete Billable
     * Mark the billable as deleted
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account used to perform the delete, must have rights to edit the billable entity. (optional)
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteBillableEntity(deviceId: kotlin.String? = null, accountId: kotlin.Long? = null) : SirqulResponse {
        val localVarResponse = deleteBillableEntityWithHttpInfo(deviceId = deviceId, accountId = accountId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /billable/delete
     * Delete Billable
     * Mark the billable as deleted
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account used to perform the delete, must have rights to edit the billable entity. (optional)
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteBillableEntityWithHttpInfo(deviceId: kotlin.String?, accountId: kotlin.Long?) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = deleteBillableEntityRequestConfig(deviceId = deviceId, accountId = accountId)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteBillableEntity
     *
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account used to perform the delete, must have rights to edit the billable entity. (optional)
     * @return RequestConfig
     */
    fun deleteBillableEntityRequestConfig(deviceId: kotlin.String?, accountId: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/billable/delete",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /billable/get
     * Get Billable
     * Used to determine the associated BillableEntity of an account
     * @param deviceId The unique device identifier that made the request (either deviceId or accountId must be used) (optional)
     * @param accountId The unique accountId that made the request (either deviceId or accountId must be used) (optional)
     * @param includeCounts Determines whether to include the retailer dash board counts into the response (optional, default to false)
     * @param includePayments Whether to enable payments or not (optional, default to true)
     * @return BillableEntityResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getBillableEntity(deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, includeCounts: kotlin.Boolean? = false, includePayments: kotlin.Boolean? = true) : BillableEntityResponse {
        val localVarResponse = getBillableEntityWithHttpInfo(deviceId = deviceId, accountId = accountId, includeCounts = includeCounts, includePayments = includePayments)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BillableEntityResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /billable/get
     * Get Billable
     * Used to determine the associated BillableEntity of an account
     * @param deviceId The unique device identifier that made the request (either deviceId or accountId must be used) (optional)
     * @param accountId The unique accountId that made the request (either deviceId or accountId must be used) (optional)
     * @param includeCounts Determines whether to include the retailer dash board counts into the response (optional, default to false)
     * @param includePayments Whether to enable payments or not (optional, default to true)
     * @return ApiResponse<BillableEntityResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getBillableEntityWithHttpInfo(deviceId: kotlin.String?, accountId: kotlin.Long?, includeCounts: kotlin.Boolean?, includePayments: kotlin.Boolean?) : ApiResponse<BillableEntityResponse?> {
        val localVariableConfig = getBillableEntityRequestConfig(deviceId = deviceId, accountId = accountId, includeCounts = includeCounts, includePayments = includePayments)

        return request<Unit, BillableEntityResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getBillableEntity
     *
     * @param deviceId The unique device identifier that made the request (either deviceId or accountId must be used) (optional)
     * @param accountId The unique accountId that made the request (either deviceId or accountId must be used) (optional)
     * @param includeCounts Determines whether to include the retailer dash board counts into the response (optional, default to false)
     * @param includePayments Whether to enable payments or not (optional, default to true)
     * @return RequestConfig
     */
    fun getBillableEntityRequestConfig(deviceId: kotlin.String?, accountId: kotlin.Long?, includeCounts: kotlin.Boolean?, includePayments: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (includeCounts != null) {
                    put("includeCounts", listOf(includeCounts.toString()))
                }
                if (includePayments != null) {
                    put("includePayments", listOf(includePayments.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/billable/get",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /billable/update
     * Update Billable
     * Updates the billable record for an account
     * @param deviceId The unique device identifier that made the request (either deviceId or accountId must be used) (optional)
     * @param accountId The unique accountId that made the request (either deviceId or accountId must be used). The account must have rights to edit the billable entity. (optional)
     * @param name The name of the entity responsible for billing  (optional)
     * @param streetAddress The street address of the billable entity (optional)
     * @param streetAddress2 Additional address information (such as a suite number, floor number, building name, or PO Box)  (optional)
     * @param city The city of the billable entity (optional)
     * @param state The state of the billable entity (optional)
     * @param postalCode The postal code of the billable entity (optional)
     * @param businessPhone The business phone of the billable entity (optional)
     * @param businessPhoneExt The business phone extension of the billable entity (optional)
     * @param authorizeNetApiKey Authorize Net Api Key of the billable entity (optional)
     * @param authorizeNetTransactionKey Authorize Net Transaction Key of the billable entity (optional)
     * @return BillableEntityResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updateBillableEntity(deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, name: kotlin.String? = null, streetAddress: kotlin.String? = null, streetAddress2: kotlin.String? = null, city: kotlin.String? = null, state: kotlin.String? = null, postalCode: kotlin.String? = null, businessPhone: kotlin.String? = null, businessPhoneExt: kotlin.String? = null, authorizeNetApiKey: kotlin.String? = null, authorizeNetTransactionKey: kotlin.String? = null) : BillableEntityResponse {
        val localVarResponse = updateBillableEntityWithHttpInfo(deviceId = deviceId, accountId = accountId, name = name, streetAddress = streetAddress, streetAddress2 = streetAddress2, city = city, state = state, postalCode = postalCode, businessPhone = businessPhone, businessPhoneExt = businessPhoneExt, authorizeNetApiKey = authorizeNetApiKey, authorizeNetTransactionKey = authorizeNetTransactionKey)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BillableEntityResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /billable/update
     * Update Billable
     * Updates the billable record for an account
     * @param deviceId The unique device identifier that made the request (either deviceId or accountId must be used) (optional)
     * @param accountId The unique accountId that made the request (either deviceId or accountId must be used). The account must have rights to edit the billable entity. (optional)
     * @param name The name of the entity responsible for billing  (optional)
     * @param streetAddress The street address of the billable entity (optional)
     * @param streetAddress2 Additional address information (such as a suite number, floor number, building name, or PO Box)  (optional)
     * @param city The city of the billable entity (optional)
     * @param state The state of the billable entity (optional)
     * @param postalCode The postal code of the billable entity (optional)
     * @param businessPhone The business phone of the billable entity (optional)
     * @param businessPhoneExt The business phone extension of the billable entity (optional)
     * @param authorizeNetApiKey Authorize Net Api Key of the billable entity (optional)
     * @param authorizeNetTransactionKey Authorize Net Transaction Key of the billable entity (optional)
     * @return ApiResponse<BillableEntityResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun updateBillableEntityWithHttpInfo(deviceId: kotlin.String?, accountId: kotlin.Long?, name: kotlin.String?, streetAddress: kotlin.String?, streetAddress2: kotlin.String?, city: kotlin.String?, state: kotlin.String?, postalCode: kotlin.String?, businessPhone: kotlin.String?, businessPhoneExt: kotlin.String?, authorizeNetApiKey: kotlin.String?, authorizeNetTransactionKey: kotlin.String?) : ApiResponse<BillableEntityResponse?> {
        val localVariableConfig = updateBillableEntityRequestConfig(deviceId = deviceId, accountId = accountId, name = name, streetAddress = streetAddress, streetAddress2 = streetAddress2, city = city, state = state, postalCode = postalCode, businessPhone = businessPhone, businessPhoneExt = businessPhoneExt, authorizeNetApiKey = authorizeNetApiKey, authorizeNetTransactionKey = authorizeNetTransactionKey)

        return request<Unit, BillableEntityResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateBillableEntity
     *
     * @param deviceId The unique device identifier that made the request (either deviceId or accountId must be used) (optional)
     * @param accountId The unique accountId that made the request (either deviceId or accountId must be used). The account must have rights to edit the billable entity. (optional)
     * @param name The name of the entity responsible for billing  (optional)
     * @param streetAddress The street address of the billable entity (optional)
     * @param streetAddress2 Additional address information (such as a suite number, floor number, building name, or PO Box)  (optional)
     * @param city The city of the billable entity (optional)
     * @param state The state of the billable entity (optional)
     * @param postalCode The postal code of the billable entity (optional)
     * @param businessPhone The business phone of the billable entity (optional)
     * @param businessPhoneExt The business phone extension of the billable entity (optional)
     * @param authorizeNetApiKey Authorize Net Api Key of the billable entity (optional)
     * @param authorizeNetTransactionKey Authorize Net Transaction Key of the billable entity (optional)
     * @return RequestConfig
     */
    fun updateBillableEntityRequestConfig(deviceId: kotlin.String?, accountId: kotlin.Long?, name: kotlin.String?, streetAddress: kotlin.String?, streetAddress2: kotlin.String?, city: kotlin.String?, state: kotlin.String?, postalCode: kotlin.String?, businessPhone: kotlin.String?, businessPhoneExt: kotlin.String?, authorizeNetApiKey: kotlin.String?, authorizeNetTransactionKey: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (streetAddress != null) {
                    put("streetAddress", listOf(streetAddress.toString()))
                }
                if (streetAddress2 != null) {
                    put("streetAddress2", listOf(streetAddress2.toString()))
                }
                if (city != null) {
                    put("city", listOf(city.toString()))
                }
                if (state != null) {
                    put("state", listOf(state.toString()))
                }
                if (postalCode != null) {
                    put("postalCode", listOf(postalCode.toString()))
                }
                if (businessPhone != null) {
                    put("businessPhone", listOf(businessPhone.toString()))
                }
                if (businessPhoneExt != null) {
                    put("businessPhoneExt", listOf(businessPhoneExt.toString()))
                }
                if (authorizeNetApiKey != null) {
                    put("authorizeNetApiKey", listOf(authorizeNetApiKey.toString()))
                }
                if (authorizeNetTransactionKey != null) {
                    put("authorizeNetTransactionKey", listOf(authorizeNetTransactionKey.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/billable/update",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
