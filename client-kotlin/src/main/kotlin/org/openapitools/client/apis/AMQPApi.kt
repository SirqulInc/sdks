/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import org.openapitools.client.models.QueueResponse
import org.openapitools.client.models.SirqulResponse

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

open class AMQPApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://dev.sirqul.com/api/3.18")
        }
    }

    /**
     * POST /queue/consumer/create
     * Create Consumer
     * Create a connection to an existing amqp queue and register as a consumer.
     * @param appKey The application key to use when creating an analytic or service request. The account needs to have permissions to the applicaton or it will be denied.
     * @param name The name of the queue to connect to
     * @param hostname The hostname of the server the queue is hosted on
     * @param username The username to access the server the queue is hosted on
     * @param password The password to access the queue to connect to
     * @param dataMapping The data mapping information in the format of AMQPRequest
     * @param deviceId The client deviceID (optional)
     * @param accountId The logged in user ID (optional)
     * @param port The port of the server the queue is hosted on (optional, default to 5672)
     * @param virtualHost The virtual host defined on the server the queue is associated on (optional)
     * @param exchanger The exchanger of the queue to connect to (optional)
     * @param exchangerType The exchanger type of the queue to connect to (optional)
     * @param workers The number of workers to generate  (optional, default to 1)
     * @param useSSL Use SSL (optional)
     * @return QueueResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun consumerCreate(appKey: kotlin.String, name: kotlin.String, hostname: kotlin.String, username: kotlin.String, password: kotlin.String, dataMapping: kotlin.String, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, port: kotlin.Int? = 5672, virtualHost: kotlin.String? = null, exchanger: kotlin.String? = null, exchangerType: kotlin.String? = null, workers: kotlin.Int? = 1, useSSL: kotlin.Boolean? = null) : QueueResponse {
        val localVarResponse = consumerCreateWithHttpInfo(appKey = appKey, name = name, hostname = hostname, username = username, password = password, dataMapping = dataMapping, deviceId = deviceId, accountId = accountId, port = port, virtualHost = virtualHost, exchanger = exchanger, exchangerType = exchangerType, workers = workers, useSSL = useSSL)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as QueueResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /queue/consumer/create
     * Create Consumer
     * Create a connection to an existing amqp queue and register as a consumer.
     * @param appKey The application key to use when creating an analytic or service request. The account needs to have permissions to the applicaton or it will be denied.
     * @param name The name of the queue to connect to
     * @param hostname The hostname of the server the queue is hosted on
     * @param username The username to access the server the queue is hosted on
     * @param password The password to access the queue to connect to
     * @param dataMapping The data mapping information in the format of AMQPRequest
     * @param deviceId The client deviceID (optional)
     * @param accountId The logged in user ID (optional)
     * @param port The port of the server the queue is hosted on (optional, default to 5672)
     * @param virtualHost The virtual host defined on the server the queue is associated on (optional)
     * @param exchanger The exchanger of the queue to connect to (optional)
     * @param exchangerType The exchanger type of the queue to connect to (optional)
     * @param workers The number of workers to generate  (optional, default to 1)
     * @param useSSL Use SSL (optional)
     * @return ApiResponse<QueueResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun consumerCreateWithHttpInfo(appKey: kotlin.String, name: kotlin.String, hostname: kotlin.String, username: kotlin.String, password: kotlin.String, dataMapping: kotlin.String, deviceId: kotlin.String?, accountId: kotlin.Long?, port: kotlin.Int?, virtualHost: kotlin.String?, exchanger: kotlin.String?, exchangerType: kotlin.String?, workers: kotlin.Int?, useSSL: kotlin.Boolean?) : ApiResponse<QueueResponse?> {
        val localVariableConfig = consumerCreateRequestConfig(appKey = appKey, name = name, hostname = hostname, username = username, password = password, dataMapping = dataMapping, deviceId = deviceId, accountId = accountId, port = port, virtualHost = virtualHost, exchanger = exchanger, exchangerType = exchangerType, workers = workers, useSSL = useSSL)

        return request<Unit, QueueResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation consumerCreate
     *
     * @param appKey The application key to use when creating an analytic or service request. The account needs to have permissions to the applicaton or it will be denied.
     * @param name The name of the queue to connect to
     * @param hostname The hostname of the server the queue is hosted on
     * @param username The username to access the server the queue is hosted on
     * @param password The password to access the queue to connect to
     * @param dataMapping The data mapping information in the format of AMQPRequest
     * @param deviceId The client deviceID (optional)
     * @param accountId The logged in user ID (optional)
     * @param port The port of the server the queue is hosted on (optional, default to 5672)
     * @param virtualHost The virtual host defined on the server the queue is associated on (optional)
     * @param exchanger The exchanger of the queue to connect to (optional)
     * @param exchangerType The exchanger type of the queue to connect to (optional)
     * @param workers The number of workers to generate  (optional, default to 1)
     * @param useSSL Use SSL (optional)
     * @return RequestConfig
     */
    fun consumerCreateRequestConfig(appKey: kotlin.String, name: kotlin.String, hostname: kotlin.String, username: kotlin.String, password: kotlin.String, dataMapping: kotlin.String, deviceId: kotlin.String?, accountId: kotlin.Long?, port: kotlin.Int?, virtualHost: kotlin.String?, exchanger: kotlin.String?, exchangerType: kotlin.String?, workers: kotlin.Int?, useSSL: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                put("appKey", listOf(appKey.toString()))
                put("name", listOf(name.toString()))
                put("hostname", listOf(hostname.toString()))
                if (port != null) {
                    put("port", listOf(port.toString()))
                }
                put("username", listOf(username.toString()))
                put("password", listOf(password.toString()))
                if (virtualHost != null) {
                    put("virtualHost", listOf(virtualHost.toString()))
                }
                if (exchanger != null) {
                    put("exchanger", listOf(exchanger.toString()))
                }
                if (exchangerType != null) {
                    put("exchangerType", listOf(exchangerType.toString()))
                }
                if (workers != null) {
                    put("workers", listOf(workers.toString()))
                }
                put("dataMapping", listOf(dataMapping.toString()))
                if (useSSL != null) {
                    put("useSSL", listOf(useSSL.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/queue/consumer/create",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /queue/consumer/update
     * Update Consumer
     * Update an existing amqp queue&#39;s data mapping.
     * @param appKey The application key to use when creating an analytic or service request. The account needs to have permissions to the applicaton or it will be denied.
     * @param queueId The queue to update
     * @param dataMapping The data mapping information in the format of AMQPRequest
     * @param deviceId The client deviceID (optional)
     * @param accountId The logged in user ID (optional)
     * @param useSSL Use SSL (optional)
     * @return QueueResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun consumerUpdate(appKey: kotlin.String, queueId: kotlin.Long, dataMapping: kotlin.String, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, useSSL: kotlin.Boolean? = null) : QueueResponse {
        val localVarResponse = consumerUpdateWithHttpInfo(appKey = appKey, queueId = queueId, dataMapping = dataMapping, deviceId = deviceId, accountId = accountId, useSSL = useSSL)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as QueueResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /queue/consumer/update
     * Update Consumer
     * Update an existing amqp queue&#39;s data mapping.
     * @param appKey The application key to use when creating an analytic or service request. The account needs to have permissions to the applicaton or it will be denied.
     * @param queueId The queue to update
     * @param dataMapping The data mapping information in the format of AMQPRequest
     * @param deviceId The client deviceID (optional)
     * @param accountId The logged in user ID (optional)
     * @param useSSL Use SSL (optional)
     * @return ApiResponse<QueueResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun consumerUpdateWithHttpInfo(appKey: kotlin.String, queueId: kotlin.Long, dataMapping: kotlin.String, deviceId: kotlin.String?, accountId: kotlin.Long?, useSSL: kotlin.Boolean?) : ApiResponse<QueueResponse?> {
        val localVariableConfig = consumerUpdateRequestConfig(appKey = appKey, queueId = queueId, dataMapping = dataMapping, deviceId = deviceId, accountId = accountId, useSSL = useSSL)

        return request<Unit, QueueResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation consumerUpdate
     *
     * @param appKey The application key to use when creating an analytic or service request. The account needs to have permissions to the applicaton or it will be denied.
     * @param queueId The queue to update
     * @param dataMapping The data mapping information in the format of AMQPRequest
     * @param deviceId The client deviceID (optional)
     * @param accountId The logged in user ID (optional)
     * @param useSSL Use SSL (optional)
     * @return RequestConfig
     */
    fun consumerUpdateRequestConfig(appKey: kotlin.String, queueId: kotlin.Long, dataMapping: kotlin.String, deviceId: kotlin.String?, accountId: kotlin.Long?, useSSL: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                put("appKey", listOf(appKey.toString()))
                put("queueId", listOf(queueId.toString()))
                put("dataMapping", listOf(dataMapping.toString()))
                if (useSSL != null) {
                    put("useSSL", listOf(useSSL.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/queue/consumer/update",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /queue/create
     * Create Queue
     * Create a basic AMQP queue. If the username and password and virtual host is not sepcified, the queue will be created on the virtual host assigned to the application.
     * @param appKey The application key unique to each application.
     * @param name The name of the queue to create
     * @param deviceId The client deviceID (optional)
     * @param accountId The logged in user ID (optional)
     * @param workers The number of workers to generate  (optional, default to 1)
     * @param analyticTags If provided the analytic processing will publsih to this queue instead of the default one for the provided list of tags (optional)
     * @param hostname The hostname of the server the queue is hosted on (optional)
     * @param port The port of the server the queue is hosted on (optional)
     * @param username The username to access the server that the queue is on (optional)
     * @param password The password to access the queue to connect to (optional)
     * @param virtualHost The virtual host defined on the server to queue (optional)
     * @param useSSL Use SSL (optional)
     * @return QueueResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun queueCreate(appKey: kotlin.String, name: kotlin.String, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, workers: kotlin.Int? = 1, analyticTags: kotlin.String? = null, hostname: kotlin.String? = null, port: kotlin.Int? = null, username: kotlin.String? = null, password: kotlin.String? = null, virtualHost: kotlin.String? = null, useSSL: kotlin.Boolean? = null) : QueueResponse {
        val localVarResponse = queueCreateWithHttpInfo(appKey = appKey, name = name, deviceId = deviceId, accountId = accountId, workers = workers, analyticTags = analyticTags, hostname = hostname, port = port, username = username, password = password, virtualHost = virtualHost, useSSL = useSSL)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as QueueResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /queue/create
     * Create Queue
     * Create a basic AMQP queue. If the username and password and virtual host is not sepcified, the queue will be created on the virtual host assigned to the application.
     * @param appKey The application key unique to each application.
     * @param name The name of the queue to create
     * @param deviceId The client deviceID (optional)
     * @param accountId The logged in user ID (optional)
     * @param workers The number of workers to generate  (optional, default to 1)
     * @param analyticTags If provided the analytic processing will publsih to this queue instead of the default one for the provided list of tags (optional)
     * @param hostname The hostname of the server the queue is hosted on (optional)
     * @param port The port of the server the queue is hosted on (optional)
     * @param username The username to access the server that the queue is on (optional)
     * @param password The password to access the queue to connect to (optional)
     * @param virtualHost The virtual host defined on the server to queue (optional)
     * @param useSSL Use SSL (optional)
     * @return ApiResponse<QueueResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun queueCreateWithHttpInfo(appKey: kotlin.String, name: kotlin.String, deviceId: kotlin.String?, accountId: kotlin.Long?, workers: kotlin.Int?, analyticTags: kotlin.String?, hostname: kotlin.String?, port: kotlin.Int?, username: kotlin.String?, password: kotlin.String?, virtualHost: kotlin.String?, useSSL: kotlin.Boolean?) : ApiResponse<QueueResponse?> {
        val localVariableConfig = queueCreateRequestConfig(appKey = appKey, name = name, deviceId = deviceId, accountId = accountId, workers = workers, analyticTags = analyticTags, hostname = hostname, port = port, username = username, password = password, virtualHost = virtualHost, useSSL = useSSL)

        return request<Unit, QueueResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation queueCreate
     *
     * @param appKey The application key unique to each application.
     * @param name The name of the queue to create
     * @param deviceId The client deviceID (optional)
     * @param accountId The logged in user ID (optional)
     * @param workers The number of workers to generate  (optional, default to 1)
     * @param analyticTags If provided the analytic processing will publsih to this queue instead of the default one for the provided list of tags (optional)
     * @param hostname The hostname of the server the queue is hosted on (optional)
     * @param port The port of the server the queue is hosted on (optional)
     * @param username The username to access the server that the queue is on (optional)
     * @param password The password to access the queue to connect to (optional)
     * @param virtualHost The virtual host defined on the server to queue (optional)
     * @param useSSL Use SSL (optional)
     * @return RequestConfig
     */
    fun queueCreateRequestConfig(appKey: kotlin.String, name: kotlin.String, deviceId: kotlin.String?, accountId: kotlin.Long?, workers: kotlin.Int?, analyticTags: kotlin.String?, hostname: kotlin.String?, port: kotlin.Int?, username: kotlin.String?, password: kotlin.String?, virtualHost: kotlin.String?, useSSL: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                put("appKey", listOf(appKey.toString()))
                put("name", listOf(name.toString()))
                if (workers != null) {
                    put("workers", listOf(workers.toString()))
                }
                if (analyticTags != null) {
                    put("analyticTags", listOf(analyticTags.toString()))
                }
                if (hostname != null) {
                    put("hostname", listOf(hostname.toString()))
                }
                if (port != null) {
                    put("port", listOf(port.toString()))
                }
                if (username != null) {
                    put("username", listOf(username.toString()))
                }
                if (password != null) {
                    put("password", listOf(password.toString()))
                }
                if (virtualHost != null) {
                    put("virtualHost", listOf(virtualHost.toString()))
                }
                if (useSSL != null) {
                    put("useSSL", listOf(useSSL.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/queue/create",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /queue/delete
     * Delete Queue
     * Delete the stored queue record and close any active connections to the AMQP servers.
     * @param queueId The id of the queue to find
     * @param deviceId The client device ID (optional)
     * @param accountId The logged in user ID (optional)
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun queueDelete(queueId: kotlin.Long, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null) : SirqulResponse {
        val localVarResponse = queueDeleteWithHttpInfo(queueId = queueId, deviceId = deviceId, accountId = accountId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /queue/delete
     * Delete Queue
     * Delete the stored queue record and close any active connections to the AMQP servers.
     * @param queueId The id of the queue to find
     * @param deviceId The client device ID (optional)
     * @param accountId The logged in user ID (optional)
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun queueDeleteWithHttpInfo(queueId: kotlin.Long, deviceId: kotlin.String?, accountId: kotlin.Long?) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = queueDeleteRequestConfig(queueId = queueId, deviceId = deviceId, accountId = accountId)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation queueDelete
     *
     * @param queueId The id of the queue to find
     * @param deviceId The client device ID (optional)
     * @param accountId The logged in user ID (optional)
     * @return RequestConfig
     */
    fun queueDeleteRequestConfig(queueId: kotlin.Long, deviceId: kotlin.String?, accountId: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                put("queueId", listOf(queueId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/queue/delete",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /queue/get
     * Get Queue
     * Get the stored queue record. Must supply the queueId, or the name and hostname and virtualHost, or the name and appKey to find the record.
     * @param deviceId The client device ID (optional)
     * @param accountId The logged in user ID (optional)
     * @param queueId The id of the queue to find (optional)
     * @param appKey The application key the queue was assigned to (optional)
     * @param name The name of the queue to find (optional)
     * @param hostname The hostname of the queue to find (optional)
     * @param virtualHost The virtual host of the queue to find (optional)
     * @return QueueResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun queueGet(deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, queueId: kotlin.Long? = null, appKey: kotlin.String? = null, name: kotlin.String? = null, hostname: kotlin.String? = null, virtualHost: kotlin.String? = null) : QueueResponse {
        val localVarResponse = queueGetWithHttpInfo(deviceId = deviceId, accountId = accountId, queueId = queueId, appKey = appKey, name = name, hostname = hostname, virtualHost = virtualHost)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as QueueResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /queue/get
     * Get Queue
     * Get the stored queue record. Must supply the queueId, or the name and hostname and virtualHost, or the name and appKey to find the record.
     * @param deviceId The client device ID (optional)
     * @param accountId The logged in user ID (optional)
     * @param queueId The id of the queue to find (optional)
     * @param appKey The application key the queue was assigned to (optional)
     * @param name The name of the queue to find (optional)
     * @param hostname The hostname of the queue to find (optional)
     * @param virtualHost The virtual host of the queue to find (optional)
     * @return ApiResponse<QueueResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun queueGetWithHttpInfo(deviceId: kotlin.String?, accountId: kotlin.Long?, queueId: kotlin.Long?, appKey: kotlin.String?, name: kotlin.String?, hostname: kotlin.String?, virtualHost: kotlin.String?) : ApiResponse<QueueResponse?> {
        val localVariableConfig = queueGetRequestConfig(deviceId = deviceId, accountId = accountId, queueId = queueId, appKey = appKey, name = name, hostname = hostname, virtualHost = virtualHost)

        return request<Unit, QueueResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation queueGet
     *
     * @param deviceId The client device ID (optional)
     * @param accountId The logged in user ID (optional)
     * @param queueId The id of the queue to find (optional)
     * @param appKey The application key the queue was assigned to (optional)
     * @param name The name of the queue to find (optional)
     * @param hostname The hostname of the queue to find (optional)
     * @param virtualHost The virtual host of the queue to find (optional)
     * @return RequestConfig
     */
    fun queueGetRequestConfig(deviceId: kotlin.String?, accountId: kotlin.Long?, queueId: kotlin.Long?, appKey: kotlin.String?, name: kotlin.String?, hostname: kotlin.String?, virtualHost: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (queueId != null) {
                    put("queueId", listOf(queueId.toString()))
                }
                if (appKey != null) {
                    put("appKey", listOf(appKey.toString()))
                }
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (hostname != null) {
                    put("hostname", listOf(hostname.toString()))
                }
                if (virtualHost != null) {
                    put("virtualHost", listOf(virtualHost.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/queue/get",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /queue/publish
     * Publish Queue
     * Publish a message to a stored queue. Must supply the queueId, or the name and hostname and virtualHost, or the name and appKey to find the record.
     * @param message The payload to send to the queue
     * @param queueId The id of the queue to publish to (optional)
     * @param appKey The application key the queue was assigned to (optional)
     * @param name The name of the queue to publish to or the analytic tag to handle if the analytic param is true (optional)
     * @param hostname The hostname of the server the queue is hosted on (optional)
     * @param virtualHost The virtual host defined on the server to queue (optional)
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun queuePublish(message: kotlin.String, queueId: kotlin.Long? = null, appKey: kotlin.String? = null, name: kotlin.String? = null, hostname: kotlin.String? = null, virtualHost: kotlin.String? = null) : SirqulResponse {
        val localVarResponse = queuePublishWithHttpInfo(message = message, queueId = queueId, appKey = appKey, name = name, hostname = hostname, virtualHost = virtualHost)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /queue/publish
     * Publish Queue
     * Publish a message to a stored queue. Must supply the queueId, or the name and hostname and virtualHost, or the name and appKey to find the record.
     * @param message The payload to send to the queue
     * @param queueId The id of the queue to publish to (optional)
     * @param appKey The application key the queue was assigned to (optional)
     * @param name The name of the queue to publish to or the analytic tag to handle if the analytic param is true (optional)
     * @param hostname The hostname of the server the queue is hosted on (optional)
     * @param virtualHost The virtual host defined on the server to queue (optional)
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun queuePublishWithHttpInfo(message: kotlin.String, queueId: kotlin.Long?, appKey: kotlin.String?, name: kotlin.String?, hostname: kotlin.String?, virtualHost: kotlin.String?) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = queuePublishRequestConfig(message = message, queueId = queueId, appKey = appKey, name = name, hostname = hostname, virtualHost = virtualHost)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation queuePublish
     *
     * @param message The payload to send to the queue
     * @param queueId The id of the queue to publish to (optional)
     * @param appKey The application key the queue was assigned to (optional)
     * @param name The name of the queue to publish to or the analytic tag to handle if the analytic param is true (optional)
     * @param hostname The hostname of the server the queue is hosted on (optional)
     * @param virtualHost The virtual host defined on the server to queue (optional)
     * @return RequestConfig
     */
    fun queuePublishRequestConfig(message: kotlin.String, queueId: kotlin.Long?, appKey: kotlin.String?, name: kotlin.String?, hostname: kotlin.String?, virtualHost: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (queueId != null) {
                    put("queueId", listOf(queueId.toString()))
                }
                if (appKey != null) {
                    put("appKey", listOf(appKey.toString()))
                }
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (hostname != null) {
                    put("hostname", listOf(hostname.toString()))
                }
                if (virtualHost != null) {
                    put("virtualHost", listOf(virtualHost.toString()))
                }
                put("message", listOf(message.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/queue/publish",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /queue/search
     * Search Queue
     * Get the queues setup for the BillableEntity&#39;s applications.
     * @param queueId The id of the queue to find (optional)
     * @param deviceId The client device ID (optional)
     * @param accountId The logged in user ID (optional)
     * @param name The name of the queue to find (optional)
     * @param start Start of the index (optional, default to 0)
     * @param limit Limit of the index (optional, default to 10)
     * @return QueueResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun queueSearch(queueId: kotlin.Long? = null, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, name: kotlin.String? = null, start: kotlin.Int? = 0, limit: kotlin.Int? = 10) : QueueResponse {
        val localVarResponse = queueSearchWithHttpInfo(queueId = queueId, deviceId = deviceId, accountId = accountId, name = name, start = start, limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as QueueResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /queue/search
     * Search Queue
     * Get the queues setup for the BillableEntity&#39;s applications.
     * @param queueId The id of the queue to find (optional)
     * @param deviceId The client device ID (optional)
     * @param accountId The logged in user ID (optional)
     * @param name The name of the queue to find (optional)
     * @param start Start of the index (optional, default to 0)
     * @param limit Limit of the index (optional, default to 10)
     * @return ApiResponse<QueueResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun queueSearchWithHttpInfo(queueId: kotlin.Long?, deviceId: kotlin.String?, accountId: kotlin.Long?, name: kotlin.String?, start: kotlin.Int?, limit: kotlin.Int?) : ApiResponse<QueueResponse?> {
        val localVariableConfig = queueSearchRequestConfig(queueId = queueId, deviceId = deviceId, accountId = accountId, name = name, start = start, limit = limit)

        return request<Unit, QueueResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation queueSearch
     *
     * @param queueId The id of the queue to find (optional)
     * @param deviceId The client device ID (optional)
     * @param accountId The logged in user ID (optional)
     * @param name The name of the queue to find (optional)
     * @param start Start of the index (optional, default to 0)
     * @param limit Limit of the index (optional, default to 10)
     * @return RequestConfig
     */
    fun queueSearchRequestConfig(queueId: kotlin.Long?, deviceId: kotlin.String?, accountId: kotlin.Long?, name: kotlin.String?, start: kotlin.Int?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (queueId != null) {
                    put("queueId", listOf(queueId.toString()))
                }
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/queue/search",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /queue/update
     * Update Queue
     * Update the basic AMQP queue.
     * @param queueId The id of the queue to update
     * @param deviceId The client deviceID (optional)
     * @param accountId The logged in user ID (optional)
     * @param appKey The application key unique to each application. (optional)
     * @param workers The number of workers to generate (optional)
     * @param analyticTags If provided the analytic processing will publsih to this queue instead of the default one for the provided list of tags (optional)
     * @param hostname The hostname of the server the queue is hosted on (optional)
     * @param port The port of the server the queue is hosted on (optional)
     * @param username The username to access the server that the queue is on (optional)
     * @param password The password to access the queue to connect to (optional)
     * @param virtualHost The virtual host defined on the server to queue (optional)
     * @param useSSL the SSL to use (optional)
     * @return QueueResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun queueUpdate(queueId: kotlin.Long, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, appKey: kotlin.String? = null, workers: kotlin.Int? = null, analyticTags: kotlin.String? = null, hostname: kotlin.String? = null, port: kotlin.Int? = null, username: kotlin.String? = null, password: kotlin.String? = null, virtualHost: kotlin.String? = null, useSSL: kotlin.Boolean? = null) : QueueResponse {
        val localVarResponse = queueUpdateWithHttpInfo(queueId = queueId, deviceId = deviceId, accountId = accountId, appKey = appKey, workers = workers, analyticTags = analyticTags, hostname = hostname, port = port, username = username, password = password, virtualHost = virtualHost, useSSL = useSSL)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as QueueResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /queue/update
     * Update Queue
     * Update the basic AMQP queue.
     * @param queueId The id of the queue to update
     * @param deviceId The client deviceID (optional)
     * @param accountId The logged in user ID (optional)
     * @param appKey The application key unique to each application. (optional)
     * @param workers The number of workers to generate (optional)
     * @param analyticTags If provided the analytic processing will publsih to this queue instead of the default one for the provided list of tags (optional)
     * @param hostname The hostname of the server the queue is hosted on (optional)
     * @param port The port of the server the queue is hosted on (optional)
     * @param username The username to access the server that the queue is on (optional)
     * @param password The password to access the queue to connect to (optional)
     * @param virtualHost The virtual host defined on the server to queue (optional)
     * @param useSSL the SSL to use (optional)
     * @return ApiResponse<QueueResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun queueUpdateWithHttpInfo(queueId: kotlin.Long, deviceId: kotlin.String?, accountId: kotlin.Long?, appKey: kotlin.String?, workers: kotlin.Int?, analyticTags: kotlin.String?, hostname: kotlin.String?, port: kotlin.Int?, username: kotlin.String?, password: kotlin.String?, virtualHost: kotlin.String?, useSSL: kotlin.Boolean?) : ApiResponse<QueueResponse?> {
        val localVariableConfig = queueUpdateRequestConfig(queueId = queueId, deviceId = deviceId, accountId = accountId, appKey = appKey, workers = workers, analyticTags = analyticTags, hostname = hostname, port = port, username = username, password = password, virtualHost = virtualHost, useSSL = useSSL)

        return request<Unit, QueueResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation queueUpdate
     *
     * @param queueId The id of the queue to update
     * @param deviceId The client deviceID (optional)
     * @param accountId The logged in user ID (optional)
     * @param appKey The application key unique to each application. (optional)
     * @param workers The number of workers to generate (optional)
     * @param analyticTags If provided the analytic processing will publsih to this queue instead of the default one for the provided list of tags (optional)
     * @param hostname The hostname of the server the queue is hosted on (optional)
     * @param port The port of the server the queue is hosted on (optional)
     * @param username The username to access the server that the queue is on (optional)
     * @param password The password to access the queue to connect to (optional)
     * @param virtualHost The virtual host defined on the server to queue (optional)
     * @param useSSL the SSL to use (optional)
     * @return RequestConfig
     */
    fun queueUpdateRequestConfig(queueId: kotlin.Long, deviceId: kotlin.String?, accountId: kotlin.Long?, appKey: kotlin.String?, workers: kotlin.Int?, analyticTags: kotlin.String?, hostname: kotlin.String?, port: kotlin.Int?, username: kotlin.String?, password: kotlin.String?, virtualHost: kotlin.String?, useSSL: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (appKey != null) {
                    put("appKey", listOf(appKey.toString()))
                }
                put("queueId", listOf(queueId.toString()))
                if (workers != null) {
                    put("workers", listOf(workers.toString()))
                }
                if (analyticTags != null) {
                    put("analyticTags", listOf(analyticTags.toString()))
                }
                if (hostname != null) {
                    put("hostname", listOf(hostname.toString()))
                }
                if (port != null) {
                    put("port", listOf(port.toString()))
                }
                if (username != null) {
                    put("username", listOf(username.toString()))
                }
                if (password != null) {
                    put("password", listOf(password.toString()))
                }
                if (virtualHost != null) {
                    put("virtualHost", listOf(virtualHost.toString()))
                }
                if (useSSL != null) {
                    put("useSSL", listOf(useSSL.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/queue/update",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
