/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import org.openapitools.client.models.ScoreResponse

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

open class ScoreApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost")
        }
    }

    /**
     * POST /api/{version}/score/create
     * Create Score
     * Create a score.  The response object will contain a series of   coded messages detailing what items were completed, the score registered,   and any tickets allocated.  Scoring a  level could complete the pack it   is in, completing that pack could complete the game, which  in turn could   complete the mission.  This completion chain is indicated to the client   via  a list of {@link MessageResponse}.
     * @param version 
     * @param accountId The logged in user.
     * @param appKey The game application key to save the score for.
     * @param points The score
     * @param missionId The missionId to score for, ignore if not playing mission. (optional)
     * @param gameId The gameId to score for, ignore if not playing mission. (optional)
     * @param packId The packId to score for, send -2 if playing community levels. (optional)
     * @param gameLevelId The gameLevelId to score for. (optional)
     * @param gameObjectId The gameObjectId to score for, ignore if level based scoring. (optional)
     * @param timeTaken The time taken to complete task (optional)
     * @param highest  (optional)
     * @return ScoreResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createScore(version: java.math.BigDecimal, accountId: kotlin.Long, appKey: kotlin.String, points: kotlin.Int, missionId: kotlin.Long? = null, gameId: kotlin.Long? = null, packId: kotlin.Long? = null, gameLevelId: kotlin.Long? = null, gameObjectId: kotlin.Long? = null, timeTaken: kotlin.Int? = null, highest: kotlin.Boolean? = null) : ScoreResponse {
        val localVarResponse = createScoreWithHttpInfo(version = version, accountId = accountId, appKey = appKey, points = points, missionId = missionId, gameId = gameId, packId = packId, gameLevelId = gameLevelId, gameObjectId = gameObjectId, timeTaken = timeTaken, highest = highest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ScoreResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/{version}/score/create
     * Create Score
     * Create a score.  The response object will contain a series of   coded messages detailing what items were completed, the score registered,   and any tickets allocated.  Scoring a  level could complete the pack it   is in, completing that pack could complete the game, which  in turn could   complete the mission.  This completion chain is indicated to the client   via  a list of {@link MessageResponse}.
     * @param version 
     * @param accountId The logged in user.
     * @param appKey The game application key to save the score for.
     * @param points The score
     * @param missionId The missionId to score for, ignore if not playing mission. (optional)
     * @param gameId The gameId to score for, ignore if not playing mission. (optional)
     * @param packId The packId to score for, send -2 if playing community levels. (optional)
     * @param gameLevelId The gameLevelId to score for. (optional)
     * @param gameObjectId The gameObjectId to score for, ignore if level based scoring. (optional)
     * @param timeTaken The time taken to complete task (optional)
     * @param highest  (optional)
     * @return ApiResponse<ScoreResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createScoreWithHttpInfo(version: java.math.BigDecimal, accountId: kotlin.Long, appKey: kotlin.String, points: kotlin.Int, missionId: kotlin.Long?, gameId: kotlin.Long?, packId: kotlin.Long?, gameLevelId: kotlin.Long?, gameObjectId: kotlin.Long?, timeTaken: kotlin.Int?, highest: kotlin.Boolean?) : ApiResponse<ScoreResponse?> {
        val localVariableConfig = createScoreRequestConfig(version = version, accountId = accountId, appKey = appKey, points = points, missionId = missionId, gameId = gameId, packId = packId, gameLevelId = gameLevelId, gameObjectId = gameObjectId, timeTaken = timeTaken, highest = highest)

        return request<Unit, ScoreResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createScore
     *
     * @param version 
     * @param accountId The logged in user.
     * @param appKey The game application key to save the score for.
     * @param points The score
     * @param missionId The missionId to score for, ignore if not playing mission. (optional)
     * @param gameId The gameId to score for, ignore if not playing mission. (optional)
     * @param packId The packId to score for, send -2 if playing community levels. (optional)
     * @param gameLevelId The gameLevelId to score for. (optional)
     * @param gameObjectId The gameObjectId to score for, ignore if level based scoring. (optional)
     * @param timeTaken The time taken to complete task (optional)
     * @param highest  (optional)
     * @return RequestConfig
     */
    fun createScoreRequestConfig(version: java.math.BigDecimal, accountId: kotlin.Long, appKey: kotlin.String, points: kotlin.Int, missionId: kotlin.Long?, gameId: kotlin.Long?, packId: kotlin.Long?, gameLevelId: kotlin.Long?, gameObjectId: kotlin.Long?, timeTaken: kotlin.Int?, highest: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("appKey", listOf(appKey.toString()))
                if (missionId != null) {
                    put("missionId", listOf(missionId.toString()))
                }
                if (gameId != null) {
                    put("gameId", listOf(gameId.toString()))
                }
                if (packId != null) {
                    put("packId", listOf(packId.toString()))
                }
                if (gameLevelId != null) {
                    put("gameLevelId", listOf(gameLevelId.toString()))
                }
                if (gameObjectId != null) {
                    put("gameObjectId", listOf(gameObjectId.toString()))
                }
                put("points", listOf(points.toString()))
                if (timeTaken != null) {
                    put("timeTaken", listOf(timeTaken.toString()))
                }
                if (highest != null) {
                    put("highest", listOf(highest.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/{version}/score/create".replace("{"+"version"+"}", encodeURIComponent(version.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /api/{version}/score/get
     * Get Score
     * Get the high score for an item.  Pass in the full path IDs for the score.
     * @param version 
     * @param accountId The logged in user.
     * @param appKey The game application key to get the level for.
     * @param missionId The missionId to score for, null if not playing mission. (optional)
     * @param gameId The gameId to score for, null if not playing mission. (optional)
     * @param packId The packId to score for, null if playing community levels. (optional)
     * @param gameLevelId The gameLevelId to score for. (optional)
     * @param gameObjectId The gameObjectId to score for, null if level based scoring. (optional)
     * @param scoreObjectType The object type to filter scores by (TicketObjectType) (optional)
     * @param scoreStatus The status of the score to filter (ScoreStatus) (optional)
     * @return ScoreResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getScore(version: java.math.BigDecimal, accountId: kotlin.Long, appKey: kotlin.String, missionId: kotlin.Long? = null, gameId: kotlin.Long? = null, packId: kotlin.Long? = null, gameLevelId: kotlin.Long? = null, gameObjectId: kotlin.Long? = null, scoreObjectType: kotlin.String? = null, scoreStatus: kotlin.String? = null) : ScoreResponse {
        val localVarResponse = getScoreWithHttpInfo(version = version, accountId = accountId, appKey = appKey, missionId = missionId, gameId = gameId, packId = packId, gameLevelId = gameLevelId, gameObjectId = gameObjectId, scoreObjectType = scoreObjectType, scoreStatus = scoreStatus)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ScoreResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/{version}/score/get
     * Get Score
     * Get the high score for an item.  Pass in the full path IDs for the score.
     * @param version 
     * @param accountId The logged in user.
     * @param appKey The game application key to get the level for.
     * @param missionId The missionId to score for, null if not playing mission. (optional)
     * @param gameId The gameId to score for, null if not playing mission. (optional)
     * @param packId The packId to score for, null if playing community levels. (optional)
     * @param gameLevelId The gameLevelId to score for. (optional)
     * @param gameObjectId The gameObjectId to score for, null if level based scoring. (optional)
     * @param scoreObjectType The object type to filter scores by (TicketObjectType) (optional)
     * @param scoreStatus The status of the score to filter (ScoreStatus) (optional)
     * @return ApiResponse<ScoreResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getScoreWithHttpInfo(version: java.math.BigDecimal, accountId: kotlin.Long, appKey: kotlin.String, missionId: kotlin.Long?, gameId: kotlin.Long?, packId: kotlin.Long?, gameLevelId: kotlin.Long?, gameObjectId: kotlin.Long?, scoreObjectType: kotlin.String?, scoreStatus: kotlin.String?) : ApiResponse<ScoreResponse?> {
        val localVariableConfig = getScoreRequestConfig(version = version, accountId = accountId, appKey = appKey, missionId = missionId, gameId = gameId, packId = packId, gameLevelId = gameLevelId, gameObjectId = gameObjectId, scoreObjectType = scoreObjectType, scoreStatus = scoreStatus)

        return request<Unit, ScoreResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getScore
     *
     * @param version 
     * @param accountId The logged in user.
     * @param appKey The game application key to get the level for.
     * @param missionId The missionId to score for, null if not playing mission. (optional)
     * @param gameId The gameId to score for, null if not playing mission. (optional)
     * @param packId The packId to score for, null if playing community levels. (optional)
     * @param gameLevelId The gameLevelId to score for. (optional)
     * @param gameObjectId The gameObjectId to score for, null if level based scoring. (optional)
     * @param scoreObjectType The object type to filter scores by (TicketObjectType) (optional)
     * @param scoreStatus The status of the score to filter (ScoreStatus) (optional)
     * @return RequestConfig
     */
    fun getScoreRequestConfig(version: java.math.BigDecimal, accountId: kotlin.Long, appKey: kotlin.String, missionId: kotlin.Long?, gameId: kotlin.Long?, packId: kotlin.Long?, gameLevelId: kotlin.Long?, gameObjectId: kotlin.Long?, scoreObjectType: kotlin.String?, scoreStatus: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("appKey", listOf(appKey.toString()))
                if (missionId != null) {
                    put("missionId", listOf(missionId.toString()))
                }
                if (gameId != null) {
                    put("gameId", listOf(gameId.toString()))
                }
                if (packId != null) {
                    put("packId", listOf(packId.toString()))
                }
                if (gameLevelId != null) {
                    put("gameLevelId", listOf(gameLevelId.toString()))
                }
                if (gameObjectId != null) {
                    put("gameObjectId", listOf(gameObjectId.toString()))
                }
                if (scoreObjectType != null) {
                    put("scoreObjectType", listOf(scoreObjectType.toString()))
                }
                if (scoreStatus != null) {
                    put("scoreStatus", listOf(scoreStatus.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/{version}/score/get".replace("{"+"version"+"}", encodeURIComponent(version.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /api/{version}/score/search
     * Search Score
     * Search the scores for an item.  Pass in the full path IDs for the scores.
     * @param version 
     * @param accountId The logged in user.
     * @param appKey The game application key to get the level for.
     * @param missionId The missionId to score for, null if not playing mission. (optional)
     * @param gameId The gameId to score for, null if not playing mission. (optional)
     * @param packId The packId to score for, null if playing community levels. (optional)
     * @param gameLevelId The gameLevelId to score for. (optional)
     * @param gameObjectId The gameObjectId to score for, null if level based scoring. (optional)
     * @return kotlin.collections.List<ScoreResponse>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun searchScores(version: java.math.BigDecimal, accountId: kotlin.Long, appKey: kotlin.String, missionId: kotlin.Long? = null, gameId: kotlin.Long? = null, packId: kotlin.Long? = null, gameLevelId: kotlin.Long? = null, gameObjectId: kotlin.Long? = null) : kotlin.collections.List<ScoreResponse> {
        val localVarResponse = searchScoresWithHttpInfo(version = version, accountId = accountId, appKey = appKey, missionId = missionId, gameId = gameId, packId = packId, gameLevelId = gameLevelId, gameObjectId = gameObjectId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<ScoreResponse>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/{version}/score/search
     * Search Score
     * Search the scores for an item.  Pass in the full path IDs for the scores.
     * @param version 
     * @param accountId The logged in user.
     * @param appKey The game application key to get the level for.
     * @param missionId The missionId to score for, null if not playing mission. (optional)
     * @param gameId The gameId to score for, null if not playing mission. (optional)
     * @param packId The packId to score for, null if playing community levels. (optional)
     * @param gameLevelId The gameLevelId to score for. (optional)
     * @param gameObjectId The gameObjectId to score for, null if level based scoring. (optional)
     * @return ApiResponse<kotlin.collections.List<ScoreResponse>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun searchScoresWithHttpInfo(version: java.math.BigDecimal, accountId: kotlin.Long, appKey: kotlin.String, missionId: kotlin.Long?, gameId: kotlin.Long?, packId: kotlin.Long?, gameLevelId: kotlin.Long?, gameObjectId: kotlin.Long?) : ApiResponse<kotlin.collections.List<ScoreResponse>?> {
        val localVariableConfig = searchScoresRequestConfig(version = version, accountId = accountId, appKey = appKey, missionId = missionId, gameId = gameId, packId = packId, gameLevelId = gameLevelId, gameObjectId = gameObjectId)

        return request<Unit, kotlin.collections.List<ScoreResponse>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation searchScores
     *
     * @param version 
     * @param accountId The logged in user.
     * @param appKey The game application key to get the level for.
     * @param missionId The missionId to score for, null if not playing mission. (optional)
     * @param gameId The gameId to score for, null if not playing mission. (optional)
     * @param packId The packId to score for, null if playing community levels. (optional)
     * @param gameLevelId The gameLevelId to score for. (optional)
     * @param gameObjectId The gameObjectId to score for, null if level based scoring. (optional)
     * @return RequestConfig
     */
    fun searchScoresRequestConfig(version: java.math.BigDecimal, accountId: kotlin.Long, appKey: kotlin.String, missionId: kotlin.Long?, gameId: kotlin.Long?, packId: kotlin.Long?, gameLevelId: kotlin.Long?, gameObjectId: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("appKey", listOf(appKey.toString()))
                if (missionId != null) {
                    put("missionId", listOf(missionId.toString()))
                }
                if (gameId != null) {
                    put("gameId", listOf(gameId.toString()))
                }
                if (packId != null) {
                    put("packId", listOf(packId.toString()))
                }
                if (gameLevelId != null) {
                    put("gameLevelId", listOf(gameLevelId.toString()))
                }
                if (gameObjectId != null) {
                    put("gameObjectId", listOf(gameObjectId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/{version}/score/search".replace("{"+"version"+"}", encodeURIComponent(version.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
