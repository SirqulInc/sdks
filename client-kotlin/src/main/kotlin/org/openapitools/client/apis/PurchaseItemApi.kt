/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import org.openapitools.client.models.PurchaseItemFullResponse
import org.openapitools.client.models.PurchaseItemResponse
import org.openapitools.client.models.SirqulResponse

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

open class PurchaseItemApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://dev.sirqul.com/api/3.18")
        }
    }

    /**
     * enum for parameter purchaseType
     */
     enum class PurchaseTypeCreatePurchaseItem(val value: kotlin.String) {
         @Json(name = "SIRQUL") SIRQUL("SIRQUL"),
         @Json(name = "IOS") IOS("IOS"),
         @Json(name = "GOOGLE") GOOGLE("GOOGLE"),
         @Json(name = "AMAZON") AMAZON("AMAZON"),
         @Json(name = "MAC") MAC("MAC"),
         @Json(name = "WP8") WP8("WP8"),
         @Json(name = "FREE") FREE("FREE");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter serviceAction
     */
     enum class ServiceActionCreatePurchaseItem(val value: kotlin.String) {
         @Json(name = "DAY_PREMIUM") DAY_PREMIUM("DAY_PREMIUM"),
         @Json(name = "WEEK_PREMIUM") WEEK_PREMIUM("WEEK_PREMIUM"),
         @Json(name = "MONTH_PREMIUM") MONTH_PREMIUM("MONTH_PREMIUM"),
         @Json(name = "YEAR_PREMIUM") YEAR_PREMIUM("YEAR_PREMIUM"),
         @Json(name = "LIFETIME_PREMIUM") LIFETIME_PREMIUM("LIFETIME_PREMIUM"),
         @Json(name = "ADD_TICKET") ADD_TICKET("ADD_TICKET"),
         @Json(name = "ADD_GIFT") ADD_GIFT("ADD_GIFT"),
         @Json(name = "ADD_POINTS") ADD_POINTS("ADD_POINTS");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * POST /purchase/create
     * Create Purchase
     * Creates a purchase item for in app purchases
     * @param appKey The application key that the purchase can be used in
     * @param name The name of the purchase item
     * @param purchaseType The purchase provider &lt;ul&gt; &lt;li&gt;SIRQUL - the Sirqul store to make purchases using tickets&lt;/li&gt; &lt;li&gt;IOS - the iTunes store for iPhone, iPod, iPod Touch&lt;/li&gt; &lt;li&gt;GOOGLE - the Google Play store&lt;/li&gt; &lt;li&gt;AMAZON - the Amazon Android store&lt;/li&gt; &lt;li&gt;MAC - the iTunes store for OSX&lt;/li&gt; &lt;li&gt;WP8 - the Windows Phone 8 store&lt;/li&gt; &lt;li&gt;FREE - used for purchase items that are free (can be used for development/testing purposes)&lt;/li&gt; &lt;/ul&gt;
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param description The description of the purchase item (optional)
     * @param tickets How much the purchase item is worth in tickets (optional)
     * @param price How much the purchase item will cost in real money (optional)
     * @param purchaseCode The unique identifier used by purchase providers to identify in-app-purchases (optional)
     * @param secretKey A secret key from purchase providers that would be used for validation (optional)
     * @param purchaseLimit How many times a user acquire the same purchase item (optional, default to 0)
     * @param serviceAction Determines whether the purchase item will enable certain features &lt;ul&gt; &lt;li&gt;DAY_PREMIUM - subscribes a user for a day of membership&lt;/li&gt; &lt;li&gt;WEEK_PREMIUM - subscribes a user for a week of membership&lt;/li&gt; &lt;li&gt;MONTH_PREMIUM - subscribes a user for a month of membership&lt;/li&gt; &lt;li&gt;ADD_TICKET - allows a user to add more tickets to their account&lt;/li&gt; &lt;li&gt;ADD_GIFT - allows a user to send/recieve the purchase item as a gift&lt;/li&gt; &lt;/ul&gt; (optional)
     * @param coverAssetId The cover image of the purchase item (optional)
     * @param promoAssetId An application specific asset that can be used to store/provide additional data (optional)
     * @param giftable Determines whether the purchase item can be gifted to other users (optional)
     * @param assetable Determines whether users can attach their own media/asset to the purchase item (optional)
     * @param allocateTickets Flag to indicate owner should receive tickets for completed missions (optional, default to false)
     * @param ticketType The type of ticket to reward, null means default type (optional)
     * @param points The number of points to award for completing a mission (optional)
     * @param offerLocationId The offer location that will get added to the user&#39;s wallet after purchase. (optional)
     * @return PurchaseItemFullResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createPurchaseItem(appKey: kotlin.String, name: kotlin.String, purchaseType: PurchaseTypeCreatePurchaseItem, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, description: kotlin.String? = null, tickets: kotlin.Int? = null, price: kotlin.Float? = null, purchaseCode: kotlin.String? = null, secretKey: kotlin.String? = null, purchaseLimit: kotlin.Int? = 0, serviceAction: ServiceActionCreatePurchaseItem? = null, coverAssetId: kotlin.Long? = null, promoAssetId: kotlin.Long? = null, giftable: kotlin.Boolean? = null, assetable: kotlin.Boolean? = null, allocateTickets: kotlin.Boolean? = false, ticketType: kotlin.String? = null, points: kotlin.Long? = null, offerLocationId: kotlin.Long? = null) : PurchaseItemFullResponse {
        val localVarResponse = createPurchaseItemWithHttpInfo(appKey = appKey, name = name, purchaseType = purchaseType, deviceId = deviceId, accountId = accountId, description = description, tickets = tickets, price = price, purchaseCode = purchaseCode, secretKey = secretKey, purchaseLimit = purchaseLimit, serviceAction = serviceAction, coverAssetId = coverAssetId, promoAssetId = promoAssetId, giftable = giftable, assetable = assetable, allocateTickets = allocateTickets, ticketType = ticketType, points = points, offerLocationId = offerLocationId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PurchaseItemFullResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /purchase/create
     * Create Purchase
     * Creates a purchase item for in app purchases
     * @param appKey The application key that the purchase can be used in
     * @param name The name of the purchase item
     * @param purchaseType The purchase provider &lt;ul&gt; &lt;li&gt;SIRQUL - the Sirqul store to make purchases using tickets&lt;/li&gt; &lt;li&gt;IOS - the iTunes store for iPhone, iPod, iPod Touch&lt;/li&gt; &lt;li&gt;GOOGLE - the Google Play store&lt;/li&gt; &lt;li&gt;AMAZON - the Amazon Android store&lt;/li&gt; &lt;li&gt;MAC - the iTunes store for OSX&lt;/li&gt; &lt;li&gt;WP8 - the Windows Phone 8 store&lt;/li&gt; &lt;li&gt;FREE - used for purchase items that are free (can be used for development/testing purposes)&lt;/li&gt; &lt;/ul&gt;
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param description The description of the purchase item (optional)
     * @param tickets How much the purchase item is worth in tickets (optional)
     * @param price How much the purchase item will cost in real money (optional)
     * @param purchaseCode The unique identifier used by purchase providers to identify in-app-purchases (optional)
     * @param secretKey A secret key from purchase providers that would be used for validation (optional)
     * @param purchaseLimit How many times a user acquire the same purchase item (optional, default to 0)
     * @param serviceAction Determines whether the purchase item will enable certain features &lt;ul&gt; &lt;li&gt;DAY_PREMIUM - subscribes a user for a day of membership&lt;/li&gt; &lt;li&gt;WEEK_PREMIUM - subscribes a user for a week of membership&lt;/li&gt; &lt;li&gt;MONTH_PREMIUM - subscribes a user for a month of membership&lt;/li&gt; &lt;li&gt;ADD_TICKET - allows a user to add more tickets to their account&lt;/li&gt; &lt;li&gt;ADD_GIFT - allows a user to send/recieve the purchase item as a gift&lt;/li&gt; &lt;/ul&gt; (optional)
     * @param coverAssetId The cover image of the purchase item (optional)
     * @param promoAssetId An application specific asset that can be used to store/provide additional data (optional)
     * @param giftable Determines whether the purchase item can be gifted to other users (optional)
     * @param assetable Determines whether users can attach their own media/asset to the purchase item (optional)
     * @param allocateTickets Flag to indicate owner should receive tickets for completed missions (optional, default to false)
     * @param ticketType The type of ticket to reward, null means default type (optional)
     * @param points The number of points to award for completing a mission (optional)
     * @param offerLocationId The offer location that will get added to the user&#39;s wallet after purchase. (optional)
     * @return ApiResponse<PurchaseItemFullResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createPurchaseItemWithHttpInfo(appKey: kotlin.String, name: kotlin.String, purchaseType: PurchaseTypeCreatePurchaseItem, deviceId: kotlin.String?, accountId: kotlin.Long?, description: kotlin.String?, tickets: kotlin.Int?, price: kotlin.Float?, purchaseCode: kotlin.String?, secretKey: kotlin.String?, purchaseLimit: kotlin.Int?, serviceAction: ServiceActionCreatePurchaseItem?, coverAssetId: kotlin.Long?, promoAssetId: kotlin.Long?, giftable: kotlin.Boolean?, assetable: kotlin.Boolean?, allocateTickets: kotlin.Boolean?, ticketType: kotlin.String?, points: kotlin.Long?, offerLocationId: kotlin.Long?) : ApiResponse<PurchaseItemFullResponse?> {
        val localVariableConfig = createPurchaseItemRequestConfig(appKey = appKey, name = name, purchaseType = purchaseType, deviceId = deviceId, accountId = accountId, description = description, tickets = tickets, price = price, purchaseCode = purchaseCode, secretKey = secretKey, purchaseLimit = purchaseLimit, serviceAction = serviceAction, coverAssetId = coverAssetId, promoAssetId = promoAssetId, giftable = giftable, assetable = assetable, allocateTickets = allocateTickets, ticketType = ticketType, points = points, offerLocationId = offerLocationId)

        return request<Unit, PurchaseItemFullResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createPurchaseItem
     *
     * @param appKey The application key that the purchase can be used in
     * @param name The name of the purchase item
     * @param purchaseType The purchase provider &lt;ul&gt; &lt;li&gt;SIRQUL - the Sirqul store to make purchases using tickets&lt;/li&gt; &lt;li&gt;IOS - the iTunes store for iPhone, iPod, iPod Touch&lt;/li&gt; &lt;li&gt;GOOGLE - the Google Play store&lt;/li&gt; &lt;li&gt;AMAZON - the Amazon Android store&lt;/li&gt; &lt;li&gt;MAC - the iTunes store for OSX&lt;/li&gt; &lt;li&gt;WP8 - the Windows Phone 8 store&lt;/li&gt; &lt;li&gt;FREE - used for purchase items that are free (can be used for development/testing purposes)&lt;/li&gt; &lt;/ul&gt;
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param description The description of the purchase item (optional)
     * @param tickets How much the purchase item is worth in tickets (optional)
     * @param price How much the purchase item will cost in real money (optional)
     * @param purchaseCode The unique identifier used by purchase providers to identify in-app-purchases (optional)
     * @param secretKey A secret key from purchase providers that would be used for validation (optional)
     * @param purchaseLimit How many times a user acquire the same purchase item (optional, default to 0)
     * @param serviceAction Determines whether the purchase item will enable certain features &lt;ul&gt; &lt;li&gt;DAY_PREMIUM - subscribes a user for a day of membership&lt;/li&gt; &lt;li&gt;WEEK_PREMIUM - subscribes a user for a week of membership&lt;/li&gt; &lt;li&gt;MONTH_PREMIUM - subscribes a user for a month of membership&lt;/li&gt; &lt;li&gt;ADD_TICKET - allows a user to add more tickets to their account&lt;/li&gt; &lt;li&gt;ADD_GIFT - allows a user to send/recieve the purchase item as a gift&lt;/li&gt; &lt;/ul&gt; (optional)
     * @param coverAssetId The cover image of the purchase item (optional)
     * @param promoAssetId An application specific asset that can be used to store/provide additional data (optional)
     * @param giftable Determines whether the purchase item can be gifted to other users (optional)
     * @param assetable Determines whether users can attach their own media/asset to the purchase item (optional)
     * @param allocateTickets Flag to indicate owner should receive tickets for completed missions (optional, default to false)
     * @param ticketType The type of ticket to reward, null means default type (optional)
     * @param points The number of points to award for completing a mission (optional)
     * @param offerLocationId The offer location that will get added to the user&#39;s wallet after purchase. (optional)
     * @return RequestConfig
     */
    fun createPurchaseItemRequestConfig(appKey: kotlin.String, name: kotlin.String, purchaseType: PurchaseTypeCreatePurchaseItem, deviceId: kotlin.String?, accountId: kotlin.Long?, description: kotlin.String?, tickets: kotlin.Int?, price: kotlin.Float?, purchaseCode: kotlin.String?, secretKey: kotlin.String?, purchaseLimit: kotlin.Int?, serviceAction: ServiceActionCreatePurchaseItem?, coverAssetId: kotlin.Long?, promoAssetId: kotlin.Long?, giftable: kotlin.Boolean?, assetable: kotlin.Boolean?, allocateTickets: kotlin.Boolean?, ticketType: kotlin.String?, points: kotlin.Long?, offerLocationId: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                put("appKey", listOf(appKey.toString()))
                put("name", listOf(name.toString()))
                if (description != null) {
                    put("description", listOf(description.toString()))
                }
                if (tickets != null) {
                    put("tickets", listOf(tickets.toString()))
                }
                if (price != null) {
                    put("price", listOf(price.toString()))
                }
                put("purchaseType", listOf(purchaseType.value))
                if (purchaseCode != null) {
                    put("purchaseCode", listOf(purchaseCode.toString()))
                }
                if (secretKey != null) {
                    put("secretKey", listOf(secretKey.toString()))
                }
                if (purchaseLimit != null) {
                    put("purchaseLimit", listOf(purchaseLimit.toString()))
                }
                if (serviceAction != null) {
                    put("serviceAction", listOf(serviceAction.value))
                }
                if (coverAssetId != null) {
                    put("coverAssetId", listOf(coverAssetId.toString()))
                }
                if (promoAssetId != null) {
                    put("promoAssetId", listOf(promoAssetId.toString()))
                }
                if (giftable != null) {
                    put("giftable", listOf(giftable.toString()))
                }
                if (assetable != null) {
                    put("assetable", listOf(assetable.toString()))
                }
                if (allocateTickets != null) {
                    put("allocateTickets", listOf(allocateTickets.toString()))
                }
                if (ticketType != null) {
                    put("ticketType", listOf(ticketType.toString()))
                }
                if (points != null) {
                    put("points", listOf(points.toString()))
                }
                if (offerLocationId != null) {
                    put("offerLocationId", listOf(offerLocationId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/purchase/create",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /purchase/delete
     * Delete Purchase
     * Marks the purchase item as deleted
     * @param purchaseItemId The purchase item id
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deletePurchaseItem(purchaseItemId: kotlin.Long, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null) : SirqulResponse {
        val localVarResponse = deletePurchaseItemWithHttpInfo(purchaseItemId = purchaseItemId, deviceId = deviceId, accountId = accountId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /purchase/delete
     * Delete Purchase
     * Marks the purchase item as deleted
     * @param purchaseItemId The purchase item id
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deletePurchaseItemWithHttpInfo(purchaseItemId: kotlin.Long, deviceId: kotlin.String?, accountId: kotlin.Long?) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = deletePurchaseItemRequestConfig(purchaseItemId = purchaseItemId, deviceId = deviceId, accountId = accountId)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deletePurchaseItem
     *
     * @param purchaseItemId The purchase item id
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @return RequestConfig
     */
    fun deletePurchaseItemRequestConfig(purchaseItemId: kotlin.Long, deviceId: kotlin.String?, accountId: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                put("purchaseItemId", listOf(purchaseItemId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/purchase/delete",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /purchase/get
     * Get Purchase
     * Get detailed information about a purchase item
     * @param purchaseItemId The purchase item id
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @return PurchaseItemFullResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getPurchaseItem(purchaseItemId: kotlin.Long, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null) : PurchaseItemFullResponse {
        val localVarResponse = getPurchaseItemWithHttpInfo(purchaseItemId = purchaseItemId, deviceId = deviceId, accountId = accountId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PurchaseItemFullResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /purchase/get
     * Get Purchase
     * Get detailed information about a purchase item
     * @param purchaseItemId The purchase item id
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @return ApiResponse<PurchaseItemFullResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getPurchaseItemWithHttpInfo(purchaseItemId: kotlin.Long, deviceId: kotlin.String?, accountId: kotlin.Long?) : ApiResponse<PurchaseItemFullResponse?> {
        val localVariableConfig = getPurchaseItemRequestConfig(purchaseItemId = purchaseItemId, deviceId = deviceId, accountId = accountId)

        return request<Unit, PurchaseItemFullResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getPurchaseItem
     *
     * @param purchaseItemId The purchase item id
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @return RequestConfig
     */
    fun getPurchaseItemRequestConfig(purchaseItemId: kotlin.Long, deviceId: kotlin.String?, accountId: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                put("purchaseItemId", listOf(purchaseItemId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/purchase/get",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter sortField
     */
     enum class SortFieldSearchPurchaseItems(val value: kotlin.String) {
         @Json(name = "ID") ID("ID"),
         @Json(name = "CREATED") CREATED("CREATED"),
         @Json(name = "UPDATED") UPDATED("UPDATED"),
         @Json(name = "DELETED") DELETED("DELETED"),
         @Json(name = "SEARCH_TAGS") SEARCH_TAGS("SEARCH_TAGS"),
         @Json(name = "ACTIVE") ACTIVE("ACTIVE"),
         @Json(name = "NAME") NAME("NAME"),
         @Json(name = "DESCRIPTION") DESCRIPTION("DESCRIPTION"),
         @Json(name = "TICKETS") TICKETS("TICKETS"),
         @Json(name = "PRICE") PRICE("PRICE"),
         @Json(name = "PURCHASE_TYPE") PURCHASE_TYPE("PURCHASE_TYPE"),
         @Json(name = "PURCHASE_CODE") PURCHASE_CODE("PURCHASE_CODE"),
         @Json(name = "PURCHASE_LIMIT") PURCHASE_LIMIT("PURCHASE_LIMIT"),
         @Json(name = "SERIVCE_ACTION") SERIVCE_ACTION("SERIVCE_ACTION"),
         @Json(name = "GIFTABLE") GIFTABLE("GIFTABLE"),
         @Json(name = "ASSETABLE") ASSETABLE("ASSETABLE"),
         @Json(name = "APPLICATION_ID") APPLICATION_ID("APPLICATION_ID"),
         @Json(name = "APPLICATION_NAME") APPLICATION_NAME("APPLICATION_NAME");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /purchase/search
     * Search Purchases
     * Search for purchasable items from the system
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param appKey The application key to filter results by application (optional)
     * @param filterByBillable Determines whether to filter results by the user&#39;s billable entity (optional, default to false)
     * @param purchaseType A comma separated list of purchase providers to filter by. Possible values include: &lt;ul&gt; &lt;li&gt;SIRQUL - purchases from the Sirqul store using tickets&lt;/li&gt; &lt;li&gt;IOS - purchases from the iTunes store for iPhone, iPod, iPod Touch&lt;/li&gt; &lt;li&gt;GOOGLE - purchases from the Google Play store&lt;/li&gt; &lt;li&gt;AMAZON - purchases from the Amazon Android store&lt;/li&gt; &lt;li&gt;MAC - purchases from the iTunes store for OSX&lt;/li&gt; &lt;li&gt;WP8 - purchases from the Windows Phone 8 store&lt;/li&gt; &lt;li&gt;FREE - purchases that are free (can be used for development/testing purposes)&lt;/li&gt; &lt;/ul&gt; (optional)
     * @param serviceAction A comma separated list of service actions to filter results by. Possible values include: &lt;ul&gt; &lt;li&gt;DAY_PREMIUM - purchases that subscribes a user for a day of membership&lt;/li&gt; &lt;li&gt;WEEK_PREMIUM - purchases that subscribes a user for a week of membership&lt;/li&gt; &lt;li&gt;MONTH_PREMIUM - purchases that subscribes a user for a month of membership&lt;/li&gt; &lt;li&gt;ADD_TICKET - purchases that allow users to add more tickets&lt;/li&gt; &lt;li&gt;ADD_GIFT - purchases that allow users to recieve gifts&lt;/li&gt; &lt;/ul&gt; (optional)
     * @param keyword The keyword used to search (optional)
     * @param sortField The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, DETAILS, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, ESTIMATED_VALUE, VOUCHER_PRICE, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY (optional, default to SortField.NAME)
     * @param descending The order to return the search results (optional, default to false)
     * @param start The record to begin the return set on (optional, default to 0)
     * @param limit The number of records to return (optional, default to 20)
     * @param activeOnly Return only active results (optional, default to false)
     * @return kotlin.collections.List<PurchaseItemResponse>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun searchPurchaseItems(deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, appKey: kotlin.String? = null, filterByBillable: kotlin.Boolean? = false, purchaseType: kotlin.String? = null, serviceAction: kotlin.String? = null, keyword: kotlin.String? = null, sortField: SortFieldSearchPurchaseItems? = SortFieldSearchPurchaseItems.NAME, descending: kotlin.Boolean? = false, start: kotlin.Int? = 0, limit: kotlin.Int? = 20, activeOnly: kotlin.Boolean? = false) : kotlin.collections.List<PurchaseItemResponse> {
        val localVarResponse = searchPurchaseItemsWithHttpInfo(deviceId = deviceId, accountId = accountId, appKey = appKey, filterByBillable = filterByBillable, purchaseType = purchaseType, serviceAction = serviceAction, keyword = keyword, sortField = sortField, descending = descending, start = start, limit = limit, activeOnly = activeOnly)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<PurchaseItemResponse>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /purchase/search
     * Search Purchases
     * Search for purchasable items from the system
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param appKey The application key to filter results by application (optional)
     * @param filterByBillable Determines whether to filter results by the user&#39;s billable entity (optional, default to false)
     * @param purchaseType A comma separated list of purchase providers to filter by. Possible values include: &lt;ul&gt; &lt;li&gt;SIRQUL - purchases from the Sirqul store using tickets&lt;/li&gt; &lt;li&gt;IOS - purchases from the iTunes store for iPhone, iPod, iPod Touch&lt;/li&gt; &lt;li&gt;GOOGLE - purchases from the Google Play store&lt;/li&gt; &lt;li&gt;AMAZON - purchases from the Amazon Android store&lt;/li&gt; &lt;li&gt;MAC - purchases from the iTunes store for OSX&lt;/li&gt; &lt;li&gt;WP8 - purchases from the Windows Phone 8 store&lt;/li&gt; &lt;li&gt;FREE - purchases that are free (can be used for development/testing purposes)&lt;/li&gt; &lt;/ul&gt; (optional)
     * @param serviceAction A comma separated list of service actions to filter results by. Possible values include: &lt;ul&gt; &lt;li&gt;DAY_PREMIUM - purchases that subscribes a user for a day of membership&lt;/li&gt; &lt;li&gt;WEEK_PREMIUM - purchases that subscribes a user for a week of membership&lt;/li&gt; &lt;li&gt;MONTH_PREMIUM - purchases that subscribes a user for a month of membership&lt;/li&gt; &lt;li&gt;ADD_TICKET - purchases that allow users to add more tickets&lt;/li&gt; &lt;li&gt;ADD_GIFT - purchases that allow users to recieve gifts&lt;/li&gt; &lt;/ul&gt; (optional)
     * @param keyword The keyword used to search (optional)
     * @param sortField The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, DETAILS, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, ESTIMATED_VALUE, VOUCHER_PRICE, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY (optional, default to SortField.NAME)
     * @param descending The order to return the search results (optional, default to false)
     * @param start The record to begin the return set on (optional, default to 0)
     * @param limit The number of records to return (optional, default to 20)
     * @param activeOnly Return only active results (optional, default to false)
     * @return ApiResponse<kotlin.collections.List<PurchaseItemResponse>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun searchPurchaseItemsWithHttpInfo(deviceId: kotlin.String?, accountId: kotlin.Long?, appKey: kotlin.String?, filterByBillable: kotlin.Boolean?, purchaseType: kotlin.String?, serviceAction: kotlin.String?, keyword: kotlin.String?, sortField: SortFieldSearchPurchaseItems?, descending: kotlin.Boolean?, start: kotlin.Int?, limit: kotlin.Int?, activeOnly: kotlin.Boolean?) : ApiResponse<kotlin.collections.List<PurchaseItemResponse>?> {
        val localVariableConfig = searchPurchaseItemsRequestConfig(deviceId = deviceId, accountId = accountId, appKey = appKey, filterByBillable = filterByBillable, purchaseType = purchaseType, serviceAction = serviceAction, keyword = keyword, sortField = sortField, descending = descending, start = start, limit = limit, activeOnly = activeOnly)

        return request<Unit, kotlin.collections.List<PurchaseItemResponse>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation searchPurchaseItems
     *
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param appKey The application key to filter results by application (optional)
     * @param filterByBillable Determines whether to filter results by the user&#39;s billable entity (optional, default to false)
     * @param purchaseType A comma separated list of purchase providers to filter by. Possible values include: &lt;ul&gt; &lt;li&gt;SIRQUL - purchases from the Sirqul store using tickets&lt;/li&gt; &lt;li&gt;IOS - purchases from the iTunes store for iPhone, iPod, iPod Touch&lt;/li&gt; &lt;li&gt;GOOGLE - purchases from the Google Play store&lt;/li&gt; &lt;li&gt;AMAZON - purchases from the Amazon Android store&lt;/li&gt; &lt;li&gt;MAC - purchases from the iTunes store for OSX&lt;/li&gt; &lt;li&gt;WP8 - purchases from the Windows Phone 8 store&lt;/li&gt; &lt;li&gt;FREE - purchases that are free (can be used for development/testing purposes)&lt;/li&gt; &lt;/ul&gt; (optional)
     * @param serviceAction A comma separated list of service actions to filter results by. Possible values include: &lt;ul&gt; &lt;li&gt;DAY_PREMIUM - purchases that subscribes a user for a day of membership&lt;/li&gt; &lt;li&gt;WEEK_PREMIUM - purchases that subscribes a user for a week of membership&lt;/li&gt; &lt;li&gt;MONTH_PREMIUM - purchases that subscribes a user for a month of membership&lt;/li&gt; &lt;li&gt;ADD_TICKET - purchases that allow users to add more tickets&lt;/li&gt; &lt;li&gt;ADD_GIFT - purchases that allow users to recieve gifts&lt;/li&gt; &lt;/ul&gt; (optional)
     * @param keyword The keyword used to search (optional)
     * @param sortField The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, DETAILS, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, ESTIMATED_VALUE, VOUCHER_PRICE, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY (optional, default to SortField.NAME)
     * @param descending The order to return the search results (optional, default to false)
     * @param start The record to begin the return set on (optional, default to 0)
     * @param limit The number of records to return (optional, default to 20)
     * @param activeOnly Return only active results (optional, default to false)
     * @return RequestConfig
     */
    fun searchPurchaseItemsRequestConfig(deviceId: kotlin.String?, accountId: kotlin.Long?, appKey: kotlin.String?, filterByBillable: kotlin.Boolean?, purchaseType: kotlin.String?, serviceAction: kotlin.String?, keyword: kotlin.String?, sortField: SortFieldSearchPurchaseItems?, descending: kotlin.Boolean?, start: kotlin.Int?, limit: kotlin.Int?, activeOnly: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (appKey != null) {
                    put("appKey", listOf(appKey.toString()))
                }
                if (filterByBillable != null) {
                    put("filterByBillable", listOf(filterByBillable.toString()))
                }
                if (purchaseType != null) {
                    put("purchaseType", listOf(purchaseType.toString()))
                }
                if (serviceAction != null) {
                    put("serviceAction", listOf(serviceAction.toString()))
                }
                if (keyword != null) {
                    put("keyword", listOf(keyword.toString()))
                }
                if (sortField != null) {
                    put("sortField", listOf(sortField.value))
                }
                if (descending != null) {
                    put("descending", listOf(descending.toString()))
                }
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (activeOnly != null) {
                    put("activeOnly", listOf(activeOnly.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/purchase/search",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter purchaseType
     */
     enum class PurchaseTypeUpdatePurchaseItem(val value: kotlin.String) {
         @Json(name = "SIRQUL") SIRQUL("SIRQUL"),
         @Json(name = "IOS") IOS("IOS"),
         @Json(name = "GOOGLE") GOOGLE("GOOGLE"),
         @Json(name = "AMAZON") AMAZON("AMAZON"),
         @Json(name = "MAC") MAC("MAC"),
         @Json(name = "WP8") WP8("WP8"),
         @Json(name = "FREE") FREE("FREE");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter serviceAction
     */
     enum class ServiceActionUpdatePurchaseItem(val value: kotlin.String) {
         @Json(name = "DAY_PREMIUM") DAY_PREMIUM("DAY_PREMIUM"),
         @Json(name = "WEEK_PREMIUM") WEEK_PREMIUM("WEEK_PREMIUM"),
         @Json(name = "MONTH_PREMIUM") MONTH_PREMIUM("MONTH_PREMIUM"),
         @Json(name = "YEAR_PREMIUM") YEAR_PREMIUM("YEAR_PREMIUM"),
         @Json(name = "LIFETIME_PREMIUM") LIFETIME_PREMIUM("LIFETIME_PREMIUM"),
         @Json(name = "ADD_TICKET") ADD_TICKET("ADD_TICKET"),
         @Json(name = "ADD_GIFT") ADD_GIFT("ADD_GIFT"),
         @Json(name = "ADD_POINTS") ADD_POINTS("ADD_POINTS");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * POST /purchase/update
     * Update Purchase
     * Updates a purchase item for in app purchases
     * @param purchaseItemId The purchase item id
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param name The name of the purchase item (optional)
     * @param description The description of the purchase item (optional)
     * @param tickets How much the purchase item is worth in tickets (optional)
     * @param price How much the purchase item will cost in real money (optional)
     * @param purchaseType The purchase provider &lt;ul&gt; &lt;li&gt;SIRQUL - the Sirqul store to make purchases using tickets&lt;/li&gt; &lt;li&gt;IOS - the iTunes store for iPhone, iPod, iPod Touch&lt;/li&gt; &lt;li&gt;GOOGLE - the Google Play store&lt;/li&gt; &lt;li&gt;AMAZON - the Amazon Android store&lt;/li&gt; &lt;li&gt;MAC - the iTunes store for OSX&lt;/li&gt; &lt;li&gt;WP8 - the Windows Phone 8 store&lt;/li&gt; &lt;li&gt;FREE - used for purchase items that are free (can be used for development/testing purposes)&lt;/li&gt; &lt;/ul&gt; (optional)
     * @param purchaseCode The unique identifier used by purchase providers to identify in-app-purchases (optional)
     * @param secretKey A secret key from purchase providers that would be used for validation (optional)
     * @param purchaseLimit How many times a user acquire the same purchase item (optional)
     * @param serviceAction Determines whether the purchase item will enable certain features &lt;ul&gt; &lt;li&gt;DAY_PREMIUM - subscribes a user for a day of membership&lt;/li&gt; &lt;li&gt;WEEK_PREMIUM - subscribes a user for a week of membership&lt;/li&gt; &lt;li&gt;MONTH_PREMIUM - subscribes a user for a month of membership&lt;/li&gt; &lt;li&gt;ADD_TICKET - allows a user to add more tickets to their account&lt;/li&gt; &lt;li&gt;ADD_GIFT - allows a user to send/recieve the purchase item as a gift&lt;/li&gt; &lt;/ul&gt; (optional)
     * @param coverAssetId The cover image of the purchase item (optional)
     * @param promoAssetId An application specific asset that can be used to store/provide additional data (optional)
     * @param giftable Determines whether the purchase item can be gifted to other users (optional)
     * @param assetable Determines whether users can attach their own media/asset to the purchase item (optional)
     * @param active Sets whether the purchase item is active or inactive (hidden from consumers) (optional)
     * @param allocateTickets Flag to indicate owner should receive tickets for completed missions (optional, default to false)
     * @param ticketType The type of ticket to reward, null means default type (optional)
     * @param points The number of points to award for completing a mission (optional)
     * @param offerLocationId The offer location that will get added to the user&#39;s wallet after purchase. (optional)
     * @return PurchaseItemFullResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updatePurchaseItem(purchaseItemId: kotlin.Long, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, name: kotlin.String? = null, description: kotlin.String? = null, tickets: kotlin.Int? = null, price: kotlin.Float? = null, purchaseType: PurchaseTypeUpdatePurchaseItem? = null, purchaseCode: kotlin.String? = null, secretKey: kotlin.String? = null, purchaseLimit: kotlin.Int? = null, serviceAction: ServiceActionUpdatePurchaseItem? = null, coverAssetId: kotlin.Long? = null, promoAssetId: kotlin.Long? = null, giftable: kotlin.Boolean? = null, assetable: kotlin.Boolean? = null, active: kotlin.Boolean? = null, allocateTickets: kotlin.Boolean? = false, ticketType: kotlin.String? = null, points: kotlin.Long? = null, offerLocationId: kotlin.Long? = null) : PurchaseItemFullResponse {
        val localVarResponse = updatePurchaseItemWithHttpInfo(purchaseItemId = purchaseItemId, deviceId = deviceId, accountId = accountId, name = name, description = description, tickets = tickets, price = price, purchaseType = purchaseType, purchaseCode = purchaseCode, secretKey = secretKey, purchaseLimit = purchaseLimit, serviceAction = serviceAction, coverAssetId = coverAssetId, promoAssetId = promoAssetId, giftable = giftable, assetable = assetable, active = active, allocateTickets = allocateTickets, ticketType = ticketType, points = points, offerLocationId = offerLocationId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PurchaseItemFullResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /purchase/update
     * Update Purchase
     * Updates a purchase item for in app purchases
     * @param purchaseItemId The purchase item id
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param name The name of the purchase item (optional)
     * @param description The description of the purchase item (optional)
     * @param tickets How much the purchase item is worth in tickets (optional)
     * @param price How much the purchase item will cost in real money (optional)
     * @param purchaseType The purchase provider &lt;ul&gt; &lt;li&gt;SIRQUL - the Sirqul store to make purchases using tickets&lt;/li&gt; &lt;li&gt;IOS - the iTunes store for iPhone, iPod, iPod Touch&lt;/li&gt; &lt;li&gt;GOOGLE - the Google Play store&lt;/li&gt; &lt;li&gt;AMAZON - the Amazon Android store&lt;/li&gt; &lt;li&gt;MAC - the iTunes store for OSX&lt;/li&gt; &lt;li&gt;WP8 - the Windows Phone 8 store&lt;/li&gt; &lt;li&gt;FREE - used for purchase items that are free (can be used for development/testing purposes)&lt;/li&gt; &lt;/ul&gt; (optional)
     * @param purchaseCode The unique identifier used by purchase providers to identify in-app-purchases (optional)
     * @param secretKey A secret key from purchase providers that would be used for validation (optional)
     * @param purchaseLimit How many times a user acquire the same purchase item (optional)
     * @param serviceAction Determines whether the purchase item will enable certain features &lt;ul&gt; &lt;li&gt;DAY_PREMIUM - subscribes a user for a day of membership&lt;/li&gt; &lt;li&gt;WEEK_PREMIUM - subscribes a user for a week of membership&lt;/li&gt; &lt;li&gt;MONTH_PREMIUM - subscribes a user for a month of membership&lt;/li&gt; &lt;li&gt;ADD_TICKET - allows a user to add more tickets to their account&lt;/li&gt; &lt;li&gt;ADD_GIFT - allows a user to send/recieve the purchase item as a gift&lt;/li&gt; &lt;/ul&gt; (optional)
     * @param coverAssetId The cover image of the purchase item (optional)
     * @param promoAssetId An application specific asset that can be used to store/provide additional data (optional)
     * @param giftable Determines whether the purchase item can be gifted to other users (optional)
     * @param assetable Determines whether users can attach their own media/asset to the purchase item (optional)
     * @param active Sets whether the purchase item is active or inactive (hidden from consumers) (optional)
     * @param allocateTickets Flag to indicate owner should receive tickets for completed missions (optional, default to false)
     * @param ticketType The type of ticket to reward, null means default type (optional)
     * @param points The number of points to award for completing a mission (optional)
     * @param offerLocationId The offer location that will get added to the user&#39;s wallet after purchase. (optional)
     * @return ApiResponse<PurchaseItemFullResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun updatePurchaseItemWithHttpInfo(purchaseItemId: kotlin.Long, deviceId: kotlin.String?, accountId: kotlin.Long?, name: kotlin.String?, description: kotlin.String?, tickets: kotlin.Int?, price: kotlin.Float?, purchaseType: PurchaseTypeUpdatePurchaseItem?, purchaseCode: kotlin.String?, secretKey: kotlin.String?, purchaseLimit: kotlin.Int?, serviceAction: ServiceActionUpdatePurchaseItem?, coverAssetId: kotlin.Long?, promoAssetId: kotlin.Long?, giftable: kotlin.Boolean?, assetable: kotlin.Boolean?, active: kotlin.Boolean?, allocateTickets: kotlin.Boolean?, ticketType: kotlin.String?, points: kotlin.Long?, offerLocationId: kotlin.Long?) : ApiResponse<PurchaseItemFullResponse?> {
        val localVariableConfig = updatePurchaseItemRequestConfig(purchaseItemId = purchaseItemId, deviceId = deviceId, accountId = accountId, name = name, description = description, tickets = tickets, price = price, purchaseType = purchaseType, purchaseCode = purchaseCode, secretKey = secretKey, purchaseLimit = purchaseLimit, serviceAction = serviceAction, coverAssetId = coverAssetId, promoAssetId = promoAssetId, giftable = giftable, assetable = assetable, active = active, allocateTickets = allocateTickets, ticketType = ticketType, points = points, offerLocationId = offerLocationId)

        return request<Unit, PurchaseItemFullResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updatePurchaseItem
     *
     * @param purchaseItemId The purchase item id
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param name The name of the purchase item (optional)
     * @param description The description of the purchase item (optional)
     * @param tickets How much the purchase item is worth in tickets (optional)
     * @param price How much the purchase item will cost in real money (optional)
     * @param purchaseType The purchase provider &lt;ul&gt; &lt;li&gt;SIRQUL - the Sirqul store to make purchases using tickets&lt;/li&gt; &lt;li&gt;IOS - the iTunes store for iPhone, iPod, iPod Touch&lt;/li&gt; &lt;li&gt;GOOGLE - the Google Play store&lt;/li&gt; &lt;li&gt;AMAZON - the Amazon Android store&lt;/li&gt; &lt;li&gt;MAC - the iTunes store for OSX&lt;/li&gt; &lt;li&gt;WP8 - the Windows Phone 8 store&lt;/li&gt; &lt;li&gt;FREE - used for purchase items that are free (can be used for development/testing purposes)&lt;/li&gt; &lt;/ul&gt; (optional)
     * @param purchaseCode The unique identifier used by purchase providers to identify in-app-purchases (optional)
     * @param secretKey A secret key from purchase providers that would be used for validation (optional)
     * @param purchaseLimit How many times a user acquire the same purchase item (optional)
     * @param serviceAction Determines whether the purchase item will enable certain features &lt;ul&gt; &lt;li&gt;DAY_PREMIUM - subscribes a user for a day of membership&lt;/li&gt; &lt;li&gt;WEEK_PREMIUM - subscribes a user for a week of membership&lt;/li&gt; &lt;li&gt;MONTH_PREMIUM - subscribes a user for a month of membership&lt;/li&gt; &lt;li&gt;ADD_TICKET - allows a user to add more tickets to their account&lt;/li&gt; &lt;li&gt;ADD_GIFT - allows a user to send/recieve the purchase item as a gift&lt;/li&gt; &lt;/ul&gt; (optional)
     * @param coverAssetId The cover image of the purchase item (optional)
     * @param promoAssetId An application specific asset that can be used to store/provide additional data (optional)
     * @param giftable Determines whether the purchase item can be gifted to other users (optional)
     * @param assetable Determines whether users can attach their own media/asset to the purchase item (optional)
     * @param active Sets whether the purchase item is active or inactive (hidden from consumers) (optional)
     * @param allocateTickets Flag to indicate owner should receive tickets for completed missions (optional, default to false)
     * @param ticketType The type of ticket to reward, null means default type (optional)
     * @param points The number of points to award for completing a mission (optional)
     * @param offerLocationId The offer location that will get added to the user&#39;s wallet after purchase. (optional)
     * @return RequestConfig
     */
    fun updatePurchaseItemRequestConfig(purchaseItemId: kotlin.Long, deviceId: kotlin.String?, accountId: kotlin.Long?, name: kotlin.String?, description: kotlin.String?, tickets: kotlin.Int?, price: kotlin.Float?, purchaseType: PurchaseTypeUpdatePurchaseItem?, purchaseCode: kotlin.String?, secretKey: kotlin.String?, purchaseLimit: kotlin.Int?, serviceAction: ServiceActionUpdatePurchaseItem?, coverAssetId: kotlin.Long?, promoAssetId: kotlin.Long?, giftable: kotlin.Boolean?, assetable: kotlin.Boolean?, active: kotlin.Boolean?, allocateTickets: kotlin.Boolean?, ticketType: kotlin.String?, points: kotlin.Long?, offerLocationId: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                put("purchaseItemId", listOf(purchaseItemId.toString()))
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (description != null) {
                    put("description", listOf(description.toString()))
                }
                if (tickets != null) {
                    put("tickets", listOf(tickets.toString()))
                }
                if (price != null) {
                    put("price", listOf(price.toString()))
                }
                if (purchaseType != null) {
                    put("purchaseType", listOf(purchaseType.value))
                }
                if (purchaseCode != null) {
                    put("purchaseCode", listOf(purchaseCode.toString()))
                }
                if (secretKey != null) {
                    put("secretKey", listOf(secretKey.toString()))
                }
                if (purchaseLimit != null) {
                    put("purchaseLimit", listOf(purchaseLimit.toString()))
                }
                if (serviceAction != null) {
                    put("serviceAction", listOf(serviceAction.value))
                }
                if (coverAssetId != null) {
                    put("coverAssetId", listOf(coverAssetId.toString()))
                }
                if (promoAssetId != null) {
                    put("promoAssetId", listOf(promoAssetId.toString()))
                }
                if (giftable != null) {
                    put("giftable", listOf(giftable.toString()))
                }
                if (assetable != null) {
                    put("assetable", listOf(assetable.toString()))
                }
                if (active != null) {
                    put("active", listOf(active.toString()))
                }
                if (allocateTickets != null) {
                    put("allocateTickets", listOf(allocateTickets.toString()))
                }
                if (ticketType != null) {
                    put("ticketType", listOf(ticketType.toString()))
                }
                if (points != null) {
                    put("points", listOf(points.toString()))
                }
                if (offerLocationId != null) {
                    put("offerLocationId", listOf(offerLocationId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/purchase/update",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
