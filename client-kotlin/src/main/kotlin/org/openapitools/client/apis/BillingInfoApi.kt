/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import org.openapitools.client.models.PaymentTypesResponse

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

open class BillingInfoApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost")
        }
    }

    /**
     * POST /api/{version}/billing/update
     * Update Payment Method
     * Update a method of payment. If the paymentMethodId is not passed in then will update their default payment method.
     * @param version 
     * @param accountId The account used to perform the the request
     * @param paymentMethodId Payment Method Id (optional)
     * @param accountName the name of the account (optional)
     * @param firstName First Name that the account is filed as (optional)
     * @param lastName Last Name that the account is filed as (optional)
     * @param address Address that the account is filed as (optional)
     * @param city City that the account is filed as (optional)
     * @param state State that the account is filed as (optional)
     * @param postalCode Postal Code that the account is filed as (optional)
     * @param country Country that the account is filed as (optional)
     * @param phone Phone that the account is filed as (optional)
     * @param creditCardNumber The full credit card number to store on file (optional)
     * @param expirationDate The credit card expiration date YYYY-MM (optional)
     * @param ccv The 3 digit confirmation code (optional)
     * @param accountNumber The bank account number (optional)
     * @param bankName The bank name (optional)
     * @param routingNumber Routing Number (optional)
     * @param defaultPaymentMethod Default Payment Method (optional)
     * @param paymentMethodNickname Payment Method Nickname (optional)
     * @param taxId Tax Id (optional)
     * @param providerCustomerProfileId Provider customer profile Id (optional)
     * @param providerPaymentProfileId Provider customer payment profile Id (optional)
     * @param metaData Meta Data (optional)
     * @return PaymentTypesResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun addPaymentMethod(version: java.math.BigDecimal, accountId: kotlin.Long, paymentMethodId: kotlin.Long? = null, accountName: kotlin.String? = null, firstName: kotlin.String? = null, lastName: kotlin.String? = null, address: kotlin.String? = null, city: kotlin.String? = null, state: kotlin.String? = null, postalCode: kotlin.String? = null, country: kotlin.String? = null, phone: kotlin.String? = null, creditCardNumber: kotlin.String? = null, expirationDate: kotlin.String? = null, ccv: kotlin.String? = null, accountNumber: kotlin.String? = null, bankName: kotlin.String? = null, routingNumber: kotlin.String? = null, defaultPaymentMethod: kotlin.Boolean? = null, paymentMethodNickname: kotlin.String? = null, taxId: kotlin.String? = null, providerCustomerProfileId: kotlin.String? = null, providerPaymentProfileId: kotlin.String? = null, metaData: kotlin.String? = null) : PaymentTypesResponse {
        val localVarResponse = addPaymentMethodWithHttpInfo(version = version, accountId = accountId, paymentMethodId = paymentMethodId, accountName = accountName, firstName = firstName, lastName = lastName, address = address, city = city, state = state, postalCode = postalCode, country = country, phone = phone, creditCardNumber = creditCardNumber, expirationDate = expirationDate, ccv = ccv, accountNumber = accountNumber, bankName = bankName, routingNumber = routingNumber, defaultPaymentMethod = defaultPaymentMethod, paymentMethodNickname = paymentMethodNickname, taxId = taxId, providerCustomerProfileId = providerCustomerProfileId, providerPaymentProfileId = providerPaymentProfileId, metaData = metaData)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaymentTypesResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/{version}/billing/update
     * Update Payment Method
     * Update a method of payment. If the paymentMethodId is not passed in then will update their default payment method.
     * @param version 
     * @param accountId The account used to perform the the request
     * @param paymentMethodId Payment Method Id (optional)
     * @param accountName the name of the account (optional)
     * @param firstName First Name that the account is filed as (optional)
     * @param lastName Last Name that the account is filed as (optional)
     * @param address Address that the account is filed as (optional)
     * @param city City that the account is filed as (optional)
     * @param state State that the account is filed as (optional)
     * @param postalCode Postal Code that the account is filed as (optional)
     * @param country Country that the account is filed as (optional)
     * @param phone Phone that the account is filed as (optional)
     * @param creditCardNumber The full credit card number to store on file (optional)
     * @param expirationDate The credit card expiration date YYYY-MM (optional)
     * @param ccv The 3 digit confirmation code (optional)
     * @param accountNumber The bank account number (optional)
     * @param bankName The bank name (optional)
     * @param routingNumber Routing Number (optional)
     * @param defaultPaymentMethod Default Payment Method (optional)
     * @param paymentMethodNickname Payment Method Nickname (optional)
     * @param taxId Tax Id (optional)
     * @param providerCustomerProfileId Provider customer profile Id (optional)
     * @param providerPaymentProfileId Provider customer payment profile Id (optional)
     * @param metaData Meta Data (optional)
     * @return ApiResponse<PaymentTypesResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun addPaymentMethodWithHttpInfo(version: java.math.BigDecimal, accountId: kotlin.Long, paymentMethodId: kotlin.Long?, accountName: kotlin.String?, firstName: kotlin.String?, lastName: kotlin.String?, address: kotlin.String?, city: kotlin.String?, state: kotlin.String?, postalCode: kotlin.String?, country: kotlin.String?, phone: kotlin.String?, creditCardNumber: kotlin.String?, expirationDate: kotlin.String?, ccv: kotlin.String?, accountNumber: kotlin.String?, bankName: kotlin.String?, routingNumber: kotlin.String?, defaultPaymentMethod: kotlin.Boolean?, paymentMethodNickname: kotlin.String?, taxId: kotlin.String?, providerCustomerProfileId: kotlin.String?, providerPaymentProfileId: kotlin.String?, metaData: kotlin.String?) : ApiResponse<PaymentTypesResponse?> {
        val localVariableConfig = addPaymentMethodRequestConfig(version = version, accountId = accountId, paymentMethodId = paymentMethodId, accountName = accountName, firstName = firstName, lastName = lastName, address = address, city = city, state = state, postalCode = postalCode, country = country, phone = phone, creditCardNumber = creditCardNumber, expirationDate = expirationDate, ccv = ccv, accountNumber = accountNumber, bankName = bankName, routingNumber = routingNumber, defaultPaymentMethod = defaultPaymentMethod, paymentMethodNickname = paymentMethodNickname, taxId = taxId, providerCustomerProfileId = providerCustomerProfileId, providerPaymentProfileId = providerPaymentProfileId, metaData = metaData)

        return request<Unit, PaymentTypesResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation addPaymentMethod
     *
     * @param version 
     * @param accountId The account used to perform the the request
     * @param paymentMethodId Payment Method Id (optional)
     * @param accountName the name of the account (optional)
     * @param firstName First Name that the account is filed as (optional)
     * @param lastName Last Name that the account is filed as (optional)
     * @param address Address that the account is filed as (optional)
     * @param city City that the account is filed as (optional)
     * @param state State that the account is filed as (optional)
     * @param postalCode Postal Code that the account is filed as (optional)
     * @param country Country that the account is filed as (optional)
     * @param phone Phone that the account is filed as (optional)
     * @param creditCardNumber The full credit card number to store on file (optional)
     * @param expirationDate The credit card expiration date YYYY-MM (optional)
     * @param ccv The 3 digit confirmation code (optional)
     * @param accountNumber The bank account number (optional)
     * @param bankName The bank name (optional)
     * @param routingNumber Routing Number (optional)
     * @param defaultPaymentMethod Default Payment Method (optional)
     * @param paymentMethodNickname Payment Method Nickname (optional)
     * @param taxId Tax Id (optional)
     * @param providerCustomerProfileId Provider customer profile Id (optional)
     * @param providerPaymentProfileId Provider customer payment profile Id (optional)
     * @param metaData Meta Data (optional)
     * @return RequestConfig
     */
    fun addPaymentMethodRequestConfig(version: java.math.BigDecimal, accountId: kotlin.Long, paymentMethodId: kotlin.Long?, accountName: kotlin.String?, firstName: kotlin.String?, lastName: kotlin.String?, address: kotlin.String?, city: kotlin.String?, state: kotlin.String?, postalCode: kotlin.String?, country: kotlin.String?, phone: kotlin.String?, creditCardNumber: kotlin.String?, expirationDate: kotlin.String?, ccv: kotlin.String?, accountNumber: kotlin.String?, bankName: kotlin.String?, routingNumber: kotlin.String?, defaultPaymentMethod: kotlin.Boolean?, paymentMethodNickname: kotlin.String?, taxId: kotlin.String?, providerCustomerProfileId: kotlin.String?, providerPaymentProfileId: kotlin.String?, metaData: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                if (paymentMethodId != null) {
                    put("paymentMethodId", listOf(paymentMethodId.toString()))
                }
                if (accountName != null) {
                    put("accountName", listOf(accountName.toString()))
                }
                if (firstName != null) {
                    put("firstName", listOf(firstName.toString()))
                }
                if (lastName != null) {
                    put("lastName", listOf(lastName.toString()))
                }
                if (address != null) {
                    put("address", listOf(address.toString()))
                }
                if (city != null) {
                    put("city", listOf(city.toString()))
                }
                if (state != null) {
                    put("state", listOf(state.toString()))
                }
                if (postalCode != null) {
                    put("postalCode", listOf(postalCode.toString()))
                }
                if (country != null) {
                    put("country", listOf(country.toString()))
                }
                if (phone != null) {
                    put("phone", listOf(phone.toString()))
                }
                if (creditCardNumber != null) {
                    put("creditCardNumber", listOf(creditCardNumber.toString()))
                }
                if (expirationDate != null) {
                    put("expirationDate", listOf(expirationDate.toString()))
                }
                if (ccv != null) {
                    put("ccv", listOf(ccv.toString()))
                }
                if (accountNumber != null) {
                    put("accountNumber", listOf(accountNumber.toString()))
                }
                if (bankName != null) {
                    put("bankName", listOf(bankName.toString()))
                }
                if (routingNumber != null) {
                    put("routingNumber", listOf(routingNumber.toString()))
                }
                if (defaultPaymentMethod != null) {
                    put("defaultPaymentMethod", listOf(defaultPaymentMethod.toString()))
                }
                if (paymentMethodNickname != null) {
                    put("paymentMethodNickname", listOf(paymentMethodNickname.toString()))
                }
                if (taxId != null) {
                    put("taxId", listOf(taxId.toString()))
                }
                if (providerCustomerProfileId != null) {
                    put("providerCustomerProfileId", listOf(providerCustomerProfileId.toString()))
                }
                if (providerPaymentProfileId != null) {
                    put("providerPaymentProfileId", listOf(providerPaymentProfileId.toString()))
                }
                if (metaData != null) {
                    put("metaData", listOf(metaData.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/{version}/billing/update".replace("{"+"version"+"}", encodeURIComponent(version.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/{version}/billing/create
     * Create Payment Method
     * Add a new method of payment.
     * @param version 
     * @param accountId The account used to perform the the request
     * @param accountName Account Name of the credit card user (optional)
     * @param firstName The first name on the credit card (optional)
     * @param lastName The last name on the credit card (optional)
     * @param address The billing address of the credit card (optional)
     * @param city The billing city of the credit card (optional)
     * @param state The billing state of the credit card (optional)
     * @param postalCode The billing zip code of the credit card (optional)
     * @param country Country of the credit card (optional)
     * @param phone The billing phone of the credit card (optional)
     * @param creditCardNumber The full credit card number to store on file (optional)
     * @param expirationDate The credit card expiration date YYYY-MM (optional)
     * @param ccv The 3 digit confirmation code (optional)
     * @param accountNumber The bank account number (optional)
     * @param bankName The bank name (optional)
     * @param routingNumber The bank routing number (optional)
     * @param paymentMethodNickname The nickname to give the payment method (optional)
     * @param taxId Tax Id (optional)
     * @param defaultPaymentMethod Whether this should be the default payment method (optional, default to true)
     * @param authToken An authorization token for providers that provide this (like Amazon Payments) (optional)
     * @param provider The payment provider (see PaymentMethodProvider) (optional, default to "AUTHORIZE_NET")
     * @param providerCustomerProfileId Provider customer profile Id (optional)
     * @param providerPaymentProfileId Provider customer payment profile Id (optional)
     * @param metaData Meta Data (optional)
     * @param appKey Application Key (optional)
     * @return PaymentTypesResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createPaymentMethod(version: java.math.BigDecimal, accountId: kotlin.Long, accountName: kotlin.String? = null, firstName: kotlin.String? = null, lastName: kotlin.String? = null, address: kotlin.String? = null, city: kotlin.String? = null, state: kotlin.String? = null, postalCode: kotlin.String? = null, country: kotlin.String? = null, phone: kotlin.String? = null, creditCardNumber: kotlin.String? = null, expirationDate: kotlin.String? = null, ccv: kotlin.String? = null, accountNumber: kotlin.String? = null, bankName: kotlin.String? = null, routingNumber: kotlin.String? = null, paymentMethodNickname: kotlin.String? = null, taxId: kotlin.String? = null, defaultPaymentMethod: kotlin.Boolean? = true, authToken: kotlin.String? = null, provider: kotlin.String? = "AUTHORIZE_NET", providerCustomerProfileId: kotlin.String? = null, providerPaymentProfileId: kotlin.String? = null, metaData: kotlin.String? = null, appKey: kotlin.String? = null) : PaymentTypesResponse {
        val localVarResponse = createPaymentMethodWithHttpInfo(version = version, accountId = accountId, accountName = accountName, firstName = firstName, lastName = lastName, address = address, city = city, state = state, postalCode = postalCode, country = country, phone = phone, creditCardNumber = creditCardNumber, expirationDate = expirationDate, ccv = ccv, accountNumber = accountNumber, bankName = bankName, routingNumber = routingNumber, paymentMethodNickname = paymentMethodNickname, taxId = taxId, defaultPaymentMethod = defaultPaymentMethod, authToken = authToken, provider = provider, providerCustomerProfileId = providerCustomerProfileId, providerPaymentProfileId = providerPaymentProfileId, metaData = metaData, appKey = appKey)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaymentTypesResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/{version}/billing/create
     * Create Payment Method
     * Add a new method of payment.
     * @param version 
     * @param accountId The account used to perform the the request
     * @param accountName Account Name of the credit card user (optional)
     * @param firstName The first name on the credit card (optional)
     * @param lastName The last name on the credit card (optional)
     * @param address The billing address of the credit card (optional)
     * @param city The billing city of the credit card (optional)
     * @param state The billing state of the credit card (optional)
     * @param postalCode The billing zip code of the credit card (optional)
     * @param country Country of the credit card (optional)
     * @param phone The billing phone of the credit card (optional)
     * @param creditCardNumber The full credit card number to store on file (optional)
     * @param expirationDate The credit card expiration date YYYY-MM (optional)
     * @param ccv The 3 digit confirmation code (optional)
     * @param accountNumber The bank account number (optional)
     * @param bankName The bank name (optional)
     * @param routingNumber The bank routing number (optional)
     * @param paymentMethodNickname The nickname to give the payment method (optional)
     * @param taxId Tax Id (optional)
     * @param defaultPaymentMethod Whether this should be the default payment method (optional, default to true)
     * @param authToken An authorization token for providers that provide this (like Amazon Payments) (optional)
     * @param provider The payment provider (see PaymentMethodProvider) (optional, default to "AUTHORIZE_NET")
     * @param providerCustomerProfileId Provider customer profile Id (optional)
     * @param providerPaymentProfileId Provider customer payment profile Id (optional)
     * @param metaData Meta Data (optional)
     * @param appKey Application Key (optional)
     * @return ApiResponse<PaymentTypesResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createPaymentMethodWithHttpInfo(version: java.math.BigDecimal, accountId: kotlin.Long, accountName: kotlin.String?, firstName: kotlin.String?, lastName: kotlin.String?, address: kotlin.String?, city: kotlin.String?, state: kotlin.String?, postalCode: kotlin.String?, country: kotlin.String?, phone: kotlin.String?, creditCardNumber: kotlin.String?, expirationDate: kotlin.String?, ccv: kotlin.String?, accountNumber: kotlin.String?, bankName: kotlin.String?, routingNumber: kotlin.String?, paymentMethodNickname: kotlin.String?, taxId: kotlin.String?, defaultPaymentMethod: kotlin.Boolean?, authToken: kotlin.String?, provider: kotlin.String?, providerCustomerProfileId: kotlin.String?, providerPaymentProfileId: kotlin.String?, metaData: kotlin.String?, appKey: kotlin.String?) : ApiResponse<PaymentTypesResponse?> {
        val localVariableConfig = createPaymentMethodRequestConfig(version = version, accountId = accountId, accountName = accountName, firstName = firstName, lastName = lastName, address = address, city = city, state = state, postalCode = postalCode, country = country, phone = phone, creditCardNumber = creditCardNumber, expirationDate = expirationDate, ccv = ccv, accountNumber = accountNumber, bankName = bankName, routingNumber = routingNumber, paymentMethodNickname = paymentMethodNickname, taxId = taxId, defaultPaymentMethod = defaultPaymentMethod, authToken = authToken, provider = provider, providerCustomerProfileId = providerCustomerProfileId, providerPaymentProfileId = providerPaymentProfileId, metaData = metaData, appKey = appKey)

        return request<Unit, PaymentTypesResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createPaymentMethod
     *
     * @param version 
     * @param accountId The account used to perform the the request
     * @param accountName Account Name of the credit card user (optional)
     * @param firstName The first name on the credit card (optional)
     * @param lastName The last name on the credit card (optional)
     * @param address The billing address of the credit card (optional)
     * @param city The billing city of the credit card (optional)
     * @param state The billing state of the credit card (optional)
     * @param postalCode The billing zip code of the credit card (optional)
     * @param country Country of the credit card (optional)
     * @param phone The billing phone of the credit card (optional)
     * @param creditCardNumber The full credit card number to store on file (optional)
     * @param expirationDate The credit card expiration date YYYY-MM (optional)
     * @param ccv The 3 digit confirmation code (optional)
     * @param accountNumber The bank account number (optional)
     * @param bankName The bank name (optional)
     * @param routingNumber The bank routing number (optional)
     * @param paymentMethodNickname The nickname to give the payment method (optional)
     * @param taxId Tax Id (optional)
     * @param defaultPaymentMethod Whether this should be the default payment method (optional, default to true)
     * @param authToken An authorization token for providers that provide this (like Amazon Payments) (optional)
     * @param provider The payment provider (see PaymentMethodProvider) (optional, default to "AUTHORIZE_NET")
     * @param providerCustomerProfileId Provider customer profile Id (optional)
     * @param providerPaymentProfileId Provider customer payment profile Id (optional)
     * @param metaData Meta Data (optional)
     * @param appKey Application Key (optional)
     * @return RequestConfig
     */
    fun createPaymentMethodRequestConfig(version: java.math.BigDecimal, accountId: kotlin.Long, accountName: kotlin.String?, firstName: kotlin.String?, lastName: kotlin.String?, address: kotlin.String?, city: kotlin.String?, state: kotlin.String?, postalCode: kotlin.String?, country: kotlin.String?, phone: kotlin.String?, creditCardNumber: kotlin.String?, expirationDate: kotlin.String?, ccv: kotlin.String?, accountNumber: kotlin.String?, bankName: kotlin.String?, routingNumber: kotlin.String?, paymentMethodNickname: kotlin.String?, taxId: kotlin.String?, defaultPaymentMethod: kotlin.Boolean?, authToken: kotlin.String?, provider: kotlin.String?, providerCustomerProfileId: kotlin.String?, providerPaymentProfileId: kotlin.String?, metaData: kotlin.String?, appKey: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                if (accountName != null) {
                    put("accountName", listOf(accountName.toString()))
                }
                if (firstName != null) {
                    put("firstName", listOf(firstName.toString()))
                }
                if (lastName != null) {
                    put("lastName", listOf(lastName.toString()))
                }
                if (address != null) {
                    put("address", listOf(address.toString()))
                }
                if (city != null) {
                    put("city", listOf(city.toString()))
                }
                if (state != null) {
                    put("state", listOf(state.toString()))
                }
                if (postalCode != null) {
                    put("postalCode", listOf(postalCode.toString()))
                }
                if (country != null) {
                    put("country", listOf(country.toString()))
                }
                if (phone != null) {
                    put("phone", listOf(phone.toString()))
                }
                if (creditCardNumber != null) {
                    put("creditCardNumber", listOf(creditCardNumber.toString()))
                }
                if (expirationDate != null) {
                    put("expirationDate", listOf(expirationDate.toString()))
                }
                if (ccv != null) {
                    put("ccv", listOf(ccv.toString()))
                }
                if (accountNumber != null) {
                    put("accountNumber", listOf(accountNumber.toString()))
                }
                if (bankName != null) {
                    put("bankName", listOf(bankName.toString()))
                }
                if (routingNumber != null) {
                    put("routingNumber", listOf(routingNumber.toString()))
                }
                if (paymentMethodNickname != null) {
                    put("paymentMethodNickname", listOf(paymentMethodNickname.toString()))
                }
                if (taxId != null) {
                    put("taxId", listOf(taxId.toString()))
                }
                if (defaultPaymentMethod != null) {
                    put("defaultPaymentMethod", listOf(defaultPaymentMethod.toString()))
                }
                if (authToken != null) {
                    put("authToken", listOf(authToken.toString()))
                }
                if (provider != null) {
                    put("provider", listOf(provider.toString()))
                }
                if (providerCustomerProfileId != null) {
                    put("providerCustomerProfileId", listOf(providerCustomerProfileId.toString()))
                }
                if (providerPaymentProfileId != null) {
                    put("providerPaymentProfileId", listOf(providerPaymentProfileId.toString()))
                }
                if (metaData != null) {
                    put("metaData", listOf(metaData.toString()))
                }
                if (appKey != null) {
                    put("appKey", listOf(appKey.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/{version}/billing/create".replace("{"+"version"+"}", encodeURIComponent(version.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/{version}/billing/crypto/transfer
     * Create Smart Contract
     * Adds a smart contract.
     * @param version 
     * @param accountId The account used to perform the the request
     * @param tokenName The token name
     * @param tokenSymbol The token symbol
     * @param paymentMethodId The payment method to return details on. If this is not set, then the user&#39;s default payment method will be returned. (optional)
     * @return PaymentTypesResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createSmartContract(version: java.math.BigDecimal, accountId: kotlin.Long, tokenName: kotlin.String, tokenSymbol: kotlin.String, paymentMethodId: kotlin.Long? = null) : PaymentTypesResponse {
        val localVarResponse = createSmartContractWithHttpInfo(version = version, accountId = accountId, tokenName = tokenName, tokenSymbol = tokenSymbol, paymentMethodId = paymentMethodId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaymentTypesResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/{version}/billing/crypto/transfer
     * Create Smart Contract
     * Adds a smart contract.
     * @param version 
     * @param accountId The account used to perform the the request
     * @param tokenName The token name
     * @param tokenSymbol The token symbol
     * @param paymentMethodId The payment method to return details on. If this is not set, then the user&#39;s default payment method will be returned. (optional)
     * @return ApiResponse<PaymentTypesResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createSmartContractWithHttpInfo(version: java.math.BigDecimal, accountId: kotlin.Long, tokenName: kotlin.String, tokenSymbol: kotlin.String, paymentMethodId: kotlin.Long?) : ApiResponse<PaymentTypesResponse?> {
        val localVariableConfig = createSmartContractRequestConfig(version = version, accountId = accountId, tokenName = tokenName, tokenSymbol = tokenSymbol, paymentMethodId = paymentMethodId)

        return request<Unit, PaymentTypesResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createSmartContract
     *
     * @param version 
     * @param accountId The account used to perform the the request
     * @param tokenName The token name
     * @param tokenSymbol The token symbol
     * @param paymentMethodId The payment method to return details on. If this is not set, then the user&#39;s default payment method will be returned. (optional)
     * @return RequestConfig
     */
    fun createSmartContractRequestConfig(version: java.math.BigDecimal, accountId: kotlin.Long, tokenName: kotlin.String, tokenSymbol: kotlin.String, paymentMethodId: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                if (paymentMethodId != null) {
                    put("paymentMethodId", listOf(paymentMethodId.toString()))
                }
                put("tokenName", listOf(tokenName.toString()))
                put("tokenSymbol", listOf(tokenSymbol.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/{version}/billing/crypto/transfer".replace("{"+"version"+"}", encodeURIComponent(version.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /api/{version}/billing/crypto/get
     * Get Crypto Balances
     * Get the cypto balance details for a user
     * @param version 
     * @param accountId The account used to perform the the request
     * @param ownerAccountId The account to retreive balances for (optional)
     * @param paymentMethodId The payment method to return details on. If this is not set, then the user&#39;s default payment method will be returned. (optional)
     * @return PaymentTypesResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getCryptoBalance(version: java.math.BigDecimal, accountId: kotlin.Long, ownerAccountId: kotlin.Long? = null, paymentMethodId: kotlin.Long? = null) : PaymentTypesResponse {
        val localVarResponse = getCryptoBalanceWithHttpInfo(version = version, accountId = accountId, ownerAccountId = ownerAccountId, paymentMethodId = paymentMethodId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaymentTypesResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/{version}/billing/crypto/get
     * Get Crypto Balances
     * Get the cypto balance details for a user
     * @param version 
     * @param accountId The account used to perform the the request
     * @param ownerAccountId The account to retreive balances for (optional)
     * @param paymentMethodId The payment method to return details on. If this is not set, then the user&#39;s default payment method will be returned. (optional)
     * @return ApiResponse<PaymentTypesResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getCryptoBalanceWithHttpInfo(version: java.math.BigDecimal, accountId: kotlin.Long, ownerAccountId: kotlin.Long?, paymentMethodId: kotlin.Long?) : ApiResponse<PaymentTypesResponse?> {
        val localVariableConfig = getCryptoBalanceRequestConfig(version = version, accountId = accountId, ownerAccountId = ownerAccountId, paymentMethodId = paymentMethodId)

        return request<Unit, PaymentTypesResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getCryptoBalance
     *
     * @param version 
     * @param accountId The account used to perform the the request
     * @param ownerAccountId The account to retreive balances for (optional)
     * @param paymentMethodId The payment method to return details on. If this is not set, then the user&#39;s default payment method will be returned. (optional)
     * @return RequestConfig
     */
    fun getCryptoBalanceRequestConfig(version: java.math.BigDecimal, accountId: kotlin.Long, ownerAccountId: kotlin.Long?, paymentMethodId: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                if (ownerAccountId != null) {
                    put("ownerAccountId", listOf(ownerAccountId.toString()))
                }
                if (paymentMethodId != null) {
                    put("paymentMethodId", listOf(paymentMethodId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/{version}/billing/crypto/get".replace("{"+"version"+"}", encodeURIComponent(version.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /api/{version}/billing/get
     * Get Payment Method
     * Get the details of the user&#39;s payment method or their current default method of payment
     * @param version 
     * @param accountId The account used to perform the the request
     * @param paymentMethodId The payment method to return details on. If this is not set, then the user&#39;s default payment method will be returned. (optional)
     * @param getCurrentBalance Determines whether to get the user&#39;s current balance for the requested payment method option (not all payment method options support this) (optional)
     * @return PaymentTypesResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getPaymentMethod(version: java.math.BigDecimal, accountId: kotlin.Long, paymentMethodId: kotlin.Long? = null, getCurrentBalance: kotlin.Boolean? = null) : PaymentTypesResponse {
        val localVarResponse = getPaymentMethodWithHttpInfo(version = version, accountId = accountId, paymentMethodId = paymentMethodId, getCurrentBalance = getCurrentBalance)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaymentTypesResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/{version}/billing/get
     * Get Payment Method
     * Get the details of the user&#39;s payment method or their current default method of payment
     * @param version 
     * @param accountId The account used to perform the the request
     * @param paymentMethodId The payment method to return details on. If this is not set, then the user&#39;s default payment method will be returned. (optional)
     * @param getCurrentBalance Determines whether to get the user&#39;s current balance for the requested payment method option (not all payment method options support this) (optional)
     * @return ApiResponse<PaymentTypesResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getPaymentMethodWithHttpInfo(version: java.math.BigDecimal, accountId: kotlin.Long, paymentMethodId: kotlin.Long?, getCurrentBalance: kotlin.Boolean?) : ApiResponse<PaymentTypesResponse?> {
        val localVariableConfig = getPaymentMethodRequestConfig(version = version, accountId = accountId, paymentMethodId = paymentMethodId, getCurrentBalance = getCurrentBalance)

        return request<Unit, PaymentTypesResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getPaymentMethod
     *
     * @param version 
     * @param accountId The account used to perform the the request
     * @param paymentMethodId The payment method to return details on. If this is not set, then the user&#39;s default payment method will be returned. (optional)
     * @param getCurrentBalance Determines whether to get the user&#39;s current balance for the requested payment method option (not all payment method options support this) (optional)
     * @return RequestConfig
     */
    fun getPaymentMethodRequestConfig(version: java.math.BigDecimal, accountId: kotlin.Long, paymentMethodId: kotlin.Long?, getCurrentBalance: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                if (paymentMethodId != null) {
                    put("paymentMethodId", listOf(paymentMethodId.toString()))
                }
                if (getCurrentBalance != null) {
                    put("getCurrentBalance", listOf(getCurrentBalance.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/{version}/billing/get".replace("{"+"version"+"}", encodeURIComponent(version.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /api/{version}/billing/search
     * Search Payment Methods
     * Search the payment methods of an account
     * @param version 
     * @param accountId Account Id to search on
     * @param provider Provider to search on (optional, default to "AUTHORIZE_NET")
     * @param type the type to search on (optional)
     * @param keyword the keyword to search on (optional)
     * @param sortField the sort field to use for the search (optional, default to "UPDATED")
     * @param descending if the results should be in descending order (optional, default to true)
     * @param start the start of the search (optional, default to 0)
     * @param limit the limit of the search (optional, default to 5)
     * @return PaymentTypesResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun searchPaymentMethod(version: java.math.BigDecimal, accountId: kotlin.Long, provider: kotlin.String? = "AUTHORIZE_NET", type: kotlin.String? = null, keyword: kotlin.String? = null, sortField: kotlin.String? = "UPDATED", descending: kotlin.Boolean? = true, start: kotlin.Int? = 0, limit: kotlin.Int? = 5) : PaymentTypesResponse {
        val localVarResponse = searchPaymentMethodWithHttpInfo(version = version, accountId = accountId, provider = provider, type = type, keyword = keyword, sortField = sortField, descending = descending, start = start, limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaymentTypesResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/{version}/billing/search
     * Search Payment Methods
     * Search the payment methods of an account
     * @param version 
     * @param accountId Account Id to search on
     * @param provider Provider to search on (optional, default to "AUTHORIZE_NET")
     * @param type the type to search on (optional)
     * @param keyword the keyword to search on (optional)
     * @param sortField the sort field to use for the search (optional, default to "UPDATED")
     * @param descending if the results should be in descending order (optional, default to true)
     * @param start the start of the search (optional, default to 0)
     * @param limit the limit of the search (optional, default to 5)
     * @return ApiResponse<PaymentTypesResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun searchPaymentMethodWithHttpInfo(version: java.math.BigDecimal, accountId: kotlin.Long, provider: kotlin.String?, type: kotlin.String?, keyword: kotlin.String?, sortField: kotlin.String?, descending: kotlin.Boolean?, start: kotlin.Int?, limit: kotlin.Int?) : ApiResponse<PaymentTypesResponse?> {
        val localVariableConfig = searchPaymentMethodRequestConfig(version = version, accountId = accountId, provider = provider, type = type, keyword = keyword, sortField = sortField, descending = descending, start = start, limit = limit)

        return request<Unit, PaymentTypesResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation searchPaymentMethod
     *
     * @param version 
     * @param accountId Account Id to search on
     * @param provider Provider to search on (optional, default to "AUTHORIZE_NET")
     * @param type the type to search on (optional)
     * @param keyword the keyword to search on (optional)
     * @param sortField the sort field to use for the search (optional, default to "UPDATED")
     * @param descending if the results should be in descending order (optional, default to true)
     * @param start the start of the search (optional, default to 0)
     * @param limit the limit of the search (optional, default to 5)
     * @return RequestConfig
     */
    fun searchPaymentMethodRequestConfig(version: java.math.BigDecimal, accountId: kotlin.Long, provider: kotlin.String?, type: kotlin.String?, keyword: kotlin.String?, sortField: kotlin.String?, descending: kotlin.Boolean?, start: kotlin.Int?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                if (provider != null) {
                    put("provider", listOf(provider.toString()))
                }
                if (type != null) {
                    put("type", listOf(type.toString()))
                }
                if (keyword != null) {
                    put("keyword", listOf(keyword.toString()))
                }
                if (sortField != null) {
                    put("sortField", listOf(sortField.toString()))
                }
                if (descending != null) {
                    put("descending", listOf(descending.toString()))
                }
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/{version}/billing/search".replace("{"+"version"+"}", encodeURIComponent(version.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
