/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import org.openapitools.client.models.RegionResponse

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

open class RegionApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://dev.sirqul.com/api/3.18")
        }
    }

    /**
     * enum for parameter visibility
     */
     enum class VisibilityCreateRegion(val value: kotlin.String) {
         @Json(name = "PUBLIC") PUBLIC("PUBLIC"),
         @Json(name = "PRIVATE") PRIVATE("PRIVATE"),
         @Json(name = "FRIENDS") FRIENDS("FRIENDS");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * POST /region/create
     * Create Region
     * Create a region.
     * @param accountId The id of the account sending the request
     * @param regionClass RegionClass of this region
     * @param shortName Short name of the region. This is optimized for search
     * @param fullName Full name of the region (optional)
     * @param parentIds Comma separated region ids that are parents of this region (optional)
     * @param childrenIds Comma separated region ids that are children of this region (optional)
     * @param postalCodeIds Comma separated postal code ids the region will include (optional)
     * @param locations Sets of name,lat,long used to create new postal codes assigned to the region (optional)
     * @param retailerLocationId the id of the retailer location that the region is being created for (optional)
     * @param visibility The Visibility of the region (optional)
     * @param categoryIds the categories that the region is assigned to (optional)
     * @param filterIds the filters that the region is assigned to (optional)
     * @param start  (optional)
     * @param end  (optional)
     * @param polygon the polygon generated for the region (optional)
     * @param metaData the meta data associated with the region (optional)
     * @param latitude the latitude of the region (optional)
     * @param longitude the longitude of the region (optional)
     * @param versionCode the version code (optional)
     * @param root If this is a root region or not. If true means this region has no parent regions (optional)
     * @param active Active or inactive status of the region (optional)
     * @return RegionResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createRegion(accountId: kotlin.Long, regionClass: kotlin.String, shortName: kotlin.String, fullName: kotlin.String? = null, parentIds: kotlin.String? = null, childrenIds: kotlin.String? = null, postalCodeIds: kotlin.String? = null, locations: kotlin.String? = null, retailerLocationId: kotlin.Long? = null, visibility: VisibilityCreateRegion? = null, categoryIds: kotlin.String? = null, filterIds: kotlin.String? = null, start: kotlin.Long? = null, end: kotlin.Long? = null, polygon: kotlin.String? = null, metaData: kotlin.String? = null, latitude: kotlin.Double? = null, longitude: kotlin.Double? = null, versionCode: kotlin.Int? = null, root: kotlin.Boolean? = null, active: kotlin.Boolean? = null) : RegionResponse {
        val localVarResponse = createRegionWithHttpInfo(accountId = accountId, regionClass = regionClass, shortName = shortName, fullName = fullName, parentIds = parentIds, childrenIds = childrenIds, postalCodeIds = postalCodeIds, locations = locations, retailerLocationId = retailerLocationId, visibility = visibility, categoryIds = categoryIds, filterIds = filterIds, start = start, end = end, polygon = polygon, metaData = metaData, latitude = latitude, longitude = longitude, versionCode = versionCode, root = root, active = active)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RegionResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /region/create
     * Create Region
     * Create a region.
     * @param accountId The id of the account sending the request
     * @param regionClass RegionClass of this region
     * @param shortName Short name of the region. This is optimized for search
     * @param fullName Full name of the region (optional)
     * @param parentIds Comma separated region ids that are parents of this region (optional)
     * @param childrenIds Comma separated region ids that are children of this region (optional)
     * @param postalCodeIds Comma separated postal code ids the region will include (optional)
     * @param locations Sets of name,lat,long used to create new postal codes assigned to the region (optional)
     * @param retailerLocationId the id of the retailer location that the region is being created for (optional)
     * @param visibility The Visibility of the region (optional)
     * @param categoryIds the categories that the region is assigned to (optional)
     * @param filterIds the filters that the region is assigned to (optional)
     * @param start  (optional)
     * @param end  (optional)
     * @param polygon the polygon generated for the region (optional)
     * @param metaData the meta data associated with the region (optional)
     * @param latitude the latitude of the region (optional)
     * @param longitude the longitude of the region (optional)
     * @param versionCode the version code (optional)
     * @param root If this is a root region or not. If true means this region has no parent regions (optional)
     * @param active Active or inactive status of the region (optional)
     * @return ApiResponse<RegionResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createRegionWithHttpInfo(accountId: kotlin.Long, regionClass: kotlin.String, shortName: kotlin.String, fullName: kotlin.String?, parentIds: kotlin.String?, childrenIds: kotlin.String?, postalCodeIds: kotlin.String?, locations: kotlin.String?, retailerLocationId: kotlin.Long?, visibility: VisibilityCreateRegion?, categoryIds: kotlin.String?, filterIds: kotlin.String?, start: kotlin.Long?, end: kotlin.Long?, polygon: kotlin.String?, metaData: kotlin.String?, latitude: kotlin.Double?, longitude: kotlin.Double?, versionCode: kotlin.Int?, root: kotlin.Boolean?, active: kotlin.Boolean?) : ApiResponse<RegionResponse?> {
        val localVariableConfig = createRegionRequestConfig(accountId = accountId, regionClass = regionClass, shortName = shortName, fullName = fullName, parentIds = parentIds, childrenIds = childrenIds, postalCodeIds = postalCodeIds, locations = locations, retailerLocationId = retailerLocationId, visibility = visibility, categoryIds = categoryIds, filterIds = filterIds, start = start, end = end, polygon = polygon, metaData = metaData, latitude = latitude, longitude = longitude, versionCode = versionCode, root = root, active = active)

        return request<Unit, RegionResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createRegion
     *
     * @param accountId The id of the account sending the request
     * @param regionClass RegionClass of this region
     * @param shortName Short name of the region. This is optimized for search
     * @param fullName Full name of the region (optional)
     * @param parentIds Comma separated region ids that are parents of this region (optional)
     * @param childrenIds Comma separated region ids that are children of this region (optional)
     * @param postalCodeIds Comma separated postal code ids the region will include (optional)
     * @param locations Sets of name,lat,long used to create new postal codes assigned to the region (optional)
     * @param retailerLocationId the id of the retailer location that the region is being created for (optional)
     * @param visibility The Visibility of the region (optional)
     * @param categoryIds the categories that the region is assigned to (optional)
     * @param filterIds the filters that the region is assigned to (optional)
     * @param start  (optional)
     * @param end  (optional)
     * @param polygon the polygon generated for the region (optional)
     * @param metaData the meta data associated with the region (optional)
     * @param latitude the latitude of the region (optional)
     * @param longitude the longitude of the region (optional)
     * @param versionCode the version code (optional)
     * @param root If this is a root region or not. If true means this region has no parent regions (optional)
     * @param active Active or inactive status of the region (optional)
     * @return RequestConfig
     */
    fun createRegionRequestConfig(accountId: kotlin.Long, regionClass: kotlin.String, shortName: kotlin.String, fullName: kotlin.String?, parentIds: kotlin.String?, childrenIds: kotlin.String?, postalCodeIds: kotlin.String?, locations: kotlin.String?, retailerLocationId: kotlin.Long?, visibility: VisibilityCreateRegion?, categoryIds: kotlin.String?, filterIds: kotlin.String?, start: kotlin.Long?, end: kotlin.Long?, polygon: kotlin.String?, metaData: kotlin.String?, latitude: kotlin.Double?, longitude: kotlin.Double?, versionCode: kotlin.Int?, root: kotlin.Boolean?, active: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("regionClass", listOf(regionClass.toString()))
                put("shortName", listOf(shortName.toString()))
                if (fullName != null) {
                    put("fullName", listOf(fullName.toString()))
                }
                if (parentIds != null) {
                    put("parentIds", listOf(parentIds.toString()))
                }
                if (childrenIds != null) {
                    put("childrenIds", listOf(childrenIds.toString()))
                }
                if (postalCodeIds != null) {
                    put("postalCodeIds", listOf(postalCodeIds.toString()))
                }
                if (locations != null) {
                    put("locations", listOf(locations.toString()))
                }
                if (retailerLocationId != null) {
                    put("retailerLocationId", listOf(retailerLocationId.toString()))
                }
                if (visibility != null) {
                    put("visibility", listOf(visibility.value))
                }
                if (categoryIds != null) {
                    put("categoryIds", listOf(categoryIds.toString()))
                }
                if (filterIds != null) {
                    put("filterIds", listOf(filterIds.toString()))
                }
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (end != null) {
                    put("end", listOf(end.toString()))
                }
                if (polygon != null) {
                    put("polygon", listOf(polygon.toString()))
                }
                if (metaData != null) {
                    put("metaData", listOf(metaData.toString()))
                }
                if (latitude != null) {
                    put("latitude", listOf(latitude.toString()))
                }
                if (longitude != null) {
                    put("longitude", listOf(longitude.toString()))
                }
                if (versionCode != null) {
                    put("versionCode", listOf(versionCode.toString()))
                }
                if (root != null) {
                    put("root", listOf(root.toString()))
                }
                if (active != null) {
                    put("active", listOf(active.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/region/create",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /region/delete
     * Delete Region
     * Delete a region.
     * @param accountId the id of the account logged in
     * @param regionId the id of the region
     * @return RegionResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteRegion(accountId: kotlin.Long, regionId: kotlin.Long) : RegionResponse {
        val localVarResponse = deleteRegionWithHttpInfo(accountId = accountId, regionId = regionId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RegionResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /region/delete
     * Delete Region
     * Delete a region.
     * @param accountId the id of the account logged in
     * @param regionId the id of the region
     * @return ApiResponse<RegionResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteRegionWithHttpInfo(accountId: kotlin.Long, regionId: kotlin.Long) : ApiResponse<RegionResponse?> {
        val localVariableConfig = deleteRegionRequestConfig(accountId = accountId, regionId = regionId)

        return request<Unit, RegionResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteRegion
     *
     * @param accountId the id of the account logged in
     * @param regionId the id of the region
     * @return RequestConfig
     */
    fun deleteRegionRequestConfig(accountId: kotlin.Long, regionId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("regionId", listOf(regionId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/region/delete",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /region/get
     * Get Region
     * Get a region.
     * @param regionId the id of the region to get
     * @param accountId the id of the logged in user (optional)
     * @return RegionResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getRegion(regionId: kotlin.Long, accountId: kotlin.Long? = null) : RegionResponse {
        val localVarResponse = getRegionWithHttpInfo(regionId = regionId, accountId = accountId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RegionResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /region/get
     * Get Region
     * Get a region.
     * @param regionId the id of the region to get
     * @param accountId the id of the logged in user (optional)
     * @return ApiResponse<RegionResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getRegionWithHttpInfo(regionId: kotlin.Long, accountId: kotlin.Long?) : ApiResponse<RegionResponse?> {
        val localVariableConfig = getRegionRequestConfig(regionId = regionId, accountId = accountId)

        return request<Unit, RegionResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getRegion
     *
     * @param regionId the id of the region to get
     * @param accountId the id of the logged in user (optional)
     * @return RequestConfig
     */
    fun getRegionRequestConfig(regionId: kotlin.Long, accountId: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                put("regionId", listOf(regionId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/region/get",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter regionClass
     */
     enum class RegionClassSearchRegions(val value: kotlin.String) {
         @Json(name = "NATIONAL") NATIONAL("NATIONAL"),
         @Json(name = "STATE") STATE("STATE"),
         @Json(name = "COUNTY") COUNTY("COUNTY"),
         @Json(name = "METRO_AREA") METRO_AREA("METRO_AREA"),
         @Json(name = "CITY") CITY("CITY"),
         @Json(name = "NEIGHBORHOOD") NEIGHBORHOOD("NEIGHBORHOOD"),
         @Json(name = "TERRITORY") TERRITORY("TERRITORY"),
         @Json(name = "CUSTOM") CUSTOM("CUSTOM"),
         @Json(name = "ZONE") ZONE("ZONE");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter visibility
     */
     enum class VisibilitySearchRegions(val value: kotlin.String) {
         @Json(name = "PUBLIC") PUBLIC("PUBLIC"),
         @Json(name = "PRIVATE") PRIVATE("PRIVATE"),
         @Json(name = "FRIENDS") FRIENDS("FRIENDS");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter searchMode
     */
     enum class SearchModeSearchRegions(val value: kotlin.String) {
         @Json(name = "RDS") RDS("RDS"),
         @Json(name = "LUCENE") LUCENE("LUCENE"),
         @Json(name = "CLOUDINDEX") CLOUDINDEX("CLOUDINDEX");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter sortField
     */
     enum class SortFieldSearchRegions(val value: kotlin.String) {
         @Json(name = "ID") ID("ID"),
         @Json(name = "UPDATED") UPDATED("UPDATED"),
         @Json(name = "NAME") NAME("NAME"),
         @Json(name = "DISTANCE") DISTANCE("DISTANCE");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /region/search
     * Search Regions
     * Get the list of regions.
     * @param accountId the owner account id of the region to be created (optional)
     * @param query This parameter is deprecated. deprecated - use \&quot;keyword\&quot; (optional)
     * @param keyword the keyword to filter results on (optional)
     * @param latitude the latitude of the user (optional)
     * @param longitude the longitude of the user (optional)
     * @param range the search radius (optional)
     * @param regionClass  (optional)
     * @param visibility  (optional)
     * @param searchMode the SearchIndexMode: RDS, LUCENE, or CLOUDINDEX. If not provided, will use the default defined in the Sirqul server (optional)
     * @param sortField the field to order results by: ID, UPDATED, NAME, or DISTANCE. If not provided, will use the default which is by ID for text and DISTANCE when lat/long is provided. (optional)
     * @param descending determines if the results get ordered in descending order (optional)
     * @param includeParent include the parent region or not (optional)
     * @param includeChildren include the chidren regions or not (optional)
     * @param includePostalCodes include the postal codes associated with the region or not (optional)
     * @param categoryIds search on the categories associated with the region (optional)
     * @param filterIds search on the filters associated with the region (optional)
     * @param versionCode filter by a specific version code (optional)
     * @param activeOnly filter to show only active results (optional)
     * @param showDeleted If showDeleted is true and activeOnly is false, will return regions that have been deleted (optional)
     * @param lastUpdatedSince only returns records that have last updated since this date \\(UTC timestamp in milliseconds\\) (optional)
     * @param start the start index for pagination (optional)
     * @param limit the limit for pagination (optional)
     * @return kotlin.collections.List<RegionResponse>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun searchRegions(accountId: kotlin.Long? = null, query: kotlin.String? = null, keyword: kotlin.String? = null, latitude: kotlin.Double? = null, longitude: kotlin.Double? = null, range: kotlin.Double? = null, regionClass: RegionClassSearchRegions? = null, visibility: VisibilitySearchRegions? = null, searchMode: SearchModeSearchRegions? = null, sortField: SortFieldSearchRegions? = null, descending: kotlin.Boolean? = null, includeParent: kotlin.Boolean? = null, includeChildren: kotlin.Boolean? = null, includePostalCodes: kotlin.Boolean? = null, categoryIds: kotlin.String? = null, filterIds: kotlin.String? = null, versionCode: kotlin.Int? = null, activeOnly: kotlin.Boolean? = null, showDeleted: kotlin.Boolean? = null, lastUpdatedSince: kotlin.Long? = null, start: kotlin.Int? = null, limit: kotlin.Int? = null) : kotlin.collections.List<RegionResponse> {
        val localVarResponse = searchRegionsWithHttpInfo(accountId = accountId, query = query, keyword = keyword, latitude = latitude, longitude = longitude, range = range, regionClass = regionClass, visibility = visibility, searchMode = searchMode, sortField = sortField, descending = descending, includeParent = includeParent, includeChildren = includeChildren, includePostalCodes = includePostalCodes, categoryIds = categoryIds, filterIds = filterIds, versionCode = versionCode, activeOnly = activeOnly, showDeleted = showDeleted, lastUpdatedSince = lastUpdatedSince, start = start, limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<RegionResponse>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /region/search
     * Search Regions
     * Get the list of regions.
     * @param accountId the owner account id of the region to be created (optional)
     * @param query This parameter is deprecated. deprecated - use \&quot;keyword\&quot; (optional)
     * @param keyword the keyword to filter results on (optional)
     * @param latitude the latitude of the user (optional)
     * @param longitude the longitude of the user (optional)
     * @param range the search radius (optional)
     * @param regionClass  (optional)
     * @param visibility  (optional)
     * @param searchMode the SearchIndexMode: RDS, LUCENE, or CLOUDINDEX. If not provided, will use the default defined in the Sirqul server (optional)
     * @param sortField the field to order results by: ID, UPDATED, NAME, or DISTANCE. If not provided, will use the default which is by ID for text and DISTANCE when lat/long is provided. (optional)
     * @param descending determines if the results get ordered in descending order (optional)
     * @param includeParent include the parent region or not (optional)
     * @param includeChildren include the chidren regions or not (optional)
     * @param includePostalCodes include the postal codes associated with the region or not (optional)
     * @param categoryIds search on the categories associated with the region (optional)
     * @param filterIds search on the filters associated with the region (optional)
     * @param versionCode filter by a specific version code (optional)
     * @param activeOnly filter to show only active results (optional)
     * @param showDeleted If showDeleted is true and activeOnly is false, will return regions that have been deleted (optional)
     * @param lastUpdatedSince only returns records that have last updated since this date \\(UTC timestamp in milliseconds\\) (optional)
     * @param start the start index for pagination (optional)
     * @param limit the limit for pagination (optional)
     * @return ApiResponse<kotlin.collections.List<RegionResponse>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun searchRegionsWithHttpInfo(accountId: kotlin.Long?, query: kotlin.String?, keyword: kotlin.String?, latitude: kotlin.Double?, longitude: kotlin.Double?, range: kotlin.Double?, regionClass: RegionClassSearchRegions?, visibility: VisibilitySearchRegions?, searchMode: SearchModeSearchRegions?, sortField: SortFieldSearchRegions?, descending: kotlin.Boolean?, includeParent: kotlin.Boolean?, includeChildren: kotlin.Boolean?, includePostalCodes: kotlin.Boolean?, categoryIds: kotlin.String?, filterIds: kotlin.String?, versionCode: kotlin.Int?, activeOnly: kotlin.Boolean?, showDeleted: kotlin.Boolean?, lastUpdatedSince: kotlin.Long?, start: kotlin.Int?, limit: kotlin.Int?) : ApiResponse<kotlin.collections.List<RegionResponse>?> {
        val localVariableConfig = searchRegionsRequestConfig(accountId = accountId, query = query, keyword = keyword, latitude = latitude, longitude = longitude, range = range, regionClass = regionClass, visibility = visibility, searchMode = searchMode, sortField = sortField, descending = descending, includeParent = includeParent, includeChildren = includeChildren, includePostalCodes = includePostalCodes, categoryIds = categoryIds, filterIds = filterIds, versionCode = versionCode, activeOnly = activeOnly, showDeleted = showDeleted, lastUpdatedSince = lastUpdatedSince, start = start, limit = limit)

        return request<Unit, kotlin.collections.List<RegionResponse>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation searchRegions
     *
     * @param accountId the owner account id of the region to be created (optional)
     * @param query This parameter is deprecated. deprecated - use \&quot;keyword\&quot; (optional)
     * @param keyword the keyword to filter results on (optional)
     * @param latitude the latitude of the user (optional)
     * @param longitude the longitude of the user (optional)
     * @param range the search radius (optional)
     * @param regionClass  (optional)
     * @param visibility  (optional)
     * @param searchMode the SearchIndexMode: RDS, LUCENE, or CLOUDINDEX. If not provided, will use the default defined in the Sirqul server (optional)
     * @param sortField the field to order results by: ID, UPDATED, NAME, or DISTANCE. If not provided, will use the default which is by ID for text and DISTANCE when lat/long is provided. (optional)
     * @param descending determines if the results get ordered in descending order (optional)
     * @param includeParent include the parent region or not (optional)
     * @param includeChildren include the chidren regions or not (optional)
     * @param includePostalCodes include the postal codes associated with the region or not (optional)
     * @param categoryIds search on the categories associated with the region (optional)
     * @param filterIds search on the filters associated with the region (optional)
     * @param versionCode filter by a specific version code (optional)
     * @param activeOnly filter to show only active results (optional)
     * @param showDeleted If showDeleted is true and activeOnly is false, will return regions that have been deleted (optional)
     * @param lastUpdatedSince only returns records that have last updated since this date \\(UTC timestamp in milliseconds\\) (optional)
     * @param start the start index for pagination (optional)
     * @param limit the limit for pagination (optional)
     * @return RequestConfig
     */
    fun searchRegionsRequestConfig(accountId: kotlin.Long?, query: kotlin.String?, keyword: kotlin.String?, latitude: kotlin.Double?, longitude: kotlin.Double?, range: kotlin.Double?, regionClass: RegionClassSearchRegions?, visibility: VisibilitySearchRegions?, searchMode: SearchModeSearchRegions?, sortField: SortFieldSearchRegions?, descending: kotlin.Boolean?, includeParent: kotlin.Boolean?, includeChildren: kotlin.Boolean?, includePostalCodes: kotlin.Boolean?, categoryIds: kotlin.String?, filterIds: kotlin.String?, versionCode: kotlin.Int?, activeOnly: kotlin.Boolean?, showDeleted: kotlin.Boolean?, lastUpdatedSince: kotlin.Long?, start: kotlin.Int?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (query != null) {
                    put("query", listOf(query.toString()))
                }
                if (keyword != null) {
                    put("keyword", listOf(keyword.toString()))
                }
                if (latitude != null) {
                    put("latitude", listOf(latitude.toString()))
                }
                if (longitude != null) {
                    put("longitude", listOf(longitude.toString()))
                }
                if (range != null) {
                    put("range", listOf(range.toString()))
                }
                if (regionClass != null) {
                    put("regionClass", listOf(regionClass.value))
                }
                if (visibility != null) {
                    put("visibility", listOf(visibility.value))
                }
                if (searchMode != null) {
                    put("searchMode", listOf(searchMode.value))
                }
                if (sortField != null) {
                    put("sortField", listOf(sortField.value))
                }
                if (descending != null) {
                    put("descending", listOf(descending.toString()))
                }
                if (includeParent != null) {
                    put("includeParent", listOf(includeParent.toString()))
                }
                if (includeChildren != null) {
                    put("includeChildren", listOf(includeChildren.toString()))
                }
                if (includePostalCodes != null) {
                    put("includePostalCodes", listOf(includePostalCodes.toString()))
                }
                if (categoryIds != null) {
                    put("categoryIds", listOf(categoryIds.toString()))
                }
                if (filterIds != null) {
                    put("filterIds", listOf(filterIds.toString()))
                }
                if (versionCode != null) {
                    put("versionCode", listOf(versionCode.toString()))
                }
                if (activeOnly != null) {
                    put("activeOnly", listOf(activeOnly.toString()))
                }
                if (showDeleted != null) {
                    put("showDeleted", listOf(showDeleted.toString()))
                }
                if (lastUpdatedSince != null) {
                    put("lastUpdatedSince", listOf(lastUpdatedSince.toString()))
                }
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/region/search",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter visibility
     */
     enum class VisibilityUpdateRegion(val value: kotlin.String) {
         @Json(name = "PUBLIC") PUBLIC("PUBLIC"),
         @Json(name = "PRIVATE") PRIVATE("PRIVATE"),
         @Json(name = "FRIENDS") FRIENDS("FRIENDS");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * POST /region/update
     * Update Region
     * Update a region.
     * @param accountId The id of the account sending the request
     * @param regionId The id of the region to be updated
     * @param regionClass RegionClass of this region (optional)
     * @param shortName Short name of the region. This is optimized for search (optional)
     * @param fullName Full name of the region (optional)
     * @param parentIds Comma separated region ids that are parents of this region (optional)
     * @param childrenIds Comma separated region ids that are children of this region (optional)
     * @param postalCodeIds Comma separated postal code ids the region will include (optional)
     * @param locations Sets of name,lat,long used to create new postal codes assigned to the region (optional)
     * @param retailerLocationId the retailer location ID that the region is associated with (optional)
     * @param visibility The Visibility of the region (optional)
     * @param categoryIds the categories that the region is assigned to (optional)
     * @param filterIds the filters that the region is assigned to (optional)
     * @param start  (optional)
     * @param end  (optional)
     * @param polygon the polygon of the region (optional)
     * @param metaData the meta data of the region (optional)
     * @param latitude the latitude of the region (optional)
     * @param longitude the longitude of the region (optional)
     * @param versionCode the version code (optional)
     * @param root If this is a root region or not. If true means this region has no parent regions (optional)
     * @param active Active or inactive status of the region (optional)
     * @param clearLists If true clear the children and postal code lists before add new ones, otherwise just append. (optional)
     * @return RegionResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updateRegion(accountId: kotlin.Long, regionId: kotlin.Long, regionClass: kotlin.String? = null, shortName: kotlin.String? = null, fullName: kotlin.String? = null, parentIds: kotlin.String? = null, childrenIds: kotlin.String? = null, postalCodeIds: kotlin.String? = null, locations: kotlin.String? = null, retailerLocationId: kotlin.Long? = null, visibility: VisibilityUpdateRegion? = null, categoryIds: kotlin.String? = null, filterIds: kotlin.String? = null, start: kotlin.Long? = null, end: kotlin.Long? = null, polygon: kotlin.String? = null, metaData: kotlin.String? = null, latitude: kotlin.Double? = null, longitude: kotlin.Double? = null, versionCode: kotlin.Int? = null, root: kotlin.Boolean? = null, active: kotlin.Boolean? = null, clearLists: kotlin.Boolean? = null) : RegionResponse {
        val localVarResponse = updateRegionWithHttpInfo(accountId = accountId, regionId = regionId, regionClass = regionClass, shortName = shortName, fullName = fullName, parentIds = parentIds, childrenIds = childrenIds, postalCodeIds = postalCodeIds, locations = locations, retailerLocationId = retailerLocationId, visibility = visibility, categoryIds = categoryIds, filterIds = filterIds, start = start, end = end, polygon = polygon, metaData = metaData, latitude = latitude, longitude = longitude, versionCode = versionCode, root = root, active = active, clearLists = clearLists)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RegionResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /region/update
     * Update Region
     * Update a region.
     * @param accountId The id of the account sending the request
     * @param regionId The id of the region to be updated
     * @param regionClass RegionClass of this region (optional)
     * @param shortName Short name of the region. This is optimized for search (optional)
     * @param fullName Full name of the region (optional)
     * @param parentIds Comma separated region ids that are parents of this region (optional)
     * @param childrenIds Comma separated region ids that are children of this region (optional)
     * @param postalCodeIds Comma separated postal code ids the region will include (optional)
     * @param locations Sets of name,lat,long used to create new postal codes assigned to the region (optional)
     * @param retailerLocationId the retailer location ID that the region is associated with (optional)
     * @param visibility The Visibility of the region (optional)
     * @param categoryIds the categories that the region is assigned to (optional)
     * @param filterIds the filters that the region is assigned to (optional)
     * @param start  (optional)
     * @param end  (optional)
     * @param polygon the polygon of the region (optional)
     * @param metaData the meta data of the region (optional)
     * @param latitude the latitude of the region (optional)
     * @param longitude the longitude of the region (optional)
     * @param versionCode the version code (optional)
     * @param root If this is a root region or not. If true means this region has no parent regions (optional)
     * @param active Active or inactive status of the region (optional)
     * @param clearLists If true clear the children and postal code lists before add new ones, otherwise just append. (optional)
     * @return ApiResponse<RegionResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun updateRegionWithHttpInfo(accountId: kotlin.Long, regionId: kotlin.Long, regionClass: kotlin.String?, shortName: kotlin.String?, fullName: kotlin.String?, parentIds: kotlin.String?, childrenIds: kotlin.String?, postalCodeIds: kotlin.String?, locations: kotlin.String?, retailerLocationId: kotlin.Long?, visibility: VisibilityUpdateRegion?, categoryIds: kotlin.String?, filterIds: kotlin.String?, start: kotlin.Long?, end: kotlin.Long?, polygon: kotlin.String?, metaData: kotlin.String?, latitude: kotlin.Double?, longitude: kotlin.Double?, versionCode: kotlin.Int?, root: kotlin.Boolean?, active: kotlin.Boolean?, clearLists: kotlin.Boolean?) : ApiResponse<RegionResponse?> {
        val localVariableConfig = updateRegionRequestConfig(accountId = accountId, regionId = regionId, regionClass = regionClass, shortName = shortName, fullName = fullName, parentIds = parentIds, childrenIds = childrenIds, postalCodeIds = postalCodeIds, locations = locations, retailerLocationId = retailerLocationId, visibility = visibility, categoryIds = categoryIds, filterIds = filterIds, start = start, end = end, polygon = polygon, metaData = metaData, latitude = latitude, longitude = longitude, versionCode = versionCode, root = root, active = active, clearLists = clearLists)

        return request<Unit, RegionResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateRegion
     *
     * @param accountId The id of the account sending the request
     * @param regionId The id of the region to be updated
     * @param regionClass RegionClass of this region (optional)
     * @param shortName Short name of the region. This is optimized for search (optional)
     * @param fullName Full name of the region (optional)
     * @param parentIds Comma separated region ids that are parents of this region (optional)
     * @param childrenIds Comma separated region ids that are children of this region (optional)
     * @param postalCodeIds Comma separated postal code ids the region will include (optional)
     * @param locations Sets of name,lat,long used to create new postal codes assigned to the region (optional)
     * @param retailerLocationId the retailer location ID that the region is associated with (optional)
     * @param visibility The Visibility of the region (optional)
     * @param categoryIds the categories that the region is assigned to (optional)
     * @param filterIds the filters that the region is assigned to (optional)
     * @param start  (optional)
     * @param end  (optional)
     * @param polygon the polygon of the region (optional)
     * @param metaData the meta data of the region (optional)
     * @param latitude the latitude of the region (optional)
     * @param longitude the longitude of the region (optional)
     * @param versionCode the version code (optional)
     * @param root If this is a root region or not. If true means this region has no parent regions (optional)
     * @param active Active or inactive status of the region (optional)
     * @param clearLists If true clear the children and postal code lists before add new ones, otherwise just append. (optional)
     * @return RequestConfig
     */
    fun updateRegionRequestConfig(accountId: kotlin.Long, regionId: kotlin.Long, regionClass: kotlin.String?, shortName: kotlin.String?, fullName: kotlin.String?, parentIds: kotlin.String?, childrenIds: kotlin.String?, postalCodeIds: kotlin.String?, locations: kotlin.String?, retailerLocationId: kotlin.Long?, visibility: VisibilityUpdateRegion?, categoryIds: kotlin.String?, filterIds: kotlin.String?, start: kotlin.Long?, end: kotlin.Long?, polygon: kotlin.String?, metaData: kotlin.String?, latitude: kotlin.Double?, longitude: kotlin.Double?, versionCode: kotlin.Int?, root: kotlin.Boolean?, active: kotlin.Boolean?, clearLists: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("regionId", listOf(regionId.toString()))
                if (regionClass != null) {
                    put("regionClass", listOf(regionClass.toString()))
                }
                if (shortName != null) {
                    put("shortName", listOf(shortName.toString()))
                }
                if (fullName != null) {
                    put("fullName", listOf(fullName.toString()))
                }
                if (parentIds != null) {
                    put("parentIds", listOf(parentIds.toString()))
                }
                if (childrenIds != null) {
                    put("childrenIds", listOf(childrenIds.toString()))
                }
                if (postalCodeIds != null) {
                    put("postalCodeIds", listOf(postalCodeIds.toString()))
                }
                if (locations != null) {
                    put("locations", listOf(locations.toString()))
                }
                if (retailerLocationId != null) {
                    put("retailerLocationId", listOf(retailerLocationId.toString()))
                }
                if (visibility != null) {
                    put("visibility", listOf(visibility.value))
                }
                if (categoryIds != null) {
                    put("categoryIds", listOf(categoryIds.toString()))
                }
                if (filterIds != null) {
                    put("filterIds", listOf(filterIds.toString()))
                }
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (end != null) {
                    put("end", listOf(end.toString()))
                }
                if (polygon != null) {
                    put("polygon", listOf(polygon.toString()))
                }
                if (metaData != null) {
                    put("metaData", listOf(metaData.toString()))
                }
                if (latitude != null) {
                    put("latitude", listOf(latitude.toString()))
                }
                if (longitude != null) {
                    put("longitude", listOf(longitude.toString()))
                }
                if (versionCode != null) {
                    put("versionCode", listOf(versionCode.toString()))
                }
                if (root != null) {
                    put("root", listOf(root.toString()))
                }
                if (active != null) {
                    put("active", listOf(active.toString()))
                }
                if (clearLists != null) {
                    put("clearLists", listOf(clearLists.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/region/update",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
