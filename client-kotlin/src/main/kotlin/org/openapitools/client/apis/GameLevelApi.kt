/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import org.openapitools.client.models.GameLevelListResponse
import org.openapitools.client.models.GameLevelResponse
import org.openapitools.client.models.QuestionResponse
import org.openapitools.client.models.SirqulResponse
import org.openapitools.client.models.WordzWordResponse

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

open class GameLevelApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost")
        }
    }

    /**
     * POST /api/{version}/level/create
     * Create Game Level
     * Create a game level. Currently does NOT support game objects.
     * @param version 
     * @param accountId The logged in user.
     * @param name The name of the level.
     * @param gameData The game level data: xml, json, or other text based format.
     * @param gameDataSuffix The game level data format type.
     * @param appKey The game application key to save the level for. (optional)
     * @param description The description of the level. (optional)
     * @param difficulty The difficulty, possible values are: VERY_EASY, EASY, MEDIUM, HARD, VERY_HARD. (optional)
     * @param appVersion The version number of the application required to correctly load/play the level. (optional)
     * @param assetImageId The asset Id of the level image. (optional)
     * @param assetIconId The asset Id of the level icon. (optional)
     * @param visibility Is the level visible to others, possible values are: PUBLIC, PRIVATE. (optional)
     * @param friendGroup Make the level be readable by all friends. (optional)
     * @param connectionIds Make the level be readable by connections in this list. (optional)
     * @param connectionGroupIds Make the level be readable by connection groups in this list. (optional)
     * @param balance Set the amount of money available to spend, once 0 deactivate level. Set to a negative value for unlimited. (optional)
     * @param active If true set the game level as active. Default is false. (optional)
     * @param allocateTickets If true then scoring will give tickets. Default is false. (optional)
     * @param ticketCount The number of tickets to reward (optional)
     * @param ticketType The type of ticket to reward, null means default type (optional)
     * @param points The number of points to award for completing a level (optional)
     * @param tutorialTitle Title of the tutorial. (optional)
     * @param tutorialMessage Message of the tutotrial. (optional)
     * @param tutorialAlignment Alignment of the tutorial image. Default to NONE. Possible values are: NONE, IMAGE_ABOVE, IMAGE_BELOW, IMAGE_LEFT, IMAGE_RIGHT, IMAGE_ONLY, TEXT_ONLY (optional)
     * @param tutorialImageAssetId Asset id of the tutorial image. (optional)
     * @param offerId id of the offer (optional)
     * @param metaData external custom client defined data (optional)
     * @return GameLevelResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createGameLevel(version: java.math.BigDecimal, accountId: kotlin.Long, name: kotlin.String, gameData: kotlin.String, gameDataSuffix: kotlin.String, appKey: kotlin.String? = null, description: kotlin.String? = null, difficulty: kotlin.String? = null, appVersion: kotlin.String? = null, assetImageId: kotlin.Long? = null, assetIconId: kotlin.Long? = null, visibility: kotlin.String? = null, friendGroup: kotlin.Boolean? = null, connectionIds: kotlin.String? = null, connectionGroupIds: kotlin.String? = null, balance: kotlin.Double? = null, active: kotlin.Boolean? = null, allocateTickets: kotlin.Boolean? = null, ticketCount: kotlin.Long? = null, ticketType: kotlin.String? = null, points: kotlin.Long? = null, tutorialTitle: kotlin.String? = null, tutorialMessage: kotlin.String? = null, tutorialAlignment: kotlin.String? = null, tutorialImageAssetId: kotlin.Long? = null, offerId: kotlin.Long? = null, metaData: kotlin.String? = null) : GameLevelResponse {
        val localVarResponse = createGameLevelWithHttpInfo(version = version, accountId = accountId, name = name, gameData = gameData, gameDataSuffix = gameDataSuffix, appKey = appKey, description = description, difficulty = difficulty, appVersion = appVersion, assetImageId = assetImageId, assetIconId = assetIconId, visibility = visibility, friendGroup = friendGroup, connectionIds = connectionIds, connectionGroupIds = connectionGroupIds, balance = balance, active = active, allocateTickets = allocateTickets, ticketCount = ticketCount, ticketType = ticketType, points = points, tutorialTitle = tutorialTitle, tutorialMessage = tutorialMessage, tutorialAlignment = tutorialAlignment, tutorialImageAssetId = tutorialImageAssetId, offerId = offerId, metaData = metaData)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GameLevelResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/{version}/level/create
     * Create Game Level
     * Create a game level. Currently does NOT support game objects.
     * @param version 
     * @param accountId The logged in user.
     * @param name The name of the level.
     * @param gameData The game level data: xml, json, or other text based format.
     * @param gameDataSuffix The game level data format type.
     * @param appKey The game application key to save the level for. (optional)
     * @param description The description of the level. (optional)
     * @param difficulty The difficulty, possible values are: VERY_EASY, EASY, MEDIUM, HARD, VERY_HARD. (optional)
     * @param appVersion The version number of the application required to correctly load/play the level. (optional)
     * @param assetImageId The asset Id of the level image. (optional)
     * @param assetIconId The asset Id of the level icon. (optional)
     * @param visibility Is the level visible to others, possible values are: PUBLIC, PRIVATE. (optional)
     * @param friendGroup Make the level be readable by all friends. (optional)
     * @param connectionIds Make the level be readable by connections in this list. (optional)
     * @param connectionGroupIds Make the level be readable by connection groups in this list. (optional)
     * @param balance Set the amount of money available to spend, once 0 deactivate level. Set to a negative value for unlimited. (optional)
     * @param active If true set the game level as active. Default is false. (optional)
     * @param allocateTickets If true then scoring will give tickets. Default is false. (optional)
     * @param ticketCount The number of tickets to reward (optional)
     * @param ticketType The type of ticket to reward, null means default type (optional)
     * @param points The number of points to award for completing a level (optional)
     * @param tutorialTitle Title of the tutorial. (optional)
     * @param tutorialMessage Message of the tutotrial. (optional)
     * @param tutorialAlignment Alignment of the tutorial image. Default to NONE. Possible values are: NONE, IMAGE_ABOVE, IMAGE_BELOW, IMAGE_LEFT, IMAGE_RIGHT, IMAGE_ONLY, TEXT_ONLY (optional)
     * @param tutorialImageAssetId Asset id of the tutorial image. (optional)
     * @param offerId id of the offer (optional)
     * @param metaData external custom client defined data (optional)
     * @return ApiResponse<GameLevelResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createGameLevelWithHttpInfo(version: java.math.BigDecimal, accountId: kotlin.Long, name: kotlin.String, gameData: kotlin.String, gameDataSuffix: kotlin.String, appKey: kotlin.String?, description: kotlin.String?, difficulty: kotlin.String?, appVersion: kotlin.String?, assetImageId: kotlin.Long?, assetIconId: kotlin.Long?, visibility: kotlin.String?, friendGroup: kotlin.Boolean?, connectionIds: kotlin.String?, connectionGroupIds: kotlin.String?, balance: kotlin.Double?, active: kotlin.Boolean?, allocateTickets: kotlin.Boolean?, ticketCount: kotlin.Long?, ticketType: kotlin.String?, points: kotlin.Long?, tutorialTitle: kotlin.String?, tutorialMessage: kotlin.String?, tutorialAlignment: kotlin.String?, tutorialImageAssetId: kotlin.Long?, offerId: kotlin.Long?, metaData: kotlin.String?) : ApiResponse<GameLevelResponse?> {
        val localVariableConfig = createGameLevelRequestConfig(version = version, accountId = accountId, name = name, gameData = gameData, gameDataSuffix = gameDataSuffix, appKey = appKey, description = description, difficulty = difficulty, appVersion = appVersion, assetImageId = assetImageId, assetIconId = assetIconId, visibility = visibility, friendGroup = friendGroup, connectionIds = connectionIds, connectionGroupIds = connectionGroupIds, balance = balance, active = active, allocateTickets = allocateTickets, ticketCount = ticketCount, ticketType = ticketType, points = points, tutorialTitle = tutorialTitle, tutorialMessage = tutorialMessage, tutorialAlignment = tutorialAlignment, tutorialImageAssetId = tutorialImageAssetId, offerId = offerId, metaData = metaData)

        return request<Unit, GameLevelResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createGameLevel
     *
     * @param version 
     * @param accountId The logged in user.
     * @param name The name of the level.
     * @param gameData The game level data: xml, json, or other text based format.
     * @param gameDataSuffix The game level data format type.
     * @param appKey The game application key to save the level for. (optional)
     * @param description The description of the level. (optional)
     * @param difficulty The difficulty, possible values are: VERY_EASY, EASY, MEDIUM, HARD, VERY_HARD. (optional)
     * @param appVersion The version number of the application required to correctly load/play the level. (optional)
     * @param assetImageId The asset Id of the level image. (optional)
     * @param assetIconId The asset Id of the level icon. (optional)
     * @param visibility Is the level visible to others, possible values are: PUBLIC, PRIVATE. (optional)
     * @param friendGroup Make the level be readable by all friends. (optional)
     * @param connectionIds Make the level be readable by connections in this list. (optional)
     * @param connectionGroupIds Make the level be readable by connection groups in this list. (optional)
     * @param balance Set the amount of money available to spend, once 0 deactivate level. Set to a negative value for unlimited. (optional)
     * @param active If true set the game level as active. Default is false. (optional)
     * @param allocateTickets If true then scoring will give tickets. Default is false. (optional)
     * @param ticketCount The number of tickets to reward (optional)
     * @param ticketType The type of ticket to reward, null means default type (optional)
     * @param points The number of points to award for completing a level (optional)
     * @param tutorialTitle Title of the tutorial. (optional)
     * @param tutorialMessage Message of the tutotrial. (optional)
     * @param tutorialAlignment Alignment of the tutorial image. Default to NONE. Possible values are: NONE, IMAGE_ABOVE, IMAGE_BELOW, IMAGE_LEFT, IMAGE_RIGHT, IMAGE_ONLY, TEXT_ONLY (optional)
     * @param tutorialImageAssetId Asset id of the tutorial image. (optional)
     * @param offerId id of the offer (optional)
     * @param metaData external custom client defined data (optional)
     * @return RequestConfig
     */
    fun createGameLevelRequestConfig(version: java.math.BigDecimal, accountId: kotlin.Long, name: kotlin.String, gameData: kotlin.String, gameDataSuffix: kotlin.String, appKey: kotlin.String?, description: kotlin.String?, difficulty: kotlin.String?, appVersion: kotlin.String?, assetImageId: kotlin.Long?, assetIconId: kotlin.Long?, visibility: kotlin.String?, friendGroup: kotlin.Boolean?, connectionIds: kotlin.String?, connectionGroupIds: kotlin.String?, balance: kotlin.Double?, active: kotlin.Boolean?, allocateTickets: kotlin.Boolean?, ticketCount: kotlin.Long?, ticketType: kotlin.String?, points: kotlin.Long?, tutorialTitle: kotlin.String?, tutorialMessage: kotlin.String?, tutorialAlignment: kotlin.String?, tutorialImageAssetId: kotlin.Long?, offerId: kotlin.Long?, metaData: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                if (appKey != null) {
                    put("appKey", listOf(appKey.toString()))
                }
                put("name", listOf(name.toString()))
                if (description != null) {
                    put("description", listOf(description.toString()))
                }
                if (difficulty != null) {
                    put("difficulty", listOf(difficulty.toString()))
                }
                if (appVersion != null) {
                    put("appVersion", listOf(appVersion.toString()))
                }
                if (assetImageId != null) {
                    put("assetImageId", listOf(assetImageId.toString()))
                }
                if (assetIconId != null) {
                    put("assetIconId", listOf(assetIconId.toString()))
                }
                put("gameData", listOf(gameData.toString()))
                put("gameDataSuffix", listOf(gameDataSuffix.toString()))
                if (visibility != null) {
                    put("visibility", listOf(visibility.toString()))
                }
                if (friendGroup != null) {
                    put("friendGroup", listOf(friendGroup.toString()))
                }
                if (connectionIds != null) {
                    put("connectionIds", listOf(connectionIds.toString()))
                }
                if (connectionGroupIds != null) {
                    put("connectionGroupIds", listOf(connectionGroupIds.toString()))
                }
                if (balance != null) {
                    put("balance", listOf(balance.toString()))
                }
                if (active != null) {
                    put("active", listOf(active.toString()))
                }
                if (allocateTickets != null) {
                    put("allocateTickets", listOf(allocateTickets.toString()))
                }
                if (ticketCount != null) {
                    put("ticketCount", listOf(ticketCount.toString()))
                }
                if (ticketType != null) {
                    put("ticketType", listOf(ticketType.toString()))
                }
                if (points != null) {
                    put("points", listOf(points.toString()))
                }
                if (tutorialTitle != null) {
                    put("tutorialTitle", listOf(tutorialTitle.toString()))
                }
                if (tutorialMessage != null) {
                    put("tutorialMessage", listOf(tutorialMessage.toString()))
                }
                if (tutorialAlignment != null) {
                    put("tutorialAlignment", listOf(tutorialAlignment.toString()))
                }
                if (tutorialImageAssetId != null) {
                    put("tutorialImageAssetId", listOf(tutorialImageAssetId.toString()))
                }
                if (offerId != null) {
                    put("offerId", listOf(offerId.toString()))
                }
                if (metaData != null) {
                    put("metaData", listOf(metaData.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/{version}/level/create".replace("{"+"version"+"}", encodeURIComponent(version.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/{version}/level/delete
     * Delete Game Level
     * Delete a game level. The level and account must be valid and have the appropirate permissions to view the content.
     * @param version 
     * @param accountId The logged in user.
     * @param levelId The id of the level to return.
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteGameLevel(version: java.math.BigDecimal, accountId: kotlin.Long, levelId: kotlin.Long) : SirqulResponse {
        val localVarResponse = deleteGameLevelWithHttpInfo(version = version, accountId = accountId, levelId = levelId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/{version}/level/delete
     * Delete Game Level
     * Delete a game level. The level and account must be valid and have the appropirate permissions to view the content.
     * @param version 
     * @param accountId The logged in user.
     * @param levelId The id of the level to return.
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteGameLevelWithHttpInfo(version: java.math.BigDecimal, accountId: kotlin.Long, levelId: kotlin.Long) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = deleteGameLevelRequestConfig(version = version, accountId = accountId, levelId = levelId)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteGameLevel
     *
     * @param version 
     * @param accountId The logged in user.
     * @param levelId The id of the level to return.
     * @return RequestConfig
     */
    fun deleteGameLevelRequestConfig(version: java.math.BigDecimal, accountId: kotlin.Long, levelId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("levelId", listOf(levelId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/{version}/level/delete".replace("{"+"version"+"}", encodeURIComponent(version.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /api/{version}/level/get
     * Get Game Level
     * Get a game level. The level and account must be valid and have the appropirate permissions to view the content.
     * @param version 
     * @param accountId The logged in user.
     * @param levelId The id of the level to return.
     * @param includeGameData If true include the game level data, otherwise don&#39;t. default is false. (optional)
     * @return GameLevelResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getGameLevel(version: java.math.BigDecimal, accountId: kotlin.Long, levelId: kotlin.Long, includeGameData: kotlin.Boolean? = null) : GameLevelResponse {
        val localVarResponse = getGameLevelWithHttpInfo(version = version, accountId = accountId, levelId = levelId, includeGameData = includeGameData)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GameLevelResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/{version}/level/get
     * Get Game Level
     * Get a game level. The level and account must be valid and have the appropirate permissions to view the content.
     * @param version 
     * @param accountId The logged in user.
     * @param levelId The id of the level to return.
     * @param includeGameData If true include the game level data, otherwise don&#39;t. default is false. (optional)
     * @return ApiResponse<GameLevelResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getGameLevelWithHttpInfo(version: java.math.BigDecimal, accountId: kotlin.Long, levelId: kotlin.Long, includeGameData: kotlin.Boolean?) : ApiResponse<GameLevelResponse?> {
        val localVariableConfig = getGameLevelRequestConfig(version = version, accountId = accountId, levelId = levelId, includeGameData = includeGameData)

        return request<Unit, GameLevelResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getGameLevel
     *
     * @param version 
     * @param accountId The logged in user.
     * @param levelId The id of the level to return.
     * @param includeGameData If true include the game level data, otherwise don&#39;t. default is false. (optional)
     * @return RequestConfig
     */
    fun getGameLevelRequestConfig(version: java.math.BigDecimal, accountId: kotlin.Long, levelId: kotlin.Long, includeGameData: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("levelId", listOf(levelId.toString()))
                if (includeGameData != null) {
                    put("includeGameData", listOf(includeGameData.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/{version}/level/get".replace("{"+"version"+"}", encodeURIComponent(version.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /api/{version}/level/search
     * Search Game Levels
     * Get a list of levels for an application, just those the account has permissions to view.
     * @param version 
     * @param accountId The logged in user.
     * @param appKey the application key
     * @param keyword Match the keyword to the owner name or level name. (optional)
     * @param sortField what field to sort on (optional)
     * @param descending whether to return levels in ascending or descending order (optional)
     * @param start Start the result set at some index. (optional)
     * @param limit Limit the result to some number. (optional)
     * @param appVersion The maximum version of the level to return. (optional)
     * @param includeGameData If true include the game level data, otherwise don&#39;t. default is false. (optional)
     * @param filters  (optional)
     * @return GameLevelListResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getGameLevelsByApplication(version: java.math.BigDecimal, accountId: kotlin.Long, appKey: kotlin.String, keyword: kotlin.String? = null, sortField: kotlin.String? = null, descending: kotlin.Boolean? = null, start: kotlin.Int? = null, limit: kotlin.Int? = null, appVersion: kotlin.String? = null, includeGameData: kotlin.Boolean? = null, filters: kotlin.String? = null) : GameLevelListResponse {
        val localVarResponse = getGameLevelsByApplicationWithHttpInfo(version = version, accountId = accountId, appKey = appKey, keyword = keyword, sortField = sortField, descending = descending, start = start, limit = limit, appVersion = appVersion, includeGameData = includeGameData, filters = filters)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GameLevelListResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/{version}/level/search
     * Search Game Levels
     * Get a list of levels for an application, just those the account has permissions to view.
     * @param version 
     * @param accountId The logged in user.
     * @param appKey the application key
     * @param keyword Match the keyword to the owner name or level name. (optional)
     * @param sortField what field to sort on (optional)
     * @param descending whether to return levels in ascending or descending order (optional)
     * @param start Start the result set at some index. (optional)
     * @param limit Limit the result to some number. (optional)
     * @param appVersion The maximum version of the level to return. (optional)
     * @param includeGameData If true include the game level data, otherwise don&#39;t. default is false. (optional)
     * @param filters  (optional)
     * @return ApiResponse<GameLevelListResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getGameLevelsByApplicationWithHttpInfo(version: java.math.BigDecimal, accountId: kotlin.Long, appKey: kotlin.String, keyword: kotlin.String?, sortField: kotlin.String?, descending: kotlin.Boolean?, start: kotlin.Int?, limit: kotlin.Int?, appVersion: kotlin.String?, includeGameData: kotlin.Boolean?, filters: kotlin.String?) : ApiResponse<GameLevelListResponse?> {
        val localVariableConfig = getGameLevelsByApplicationRequestConfig(version = version, accountId = accountId, appKey = appKey, keyword = keyword, sortField = sortField, descending = descending, start = start, limit = limit, appVersion = appVersion, includeGameData = includeGameData, filters = filters)

        return request<Unit, GameLevelListResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getGameLevelsByApplication
     *
     * @param version 
     * @param accountId The logged in user.
     * @param appKey the application key
     * @param keyword Match the keyword to the owner name or level name. (optional)
     * @param sortField what field to sort on (optional)
     * @param descending whether to return levels in ascending or descending order (optional)
     * @param start Start the result set at some index. (optional)
     * @param limit Limit the result to some number. (optional)
     * @param appVersion The maximum version of the level to return. (optional)
     * @param includeGameData If true include the game level data, otherwise don&#39;t. default is false. (optional)
     * @param filters  (optional)
     * @return RequestConfig
     */
    fun getGameLevelsByApplicationRequestConfig(version: java.math.BigDecimal, accountId: kotlin.Long, appKey: kotlin.String, keyword: kotlin.String?, sortField: kotlin.String?, descending: kotlin.Boolean?, start: kotlin.Int?, limit: kotlin.Int?, appVersion: kotlin.String?, includeGameData: kotlin.Boolean?, filters: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("appKey", listOf(appKey.toString()))
                if (keyword != null) {
                    put("keyword", listOf(keyword.toString()))
                }
                if (sortField != null) {
                    put("sortField", listOf(sortField.toString()))
                }
                if (descending != null) {
                    put("descending", listOf(descending.toString()))
                }
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (appVersion != null) {
                    put("appVersion", listOf(appVersion.toString()))
                }
                if (includeGameData != null) {
                    put("includeGameData", listOf(includeGameData.toString()))
                }
                if (filters != null) {
                    put("filters", listOf(filters.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/{version}/level/search".replace("{"+"version"+"}", encodeURIComponent(version.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter sortField
     */
     enum class SortFieldGetGameLevelsByBillableEntity(val value: kotlin.String) {
         @Json(name = "LEVEL_ACTIVE") LEVEL_ACTIVE("LEVEL_ACTIVE"),
         @Json(name = "LEVEL_NAME") LEVEL_NAME("LEVEL_NAME"),
         @Json(name = "LEVEL_DESCRIPTION") LEVEL_DESCRIPTION("LEVEL_DESCRIPTION"),
         @Json(name = "LEVEL_CREATED") LEVEL_CREATED("LEVEL_CREATED"),
         @Json(name = "LEVEL_UPDATED") LEVEL_UPDATED("LEVEL_UPDATED"),
         @Json(name = "LEVEL_LIKES") LEVEL_LIKES("LEVEL_LIKES"),
         @Json(name = "LEVEL_DISLIKES") LEVEL_DISLIKES("LEVEL_DISLIKES"),
         @Json(name = "LEVEL_NOTES") LEVEL_NOTES("LEVEL_NOTES"),
         @Json(name = "LEVEL_PLAYS") LEVEL_PLAYS("LEVEL_PLAYS"),
         @Json(name = "LEVEL_DOWNLOADS") LEVEL_DOWNLOADS("LEVEL_DOWNLOADS"),
         @Json(name = "LEVEL_QUITS") LEVEL_QUITS("LEVEL_QUITS"),
         @Json(name = "LEVEL_COMPLETES") LEVEL_COMPLETES("LEVEL_COMPLETES"),
         @Json(name = "LEVEL_VERSION") LEVEL_VERSION("LEVEL_VERSION"),
         @Json(name = "LEVEL_MISSION_TYPE") LEVEL_MISSION_TYPE("LEVEL_MISSION_TYPE"),
         @Json(name = "LEVEL_OWNER_DISPLAY") LEVEL_OWNER_DISPLAY("LEVEL_OWNER_DISPLAY"),
         @Json(name = "GAME_OWNER_DISPLAY") GAME_OWNER_DISPLAY("GAME_OWNER_DISPLAY"),
         @Json(name = "GAME_TITLE") GAME_TITLE("GAME_TITLE"),
         @Json(name = "GAME_DESCRIPTION") GAME_DESCRIPTION("GAME_DESCRIPTION"),
         @Json(name = "GAME_LIKES") GAME_LIKES("GAME_LIKES"),
         @Json(name = "GAME_DISLIKES") GAME_DISLIKES("GAME_DISLIKES"),
         @Json(name = "APP_NAME") APP_NAME("APP_NAME"),
         @Json(name = "APP_SCORING_TYPE") APP_SCORING_TYPE("APP_SCORING_TYPE");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /api/{version}/level/searchByBillableEntity
     * Search Game Level by Billable Entity
     * Searches on game levels that the logged in user has access to. A user would have access if the creator of the game level is managed under the same BillableEntity.
     * @param version 
     * @param accountId The account id of the user
     * @param appKey the application key (optional)
     * @param keyword The keyword used to search (optional)
     * @param sortField The column to sort the search on (optional)
     * @param descending The order to return the search results (optional)
     * @param activeOnly Return only active results (optional)
     * @param start The record to begin the return set on (optional)
     * @param limit The number of records to return (optional)
     * @return GameLevelResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getGameLevelsByBillableEntity(version: java.math.BigDecimal, accountId: kotlin.Long, appKey: kotlin.String? = null, keyword: kotlin.String? = null, sortField: SortFieldGetGameLevelsByBillableEntity? = null, descending: kotlin.Boolean? = null, activeOnly: kotlin.Boolean? = null, start: kotlin.Long? = null, limit: kotlin.Long? = null) : GameLevelResponse {
        val localVarResponse = getGameLevelsByBillableEntityWithHttpInfo(version = version, accountId = accountId, appKey = appKey, keyword = keyword, sortField = sortField, descending = descending, activeOnly = activeOnly, start = start, limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GameLevelResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/{version}/level/searchByBillableEntity
     * Search Game Level by Billable Entity
     * Searches on game levels that the logged in user has access to. A user would have access if the creator of the game level is managed under the same BillableEntity.
     * @param version 
     * @param accountId The account id of the user
     * @param appKey the application key (optional)
     * @param keyword The keyword used to search (optional)
     * @param sortField The column to sort the search on (optional)
     * @param descending The order to return the search results (optional)
     * @param activeOnly Return only active results (optional)
     * @param start The record to begin the return set on (optional)
     * @param limit The number of records to return (optional)
     * @return ApiResponse<GameLevelResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getGameLevelsByBillableEntityWithHttpInfo(version: java.math.BigDecimal, accountId: kotlin.Long, appKey: kotlin.String?, keyword: kotlin.String?, sortField: SortFieldGetGameLevelsByBillableEntity?, descending: kotlin.Boolean?, activeOnly: kotlin.Boolean?, start: kotlin.Long?, limit: kotlin.Long?) : ApiResponse<GameLevelResponse?> {
        val localVariableConfig = getGameLevelsByBillableEntityRequestConfig(version = version, accountId = accountId, appKey = appKey, keyword = keyword, sortField = sortField, descending = descending, activeOnly = activeOnly, start = start, limit = limit)

        return request<Unit, GameLevelResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getGameLevelsByBillableEntity
     *
     * @param version 
     * @param accountId The account id of the user
     * @param appKey the application key (optional)
     * @param keyword The keyword used to search (optional)
     * @param sortField The column to sort the search on (optional)
     * @param descending The order to return the search results (optional)
     * @param activeOnly Return only active results (optional)
     * @param start The record to begin the return set on (optional)
     * @param limit The number of records to return (optional)
     * @return RequestConfig
     */
    fun getGameLevelsByBillableEntityRequestConfig(version: java.math.BigDecimal, accountId: kotlin.Long, appKey: kotlin.String?, keyword: kotlin.String?, sortField: SortFieldGetGameLevelsByBillableEntity?, descending: kotlin.Boolean?, activeOnly: kotlin.Boolean?, start: kotlin.Long?, limit: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                if (appKey != null) {
                    put("appKey", listOf(appKey.toString()))
                }
                if (keyword != null) {
                    put("keyword", listOf(keyword.toString()))
                }
                if (sortField != null) {
                    put("sortField", listOf(sortField.value))
                }
                if (descending != null) {
                    put("descending", listOf(descending.toString()))
                }
                if (activeOnly != null) {
                    put("activeOnly", listOf(activeOnly.toString()))
                }
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/{version}/level/searchByBillableEntity".replace("{"+"version"+"}", encodeURIComponent(version.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /api/{version}/level/questions/get
     * Get Level Questions
     * Get questions within a level.
     * @param version 
     * @param levelId the id of the level to get questions from
     * @param accountId the id of the logged in user
     * @return QuestionResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getQuestionsInLevel(version: java.math.BigDecimal, levelId: kotlin.Long, accountId: kotlin.Long) : QuestionResponse {
        val localVarResponse = getQuestionsInLevelWithHttpInfo(version = version, levelId = levelId, accountId = accountId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as QuestionResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/{version}/level/questions/get
     * Get Level Questions
     * Get questions within a level.
     * @param version 
     * @param levelId the id of the level to get questions from
     * @param accountId the id of the logged in user
     * @return ApiResponse<QuestionResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getQuestionsInLevelWithHttpInfo(version: java.math.BigDecimal, levelId: kotlin.Long, accountId: kotlin.Long) : ApiResponse<QuestionResponse?> {
        val localVariableConfig = getQuestionsInLevelRequestConfig(version = version, levelId = levelId, accountId = accountId)

        return request<Unit, QuestionResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getQuestionsInLevel
     *
     * @param version 
     * @param levelId the id of the level to get questions from
     * @param accountId the id of the logged in user
     * @return RequestConfig
     */
    fun getQuestionsInLevelRequestConfig(version: java.math.BigDecimal, levelId: kotlin.Long, accountId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("levelId", listOf(levelId.toString()))
                put("accountId", listOf(accountId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/{version}/level/questions/get".replace("{"+"version"+"}", encodeURIComponent(version.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /api/{version}/level/words/get
     * Get Level Words
     * Get words within a level.
     * @param version 
     * @param levelId the id of the level to get words for
     * @param accountId the id of the logged in user
     * @return WordzWordResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getWordsInLevel(version: java.math.BigDecimal, levelId: kotlin.Long, accountId: kotlin.Long) : WordzWordResponse {
        val localVarResponse = getWordsInLevelWithHttpInfo(version = version, levelId = levelId, accountId = accountId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as WordzWordResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/{version}/level/words/get
     * Get Level Words
     * Get words within a level.
     * @param version 
     * @param levelId the id of the level to get words for
     * @param accountId the id of the logged in user
     * @return ApiResponse<WordzWordResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getWordsInLevelWithHttpInfo(version: java.math.BigDecimal, levelId: kotlin.Long, accountId: kotlin.Long) : ApiResponse<WordzWordResponse?> {
        val localVariableConfig = getWordsInLevelRequestConfig(version = version, levelId = levelId, accountId = accountId)

        return request<Unit, WordzWordResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getWordsInLevel
     *
     * @param version 
     * @param levelId the id of the level to get words for
     * @param accountId the id of the logged in user
     * @return RequestConfig
     */
    fun getWordsInLevelRequestConfig(version: java.math.BigDecimal, levelId: kotlin.Long, accountId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("levelId", listOf(levelId.toString()))
                put("accountId", listOf(accountId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/{version}/level/words/get".replace("{"+"version"+"}", encodeURIComponent(version.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/{version}/level/update
     * Update Game Level
     * Update a game level. Currently does NOT support game objects.
     * @param version 
     * @param accountId The logged in user.
     * @param levelId If update then include the level Id.
     * @param appKey The game application key to save the level for. (optional)
     * @param name The name of the level. (optional)
     * @param description The description of the level. (optional)
     * @param difficulty The difficulty, possible values are: VERY_EASY, EASY, MEDIUM, HARD, VERY_HARD. (optional)
     * @param appVersion The version number of the applicatuion required to correctly load/play the level. (optional)
     * @param assetImageId The asset Id of the level image. (optional)
     * @param assetIconId The asset Id of the level icon. (optional)
     * @param gameData The game level data: xml, json, or other texted based format. (optional)
     * @param gameDataSuffix The game level data format type. (optional)
     * @param visibility Is the level visible to others, possible values are: PUBLIC, PRIVATE. (optional)
     * @param friendGroup Make the level be readable by all friends. (optional)
     * @param connectionIds Make the level be readable by connections in this list. (optional)
     * @param connectionGroupIds Make the level be readable by connection groups in this list. (optional)
     * @param balance Set the amount of money available to spend, once 0 deactivate level. Set to a negative value for unlimited. (optional)
     * @param active If true set the game level as active. (optional)
     * @param allocateTickets If true then scoring will give tickets. (optional)
     * @param ticketCount The number of tickets to reward (optional)
     * @param ticketType The type of ticket to reward, null means default type (optional)
     * @param points The number of points to award for completing a level (optional)
     * @param tutorialTitle Title of the tutorial. (optional)
     * @param tutorialMessage Message of the tutorial. (optional)
     * @param tutorialAlignment Alignment of the tutorial image, possible values are: NONE, IMAGE_ABOVE, IMAGE_BELOW, IMAGE_LEFT, IMAGE_RIGHT, IMAGE_ONLY, TEXT_ONLY (optional)
     * @param tutorialImageAssetId Asset id of the tutorial image. (optional)
     * @param offerId  (optional)
     * @param metaData external custom client defined data (optional)
     * @return GameLevelResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updateGameLevel(version: java.math.BigDecimal, accountId: kotlin.Long, levelId: kotlin.Long, appKey: kotlin.String? = null, name: kotlin.String? = null, description: kotlin.String? = null, difficulty: kotlin.String? = null, appVersion: kotlin.String? = null, assetImageId: kotlin.Long? = null, assetIconId: kotlin.Long? = null, gameData: kotlin.String? = null, gameDataSuffix: kotlin.String? = null, visibility: kotlin.String? = null, friendGroup: kotlin.Boolean? = null, connectionIds: kotlin.String? = null, connectionGroupIds: kotlin.String? = null, balance: kotlin.Double? = null, active: kotlin.Boolean? = null, allocateTickets: kotlin.Boolean? = null, ticketCount: kotlin.Long? = null, ticketType: kotlin.String? = null, points: kotlin.Long? = null, tutorialTitle: kotlin.String? = null, tutorialMessage: kotlin.String? = null, tutorialAlignment: kotlin.String? = null, tutorialImageAssetId: kotlin.Long? = null, offerId: kotlin.Long? = null, metaData: kotlin.String? = null) : GameLevelResponse {
        val localVarResponse = updateGameLevelWithHttpInfo(version = version, accountId = accountId, levelId = levelId, appKey = appKey, name = name, description = description, difficulty = difficulty, appVersion = appVersion, assetImageId = assetImageId, assetIconId = assetIconId, gameData = gameData, gameDataSuffix = gameDataSuffix, visibility = visibility, friendGroup = friendGroup, connectionIds = connectionIds, connectionGroupIds = connectionGroupIds, balance = balance, active = active, allocateTickets = allocateTickets, ticketCount = ticketCount, ticketType = ticketType, points = points, tutorialTitle = tutorialTitle, tutorialMessage = tutorialMessage, tutorialAlignment = tutorialAlignment, tutorialImageAssetId = tutorialImageAssetId, offerId = offerId, metaData = metaData)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GameLevelResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/{version}/level/update
     * Update Game Level
     * Update a game level. Currently does NOT support game objects.
     * @param version 
     * @param accountId The logged in user.
     * @param levelId If update then include the level Id.
     * @param appKey The game application key to save the level for. (optional)
     * @param name The name of the level. (optional)
     * @param description The description of the level. (optional)
     * @param difficulty The difficulty, possible values are: VERY_EASY, EASY, MEDIUM, HARD, VERY_HARD. (optional)
     * @param appVersion The version number of the applicatuion required to correctly load/play the level. (optional)
     * @param assetImageId The asset Id of the level image. (optional)
     * @param assetIconId The asset Id of the level icon. (optional)
     * @param gameData The game level data: xml, json, or other texted based format. (optional)
     * @param gameDataSuffix The game level data format type. (optional)
     * @param visibility Is the level visible to others, possible values are: PUBLIC, PRIVATE. (optional)
     * @param friendGroup Make the level be readable by all friends. (optional)
     * @param connectionIds Make the level be readable by connections in this list. (optional)
     * @param connectionGroupIds Make the level be readable by connection groups in this list. (optional)
     * @param balance Set the amount of money available to spend, once 0 deactivate level. Set to a negative value for unlimited. (optional)
     * @param active If true set the game level as active. (optional)
     * @param allocateTickets If true then scoring will give tickets. (optional)
     * @param ticketCount The number of tickets to reward (optional)
     * @param ticketType The type of ticket to reward, null means default type (optional)
     * @param points The number of points to award for completing a level (optional)
     * @param tutorialTitle Title of the tutorial. (optional)
     * @param tutorialMessage Message of the tutorial. (optional)
     * @param tutorialAlignment Alignment of the tutorial image, possible values are: NONE, IMAGE_ABOVE, IMAGE_BELOW, IMAGE_LEFT, IMAGE_RIGHT, IMAGE_ONLY, TEXT_ONLY (optional)
     * @param tutorialImageAssetId Asset id of the tutorial image. (optional)
     * @param offerId  (optional)
     * @param metaData external custom client defined data (optional)
     * @return ApiResponse<GameLevelResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun updateGameLevelWithHttpInfo(version: java.math.BigDecimal, accountId: kotlin.Long, levelId: kotlin.Long, appKey: kotlin.String?, name: kotlin.String?, description: kotlin.String?, difficulty: kotlin.String?, appVersion: kotlin.String?, assetImageId: kotlin.Long?, assetIconId: kotlin.Long?, gameData: kotlin.String?, gameDataSuffix: kotlin.String?, visibility: kotlin.String?, friendGroup: kotlin.Boolean?, connectionIds: kotlin.String?, connectionGroupIds: kotlin.String?, balance: kotlin.Double?, active: kotlin.Boolean?, allocateTickets: kotlin.Boolean?, ticketCount: kotlin.Long?, ticketType: kotlin.String?, points: kotlin.Long?, tutorialTitle: kotlin.String?, tutorialMessage: kotlin.String?, tutorialAlignment: kotlin.String?, tutorialImageAssetId: kotlin.Long?, offerId: kotlin.Long?, metaData: kotlin.String?) : ApiResponse<GameLevelResponse?> {
        val localVariableConfig = updateGameLevelRequestConfig(version = version, accountId = accountId, levelId = levelId, appKey = appKey, name = name, description = description, difficulty = difficulty, appVersion = appVersion, assetImageId = assetImageId, assetIconId = assetIconId, gameData = gameData, gameDataSuffix = gameDataSuffix, visibility = visibility, friendGroup = friendGroup, connectionIds = connectionIds, connectionGroupIds = connectionGroupIds, balance = balance, active = active, allocateTickets = allocateTickets, ticketCount = ticketCount, ticketType = ticketType, points = points, tutorialTitle = tutorialTitle, tutorialMessage = tutorialMessage, tutorialAlignment = tutorialAlignment, tutorialImageAssetId = tutorialImageAssetId, offerId = offerId, metaData = metaData)

        return request<Unit, GameLevelResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateGameLevel
     *
     * @param version 
     * @param accountId The logged in user.
     * @param levelId If update then include the level Id.
     * @param appKey The game application key to save the level for. (optional)
     * @param name The name of the level. (optional)
     * @param description The description of the level. (optional)
     * @param difficulty The difficulty, possible values are: VERY_EASY, EASY, MEDIUM, HARD, VERY_HARD. (optional)
     * @param appVersion The version number of the applicatuion required to correctly load/play the level. (optional)
     * @param assetImageId The asset Id of the level image. (optional)
     * @param assetIconId The asset Id of the level icon. (optional)
     * @param gameData The game level data: xml, json, or other texted based format. (optional)
     * @param gameDataSuffix The game level data format type. (optional)
     * @param visibility Is the level visible to others, possible values are: PUBLIC, PRIVATE. (optional)
     * @param friendGroup Make the level be readable by all friends. (optional)
     * @param connectionIds Make the level be readable by connections in this list. (optional)
     * @param connectionGroupIds Make the level be readable by connection groups in this list. (optional)
     * @param balance Set the amount of money available to spend, once 0 deactivate level. Set to a negative value for unlimited. (optional)
     * @param active If true set the game level as active. (optional)
     * @param allocateTickets If true then scoring will give tickets. (optional)
     * @param ticketCount The number of tickets to reward (optional)
     * @param ticketType The type of ticket to reward, null means default type (optional)
     * @param points The number of points to award for completing a level (optional)
     * @param tutorialTitle Title of the tutorial. (optional)
     * @param tutorialMessage Message of the tutorial. (optional)
     * @param tutorialAlignment Alignment of the tutorial image, possible values are: NONE, IMAGE_ABOVE, IMAGE_BELOW, IMAGE_LEFT, IMAGE_RIGHT, IMAGE_ONLY, TEXT_ONLY (optional)
     * @param tutorialImageAssetId Asset id of the tutorial image. (optional)
     * @param offerId  (optional)
     * @param metaData external custom client defined data (optional)
     * @return RequestConfig
     */
    fun updateGameLevelRequestConfig(version: java.math.BigDecimal, accountId: kotlin.Long, levelId: kotlin.Long, appKey: kotlin.String?, name: kotlin.String?, description: kotlin.String?, difficulty: kotlin.String?, appVersion: kotlin.String?, assetImageId: kotlin.Long?, assetIconId: kotlin.Long?, gameData: kotlin.String?, gameDataSuffix: kotlin.String?, visibility: kotlin.String?, friendGroup: kotlin.Boolean?, connectionIds: kotlin.String?, connectionGroupIds: kotlin.String?, balance: kotlin.Double?, active: kotlin.Boolean?, allocateTickets: kotlin.Boolean?, ticketCount: kotlin.Long?, ticketType: kotlin.String?, points: kotlin.Long?, tutorialTitle: kotlin.String?, tutorialMessage: kotlin.String?, tutorialAlignment: kotlin.String?, tutorialImageAssetId: kotlin.Long?, offerId: kotlin.Long?, metaData: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                if (appKey != null) {
                    put("appKey", listOf(appKey.toString()))
                }
                put("levelId", listOf(levelId.toString()))
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (description != null) {
                    put("description", listOf(description.toString()))
                }
                if (difficulty != null) {
                    put("difficulty", listOf(difficulty.toString()))
                }
                if (appVersion != null) {
                    put("appVersion", listOf(appVersion.toString()))
                }
                if (assetImageId != null) {
                    put("assetImageId", listOf(assetImageId.toString()))
                }
                if (assetIconId != null) {
                    put("assetIconId", listOf(assetIconId.toString()))
                }
                if (gameData != null) {
                    put("gameData", listOf(gameData.toString()))
                }
                if (gameDataSuffix != null) {
                    put("gameDataSuffix", listOf(gameDataSuffix.toString()))
                }
                if (visibility != null) {
                    put("visibility", listOf(visibility.toString()))
                }
                if (friendGroup != null) {
                    put("friendGroup", listOf(friendGroup.toString()))
                }
                if (connectionIds != null) {
                    put("connectionIds", listOf(connectionIds.toString()))
                }
                if (connectionGroupIds != null) {
                    put("connectionGroupIds", listOf(connectionGroupIds.toString()))
                }
                if (balance != null) {
                    put("balance", listOf(balance.toString()))
                }
                if (active != null) {
                    put("active", listOf(active.toString()))
                }
                if (allocateTickets != null) {
                    put("allocateTickets", listOf(allocateTickets.toString()))
                }
                if (ticketCount != null) {
                    put("ticketCount", listOf(ticketCount.toString()))
                }
                if (ticketType != null) {
                    put("ticketType", listOf(ticketType.toString()))
                }
                if (points != null) {
                    put("points", listOf(points.toString()))
                }
                if (tutorialTitle != null) {
                    put("tutorialTitle", listOf(tutorialTitle.toString()))
                }
                if (tutorialMessage != null) {
                    put("tutorialMessage", listOf(tutorialMessage.toString()))
                }
                if (tutorialAlignment != null) {
                    put("tutorialAlignment", listOf(tutorialAlignment.toString()))
                }
                if (tutorialImageAssetId != null) {
                    put("tutorialImageAssetId", listOf(tutorialImageAssetId.toString()))
                }
                if (offerId != null) {
                    put("offerId", listOf(offerId.toString()))
                }
                if (metaData != null) {
                    put("metaData", listOf(metaData.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/{version}/level/update".replace("{"+"version"+"}", encodeURIComponent(version.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/{version}/level/questions/update
     * Update Level Questions
     * Updates a level with question game objects.
     * @param version 
     * @param levelId the id of the level to update questions on
     * @param accountId the id of the logged in user
     * @param questionIds the IDs of the questions to update
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updateQuestionsInLevel(version: java.math.BigDecimal, levelId: kotlin.Long, accountId: kotlin.Long, questionIds: kotlin.String) : SirqulResponse {
        val localVarResponse = updateQuestionsInLevelWithHttpInfo(version = version, levelId = levelId, accountId = accountId, questionIds = questionIds)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/{version}/level/questions/update
     * Update Level Questions
     * Updates a level with question game objects.
     * @param version 
     * @param levelId the id of the level to update questions on
     * @param accountId the id of the logged in user
     * @param questionIds the IDs of the questions to update
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun updateQuestionsInLevelWithHttpInfo(version: java.math.BigDecimal, levelId: kotlin.Long, accountId: kotlin.Long, questionIds: kotlin.String) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = updateQuestionsInLevelRequestConfig(version = version, levelId = levelId, accountId = accountId, questionIds = questionIds)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateQuestionsInLevel
     *
     * @param version 
     * @param levelId the id of the level to update questions on
     * @param accountId the id of the logged in user
     * @param questionIds the IDs of the questions to update
     * @return RequestConfig
     */
    fun updateQuestionsInLevelRequestConfig(version: java.math.BigDecimal, levelId: kotlin.Long, accountId: kotlin.Long, questionIds: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("levelId", listOf(levelId.toString()))
                put("accountId", listOf(accountId.toString()))
                put("questionIds", listOf(questionIds.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/{version}/level/questions/update".replace("{"+"version"+"}", encodeURIComponent(version.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/{version}/level/words/update
     * Update Level Words
     * Updates a level with word game objects.
     * @param version 
     * @param levelId the id of the level to update words for
     * @param accountId the id of the logged in user
     * @param wordIds the ids of the words to update for the level
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updateWordsInLevel(version: java.math.BigDecimal, levelId: kotlin.Long, accountId: kotlin.Long, wordIds: kotlin.String) : SirqulResponse {
        val localVarResponse = updateWordsInLevelWithHttpInfo(version = version, levelId = levelId, accountId = accountId, wordIds = wordIds)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/{version}/level/words/update
     * Update Level Words
     * Updates a level with word game objects.
     * @param version 
     * @param levelId the id of the level to update words for
     * @param accountId the id of the logged in user
     * @param wordIds the ids of the words to update for the level
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun updateWordsInLevelWithHttpInfo(version: java.math.BigDecimal, levelId: kotlin.Long, accountId: kotlin.Long, wordIds: kotlin.String) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = updateWordsInLevelRequestConfig(version = version, levelId = levelId, accountId = accountId, wordIds = wordIds)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateWordsInLevel
     *
     * @param version 
     * @param levelId the id of the level to update words for
     * @param accountId the id of the logged in user
     * @param wordIds the ids of the words to update for the level
     * @return RequestConfig
     */
    fun updateWordsInLevelRequestConfig(version: java.math.BigDecimal, levelId: kotlin.Long, accountId: kotlin.Long, wordIds: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("levelId", listOf(levelId.toString()))
                put("accountId", listOf(accountId.toString()))
                put("wordIds", listOf(wordIds.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/{version}/level/words/update".replace("{"+"version"+"}", encodeURIComponent(version.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
