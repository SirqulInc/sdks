/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import org.openapitools.client.models.CoordsResponse
import org.openapitools.client.models.GeoPointResponse
import org.openapitools.client.models.LocationSearchResponse
import org.openapitools.client.models.SirqulResponse
import org.openapitools.client.models.TrilatCacheRequest

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

open class LocationApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://dev.sirqul.com/api/3.18")
        }
    }

    /**
     * POST /location/trilaterate/cache
     * Create Trilateration Data with File
     * Creates trilateration samples for a source device (i.e. a router).
     * @param udid The unique identifier of the source device
     * @param sourceTime The current timestamp of the source device (optional)
     * @param minimumSampleSize the minimum number of Edysen devices that must be used to be able to trilaterate a device (optional)
     * @param `data` The json formated sample data:  &#x60;&#x60;&#x60;json {    \&quot;count\&quot;: 2,   \&quot;timespan\&quot;: 10,    \&quot;samples\&quot;: [     {       \&quot;deviceId\&quot;: \&quot;device1\&quot;,       \&quot;randomizedId\&quot;: true,        \&quot;deviceSignature\&quot;: \&quot;probe:xyz...\&quot;,        \&quot;alternativeId\&quot;:\&quot;adc123\&quot;,        \&quot;rssi\&quot;: [-63, -75]     },      {       \&quot;deviceId\&quot;: \&quot;device2\&quot;,       \&quot;randomizedId\&quot;: true,        \&quot;deviceSignature\&quot;: \&quot;probe:xyz...\&quot;,        \&quot;alternativeId\&quot;: \&quot;adc123\&quot;,        \&quot;rssi\&quot;: [-83, -79]     }   ] } &#x60;&#x60;&#x60;  (optional)
     * @param dataFile Binary file containing data (multipart upload) (optional)
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun cacheTrilaterationData(udid: kotlin.String, sourceTime: kotlin.Long? = null, minimumSampleSize: kotlin.Int? = null, `data`: kotlin.String? = null, dataFile: java.io.File? = null) : SirqulResponse {
        val localVarResponse = cacheTrilaterationDataWithHttpInfo(udid = udid, sourceTime = sourceTime, minimumSampleSize = minimumSampleSize, `data` = `data`, dataFile = dataFile)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /location/trilaterate/cache
     * Create Trilateration Data with File
     * Creates trilateration samples for a source device (i.e. a router).
     * @param udid The unique identifier of the source device
     * @param sourceTime The current timestamp of the source device (optional)
     * @param minimumSampleSize the minimum number of Edysen devices that must be used to be able to trilaterate a device (optional)
     * @param `data` The json formated sample data:  &#x60;&#x60;&#x60;json {    \&quot;count\&quot;: 2,   \&quot;timespan\&quot;: 10,    \&quot;samples\&quot;: [     {       \&quot;deviceId\&quot;: \&quot;device1\&quot;,       \&quot;randomizedId\&quot;: true,        \&quot;deviceSignature\&quot;: \&quot;probe:xyz...\&quot;,        \&quot;alternativeId\&quot;:\&quot;adc123\&quot;,        \&quot;rssi\&quot;: [-63, -75]     },      {       \&quot;deviceId\&quot;: \&quot;device2\&quot;,       \&quot;randomizedId\&quot;: true,        \&quot;deviceSignature\&quot;: \&quot;probe:xyz...\&quot;,        \&quot;alternativeId\&quot;: \&quot;adc123\&quot;,        \&quot;rssi\&quot;: [-83, -79]     }   ] } &#x60;&#x60;&#x60;  (optional)
     * @param dataFile Binary file containing data (multipart upload) (optional)
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun cacheTrilaterationDataWithHttpInfo(udid: kotlin.String, sourceTime: kotlin.Long?, minimumSampleSize: kotlin.Int?, `data`: kotlin.String?, dataFile: java.io.File?) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = cacheTrilaterationDataRequestConfig(udid = udid, sourceTime = sourceTime, minimumSampleSize = minimumSampleSize, `data` = `data`, dataFile = dataFile)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation cacheTrilaterationData
     *
     * @param udid The unique identifier of the source device
     * @param sourceTime The current timestamp of the source device (optional)
     * @param minimumSampleSize the minimum number of Edysen devices that must be used to be able to trilaterate a device (optional)
     * @param `data` The json formated sample data:  &#x60;&#x60;&#x60;json {    \&quot;count\&quot;: 2,   \&quot;timespan\&quot;: 10,    \&quot;samples\&quot;: [     {       \&quot;deviceId\&quot;: \&quot;device1\&quot;,       \&quot;randomizedId\&quot;: true,        \&quot;deviceSignature\&quot;: \&quot;probe:xyz...\&quot;,        \&quot;alternativeId\&quot;:\&quot;adc123\&quot;,        \&quot;rssi\&quot;: [-63, -75]     },      {       \&quot;deviceId\&quot;: \&quot;device2\&quot;,       \&quot;randomizedId\&quot;: true,        \&quot;deviceSignature\&quot;: \&quot;probe:xyz...\&quot;,        \&quot;alternativeId\&quot;: \&quot;adc123\&quot;,        \&quot;rssi\&quot;: [-83, -79]     }   ] } &#x60;&#x60;&#x60;  (optional)
     * @param dataFile Binary file containing data (multipart upload) (optional)
     * @return RequestConfig
     */
    fun cacheTrilaterationDataRequestConfig(udid: kotlin.String, sourceTime: kotlin.Long?, minimumSampleSize: kotlin.Int?, `data`: kotlin.String?, dataFile: java.io.File?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("udid", listOf(udid.toString()))
                if (sourceTime != null) {
                    put("sourceTime", listOf(sourceTime.toString()))
                }
                if (minimumSampleSize != null) {
                    put("minimumSampleSize", listOf(minimumSampleSize.toString()))
                }
                if (`data` != null) {
                    put("data", listOf(`data`.toString()))
                }
                if (dataFile != null) {
                    put("dataFile", listOf(dataFile.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/location/trilaterate/cache",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /location/trilaterate/cache/submit
     * Create Trilateration Data with Rest
     * Creates trilateration samples for a source device (i.e. a router).
     * @param body  (optional)
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun cacheTrilaterationDataGzip(body: TrilatCacheRequest? = null) : SirqulResponse {
        val localVarResponse = cacheTrilaterationDataGzipWithHttpInfo(body = body)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /location/trilaterate/cache/submit
     * Create Trilateration Data with Rest
     * Creates trilateration samples for a source device (i.e. a router).
     * @param body  (optional)
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun cacheTrilaterationDataGzipWithHttpInfo(body: TrilatCacheRequest?) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = cacheTrilaterationDataGzipRequestConfig(body = body)

        return request<TrilatCacheRequest, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation cacheTrilaterationDataGzip
     *
     * @param body  (optional)
     * @return RequestConfig
     */
    fun cacheTrilaterationDataGzipRequestConfig(body: TrilatCacheRequest?) : RequestConfig<TrilatCacheRequest> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/location/trilaterate/cache/submit",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /location/ip
     * Get Location by IP
     * Get location information based on an IP address.
     * @param ip the ip address of the client device (optional)
     * @return CoordsResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getLocationByIp(ip: kotlin.String? = null) : CoordsResponse {
        val localVarResponse = getLocationByIpWithHttpInfo(ip = ip)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CoordsResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /location/ip
     * Get Location by IP
     * Get location information based on an IP address.
     * @param ip the ip address of the client device (optional)
     * @return ApiResponse<CoordsResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getLocationByIpWithHttpInfo(ip: kotlin.String?) : ApiResponse<CoordsResponse?> {
        val localVariableConfig = getLocationByIpRequestConfig(ip = ip)

        return request<Unit, CoordsResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getLocationByIp
     *
     * @param ip the ip address of the client device (optional)
     * @return RequestConfig
     */
    fun getLocationByIpRequestConfig(ip: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (ip != null) {
                    put("ip", listOf(ip.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/location/ip",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /account/location/trilaterate
     * Get Location by Trilateration
     * Send in device data and calculate a position based on signal strengths.
     * @param accountId The account making the request, if provided the last know location will be updated (optional)
     * @param latitude The known GPS latitude to compare to the calculated version (optional)
     * @param longitude The known GPS longitude to compare to the calculated version (optional)
     * @param `data` The json formated sample data:  &#x60;&#x60;&#x60;json {    \&quot;count\&quot;: 2,   \&quot;timespan\&quot;: 10,    \&quot;samples\&quot;: [     {       \&quot;deviceId\&quot;: \&quot;device1\&quot;,       \&quot;rssi\&quot;: [-63, -75]     },      {       \&quot;deviceId\&quot;: \&quot;device2\&quot;,       \&quot;rssi\&quot;: [-83, -79]     }   ] } &#x60;&#x60;&#x60;  (optional)
     * @param responseFilters Optional response filters (not used currently) (optional)
     * @return GeoPointResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getLocationByTrilateration(accountId: kotlin.Long? = null, latitude: kotlin.Double? = null, longitude: kotlin.Double? = null, `data`: kotlin.String? = null, responseFilters: kotlin.String? = null) : GeoPointResponse {
        val localVarResponse = getLocationByTrilaterationWithHttpInfo(accountId = accountId, latitude = latitude, longitude = longitude, `data` = `data`, responseFilters = responseFilters)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GeoPointResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /account/location/trilaterate
     * Get Location by Trilateration
     * Send in device data and calculate a position based on signal strengths.
     * @param accountId The account making the request, if provided the last know location will be updated (optional)
     * @param latitude The known GPS latitude to compare to the calculated version (optional)
     * @param longitude The known GPS longitude to compare to the calculated version (optional)
     * @param `data` The json formated sample data:  &#x60;&#x60;&#x60;json {    \&quot;count\&quot;: 2,   \&quot;timespan\&quot;: 10,    \&quot;samples\&quot;: [     {       \&quot;deviceId\&quot;: \&quot;device1\&quot;,       \&quot;rssi\&quot;: [-63, -75]     },      {       \&quot;deviceId\&quot;: \&quot;device2\&quot;,       \&quot;rssi\&quot;: [-83, -79]     }   ] } &#x60;&#x60;&#x60;  (optional)
     * @param responseFilters Optional response filters (not used currently) (optional)
     * @return ApiResponse<GeoPointResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getLocationByTrilaterationWithHttpInfo(accountId: kotlin.Long?, latitude: kotlin.Double?, longitude: kotlin.Double?, `data`: kotlin.String?, responseFilters: kotlin.String?) : ApiResponse<GeoPointResponse?> {
        val localVariableConfig = getLocationByTrilaterationRequestConfig(accountId = accountId, latitude = latitude, longitude = longitude, `data` = `data`, responseFilters = responseFilters)

        return request<Unit, GeoPointResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getLocationByTrilateration
     *
     * @param accountId The account making the request, if provided the last know location will be updated (optional)
     * @param latitude The known GPS latitude to compare to the calculated version (optional)
     * @param longitude The known GPS longitude to compare to the calculated version (optional)
     * @param `data` The json formated sample data:  &#x60;&#x60;&#x60;json {    \&quot;count\&quot;: 2,   \&quot;timespan\&quot;: 10,    \&quot;samples\&quot;: [     {       \&quot;deviceId\&quot;: \&quot;device1\&quot;,       \&quot;rssi\&quot;: [-63, -75]     },      {       \&quot;deviceId\&quot;: \&quot;device2\&quot;,       \&quot;rssi\&quot;: [-83, -79]     }   ] } &#x60;&#x60;&#x60;  (optional)
     * @param responseFilters Optional response filters (not used currently) (optional)
     * @return RequestConfig
     */
    fun getLocationByTrilaterationRequestConfig(accountId: kotlin.Long?, latitude: kotlin.Double?, longitude: kotlin.Double?, `data`: kotlin.String?, responseFilters: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (latitude != null) {
                    put("latitude", listOf(latitude.toString()))
                }
                if (longitude != null) {
                    put("longitude", listOf(longitude.toString()))
                }
                if (`data` != null) {
                    put("data", listOf(`data`.toString()))
                }
                if (responseFilters != null) {
                    put("responseFilters", listOf(responseFilters.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/account/location/trilaterate",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /location/search
     * Search Regions or Postal Codes
     * Searches geographic locations by proximity via address or keyword.
     * @param deviceId the device id (optional)
     * @param accountId the account id (optional)
     * @param currentlatitude This parameter is deprecated. (optional)
     * @param currentlongitude This parameter is deprecated. (optional)
     * @param currentLatitude the current latitude of the user (optional)
     * @param currentLongitude the current longitude of the user (optional)
     * @param query the query results by keyword or address (optional)
     * @param zipcode This parameter is deprecated. (optional)
     * @param zipCode the zip code to filter results (optional)
     * @param selectedMaplatitude This parameter is deprecated. (optional)
     * @param selectedMaplongitude This parameter is deprecated. (optional)
     * @param selectedMapLatitude the latitude of where the search should originate from (optional)
     * @param selectedMapLongitude the longitude of where the search should originate from (optional)
     * @param searchRange the search range of the search in miles (optional, default to 5.0)
     * @param useGeocode determines whether to allow searches via address (optional, default to false)
     * @param i This parameter is deprecated. (optional)
     * @param start the start index for pagination (optional, default to 0)
     * @param l This parameter is deprecated. (optional)
     * @param limit the limit for pagination (optional, default to 20)
     * @return LocationSearchResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getLocations(deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, currentlatitude: kotlin.Double? = null, currentlongitude: kotlin.Double? = null, currentLatitude: kotlin.Double? = null, currentLongitude: kotlin.Double? = null, query: kotlin.String? = null, zipcode: kotlin.String? = null, zipCode: kotlin.String? = null, selectedMaplatitude: kotlin.Double? = null, selectedMaplongitude: kotlin.Double? = null, selectedMapLatitude: kotlin.Double? = null, selectedMapLongitude: kotlin.Double? = null, searchRange: kotlin.Double? = 5.0, useGeocode: kotlin.Boolean? = false, i: kotlin.Int? = null, start: kotlin.Int? = 0, l: kotlin.Int? = null, limit: kotlin.Int? = 20) : LocationSearchResponse {
        val localVarResponse = getLocationsWithHttpInfo(deviceId = deviceId, accountId = accountId, currentlatitude = currentlatitude, currentlongitude = currentlongitude, currentLatitude = currentLatitude, currentLongitude = currentLongitude, query = query, zipcode = zipcode, zipCode = zipCode, selectedMaplatitude = selectedMaplatitude, selectedMaplongitude = selectedMaplongitude, selectedMapLatitude = selectedMapLatitude, selectedMapLongitude = selectedMapLongitude, searchRange = searchRange, useGeocode = useGeocode, i = i, start = start, l = l, limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as LocationSearchResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /location/search
     * Search Regions or Postal Codes
     * Searches geographic locations by proximity via address or keyword.
     * @param deviceId the device id (optional)
     * @param accountId the account id (optional)
     * @param currentlatitude This parameter is deprecated. (optional)
     * @param currentlongitude This parameter is deprecated. (optional)
     * @param currentLatitude the current latitude of the user (optional)
     * @param currentLongitude the current longitude of the user (optional)
     * @param query the query results by keyword or address (optional)
     * @param zipcode This parameter is deprecated. (optional)
     * @param zipCode the zip code to filter results (optional)
     * @param selectedMaplatitude This parameter is deprecated. (optional)
     * @param selectedMaplongitude This parameter is deprecated. (optional)
     * @param selectedMapLatitude the latitude of where the search should originate from (optional)
     * @param selectedMapLongitude the longitude of where the search should originate from (optional)
     * @param searchRange the search range of the search in miles (optional, default to 5.0)
     * @param useGeocode determines whether to allow searches via address (optional, default to false)
     * @param i This parameter is deprecated. (optional)
     * @param start the start index for pagination (optional, default to 0)
     * @param l This parameter is deprecated. (optional)
     * @param limit the limit for pagination (optional, default to 20)
     * @return ApiResponse<LocationSearchResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getLocationsWithHttpInfo(deviceId: kotlin.String?, accountId: kotlin.Long?, currentlatitude: kotlin.Double?, currentlongitude: kotlin.Double?, currentLatitude: kotlin.Double?, currentLongitude: kotlin.Double?, query: kotlin.String?, zipcode: kotlin.String?, zipCode: kotlin.String?, selectedMaplatitude: kotlin.Double?, selectedMaplongitude: kotlin.Double?, selectedMapLatitude: kotlin.Double?, selectedMapLongitude: kotlin.Double?, searchRange: kotlin.Double?, useGeocode: kotlin.Boolean?, i: kotlin.Int?, start: kotlin.Int?, l: kotlin.Int?, limit: kotlin.Int?) : ApiResponse<LocationSearchResponse?> {
        val localVariableConfig = getLocationsRequestConfig(deviceId = deviceId, accountId = accountId, currentlatitude = currentlatitude, currentlongitude = currentlongitude, currentLatitude = currentLatitude, currentLongitude = currentLongitude, query = query, zipcode = zipcode, zipCode = zipCode, selectedMaplatitude = selectedMaplatitude, selectedMaplongitude = selectedMaplongitude, selectedMapLatitude = selectedMapLatitude, selectedMapLongitude = selectedMapLongitude, searchRange = searchRange, useGeocode = useGeocode, i = i, start = start, l = l, limit = limit)

        return request<Unit, LocationSearchResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getLocations
     *
     * @param deviceId the device id (optional)
     * @param accountId the account id (optional)
     * @param currentlatitude This parameter is deprecated. (optional)
     * @param currentlongitude This parameter is deprecated. (optional)
     * @param currentLatitude the current latitude of the user (optional)
     * @param currentLongitude the current longitude of the user (optional)
     * @param query the query results by keyword or address (optional)
     * @param zipcode This parameter is deprecated. (optional)
     * @param zipCode the zip code to filter results (optional)
     * @param selectedMaplatitude This parameter is deprecated. (optional)
     * @param selectedMaplongitude This parameter is deprecated. (optional)
     * @param selectedMapLatitude the latitude of where the search should originate from (optional)
     * @param selectedMapLongitude the longitude of where the search should originate from (optional)
     * @param searchRange the search range of the search in miles (optional, default to 5.0)
     * @param useGeocode determines whether to allow searches via address (optional, default to false)
     * @param i This parameter is deprecated. (optional)
     * @param start the start index for pagination (optional, default to 0)
     * @param l This parameter is deprecated. (optional)
     * @param limit the limit for pagination (optional, default to 20)
     * @return RequestConfig
     */
    fun getLocationsRequestConfig(deviceId: kotlin.String?, accountId: kotlin.Long?, currentlatitude: kotlin.Double?, currentlongitude: kotlin.Double?, currentLatitude: kotlin.Double?, currentLongitude: kotlin.Double?, query: kotlin.String?, zipcode: kotlin.String?, zipCode: kotlin.String?, selectedMaplatitude: kotlin.Double?, selectedMaplongitude: kotlin.Double?, selectedMapLatitude: kotlin.Double?, selectedMapLongitude: kotlin.Double?, searchRange: kotlin.Double?, useGeocode: kotlin.Boolean?, i: kotlin.Int?, start: kotlin.Int?, l: kotlin.Int?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (currentlatitude != null) {
                    put("currentlatitude", listOf(currentlatitude.toString()))
                }
                if (currentlongitude != null) {
                    put("currentlongitude", listOf(currentlongitude.toString()))
                }
                if (currentLatitude != null) {
                    put("currentLatitude", listOf(currentLatitude.toString()))
                }
                if (currentLongitude != null) {
                    put("currentLongitude", listOf(currentLongitude.toString()))
                }
                if (query != null) {
                    put("query", listOf(query.toString()))
                }
                if (zipcode != null) {
                    put("zipcode", listOf(zipcode.toString()))
                }
                if (zipCode != null) {
                    put("zipCode", listOf(zipCode.toString()))
                }
                if (selectedMaplatitude != null) {
                    put("selectedMaplatitude", listOf(selectedMaplatitude.toString()))
                }
                if (selectedMaplongitude != null) {
                    put("selectedMaplongitude", listOf(selectedMaplongitude.toString()))
                }
                if (selectedMapLatitude != null) {
                    put("selectedMapLatitude", listOf(selectedMapLatitude.toString()))
                }
                if (selectedMapLongitude != null) {
                    put("selectedMapLongitude", listOf(selectedMapLongitude.toString()))
                }
                if (searchRange != null) {
                    put("searchRange", listOf(searchRange.toString()))
                }
                if (useGeocode != null) {
                    put("useGeocode", listOf(useGeocode.toString()))
                }
                if (i != null) {
                    put("_i", listOf(i.toString()))
                }
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (l != null) {
                    put("_l", listOf(l.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/location/search",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
