/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import org.openapitools.client.models.RetailerLocationResponse
import org.openapitools.client.models.SirqulResponse

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

open class RetailerLocationApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://dev.sirqul.com/api/3.18")
        }
    }

    /**
     * POST /location/create
     * Create Retailer Location (Consumer)
     * Creates a location record for an application that can support crowd sourced locations.
     * @param appKey the application key
     * @param name The name of the retailer location
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param streetAddress The street address of the retailer location (optional)
     * @param streetAddress2 Additional address information (such as a suite number, floor number, building name, or PO Box) (optional)
     * @param city The city of the retailer location (optional)
     * @param state The state of the retailer location (optional)
     * @param postalCode The postal code of the retailer location (optional)
     * @param country the country of the retailer location (optional)
     * @param businessPhone The business phone (optional)
     * @param businessPhoneExt The business phone extension (optional)
     * @param website The website of the retailer location (optional)
     * @param email The email of the retailer location (optional)
     * @param detailsHeader A brief description about the retailer location (255 character limit) (optional)
     * @param detailsBody A detailed description about the retailer location (optional)
     * @param hours The hours of operation (optional)
     * @param tags Custom string field for doing full-text searches (optional)
     * @param logoAssetId The retailer location logo asset id (optional)
     * @param picture1AssetId An asset id (optional)
     * @param picture2AssetId An asset id (optional)
     * @param categoryIds Comma separated list of category IDs used to filter retailer locations by categories (optional)
     * @param filterIds Comma separated list of filter IDs used to filter retailer locations (optional)
     * @param metaData External custom client defined data (optional)
     * @param publicLocation Whether the location is public (optional)
     * @param active whether the retailer location created should be active or not (optional)
     * @param locationType External custom type identifier (optional)
     * @param latitude The latitude to center the search on (optional)
     * @param longitude The longitude to center the search on (optional)
     * @return RetailerLocationResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createRetailerLocationConsumer(appKey: kotlin.String, name: kotlin.String, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, streetAddress: kotlin.String? = null, streetAddress2: kotlin.String? = null, city: kotlin.String? = null, state: kotlin.String? = null, postalCode: kotlin.String? = null, country: kotlin.String? = null, businessPhone: kotlin.String? = null, businessPhoneExt: kotlin.String? = null, website: kotlin.String? = null, email: kotlin.String? = null, detailsHeader: kotlin.String? = null, detailsBody: kotlin.String? = null, hours: kotlin.String? = null, tags: kotlin.String? = null, logoAssetId: kotlin.Long? = null, picture1AssetId: kotlin.Long? = null, picture2AssetId: kotlin.Long? = null, categoryIds: kotlin.String? = null, filterIds: kotlin.String? = null, metaData: kotlin.String? = null, publicLocation: kotlin.Boolean? = null, active: kotlin.Boolean? = null, locationType: kotlin.String? = null, latitude: kotlin.Double? = null, longitude: kotlin.Double? = null) : RetailerLocationResponse {
        val localVarResponse = createRetailerLocationConsumerWithHttpInfo(appKey = appKey, name = name, deviceId = deviceId, accountId = accountId, streetAddress = streetAddress, streetAddress2 = streetAddress2, city = city, state = state, postalCode = postalCode, country = country, businessPhone = businessPhone, businessPhoneExt = businessPhoneExt, website = website, email = email, detailsHeader = detailsHeader, detailsBody = detailsBody, hours = hours, tags = tags, logoAssetId = logoAssetId, picture1AssetId = picture1AssetId, picture2AssetId = picture2AssetId, categoryIds = categoryIds, filterIds = filterIds, metaData = metaData, publicLocation = publicLocation, active = active, locationType = locationType, latitude = latitude, longitude = longitude)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RetailerLocationResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /location/create
     * Create Retailer Location (Consumer)
     * Creates a location record for an application that can support crowd sourced locations.
     * @param appKey the application key
     * @param name The name of the retailer location
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param streetAddress The street address of the retailer location (optional)
     * @param streetAddress2 Additional address information (such as a suite number, floor number, building name, or PO Box) (optional)
     * @param city The city of the retailer location (optional)
     * @param state The state of the retailer location (optional)
     * @param postalCode The postal code of the retailer location (optional)
     * @param country the country of the retailer location (optional)
     * @param businessPhone The business phone (optional)
     * @param businessPhoneExt The business phone extension (optional)
     * @param website The website of the retailer location (optional)
     * @param email The email of the retailer location (optional)
     * @param detailsHeader A brief description about the retailer location (255 character limit) (optional)
     * @param detailsBody A detailed description about the retailer location (optional)
     * @param hours The hours of operation (optional)
     * @param tags Custom string field for doing full-text searches (optional)
     * @param logoAssetId The retailer location logo asset id (optional)
     * @param picture1AssetId An asset id (optional)
     * @param picture2AssetId An asset id (optional)
     * @param categoryIds Comma separated list of category IDs used to filter retailer locations by categories (optional)
     * @param filterIds Comma separated list of filter IDs used to filter retailer locations (optional)
     * @param metaData External custom client defined data (optional)
     * @param publicLocation Whether the location is public (optional)
     * @param active whether the retailer location created should be active or not (optional)
     * @param locationType External custom type identifier (optional)
     * @param latitude The latitude to center the search on (optional)
     * @param longitude The longitude to center the search on (optional)
     * @return ApiResponse<RetailerLocationResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createRetailerLocationConsumerWithHttpInfo(appKey: kotlin.String, name: kotlin.String, deviceId: kotlin.String?, accountId: kotlin.Long?, streetAddress: kotlin.String?, streetAddress2: kotlin.String?, city: kotlin.String?, state: kotlin.String?, postalCode: kotlin.String?, country: kotlin.String?, businessPhone: kotlin.String?, businessPhoneExt: kotlin.String?, website: kotlin.String?, email: kotlin.String?, detailsHeader: kotlin.String?, detailsBody: kotlin.String?, hours: kotlin.String?, tags: kotlin.String?, logoAssetId: kotlin.Long?, picture1AssetId: kotlin.Long?, picture2AssetId: kotlin.Long?, categoryIds: kotlin.String?, filterIds: kotlin.String?, metaData: kotlin.String?, publicLocation: kotlin.Boolean?, active: kotlin.Boolean?, locationType: kotlin.String?, latitude: kotlin.Double?, longitude: kotlin.Double?) : ApiResponse<RetailerLocationResponse?> {
        val localVariableConfig = createRetailerLocationConsumerRequestConfig(appKey = appKey, name = name, deviceId = deviceId, accountId = accountId, streetAddress = streetAddress, streetAddress2 = streetAddress2, city = city, state = state, postalCode = postalCode, country = country, businessPhone = businessPhone, businessPhoneExt = businessPhoneExt, website = website, email = email, detailsHeader = detailsHeader, detailsBody = detailsBody, hours = hours, tags = tags, logoAssetId = logoAssetId, picture1AssetId = picture1AssetId, picture2AssetId = picture2AssetId, categoryIds = categoryIds, filterIds = filterIds, metaData = metaData, publicLocation = publicLocation, active = active, locationType = locationType, latitude = latitude, longitude = longitude)

        return request<Unit, RetailerLocationResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createRetailerLocationConsumer
     *
     * @param appKey the application key
     * @param name The name of the retailer location
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param streetAddress The street address of the retailer location (optional)
     * @param streetAddress2 Additional address information (such as a suite number, floor number, building name, or PO Box) (optional)
     * @param city The city of the retailer location (optional)
     * @param state The state of the retailer location (optional)
     * @param postalCode The postal code of the retailer location (optional)
     * @param country the country of the retailer location (optional)
     * @param businessPhone The business phone (optional)
     * @param businessPhoneExt The business phone extension (optional)
     * @param website The website of the retailer location (optional)
     * @param email The email of the retailer location (optional)
     * @param detailsHeader A brief description about the retailer location (255 character limit) (optional)
     * @param detailsBody A detailed description about the retailer location (optional)
     * @param hours The hours of operation (optional)
     * @param tags Custom string field for doing full-text searches (optional)
     * @param logoAssetId The retailer location logo asset id (optional)
     * @param picture1AssetId An asset id (optional)
     * @param picture2AssetId An asset id (optional)
     * @param categoryIds Comma separated list of category IDs used to filter retailer locations by categories (optional)
     * @param filterIds Comma separated list of filter IDs used to filter retailer locations (optional)
     * @param metaData External custom client defined data (optional)
     * @param publicLocation Whether the location is public (optional)
     * @param active whether the retailer location created should be active or not (optional)
     * @param locationType External custom type identifier (optional)
     * @param latitude The latitude to center the search on (optional)
     * @param longitude The longitude to center the search on (optional)
     * @return RequestConfig
     */
    fun createRetailerLocationConsumerRequestConfig(appKey: kotlin.String, name: kotlin.String, deviceId: kotlin.String?, accountId: kotlin.Long?, streetAddress: kotlin.String?, streetAddress2: kotlin.String?, city: kotlin.String?, state: kotlin.String?, postalCode: kotlin.String?, country: kotlin.String?, businessPhone: kotlin.String?, businessPhoneExt: kotlin.String?, website: kotlin.String?, email: kotlin.String?, detailsHeader: kotlin.String?, detailsBody: kotlin.String?, hours: kotlin.String?, tags: kotlin.String?, logoAssetId: kotlin.Long?, picture1AssetId: kotlin.Long?, picture2AssetId: kotlin.Long?, categoryIds: kotlin.String?, filterIds: kotlin.String?, metaData: kotlin.String?, publicLocation: kotlin.Boolean?, active: kotlin.Boolean?, locationType: kotlin.String?, latitude: kotlin.Double?, longitude: kotlin.Double?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                put("appKey", listOf(appKey.toString()))
                put("name", listOf(name.toString()))
                if (streetAddress != null) {
                    put("streetAddress", listOf(streetAddress.toString()))
                }
                if (streetAddress2 != null) {
                    put("streetAddress2", listOf(streetAddress2.toString()))
                }
                if (city != null) {
                    put("city", listOf(city.toString()))
                }
                if (state != null) {
                    put("state", listOf(state.toString()))
                }
                if (postalCode != null) {
                    put("postalCode", listOf(postalCode.toString()))
                }
                if (country != null) {
                    put("country", listOf(country.toString()))
                }
                if (businessPhone != null) {
                    put("businessPhone", listOf(businessPhone.toString()))
                }
                if (businessPhoneExt != null) {
                    put("businessPhoneExt", listOf(businessPhoneExt.toString()))
                }
                if (website != null) {
                    put("website", listOf(website.toString()))
                }
                if (email != null) {
                    put("email", listOf(email.toString()))
                }
                if (detailsHeader != null) {
                    put("detailsHeader", listOf(detailsHeader.toString()))
                }
                if (detailsBody != null) {
                    put("detailsBody", listOf(detailsBody.toString()))
                }
                if (hours != null) {
                    put("hours", listOf(hours.toString()))
                }
                if (tags != null) {
                    put("tags", listOf(tags.toString()))
                }
                if (logoAssetId != null) {
                    put("logoAssetId", listOf(logoAssetId.toString()))
                }
                if (picture1AssetId != null) {
                    put("picture1AssetId", listOf(picture1AssetId.toString()))
                }
                if (picture2AssetId != null) {
                    put("picture2AssetId", listOf(picture2AssetId.toString()))
                }
                if (categoryIds != null) {
                    put("categoryIds", listOf(categoryIds.toString()))
                }
                if (filterIds != null) {
                    put("filterIds", listOf(filterIds.toString()))
                }
                if (metaData != null) {
                    put("metaData", listOf(metaData.toString()))
                }
                if (publicLocation != null) {
                    put("publicLocation", listOf(publicLocation.toString()))
                }
                if (active != null) {
                    put("active", listOf(active.toString()))
                }
                if (locationType != null) {
                    put("locationType", listOf(locationType.toString()))
                }
                if (latitude != null) {
                    put("latitude", listOf(latitude.toString()))
                }
                if (longitude != null) {
                    put("longitude", listOf(longitude.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/location/create",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter responseFormat
     */
     enum class ResponseFormatCreateRetailerLocations(val value: kotlin.String) {
         @Json(name = "HTML") HTML("HTML"),
         @Json(name = "XML") XML("XML"),
         @Json(name = "JSON") JSON("JSON"),
         @Json(name = "CSV") CSV("CSV");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * POST /retailer/location/create
     * Create Retailer Location
     * Creates a location record for a retailer. Only the owner and the employees of the retailer have access to do this.
     * @param retailerId The ID of the retailer
     * @param name The name of the retailer location
     * @param streetAddress The street address of the retailer location
     * @param city The city of the retailer location
     * @param state The state of the retailer location
     * @param postalCode The postal code of the retailer location
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param streetAddress2 Additional address information (such as a suite number, floor number, building name, or PO Box) (optional)
     * @param country the country of the retailer location (optional)
     * @param businessPhone The business phone number of the retailer location (optional)
     * @param businessPhoneExt The business phone extension (optional)
     * @param website The website of the retailer location (optional)
     * @param email The email of the retailer location (optional)
     * @param internalId An internal identifier used by the retailer (optional)
     * @param detailsHeader A brief description about the retailer location (255 character limit) (optional)
     * @param detailsBody A detailed description about the retailer location (optional)
     * @param hours The hours of operation (optional)
     * @param logo The retailer location logo sent as a multipart binary file (you can optionally use logoAssetId if the asset has already been uploaded before) (optional)
     * @param logoAssetId The retailer location logo asset id (optional)
     * @param picture1 Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture1AssetId if the asset has already been uploaded before) (optional)
     * @param picture1AssetId An asset id (optional)
     * @param picture2 Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture2AssetId if the asset has already been uploaded before) (optional)
     * @param picture2AssetId An asset id (optional)
     * @param categoryIds Comma separated list of category IDs used to filter retailer locations by categories (optional)
     * @param filterIds Comma separated list of filter IDs used to filter retailer locations (optional)
     * @param latitude the latitude of the retailer location (optional)
     * @param longitude the longitude of the retailer location (optional)
     * @param building  (optional)
     * @param googlePlaceId the ID of the Google Place that this retailer location is assigned to (optional)
     * @param yelpId the Yelp ID that this retailer location is assigned to (optional)
     * @param active whether the retailer location should be active or inactive (optional)
     * @param publicLocation Sets whether the location is public or not (optional)
     * @param locationType External custom type identifier (optional)
     * @param audienceIds Comma separated list of audience IDs used to assign audiences to the retailer location (optional)
     * @param audienceIdsToAdd Comma separated list of audience IDs to add to the retailer location (optional)
     * @param audienceIdsToRemove Comma separated list of audience IDs to remove from the retailer location (optional)
     * @param responseFormat The format of the returned response {JSON // default , HTML // for Dojo support when uploading assets} (optional)
     * @param responseIncludes Comma separated list of response includes (e.g. RETAILER,ASSETS,OFFERS,CATEGORIES,FILTERS,AUDIENCES,QRCODE) (optional)
     * @return RetailerLocationResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createRetailerLocations(retailerId: kotlin.Long, name: kotlin.String, streetAddress: kotlin.String, city: kotlin.String, state: kotlin.String, postalCode: kotlin.String, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, streetAddress2: kotlin.String? = null, country: kotlin.String? = null, businessPhone: kotlin.String? = null, businessPhoneExt: kotlin.String? = null, website: kotlin.String? = null, email: kotlin.String? = null, internalId: kotlin.String? = null, detailsHeader: kotlin.String? = null, detailsBody: kotlin.String? = null, hours: kotlin.String? = null, logo: java.io.File? = null, logoAssetId: kotlin.Long? = null, picture1: java.io.File? = null, picture1AssetId: kotlin.Long? = null, picture2: java.io.File? = null, picture2AssetId: kotlin.Long? = null, categoryIds: kotlin.String? = null, filterIds: kotlin.String? = null, latitude: kotlin.Double? = null, longitude: kotlin.Double? = null, building: kotlin.String? = null, googlePlaceId: kotlin.String? = null, yelpId: kotlin.String? = null, active: kotlin.Boolean? = null, publicLocation: kotlin.Boolean? = null, locationType: kotlin.String? = null, audienceIds: kotlin.String? = null, audienceIdsToAdd: kotlin.String? = null, audienceIdsToRemove: kotlin.String? = null, responseFormat: ResponseFormatCreateRetailerLocations? = null, responseIncludes: kotlin.String? = null) : RetailerLocationResponse {
        val localVarResponse = createRetailerLocationsWithHttpInfo(retailerId = retailerId, name = name, streetAddress = streetAddress, city = city, state = state, postalCode = postalCode, deviceId = deviceId, accountId = accountId, streetAddress2 = streetAddress2, country = country, businessPhone = businessPhone, businessPhoneExt = businessPhoneExt, website = website, email = email, internalId = internalId, detailsHeader = detailsHeader, detailsBody = detailsBody, hours = hours, logo = logo, logoAssetId = logoAssetId, picture1 = picture1, picture1AssetId = picture1AssetId, picture2 = picture2, picture2AssetId = picture2AssetId, categoryIds = categoryIds, filterIds = filterIds, latitude = latitude, longitude = longitude, building = building, googlePlaceId = googlePlaceId, yelpId = yelpId, active = active, publicLocation = publicLocation, locationType = locationType, audienceIds = audienceIds, audienceIdsToAdd = audienceIdsToAdd, audienceIdsToRemove = audienceIdsToRemove, responseFormat = responseFormat, responseIncludes = responseIncludes)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RetailerLocationResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /retailer/location/create
     * Create Retailer Location
     * Creates a location record for a retailer. Only the owner and the employees of the retailer have access to do this.
     * @param retailerId The ID of the retailer
     * @param name The name of the retailer location
     * @param streetAddress The street address of the retailer location
     * @param city The city of the retailer location
     * @param state The state of the retailer location
     * @param postalCode The postal code of the retailer location
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param streetAddress2 Additional address information (such as a suite number, floor number, building name, or PO Box) (optional)
     * @param country the country of the retailer location (optional)
     * @param businessPhone The business phone number of the retailer location (optional)
     * @param businessPhoneExt The business phone extension (optional)
     * @param website The website of the retailer location (optional)
     * @param email The email of the retailer location (optional)
     * @param internalId An internal identifier used by the retailer (optional)
     * @param detailsHeader A brief description about the retailer location (255 character limit) (optional)
     * @param detailsBody A detailed description about the retailer location (optional)
     * @param hours The hours of operation (optional)
     * @param logo The retailer location logo sent as a multipart binary file (you can optionally use logoAssetId if the asset has already been uploaded before) (optional)
     * @param logoAssetId The retailer location logo asset id (optional)
     * @param picture1 Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture1AssetId if the asset has already been uploaded before) (optional)
     * @param picture1AssetId An asset id (optional)
     * @param picture2 Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture2AssetId if the asset has already been uploaded before) (optional)
     * @param picture2AssetId An asset id (optional)
     * @param categoryIds Comma separated list of category IDs used to filter retailer locations by categories (optional)
     * @param filterIds Comma separated list of filter IDs used to filter retailer locations (optional)
     * @param latitude the latitude of the retailer location (optional)
     * @param longitude the longitude of the retailer location (optional)
     * @param building  (optional)
     * @param googlePlaceId the ID of the Google Place that this retailer location is assigned to (optional)
     * @param yelpId the Yelp ID that this retailer location is assigned to (optional)
     * @param active whether the retailer location should be active or inactive (optional)
     * @param publicLocation Sets whether the location is public or not (optional)
     * @param locationType External custom type identifier (optional)
     * @param audienceIds Comma separated list of audience IDs used to assign audiences to the retailer location (optional)
     * @param audienceIdsToAdd Comma separated list of audience IDs to add to the retailer location (optional)
     * @param audienceIdsToRemove Comma separated list of audience IDs to remove from the retailer location (optional)
     * @param responseFormat The format of the returned response {JSON // default , HTML // for Dojo support when uploading assets} (optional)
     * @param responseIncludes Comma separated list of response includes (e.g. RETAILER,ASSETS,OFFERS,CATEGORIES,FILTERS,AUDIENCES,QRCODE) (optional)
     * @return ApiResponse<RetailerLocationResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createRetailerLocationsWithHttpInfo(retailerId: kotlin.Long, name: kotlin.String, streetAddress: kotlin.String, city: kotlin.String, state: kotlin.String, postalCode: kotlin.String, deviceId: kotlin.String?, accountId: kotlin.Long?, streetAddress2: kotlin.String?, country: kotlin.String?, businessPhone: kotlin.String?, businessPhoneExt: kotlin.String?, website: kotlin.String?, email: kotlin.String?, internalId: kotlin.String?, detailsHeader: kotlin.String?, detailsBody: kotlin.String?, hours: kotlin.String?, logo: java.io.File?, logoAssetId: kotlin.Long?, picture1: java.io.File?, picture1AssetId: kotlin.Long?, picture2: java.io.File?, picture2AssetId: kotlin.Long?, categoryIds: kotlin.String?, filterIds: kotlin.String?, latitude: kotlin.Double?, longitude: kotlin.Double?, building: kotlin.String?, googlePlaceId: kotlin.String?, yelpId: kotlin.String?, active: kotlin.Boolean?, publicLocation: kotlin.Boolean?, locationType: kotlin.String?, audienceIds: kotlin.String?, audienceIdsToAdd: kotlin.String?, audienceIdsToRemove: kotlin.String?, responseFormat: ResponseFormatCreateRetailerLocations?, responseIncludes: kotlin.String?) : ApiResponse<RetailerLocationResponse?> {
        val localVariableConfig = createRetailerLocationsRequestConfig(retailerId = retailerId, name = name, streetAddress = streetAddress, city = city, state = state, postalCode = postalCode, deviceId = deviceId, accountId = accountId, streetAddress2 = streetAddress2, country = country, businessPhone = businessPhone, businessPhoneExt = businessPhoneExt, website = website, email = email, internalId = internalId, detailsHeader = detailsHeader, detailsBody = detailsBody, hours = hours, logo = logo, logoAssetId = logoAssetId, picture1 = picture1, picture1AssetId = picture1AssetId, picture2 = picture2, picture2AssetId = picture2AssetId, categoryIds = categoryIds, filterIds = filterIds, latitude = latitude, longitude = longitude, building = building, googlePlaceId = googlePlaceId, yelpId = yelpId, active = active, publicLocation = publicLocation, locationType = locationType, audienceIds = audienceIds, audienceIdsToAdd = audienceIdsToAdd, audienceIdsToRemove = audienceIdsToRemove, responseFormat = responseFormat, responseIncludes = responseIncludes)

        return request<Unit, RetailerLocationResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createRetailerLocations
     *
     * @param retailerId The ID of the retailer
     * @param name The name of the retailer location
     * @param streetAddress The street address of the retailer location
     * @param city The city of the retailer location
     * @param state The state of the retailer location
     * @param postalCode The postal code of the retailer location
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param streetAddress2 Additional address information (such as a suite number, floor number, building name, or PO Box) (optional)
     * @param country the country of the retailer location (optional)
     * @param businessPhone The business phone number of the retailer location (optional)
     * @param businessPhoneExt The business phone extension (optional)
     * @param website The website of the retailer location (optional)
     * @param email The email of the retailer location (optional)
     * @param internalId An internal identifier used by the retailer (optional)
     * @param detailsHeader A brief description about the retailer location (255 character limit) (optional)
     * @param detailsBody A detailed description about the retailer location (optional)
     * @param hours The hours of operation (optional)
     * @param logo The retailer location logo sent as a multipart binary file (you can optionally use logoAssetId if the asset has already been uploaded before) (optional)
     * @param logoAssetId The retailer location logo asset id (optional)
     * @param picture1 Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture1AssetId if the asset has already been uploaded before) (optional)
     * @param picture1AssetId An asset id (optional)
     * @param picture2 Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture2AssetId if the asset has already been uploaded before) (optional)
     * @param picture2AssetId An asset id (optional)
     * @param categoryIds Comma separated list of category IDs used to filter retailer locations by categories (optional)
     * @param filterIds Comma separated list of filter IDs used to filter retailer locations (optional)
     * @param latitude the latitude of the retailer location (optional)
     * @param longitude the longitude of the retailer location (optional)
     * @param building  (optional)
     * @param googlePlaceId the ID of the Google Place that this retailer location is assigned to (optional)
     * @param yelpId the Yelp ID that this retailer location is assigned to (optional)
     * @param active whether the retailer location should be active or inactive (optional)
     * @param publicLocation Sets whether the location is public or not (optional)
     * @param locationType External custom type identifier (optional)
     * @param audienceIds Comma separated list of audience IDs used to assign audiences to the retailer location (optional)
     * @param audienceIdsToAdd Comma separated list of audience IDs to add to the retailer location (optional)
     * @param audienceIdsToRemove Comma separated list of audience IDs to remove from the retailer location (optional)
     * @param responseFormat The format of the returned response {JSON // default , HTML // for Dojo support when uploading assets} (optional)
     * @param responseIncludes Comma separated list of response includes (e.g. RETAILER,ASSETS,OFFERS,CATEGORIES,FILTERS,AUDIENCES,QRCODE) (optional)
     * @return RequestConfig
     */
    fun createRetailerLocationsRequestConfig(retailerId: kotlin.Long, name: kotlin.String, streetAddress: kotlin.String, city: kotlin.String, state: kotlin.String, postalCode: kotlin.String, deviceId: kotlin.String?, accountId: kotlin.Long?, streetAddress2: kotlin.String?, country: kotlin.String?, businessPhone: kotlin.String?, businessPhoneExt: kotlin.String?, website: kotlin.String?, email: kotlin.String?, internalId: kotlin.String?, detailsHeader: kotlin.String?, detailsBody: kotlin.String?, hours: kotlin.String?, logo: java.io.File?, logoAssetId: kotlin.Long?, picture1: java.io.File?, picture1AssetId: kotlin.Long?, picture2: java.io.File?, picture2AssetId: kotlin.Long?, categoryIds: kotlin.String?, filterIds: kotlin.String?, latitude: kotlin.Double?, longitude: kotlin.Double?, building: kotlin.String?, googlePlaceId: kotlin.String?, yelpId: kotlin.String?, active: kotlin.Boolean?, publicLocation: kotlin.Boolean?, locationType: kotlin.String?, audienceIds: kotlin.String?, audienceIdsToAdd: kotlin.String?, audienceIdsToRemove: kotlin.String?, responseFormat: ResponseFormatCreateRetailerLocations?, responseIncludes: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                put("retailerId", listOf(retailerId.toString()))
                put("name", listOf(name.toString()))
                put("streetAddress", listOf(streetAddress.toString()))
                if (streetAddress2 != null) {
                    put("streetAddress2", listOf(streetAddress2.toString()))
                }
                put("city", listOf(city.toString()))
                put("state", listOf(state.toString()))
                put("postalCode", listOf(postalCode.toString()))
                if (country != null) {
                    put("country", listOf(country.toString()))
                }
                if (businessPhone != null) {
                    put("businessPhone", listOf(businessPhone.toString()))
                }
                if (businessPhoneExt != null) {
                    put("businessPhoneExt", listOf(businessPhoneExt.toString()))
                }
                if (website != null) {
                    put("website", listOf(website.toString()))
                }
                if (email != null) {
                    put("email", listOf(email.toString()))
                }
                if (internalId != null) {
                    put("internalId", listOf(internalId.toString()))
                }
                if (detailsHeader != null) {
                    put("detailsHeader", listOf(detailsHeader.toString()))
                }
                if (detailsBody != null) {
                    put("detailsBody", listOf(detailsBody.toString()))
                }
                if (hours != null) {
                    put("hours", listOf(hours.toString()))
                }
                if (logo != null) {
                    put("logo", listOf(logo.toString()))
                }
                if (logoAssetId != null) {
                    put("logoAssetId", listOf(logoAssetId.toString()))
                }
                if (picture1 != null) {
                    put("picture1", listOf(picture1.toString()))
                }
                if (picture1AssetId != null) {
                    put("picture1AssetId", listOf(picture1AssetId.toString()))
                }
                if (picture2 != null) {
                    put("picture2", listOf(picture2.toString()))
                }
                if (picture2AssetId != null) {
                    put("picture2AssetId", listOf(picture2AssetId.toString()))
                }
                if (categoryIds != null) {
                    put("categoryIds", listOf(categoryIds.toString()))
                }
                if (filterIds != null) {
                    put("filterIds", listOf(filterIds.toString()))
                }
                if (latitude != null) {
                    put("latitude", listOf(latitude.toString()))
                }
                if (longitude != null) {
                    put("longitude", listOf(longitude.toString()))
                }
                if (building != null) {
                    put("building", listOf(building.toString()))
                }
                if (googlePlaceId != null) {
                    put("googlePlaceId", listOf(googlePlaceId.toString()))
                }
                if (yelpId != null) {
                    put("yelpId", listOf(yelpId.toString()))
                }
                if (active != null) {
                    put("active", listOf(active.toString()))
                }
                if (publicLocation != null) {
                    put("publicLocation", listOf(publicLocation.toString()))
                }
                if (locationType != null) {
                    put("locationType", listOf(locationType.toString()))
                }
                if (audienceIds != null) {
                    put("audienceIds", listOf(audienceIds.toString()))
                }
                if (audienceIdsToAdd != null) {
                    put("audienceIdsToAdd", listOf(audienceIdsToAdd.toString()))
                }
                if (audienceIdsToRemove != null) {
                    put("audienceIdsToRemove", listOf(audienceIdsToRemove.toString()))
                }
                if (responseFormat != null) {
                    put("responseFormat", listOf(responseFormat.value))
                }
                if (responseIncludes != null) {
                    put("responseIncludes", listOf(responseIncludes.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/retailer/location/create",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /retailer/location/delete
     * Delete Retailer Location
     * Set the deleted timestamp to current time. This effectively deletes the retailer location since all queries should ignore any records with a deleted time stamp.
     * @param deviceId the device id (optional)
     * @param accountId the id of the logged in user (optional)
     * @param retailerLocationId the id of the retailer location to delete (optional)
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteRetailerLocation(deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, retailerLocationId: kotlin.Long? = null) : SirqulResponse {
        val localVarResponse = deleteRetailerLocationWithHttpInfo(deviceId = deviceId, accountId = accountId, retailerLocationId = retailerLocationId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /retailer/location/delete
     * Delete Retailer Location
     * Set the deleted timestamp to current time. This effectively deletes the retailer location since all queries should ignore any records with a deleted time stamp.
     * @param deviceId the device id (optional)
     * @param accountId the id of the logged in user (optional)
     * @param retailerLocationId the id of the retailer location to delete (optional)
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteRetailerLocationWithHttpInfo(deviceId: kotlin.String?, accountId: kotlin.Long?, retailerLocationId: kotlin.Long?) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = deleteRetailerLocationRequestConfig(deviceId = deviceId, accountId = accountId, retailerLocationId = retailerLocationId)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteRetailerLocation
     *
     * @param deviceId the device id (optional)
     * @param accountId the id of the logged in user (optional)
     * @param retailerLocationId the id of the retailer location to delete (optional)
     * @return RequestConfig
     */
    fun deleteRetailerLocationRequestConfig(deviceId: kotlin.String?, accountId: kotlin.Long?, retailerLocationId: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (retailerLocationId != null) {
                    put("retailerLocationId", listOf(retailerLocationId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/retailer/location/delete",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /retailer/location/get
     * Get Retailer Location
     * Gets a retailer location. Only the owner and the employees of the retailer have access to view its information.
     * @param retailerLocationId The ID of the retailer location
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param retailerLocationToken the unique token of the retailer location (optional)
     * @return RetailerLocationResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getRetailerLocation(retailerLocationId: kotlin.Long, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, retailerLocationToken: kotlin.String? = null) : RetailerLocationResponse {
        val localVarResponse = getRetailerLocationWithHttpInfo(retailerLocationId = retailerLocationId, deviceId = deviceId, accountId = accountId, retailerLocationToken = retailerLocationToken)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RetailerLocationResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /retailer/location/get
     * Get Retailer Location
     * Gets a retailer location. Only the owner and the employees of the retailer have access to view its information.
     * @param retailerLocationId The ID of the retailer location
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param retailerLocationToken the unique token of the retailer location (optional)
     * @return ApiResponse<RetailerLocationResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getRetailerLocationWithHttpInfo(retailerLocationId: kotlin.Long, deviceId: kotlin.String?, accountId: kotlin.Long?, retailerLocationToken: kotlin.String?) : ApiResponse<RetailerLocationResponse?> {
        val localVariableConfig = getRetailerLocationRequestConfig(retailerLocationId = retailerLocationId, deviceId = deviceId, accountId = accountId, retailerLocationToken = retailerLocationToken)

        return request<Unit, RetailerLocationResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getRetailerLocation
     *
     * @param retailerLocationId The ID of the retailer location
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param retailerLocationToken the unique token of the retailer location (optional)
     * @return RequestConfig
     */
    fun getRetailerLocationRequestConfig(retailerLocationId: kotlin.Long, deviceId: kotlin.String?, accountId: kotlin.Long?, retailerLocationToken: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                put("retailerLocationId", listOf(retailerLocationId.toString()))
                if (retailerLocationToken != null) {
                    put("retailerLocationToken", listOf(retailerLocationToken.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/retailer/location/get",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /location/get
     * Get Retailer Location (Consumer)
     * Gets the details of a retailer location as a consumer.
     * @param retailerLocationId The retailer location id
     * @param deviceId The device id for returning account information (i.e. favorites) (optional)
     * @param accountId The account id for returning account information (i.e. favorites) (optional)
     * @return RetailerLocationResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getRetailerLocationConsumer(retailerLocationId: kotlin.Long, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null) : RetailerLocationResponse {
        val localVarResponse = getRetailerLocationConsumerWithHttpInfo(retailerLocationId = retailerLocationId, deviceId = deviceId, accountId = accountId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RetailerLocationResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /location/get
     * Get Retailer Location (Consumer)
     * Gets the details of a retailer location as a consumer.
     * @param retailerLocationId The retailer location id
     * @param deviceId The device id for returning account information (i.e. favorites) (optional)
     * @param accountId The account id for returning account information (i.e. favorites) (optional)
     * @return ApiResponse<RetailerLocationResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getRetailerLocationConsumerWithHttpInfo(retailerLocationId: kotlin.Long, deviceId: kotlin.String?, accountId: kotlin.Long?) : ApiResponse<RetailerLocationResponse?> {
        val localVariableConfig = getRetailerLocationConsumerRequestConfig(retailerLocationId = retailerLocationId, deviceId = deviceId, accountId = accountId)

        return request<Unit, RetailerLocationResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getRetailerLocationConsumer
     *
     * @param retailerLocationId The retailer location id
     * @param deviceId The device id for returning account information (i.e. favorites) (optional)
     * @param accountId The account id for returning account information (i.e. favorites) (optional)
     * @return RequestConfig
     */
    fun getRetailerLocationConsumerRequestConfig(retailerLocationId: kotlin.Long, deviceId: kotlin.String?, accountId: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                put("retailerLocationId", listOf(retailerLocationId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/location/get",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter distanceUnit
     */
     enum class DistanceUnitIndexedRetailerLocationDistanceSearch(val value: kotlin.String) {
         @Json(name = "MILES") MILES("MILES"),
         @Json(name = "KILOMETERS") KILOMETERS("KILOMETERS");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /retailer/location/idistancesearch
     * Distance Search Retailer Locations (Indexed)
     * Retailer location indexed search by distance. This searches on any retailer location with location data and returns the results sorted by distance.
     * @param latitude The latitude to center the search on
     * @param longitude The longitude to center the search on
     * @param searchRange The search range in the distanceUnit specified; default is MILES.
     * @param start The start index for pagination
     * @param limit The limit for pagination
     * @param accountId The account id of the user (optional)
     * @param address Used to return results using this address as the center (optional)
     * @param hasOffers boolean to indicate whether to include retailer locations that have no offers (optional)
     * @param categories Comma separate list of category ids (optional)
     * @param filters Comma separated list of filter ids (optional)
     * @param audiences Comma separated list of audience ids (optional)
     * @param retailerIds Comma separated list of retailer ids (optional)
     * @param retailerLocationIds Comma separated list of retailer location ids (optional)
     * @param tags Does a full-text search on tags (optional)
     * @param locationType Location type filter (optional)
     * @param sortField The field to sort the result set on. Possible values include: DISTANCE, RETAILER_NAME, RETAILER_LOCATION_NAME (optional)
     * @param descending Determines whether the sorted list is in descending or ascending order (optional)
     * @param q This parameter is deprecated. (optional)
     * @param keyword Search by keyword (optional)
     * @param keywordOperator Determines the operator used when there are multiple words in the &#39;keyword&#39; parameter (optional)
     * @param searchExpression Search expression to further refine results (optional)
     * @param distanceUnit Unit of distance (optional)
     * @param returnFavorited (deprecated) return favorited flag (optional)
     * @param returnRetailer Return retailer info (optional)
     * @param returnAssets Return assets (optional)
     * @param returnOffers Return offers (optional)
     * @param returnCategories Return categories (optional)
     * @param returnFilters Return filters (optional)
     * @param returnAudiences Return audiences (optional)
     * @param returnQrCode Return QR code info (optional)
     * @param returnExternalCategoryData Return external category data (optional)
     * @param includeFavorite Include favorites in response (optional)
     * @param includeLiked Include liked flag in response (optional)
     * @param includeRating Include rating info in response (optional)
     * @return kotlin.collections.List<RetailerLocationResponse>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun indexedRetailerLocationDistanceSearch(latitude: kotlin.Double, longitude: kotlin.Double, searchRange: kotlin.Double, start: kotlin.Int, limit: kotlin.Int, accountId: kotlin.Long? = null, address: kotlin.String? = null, hasOffers: kotlin.Boolean? = null, categories: kotlin.String? = null, filters: kotlin.String? = null, audiences: kotlin.String? = null, retailerIds: kotlin.String? = null, retailerLocationIds: kotlin.String? = null, tags: kotlin.String? = null, locationType: kotlin.String? = null, sortField: kotlin.String? = null, descending: kotlin.Boolean? = null, q: kotlin.String? = null, keyword: kotlin.String? = null, keywordOperator: kotlin.String? = null, searchExpression: kotlin.String? = null, distanceUnit: DistanceUnitIndexedRetailerLocationDistanceSearch? = null, returnFavorited: kotlin.Boolean? = null, returnRetailer: kotlin.Boolean? = null, returnAssets: kotlin.Boolean? = null, returnOffers: kotlin.Boolean? = null, returnCategories: kotlin.Boolean? = null, returnFilters: kotlin.Boolean? = null, returnAudiences: kotlin.Boolean? = null, returnQrCode: kotlin.Boolean? = null, returnExternalCategoryData: kotlin.Boolean? = null, includeFavorite: kotlin.Boolean? = null, includeLiked: kotlin.Boolean? = null, includeRating: kotlin.Boolean? = null) : kotlin.collections.List<RetailerLocationResponse> {
        val localVarResponse = indexedRetailerLocationDistanceSearchWithHttpInfo(latitude = latitude, longitude = longitude, searchRange = searchRange, start = start, limit = limit, accountId = accountId, address = address, hasOffers = hasOffers, categories = categories, filters = filters, audiences = audiences, retailerIds = retailerIds, retailerLocationIds = retailerLocationIds, tags = tags, locationType = locationType, sortField = sortField, descending = descending, q = q, keyword = keyword, keywordOperator = keywordOperator, searchExpression = searchExpression, distanceUnit = distanceUnit, returnFavorited = returnFavorited, returnRetailer = returnRetailer, returnAssets = returnAssets, returnOffers = returnOffers, returnCategories = returnCategories, returnFilters = returnFilters, returnAudiences = returnAudiences, returnQrCode = returnQrCode, returnExternalCategoryData = returnExternalCategoryData, includeFavorite = includeFavorite, includeLiked = includeLiked, includeRating = includeRating)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<RetailerLocationResponse>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /retailer/location/idistancesearch
     * Distance Search Retailer Locations (Indexed)
     * Retailer location indexed search by distance. This searches on any retailer location with location data and returns the results sorted by distance.
     * @param latitude The latitude to center the search on
     * @param longitude The longitude to center the search on
     * @param searchRange The search range in the distanceUnit specified; default is MILES.
     * @param start The start index for pagination
     * @param limit The limit for pagination
     * @param accountId The account id of the user (optional)
     * @param address Used to return results using this address as the center (optional)
     * @param hasOffers boolean to indicate whether to include retailer locations that have no offers (optional)
     * @param categories Comma separate list of category ids (optional)
     * @param filters Comma separated list of filter ids (optional)
     * @param audiences Comma separated list of audience ids (optional)
     * @param retailerIds Comma separated list of retailer ids (optional)
     * @param retailerLocationIds Comma separated list of retailer location ids (optional)
     * @param tags Does a full-text search on tags (optional)
     * @param locationType Location type filter (optional)
     * @param sortField The field to sort the result set on. Possible values include: DISTANCE, RETAILER_NAME, RETAILER_LOCATION_NAME (optional)
     * @param descending Determines whether the sorted list is in descending or ascending order (optional)
     * @param q This parameter is deprecated. (optional)
     * @param keyword Search by keyword (optional)
     * @param keywordOperator Determines the operator used when there are multiple words in the &#39;keyword&#39; parameter (optional)
     * @param searchExpression Search expression to further refine results (optional)
     * @param distanceUnit Unit of distance (optional)
     * @param returnFavorited (deprecated) return favorited flag (optional)
     * @param returnRetailer Return retailer info (optional)
     * @param returnAssets Return assets (optional)
     * @param returnOffers Return offers (optional)
     * @param returnCategories Return categories (optional)
     * @param returnFilters Return filters (optional)
     * @param returnAudiences Return audiences (optional)
     * @param returnQrCode Return QR code info (optional)
     * @param returnExternalCategoryData Return external category data (optional)
     * @param includeFavorite Include favorites in response (optional)
     * @param includeLiked Include liked flag in response (optional)
     * @param includeRating Include rating info in response (optional)
     * @return ApiResponse<kotlin.collections.List<RetailerLocationResponse>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun indexedRetailerLocationDistanceSearchWithHttpInfo(latitude: kotlin.Double, longitude: kotlin.Double, searchRange: kotlin.Double, start: kotlin.Int, limit: kotlin.Int, accountId: kotlin.Long?, address: kotlin.String?, hasOffers: kotlin.Boolean?, categories: kotlin.String?, filters: kotlin.String?, audiences: kotlin.String?, retailerIds: kotlin.String?, retailerLocationIds: kotlin.String?, tags: kotlin.String?, locationType: kotlin.String?, sortField: kotlin.String?, descending: kotlin.Boolean?, q: kotlin.String?, keyword: kotlin.String?, keywordOperator: kotlin.String?, searchExpression: kotlin.String?, distanceUnit: DistanceUnitIndexedRetailerLocationDistanceSearch?, returnFavorited: kotlin.Boolean?, returnRetailer: kotlin.Boolean?, returnAssets: kotlin.Boolean?, returnOffers: kotlin.Boolean?, returnCategories: kotlin.Boolean?, returnFilters: kotlin.Boolean?, returnAudiences: kotlin.Boolean?, returnQrCode: kotlin.Boolean?, returnExternalCategoryData: kotlin.Boolean?, includeFavorite: kotlin.Boolean?, includeLiked: kotlin.Boolean?, includeRating: kotlin.Boolean?) : ApiResponse<kotlin.collections.List<RetailerLocationResponse>?> {
        val localVariableConfig = indexedRetailerLocationDistanceSearchRequestConfig(latitude = latitude, longitude = longitude, searchRange = searchRange, start = start, limit = limit, accountId = accountId, address = address, hasOffers = hasOffers, categories = categories, filters = filters, audiences = audiences, retailerIds = retailerIds, retailerLocationIds = retailerLocationIds, tags = tags, locationType = locationType, sortField = sortField, descending = descending, q = q, keyword = keyword, keywordOperator = keywordOperator, searchExpression = searchExpression, distanceUnit = distanceUnit, returnFavorited = returnFavorited, returnRetailer = returnRetailer, returnAssets = returnAssets, returnOffers = returnOffers, returnCategories = returnCategories, returnFilters = returnFilters, returnAudiences = returnAudiences, returnQrCode = returnQrCode, returnExternalCategoryData = returnExternalCategoryData, includeFavorite = includeFavorite, includeLiked = includeLiked, includeRating = includeRating)

        return request<Unit, kotlin.collections.List<RetailerLocationResponse>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation indexedRetailerLocationDistanceSearch
     *
     * @param latitude The latitude to center the search on
     * @param longitude The longitude to center the search on
     * @param searchRange The search range in the distanceUnit specified; default is MILES.
     * @param start The start index for pagination
     * @param limit The limit for pagination
     * @param accountId The account id of the user (optional)
     * @param address Used to return results using this address as the center (optional)
     * @param hasOffers boolean to indicate whether to include retailer locations that have no offers (optional)
     * @param categories Comma separate list of category ids (optional)
     * @param filters Comma separated list of filter ids (optional)
     * @param audiences Comma separated list of audience ids (optional)
     * @param retailerIds Comma separated list of retailer ids (optional)
     * @param retailerLocationIds Comma separated list of retailer location ids (optional)
     * @param tags Does a full-text search on tags (optional)
     * @param locationType Location type filter (optional)
     * @param sortField The field to sort the result set on. Possible values include: DISTANCE, RETAILER_NAME, RETAILER_LOCATION_NAME (optional)
     * @param descending Determines whether the sorted list is in descending or ascending order (optional)
     * @param q This parameter is deprecated. (optional)
     * @param keyword Search by keyword (optional)
     * @param keywordOperator Determines the operator used when there are multiple words in the &#39;keyword&#39; parameter (optional)
     * @param searchExpression Search expression to further refine results (optional)
     * @param distanceUnit Unit of distance (optional)
     * @param returnFavorited (deprecated) return favorited flag (optional)
     * @param returnRetailer Return retailer info (optional)
     * @param returnAssets Return assets (optional)
     * @param returnOffers Return offers (optional)
     * @param returnCategories Return categories (optional)
     * @param returnFilters Return filters (optional)
     * @param returnAudiences Return audiences (optional)
     * @param returnQrCode Return QR code info (optional)
     * @param returnExternalCategoryData Return external category data (optional)
     * @param includeFavorite Include favorites in response (optional)
     * @param includeLiked Include liked flag in response (optional)
     * @param includeRating Include rating info in response (optional)
     * @return RequestConfig
     */
    fun indexedRetailerLocationDistanceSearchRequestConfig(latitude: kotlin.Double, longitude: kotlin.Double, searchRange: kotlin.Double, start: kotlin.Int, limit: kotlin.Int, accountId: kotlin.Long?, address: kotlin.String?, hasOffers: kotlin.Boolean?, categories: kotlin.String?, filters: kotlin.String?, audiences: kotlin.String?, retailerIds: kotlin.String?, retailerLocationIds: kotlin.String?, tags: kotlin.String?, locationType: kotlin.String?, sortField: kotlin.String?, descending: kotlin.Boolean?, q: kotlin.String?, keyword: kotlin.String?, keywordOperator: kotlin.String?, searchExpression: kotlin.String?, distanceUnit: DistanceUnitIndexedRetailerLocationDistanceSearch?, returnFavorited: kotlin.Boolean?, returnRetailer: kotlin.Boolean?, returnAssets: kotlin.Boolean?, returnOffers: kotlin.Boolean?, returnCategories: kotlin.Boolean?, returnFilters: kotlin.Boolean?, returnAudiences: kotlin.Boolean?, returnQrCode: kotlin.Boolean?, returnExternalCategoryData: kotlin.Boolean?, includeFavorite: kotlin.Boolean?, includeLiked: kotlin.Boolean?, includeRating: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("latitude", listOf(latitude.toString()))
                put("longitude", listOf(longitude.toString()))
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (address != null) {
                    put("address", listOf(address.toString()))
                }
                put("searchRange", listOf(searchRange.toString()))
                put("start", listOf(start.toString()))
                put("limit", listOf(limit.toString()))
                if (hasOffers != null) {
                    put("hasOffers", listOf(hasOffers.toString()))
                }
                if (categories != null) {
                    put("categories", listOf(categories.toString()))
                }
                if (filters != null) {
                    put("filters", listOf(filters.toString()))
                }
                if (audiences != null) {
                    put("audiences", listOf(audiences.toString()))
                }
                if (retailerIds != null) {
                    put("retailerIds", listOf(retailerIds.toString()))
                }
                if (retailerLocationIds != null) {
                    put("retailerLocationIds", listOf(retailerLocationIds.toString()))
                }
                if (tags != null) {
                    put("tags", listOf(tags.toString()))
                }
                if (locationType != null) {
                    put("locationType", listOf(locationType.toString()))
                }
                if (sortField != null) {
                    put("sortField", listOf(sortField.toString()))
                }
                if (descending != null) {
                    put("descending", listOf(descending.toString()))
                }
                if (q != null) {
                    put("q", listOf(q.toString()))
                }
                if (keyword != null) {
                    put("keyword", listOf(keyword.toString()))
                }
                if (keywordOperator != null) {
                    put("keywordOperator", listOf(keywordOperator.toString()))
                }
                if (searchExpression != null) {
                    put("searchExpression", listOf(searchExpression.toString()))
                }
                if (distanceUnit != null) {
                    put("distanceUnit", listOf(distanceUnit.value))
                }
                if (returnFavorited != null) {
                    put("returnFavorited", listOf(returnFavorited.toString()))
                }
                if (returnRetailer != null) {
                    put("returnRetailer", listOf(returnRetailer.toString()))
                }
                if (returnAssets != null) {
                    put("returnAssets", listOf(returnAssets.toString()))
                }
                if (returnOffers != null) {
                    put("returnOffers", listOf(returnOffers.toString()))
                }
                if (returnCategories != null) {
                    put("returnCategories", listOf(returnCategories.toString()))
                }
                if (returnFilters != null) {
                    put("returnFilters", listOf(returnFilters.toString()))
                }
                if (returnAudiences != null) {
                    put("returnAudiences", listOf(returnAudiences.toString()))
                }
                if (returnQrCode != null) {
                    put("returnQrCode", listOf(returnQrCode.toString()))
                }
                if (returnExternalCategoryData != null) {
                    put("returnExternalCategoryData", listOf(returnExternalCategoryData.toString()))
                }
                if (includeFavorite != null) {
                    put("includeFavorite", listOf(includeFavorite.toString()))
                }
                if (includeLiked != null) {
                    put("includeLiked", listOf(includeLiked.toString()))
                }
                if (includeRating != null) {
                    put("includeRating", listOf(includeRating.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/retailer/location/idistancesearch",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /retailer/location/isearch
     * Keyword Search Retailer Locations (Indexed)
     * Retailer location (faster) indexed search. This searches all retailer locations.
     * @param accountId The account id of the user (optional)
     * @param start The start index for pagination (optional)
     * @param limit The limit for pagination (optional)
     * @param hasOffers boolean to indicate whether to include retailer locations that have no offers (optional)
     * @param categories Comma separate list of category ids (optional)
     * @param filters Comma separated list of filter ids (optional)
     * @param audiences Comma separated list of audience ids (optional)
     * @param retailerIds Comma separated list of retailer ids (optional)
     * @param retailerLocationIds Comma separated list of retailer location ids (optional)
     * @param tags Does a full-text search on tags (optional)
     * @param locationType Location type filter (optional)
     * @param sortField The field to sort the result set on. Possible values include: RETAILER_NAME, RETAILER_LOCATION_NAME (optional)
     * @param descending Determines whether the sorted list is in descending or ascending order (optional)
     * @param q This parameter is deprecated. (optional)
     * @param keyword Search by keyword (optional)
     * @param keywordOperator Determines the operator used when there are multiple words in the &#39;keyword&#39; parameter (optional)
     * @param searchExpression Search expression to further refine results (optional)
     * @param returnRetailer Return retailer info (optional)
     * @param returnAssets Return assets (optional)
     * @param returnOffers Return offers (optional)
     * @param returnCategories Return categories (optional)
     * @param returnFilters Return filters (optional)
     * @param returnAudiences Return audiences (optional)
     * @param returnQrCode Return QR code info (optional)
     * @param returnExternalCategoryData Return external category data (optional)
     * @param includeFavorite Include favorites in response (optional)
     * @param includeLiked Include liked flag in response (optional)
     * @param includeRating Include rating info in response (optional)
     * @return kotlin.collections.List<RetailerLocationResponse>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun indexedRetailerLocationSearch(accountId: kotlin.Long? = null, start: kotlin.Int? = null, limit: kotlin.Int? = null, hasOffers: kotlin.Boolean? = null, categories: kotlin.String? = null, filters: kotlin.String? = null, audiences: kotlin.String? = null, retailerIds: kotlin.String? = null, retailerLocationIds: kotlin.String? = null, tags: kotlin.String? = null, locationType: kotlin.String? = null, sortField: kotlin.String? = null, descending: kotlin.Boolean? = null, q: kotlin.String? = null, keyword: kotlin.String? = null, keywordOperator: kotlin.String? = null, searchExpression: kotlin.String? = null, returnRetailer: kotlin.Boolean? = null, returnAssets: kotlin.Boolean? = null, returnOffers: kotlin.Boolean? = null, returnCategories: kotlin.Boolean? = null, returnFilters: kotlin.Boolean? = null, returnAudiences: kotlin.Boolean? = null, returnQrCode: kotlin.Boolean? = null, returnExternalCategoryData: kotlin.Boolean? = null, includeFavorite: kotlin.Boolean? = null, includeLiked: kotlin.Boolean? = null, includeRating: kotlin.Boolean? = null) : kotlin.collections.List<RetailerLocationResponse> {
        val localVarResponse = indexedRetailerLocationSearchWithHttpInfo(accountId = accountId, start = start, limit = limit, hasOffers = hasOffers, categories = categories, filters = filters, audiences = audiences, retailerIds = retailerIds, retailerLocationIds = retailerLocationIds, tags = tags, locationType = locationType, sortField = sortField, descending = descending, q = q, keyword = keyword, keywordOperator = keywordOperator, searchExpression = searchExpression, returnRetailer = returnRetailer, returnAssets = returnAssets, returnOffers = returnOffers, returnCategories = returnCategories, returnFilters = returnFilters, returnAudiences = returnAudiences, returnQrCode = returnQrCode, returnExternalCategoryData = returnExternalCategoryData, includeFavorite = includeFavorite, includeLiked = includeLiked, includeRating = includeRating)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<RetailerLocationResponse>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /retailer/location/isearch
     * Keyword Search Retailer Locations (Indexed)
     * Retailer location (faster) indexed search. This searches all retailer locations.
     * @param accountId The account id of the user (optional)
     * @param start The start index for pagination (optional)
     * @param limit The limit for pagination (optional)
     * @param hasOffers boolean to indicate whether to include retailer locations that have no offers (optional)
     * @param categories Comma separate list of category ids (optional)
     * @param filters Comma separated list of filter ids (optional)
     * @param audiences Comma separated list of audience ids (optional)
     * @param retailerIds Comma separated list of retailer ids (optional)
     * @param retailerLocationIds Comma separated list of retailer location ids (optional)
     * @param tags Does a full-text search on tags (optional)
     * @param locationType Location type filter (optional)
     * @param sortField The field to sort the result set on. Possible values include: RETAILER_NAME, RETAILER_LOCATION_NAME (optional)
     * @param descending Determines whether the sorted list is in descending or ascending order (optional)
     * @param q This parameter is deprecated. (optional)
     * @param keyword Search by keyword (optional)
     * @param keywordOperator Determines the operator used when there are multiple words in the &#39;keyword&#39; parameter (optional)
     * @param searchExpression Search expression to further refine results (optional)
     * @param returnRetailer Return retailer info (optional)
     * @param returnAssets Return assets (optional)
     * @param returnOffers Return offers (optional)
     * @param returnCategories Return categories (optional)
     * @param returnFilters Return filters (optional)
     * @param returnAudiences Return audiences (optional)
     * @param returnQrCode Return QR code info (optional)
     * @param returnExternalCategoryData Return external category data (optional)
     * @param includeFavorite Include favorites in response (optional)
     * @param includeLiked Include liked flag in response (optional)
     * @param includeRating Include rating info in response (optional)
     * @return ApiResponse<kotlin.collections.List<RetailerLocationResponse>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun indexedRetailerLocationSearchWithHttpInfo(accountId: kotlin.Long?, start: kotlin.Int?, limit: kotlin.Int?, hasOffers: kotlin.Boolean?, categories: kotlin.String?, filters: kotlin.String?, audiences: kotlin.String?, retailerIds: kotlin.String?, retailerLocationIds: kotlin.String?, tags: kotlin.String?, locationType: kotlin.String?, sortField: kotlin.String?, descending: kotlin.Boolean?, q: kotlin.String?, keyword: kotlin.String?, keywordOperator: kotlin.String?, searchExpression: kotlin.String?, returnRetailer: kotlin.Boolean?, returnAssets: kotlin.Boolean?, returnOffers: kotlin.Boolean?, returnCategories: kotlin.Boolean?, returnFilters: kotlin.Boolean?, returnAudiences: kotlin.Boolean?, returnQrCode: kotlin.Boolean?, returnExternalCategoryData: kotlin.Boolean?, includeFavorite: kotlin.Boolean?, includeLiked: kotlin.Boolean?, includeRating: kotlin.Boolean?) : ApiResponse<kotlin.collections.List<RetailerLocationResponse>?> {
        val localVariableConfig = indexedRetailerLocationSearchRequestConfig(accountId = accountId, start = start, limit = limit, hasOffers = hasOffers, categories = categories, filters = filters, audiences = audiences, retailerIds = retailerIds, retailerLocationIds = retailerLocationIds, tags = tags, locationType = locationType, sortField = sortField, descending = descending, q = q, keyword = keyword, keywordOperator = keywordOperator, searchExpression = searchExpression, returnRetailer = returnRetailer, returnAssets = returnAssets, returnOffers = returnOffers, returnCategories = returnCategories, returnFilters = returnFilters, returnAudiences = returnAudiences, returnQrCode = returnQrCode, returnExternalCategoryData = returnExternalCategoryData, includeFavorite = includeFavorite, includeLiked = includeLiked, includeRating = includeRating)

        return request<Unit, kotlin.collections.List<RetailerLocationResponse>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation indexedRetailerLocationSearch
     *
     * @param accountId The account id of the user (optional)
     * @param start The start index for pagination (optional)
     * @param limit The limit for pagination (optional)
     * @param hasOffers boolean to indicate whether to include retailer locations that have no offers (optional)
     * @param categories Comma separate list of category ids (optional)
     * @param filters Comma separated list of filter ids (optional)
     * @param audiences Comma separated list of audience ids (optional)
     * @param retailerIds Comma separated list of retailer ids (optional)
     * @param retailerLocationIds Comma separated list of retailer location ids (optional)
     * @param tags Does a full-text search on tags (optional)
     * @param locationType Location type filter (optional)
     * @param sortField The field to sort the result set on. Possible values include: RETAILER_NAME, RETAILER_LOCATION_NAME (optional)
     * @param descending Determines whether the sorted list is in descending or ascending order (optional)
     * @param q This parameter is deprecated. (optional)
     * @param keyword Search by keyword (optional)
     * @param keywordOperator Determines the operator used when there are multiple words in the &#39;keyword&#39; parameter (optional)
     * @param searchExpression Search expression to further refine results (optional)
     * @param returnRetailer Return retailer info (optional)
     * @param returnAssets Return assets (optional)
     * @param returnOffers Return offers (optional)
     * @param returnCategories Return categories (optional)
     * @param returnFilters Return filters (optional)
     * @param returnAudiences Return audiences (optional)
     * @param returnQrCode Return QR code info (optional)
     * @param returnExternalCategoryData Return external category data (optional)
     * @param includeFavorite Include favorites in response (optional)
     * @param includeLiked Include liked flag in response (optional)
     * @param includeRating Include rating info in response (optional)
     * @return RequestConfig
     */
    fun indexedRetailerLocationSearchRequestConfig(accountId: kotlin.Long?, start: kotlin.Int?, limit: kotlin.Int?, hasOffers: kotlin.Boolean?, categories: kotlin.String?, filters: kotlin.String?, audiences: kotlin.String?, retailerIds: kotlin.String?, retailerLocationIds: kotlin.String?, tags: kotlin.String?, locationType: kotlin.String?, sortField: kotlin.String?, descending: kotlin.Boolean?, q: kotlin.String?, keyword: kotlin.String?, keywordOperator: kotlin.String?, searchExpression: kotlin.String?, returnRetailer: kotlin.Boolean?, returnAssets: kotlin.Boolean?, returnOffers: kotlin.Boolean?, returnCategories: kotlin.Boolean?, returnFilters: kotlin.Boolean?, returnAudiences: kotlin.Boolean?, returnQrCode: kotlin.Boolean?, returnExternalCategoryData: kotlin.Boolean?, includeFavorite: kotlin.Boolean?, includeLiked: kotlin.Boolean?, includeRating: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (hasOffers != null) {
                    put("hasOffers", listOf(hasOffers.toString()))
                }
                if (categories != null) {
                    put("categories", listOf(categories.toString()))
                }
                if (filters != null) {
                    put("filters", listOf(filters.toString()))
                }
                if (audiences != null) {
                    put("audiences", listOf(audiences.toString()))
                }
                if (retailerIds != null) {
                    put("retailerIds", listOf(retailerIds.toString()))
                }
                if (retailerLocationIds != null) {
                    put("retailerLocationIds", listOf(retailerLocationIds.toString()))
                }
                if (tags != null) {
                    put("tags", listOf(tags.toString()))
                }
                if (locationType != null) {
                    put("locationType", listOf(locationType.toString()))
                }
                if (sortField != null) {
                    put("sortField", listOf(sortField.toString()))
                }
                if (descending != null) {
                    put("descending", listOf(descending.toString()))
                }
                if (q != null) {
                    put("q", listOf(q.toString()))
                }
                if (keyword != null) {
                    put("keyword", listOf(keyword.toString()))
                }
                if (keywordOperator != null) {
                    put("keywordOperator", listOf(keywordOperator.toString()))
                }
                if (searchExpression != null) {
                    put("searchExpression", listOf(searchExpression.toString()))
                }
                if (returnRetailer != null) {
                    put("returnRetailer", listOf(returnRetailer.toString()))
                }
                if (returnAssets != null) {
                    put("returnAssets", listOf(returnAssets.toString()))
                }
                if (returnOffers != null) {
                    put("returnOffers", listOf(returnOffers.toString()))
                }
                if (returnCategories != null) {
                    put("returnCategories", listOf(returnCategories.toString()))
                }
                if (returnFilters != null) {
                    put("returnFilters", listOf(returnFilters.toString()))
                }
                if (returnAudiences != null) {
                    put("returnAudiences", listOf(returnAudiences.toString()))
                }
                if (returnQrCode != null) {
                    put("returnQrCode", listOf(returnQrCode.toString()))
                }
                if (returnExternalCategoryData != null) {
                    put("returnExternalCategoryData", listOf(returnExternalCategoryData.toString()))
                }
                if (includeFavorite != null) {
                    put("includeFavorite", listOf(includeFavorite.toString()))
                }
                if (includeLiked != null) {
                    put("includeLiked", listOf(includeLiked.toString()))
                }
                if (includeRating != null) {
                    put("includeRating", listOf(includeRating.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/retailer/location/isearch",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter sortField
     */
     enum class SortFieldSearchRetailerLocations(val value: kotlin.String) {
         @Json(name = "ID") ID("ID"),
         @Json(name = "CREATED") CREATED("CREATED"),
         @Json(name = "UPDATED") UPDATED("UPDATED"),
         @Json(name = "DELETED") DELETED("DELETED"),
         @Json(name = "SEARCH_TAGS") SEARCH_TAGS("SEARCH_TAGS"),
         @Json(name = "ACTIVE") ACTIVE("ACTIVE"),
         @Json(name = "RETAILER_ID") RETAILER_ID("RETAILER_ID"),
         @Json(name = "BILLABLE_ENTITY_ID") BILLABLE_ENTITY_ID("BILLABLE_ENTITY_ID"),
         @Json(name = "BILLABLE_ENTITY_NAME") BILLABLE_ENTITY_NAME("BILLABLE_ENTITY_NAME"),
         @Json(name = "RESPONSIBLE_DISPLAY") RESPONSIBLE_DISPLAY("RESPONSIBLE_DISPLAY"),
         @Json(name = "ADDRESS_STREET") ADDRESS_STREET("ADDRESS_STREET"),
         @Json(name = "ADDRESS_CITY") ADDRESS_CITY("ADDRESS_CITY"),
         @Json(name = "ADDRESS_STATE") ADDRESS_STATE("ADDRESS_STATE"),
         @Json(name = "ADDRESS_POSTAL_CODE") ADDRESS_POSTAL_CODE("ADDRESS_POSTAL_CODE"),
         @Json(name = "ADDRESS_COUNTRY") ADDRESS_COUNTRY("ADDRESS_COUNTRY"),
         @Json(name = "NAME") NAME("NAME"),
         @Json(name = "CODE") CODE("CODE");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /retailer/location/search
     * Search Retailer Locations (Owned)
     * Searches on retailer locations that the account has access to.
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param q This parameter is deprecated. (optional)
     * @param keyword The keyword used to search (optional)
     * @param retailerIds Comma separated list of retailer IDs which when passed in will filter the results to only return these retailers. (optional)
     * @param retailerLocationIds Comma separated list of retailer location IDs (optional)
     * @param locationType Location type filter (optional)
     * @param sortField The column to sort the search on (optional)
     * @param descending The order to return the search results (optional)
     * @param i This parameter is deprecated. (optional)
     * @param start The record to begin the return set on (optional)
     * @param l This parameter is deprecated. (optional)
     * @param limit The number of records to return (optional)
     * @param showPublicLocations Whether to include public locations in the results (optional)
     * @param activeOnly Return only active results (optional)
     * @param returnRetailer Return retailer info (optional)
     * @param returnAssets Return assets (optional)
     * @param returnOffers Return offers (optional)
     * @param returnCategories Return categories (optional)
     * @param returnFilters Return filters (optional)
     * @param returnAudiences Return audiences (optional)
     * @param returnQrCode Return QR code info (optional)
     * @param includeFavorite Include favorites in response (optional)
     * @param includeLiked Include liked flag in response (optional)
     * @param includeRating Include rating info in response (optional)
     * @return kotlin.collections.List<RetailerLocationResponse>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun searchRetailerLocations(deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, q: kotlin.String? = null, keyword: kotlin.String? = null, retailerIds: kotlin.String? = null, retailerLocationIds: kotlin.String? = null, locationType: kotlin.String? = null, sortField: SortFieldSearchRetailerLocations? = null, descending: kotlin.Boolean? = null, i: kotlin.Int? = null, start: kotlin.Int? = null, l: kotlin.Int? = null, limit: kotlin.Int? = null, showPublicLocations: kotlin.Boolean? = null, activeOnly: kotlin.Boolean? = null, returnRetailer: kotlin.Boolean? = null, returnAssets: kotlin.Boolean? = null, returnOffers: kotlin.Boolean? = null, returnCategories: kotlin.Boolean? = null, returnFilters: kotlin.Boolean? = null, returnAudiences: kotlin.Boolean? = null, returnQrCode: kotlin.Boolean? = null, includeFavorite: kotlin.Boolean? = null, includeLiked: kotlin.Boolean? = null, includeRating: kotlin.Boolean? = null) : kotlin.collections.List<RetailerLocationResponse> {
        val localVarResponse = searchRetailerLocationsWithHttpInfo(deviceId = deviceId, accountId = accountId, q = q, keyword = keyword, retailerIds = retailerIds, retailerLocationIds = retailerLocationIds, locationType = locationType, sortField = sortField, descending = descending, i = i, start = start, l = l, limit = limit, showPublicLocations = showPublicLocations, activeOnly = activeOnly, returnRetailer = returnRetailer, returnAssets = returnAssets, returnOffers = returnOffers, returnCategories = returnCategories, returnFilters = returnFilters, returnAudiences = returnAudiences, returnQrCode = returnQrCode, includeFavorite = includeFavorite, includeLiked = includeLiked, includeRating = includeRating)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<RetailerLocationResponse>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /retailer/location/search
     * Search Retailer Locations (Owned)
     * Searches on retailer locations that the account has access to.
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param q This parameter is deprecated. (optional)
     * @param keyword The keyword used to search (optional)
     * @param retailerIds Comma separated list of retailer IDs which when passed in will filter the results to only return these retailers. (optional)
     * @param retailerLocationIds Comma separated list of retailer location IDs (optional)
     * @param locationType Location type filter (optional)
     * @param sortField The column to sort the search on (optional)
     * @param descending The order to return the search results (optional)
     * @param i This parameter is deprecated. (optional)
     * @param start The record to begin the return set on (optional)
     * @param l This parameter is deprecated. (optional)
     * @param limit The number of records to return (optional)
     * @param showPublicLocations Whether to include public locations in the results (optional)
     * @param activeOnly Return only active results (optional)
     * @param returnRetailer Return retailer info (optional)
     * @param returnAssets Return assets (optional)
     * @param returnOffers Return offers (optional)
     * @param returnCategories Return categories (optional)
     * @param returnFilters Return filters (optional)
     * @param returnAudiences Return audiences (optional)
     * @param returnQrCode Return QR code info (optional)
     * @param includeFavorite Include favorites in response (optional)
     * @param includeLiked Include liked flag in response (optional)
     * @param includeRating Include rating info in response (optional)
     * @return ApiResponse<kotlin.collections.List<RetailerLocationResponse>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun searchRetailerLocationsWithHttpInfo(deviceId: kotlin.String?, accountId: kotlin.Long?, q: kotlin.String?, keyword: kotlin.String?, retailerIds: kotlin.String?, retailerLocationIds: kotlin.String?, locationType: kotlin.String?, sortField: SortFieldSearchRetailerLocations?, descending: kotlin.Boolean?, i: kotlin.Int?, start: kotlin.Int?, l: kotlin.Int?, limit: kotlin.Int?, showPublicLocations: kotlin.Boolean?, activeOnly: kotlin.Boolean?, returnRetailer: kotlin.Boolean?, returnAssets: kotlin.Boolean?, returnOffers: kotlin.Boolean?, returnCategories: kotlin.Boolean?, returnFilters: kotlin.Boolean?, returnAudiences: kotlin.Boolean?, returnQrCode: kotlin.Boolean?, includeFavorite: kotlin.Boolean?, includeLiked: kotlin.Boolean?, includeRating: kotlin.Boolean?) : ApiResponse<kotlin.collections.List<RetailerLocationResponse>?> {
        val localVariableConfig = searchRetailerLocationsRequestConfig(deviceId = deviceId, accountId = accountId, q = q, keyword = keyword, retailerIds = retailerIds, retailerLocationIds = retailerLocationIds, locationType = locationType, sortField = sortField, descending = descending, i = i, start = start, l = l, limit = limit, showPublicLocations = showPublicLocations, activeOnly = activeOnly, returnRetailer = returnRetailer, returnAssets = returnAssets, returnOffers = returnOffers, returnCategories = returnCategories, returnFilters = returnFilters, returnAudiences = returnAudiences, returnQrCode = returnQrCode, includeFavorite = includeFavorite, includeLiked = includeLiked, includeRating = includeRating)

        return request<Unit, kotlin.collections.List<RetailerLocationResponse>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation searchRetailerLocations
     *
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param q This parameter is deprecated. (optional)
     * @param keyword The keyword used to search (optional)
     * @param retailerIds Comma separated list of retailer IDs which when passed in will filter the results to only return these retailers. (optional)
     * @param retailerLocationIds Comma separated list of retailer location IDs (optional)
     * @param locationType Location type filter (optional)
     * @param sortField The column to sort the search on (optional)
     * @param descending The order to return the search results (optional)
     * @param i This parameter is deprecated. (optional)
     * @param start The record to begin the return set on (optional)
     * @param l This parameter is deprecated. (optional)
     * @param limit The number of records to return (optional)
     * @param showPublicLocations Whether to include public locations in the results (optional)
     * @param activeOnly Return only active results (optional)
     * @param returnRetailer Return retailer info (optional)
     * @param returnAssets Return assets (optional)
     * @param returnOffers Return offers (optional)
     * @param returnCategories Return categories (optional)
     * @param returnFilters Return filters (optional)
     * @param returnAudiences Return audiences (optional)
     * @param returnQrCode Return QR code info (optional)
     * @param includeFavorite Include favorites in response (optional)
     * @param includeLiked Include liked flag in response (optional)
     * @param includeRating Include rating info in response (optional)
     * @return RequestConfig
     */
    fun searchRetailerLocationsRequestConfig(deviceId: kotlin.String?, accountId: kotlin.Long?, q: kotlin.String?, keyword: kotlin.String?, retailerIds: kotlin.String?, retailerLocationIds: kotlin.String?, locationType: kotlin.String?, sortField: SortFieldSearchRetailerLocations?, descending: kotlin.Boolean?, i: kotlin.Int?, start: kotlin.Int?, l: kotlin.Int?, limit: kotlin.Int?, showPublicLocations: kotlin.Boolean?, activeOnly: kotlin.Boolean?, returnRetailer: kotlin.Boolean?, returnAssets: kotlin.Boolean?, returnOffers: kotlin.Boolean?, returnCategories: kotlin.Boolean?, returnFilters: kotlin.Boolean?, returnAudiences: kotlin.Boolean?, returnQrCode: kotlin.Boolean?, includeFavorite: kotlin.Boolean?, includeLiked: kotlin.Boolean?, includeRating: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (q != null) {
                    put("q", listOf(q.toString()))
                }
                if (keyword != null) {
                    put("keyword", listOf(keyword.toString()))
                }
                if (retailerIds != null) {
                    put("retailerIds", listOf(retailerIds.toString()))
                }
                if (retailerLocationIds != null) {
                    put("retailerLocationIds", listOf(retailerLocationIds.toString()))
                }
                if (locationType != null) {
                    put("locationType", listOf(locationType.toString()))
                }
                if (sortField != null) {
                    put("sortField", listOf(sortField.value))
                }
                if (descending != null) {
                    put("descending", listOf(descending.toString()))
                }
                if (i != null) {
                    put("_i", listOf(i.toString()))
                }
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (l != null) {
                    put("_l", listOf(l.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (showPublicLocations != null) {
                    put("showPublicLocations", listOf(showPublicLocations.toString()))
                }
                if (activeOnly != null) {
                    put("activeOnly", listOf(activeOnly.toString()))
                }
                if (returnRetailer != null) {
                    put("returnRetailer", listOf(returnRetailer.toString()))
                }
                if (returnAssets != null) {
                    put("returnAssets", listOf(returnAssets.toString()))
                }
                if (returnOffers != null) {
                    put("returnOffers", listOf(returnOffers.toString()))
                }
                if (returnCategories != null) {
                    put("returnCategories", listOf(returnCategories.toString()))
                }
                if (returnFilters != null) {
                    put("returnFilters", listOf(returnFilters.toString()))
                }
                if (returnAudiences != null) {
                    put("returnAudiences", listOf(returnAudiences.toString()))
                }
                if (returnQrCode != null) {
                    put("returnQrCode", listOf(returnQrCode.toString()))
                }
                if (includeFavorite != null) {
                    put("includeFavorite", listOf(includeFavorite.toString()))
                }
                if (includeLiked != null) {
                    put("includeLiked", listOf(includeLiked.toString()))
                }
                if (includeRating != null) {
                    put("includeRating", listOf(includeRating.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/retailer/location/search",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter responseFormat
     */
     enum class ResponseFormatUpdateRetailerLocations(val value: kotlin.String) {
         @Json(name = "HTML") HTML("HTML"),
         @Json(name = "XML") XML("XML"),
         @Json(name = "JSON") JSON("JSON"),
         @Json(name = "CSV") CSV("CSV");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * POST /retailer/location/update
     * Update Retailer Location
     * Updates a location record for a retailer. Only the owner and the employees of the retailer have access to do this.
     * @param retailerLocationId The ID of the retailer location
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param name The name of the retailer location (optional)
     * @param streetAddress The street address of the retailer location (optional)
     * @param streetAddress2 Additional address information (such as a suite number, floor number, building name, or PO Box) (optional)
     * @param city The city of the retailer location (optional)
     * @param state The state of the retailer location (optional)
     * @param postalCode The postal code of the retailer location (optional)
     * @param country the country of the retailer location (optional)
     * @param businessPhone The business phone number of the retailer location (optional)
     * @param businessPhoneExt The business phone extension of the retailer location (optional)
     * @param website The website of the retailer location (optional)
     * @param email The email of the retailer location (optional)
     * @param internalId An internal identifier used by the retailer (optional)
     * @param detailsHeader A brief description about the retailer location (255 character limit) (optional)
     * @param detailsBody A detailed description about the retailer location (optional)
     * @param hours The hours of operation (optional)
     * @param logo The retailer location logo sent as a multipart binary file (you can optionally use logoAssetId if the asset has already been uploaded before) (optional)
     * @param logoAssetId The retailer location logo asset id (optional)
     * @param picture1 Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture1AssetId if the asset has already been uploaded before) (optional)
     * @param picture1AssetId An asset id (optional)
     * @param picture2 Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture2AssetId if the asset has already been uploaded before) (optional)
     * @param picture2AssetId An asset id (optional)
     * @param categoryIds Comma separated list of category IDs used to filter retailer locations by categories (optional)
     * @param filterIds Comma separated list of filter IDs used to filter retailer locations (optional)
     * @param latitude the latituede of the retailer location (optional)
     * @param longitude the longitude of the retailer location (optional)
     * @param building  (optional)
     * @param googlePlaceId the Google Place ID that the retailer location is associated with (optional)
     * @param yelpId the Yelp ID that the retailer location is associated with (optional)
     * @param metaData External custom client defined data (optional)
     * @param paymentProvider Specifies which payment provider Sirqul will use when making payments (optional)
     * @param active Sets whether the retailer is active or inactive (hidden from consumers) (optional)
     * @param publicLocation Sets whether the location is public or not (optional)
     * @param locationType External custom type identifier (optional)
     * @param audienceIds Comma separated list of audience IDs used to assign audiences to the retailer location (optional)
     * @param audienceIdsToAdd Comma separated list of audience IDs to add to the retailer location (optional)
     * @param audienceIdsToRemove Comma separated list of audience IDs to remove from the retailer location (optional)
     * @param responseFormat The format of the returned response {JSON // default , HTML // for Dojo support when uploading assets} (optional)
     * @param tags Custom string field for doing full-text searches (optional)
     * @return RetailerLocationResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updateRetailerLocations(retailerLocationId: kotlin.Long, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, name: kotlin.String? = null, streetAddress: kotlin.String? = null, streetAddress2: kotlin.String? = null, city: kotlin.String? = null, state: kotlin.String? = null, postalCode: kotlin.String? = null, country: kotlin.String? = null, businessPhone: kotlin.String? = null, businessPhoneExt: kotlin.String? = null, website: kotlin.String? = null, email: kotlin.String? = null, internalId: kotlin.String? = null, detailsHeader: kotlin.String? = null, detailsBody: kotlin.String? = null, hours: kotlin.String? = null, logo: java.io.File? = null, logoAssetId: kotlin.Long? = null, picture1: java.io.File? = null, picture1AssetId: kotlin.Long? = null, picture2: java.io.File? = null, picture2AssetId: kotlin.Long? = null, categoryIds: kotlin.String? = null, filterIds: kotlin.String? = null, latitude: kotlin.Double? = null, longitude: kotlin.Double? = null, building: kotlin.String? = null, googlePlaceId: kotlin.String? = null, yelpId: kotlin.String? = null, metaData: kotlin.String? = null, paymentProvider: kotlin.String? = null, active: kotlin.Boolean? = null, publicLocation: kotlin.Boolean? = null, locationType: kotlin.String? = null, audienceIds: kotlin.String? = null, audienceIdsToAdd: kotlin.String? = null, audienceIdsToRemove: kotlin.String? = null, responseFormat: ResponseFormatUpdateRetailerLocations? = null, tags: kotlin.String? = null) : RetailerLocationResponse {
        val localVarResponse = updateRetailerLocationsWithHttpInfo(retailerLocationId = retailerLocationId, deviceId = deviceId, accountId = accountId, name = name, streetAddress = streetAddress, streetAddress2 = streetAddress2, city = city, state = state, postalCode = postalCode, country = country, businessPhone = businessPhone, businessPhoneExt = businessPhoneExt, website = website, email = email, internalId = internalId, detailsHeader = detailsHeader, detailsBody = detailsBody, hours = hours, logo = logo, logoAssetId = logoAssetId, picture1 = picture1, picture1AssetId = picture1AssetId, picture2 = picture2, picture2AssetId = picture2AssetId, categoryIds = categoryIds, filterIds = filterIds, latitude = latitude, longitude = longitude, building = building, googlePlaceId = googlePlaceId, yelpId = yelpId, metaData = metaData, paymentProvider = paymentProvider, active = active, publicLocation = publicLocation, locationType = locationType, audienceIds = audienceIds, audienceIdsToAdd = audienceIdsToAdd, audienceIdsToRemove = audienceIdsToRemove, responseFormat = responseFormat, tags = tags)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RetailerLocationResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /retailer/location/update
     * Update Retailer Location
     * Updates a location record for a retailer. Only the owner and the employees of the retailer have access to do this.
     * @param retailerLocationId The ID of the retailer location
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param name The name of the retailer location (optional)
     * @param streetAddress The street address of the retailer location (optional)
     * @param streetAddress2 Additional address information (such as a suite number, floor number, building name, or PO Box) (optional)
     * @param city The city of the retailer location (optional)
     * @param state The state of the retailer location (optional)
     * @param postalCode The postal code of the retailer location (optional)
     * @param country the country of the retailer location (optional)
     * @param businessPhone The business phone number of the retailer location (optional)
     * @param businessPhoneExt The business phone extension of the retailer location (optional)
     * @param website The website of the retailer location (optional)
     * @param email The email of the retailer location (optional)
     * @param internalId An internal identifier used by the retailer (optional)
     * @param detailsHeader A brief description about the retailer location (255 character limit) (optional)
     * @param detailsBody A detailed description about the retailer location (optional)
     * @param hours The hours of operation (optional)
     * @param logo The retailer location logo sent as a multipart binary file (you can optionally use logoAssetId if the asset has already been uploaded before) (optional)
     * @param logoAssetId The retailer location logo asset id (optional)
     * @param picture1 Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture1AssetId if the asset has already been uploaded before) (optional)
     * @param picture1AssetId An asset id (optional)
     * @param picture2 Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture2AssetId if the asset has already been uploaded before) (optional)
     * @param picture2AssetId An asset id (optional)
     * @param categoryIds Comma separated list of category IDs used to filter retailer locations by categories (optional)
     * @param filterIds Comma separated list of filter IDs used to filter retailer locations (optional)
     * @param latitude the latituede of the retailer location (optional)
     * @param longitude the longitude of the retailer location (optional)
     * @param building  (optional)
     * @param googlePlaceId the Google Place ID that the retailer location is associated with (optional)
     * @param yelpId the Yelp ID that the retailer location is associated with (optional)
     * @param metaData External custom client defined data (optional)
     * @param paymentProvider Specifies which payment provider Sirqul will use when making payments (optional)
     * @param active Sets whether the retailer is active or inactive (hidden from consumers) (optional)
     * @param publicLocation Sets whether the location is public or not (optional)
     * @param locationType External custom type identifier (optional)
     * @param audienceIds Comma separated list of audience IDs used to assign audiences to the retailer location (optional)
     * @param audienceIdsToAdd Comma separated list of audience IDs to add to the retailer location (optional)
     * @param audienceIdsToRemove Comma separated list of audience IDs to remove from the retailer location (optional)
     * @param responseFormat The format of the returned response {JSON // default , HTML // for Dojo support when uploading assets} (optional)
     * @param tags Custom string field for doing full-text searches (optional)
     * @return ApiResponse<RetailerLocationResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun updateRetailerLocationsWithHttpInfo(retailerLocationId: kotlin.Long, deviceId: kotlin.String?, accountId: kotlin.Long?, name: kotlin.String?, streetAddress: kotlin.String?, streetAddress2: kotlin.String?, city: kotlin.String?, state: kotlin.String?, postalCode: kotlin.String?, country: kotlin.String?, businessPhone: kotlin.String?, businessPhoneExt: kotlin.String?, website: kotlin.String?, email: kotlin.String?, internalId: kotlin.String?, detailsHeader: kotlin.String?, detailsBody: kotlin.String?, hours: kotlin.String?, logo: java.io.File?, logoAssetId: kotlin.Long?, picture1: java.io.File?, picture1AssetId: kotlin.Long?, picture2: java.io.File?, picture2AssetId: kotlin.Long?, categoryIds: kotlin.String?, filterIds: kotlin.String?, latitude: kotlin.Double?, longitude: kotlin.Double?, building: kotlin.String?, googlePlaceId: kotlin.String?, yelpId: kotlin.String?, metaData: kotlin.String?, paymentProvider: kotlin.String?, active: kotlin.Boolean?, publicLocation: kotlin.Boolean?, locationType: kotlin.String?, audienceIds: kotlin.String?, audienceIdsToAdd: kotlin.String?, audienceIdsToRemove: kotlin.String?, responseFormat: ResponseFormatUpdateRetailerLocations?, tags: kotlin.String?) : ApiResponse<RetailerLocationResponse?> {
        val localVariableConfig = updateRetailerLocationsRequestConfig(retailerLocationId = retailerLocationId, deviceId = deviceId, accountId = accountId, name = name, streetAddress = streetAddress, streetAddress2 = streetAddress2, city = city, state = state, postalCode = postalCode, country = country, businessPhone = businessPhone, businessPhoneExt = businessPhoneExt, website = website, email = email, internalId = internalId, detailsHeader = detailsHeader, detailsBody = detailsBody, hours = hours, logo = logo, logoAssetId = logoAssetId, picture1 = picture1, picture1AssetId = picture1AssetId, picture2 = picture2, picture2AssetId = picture2AssetId, categoryIds = categoryIds, filterIds = filterIds, latitude = latitude, longitude = longitude, building = building, googlePlaceId = googlePlaceId, yelpId = yelpId, metaData = metaData, paymentProvider = paymentProvider, active = active, publicLocation = publicLocation, locationType = locationType, audienceIds = audienceIds, audienceIdsToAdd = audienceIdsToAdd, audienceIdsToRemove = audienceIdsToRemove, responseFormat = responseFormat, tags = tags)

        return request<Unit, RetailerLocationResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateRetailerLocations
     *
     * @param retailerLocationId The ID of the retailer location
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param name The name of the retailer location (optional)
     * @param streetAddress The street address of the retailer location (optional)
     * @param streetAddress2 Additional address information (such as a suite number, floor number, building name, or PO Box) (optional)
     * @param city The city of the retailer location (optional)
     * @param state The state of the retailer location (optional)
     * @param postalCode The postal code of the retailer location (optional)
     * @param country the country of the retailer location (optional)
     * @param businessPhone The business phone number of the retailer location (optional)
     * @param businessPhoneExt The business phone extension of the retailer location (optional)
     * @param website The website of the retailer location (optional)
     * @param email The email of the retailer location (optional)
     * @param internalId An internal identifier used by the retailer (optional)
     * @param detailsHeader A brief description about the retailer location (255 character limit) (optional)
     * @param detailsBody A detailed description about the retailer location (optional)
     * @param hours The hours of operation (optional)
     * @param logo The retailer location logo sent as a multipart binary file (you can optionally use logoAssetId if the asset has already been uploaded before) (optional)
     * @param logoAssetId The retailer location logo asset id (optional)
     * @param picture1 Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture1AssetId if the asset has already been uploaded before) (optional)
     * @param picture1AssetId An asset id (optional)
     * @param picture2 Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture2AssetId if the asset has already been uploaded before) (optional)
     * @param picture2AssetId An asset id (optional)
     * @param categoryIds Comma separated list of category IDs used to filter retailer locations by categories (optional)
     * @param filterIds Comma separated list of filter IDs used to filter retailer locations (optional)
     * @param latitude the latituede of the retailer location (optional)
     * @param longitude the longitude of the retailer location (optional)
     * @param building  (optional)
     * @param googlePlaceId the Google Place ID that the retailer location is associated with (optional)
     * @param yelpId the Yelp ID that the retailer location is associated with (optional)
     * @param metaData External custom client defined data (optional)
     * @param paymentProvider Specifies which payment provider Sirqul will use when making payments (optional)
     * @param active Sets whether the retailer is active or inactive (hidden from consumers) (optional)
     * @param publicLocation Sets whether the location is public or not (optional)
     * @param locationType External custom type identifier (optional)
     * @param audienceIds Comma separated list of audience IDs used to assign audiences to the retailer location (optional)
     * @param audienceIdsToAdd Comma separated list of audience IDs to add to the retailer location (optional)
     * @param audienceIdsToRemove Comma separated list of audience IDs to remove from the retailer location (optional)
     * @param responseFormat The format of the returned response {JSON // default , HTML // for Dojo support when uploading assets} (optional)
     * @param tags Custom string field for doing full-text searches (optional)
     * @return RequestConfig
     */
    fun updateRetailerLocationsRequestConfig(retailerLocationId: kotlin.Long, deviceId: kotlin.String?, accountId: kotlin.Long?, name: kotlin.String?, streetAddress: kotlin.String?, streetAddress2: kotlin.String?, city: kotlin.String?, state: kotlin.String?, postalCode: kotlin.String?, country: kotlin.String?, businessPhone: kotlin.String?, businessPhoneExt: kotlin.String?, website: kotlin.String?, email: kotlin.String?, internalId: kotlin.String?, detailsHeader: kotlin.String?, detailsBody: kotlin.String?, hours: kotlin.String?, logo: java.io.File?, logoAssetId: kotlin.Long?, picture1: java.io.File?, picture1AssetId: kotlin.Long?, picture2: java.io.File?, picture2AssetId: kotlin.Long?, categoryIds: kotlin.String?, filterIds: kotlin.String?, latitude: kotlin.Double?, longitude: kotlin.Double?, building: kotlin.String?, googlePlaceId: kotlin.String?, yelpId: kotlin.String?, metaData: kotlin.String?, paymentProvider: kotlin.String?, active: kotlin.Boolean?, publicLocation: kotlin.Boolean?, locationType: kotlin.String?, audienceIds: kotlin.String?, audienceIdsToAdd: kotlin.String?, audienceIdsToRemove: kotlin.String?, responseFormat: ResponseFormatUpdateRetailerLocations?, tags: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                put("retailerLocationId", listOf(retailerLocationId.toString()))
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (streetAddress != null) {
                    put("streetAddress", listOf(streetAddress.toString()))
                }
                if (streetAddress2 != null) {
                    put("streetAddress2", listOf(streetAddress2.toString()))
                }
                if (city != null) {
                    put("city", listOf(city.toString()))
                }
                if (state != null) {
                    put("state", listOf(state.toString()))
                }
                if (postalCode != null) {
                    put("postalCode", listOf(postalCode.toString()))
                }
                if (country != null) {
                    put("country", listOf(country.toString()))
                }
                if (businessPhone != null) {
                    put("businessPhone", listOf(businessPhone.toString()))
                }
                if (businessPhoneExt != null) {
                    put("businessPhoneExt", listOf(businessPhoneExt.toString()))
                }
                if (website != null) {
                    put("website", listOf(website.toString()))
                }
                if (email != null) {
                    put("email", listOf(email.toString()))
                }
                if (internalId != null) {
                    put("internalId", listOf(internalId.toString()))
                }
                if (detailsHeader != null) {
                    put("detailsHeader", listOf(detailsHeader.toString()))
                }
                if (detailsBody != null) {
                    put("detailsBody", listOf(detailsBody.toString()))
                }
                if (hours != null) {
                    put("hours", listOf(hours.toString()))
                }
                if (logo != null) {
                    put("logo", listOf(logo.toString()))
                }
                if (logoAssetId != null) {
                    put("logoAssetId", listOf(logoAssetId.toString()))
                }
                if (picture1 != null) {
                    put("picture1", listOf(picture1.toString()))
                }
                if (picture1AssetId != null) {
                    put("picture1AssetId", listOf(picture1AssetId.toString()))
                }
                if (picture2 != null) {
                    put("picture2", listOf(picture2.toString()))
                }
                if (picture2AssetId != null) {
                    put("picture2AssetId", listOf(picture2AssetId.toString()))
                }
                if (categoryIds != null) {
                    put("categoryIds", listOf(categoryIds.toString()))
                }
                if (filterIds != null) {
                    put("filterIds", listOf(filterIds.toString()))
                }
                if (latitude != null) {
                    put("latitude", listOf(latitude.toString()))
                }
                if (longitude != null) {
                    put("longitude", listOf(longitude.toString()))
                }
                if (building != null) {
                    put("building", listOf(building.toString()))
                }
                if (googlePlaceId != null) {
                    put("googlePlaceId", listOf(googlePlaceId.toString()))
                }
                if (yelpId != null) {
                    put("yelpId", listOf(yelpId.toString()))
                }
                if (metaData != null) {
                    put("metaData", listOf(metaData.toString()))
                }
                if (paymentProvider != null) {
                    put("paymentProvider", listOf(paymentProvider.toString()))
                }
                if (active != null) {
                    put("active", listOf(active.toString()))
                }
                if (publicLocation != null) {
                    put("publicLocation", listOf(publicLocation.toString()))
                }
                if (locationType != null) {
                    put("locationType", listOf(locationType.toString()))
                }
                if (audienceIds != null) {
                    put("audienceIds", listOf(audienceIds.toString()))
                }
                if (audienceIdsToAdd != null) {
                    put("audienceIdsToAdd", listOf(audienceIdsToAdd.toString()))
                }
                if (audienceIdsToRemove != null) {
                    put("audienceIdsToRemove", listOf(audienceIdsToRemove.toString()))
                }
                if (responseFormat != null) {
                    put("responseFormat", listOf(responseFormat.value))
                }
                if (tags != null) {
                    put("tags", listOf(tags.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/retailer/location/update",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
