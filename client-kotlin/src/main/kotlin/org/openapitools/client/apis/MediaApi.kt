/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import org.openapitools.client.models.MediaOfferResponse
import org.openapitools.client.models.SirqulResponse

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

open class MediaApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://dev.sirqul.com/api/3.18")
        }
    }

    /**
     * enum for parameter barcodeType
     */
     enum class BarcodeTypeCreateMedia(val value: kotlin.String) {
         @Json(name = "NONE") NONE("NONE"),
         @Json(name = "UPC") UPC("UPC"),
         @Json(name = "CODE_128") CODE_128("CODE_128"),
         @Json(name = "QR") QR("QR"),
         @Json(name = "CUSTOM_MEDIA") CUSTOM_MEDIA("CUSTOM_MEDIA");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter specialOfferType
     */
     enum class SpecialOfferTypeCreateMedia(val value: kotlin.String) {
         @Json(name = "ALL") ALL("ALL"),
         @Json(name = "RESERVABLE") RESERVABLE("RESERVABLE"),
         @Json(name = "REGULAR_OFFER") REGULAR_OFFER("REGULAR_OFFER"),
         @Json(name = "ACT_NOW") ACT_NOW("ACT_NOW"),
         @Json(name = "GET_THERE_NOW") GET_THERE_NOW("GET_THERE_NOW"),
         @Json(name = "SQOOT") SQOOT("SQOOT"),
         @Json(name = "TICKETS") TICKETS("TICKETS"),
         @Json(name = "YIPIT") YIPIT("YIPIT");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter offerVisibility
     */
     enum class OfferVisibilityCreateMedia(val value: kotlin.String) {
         @Json(name = "PUBLIC") PUBLIC("PUBLIC"),
         @Json(name = "LISTABLE") LISTABLE("LISTABLE"),
         @Json(name = "REWARDABLE") REWARDABLE("REWARDABLE"),
         @Json(name = "TRIGGERABLE") TRIGGERABLE("TRIGGERABLE"),
         @Json(name = "PRIVATE") PRIVATE("PRIVATE");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter conditionType
     */
     enum class ConditionTypeCreateMedia(val value: kotlin.String) {
         @Json(name = "NEW") NEW("NEW"),
         @Json(name = "USED") USED("USED"),
         @Json(name = "REFURBISHED") REFURBISHED("REFURBISHED"),
         @Json(name = "OTHER") OTHER("OTHER");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter mediaType
     */
     enum class MediaTypeCreateMedia(val value: kotlin.String) {
         @Json(name = "APK") APK("APK"),
         @Json(name = "APPLICATION") APPLICATION("APPLICATION"),
         @Json(name = "IMAGE") IMAGE("IMAGE"),
         @Json(name = "AUDIO") AUDIO("AUDIO"),
         @Json(name = "VIDEO") VIDEO("VIDEO"),
         @Json(name = "MULTIPART") MULTIPART("MULTIPART"),
         @Json(name = "BAR_CODE") BAR_CODE("BAR_CODE"),
         @Json(name = "TEXT") TEXT("TEXT"),
         @Json(name = "OTHER") OTHER("OTHER");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * POST /media/create
     * Create Media
     * Create a media offering.
     * @param accountId The account id of the logged in user
     * @param title The title (255 char limit)
     * @param barcodeType The bar code type {NONE, UPC, CODE_128, QR, CUSTOM_MEDIA}
     * @param noExpiration Overrides the expiration date so that the offer does not expire
     * @param availableLimit The limit of how many times the offer can be used by consumers
     * @param availableLimitPerUser The limit of how many times a user can used the same offer
     * @param addedLimit The limit of how many times the offer can be added to consumer wallets
     * @param viewLimit The limit of how many times the offer can be viewed
     * @param maxPrints The maximum number of times the offer can be printed
     * @param ticketPrice The cost of the offer in tickets
     * @param fullPrice The retail/full price cost of the offer in real currency
     * @param discountPrice The cost of the offer at a discounted price (what the consumer pays)
     * @param specialOfferType The special offer type {ALL, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW}
     * @param offerVisibility The offer visibility {PUBLIC, REWARDABLE, TRIGGERABLE}
     * @param active Sets the active flag
     * @param retailerLocationIds Comma separated list of retailer location ids. This will assign the offer to these retailer locations. (optional)
     * @param subTitle The sub title (255 char limit) (optional)
     * @param details The details of the media (optional)
     * @param subDetails A string for custom details (255 char limit) (optional)
     * @param finePrint The fine print of the media (optional)
     * @param barcodeEntry The bar code entry string (optional)
     * @param externalRedeemOptions An external identifier. What the identifier will be used for and how it is formatted is up to the frontend developer (optional)
     * @param externalUrl The clickUrl of the offer (optional)
     * @param ticketsRewardType The type of ticket to reward, null means default type (optional)
     * @param ticketsReward Determines how many tickets are awarded (optional)
     * @param activated The date of when the offer will be visible to consumers (optional)
     * @param expires The date of when the offer expires (optional)
     * @param ticketPriceType the type of ticket needed to buy offer (optional)
     * @param showRemaining show how many of the media is remaining (if there is a limit) (optional)
     * @param showRedeemed show how many of the media has been redeemed (optional)
     * @param replaced if the media has been replaced (optional)
     * @param featured if the media should be featured or not (optional)
     * @param categoryIds Comma separated list of category ids (optional)
     * @param filterIds Comma separated list of filter ids (optional)
     * @param barcodeAssetId The id of the barcode asset (optional)
     * @param imageAssetId The id of the an offer asset (optional)
     * @param imageAssetId1 The id of the an offer asset (optional)
     * @param imageAssetId2 The id of the an offer asset (optional)
     * @param imageAssetId3 The id of the an offer asset (optional)
     * @param imageAssetId4 The id of the an offer asset (optional)
     * @param imageAssetId5 The id of the an offer asset (optional)
     * @param publisher The maker of the item. (optional)
     * @param redeemableStart The redeemable start date/time of the offer. (optional)
     * @param redeemableEnd The redeemable start date/time of the offer. (optional)
     * @param conditionType The condition type of the media (optional)
     * @param isbn The ISBN id (optional)
     * @param asin The ASIN id (optional)
     * @param catalogNumbers The list of catelog numbers, comma seperated (optional)
     * @param parentalRating The parental control rating (optional)
     * @param availabilityDate The date the media is available to use (optional)
     * @param mediaType the media type (optional)
     * @param duration The total playing time of the media item (optional)
     * @param author The created/author of the media item (optional)
     * @param releaseDate The date/time of when the media item was originally released (optional)
     * @param collectionIds the IDs of the collections this media should be assigned to (optional)
     * @param availability ability to assign if this media should active or not (optional)
     * @param availabilitySummary ability to assign when the media expires (optional)
     * @return MediaOfferResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createMedia(accountId: kotlin.Long, title: kotlin.String, barcodeType: BarcodeTypeCreateMedia, noExpiration: kotlin.Boolean, availableLimit: kotlin.Int, availableLimitPerUser: kotlin.Int, addedLimit: kotlin.Int, viewLimit: kotlin.Int, maxPrints: kotlin.Int, ticketPrice: kotlin.Long, fullPrice: kotlin.Double, discountPrice: kotlin.Double, specialOfferType: SpecialOfferTypeCreateMedia, offerVisibility: OfferVisibilityCreateMedia, active: kotlin.Boolean, retailerLocationIds: kotlin.String? = null, subTitle: kotlin.String? = null, details: kotlin.String? = null, subDetails: kotlin.String? = null, finePrint: kotlin.String? = null, barcodeEntry: kotlin.String? = null, externalRedeemOptions: kotlin.String? = null, externalUrl: kotlin.String? = null, ticketsRewardType: kotlin.String? = null, ticketsReward: kotlin.Long? = null, activated: kotlin.Long? = null, expires: kotlin.Long? = null, ticketPriceType: kotlin.String? = null, showRemaining: kotlin.Boolean? = null, showRedeemed: kotlin.Boolean? = null, replaced: kotlin.Boolean? = null, featured: kotlin.Boolean? = null, categoryIds: kotlin.String? = null, filterIds: kotlin.String? = null, barcodeAssetId: kotlin.Long? = null, imageAssetId: kotlin.Long? = null, imageAssetId1: kotlin.Long? = null, imageAssetId2: kotlin.Long? = null, imageAssetId3: kotlin.Long? = null, imageAssetId4: kotlin.Long? = null, imageAssetId5: kotlin.Long? = null, publisher: kotlin.String? = null, redeemableStart: kotlin.Long? = null, redeemableEnd: kotlin.Long? = null, conditionType: ConditionTypeCreateMedia? = null, isbn: kotlin.String? = null, asin: kotlin.String? = null, catalogNumbers: kotlin.String? = null, parentalRating: kotlin.String? = null, availabilityDate: kotlin.Long? = null, mediaType: MediaTypeCreateMedia? = null, duration: kotlin.Int? = null, author: kotlin.String? = null, releaseDate: kotlin.Long? = null, collectionIds: kotlin.String? = null, availability: kotlin.String? = null, availabilitySummary: kotlin.String? = null) : MediaOfferResponse {
        val localVarResponse = createMediaWithHttpInfo(accountId = accountId, title = title, barcodeType = barcodeType, noExpiration = noExpiration, availableLimit = availableLimit, availableLimitPerUser = availableLimitPerUser, addedLimit = addedLimit, viewLimit = viewLimit, maxPrints = maxPrints, ticketPrice = ticketPrice, fullPrice = fullPrice, discountPrice = discountPrice, specialOfferType = specialOfferType, offerVisibility = offerVisibility, active = active, retailerLocationIds = retailerLocationIds, subTitle = subTitle, details = details, subDetails = subDetails, finePrint = finePrint, barcodeEntry = barcodeEntry, externalRedeemOptions = externalRedeemOptions, externalUrl = externalUrl, ticketsRewardType = ticketsRewardType, ticketsReward = ticketsReward, activated = activated, expires = expires, ticketPriceType = ticketPriceType, showRemaining = showRemaining, showRedeemed = showRedeemed, replaced = replaced, featured = featured, categoryIds = categoryIds, filterIds = filterIds, barcodeAssetId = barcodeAssetId, imageAssetId = imageAssetId, imageAssetId1 = imageAssetId1, imageAssetId2 = imageAssetId2, imageAssetId3 = imageAssetId3, imageAssetId4 = imageAssetId4, imageAssetId5 = imageAssetId5, publisher = publisher, redeemableStart = redeemableStart, redeemableEnd = redeemableEnd, conditionType = conditionType, isbn = isbn, asin = asin, catalogNumbers = catalogNumbers, parentalRating = parentalRating, availabilityDate = availabilityDate, mediaType = mediaType, duration = duration, author = author, releaseDate = releaseDate, collectionIds = collectionIds, availability = availability, availabilitySummary = availabilitySummary)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MediaOfferResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /media/create
     * Create Media
     * Create a media offering.
     * @param accountId The account id of the logged in user
     * @param title The title (255 char limit)
     * @param barcodeType The bar code type {NONE, UPC, CODE_128, QR, CUSTOM_MEDIA}
     * @param noExpiration Overrides the expiration date so that the offer does not expire
     * @param availableLimit The limit of how many times the offer can be used by consumers
     * @param availableLimitPerUser The limit of how many times a user can used the same offer
     * @param addedLimit The limit of how many times the offer can be added to consumer wallets
     * @param viewLimit The limit of how many times the offer can be viewed
     * @param maxPrints The maximum number of times the offer can be printed
     * @param ticketPrice The cost of the offer in tickets
     * @param fullPrice The retail/full price cost of the offer in real currency
     * @param discountPrice The cost of the offer at a discounted price (what the consumer pays)
     * @param specialOfferType The special offer type {ALL, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW}
     * @param offerVisibility The offer visibility {PUBLIC, REWARDABLE, TRIGGERABLE}
     * @param active Sets the active flag
     * @param retailerLocationIds Comma separated list of retailer location ids. This will assign the offer to these retailer locations. (optional)
     * @param subTitle The sub title (255 char limit) (optional)
     * @param details The details of the media (optional)
     * @param subDetails A string for custom details (255 char limit) (optional)
     * @param finePrint The fine print of the media (optional)
     * @param barcodeEntry The bar code entry string (optional)
     * @param externalRedeemOptions An external identifier. What the identifier will be used for and how it is formatted is up to the frontend developer (optional)
     * @param externalUrl The clickUrl of the offer (optional)
     * @param ticketsRewardType The type of ticket to reward, null means default type (optional)
     * @param ticketsReward Determines how many tickets are awarded (optional)
     * @param activated The date of when the offer will be visible to consumers (optional)
     * @param expires The date of when the offer expires (optional)
     * @param ticketPriceType the type of ticket needed to buy offer (optional)
     * @param showRemaining show how many of the media is remaining (if there is a limit) (optional)
     * @param showRedeemed show how many of the media has been redeemed (optional)
     * @param replaced if the media has been replaced (optional)
     * @param featured if the media should be featured or not (optional)
     * @param categoryIds Comma separated list of category ids (optional)
     * @param filterIds Comma separated list of filter ids (optional)
     * @param barcodeAssetId The id of the barcode asset (optional)
     * @param imageAssetId The id of the an offer asset (optional)
     * @param imageAssetId1 The id of the an offer asset (optional)
     * @param imageAssetId2 The id of the an offer asset (optional)
     * @param imageAssetId3 The id of the an offer asset (optional)
     * @param imageAssetId4 The id of the an offer asset (optional)
     * @param imageAssetId5 The id of the an offer asset (optional)
     * @param publisher The maker of the item. (optional)
     * @param redeemableStart The redeemable start date/time of the offer. (optional)
     * @param redeemableEnd The redeemable start date/time of the offer. (optional)
     * @param conditionType The condition type of the media (optional)
     * @param isbn The ISBN id (optional)
     * @param asin The ASIN id (optional)
     * @param catalogNumbers The list of catelog numbers, comma seperated (optional)
     * @param parentalRating The parental control rating (optional)
     * @param availabilityDate The date the media is available to use (optional)
     * @param mediaType the media type (optional)
     * @param duration The total playing time of the media item (optional)
     * @param author The created/author of the media item (optional)
     * @param releaseDate The date/time of when the media item was originally released (optional)
     * @param collectionIds the IDs of the collections this media should be assigned to (optional)
     * @param availability ability to assign if this media should active or not (optional)
     * @param availabilitySummary ability to assign when the media expires (optional)
     * @return ApiResponse<MediaOfferResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createMediaWithHttpInfo(accountId: kotlin.Long, title: kotlin.String, barcodeType: BarcodeTypeCreateMedia, noExpiration: kotlin.Boolean, availableLimit: kotlin.Int, availableLimitPerUser: kotlin.Int, addedLimit: kotlin.Int, viewLimit: kotlin.Int, maxPrints: kotlin.Int, ticketPrice: kotlin.Long, fullPrice: kotlin.Double, discountPrice: kotlin.Double, specialOfferType: SpecialOfferTypeCreateMedia, offerVisibility: OfferVisibilityCreateMedia, active: kotlin.Boolean, retailerLocationIds: kotlin.String?, subTitle: kotlin.String?, details: kotlin.String?, subDetails: kotlin.String?, finePrint: kotlin.String?, barcodeEntry: kotlin.String?, externalRedeemOptions: kotlin.String?, externalUrl: kotlin.String?, ticketsRewardType: kotlin.String?, ticketsReward: kotlin.Long?, activated: kotlin.Long?, expires: kotlin.Long?, ticketPriceType: kotlin.String?, showRemaining: kotlin.Boolean?, showRedeemed: kotlin.Boolean?, replaced: kotlin.Boolean?, featured: kotlin.Boolean?, categoryIds: kotlin.String?, filterIds: kotlin.String?, barcodeAssetId: kotlin.Long?, imageAssetId: kotlin.Long?, imageAssetId1: kotlin.Long?, imageAssetId2: kotlin.Long?, imageAssetId3: kotlin.Long?, imageAssetId4: kotlin.Long?, imageAssetId5: kotlin.Long?, publisher: kotlin.String?, redeemableStart: kotlin.Long?, redeemableEnd: kotlin.Long?, conditionType: ConditionTypeCreateMedia?, isbn: kotlin.String?, asin: kotlin.String?, catalogNumbers: kotlin.String?, parentalRating: kotlin.String?, availabilityDate: kotlin.Long?, mediaType: MediaTypeCreateMedia?, duration: kotlin.Int?, author: kotlin.String?, releaseDate: kotlin.Long?, collectionIds: kotlin.String?, availability: kotlin.String?, availabilitySummary: kotlin.String?) : ApiResponse<MediaOfferResponse?> {
        val localVariableConfig = createMediaRequestConfig(accountId = accountId, title = title, barcodeType = barcodeType, noExpiration = noExpiration, availableLimit = availableLimit, availableLimitPerUser = availableLimitPerUser, addedLimit = addedLimit, viewLimit = viewLimit, maxPrints = maxPrints, ticketPrice = ticketPrice, fullPrice = fullPrice, discountPrice = discountPrice, specialOfferType = specialOfferType, offerVisibility = offerVisibility, active = active, retailerLocationIds = retailerLocationIds, subTitle = subTitle, details = details, subDetails = subDetails, finePrint = finePrint, barcodeEntry = barcodeEntry, externalRedeemOptions = externalRedeemOptions, externalUrl = externalUrl, ticketsRewardType = ticketsRewardType, ticketsReward = ticketsReward, activated = activated, expires = expires, ticketPriceType = ticketPriceType, showRemaining = showRemaining, showRedeemed = showRedeemed, replaced = replaced, featured = featured, categoryIds = categoryIds, filterIds = filterIds, barcodeAssetId = barcodeAssetId, imageAssetId = imageAssetId, imageAssetId1 = imageAssetId1, imageAssetId2 = imageAssetId2, imageAssetId3 = imageAssetId3, imageAssetId4 = imageAssetId4, imageAssetId5 = imageAssetId5, publisher = publisher, redeemableStart = redeemableStart, redeemableEnd = redeemableEnd, conditionType = conditionType, isbn = isbn, asin = asin, catalogNumbers = catalogNumbers, parentalRating = parentalRating, availabilityDate = availabilityDate, mediaType = mediaType, duration = duration, author = author, releaseDate = releaseDate, collectionIds = collectionIds, availability = availability, availabilitySummary = availabilitySummary)

        return request<Unit, MediaOfferResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createMedia
     *
     * @param accountId The account id of the logged in user
     * @param title The title (255 char limit)
     * @param barcodeType The bar code type {NONE, UPC, CODE_128, QR, CUSTOM_MEDIA}
     * @param noExpiration Overrides the expiration date so that the offer does not expire
     * @param availableLimit The limit of how many times the offer can be used by consumers
     * @param availableLimitPerUser The limit of how many times a user can used the same offer
     * @param addedLimit The limit of how many times the offer can be added to consumer wallets
     * @param viewLimit The limit of how many times the offer can be viewed
     * @param maxPrints The maximum number of times the offer can be printed
     * @param ticketPrice The cost of the offer in tickets
     * @param fullPrice The retail/full price cost of the offer in real currency
     * @param discountPrice The cost of the offer at a discounted price (what the consumer pays)
     * @param specialOfferType The special offer type {ALL, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW}
     * @param offerVisibility The offer visibility {PUBLIC, REWARDABLE, TRIGGERABLE}
     * @param active Sets the active flag
     * @param retailerLocationIds Comma separated list of retailer location ids. This will assign the offer to these retailer locations. (optional)
     * @param subTitle The sub title (255 char limit) (optional)
     * @param details The details of the media (optional)
     * @param subDetails A string for custom details (255 char limit) (optional)
     * @param finePrint The fine print of the media (optional)
     * @param barcodeEntry The bar code entry string (optional)
     * @param externalRedeemOptions An external identifier. What the identifier will be used for and how it is formatted is up to the frontend developer (optional)
     * @param externalUrl The clickUrl of the offer (optional)
     * @param ticketsRewardType The type of ticket to reward, null means default type (optional)
     * @param ticketsReward Determines how many tickets are awarded (optional)
     * @param activated The date of when the offer will be visible to consumers (optional)
     * @param expires The date of when the offer expires (optional)
     * @param ticketPriceType the type of ticket needed to buy offer (optional)
     * @param showRemaining show how many of the media is remaining (if there is a limit) (optional)
     * @param showRedeemed show how many of the media has been redeemed (optional)
     * @param replaced if the media has been replaced (optional)
     * @param featured if the media should be featured or not (optional)
     * @param categoryIds Comma separated list of category ids (optional)
     * @param filterIds Comma separated list of filter ids (optional)
     * @param barcodeAssetId The id of the barcode asset (optional)
     * @param imageAssetId The id of the an offer asset (optional)
     * @param imageAssetId1 The id of the an offer asset (optional)
     * @param imageAssetId2 The id of the an offer asset (optional)
     * @param imageAssetId3 The id of the an offer asset (optional)
     * @param imageAssetId4 The id of the an offer asset (optional)
     * @param imageAssetId5 The id of the an offer asset (optional)
     * @param publisher The maker of the item. (optional)
     * @param redeemableStart The redeemable start date/time of the offer. (optional)
     * @param redeemableEnd The redeemable start date/time of the offer. (optional)
     * @param conditionType The condition type of the media (optional)
     * @param isbn The ISBN id (optional)
     * @param asin The ASIN id (optional)
     * @param catalogNumbers The list of catelog numbers, comma seperated (optional)
     * @param parentalRating The parental control rating (optional)
     * @param availabilityDate The date the media is available to use (optional)
     * @param mediaType the media type (optional)
     * @param duration The total playing time of the media item (optional)
     * @param author The created/author of the media item (optional)
     * @param releaseDate The date/time of when the media item was originally released (optional)
     * @param collectionIds the IDs of the collections this media should be assigned to (optional)
     * @param availability ability to assign if this media should active or not (optional)
     * @param availabilitySummary ability to assign when the media expires (optional)
     * @return RequestConfig
     */
    fun createMediaRequestConfig(accountId: kotlin.Long, title: kotlin.String, barcodeType: BarcodeTypeCreateMedia, noExpiration: kotlin.Boolean, availableLimit: kotlin.Int, availableLimitPerUser: kotlin.Int, addedLimit: kotlin.Int, viewLimit: kotlin.Int, maxPrints: kotlin.Int, ticketPrice: kotlin.Long, fullPrice: kotlin.Double, discountPrice: kotlin.Double, specialOfferType: SpecialOfferTypeCreateMedia, offerVisibility: OfferVisibilityCreateMedia, active: kotlin.Boolean, retailerLocationIds: kotlin.String?, subTitle: kotlin.String?, details: kotlin.String?, subDetails: kotlin.String?, finePrint: kotlin.String?, barcodeEntry: kotlin.String?, externalRedeemOptions: kotlin.String?, externalUrl: kotlin.String?, ticketsRewardType: kotlin.String?, ticketsReward: kotlin.Long?, activated: kotlin.Long?, expires: kotlin.Long?, ticketPriceType: kotlin.String?, showRemaining: kotlin.Boolean?, showRedeemed: kotlin.Boolean?, replaced: kotlin.Boolean?, featured: kotlin.Boolean?, categoryIds: kotlin.String?, filterIds: kotlin.String?, barcodeAssetId: kotlin.Long?, imageAssetId: kotlin.Long?, imageAssetId1: kotlin.Long?, imageAssetId2: kotlin.Long?, imageAssetId3: kotlin.Long?, imageAssetId4: kotlin.Long?, imageAssetId5: kotlin.Long?, publisher: kotlin.String?, redeemableStart: kotlin.Long?, redeemableEnd: kotlin.Long?, conditionType: ConditionTypeCreateMedia?, isbn: kotlin.String?, asin: kotlin.String?, catalogNumbers: kotlin.String?, parentalRating: kotlin.String?, availabilityDate: kotlin.Long?, mediaType: MediaTypeCreateMedia?, duration: kotlin.Int?, author: kotlin.String?, releaseDate: kotlin.Long?, collectionIds: kotlin.String?, availability: kotlin.String?, availabilitySummary: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                if (retailerLocationIds != null) {
                    put("retailerLocationIds", listOf(retailerLocationIds.toString()))
                }
                put("title", listOf(title.toString()))
                if (subTitle != null) {
                    put("subTitle", listOf(subTitle.toString()))
                }
                if (details != null) {
                    put("details", listOf(details.toString()))
                }
                if (subDetails != null) {
                    put("subDetails", listOf(subDetails.toString()))
                }
                if (finePrint != null) {
                    put("finePrint", listOf(finePrint.toString()))
                }
                put("barcodeType", listOf(barcodeType.value))
                if (barcodeEntry != null) {
                    put("barcodeEntry", listOf(barcodeEntry.toString()))
                }
                if (externalRedeemOptions != null) {
                    put("externalRedeemOptions", listOf(externalRedeemOptions.toString()))
                }
                if (externalUrl != null) {
                    put("externalUrl", listOf(externalUrl.toString()))
                }
                if (ticketsRewardType != null) {
                    put("ticketsRewardType", listOf(ticketsRewardType.toString()))
                }
                if (ticketsReward != null) {
                    put("ticketsReward", listOf(ticketsReward.toString()))
                }
                if (activated != null) {
                    put("activated", listOf(activated.toString()))
                }
                if (expires != null) {
                    put("expires", listOf(expires.toString()))
                }
                put("noExpiration", listOf(noExpiration.toString()))
                put("availableLimit", listOf(availableLimit.toString()))
                put("availableLimitPerUser", listOf(availableLimitPerUser.toString()))
                put("addedLimit", listOf(addedLimit.toString()))
                put("viewLimit", listOf(viewLimit.toString()))
                put("maxPrints", listOf(maxPrints.toString()))
                if (ticketPriceType != null) {
                    put("ticketPriceType", listOf(ticketPriceType.toString()))
                }
                put("ticketPrice", listOf(ticketPrice.toString()))
                put("fullPrice", listOf(fullPrice.toString()))
                put("discountPrice", listOf(discountPrice.toString()))
                if (showRemaining != null) {
                    put("showRemaining", listOf(showRemaining.toString()))
                }
                if (showRedeemed != null) {
                    put("showRedeemed", listOf(showRedeemed.toString()))
                }
                if (replaced != null) {
                    put("replaced", listOf(replaced.toString()))
                }
                if (featured != null) {
                    put("featured", listOf(featured.toString()))
                }
                put("specialOfferType", listOf(specialOfferType.value))
                put("offerVisibility", listOf(offerVisibility.value))
                if (categoryIds != null) {
                    put("categoryIds", listOf(categoryIds.toString()))
                }
                if (filterIds != null) {
                    put("filterIds", listOf(filterIds.toString()))
                }
                put("active", listOf(active.toString()))
                if (barcodeAssetId != null) {
                    put("barcodeAssetId", listOf(barcodeAssetId.toString()))
                }
                if (imageAssetId != null) {
                    put("imageAssetId", listOf(imageAssetId.toString()))
                }
                if (imageAssetId1 != null) {
                    put("imageAssetId1", listOf(imageAssetId1.toString()))
                }
                if (imageAssetId2 != null) {
                    put("imageAssetId2", listOf(imageAssetId2.toString()))
                }
                if (imageAssetId3 != null) {
                    put("imageAssetId3", listOf(imageAssetId3.toString()))
                }
                if (imageAssetId4 != null) {
                    put("imageAssetId4", listOf(imageAssetId4.toString()))
                }
                if (imageAssetId5 != null) {
                    put("imageAssetId5", listOf(imageAssetId5.toString()))
                }
                if (publisher != null) {
                    put("publisher", listOf(publisher.toString()))
                }
                if (redeemableStart != null) {
                    put("redeemableStart", listOf(redeemableStart.toString()))
                }
                if (redeemableEnd != null) {
                    put("redeemableEnd", listOf(redeemableEnd.toString()))
                }
                if (conditionType != null) {
                    put("conditionType", listOf(conditionType.value))
                }
                if (isbn != null) {
                    put("isbn", listOf(isbn.toString()))
                }
                if (asin != null) {
                    put("asin", listOf(asin.toString()))
                }
                if (catalogNumbers != null) {
                    put("catalogNumbers", listOf(catalogNumbers.toString()))
                }
                if (parentalRating != null) {
                    put("parentalRating", listOf(parentalRating.toString()))
                }
                if (availabilityDate != null) {
                    put("availabilityDate", listOf(availabilityDate.toString()))
                }
                if (mediaType != null) {
                    put("mediaType", listOf(mediaType.value))
                }
                if (duration != null) {
                    put("duration", listOf(duration.toString()))
                }
                if (author != null) {
                    put("author", listOf(author.toString()))
                }
                if (releaseDate != null) {
                    put("releaseDate", listOf(releaseDate.toString()))
                }
                if (collectionIds != null) {
                    put("collectionIds", listOf(collectionIds.toString()))
                }
                if (availability != null) {
                    put("availability", listOf(availability.toString()))
                }
                if (availabilitySummary != null) {
                    put("availabilitySummary", listOf(availabilitySummary.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/media/create",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /media/delete
     * Delete Media
     * Delete a media offering that the user has permissions to.
     * @param accountId the id of the logged in user
     * @param mediaId the ID of the media to delete
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteMedia(accountId: kotlin.Long, mediaId: kotlin.Long) : SirqulResponse {
        val localVarResponse = deleteMediaWithHttpInfo(accountId = accountId, mediaId = mediaId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /media/delete
     * Delete Media
     * Delete a media offering that the user has permissions to.
     * @param accountId the id of the logged in user
     * @param mediaId the ID of the media to delete
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteMediaWithHttpInfo(accountId: kotlin.Long, mediaId: kotlin.Long) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = deleteMediaRequestConfig(accountId = accountId, mediaId = mediaId)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteMedia
     *
     * @param accountId the id of the logged in user
     * @param mediaId the ID of the media to delete
     * @return RequestConfig
     */
    fun deleteMediaRequestConfig(accountId: kotlin.Long, mediaId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("mediaId", listOf(mediaId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/media/delete",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /media/get
     * Media Get
     * Get a media offering.
     * @param accountId the id of the logged in user
     * @param mediaId the id of the media to get
     * @return MediaOfferResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getMedia(accountId: kotlin.Long, mediaId: kotlin.Long) : MediaOfferResponse {
        val localVarResponse = getMediaWithHttpInfo(accountId = accountId, mediaId = mediaId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MediaOfferResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /media/get
     * Media Get
     * Get a media offering.
     * @param accountId the id of the logged in user
     * @param mediaId the id of the media to get
     * @return ApiResponse<MediaOfferResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getMediaWithHttpInfo(accountId: kotlin.Long, mediaId: kotlin.Long) : ApiResponse<MediaOfferResponse?> {
        val localVariableConfig = getMediaRequestConfig(accountId = accountId, mediaId = mediaId)

        return request<Unit, MediaOfferResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getMedia
     *
     * @param accountId the id of the logged in user
     * @param mediaId the id of the media to get
     * @return RequestConfig
     */
    fun getMediaRequestConfig(accountId: kotlin.Long, mediaId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("mediaId", listOf(mediaId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/media/get",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter sortField
     */
     enum class SortFieldSearchMedia(val value: kotlin.String) {
         @Json(name = "ID") ID("ID"),
         @Json(name = "CREATED") CREATED("CREATED"),
         @Json(name = "UPDATED") UPDATED("UPDATED"),
         @Json(name = "DELETED") DELETED("DELETED"),
         @Json(name = "SEARCH_TAGS") SEARCH_TAGS("SEARCH_TAGS"),
         @Json(name = "ACTIVE") ACTIVE("ACTIVE"),
         @Json(name = "ACTIVATED") ACTIVATED("ACTIVATED"),
         @Json(name = "EXPIRES") EXPIRES("EXPIRES"),
         @Json(name = "REDEEMABLE_START") REDEEMABLE_START("REDEEMABLE_START"),
         @Json(name = "REDEEMABLE_END") REDEEMABLE_END("REDEEMABLE_END"),
         @Json(name = "TITLE") TITLE("TITLE"),
         @Json(name = "SUBTITLE") SUBTITLE("SUBTITLE"),
         @Json(name = "DETAILS") DETAILS("DETAILS"),
         @Json(name = "OFFER_TYPE") OFFER_TYPE("OFFER_TYPE"),
         @Json(name = "SPECIAL_OFFER_TYPE") SPECIAL_OFFER_TYPE("SPECIAL_OFFER_TYPE"),
         @Json(name = "OFFER_VISIBILITY") OFFER_VISIBILITY("OFFER_VISIBILITY"),
         @Json(name = "ESTIMATED_VALUE") ESTIMATED_VALUE("ESTIMATED_VALUE"),
         @Json(name = "VOUCHER_PRICE") VOUCHER_PRICE("VOUCHER_PRICE"),
         @Json(name = "VOUCHER_DISCOUNT_PRICE") VOUCHER_DISCOUNT_PRICE("VOUCHER_DISCOUNT_PRICE"),
         @Json(name = "FULL_PRICE") FULL_PRICE("FULL_PRICE"),
         @Json(name = "DICOUNT_PRICE") DICOUNT_PRICE("DICOUNT_PRICE"),
         @Json(name = "TICKETS_REWARD") TICKETS_REWARD("TICKETS_REWARD"),
         @Json(name = "AVAILABILITY_DATE") AVAILABILITY_DATE("AVAILABILITY_DATE"),
         @Json(name = "RELEASE_DATE") RELEASE_DATE("RELEASE_DATE"),
         @Json(name = "RETAILER_ID") RETAILER_ID("RETAILER_ID"),
         @Json(name = "RETAILER_NAME") RETAILER_NAME("RETAILER_NAME"),
         @Json(name = "RETAILER_LOCATION_ID") RETAILER_LOCATION_ID("RETAILER_LOCATION_ID"),
         @Json(name = "RETAILER_LOCATION_NAME") RETAILER_LOCATION_NAME("RETAILER_LOCATION_NAME"),
         @Json(name = "BILLABLE_ENTITY_ID") BILLABLE_ENTITY_ID("BILLABLE_ENTITY_ID"),
         @Json(name = "BILLABLE_ENTITY_NAME") BILLABLE_ENTITY_NAME("BILLABLE_ENTITY_NAME"),
         @Json(name = "RESPONSIBLE_DISPLAY") RESPONSIBLE_DISPLAY("RESPONSIBLE_DISPLAY");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /media/search
     * Search Media
     * Searches on events that the account has access to.
     * @param accountId The logged in user.
     * @param activeOnly Return only active results
     * @param sortField The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, DETAILS, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, ESTIMATED_VALUE, VOUCHER_PRICE, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY, AVAILABILITY_DATE, RELEASE_DATE
     * @param descending The order to return the search results
     * @param keyword The keyword used to search (optional)
     * @param categoryIds  (optional)
     * @param filterIds  (optional)
     * @param start The record to begin the return set on (optional)
     * @param limit The number of records to return (optional)
     * @return kotlin.collections.List<MediaOfferResponse>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun searchMedia(accountId: kotlin.Long, activeOnly: kotlin.Boolean, sortField: SortFieldSearchMedia, descending: kotlin.Boolean, keyword: kotlin.String? = null, categoryIds: kotlin.String? = null, filterIds: kotlin.String? = null, start: kotlin.Int? = null, limit: kotlin.Int? = null) : kotlin.collections.List<MediaOfferResponse> {
        val localVarResponse = searchMediaWithHttpInfo(accountId = accountId, activeOnly = activeOnly, sortField = sortField, descending = descending, keyword = keyword, categoryIds = categoryIds, filterIds = filterIds, start = start, limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<MediaOfferResponse>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /media/search
     * Search Media
     * Searches on events that the account has access to.
     * @param accountId The logged in user.
     * @param activeOnly Return only active results
     * @param sortField The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, DETAILS, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, ESTIMATED_VALUE, VOUCHER_PRICE, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY, AVAILABILITY_DATE, RELEASE_DATE
     * @param descending The order to return the search results
     * @param keyword The keyword used to search (optional)
     * @param categoryIds  (optional)
     * @param filterIds  (optional)
     * @param start The record to begin the return set on (optional)
     * @param limit The number of records to return (optional)
     * @return ApiResponse<kotlin.collections.List<MediaOfferResponse>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun searchMediaWithHttpInfo(accountId: kotlin.Long, activeOnly: kotlin.Boolean, sortField: SortFieldSearchMedia, descending: kotlin.Boolean, keyword: kotlin.String?, categoryIds: kotlin.String?, filterIds: kotlin.String?, start: kotlin.Int?, limit: kotlin.Int?) : ApiResponse<kotlin.collections.List<MediaOfferResponse>?> {
        val localVariableConfig = searchMediaRequestConfig(accountId = accountId, activeOnly = activeOnly, sortField = sortField, descending = descending, keyword = keyword, categoryIds = categoryIds, filterIds = filterIds, start = start, limit = limit)

        return request<Unit, kotlin.collections.List<MediaOfferResponse>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation searchMedia
     *
     * @param accountId The logged in user.
     * @param activeOnly Return only active results
     * @param sortField The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, DETAILS, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, ESTIMATED_VALUE, VOUCHER_PRICE, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY, AVAILABILITY_DATE, RELEASE_DATE
     * @param descending The order to return the search results
     * @param keyword The keyword used to search (optional)
     * @param categoryIds  (optional)
     * @param filterIds  (optional)
     * @param start The record to begin the return set on (optional)
     * @param limit The number of records to return (optional)
     * @return RequestConfig
     */
    fun searchMediaRequestConfig(accountId: kotlin.Long, activeOnly: kotlin.Boolean, sortField: SortFieldSearchMedia, descending: kotlin.Boolean, keyword: kotlin.String?, categoryIds: kotlin.String?, filterIds: kotlin.String?, start: kotlin.Int?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                if (keyword != null) {
                    put("keyword", listOf(keyword.toString()))
                }
                put("activeOnly", listOf(activeOnly.toString()))
                if (categoryIds != null) {
                    put("categoryIds", listOf(categoryIds.toString()))
                }
                if (filterIds != null) {
                    put("filterIds", listOf(filterIds.toString()))
                }
                put("sortField", listOf(sortField.value))
                put("descending", listOf(descending.toString()))
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/media/search",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter barcodeType
     */
     enum class BarcodeTypeUpdateMedia(val value: kotlin.String) {
         @Json(name = "NONE") NONE("NONE"),
         @Json(name = "UPC") UPC("UPC"),
         @Json(name = "CODE_128") CODE_128("CODE_128"),
         @Json(name = "QR") QR("QR"),
         @Json(name = "CUSTOM_MEDIA") CUSTOM_MEDIA("CUSTOM_MEDIA");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter specialOfferType
     */
     enum class SpecialOfferTypeUpdateMedia(val value: kotlin.String) {
         @Json(name = "ALL") ALL("ALL"),
         @Json(name = "RESERVABLE") RESERVABLE("RESERVABLE"),
         @Json(name = "REGULAR_OFFER") REGULAR_OFFER("REGULAR_OFFER"),
         @Json(name = "ACT_NOW") ACT_NOW("ACT_NOW"),
         @Json(name = "GET_THERE_NOW") GET_THERE_NOW("GET_THERE_NOW"),
         @Json(name = "SQOOT") SQOOT("SQOOT"),
         @Json(name = "TICKETS") TICKETS("TICKETS"),
         @Json(name = "YIPIT") YIPIT("YIPIT");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter offerVisibility
     */
     enum class OfferVisibilityUpdateMedia(val value: kotlin.String) {
         @Json(name = "PUBLIC") PUBLIC("PUBLIC"),
         @Json(name = "LISTABLE") LISTABLE("LISTABLE"),
         @Json(name = "REWARDABLE") REWARDABLE("REWARDABLE"),
         @Json(name = "TRIGGERABLE") TRIGGERABLE("TRIGGERABLE"),
         @Json(name = "PRIVATE") PRIVATE("PRIVATE");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter conditionType
     */
     enum class ConditionTypeUpdateMedia(val value: kotlin.String) {
         @Json(name = "NEW") NEW("NEW"),
         @Json(name = "USED") USED("USED"),
         @Json(name = "REFURBISHED") REFURBISHED("REFURBISHED"),
         @Json(name = "OTHER") OTHER("OTHER");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter mediaType
     */
     enum class MediaTypeUpdateMedia(val value: kotlin.String) {
         @Json(name = "APK") APK("APK"),
         @Json(name = "APPLICATION") APPLICATION("APPLICATION"),
         @Json(name = "IMAGE") IMAGE("IMAGE"),
         @Json(name = "AUDIO") AUDIO("AUDIO"),
         @Json(name = "VIDEO") VIDEO("VIDEO"),
         @Json(name = "MULTIPART") MULTIPART("MULTIPART"),
         @Json(name = "BAR_CODE") BAR_CODE("BAR_CODE"),
         @Json(name = "TEXT") TEXT("TEXT"),
         @Json(name = "OTHER") OTHER("OTHER");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * POST /media/update
     * Update Media
     * Update a media offering.
     * @param accountId The account used to perform the update, must have rights to edit the offer (deviceId or accountId required)
     * @param mediaId 
     * @param retailerLocationIds Comma separated list of retailer location ids. This will assign the offer to these retailer locations. (optional)
     * @param offerLocations A list of json data that has offer location specific values. (optional)
     * @param title The title (255 char limit) (optional)
     * @param subTitle The sub title (255 char limit) (optional)
     * @param details The details (optional)
     * @param subDetails A string for custom details (255 char limit) (optional)
     * @param finePrint The fine print (optional)
     * @param barcodeType The bar code type {NONE, UPC, CODE_128, QR, CUSTOM_MEDIA} (optional)
     * @param barcodeEntry The bar code entry string (optional)
     * @param externalRedeemOptions An external identifier. What the identifier will be used for and how it is formatted is up to the frontend developer. (optional)
     * @param externalUrl The clickUrl of the offer (optional)
     * @param ticketsRewardType The type of ticket to reward, null means default type (optional)
     * @param ticketsReward Determines how many tickets are awarded (optional)
     * @param activated The date of when the offer will be visible to consumers (optional)
     * @param expires The date of when the offer expires (optional)
     * @param noExpiration Overrides the expiration date so that the offer does not expire (optional)
     * @param availableLimit The limit of how many times the offer can be used by consumers (optional)
     * @param availableLimitPerUser The limit of how many times a user can used the same offer (optional)
     * @param addedLimit The limit of how many times the offer can be added to consumer wallets (optional)
     * @param viewLimit  (optional)
     * @param maxPrints The maximum number of times the offer can be printed (optional)
     * @param ticketPriceType the type of ticket needed to buy the offer (optional)
     * @param ticketPrice The cost of the offer in tickets (optional)
     * @param fullPrice The retail/full price cost of the offer in real currency (optional)
     * @param discountPrice The cost of the offer at a discounted price (what the consumer pays) (optional)
     * @param showRemaining The show remaining (optional)
     * @param showRedeemed The show redeemed (optional)
     * @param replaced The replaced (optional)
     * @param featured The featured (optional)
     * @param specialOfferType The special offer type {ALL, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW} (optional)
     * @param offerVisibility The offer visibility {PUBLIC, REWARDABLE, TRIGGERABLE} (optional)
     * @param categoryIds Comma separated list of category ids (optional)
     * @param filterIds Comma separated list of filter ids (optional)
     * @param active Sets the active flag (optional)
     * @param barcodeAssetId The id of the barcode asset (optional)
     * @param imageAssetId The id of the an offer asset (optional)
     * @param imageAssetId1 The id of the an offer asset (optional)
     * @param imageAssetId2 The id of the an offer asset (optional)
     * @param imageAssetId3 The id of the an offer asset (optional)
     * @param imageAssetId4 The id of the an offer asset (optional)
     * @param imageAssetId5 The id of the an offer asset (optional)
     * @param publisher The maker of the item. (optional)
     * @param redeemableStart The redeemable start date/time of the offer. (optional)
     * @param redeemableEnd The redeemable start date/time of the offer. (optional)
     * @param conditionType The condition. OfferType PRODUCT only. (optional)
     * @param isbn The ISBN id. OfferType PRODUCT only. (optional)
     * @param asin The ASIN id. OfferType PRODUCT only. (optional)
     * @param catalogNumbers The list of catelog numbers, comma seperated. OfferType PRODUCT only. (optional)
     * @param availabilityDate The date available. OfferType PRODUCT only. (optional)
     * @param parentalRating The parental control rating. OfferType PRODUCT only. (optional)
     * @param mediaType  (optional)
     * @param duration The total playing time of the media item. OfferType MEDIA only. (optional)
     * @param author The created/author of the media item. OfferType MEDIA only. (optional)
     * @param releaseDate The date/time of when the media item was originally released. OfferType MEDIA only. (optional)
     * @param collectionIds  (optional)
     * @param availability  (optional)
     * @param availabilitySummary  (optional)
     * @return MediaOfferResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updateMedia(accountId: kotlin.Long, mediaId: kotlin.Long, retailerLocationIds: kotlin.String? = null, offerLocations: kotlin.String? = null, title: kotlin.String? = null, subTitle: kotlin.String? = null, details: kotlin.String? = null, subDetails: kotlin.String? = null, finePrint: kotlin.String? = null, barcodeType: BarcodeTypeUpdateMedia? = null, barcodeEntry: kotlin.String? = null, externalRedeemOptions: kotlin.String? = null, externalUrl: kotlin.String? = null, ticketsRewardType: kotlin.String? = null, ticketsReward: kotlin.Long? = null, activated: kotlin.Long? = null, expires: kotlin.Long? = null, noExpiration: kotlin.Boolean? = null, availableLimit: kotlin.Int? = null, availableLimitPerUser: kotlin.Int? = null, addedLimit: kotlin.Int? = null, viewLimit: kotlin.Int? = null, maxPrints: kotlin.Int? = null, ticketPriceType: kotlin.String? = null, ticketPrice: kotlin.Long? = null, fullPrice: kotlin.Double? = null, discountPrice: kotlin.Double? = null, showRemaining: kotlin.Boolean? = null, showRedeemed: kotlin.Boolean? = null, replaced: kotlin.Boolean? = null, featured: kotlin.Boolean? = null, specialOfferType: SpecialOfferTypeUpdateMedia? = null, offerVisibility: OfferVisibilityUpdateMedia? = null, categoryIds: kotlin.String? = null, filterIds: kotlin.String? = null, active: kotlin.Boolean? = null, barcodeAssetId: kotlin.Long? = null, imageAssetId: kotlin.Long? = null, imageAssetId1: kotlin.Long? = null, imageAssetId2: kotlin.Long? = null, imageAssetId3: kotlin.Long? = null, imageAssetId4: kotlin.Long? = null, imageAssetId5: kotlin.Long? = null, publisher: kotlin.String? = null, redeemableStart: kotlin.Long? = null, redeemableEnd: kotlin.Long? = null, conditionType: ConditionTypeUpdateMedia? = null, isbn: kotlin.String? = null, asin: kotlin.String? = null, catalogNumbers: kotlin.String? = null, availabilityDate: kotlin.Long? = null, parentalRating: kotlin.String? = null, mediaType: MediaTypeUpdateMedia? = null, duration: kotlin.Int? = null, author: kotlin.String? = null, releaseDate: kotlin.Long? = null, collectionIds: kotlin.String? = null, availability: kotlin.String? = null, availabilitySummary: kotlin.String? = null) : MediaOfferResponse {
        val localVarResponse = updateMediaWithHttpInfo(accountId = accountId, mediaId = mediaId, retailerLocationIds = retailerLocationIds, offerLocations = offerLocations, title = title, subTitle = subTitle, details = details, subDetails = subDetails, finePrint = finePrint, barcodeType = barcodeType, barcodeEntry = barcodeEntry, externalRedeemOptions = externalRedeemOptions, externalUrl = externalUrl, ticketsRewardType = ticketsRewardType, ticketsReward = ticketsReward, activated = activated, expires = expires, noExpiration = noExpiration, availableLimit = availableLimit, availableLimitPerUser = availableLimitPerUser, addedLimit = addedLimit, viewLimit = viewLimit, maxPrints = maxPrints, ticketPriceType = ticketPriceType, ticketPrice = ticketPrice, fullPrice = fullPrice, discountPrice = discountPrice, showRemaining = showRemaining, showRedeemed = showRedeemed, replaced = replaced, featured = featured, specialOfferType = specialOfferType, offerVisibility = offerVisibility, categoryIds = categoryIds, filterIds = filterIds, active = active, barcodeAssetId = barcodeAssetId, imageAssetId = imageAssetId, imageAssetId1 = imageAssetId1, imageAssetId2 = imageAssetId2, imageAssetId3 = imageAssetId3, imageAssetId4 = imageAssetId4, imageAssetId5 = imageAssetId5, publisher = publisher, redeemableStart = redeemableStart, redeemableEnd = redeemableEnd, conditionType = conditionType, isbn = isbn, asin = asin, catalogNumbers = catalogNumbers, availabilityDate = availabilityDate, parentalRating = parentalRating, mediaType = mediaType, duration = duration, author = author, releaseDate = releaseDate, collectionIds = collectionIds, availability = availability, availabilitySummary = availabilitySummary)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MediaOfferResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /media/update
     * Update Media
     * Update a media offering.
     * @param accountId The account used to perform the update, must have rights to edit the offer (deviceId or accountId required)
     * @param mediaId 
     * @param retailerLocationIds Comma separated list of retailer location ids. This will assign the offer to these retailer locations. (optional)
     * @param offerLocations A list of json data that has offer location specific values. (optional)
     * @param title The title (255 char limit) (optional)
     * @param subTitle The sub title (255 char limit) (optional)
     * @param details The details (optional)
     * @param subDetails A string for custom details (255 char limit) (optional)
     * @param finePrint The fine print (optional)
     * @param barcodeType The bar code type {NONE, UPC, CODE_128, QR, CUSTOM_MEDIA} (optional)
     * @param barcodeEntry The bar code entry string (optional)
     * @param externalRedeemOptions An external identifier. What the identifier will be used for and how it is formatted is up to the frontend developer. (optional)
     * @param externalUrl The clickUrl of the offer (optional)
     * @param ticketsRewardType The type of ticket to reward, null means default type (optional)
     * @param ticketsReward Determines how many tickets are awarded (optional)
     * @param activated The date of when the offer will be visible to consumers (optional)
     * @param expires The date of when the offer expires (optional)
     * @param noExpiration Overrides the expiration date so that the offer does not expire (optional)
     * @param availableLimit The limit of how many times the offer can be used by consumers (optional)
     * @param availableLimitPerUser The limit of how many times a user can used the same offer (optional)
     * @param addedLimit The limit of how many times the offer can be added to consumer wallets (optional)
     * @param viewLimit  (optional)
     * @param maxPrints The maximum number of times the offer can be printed (optional)
     * @param ticketPriceType the type of ticket needed to buy the offer (optional)
     * @param ticketPrice The cost of the offer in tickets (optional)
     * @param fullPrice The retail/full price cost of the offer in real currency (optional)
     * @param discountPrice The cost of the offer at a discounted price (what the consumer pays) (optional)
     * @param showRemaining The show remaining (optional)
     * @param showRedeemed The show redeemed (optional)
     * @param replaced The replaced (optional)
     * @param featured The featured (optional)
     * @param specialOfferType The special offer type {ALL, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW} (optional)
     * @param offerVisibility The offer visibility {PUBLIC, REWARDABLE, TRIGGERABLE} (optional)
     * @param categoryIds Comma separated list of category ids (optional)
     * @param filterIds Comma separated list of filter ids (optional)
     * @param active Sets the active flag (optional)
     * @param barcodeAssetId The id of the barcode asset (optional)
     * @param imageAssetId The id of the an offer asset (optional)
     * @param imageAssetId1 The id of the an offer asset (optional)
     * @param imageAssetId2 The id of the an offer asset (optional)
     * @param imageAssetId3 The id of the an offer asset (optional)
     * @param imageAssetId4 The id of the an offer asset (optional)
     * @param imageAssetId5 The id of the an offer asset (optional)
     * @param publisher The maker of the item. (optional)
     * @param redeemableStart The redeemable start date/time of the offer. (optional)
     * @param redeemableEnd The redeemable start date/time of the offer. (optional)
     * @param conditionType The condition. OfferType PRODUCT only. (optional)
     * @param isbn The ISBN id. OfferType PRODUCT only. (optional)
     * @param asin The ASIN id. OfferType PRODUCT only. (optional)
     * @param catalogNumbers The list of catelog numbers, comma seperated. OfferType PRODUCT only. (optional)
     * @param availabilityDate The date available. OfferType PRODUCT only. (optional)
     * @param parentalRating The parental control rating. OfferType PRODUCT only. (optional)
     * @param mediaType  (optional)
     * @param duration The total playing time of the media item. OfferType MEDIA only. (optional)
     * @param author The created/author of the media item. OfferType MEDIA only. (optional)
     * @param releaseDate The date/time of when the media item was originally released. OfferType MEDIA only. (optional)
     * @param collectionIds  (optional)
     * @param availability  (optional)
     * @param availabilitySummary  (optional)
     * @return ApiResponse<MediaOfferResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun updateMediaWithHttpInfo(accountId: kotlin.Long, mediaId: kotlin.Long, retailerLocationIds: kotlin.String?, offerLocations: kotlin.String?, title: kotlin.String?, subTitle: kotlin.String?, details: kotlin.String?, subDetails: kotlin.String?, finePrint: kotlin.String?, barcodeType: BarcodeTypeUpdateMedia?, barcodeEntry: kotlin.String?, externalRedeemOptions: kotlin.String?, externalUrl: kotlin.String?, ticketsRewardType: kotlin.String?, ticketsReward: kotlin.Long?, activated: kotlin.Long?, expires: kotlin.Long?, noExpiration: kotlin.Boolean?, availableLimit: kotlin.Int?, availableLimitPerUser: kotlin.Int?, addedLimit: kotlin.Int?, viewLimit: kotlin.Int?, maxPrints: kotlin.Int?, ticketPriceType: kotlin.String?, ticketPrice: kotlin.Long?, fullPrice: kotlin.Double?, discountPrice: kotlin.Double?, showRemaining: kotlin.Boolean?, showRedeemed: kotlin.Boolean?, replaced: kotlin.Boolean?, featured: kotlin.Boolean?, specialOfferType: SpecialOfferTypeUpdateMedia?, offerVisibility: OfferVisibilityUpdateMedia?, categoryIds: kotlin.String?, filterIds: kotlin.String?, active: kotlin.Boolean?, barcodeAssetId: kotlin.Long?, imageAssetId: kotlin.Long?, imageAssetId1: kotlin.Long?, imageAssetId2: kotlin.Long?, imageAssetId3: kotlin.Long?, imageAssetId4: kotlin.Long?, imageAssetId5: kotlin.Long?, publisher: kotlin.String?, redeemableStart: kotlin.Long?, redeemableEnd: kotlin.Long?, conditionType: ConditionTypeUpdateMedia?, isbn: kotlin.String?, asin: kotlin.String?, catalogNumbers: kotlin.String?, availabilityDate: kotlin.Long?, parentalRating: kotlin.String?, mediaType: MediaTypeUpdateMedia?, duration: kotlin.Int?, author: kotlin.String?, releaseDate: kotlin.Long?, collectionIds: kotlin.String?, availability: kotlin.String?, availabilitySummary: kotlin.String?) : ApiResponse<MediaOfferResponse?> {
        val localVariableConfig = updateMediaRequestConfig(accountId = accountId, mediaId = mediaId, retailerLocationIds = retailerLocationIds, offerLocations = offerLocations, title = title, subTitle = subTitle, details = details, subDetails = subDetails, finePrint = finePrint, barcodeType = barcodeType, barcodeEntry = barcodeEntry, externalRedeemOptions = externalRedeemOptions, externalUrl = externalUrl, ticketsRewardType = ticketsRewardType, ticketsReward = ticketsReward, activated = activated, expires = expires, noExpiration = noExpiration, availableLimit = availableLimit, availableLimitPerUser = availableLimitPerUser, addedLimit = addedLimit, viewLimit = viewLimit, maxPrints = maxPrints, ticketPriceType = ticketPriceType, ticketPrice = ticketPrice, fullPrice = fullPrice, discountPrice = discountPrice, showRemaining = showRemaining, showRedeemed = showRedeemed, replaced = replaced, featured = featured, specialOfferType = specialOfferType, offerVisibility = offerVisibility, categoryIds = categoryIds, filterIds = filterIds, active = active, barcodeAssetId = barcodeAssetId, imageAssetId = imageAssetId, imageAssetId1 = imageAssetId1, imageAssetId2 = imageAssetId2, imageAssetId3 = imageAssetId3, imageAssetId4 = imageAssetId4, imageAssetId5 = imageAssetId5, publisher = publisher, redeemableStart = redeemableStart, redeemableEnd = redeemableEnd, conditionType = conditionType, isbn = isbn, asin = asin, catalogNumbers = catalogNumbers, availabilityDate = availabilityDate, parentalRating = parentalRating, mediaType = mediaType, duration = duration, author = author, releaseDate = releaseDate, collectionIds = collectionIds, availability = availability, availabilitySummary = availabilitySummary)

        return request<Unit, MediaOfferResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateMedia
     *
     * @param accountId The account used to perform the update, must have rights to edit the offer (deviceId or accountId required)
     * @param mediaId 
     * @param retailerLocationIds Comma separated list of retailer location ids. This will assign the offer to these retailer locations. (optional)
     * @param offerLocations A list of json data that has offer location specific values. (optional)
     * @param title The title (255 char limit) (optional)
     * @param subTitle The sub title (255 char limit) (optional)
     * @param details The details (optional)
     * @param subDetails A string for custom details (255 char limit) (optional)
     * @param finePrint The fine print (optional)
     * @param barcodeType The bar code type {NONE, UPC, CODE_128, QR, CUSTOM_MEDIA} (optional)
     * @param barcodeEntry The bar code entry string (optional)
     * @param externalRedeemOptions An external identifier. What the identifier will be used for and how it is formatted is up to the frontend developer. (optional)
     * @param externalUrl The clickUrl of the offer (optional)
     * @param ticketsRewardType The type of ticket to reward, null means default type (optional)
     * @param ticketsReward Determines how many tickets are awarded (optional)
     * @param activated The date of when the offer will be visible to consumers (optional)
     * @param expires The date of when the offer expires (optional)
     * @param noExpiration Overrides the expiration date so that the offer does not expire (optional)
     * @param availableLimit The limit of how many times the offer can be used by consumers (optional)
     * @param availableLimitPerUser The limit of how many times a user can used the same offer (optional)
     * @param addedLimit The limit of how many times the offer can be added to consumer wallets (optional)
     * @param viewLimit  (optional)
     * @param maxPrints The maximum number of times the offer can be printed (optional)
     * @param ticketPriceType the type of ticket needed to buy the offer (optional)
     * @param ticketPrice The cost of the offer in tickets (optional)
     * @param fullPrice The retail/full price cost of the offer in real currency (optional)
     * @param discountPrice The cost of the offer at a discounted price (what the consumer pays) (optional)
     * @param showRemaining The show remaining (optional)
     * @param showRedeemed The show redeemed (optional)
     * @param replaced The replaced (optional)
     * @param featured The featured (optional)
     * @param specialOfferType The special offer type {ALL, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW} (optional)
     * @param offerVisibility The offer visibility {PUBLIC, REWARDABLE, TRIGGERABLE} (optional)
     * @param categoryIds Comma separated list of category ids (optional)
     * @param filterIds Comma separated list of filter ids (optional)
     * @param active Sets the active flag (optional)
     * @param barcodeAssetId The id of the barcode asset (optional)
     * @param imageAssetId The id of the an offer asset (optional)
     * @param imageAssetId1 The id of the an offer asset (optional)
     * @param imageAssetId2 The id of the an offer asset (optional)
     * @param imageAssetId3 The id of the an offer asset (optional)
     * @param imageAssetId4 The id of the an offer asset (optional)
     * @param imageAssetId5 The id of the an offer asset (optional)
     * @param publisher The maker of the item. (optional)
     * @param redeemableStart The redeemable start date/time of the offer. (optional)
     * @param redeemableEnd The redeemable start date/time of the offer. (optional)
     * @param conditionType The condition. OfferType PRODUCT only. (optional)
     * @param isbn The ISBN id. OfferType PRODUCT only. (optional)
     * @param asin The ASIN id. OfferType PRODUCT only. (optional)
     * @param catalogNumbers The list of catelog numbers, comma seperated. OfferType PRODUCT only. (optional)
     * @param availabilityDate The date available. OfferType PRODUCT only. (optional)
     * @param parentalRating The parental control rating. OfferType PRODUCT only. (optional)
     * @param mediaType  (optional)
     * @param duration The total playing time of the media item. OfferType MEDIA only. (optional)
     * @param author The created/author of the media item. OfferType MEDIA only. (optional)
     * @param releaseDate The date/time of when the media item was originally released. OfferType MEDIA only. (optional)
     * @param collectionIds  (optional)
     * @param availability  (optional)
     * @param availabilitySummary  (optional)
     * @return RequestConfig
     */
    fun updateMediaRequestConfig(accountId: kotlin.Long, mediaId: kotlin.Long, retailerLocationIds: kotlin.String?, offerLocations: kotlin.String?, title: kotlin.String?, subTitle: kotlin.String?, details: kotlin.String?, subDetails: kotlin.String?, finePrint: kotlin.String?, barcodeType: BarcodeTypeUpdateMedia?, barcodeEntry: kotlin.String?, externalRedeemOptions: kotlin.String?, externalUrl: kotlin.String?, ticketsRewardType: kotlin.String?, ticketsReward: kotlin.Long?, activated: kotlin.Long?, expires: kotlin.Long?, noExpiration: kotlin.Boolean?, availableLimit: kotlin.Int?, availableLimitPerUser: kotlin.Int?, addedLimit: kotlin.Int?, viewLimit: kotlin.Int?, maxPrints: kotlin.Int?, ticketPriceType: kotlin.String?, ticketPrice: kotlin.Long?, fullPrice: kotlin.Double?, discountPrice: kotlin.Double?, showRemaining: kotlin.Boolean?, showRedeemed: kotlin.Boolean?, replaced: kotlin.Boolean?, featured: kotlin.Boolean?, specialOfferType: SpecialOfferTypeUpdateMedia?, offerVisibility: OfferVisibilityUpdateMedia?, categoryIds: kotlin.String?, filterIds: kotlin.String?, active: kotlin.Boolean?, barcodeAssetId: kotlin.Long?, imageAssetId: kotlin.Long?, imageAssetId1: kotlin.Long?, imageAssetId2: kotlin.Long?, imageAssetId3: kotlin.Long?, imageAssetId4: kotlin.Long?, imageAssetId5: kotlin.Long?, publisher: kotlin.String?, redeemableStart: kotlin.Long?, redeemableEnd: kotlin.Long?, conditionType: ConditionTypeUpdateMedia?, isbn: kotlin.String?, asin: kotlin.String?, catalogNumbers: kotlin.String?, availabilityDate: kotlin.Long?, parentalRating: kotlin.String?, mediaType: MediaTypeUpdateMedia?, duration: kotlin.Int?, author: kotlin.String?, releaseDate: kotlin.Long?, collectionIds: kotlin.String?, availability: kotlin.String?, availabilitySummary: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("mediaId", listOf(mediaId.toString()))
                if (retailerLocationIds != null) {
                    put("retailerLocationIds", listOf(retailerLocationIds.toString()))
                }
                if (offerLocations != null) {
                    put("offerLocations", listOf(offerLocations.toString()))
                }
                if (title != null) {
                    put("title", listOf(title.toString()))
                }
                if (subTitle != null) {
                    put("subTitle", listOf(subTitle.toString()))
                }
                if (details != null) {
                    put("details", listOf(details.toString()))
                }
                if (subDetails != null) {
                    put("subDetails", listOf(subDetails.toString()))
                }
                if (finePrint != null) {
                    put("finePrint", listOf(finePrint.toString()))
                }
                if (barcodeType != null) {
                    put("barcodeType", listOf(barcodeType.value))
                }
                if (barcodeEntry != null) {
                    put("barcodeEntry", listOf(barcodeEntry.toString()))
                }
                if (externalRedeemOptions != null) {
                    put("externalRedeemOptions", listOf(externalRedeemOptions.toString()))
                }
                if (externalUrl != null) {
                    put("externalUrl", listOf(externalUrl.toString()))
                }
                if (ticketsRewardType != null) {
                    put("ticketsRewardType", listOf(ticketsRewardType.toString()))
                }
                if (ticketsReward != null) {
                    put("ticketsReward", listOf(ticketsReward.toString()))
                }
                if (activated != null) {
                    put("activated", listOf(activated.toString()))
                }
                if (expires != null) {
                    put("expires", listOf(expires.toString()))
                }
                if (noExpiration != null) {
                    put("noExpiration", listOf(noExpiration.toString()))
                }
                if (availableLimit != null) {
                    put("availableLimit", listOf(availableLimit.toString()))
                }
                if (availableLimitPerUser != null) {
                    put("availableLimitPerUser", listOf(availableLimitPerUser.toString()))
                }
                if (addedLimit != null) {
                    put("addedLimit", listOf(addedLimit.toString()))
                }
                if (viewLimit != null) {
                    put("viewLimit", listOf(viewLimit.toString()))
                }
                if (maxPrints != null) {
                    put("maxPrints", listOf(maxPrints.toString()))
                }
                if (ticketPriceType != null) {
                    put("ticketPriceType", listOf(ticketPriceType.toString()))
                }
                if (ticketPrice != null) {
                    put("ticketPrice", listOf(ticketPrice.toString()))
                }
                if (fullPrice != null) {
                    put("fullPrice", listOf(fullPrice.toString()))
                }
                if (discountPrice != null) {
                    put("discountPrice", listOf(discountPrice.toString()))
                }
                if (showRemaining != null) {
                    put("showRemaining", listOf(showRemaining.toString()))
                }
                if (showRedeemed != null) {
                    put("showRedeemed", listOf(showRedeemed.toString()))
                }
                if (replaced != null) {
                    put("replaced", listOf(replaced.toString()))
                }
                if (featured != null) {
                    put("featured", listOf(featured.toString()))
                }
                if (specialOfferType != null) {
                    put("specialOfferType", listOf(specialOfferType.value))
                }
                if (offerVisibility != null) {
                    put("offerVisibility", listOf(offerVisibility.value))
                }
                if (categoryIds != null) {
                    put("categoryIds", listOf(categoryIds.toString()))
                }
                if (filterIds != null) {
                    put("filterIds", listOf(filterIds.toString()))
                }
                if (active != null) {
                    put("active", listOf(active.toString()))
                }
                if (barcodeAssetId != null) {
                    put("barcodeAssetId", listOf(barcodeAssetId.toString()))
                }
                if (imageAssetId != null) {
                    put("imageAssetId", listOf(imageAssetId.toString()))
                }
                if (imageAssetId1 != null) {
                    put("imageAssetId1", listOf(imageAssetId1.toString()))
                }
                if (imageAssetId2 != null) {
                    put("imageAssetId2", listOf(imageAssetId2.toString()))
                }
                if (imageAssetId3 != null) {
                    put("imageAssetId3", listOf(imageAssetId3.toString()))
                }
                if (imageAssetId4 != null) {
                    put("imageAssetId4", listOf(imageAssetId4.toString()))
                }
                if (imageAssetId5 != null) {
                    put("imageAssetId5", listOf(imageAssetId5.toString()))
                }
                if (publisher != null) {
                    put("publisher", listOf(publisher.toString()))
                }
                if (redeemableStart != null) {
                    put("redeemableStart", listOf(redeemableStart.toString()))
                }
                if (redeemableEnd != null) {
                    put("redeemableEnd", listOf(redeemableEnd.toString()))
                }
                if (conditionType != null) {
                    put("conditionType", listOf(conditionType.value))
                }
                if (isbn != null) {
                    put("isbn", listOf(isbn.toString()))
                }
                if (asin != null) {
                    put("asin", listOf(asin.toString()))
                }
                if (catalogNumbers != null) {
                    put("catalogNumbers", listOf(catalogNumbers.toString()))
                }
                if (availabilityDate != null) {
                    put("availabilityDate", listOf(availabilityDate.toString()))
                }
                if (parentalRating != null) {
                    put("parentalRating", listOf(parentalRating.toString()))
                }
                if (mediaType != null) {
                    put("mediaType", listOf(mediaType.value))
                }
                if (duration != null) {
                    put("duration", listOf(duration.toString()))
                }
                if (author != null) {
                    put("author", listOf(author.toString()))
                }
                if (releaseDate != null) {
                    put("releaseDate", listOf(releaseDate.toString()))
                }
                if (collectionIds != null) {
                    put("collectionIds", listOf(collectionIds.toString()))
                }
                if (availability != null) {
                    put("availability", listOf(availability.toString()))
                }
                if (availabilitySummary != null) {
                    put("availabilitySummary", listOf(availabilitySummary.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/media/update",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
