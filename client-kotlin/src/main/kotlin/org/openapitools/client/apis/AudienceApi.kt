/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import org.openapitools.client.models.AgeGroupResponse
import org.openapitools.client.models.AudienceDeviceResponse
import org.openapitools.client.models.AudienceResponse
import org.openapitools.client.models.OfferListResponse
import org.openapitools.client.models.SearchResponse
import org.openapitools.client.models.SirqulResponse

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

open class AudienceApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://dev.sirqul.com/api/3.18")
        }
    }

    /**
     * POST /audience/create
     * Create Audience
     * Create a user defined audience.
     * @param accountId The logged in user.
     * @param name The name of the audience
     * @param description The description of the audience (optional)
     * @param searchTags The search tags (optional)
     * @param gender The gender; possible values are: MALE, FEMALE, ANY (optional)
     * @param ageGroups The list of age groups, comma separated; possible values are AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS, AGE_ANY (to reset to none) (optional)
     * @param categoryIds The list of category ids, comma separated; possible values are retrieved via /api/{version}/category/search (pass in id values) (optional)
     * @param applicationIds The list of application ids, comma separated; possible values are retrieved via /api/{version}/application/list (pass in id values) (optional)
     * @param gameExperienceLevel The experience level of the player; possible values are: ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT (optional)
     * @param devices (Deprecated) Use deviceIds. The list of targeted device names, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in name values) (optional)
     * @param deviceIds The list of targeted device ids, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in id values) (optional)
     * @param deviceVersions The list of targeted device version ranges that are aligned with the provided devices list, comma separated (examples: 2.3-X, 0-5.1.4, 4.3.1-6.1.4) (optional)
     * @param locations The list of locations to build the center around; comma separated list of latitude/longitude pairs (example: lat1,long1,lat2,long2) (optional)
     * @param radius The list of radius of influence for the audience, in miles; comma separated list. Either provide 1 to be applied to all location pairs or a matching list to each lat/long pair. (optional)
     * @param startTimeOffset Seconds from the start time of an event (optional)
     * @param endTimeOffset Seconds from the end time of an event (optional)
     * @param sendSuggestion If true, then notify matching users when they are inside the radius (optional, default to true)
     * @param associateDescription The description of the associated object (optional)
     * @param associateType The type of the object to center the audience geofence (optional)
     * @param associateId The ID of the object to center the audience geofence (optional)
     * @param groupingId Optional grouping id for the audience (optional)
     * @param metaData External custom client defined data (optional)
     * @param visibility Visibility of the audience (optional)
     * @param audienceType Type of audience (optional)
     * @param useOrder Use order for cohort (optional)
     * @param cohortRegionsData Cohort data for \&quot;cohort\&quot; audience type (optional)
     * @param appKey Filter results by application key (optional)
     * @param trilaterationTypes Trilateration types (optional)
     * @param uniqueName If true, makes sure the audience name is unique (optional)
     * @return AudienceResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createAudience(accountId: kotlin.Long, name: kotlin.String, description: kotlin.String? = null, searchTags: kotlin.String? = null, gender: kotlin.String? = null, ageGroups: kotlin.String? = null, categoryIds: kotlin.String? = null, applicationIds: kotlin.String? = null, gameExperienceLevel: kotlin.String? = null, devices: kotlin.String? = null, deviceIds: kotlin.String? = null, deviceVersions: kotlin.String? = null, locations: kotlin.String? = null, radius: kotlin.String? = null, startTimeOffset: kotlin.Int? = null, endTimeOffset: kotlin.Int? = null, sendSuggestion: kotlin.Boolean? = true, associateDescription: kotlin.String? = null, associateType: kotlin.String? = null, associateId: kotlin.Long? = null, groupingId: kotlin.String? = null, metaData: kotlin.String? = null, visibility: kotlin.String? = null, audienceType: kotlin.String? = null, useOrder: kotlin.Boolean? = null, cohortRegionsData: kotlin.String? = null, appKey: kotlin.String? = null, trilaterationTypes: kotlin.String? = null, uniqueName: kotlin.Boolean? = null) : AudienceResponse {
        val localVarResponse = createAudienceWithHttpInfo(accountId = accountId, name = name, description = description, searchTags = searchTags, gender = gender, ageGroups = ageGroups, categoryIds = categoryIds, applicationIds = applicationIds, gameExperienceLevel = gameExperienceLevel, devices = devices, deviceIds = deviceIds, deviceVersions = deviceVersions, locations = locations, radius = radius, startTimeOffset = startTimeOffset, endTimeOffset = endTimeOffset, sendSuggestion = sendSuggestion, associateDescription = associateDescription, associateType = associateType, associateId = associateId, groupingId = groupingId, metaData = metaData, visibility = visibility, audienceType = audienceType, useOrder = useOrder, cohortRegionsData = cohortRegionsData, appKey = appKey, trilaterationTypes = trilaterationTypes, uniqueName = uniqueName)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AudienceResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /audience/create
     * Create Audience
     * Create a user defined audience.
     * @param accountId The logged in user.
     * @param name The name of the audience
     * @param description The description of the audience (optional)
     * @param searchTags The search tags (optional)
     * @param gender The gender; possible values are: MALE, FEMALE, ANY (optional)
     * @param ageGroups The list of age groups, comma separated; possible values are AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS, AGE_ANY (to reset to none) (optional)
     * @param categoryIds The list of category ids, comma separated; possible values are retrieved via /api/{version}/category/search (pass in id values) (optional)
     * @param applicationIds The list of application ids, comma separated; possible values are retrieved via /api/{version}/application/list (pass in id values) (optional)
     * @param gameExperienceLevel The experience level of the player; possible values are: ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT (optional)
     * @param devices (Deprecated) Use deviceIds. The list of targeted device names, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in name values) (optional)
     * @param deviceIds The list of targeted device ids, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in id values) (optional)
     * @param deviceVersions The list of targeted device version ranges that are aligned with the provided devices list, comma separated (examples: 2.3-X, 0-5.1.4, 4.3.1-6.1.4) (optional)
     * @param locations The list of locations to build the center around; comma separated list of latitude/longitude pairs (example: lat1,long1,lat2,long2) (optional)
     * @param radius The list of radius of influence for the audience, in miles; comma separated list. Either provide 1 to be applied to all location pairs or a matching list to each lat/long pair. (optional)
     * @param startTimeOffset Seconds from the start time of an event (optional)
     * @param endTimeOffset Seconds from the end time of an event (optional)
     * @param sendSuggestion If true, then notify matching users when they are inside the radius (optional, default to true)
     * @param associateDescription The description of the associated object (optional)
     * @param associateType The type of the object to center the audience geofence (optional)
     * @param associateId The ID of the object to center the audience geofence (optional)
     * @param groupingId Optional grouping id for the audience (optional)
     * @param metaData External custom client defined data (optional)
     * @param visibility Visibility of the audience (optional)
     * @param audienceType Type of audience (optional)
     * @param useOrder Use order for cohort (optional)
     * @param cohortRegionsData Cohort data for \&quot;cohort\&quot; audience type (optional)
     * @param appKey Filter results by application key (optional)
     * @param trilaterationTypes Trilateration types (optional)
     * @param uniqueName If true, makes sure the audience name is unique (optional)
     * @return ApiResponse<AudienceResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createAudienceWithHttpInfo(accountId: kotlin.Long, name: kotlin.String, description: kotlin.String?, searchTags: kotlin.String?, gender: kotlin.String?, ageGroups: kotlin.String?, categoryIds: kotlin.String?, applicationIds: kotlin.String?, gameExperienceLevel: kotlin.String?, devices: kotlin.String?, deviceIds: kotlin.String?, deviceVersions: kotlin.String?, locations: kotlin.String?, radius: kotlin.String?, startTimeOffset: kotlin.Int?, endTimeOffset: kotlin.Int?, sendSuggestion: kotlin.Boolean?, associateDescription: kotlin.String?, associateType: kotlin.String?, associateId: kotlin.Long?, groupingId: kotlin.String?, metaData: kotlin.String?, visibility: kotlin.String?, audienceType: kotlin.String?, useOrder: kotlin.Boolean?, cohortRegionsData: kotlin.String?, appKey: kotlin.String?, trilaterationTypes: kotlin.String?, uniqueName: kotlin.Boolean?) : ApiResponse<AudienceResponse?> {
        val localVariableConfig = createAudienceRequestConfig(accountId = accountId, name = name, description = description, searchTags = searchTags, gender = gender, ageGroups = ageGroups, categoryIds = categoryIds, applicationIds = applicationIds, gameExperienceLevel = gameExperienceLevel, devices = devices, deviceIds = deviceIds, deviceVersions = deviceVersions, locations = locations, radius = radius, startTimeOffset = startTimeOffset, endTimeOffset = endTimeOffset, sendSuggestion = sendSuggestion, associateDescription = associateDescription, associateType = associateType, associateId = associateId, groupingId = groupingId, metaData = metaData, visibility = visibility, audienceType = audienceType, useOrder = useOrder, cohortRegionsData = cohortRegionsData, appKey = appKey, trilaterationTypes = trilaterationTypes, uniqueName = uniqueName)

        return request<Unit, AudienceResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createAudience
     *
     * @param accountId The logged in user.
     * @param name The name of the audience
     * @param description The description of the audience (optional)
     * @param searchTags The search tags (optional)
     * @param gender The gender; possible values are: MALE, FEMALE, ANY (optional)
     * @param ageGroups The list of age groups, comma separated; possible values are AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS, AGE_ANY (to reset to none) (optional)
     * @param categoryIds The list of category ids, comma separated; possible values are retrieved via /api/{version}/category/search (pass in id values) (optional)
     * @param applicationIds The list of application ids, comma separated; possible values are retrieved via /api/{version}/application/list (pass in id values) (optional)
     * @param gameExperienceLevel The experience level of the player; possible values are: ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT (optional)
     * @param devices (Deprecated) Use deviceIds. The list of targeted device names, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in name values) (optional)
     * @param deviceIds The list of targeted device ids, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in id values) (optional)
     * @param deviceVersions The list of targeted device version ranges that are aligned with the provided devices list, comma separated (examples: 2.3-X, 0-5.1.4, 4.3.1-6.1.4) (optional)
     * @param locations The list of locations to build the center around; comma separated list of latitude/longitude pairs (example: lat1,long1,lat2,long2) (optional)
     * @param radius The list of radius of influence for the audience, in miles; comma separated list. Either provide 1 to be applied to all location pairs or a matching list to each lat/long pair. (optional)
     * @param startTimeOffset Seconds from the start time of an event (optional)
     * @param endTimeOffset Seconds from the end time of an event (optional)
     * @param sendSuggestion If true, then notify matching users when they are inside the radius (optional, default to true)
     * @param associateDescription The description of the associated object (optional)
     * @param associateType The type of the object to center the audience geofence (optional)
     * @param associateId The ID of the object to center the audience geofence (optional)
     * @param groupingId Optional grouping id for the audience (optional)
     * @param metaData External custom client defined data (optional)
     * @param visibility Visibility of the audience (optional)
     * @param audienceType Type of audience (optional)
     * @param useOrder Use order for cohort (optional)
     * @param cohortRegionsData Cohort data for \&quot;cohort\&quot; audience type (optional)
     * @param appKey Filter results by application key (optional)
     * @param trilaterationTypes Trilateration types (optional)
     * @param uniqueName If true, makes sure the audience name is unique (optional)
     * @return RequestConfig
     */
    fun createAudienceRequestConfig(accountId: kotlin.Long, name: kotlin.String, description: kotlin.String?, searchTags: kotlin.String?, gender: kotlin.String?, ageGroups: kotlin.String?, categoryIds: kotlin.String?, applicationIds: kotlin.String?, gameExperienceLevel: kotlin.String?, devices: kotlin.String?, deviceIds: kotlin.String?, deviceVersions: kotlin.String?, locations: kotlin.String?, radius: kotlin.String?, startTimeOffset: kotlin.Int?, endTimeOffset: kotlin.Int?, sendSuggestion: kotlin.Boolean?, associateDescription: kotlin.String?, associateType: kotlin.String?, associateId: kotlin.Long?, groupingId: kotlin.String?, metaData: kotlin.String?, visibility: kotlin.String?, audienceType: kotlin.String?, useOrder: kotlin.Boolean?, cohortRegionsData: kotlin.String?, appKey: kotlin.String?, trilaterationTypes: kotlin.String?, uniqueName: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("name", listOf(name.toString()))
                if (description != null) {
                    put("description", listOf(description.toString()))
                }
                if (searchTags != null) {
                    put("searchTags", listOf(searchTags.toString()))
                }
                if (gender != null) {
                    put("gender", listOf(gender.toString()))
                }
                if (ageGroups != null) {
                    put("ageGroups", listOf(ageGroups.toString()))
                }
                if (categoryIds != null) {
                    put("categoryIds", listOf(categoryIds.toString()))
                }
                if (applicationIds != null) {
                    put("applicationIds", listOf(applicationIds.toString()))
                }
                if (gameExperienceLevel != null) {
                    put("gameExperienceLevel", listOf(gameExperienceLevel.toString()))
                }
                if (devices != null) {
                    put("devices", listOf(devices.toString()))
                }
                if (deviceIds != null) {
                    put("deviceIds", listOf(deviceIds.toString()))
                }
                if (deviceVersions != null) {
                    put("deviceVersions", listOf(deviceVersions.toString()))
                }
                if (locations != null) {
                    put("locations", listOf(locations.toString()))
                }
                if (radius != null) {
                    put("radius", listOf(radius.toString()))
                }
                if (startTimeOffset != null) {
                    put("startTimeOffset", listOf(startTimeOffset.toString()))
                }
                if (endTimeOffset != null) {
                    put("endTimeOffset", listOf(endTimeOffset.toString()))
                }
                if (sendSuggestion != null) {
                    put("sendSuggestion", listOf(sendSuggestion.toString()))
                }
                if (associateDescription != null) {
                    put("associateDescription", listOf(associateDescription.toString()))
                }
                if (associateType != null) {
                    put("associateType", listOf(associateType.toString()))
                }
                if (associateId != null) {
                    put("associateId", listOf(associateId.toString()))
                }
                if (groupingId != null) {
                    put("groupingId", listOf(groupingId.toString()))
                }
                if (metaData != null) {
                    put("metaData", listOf(metaData.toString()))
                }
                if (visibility != null) {
                    put("visibility", listOf(visibility.toString()))
                }
                if (audienceType != null) {
                    put("audienceType", listOf(audienceType.toString()))
                }
                if (useOrder != null) {
                    put("useOrder", listOf(useOrder.toString()))
                }
                if (cohortRegionsData != null) {
                    put("cohortRegionsData", listOf(cohortRegionsData.toString()))
                }
                if (appKey != null) {
                    put("appKey", listOf(appKey.toString()))
                }
                if (trilaterationTypes != null) {
                    put("trilaterationTypes", listOf(trilaterationTypes.toString()))
                }
                if (uniqueName != null) {
                    put("uniqueName", listOf(uniqueName.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/audience/create",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /audience/delete
     * Delete Audience
     * Delete an audience. The audience and account must be valid and have the appropirate permissions to view the content.
     * @param accountId The logged in user.
     * @param audienceId The id of the audience to delete.
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteAudience(accountId: kotlin.Long, audienceId: kotlin.Long) : SirqulResponse {
        val localVarResponse = deleteAudienceWithHttpInfo(accountId = accountId, audienceId = audienceId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /audience/delete
     * Delete Audience
     * Delete an audience. The audience and account must be valid and have the appropirate permissions to view the content.
     * @param accountId The logged in user.
     * @param audienceId The id of the audience to delete.
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteAudienceWithHttpInfo(accountId: kotlin.Long, audienceId: kotlin.Long) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = deleteAudienceRequestConfig(accountId = accountId, audienceId = audienceId)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteAudience
     *
     * @param accountId The logged in user.
     * @param audienceId The id of the audience to delete.
     * @return RequestConfig
     */
    fun deleteAudienceRequestConfig(accountId: kotlin.Long, audienceId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("audienceId", listOf(audienceId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/audience/delete",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /audience/ageGroups
     * Get Age Groups
     * Gets the list of available age groups that can be selected by consumers and retailers targeting offers.
     * @return kotlin.collections.List<AgeGroupResponse>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAgeGroups() : kotlin.collections.List<AgeGroupResponse> {
        val localVarResponse = getAgeGroupsWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<AgeGroupResponse>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /audience/ageGroups
     * Get Age Groups
     * Gets the list of available age groups that can be selected by consumers and retailers targeting offers.
     * @return ApiResponse<kotlin.collections.List<AgeGroupResponse>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getAgeGroupsWithHttpInfo() : ApiResponse<kotlin.collections.List<AgeGroupResponse>?> {
        val localVariableConfig = getAgeGroupsRequestConfig()

        return request<Unit, kotlin.collections.List<AgeGroupResponse>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAgeGroups
     *
     * @return RequestConfig
     */
    fun getAgeGroupsRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/audience/ageGroups",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /audience/get
     * Get Audience
     * Get an audience. The audience and account must be valid and have the appropriate permissions to view the content.
     * @param accountId The logged in user.
     * @param audienceId The id of the audience to return.
     * @param appKey The application key (optional). If provided, results may be scoped to this application. (optional)
     * @param returnAccountCount (boolean) set to true to include the accountCount associated with current audience of the current app (optional, default to false)
     * @param returnAlbumCount (boolean) set to true to include the albumCount associated with current audience of the current app (optional, default to false)
     * @param albumTypesForCount (String) comma separated list, return an array with each item is the count of each album type. If not provided, \&quot;all_types\&quot; count is returned. (optional)
     * @return AudienceResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAudience(accountId: kotlin.Long, audienceId: kotlin.Long, appKey: kotlin.String? = null, returnAccountCount: kotlin.Boolean? = false, returnAlbumCount: kotlin.Boolean? = false, albumTypesForCount: kotlin.String? = null) : AudienceResponse {
        val localVarResponse = getAudienceWithHttpInfo(accountId = accountId, audienceId = audienceId, appKey = appKey, returnAccountCount = returnAccountCount, returnAlbumCount = returnAlbumCount, albumTypesForCount = albumTypesForCount)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AudienceResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /audience/get
     * Get Audience
     * Get an audience. The audience and account must be valid and have the appropriate permissions to view the content.
     * @param accountId The logged in user.
     * @param audienceId The id of the audience to return.
     * @param appKey The application key (optional). If provided, results may be scoped to this application. (optional)
     * @param returnAccountCount (boolean) set to true to include the accountCount associated with current audience of the current app (optional, default to false)
     * @param returnAlbumCount (boolean) set to true to include the albumCount associated with current audience of the current app (optional, default to false)
     * @param albumTypesForCount (String) comma separated list, return an array with each item is the count of each album type. If not provided, \&quot;all_types\&quot; count is returned. (optional)
     * @return ApiResponse<AudienceResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getAudienceWithHttpInfo(accountId: kotlin.Long, audienceId: kotlin.Long, appKey: kotlin.String?, returnAccountCount: kotlin.Boolean?, returnAlbumCount: kotlin.Boolean?, albumTypesForCount: kotlin.String?) : ApiResponse<AudienceResponse?> {
        val localVariableConfig = getAudienceRequestConfig(accountId = accountId, audienceId = audienceId, appKey = appKey, returnAccountCount = returnAccountCount, returnAlbumCount = returnAlbumCount, albumTypesForCount = albumTypesForCount)

        return request<Unit, AudienceResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAudience
     *
     * @param accountId The logged in user.
     * @param audienceId The id of the audience to return.
     * @param appKey The application key (optional). If provided, results may be scoped to this application. (optional)
     * @param returnAccountCount (boolean) set to true to include the accountCount associated with current audience of the current app (optional, default to false)
     * @param returnAlbumCount (boolean) set to true to include the albumCount associated with current audience of the current app (optional, default to false)
     * @param albumTypesForCount (String) comma separated list, return an array with each item is the count of each album type. If not provided, \&quot;all_types\&quot; count is returned. (optional)
     * @return RequestConfig
     */
    fun getAudienceRequestConfig(accountId: kotlin.Long, audienceId: kotlin.Long, appKey: kotlin.String?, returnAccountCount: kotlin.Boolean?, returnAlbumCount: kotlin.Boolean?, albumTypesForCount: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("audienceId", listOf(audienceId.toString()))
                if (appKey != null) {
                    put("appKey", listOf(appKey.toString()))
                }
                if (returnAccountCount != null) {
                    put("returnAccountCount", listOf(returnAccountCount.toString()))
                }
                if (returnAlbumCount != null) {
                    put("returnAlbumCount", listOf(returnAlbumCount.toString()))
                }
                if (albumTypesForCount != null) {
                    put("albumTypesForCount", listOf(albumTypesForCount.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/audience/get",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter sortField
     */
     enum class SortFieldGetAudienceList(val value: kotlin.String) {
         @Json(name = "ID") ID("ID"),
         @Json(name = "CREATED") CREATED("CREATED"),
         @Json(name = "UPDATED") UPDATED("UPDATED"),
         @Json(name = "DELETED") DELETED("DELETED"),
         @Json(name = "SEARCH_TAGS") SEARCH_TAGS("SEARCH_TAGS"),
         @Json(name = "ACTIVE") ACTIVE("ACTIVE"),
         @Json(name = "NAME") NAME("NAME"),
         @Json(name = "DESCRIPTION") DESCRIPTION("DESCRIPTION"),
         @Json(name = "SEND_SUGGESTION") SEND_SUGGESTION("SEND_SUGGESTION"),
         @Json(name = "OWNER_ID") OWNER_ID("OWNER_ID"),
         @Json(name = "OWNER_DISPLAY") OWNER_DISPLAY("OWNER_DISPLAY"),
         @Json(name = "GENDER") GENDER("GENDER");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /audience/search
     * Search Audiences
     * Get the list audiences owned by the account
     * @param accountId The logged in user. (optional)
     * @param albumIds Comma separated list of album IDs to filter results with (optional)
     * @param keyword The keyword used to search (optional)
     * @param keywordFields Comma separated list of fields that the keywords will match against. Possible values include: SEARCH_TAGS, NAME, DESCRIPTION, OWNER_DISPLAY (optional, default to "SEARCH_TAGS,NAME,DESCRIPTION")
     * @param sortField The field to sort by, possible values include: {ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, NAME, DESCRIPTION, OWNER_ID, OWNER_DISPLAY, GENDER} (optional, default to SortField.NAME)
     * @param descending The order to return the results. Default is false, which will return the results in ascending order. (optional, default to false)
     * @param start The index into the record set to start with. (optional, default to 0)
     * @param limit The total number of record to return (there is a hard limit of 100). (optional, default to 20)
     * @param sendSuggestion Filter results based on whether or not the audience is set to send suggestions (optional)
     * @param activeOnly Determines whether to return only active results. Default is false. (optional)
     * @param groupByGroupingId Groups results by the audience groupingId (this does not work in conjunction with the following parameters: albumIds, audienceType, appKey, returnGlobal) (optional)
     * @param appKey Filter results by application key (optional)
     * @param returnGlobal If filtering by appKey, determines whether or not audiences that do not have an application set will also be returned as well (optional)
     * @param exactKeyword If true, match keyword exactly (optional)
     * @param audienceType (Deprecated) Filter results by audience type (optional)
     * @param audienceTypes comma separated string with the different audience types you want to filter for (optional)
     * @param returnAccountCount (boolean) set to true to include the accountCount associated with current audience of the current app (optional, default to false)
     * @param returnAlbumCount (boolean) set to true to include the albumCount associated with current audience of the current app (optional, default to false)
     * @param albumTypesForCount (String) comma separated list, return an array with each item is the count of each album type. If not provided, \&quot;all_types\&quot; count is returned. (optional)
     * @return kotlin.collections.List<SearchResponse>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAudienceList(accountId: kotlin.Long? = null, albumIds: kotlin.String? = null, keyword: kotlin.String? = null, keywordFields: kotlin.String? = "SEARCH_TAGS,NAME,DESCRIPTION", sortField: SortFieldGetAudienceList? = SortFieldGetAudienceList.NAME, descending: kotlin.Boolean? = false, start: kotlin.Int? = 0, limit: kotlin.Int? = 20, sendSuggestion: kotlin.Boolean? = null, activeOnly: kotlin.Boolean? = null, groupByGroupingId: kotlin.Boolean? = null, appKey: kotlin.String? = null, returnGlobal: kotlin.Boolean? = null, exactKeyword: kotlin.Boolean? = null, audienceType: kotlin.String? = null, audienceTypes: kotlin.String? = null, returnAccountCount: kotlin.Boolean? = false, returnAlbumCount: kotlin.Boolean? = false, albumTypesForCount: kotlin.String? = null) : kotlin.collections.List<SearchResponse> {
        val localVarResponse = getAudienceListWithHttpInfo(accountId = accountId, albumIds = albumIds, keyword = keyword, keywordFields = keywordFields, sortField = sortField, descending = descending, start = start, limit = limit, sendSuggestion = sendSuggestion, activeOnly = activeOnly, groupByGroupingId = groupByGroupingId, appKey = appKey, returnGlobal = returnGlobal, exactKeyword = exactKeyword, audienceType = audienceType, audienceTypes = audienceTypes, returnAccountCount = returnAccountCount, returnAlbumCount = returnAlbumCount, albumTypesForCount = albumTypesForCount)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<SearchResponse>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /audience/search
     * Search Audiences
     * Get the list audiences owned by the account
     * @param accountId The logged in user. (optional)
     * @param albumIds Comma separated list of album IDs to filter results with (optional)
     * @param keyword The keyword used to search (optional)
     * @param keywordFields Comma separated list of fields that the keywords will match against. Possible values include: SEARCH_TAGS, NAME, DESCRIPTION, OWNER_DISPLAY (optional, default to "SEARCH_TAGS,NAME,DESCRIPTION")
     * @param sortField The field to sort by, possible values include: {ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, NAME, DESCRIPTION, OWNER_ID, OWNER_DISPLAY, GENDER} (optional, default to SortField.NAME)
     * @param descending The order to return the results. Default is false, which will return the results in ascending order. (optional, default to false)
     * @param start The index into the record set to start with. (optional, default to 0)
     * @param limit The total number of record to return (there is a hard limit of 100). (optional, default to 20)
     * @param sendSuggestion Filter results based on whether or not the audience is set to send suggestions (optional)
     * @param activeOnly Determines whether to return only active results. Default is false. (optional)
     * @param groupByGroupingId Groups results by the audience groupingId (this does not work in conjunction with the following parameters: albumIds, audienceType, appKey, returnGlobal) (optional)
     * @param appKey Filter results by application key (optional)
     * @param returnGlobal If filtering by appKey, determines whether or not audiences that do not have an application set will also be returned as well (optional)
     * @param exactKeyword If true, match keyword exactly (optional)
     * @param audienceType (Deprecated) Filter results by audience type (optional)
     * @param audienceTypes comma separated string with the different audience types you want to filter for (optional)
     * @param returnAccountCount (boolean) set to true to include the accountCount associated with current audience of the current app (optional, default to false)
     * @param returnAlbumCount (boolean) set to true to include the albumCount associated with current audience of the current app (optional, default to false)
     * @param albumTypesForCount (String) comma separated list, return an array with each item is the count of each album type. If not provided, \&quot;all_types\&quot; count is returned. (optional)
     * @return ApiResponse<kotlin.collections.List<SearchResponse>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getAudienceListWithHttpInfo(accountId: kotlin.Long?, albumIds: kotlin.String?, keyword: kotlin.String?, keywordFields: kotlin.String?, sortField: SortFieldGetAudienceList?, descending: kotlin.Boolean?, start: kotlin.Int?, limit: kotlin.Int?, sendSuggestion: kotlin.Boolean?, activeOnly: kotlin.Boolean?, groupByGroupingId: kotlin.Boolean?, appKey: kotlin.String?, returnGlobal: kotlin.Boolean?, exactKeyword: kotlin.Boolean?, audienceType: kotlin.String?, audienceTypes: kotlin.String?, returnAccountCount: kotlin.Boolean?, returnAlbumCount: kotlin.Boolean?, albumTypesForCount: kotlin.String?) : ApiResponse<kotlin.collections.List<SearchResponse>?> {
        val localVariableConfig = getAudienceListRequestConfig(accountId = accountId, albumIds = albumIds, keyword = keyword, keywordFields = keywordFields, sortField = sortField, descending = descending, start = start, limit = limit, sendSuggestion = sendSuggestion, activeOnly = activeOnly, groupByGroupingId = groupByGroupingId, appKey = appKey, returnGlobal = returnGlobal, exactKeyword = exactKeyword, audienceType = audienceType, audienceTypes = audienceTypes, returnAccountCount = returnAccountCount, returnAlbumCount = returnAlbumCount, albumTypesForCount = albumTypesForCount)

        return request<Unit, kotlin.collections.List<SearchResponse>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAudienceList
     *
     * @param accountId The logged in user. (optional)
     * @param albumIds Comma separated list of album IDs to filter results with (optional)
     * @param keyword The keyword used to search (optional)
     * @param keywordFields Comma separated list of fields that the keywords will match against. Possible values include: SEARCH_TAGS, NAME, DESCRIPTION, OWNER_DISPLAY (optional, default to "SEARCH_TAGS,NAME,DESCRIPTION")
     * @param sortField The field to sort by, possible values include: {ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, NAME, DESCRIPTION, OWNER_ID, OWNER_DISPLAY, GENDER} (optional, default to SortField.NAME)
     * @param descending The order to return the results. Default is false, which will return the results in ascending order. (optional, default to false)
     * @param start The index into the record set to start with. (optional, default to 0)
     * @param limit The total number of record to return (there is a hard limit of 100). (optional, default to 20)
     * @param sendSuggestion Filter results based on whether or not the audience is set to send suggestions (optional)
     * @param activeOnly Determines whether to return only active results. Default is false. (optional)
     * @param groupByGroupingId Groups results by the audience groupingId (this does not work in conjunction with the following parameters: albumIds, audienceType, appKey, returnGlobal) (optional)
     * @param appKey Filter results by application key (optional)
     * @param returnGlobal If filtering by appKey, determines whether or not audiences that do not have an application set will also be returned as well (optional)
     * @param exactKeyword If true, match keyword exactly (optional)
     * @param audienceType (Deprecated) Filter results by audience type (optional)
     * @param audienceTypes comma separated string with the different audience types you want to filter for (optional)
     * @param returnAccountCount (boolean) set to true to include the accountCount associated with current audience of the current app (optional, default to false)
     * @param returnAlbumCount (boolean) set to true to include the albumCount associated with current audience of the current app (optional, default to false)
     * @param albumTypesForCount (String) comma separated list, return an array with each item is the count of each album type. If not provided, \&quot;all_types\&quot; count is returned. (optional)
     * @return RequestConfig
     */
    fun getAudienceListRequestConfig(accountId: kotlin.Long?, albumIds: kotlin.String?, keyword: kotlin.String?, keywordFields: kotlin.String?, sortField: SortFieldGetAudienceList?, descending: kotlin.Boolean?, start: kotlin.Int?, limit: kotlin.Int?, sendSuggestion: kotlin.Boolean?, activeOnly: kotlin.Boolean?, groupByGroupingId: kotlin.Boolean?, appKey: kotlin.String?, returnGlobal: kotlin.Boolean?, exactKeyword: kotlin.Boolean?, audienceType: kotlin.String?, audienceTypes: kotlin.String?, returnAccountCount: kotlin.Boolean?, returnAlbumCount: kotlin.Boolean?, albumTypesForCount: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (albumIds != null) {
                    put("albumIds", listOf(albumIds.toString()))
                }
                if (keyword != null) {
                    put("keyword", listOf(keyword.toString()))
                }
                if (keywordFields != null) {
                    put("keywordFields", listOf(keywordFields.toString()))
                }
                if (sortField != null) {
                    put("sortField", listOf(sortField.value))
                }
                if (descending != null) {
                    put("descending", listOf(descending.toString()))
                }
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sendSuggestion != null) {
                    put("sendSuggestion", listOf(sendSuggestion.toString()))
                }
                if (activeOnly != null) {
                    put("activeOnly", listOf(activeOnly.toString()))
                }
                if (groupByGroupingId != null) {
                    put("groupByGroupingId", listOf(groupByGroupingId.toString()))
                }
                if (appKey != null) {
                    put("appKey", listOf(appKey.toString()))
                }
                if (returnGlobal != null) {
                    put("returnGlobal", listOf(returnGlobal.toString()))
                }
                if (exactKeyword != null) {
                    put("exactKeyword", listOf(exactKeyword.toString()))
                }
                if (audienceType != null) {
                    put("audienceType", listOf(audienceType.toString()))
                }
                if (audienceTypes != null) {
                    put("audienceTypes", listOf(audienceTypes.toString()))
                }
                if (returnAccountCount != null) {
                    put("returnAccountCount", listOf(returnAccountCount.toString()))
                }
                if (returnAlbumCount != null) {
                    put("returnAlbumCount", listOf(returnAlbumCount.toString()))
                }
                if (albumTypesForCount != null) {
                    put("albumTypesForCount", listOf(albumTypesForCount.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/audience/search",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /audience/devices
     * Get Devices
     * Gets the list of available devices that can be selected by consumers and retailers.
     * @param includeInactive If true return inactive record as well. default is false.
     * @return kotlin.collections.List<AudienceDeviceResponse>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getDevices(includeInactive: kotlin.Boolean) : kotlin.collections.List<AudienceDeviceResponse> {
        val localVarResponse = getDevicesWithHttpInfo(includeInactive = includeInactive)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<AudienceDeviceResponse>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /audience/devices
     * Get Devices
     * Gets the list of available devices that can be selected by consumers and retailers.
     * @param includeInactive If true return inactive record as well. default is false.
     * @return ApiResponse<kotlin.collections.List<AudienceDeviceResponse>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getDevicesWithHttpInfo(includeInactive: kotlin.Boolean) : ApiResponse<kotlin.collections.List<AudienceDeviceResponse>?> {
        val localVariableConfig = getDevicesRequestConfig(includeInactive = includeInactive)

        return request<Unit, kotlin.collections.List<AudienceDeviceResponse>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getDevices
     *
     * @param includeInactive If true return inactive record as well. default is false.
     * @return RequestConfig
     */
    fun getDevicesRequestConfig(includeInactive: kotlin.Boolean) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("includeInactive", listOf(includeInactive.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/audience/devices",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /audience/experiences
     * Get Experiences
     * Gets the list of available experiences that can be selected by consumers and retailers.
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getExperiences() : SirqulResponse {
        val localVarResponse = getExperiencesWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /audience/experiences
     * Get Experiences
     * Gets the list of available experiences that can be selected by consumers and retailers.
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getExperiencesWithHttpInfo() : ApiResponse<SirqulResponse?> {
        val localVariableConfig = getExperiencesRequestConfig()

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getExperiences
     *
     * @return RequestConfig
     */
    fun getExperiencesRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/audience/experiences",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /audience/grouped/get
     * Get GroupedAudiences
     * Get a group of audiences. The audience and account must be valid and have the appropriate permissions to view the content.
     * @param accountId The logged in user.
     * @param audienceGroupingId The audience grouping id to return.
     * @return AudienceResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getGroupedAudiences(accountId: kotlin.Long, audienceGroupingId: kotlin.String) : AudienceResponse {
        val localVarResponse = getGroupedAudiencesWithHttpInfo(accountId = accountId, audienceGroupingId = audienceGroupingId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AudienceResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /audience/grouped/get
     * Get GroupedAudiences
     * Get a group of audiences. The audience and account must be valid and have the appropriate permissions to view the content.
     * @param accountId The logged in user.
     * @param audienceGroupingId The audience grouping id to return.
     * @return ApiResponse<AudienceResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getGroupedAudiencesWithHttpInfo(accountId: kotlin.Long, audienceGroupingId: kotlin.String) : ApiResponse<AudienceResponse?> {
        val localVariableConfig = getGroupedAudiencesRequestConfig(accountId = accountId, audienceGroupingId = audienceGroupingId)

        return request<Unit, AudienceResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getGroupedAudiences
     *
     * @param accountId The logged in user.
     * @param audienceGroupingId The audience grouping id to return.
     * @return RequestConfig
     */
    fun getGroupedAudiencesRequestConfig(accountId: kotlin.Long, audienceGroupingId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("audienceGroupingId", listOf(audienceGroupingId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/audience/grouped/get",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /audience/suggestion/list
     * List Suggestions by Audience
     * List either Missions or Offers that the user matches the assigned audience.
     * @param accountId The account to match offers for.
     * @param limit the limit of the index
     * @param suggestionType the type of suggestion
     * @return OfferListResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listByAccount(accountId: kotlin.Long, limit: kotlin.Int, suggestionType: kotlin.String) : OfferListResponse {
        val localVarResponse = listByAccountWithHttpInfo(accountId = accountId, limit = limit, suggestionType = suggestionType)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OfferListResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /audience/suggestion/list
     * List Suggestions by Audience
     * List either Missions or Offers that the user matches the assigned audience.
     * @param accountId The account to match offers for.
     * @param limit the limit of the index
     * @param suggestionType the type of suggestion
     * @return ApiResponse<OfferListResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listByAccountWithHttpInfo(accountId: kotlin.Long, limit: kotlin.Int, suggestionType: kotlin.String) : ApiResponse<OfferListResponse?> {
        val localVariableConfig = listByAccountRequestConfig(accountId = accountId, limit = limit, suggestionType = suggestionType)

        return request<Unit, OfferListResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listByAccount
     *
     * @param accountId The account to match offers for.
     * @param limit the limit of the index
     * @param suggestionType the type of suggestion
     * @return RequestConfig
     */
    fun listByAccountRequestConfig(accountId: kotlin.Long, limit: kotlin.Int, suggestionType: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("limit", listOf(limit.toString()))
                put("suggestionType", listOf(suggestionType.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/audience/suggestion/list",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /audience/suggestion/offersByAudience
     * List Offers by Audience
     * Get a list of offer locations based on audience information provided.
     * @param limit this is the limit of the index
     * @param gender this is the gender to list offers by (optional)
     * @param age this is the age to list offers by (optional)
     * @param categoryIds this is the category IDs to list offers by (optional)
     * @param latitude this is the latitude to list offers by (optional)
     * @param longitude this is the longitude to list offers by (optional)
     * @return OfferListResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listByAudience(limit: kotlin.Int, gender: kotlin.String? = null, age: kotlin.Int? = null, categoryIds: kotlin.String? = null, latitude: kotlin.Double? = null, longitude: kotlin.Double? = null) : OfferListResponse {
        val localVarResponse = listByAudienceWithHttpInfo(limit = limit, gender = gender, age = age, categoryIds = categoryIds, latitude = latitude, longitude = longitude)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OfferListResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /audience/suggestion/offersByAudience
     * List Offers by Audience
     * Get a list of offer locations based on audience information provided.
     * @param limit this is the limit of the index
     * @param gender this is the gender to list offers by (optional)
     * @param age this is the age to list offers by (optional)
     * @param categoryIds this is the category IDs to list offers by (optional)
     * @param latitude this is the latitude to list offers by (optional)
     * @param longitude this is the longitude to list offers by (optional)
     * @return ApiResponse<OfferListResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listByAudienceWithHttpInfo(limit: kotlin.Int, gender: kotlin.String?, age: kotlin.Int?, categoryIds: kotlin.String?, latitude: kotlin.Double?, longitude: kotlin.Double?) : ApiResponse<OfferListResponse?> {
        val localVariableConfig = listByAudienceRequestConfig(limit = limit, gender = gender, age = age, categoryIds = categoryIds, latitude = latitude, longitude = longitude)

        return request<Unit, OfferListResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listByAudience
     *
     * @param limit this is the limit of the index
     * @param gender this is the gender to list offers by (optional)
     * @param age this is the age to list offers by (optional)
     * @param categoryIds this is the category IDs to list offers by (optional)
     * @param latitude this is the latitude to list offers by (optional)
     * @param longitude this is the longitude to list offers by (optional)
     * @return RequestConfig
     */
    fun listByAudienceRequestConfig(limit: kotlin.Int, gender: kotlin.String?, age: kotlin.Int?, categoryIds: kotlin.String?, latitude: kotlin.Double?, longitude: kotlin.Double?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (gender != null) {
                    put("gender", listOf(gender.toString()))
                }
                if (age != null) {
                    put("age", listOf(age.toString()))
                }
                if (categoryIds != null) {
                    put("categoryIds", listOf(categoryIds.toString()))
                }
                if (latitude != null) {
                    put("latitude", listOf(latitude.toString()))
                }
                if (longitude != null) {
                    put("longitude", listOf(longitude.toString()))
                }
                put("limit", listOf(limit.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/audience/suggestion/offersByAudience",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /audience/suggestion/latest
     * List Sent Suggestions 
     * Return list of recent trigger suggestions that have been sent to the user.
     * @param accountId The account to match offers for.
     * @param timeframe The timeframe in seconds of the latest suggestions
     * @param suggestionType The type of trigger suggestions to return
     * @return OfferListResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listLastestByAccount(accountId: kotlin.Long, timeframe: kotlin.Int, suggestionType: kotlin.String) : OfferListResponse {
        val localVarResponse = listLastestByAccountWithHttpInfo(accountId = accountId, timeframe = timeframe, suggestionType = suggestionType)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OfferListResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /audience/suggestion/latest
     * List Sent Suggestions 
     * Return list of recent trigger suggestions that have been sent to the user.
     * @param accountId The account to match offers for.
     * @param timeframe The timeframe in seconds of the latest suggestions
     * @param suggestionType The type of trigger suggestions to return
     * @return ApiResponse<OfferListResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listLastestByAccountWithHttpInfo(accountId: kotlin.Long, timeframe: kotlin.Int, suggestionType: kotlin.String) : ApiResponse<OfferListResponse?> {
        val localVariableConfig = listLastestByAccountRequestConfig(accountId = accountId, timeframe = timeframe, suggestionType = suggestionType)

        return request<Unit, OfferListResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listLastestByAccount
     *
     * @param accountId The account to match offers for.
     * @param timeframe The timeframe in seconds of the latest suggestions
     * @param suggestionType The type of trigger suggestions to return
     * @return RequestConfig
     */
    fun listLastestByAccountRequestConfig(accountId: kotlin.Long, timeframe: kotlin.Int, suggestionType: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("timeframe", listOf(timeframe.toString()))
                put("suggestionType", listOf(suggestionType.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/audience/suggestion/latest",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /audience/suggestion/send
     * Send Suggestions
     * Use the accountId to determine the associated BillableEntity. From there get a list of all triggers associated with the BillableEntity.
     * @param accountId The account to match offers for.
     * @param latitude the latitude
     * @param longitude the longitude
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sendByAccount(accountId: kotlin.Long, latitude: kotlin.Double, longitude: kotlin.Double) : SirqulResponse {
        val localVarResponse = sendByAccountWithHttpInfo(accountId = accountId, latitude = latitude, longitude = longitude)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /audience/suggestion/send
     * Send Suggestions
     * Use the accountId to determine the associated BillableEntity. From there get a list of all triggers associated with the BillableEntity.
     * @param accountId The account to match offers for.
     * @param latitude the latitude
     * @param longitude the longitude
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sendByAccountWithHttpInfo(accountId: kotlin.Long, latitude: kotlin.Double, longitude: kotlin.Double) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = sendByAccountRequestConfig(accountId = accountId, latitude = latitude, longitude = longitude)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sendByAccount
     *
     * @param accountId The account to match offers for.
     * @param latitude the latitude
     * @param longitude the longitude
     * @return RequestConfig
     */
    fun sendByAccountRequestConfig(accountId: kotlin.Long, latitude: kotlin.Double, longitude: kotlin.Double) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("latitude", listOf(latitude.toString()))
                put("longitude", listOf(longitude.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/audience/suggestion/send",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /audience/update
     * Update Audience
     * Update a user defined audience.
     * @param accountId The logged in user.
     * @param audienceId The id of the audience to update.
     * @param name The name of the audience (optional)
     * @param description The description of the audience (optional)
     * @param searchTags The search tags (optional)
     * @param gender The gender; possible values are: MALE, FEMALE, ANY (optional)
     * @param ageGroups The list of age groups, comma separated; possible values are AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS, AGE_ANY (to reset to none) (optional)
     * @param categoryIds The list of category ids, comma separated; possible values are retrieved via /api/{version}/category/search (pass in id values) (optional)
     * @param applicationIds The list of application ids, comma separated; possible values are retrieved via /api/{version}/application/list (pass in id values) (optional)
     * @param gameExperienceLevel The experience level of the player; possible values are: ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT (optional)
     * @param devices (Deprecated) Use deviceIds. The list of targeted device names, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in name values) (optional)
     * @param deviceIds The list of targeted device ids, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in id values) (optional)
     * @param deviceVersions The list of targeted device version ranges that are aligned with the provided devices list, comma separated (examples: 2.3-X, 0-5.1.4, 4.3.1-6.1.4) (optional)
     * @param locations The list of locations to build the center around; comma separated list of latitude/longitude pairs (example: lat1,long1,lat2,long2) (optional)
     * @param radius The list of radius of influence for the audience, in miles; comma separated list. Either provide 1 to be applied to all location pairs or a matching list to each lat/long pair. (optional)
     * @param active if audience is active (optional)
     * @param sendSuggestion If true, then notify matching users when they are inside the radius (optional)
     * @param startTimeOffset Seconds from the start time of an event (optional)
     * @param endTimeOffset Seconds from the end time of an event (optional)
     * @param associateDescription the associate description (optional)
     * @param associateType The type of the object to center the audience geofence (optional)
     * @param associateId The ID of the object to center the audience geofence (optional)
     * @param groupingId Optional grouping id for the audience (optional)
     * @param metaData External custom client defined data (optional)
     * @param visibility Visibility of the audience (optional)
     * @param audienceType Type of audience (optional)
     * @param useOrder Use order for cohort (optional)
     * @param cohortRegionsData Cohort data for \&quot;cohort\&quot; audience type (optional)
     * @param appKey Filter results by application key (optional)
     * @param trilaterationTypes Trilateration types (optional)
     * @param uniqueName If true, makes sure the audience name is unique (optional)
     * @return AudienceResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updateAudience(accountId: kotlin.Long, audienceId: kotlin.Long, name: kotlin.String? = null, description: kotlin.String? = null, searchTags: kotlin.String? = null, gender: kotlin.String? = null, ageGroups: kotlin.String? = null, categoryIds: kotlin.String? = null, applicationIds: kotlin.String? = null, gameExperienceLevel: kotlin.String? = null, devices: kotlin.String? = null, deviceIds: kotlin.String? = null, deviceVersions: kotlin.String? = null, locations: kotlin.String? = null, radius: kotlin.String? = null, active: kotlin.Boolean? = null, sendSuggestion: kotlin.Boolean? = null, startTimeOffset: kotlin.Int? = null, endTimeOffset: kotlin.Int? = null, associateDescription: kotlin.String? = null, associateType: kotlin.String? = null, associateId: kotlin.Long? = null, groupingId: kotlin.String? = null, metaData: kotlin.String? = null, visibility: kotlin.String? = null, audienceType: kotlin.String? = null, useOrder: kotlin.Boolean? = null, cohortRegionsData: kotlin.String? = null, appKey: kotlin.String? = null, trilaterationTypes: kotlin.String? = null, uniqueName: kotlin.Boolean? = null) : AudienceResponse {
        val localVarResponse = updateAudienceWithHttpInfo(accountId = accountId, audienceId = audienceId, name = name, description = description, searchTags = searchTags, gender = gender, ageGroups = ageGroups, categoryIds = categoryIds, applicationIds = applicationIds, gameExperienceLevel = gameExperienceLevel, devices = devices, deviceIds = deviceIds, deviceVersions = deviceVersions, locations = locations, radius = radius, active = active, sendSuggestion = sendSuggestion, startTimeOffset = startTimeOffset, endTimeOffset = endTimeOffset, associateDescription = associateDescription, associateType = associateType, associateId = associateId, groupingId = groupingId, metaData = metaData, visibility = visibility, audienceType = audienceType, useOrder = useOrder, cohortRegionsData = cohortRegionsData, appKey = appKey, trilaterationTypes = trilaterationTypes, uniqueName = uniqueName)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AudienceResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /audience/update
     * Update Audience
     * Update a user defined audience.
     * @param accountId The logged in user.
     * @param audienceId The id of the audience to update.
     * @param name The name of the audience (optional)
     * @param description The description of the audience (optional)
     * @param searchTags The search tags (optional)
     * @param gender The gender; possible values are: MALE, FEMALE, ANY (optional)
     * @param ageGroups The list of age groups, comma separated; possible values are AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS, AGE_ANY (to reset to none) (optional)
     * @param categoryIds The list of category ids, comma separated; possible values are retrieved via /api/{version}/category/search (pass in id values) (optional)
     * @param applicationIds The list of application ids, comma separated; possible values are retrieved via /api/{version}/application/list (pass in id values) (optional)
     * @param gameExperienceLevel The experience level of the player; possible values are: ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT (optional)
     * @param devices (Deprecated) Use deviceIds. The list of targeted device names, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in name values) (optional)
     * @param deviceIds The list of targeted device ids, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in id values) (optional)
     * @param deviceVersions The list of targeted device version ranges that are aligned with the provided devices list, comma separated (examples: 2.3-X, 0-5.1.4, 4.3.1-6.1.4) (optional)
     * @param locations The list of locations to build the center around; comma separated list of latitude/longitude pairs (example: lat1,long1,lat2,long2) (optional)
     * @param radius The list of radius of influence for the audience, in miles; comma separated list. Either provide 1 to be applied to all location pairs or a matching list to each lat/long pair. (optional)
     * @param active if audience is active (optional)
     * @param sendSuggestion If true, then notify matching users when they are inside the radius (optional)
     * @param startTimeOffset Seconds from the start time of an event (optional)
     * @param endTimeOffset Seconds from the end time of an event (optional)
     * @param associateDescription the associate description (optional)
     * @param associateType The type of the object to center the audience geofence (optional)
     * @param associateId The ID of the object to center the audience geofence (optional)
     * @param groupingId Optional grouping id for the audience (optional)
     * @param metaData External custom client defined data (optional)
     * @param visibility Visibility of the audience (optional)
     * @param audienceType Type of audience (optional)
     * @param useOrder Use order for cohort (optional)
     * @param cohortRegionsData Cohort data for \&quot;cohort\&quot; audience type (optional)
     * @param appKey Filter results by application key (optional)
     * @param trilaterationTypes Trilateration types (optional)
     * @param uniqueName If true, makes sure the audience name is unique (optional)
     * @return ApiResponse<AudienceResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun updateAudienceWithHttpInfo(accountId: kotlin.Long, audienceId: kotlin.Long, name: kotlin.String?, description: kotlin.String?, searchTags: kotlin.String?, gender: kotlin.String?, ageGroups: kotlin.String?, categoryIds: kotlin.String?, applicationIds: kotlin.String?, gameExperienceLevel: kotlin.String?, devices: kotlin.String?, deviceIds: kotlin.String?, deviceVersions: kotlin.String?, locations: kotlin.String?, radius: kotlin.String?, active: kotlin.Boolean?, sendSuggestion: kotlin.Boolean?, startTimeOffset: kotlin.Int?, endTimeOffset: kotlin.Int?, associateDescription: kotlin.String?, associateType: kotlin.String?, associateId: kotlin.Long?, groupingId: kotlin.String?, metaData: kotlin.String?, visibility: kotlin.String?, audienceType: kotlin.String?, useOrder: kotlin.Boolean?, cohortRegionsData: kotlin.String?, appKey: kotlin.String?, trilaterationTypes: kotlin.String?, uniqueName: kotlin.Boolean?) : ApiResponse<AudienceResponse?> {
        val localVariableConfig = updateAudienceRequestConfig(accountId = accountId, audienceId = audienceId, name = name, description = description, searchTags = searchTags, gender = gender, ageGroups = ageGroups, categoryIds = categoryIds, applicationIds = applicationIds, gameExperienceLevel = gameExperienceLevel, devices = devices, deviceIds = deviceIds, deviceVersions = deviceVersions, locations = locations, radius = radius, active = active, sendSuggestion = sendSuggestion, startTimeOffset = startTimeOffset, endTimeOffset = endTimeOffset, associateDescription = associateDescription, associateType = associateType, associateId = associateId, groupingId = groupingId, metaData = metaData, visibility = visibility, audienceType = audienceType, useOrder = useOrder, cohortRegionsData = cohortRegionsData, appKey = appKey, trilaterationTypes = trilaterationTypes, uniqueName = uniqueName)

        return request<Unit, AudienceResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateAudience
     *
     * @param accountId The logged in user.
     * @param audienceId The id of the audience to update.
     * @param name The name of the audience (optional)
     * @param description The description of the audience (optional)
     * @param searchTags The search tags (optional)
     * @param gender The gender; possible values are: MALE, FEMALE, ANY (optional)
     * @param ageGroups The list of age groups, comma separated; possible values are AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS, AGE_ANY (to reset to none) (optional)
     * @param categoryIds The list of category ids, comma separated; possible values are retrieved via /api/{version}/category/search (pass in id values) (optional)
     * @param applicationIds The list of application ids, comma separated; possible values are retrieved via /api/{version}/application/list (pass in id values) (optional)
     * @param gameExperienceLevel The experience level of the player; possible values are: ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT (optional)
     * @param devices (Deprecated) Use deviceIds. The list of targeted device names, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in name values) (optional)
     * @param deviceIds The list of targeted device ids, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in id values) (optional)
     * @param deviceVersions The list of targeted device version ranges that are aligned with the provided devices list, comma separated (examples: 2.3-X, 0-5.1.4, 4.3.1-6.1.4) (optional)
     * @param locations The list of locations to build the center around; comma separated list of latitude/longitude pairs (example: lat1,long1,lat2,long2) (optional)
     * @param radius The list of radius of influence for the audience, in miles; comma separated list. Either provide 1 to be applied to all location pairs or a matching list to each lat/long pair. (optional)
     * @param active if audience is active (optional)
     * @param sendSuggestion If true, then notify matching users when they are inside the radius (optional)
     * @param startTimeOffset Seconds from the start time of an event (optional)
     * @param endTimeOffset Seconds from the end time of an event (optional)
     * @param associateDescription the associate description (optional)
     * @param associateType The type of the object to center the audience geofence (optional)
     * @param associateId The ID of the object to center the audience geofence (optional)
     * @param groupingId Optional grouping id for the audience (optional)
     * @param metaData External custom client defined data (optional)
     * @param visibility Visibility of the audience (optional)
     * @param audienceType Type of audience (optional)
     * @param useOrder Use order for cohort (optional)
     * @param cohortRegionsData Cohort data for \&quot;cohort\&quot; audience type (optional)
     * @param appKey Filter results by application key (optional)
     * @param trilaterationTypes Trilateration types (optional)
     * @param uniqueName If true, makes sure the audience name is unique (optional)
     * @return RequestConfig
     */
    fun updateAudienceRequestConfig(accountId: kotlin.Long, audienceId: kotlin.Long, name: kotlin.String?, description: kotlin.String?, searchTags: kotlin.String?, gender: kotlin.String?, ageGroups: kotlin.String?, categoryIds: kotlin.String?, applicationIds: kotlin.String?, gameExperienceLevel: kotlin.String?, devices: kotlin.String?, deviceIds: kotlin.String?, deviceVersions: kotlin.String?, locations: kotlin.String?, radius: kotlin.String?, active: kotlin.Boolean?, sendSuggestion: kotlin.Boolean?, startTimeOffset: kotlin.Int?, endTimeOffset: kotlin.Int?, associateDescription: kotlin.String?, associateType: kotlin.String?, associateId: kotlin.Long?, groupingId: kotlin.String?, metaData: kotlin.String?, visibility: kotlin.String?, audienceType: kotlin.String?, useOrder: kotlin.Boolean?, cohortRegionsData: kotlin.String?, appKey: kotlin.String?, trilaterationTypes: kotlin.String?, uniqueName: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("audienceId", listOf(audienceId.toString()))
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (description != null) {
                    put("description", listOf(description.toString()))
                }
                if (searchTags != null) {
                    put("searchTags", listOf(searchTags.toString()))
                }
                if (gender != null) {
                    put("gender", listOf(gender.toString()))
                }
                if (ageGroups != null) {
                    put("ageGroups", listOf(ageGroups.toString()))
                }
                if (categoryIds != null) {
                    put("categoryIds", listOf(categoryIds.toString()))
                }
                if (applicationIds != null) {
                    put("applicationIds", listOf(applicationIds.toString()))
                }
                if (gameExperienceLevel != null) {
                    put("gameExperienceLevel", listOf(gameExperienceLevel.toString()))
                }
                if (devices != null) {
                    put("devices", listOf(devices.toString()))
                }
                if (deviceIds != null) {
                    put("deviceIds", listOf(deviceIds.toString()))
                }
                if (deviceVersions != null) {
                    put("deviceVersions", listOf(deviceVersions.toString()))
                }
                if (locations != null) {
                    put("locations", listOf(locations.toString()))
                }
                if (radius != null) {
                    put("radius", listOf(radius.toString()))
                }
                if (active != null) {
                    put("active", listOf(active.toString()))
                }
                if (sendSuggestion != null) {
                    put("sendSuggestion", listOf(sendSuggestion.toString()))
                }
                if (startTimeOffset != null) {
                    put("startTimeOffset", listOf(startTimeOffset.toString()))
                }
                if (endTimeOffset != null) {
                    put("endTimeOffset", listOf(endTimeOffset.toString()))
                }
                if (associateDescription != null) {
                    put("associateDescription", listOf(associateDescription.toString()))
                }
                if (associateType != null) {
                    put("associateType", listOf(associateType.toString()))
                }
                if (associateId != null) {
                    put("associateId", listOf(associateId.toString()))
                }
                if (groupingId != null) {
                    put("groupingId", listOf(groupingId.toString()))
                }
                if (metaData != null) {
                    put("metaData", listOf(metaData.toString()))
                }
                if (visibility != null) {
                    put("visibility", listOf(visibility.toString()))
                }
                if (audienceType != null) {
                    put("audienceType", listOf(audienceType.toString()))
                }
                if (useOrder != null) {
                    put("useOrder", listOf(useOrder.toString()))
                }
                if (cohortRegionsData != null) {
                    put("cohortRegionsData", listOf(cohortRegionsData.toString()))
                }
                if (appKey != null) {
                    put("appKey", listOf(appKey.toString()))
                }
                if (trilaterationTypes != null) {
                    put("trilaterationTypes", listOf(trilaterationTypes.toString()))
                }
                if (uniqueName != null) {
                    put("uniqueName", listOf(uniqueName.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/audience/update",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
