/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import org.openapitools.client.models.NoteResponse
import org.openapitools.client.models.SirqulResponse

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

open class NoteApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://dev.sirqul.com/api/3.18")
        }
    }

    /**
     * POST /note/batch
     * Batch Note Operation
     * Perform a batch operation on notes for a notable object (for example: DELETE_ALL_NOTES_IN_NOTABLE). 
     * @param notableId The id of the notable object the batch operation will affect
     * @param notableType The notable object type (for example ALBUM, ASSET, OFFER, etc.)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param batchOperation The batch operation to perform (e.g., DELETE_ALL_NOTES_IN_NOTABLE). Optional. (optional)
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun batchOperation(notableId: kotlin.Long, notableType: kotlin.String, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, batchOperation: kotlin.String? = null) : SirqulResponse {
        val localVarResponse = batchOperationWithHttpInfo(notableId = notableId, notableType = notableType, deviceId = deviceId, accountId = accountId, batchOperation = batchOperation)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /note/batch
     * Batch Note Operation
     * Perform a batch operation on notes for a notable object (for example: DELETE_ALL_NOTES_IN_NOTABLE). 
     * @param notableId The id of the notable object the batch operation will affect
     * @param notableType The notable object type (for example ALBUM, ASSET, OFFER, etc.)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param batchOperation The batch operation to perform (e.g., DELETE_ALL_NOTES_IN_NOTABLE). Optional. (optional)
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun batchOperationWithHttpInfo(notableId: kotlin.Long, notableType: kotlin.String, deviceId: kotlin.String?, accountId: kotlin.Long?, batchOperation: kotlin.String?) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = batchOperationRequestConfig(notableId = notableId, notableType = notableType, deviceId = deviceId, accountId = accountId, batchOperation = batchOperation)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation batchOperation
     *
     * @param notableId The id of the notable object the batch operation will affect
     * @param notableType The notable object type (for example ALBUM, ASSET, OFFER, etc.)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param batchOperation The batch operation to perform (e.g., DELETE_ALL_NOTES_IN_NOTABLE). Optional. (optional)
     * @return RequestConfig
     */
    fun batchOperationRequestConfig(notableId: kotlin.Long, notableType: kotlin.String, deviceId: kotlin.String?, accountId: kotlin.Long?, batchOperation: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                put("notableId", listOf(notableId.toString()))
                put("notableType", listOf(notableType.toString()))
                if (batchOperation != null) {
                    put("batchOperation", listOf(batchOperation.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/note/batch",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /note/create
     * Create Note
     * This is used to leave a comment (note) on a notable object (i.e. albums, album contests, assets, game levels, offers, offer locations, retailers, retailer locations, and theme descriptors). Leaving a comment on a notable object will be visiable to everyone who has access to view the object.
     * @param comment The message the user wishes to leave a comment on
     * @param deviceId The unique device identifier that made the request (either deviceId or accountId must be used) (optional)
     * @param accountId The unique accountId that made the request (either deviceId or accountId must be used) (optional)
     * @param notableType The notable object type {ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, OFFER, OFFER_LOCATION, RETAILER, RETAILER_LOCATION, THEME_DESCRIPTOR} (optional)
     * @param notableId The id of the notable object (optional)
     * @param noteType The custom string defined by the client (used for differentiating various note types) (optional)
     * @param assetIds A comma separated list of asset IDs to add with the note (optional)
     * @param tags search tags (optional)
     * @param permissionableType This is used for sending out group notifications. For example, when someone adds a note to an asset which is also a part of an album, everyone in the album will receive a notification. This is achieved by passing in the permissionable type (in this case \&quot;album\&quot;), and the permissionable id (the album id). Possible types: {ALBUM, ALBUM_CONTEST, GAME_LEVEL, THEME_DESCRIPTOR} (optional)
     * @param permissionableId The id of the permissionable object (for sending group notifications) (optional)
     * @param appKey The application key used to identify the application (optional)
     * @param locationDescription The description of the location (optional)
     * @param latitude The current location of the user (optional)
     * @param longitude The current location of the user (optional)
     * @param metaData External custom client defined data (optional)
     * @param receiverAccountIds Comma separated list of additional account IDs that will receive the note notifications (optional)
     * @param returnFullResponse whether to return the full response or not (optional)
     * @param initializeAsset Check true if need to initialize an asset and assign to current note (optional)
     * @param assetReturnNulls Return null fields for asset response when creating an asset (optional)
     * @param assetAlbumId the album the asset will be added to (optional) (optional)
     * @param assetCollectionId the collection ID that the asset is associated with (optional)
     * @param assetAddToDefaultAlbum the default album to add the asset to (optional)
     * @param assetAddToMediaLibrary the media library to add the asset to (optional)
     * @param assetVersionCode the version code of the asset (optional)
     * @param assetVersionName the version name of the asset (optional)
     * @param assetMetaData the meta data of the asset (optional)
     * @param assetCaption the caption of the asset (optional)
     * @param assetMedia the media of the asset (optional)
     * @param assetMediaUrl the media URL of the asset (optional)
     * @param assetMediaString the media string of the asset (optional)
     * @param assetMediaStringFileName the media string file name of the asset (optional)
     * @param assetMediaStringContentType the media string content type of the asset (optional)
     * @param assetAttachedMedia the attached media of the asset (optional)
     * @param assetAttachedMediaUrl the attached media URL of the asset (optional)
     * @param assetAttachedMediaString the attached media string of the asset (optional)
     * @param assetAttachedMediaStringFileName the attached media string file name of the asset (optional)
     * @param assetAttachedMediaStringContentType the attached media string content type of the asset (optional)
     * @param assetLocationDescription the location description for the asset (optional)
     * @param assetApp the application for the asset (optional)
     * @param assetSearchTags the search tags used for the asset (optional)
     * @param assetLatitude the latitude of the asset (optional)
     * @param assetLongitude the longitude of the asset (optional)
     * @return NoteResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createNote(comment: kotlin.String, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, notableType: kotlin.String? = null, notableId: kotlin.Long? = null, noteType: kotlin.String? = null, assetIds: kotlin.String? = null, tags: kotlin.String? = null, permissionableType: kotlin.String? = null, permissionableId: kotlin.Long? = null, appKey: kotlin.String? = null, locationDescription: kotlin.String? = null, latitude: kotlin.Double? = null, longitude: kotlin.Double? = null, metaData: kotlin.String? = null, receiverAccountIds: kotlin.String? = null, returnFullResponse: kotlin.Boolean? = null, initializeAsset: kotlin.Boolean? = null, assetReturnNulls: kotlin.Boolean? = null, assetAlbumId: kotlin.Long? = null, assetCollectionId: kotlin.Long? = null, assetAddToDefaultAlbum: kotlin.String? = null, assetAddToMediaLibrary: kotlin.Boolean? = null, assetVersionCode: kotlin.Int? = null, assetVersionName: kotlin.String? = null, assetMetaData: kotlin.String? = null, assetCaption: kotlin.String? = null, assetMedia: java.io.File? = null, assetMediaUrl: kotlin.String? = null, assetMediaString: kotlin.String? = null, assetMediaStringFileName: kotlin.String? = null, assetMediaStringContentType: kotlin.String? = null, assetAttachedMedia: java.io.File? = null, assetAttachedMediaUrl: kotlin.String? = null, assetAttachedMediaString: kotlin.String? = null, assetAttachedMediaStringFileName: kotlin.String? = null, assetAttachedMediaStringContentType: kotlin.String? = null, assetLocationDescription: kotlin.String? = null, assetApp: kotlin.String? = null, assetSearchTags: kotlin.String? = null, assetLatitude: kotlin.Double? = null, assetLongitude: java.math.BigDecimal? = null) : NoteResponse {
        val localVarResponse = createNoteWithHttpInfo(comment = comment, deviceId = deviceId, accountId = accountId, notableType = notableType, notableId = notableId, noteType = noteType, assetIds = assetIds, tags = tags, permissionableType = permissionableType, permissionableId = permissionableId, appKey = appKey, locationDescription = locationDescription, latitude = latitude, longitude = longitude, metaData = metaData, receiverAccountIds = receiverAccountIds, returnFullResponse = returnFullResponse, initializeAsset = initializeAsset, assetReturnNulls = assetReturnNulls, assetAlbumId = assetAlbumId, assetCollectionId = assetCollectionId, assetAddToDefaultAlbum = assetAddToDefaultAlbum, assetAddToMediaLibrary = assetAddToMediaLibrary, assetVersionCode = assetVersionCode, assetVersionName = assetVersionName, assetMetaData = assetMetaData, assetCaption = assetCaption, assetMedia = assetMedia, assetMediaUrl = assetMediaUrl, assetMediaString = assetMediaString, assetMediaStringFileName = assetMediaStringFileName, assetMediaStringContentType = assetMediaStringContentType, assetAttachedMedia = assetAttachedMedia, assetAttachedMediaUrl = assetAttachedMediaUrl, assetAttachedMediaString = assetAttachedMediaString, assetAttachedMediaStringFileName = assetAttachedMediaStringFileName, assetAttachedMediaStringContentType = assetAttachedMediaStringContentType, assetLocationDescription = assetLocationDescription, assetApp = assetApp, assetSearchTags = assetSearchTags, assetLatitude = assetLatitude, assetLongitude = assetLongitude)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as NoteResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /note/create
     * Create Note
     * This is used to leave a comment (note) on a notable object (i.e. albums, album contests, assets, game levels, offers, offer locations, retailers, retailer locations, and theme descriptors). Leaving a comment on a notable object will be visiable to everyone who has access to view the object.
     * @param comment The message the user wishes to leave a comment on
     * @param deviceId The unique device identifier that made the request (either deviceId or accountId must be used) (optional)
     * @param accountId The unique accountId that made the request (either deviceId or accountId must be used) (optional)
     * @param notableType The notable object type {ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, OFFER, OFFER_LOCATION, RETAILER, RETAILER_LOCATION, THEME_DESCRIPTOR} (optional)
     * @param notableId The id of the notable object (optional)
     * @param noteType The custom string defined by the client (used for differentiating various note types) (optional)
     * @param assetIds A comma separated list of asset IDs to add with the note (optional)
     * @param tags search tags (optional)
     * @param permissionableType This is used for sending out group notifications. For example, when someone adds a note to an asset which is also a part of an album, everyone in the album will receive a notification. This is achieved by passing in the permissionable type (in this case \&quot;album\&quot;), and the permissionable id (the album id). Possible types: {ALBUM, ALBUM_CONTEST, GAME_LEVEL, THEME_DESCRIPTOR} (optional)
     * @param permissionableId The id of the permissionable object (for sending group notifications) (optional)
     * @param appKey The application key used to identify the application (optional)
     * @param locationDescription The description of the location (optional)
     * @param latitude The current location of the user (optional)
     * @param longitude The current location of the user (optional)
     * @param metaData External custom client defined data (optional)
     * @param receiverAccountIds Comma separated list of additional account IDs that will receive the note notifications (optional)
     * @param returnFullResponse whether to return the full response or not (optional)
     * @param initializeAsset Check true if need to initialize an asset and assign to current note (optional)
     * @param assetReturnNulls Return null fields for asset response when creating an asset (optional)
     * @param assetAlbumId the album the asset will be added to (optional) (optional)
     * @param assetCollectionId the collection ID that the asset is associated with (optional)
     * @param assetAddToDefaultAlbum the default album to add the asset to (optional)
     * @param assetAddToMediaLibrary the media library to add the asset to (optional)
     * @param assetVersionCode the version code of the asset (optional)
     * @param assetVersionName the version name of the asset (optional)
     * @param assetMetaData the meta data of the asset (optional)
     * @param assetCaption the caption of the asset (optional)
     * @param assetMedia the media of the asset (optional)
     * @param assetMediaUrl the media URL of the asset (optional)
     * @param assetMediaString the media string of the asset (optional)
     * @param assetMediaStringFileName the media string file name of the asset (optional)
     * @param assetMediaStringContentType the media string content type of the asset (optional)
     * @param assetAttachedMedia the attached media of the asset (optional)
     * @param assetAttachedMediaUrl the attached media URL of the asset (optional)
     * @param assetAttachedMediaString the attached media string of the asset (optional)
     * @param assetAttachedMediaStringFileName the attached media string file name of the asset (optional)
     * @param assetAttachedMediaStringContentType the attached media string content type of the asset (optional)
     * @param assetLocationDescription the location description for the asset (optional)
     * @param assetApp the application for the asset (optional)
     * @param assetSearchTags the search tags used for the asset (optional)
     * @param assetLatitude the latitude of the asset (optional)
     * @param assetLongitude the longitude of the asset (optional)
     * @return ApiResponse<NoteResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createNoteWithHttpInfo(comment: kotlin.String, deviceId: kotlin.String?, accountId: kotlin.Long?, notableType: kotlin.String?, notableId: kotlin.Long?, noteType: kotlin.String?, assetIds: kotlin.String?, tags: kotlin.String?, permissionableType: kotlin.String?, permissionableId: kotlin.Long?, appKey: kotlin.String?, locationDescription: kotlin.String?, latitude: kotlin.Double?, longitude: kotlin.Double?, metaData: kotlin.String?, receiverAccountIds: kotlin.String?, returnFullResponse: kotlin.Boolean?, initializeAsset: kotlin.Boolean?, assetReturnNulls: kotlin.Boolean?, assetAlbumId: kotlin.Long?, assetCollectionId: kotlin.Long?, assetAddToDefaultAlbum: kotlin.String?, assetAddToMediaLibrary: kotlin.Boolean?, assetVersionCode: kotlin.Int?, assetVersionName: kotlin.String?, assetMetaData: kotlin.String?, assetCaption: kotlin.String?, assetMedia: java.io.File?, assetMediaUrl: kotlin.String?, assetMediaString: kotlin.String?, assetMediaStringFileName: kotlin.String?, assetMediaStringContentType: kotlin.String?, assetAttachedMedia: java.io.File?, assetAttachedMediaUrl: kotlin.String?, assetAttachedMediaString: kotlin.String?, assetAttachedMediaStringFileName: kotlin.String?, assetAttachedMediaStringContentType: kotlin.String?, assetLocationDescription: kotlin.String?, assetApp: kotlin.String?, assetSearchTags: kotlin.String?, assetLatitude: kotlin.Double?, assetLongitude: java.math.BigDecimal?) : ApiResponse<NoteResponse?> {
        val localVariableConfig = createNoteRequestConfig(comment = comment, deviceId = deviceId, accountId = accountId, notableType = notableType, notableId = notableId, noteType = noteType, assetIds = assetIds, tags = tags, permissionableType = permissionableType, permissionableId = permissionableId, appKey = appKey, locationDescription = locationDescription, latitude = latitude, longitude = longitude, metaData = metaData, receiverAccountIds = receiverAccountIds, returnFullResponse = returnFullResponse, initializeAsset = initializeAsset, assetReturnNulls = assetReturnNulls, assetAlbumId = assetAlbumId, assetCollectionId = assetCollectionId, assetAddToDefaultAlbum = assetAddToDefaultAlbum, assetAddToMediaLibrary = assetAddToMediaLibrary, assetVersionCode = assetVersionCode, assetVersionName = assetVersionName, assetMetaData = assetMetaData, assetCaption = assetCaption, assetMedia = assetMedia, assetMediaUrl = assetMediaUrl, assetMediaString = assetMediaString, assetMediaStringFileName = assetMediaStringFileName, assetMediaStringContentType = assetMediaStringContentType, assetAttachedMedia = assetAttachedMedia, assetAttachedMediaUrl = assetAttachedMediaUrl, assetAttachedMediaString = assetAttachedMediaString, assetAttachedMediaStringFileName = assetAttachedMediaStringFileName, assetAttachedMediaStringContentType = assetAttachedMediaStringContentType, assetLocationDescription = assetLocationDescription, assetApp = assetApp, assetSearchTags = assetSearchTags, assetLatitude = assetLatitude, assetLongitude = assetLongitude)

        return request<Unit, NoteResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createNote
     *
     * @param comment The message the user wishes to leave a comment on
     * @param deviceId The unique device identifier that made the request (either deviceId or accountId must be used) (optional)
     * @param accountId The unique accountId that made the request (either deviceId or accountId must be used) (optional)
     * @param notableType The notable object type {ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, OFFER, OFFER_LOCATION, RETAILER, RETAILER_LOCATION, THEME_DESCRIPTOR} (optional)
     * @param notableId The id of the notable object (optional)
     * @param noteType The custom string defined by the client (used for differentiating various note types) (optional)
     * @param assetIds A comma separated list of asset IDs to add with the note (optional)
     * @param tags search tags (optional)
     * @param permissionableType This is used for sending out group notifications. For example, when someone adds a note to an asset which is also a part of an album, everyone in the album will receive a notification. This is achieved by passing in the permissionable type (in this case \&quot;album\&quot;), and the permissionable id (the album id). Possible types: {ALBUM, ALBUM_CONTEST, GAME_LEVEL, THEME_DESCRIPTOR} (optional)
     * @param permissionableId The id of the permissionable object (for sending group notifications) (optional)
     * @param appKey The application key used to identify the application (optional)
     * @param locationDescription The description of the location (optional)
     * @param latitude The current location of the user (optional)
     * @param longitude The current location of the user (optional)
     * @param metaData External custom client defined data (optional)
     * @param receiverAccountIds Comma separated list of additional account IDs that will receive the note notifications (optional)
     * @param returnFullResponse whether to return the full response or not (optional)
     * @param initializeAsset Check true if need to initialize an asset and assign to current note (optional)
     * @param assetReturnNulls Return null fields for asset response when creating an asset (optional)
     * @param assetAlbumId the album the asset will be added to (optional) (optional)
     * @param assetCollectionId the collection ID that the asset is associated with (optional)
     * @param assetAddToDefaultAlbum the default album to add the asset to (optional)
     * @param assetAddToMediaLibrary the media library to add the asset to (optional)
     * @param assetVersionCode the version code of the asset (optional)
     * @param assetVersionName the version name of the asset (optional)
     * @param assetMetaData the meta data of the asset (optional)
     * @param assetCaption the caption of the asset (optional)
     * @param assetMedia the media of the asset (optional)
     * @param assetMediaUrl the media URL of the asset (optional)
     * @param assetMediaString the media string of the asset (optional)
     * @param assetMediaStringFileName the media string file name of the asset (optional)
     * @param assetMediaStringContentType the media string content type of the asset (optional)
     * @param assetAttachedMedia the attached media of the asset (optional)
     * @param assetAttachedMediaUrl the attached media URL of the asset (optional)
     * @param assetAttachedMediaString the attached media string of the asset (optional)
     * @param assetAttachedMediaStringFileName the attached media string file name of the asset (optional)
     * @param assetAttachedMediaStringContentType the attached media string content type of the asset (optional)
     * @param assetLocationDescription the location description for the asset (optional)
     * @param assetApp the application for the asset (optional)
     * @param assetSearchTags the search tags used for the asset (optional)
     * @param assetLatitude the latitude of the asset (optional)
     * @param assetLongitude the longitude of the asset (optional)
     * @return RequestConfig
     */
    fun createNoteRequestConfig(comment: kotlin.String, deviceId: kotlin.String?, accountId: kotlin.Long?, notableType: kotlin.String?, notableId: kotlin.Long?, noteType: kotlin.String?, assetIds: kotlin.String?, tags: kotlin.String?, permissionableType: kotlin.String?, permissionableId: kotlin.Long?, appKey: kotlin.String?, locationDescription: kotlin.String?, latitude: kotlin.Double?, longitude: kotlin.Double?, metaData: kotlin.String?, receiverAccountIds: kotlin.String?, returnFullResponse: kotlin.Boolean?, initializeAsset: kotlin.Boolean?, assetReturnNulls: kotlin.Boolean?, assetAlbumId: kotlin.Long?, assetCollectionId: kotlin.Long?, assetAddToDefaultAlbum: kotlin.String?, assetAddToMediaLibrary: kotlin.Boolean?, assetVersionCode: kotlin.Int?, assetVersionName: kotlin.String?, assetMetaData: kotlin.String?, assetCaption: kotlin.String?, assetMedia: java.io.File?, assetMediaUrl: kotlin.String?, assetMediaString: kotlin.String?, assetMediaStringFileName: kotlin.String?, assetMediaStringContentType: kotlin.String?, assetAttachedMedia: java.io.File?, assetAttachedMediaUrl: kotlin.String?, assetAttachedMediaString: kotlin.String?, assetAttachedMediaStringFileName: kotlin.String?, assetAttachedMediaStringContentType: kotlin.String?, assetLocationDescription: kotlin.String?, assetApp: kotlin.String?, assetSearchTags: kotlin.String?, assetLatitude: kotlin.Double?, assetLongitude: java.math.BigDecimal?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (notableType != null) {
                    put("notableType", listOf(notableType.toString()))
                }
                if (notableId != null) {
                    put("notableId", listOf(notableId.toString()))
                }
                put("comment", listOf(comment.toString()))
                if (noteType != null) {
                    put("noteType", listOf(noteType.toString()))
                }
                if (assetIds != null) {
                    put("assetIds", listOf(assetIds.toString()))
                }
                if (tags != null) {
                    put("tags", listOf(tags.toString()))
                }
                if (permissionableType != null) {
                    put("permissionableType", listOf(permissionableType.toString()))
                }
                if (permissionableId != null) {
                    put("permissionableId", listOf(permissionableId.toString()))
                }
                if (appKey != null) {
                    put("appKey", listOf(appKey.toString()))
                }
                if (locationDescription != null) {
                    put("locationDescription", listOf(locationDescription.toString()))
                }
                if (latitude != null) {
                    put("latitude", listOf(latitude.toString()))
                }
                if (longitude != null) {
                    put("longitude", listOf(longitude.toString()))
                }
                if (metaData != null) {
                    put("metaData", listOf(metaData.toString()))
                }
                if (receiverAccountIds != null) {
                    put("receiverAccountIds", listOf(receiverAccountIds.toString()))
                }
                if (returnFullResponse != null) {
                    put("returnFullResponse", listOf(returnFullResponse.toString()))
                }
                if (initializeAsset != null) {
                    put("initializeAsset", listOf(initializeAsset.toString()))
                }
                if (assetReturnNulls != null) {
                    put("assetReturnNulls", listOf(assetReturnNulls.toString()))
                }
                if (assetAlbumId != null) {
                    put("assetAlbumId", listOf(assetAlbumId.toString()))
                }
                if (assetCollectionId != null) {
                    put("assetCollectionId", listOf(assetCollectionId.toString()))
                }
                if (assetAddToDefaultAlbum != null) {
                    put("assetAddToDefaultAlbum", listOf(assetAddToDefaultAlbum.toString()))
                }
                if (assetAddToMediaLibrary != null) {
                    put("assetAddToMediaLibrary", listOf(assetAddToMediaLibrary.toString()))
                }
                if (assetVersionCode != null) {
                    put("assetVersionCode", listOf(assetVersionCode.toString()))
                }
                if (assetVersionName != null) {
                    put("assetVersionName", listOf(assetVersionName.toString()))
                }
                if (assetMetaData != null) {
                    put("assetMetaData", listOf(assetMetaData.toString()))
                }
                if (assetCaption != null) {
                    put("assetCaption", listOf(assetCaption.toString()))
                }
                if (assetMedia != null) {
                    put("assetMedia", listOf(assetMedia.toString()))
                }
                if (assetMediaUrl != null) {
                    put("assetMediaUrl", listOf(assetMediaUrl.toString()))
                }
                if (assetMediaString != null) {
                    put("assetMediaString", listOf(assetMediaString.toString()))
                }
                if (assetMediaStringFileName != null) {
                    put("assetMediaStringFileName", listOf(assetMediaStringFileName.toString()))
                }
                if (assetMediaStringContentType != null) {
                    put("assetMediaStringContentType", listOf(assetMediaStringContentType.toString()))
                }
                if (assetAttachedMedia != null) {
                    put("assetAttachedMedia", listOf(assetAttachedMedia.toString()))
                }
                if (assetAttachedMediaUrl != null) {
                    put("assetAttachedMediaUrl", listOf(assetAttachedMediaUrl.toString()))
                }
                if (assetAttachedMediaString != null) {
                    put("assetAttachedMediaString", listOf(assetAttachedMediaString.toString()))
                }
                if (assetAttachedMediaStringFileName != null) {
                    put("assetAttachedMediaStringFileName", listOf(assetAttachedMediaStringFileName.toString()))
                }
                if (assetAttachedMediaStringContentType != null) {
                    put("assetAttachedMediaStringContentType", listOf(assetAttachedMediaStringContentType.toString()))
                }
                if (assetLocationDescription != null) {
                    put("assetLocationDescription", listOf(assetLocationDescription.toString()))
                }
                if (assetApp != null) {
                    put("assetApp", listOf(assetApp.toString()))
                }
                if (assetSearchTags != null) {
                    put("assetSearchTags", listOf(assetSearchTags.toString()))
                }
                if (assetLatitude != null) {
                    put("assetLatitude", listOf(assetLatitude.toString()))
                }
                if (assetLongitude != null) {
                    put("assetLongitude", listOf(assetLongitude.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/note/create",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /note/delete
     * Delete Note
     * Sets a comment (note) as deleted.
     * @param noteId The ID of the note to delete
     * @param deviceId The unique device identifier that made the request (either deviceId or accountId must be used) (optional)
     * @param accountId The unique accountId that made the request (either deviceId or accountId must be used) (optional)
     * @param latitude The current location of the user (optional)
     * @param longitude The current location of the user (optional)
     * @param appKey The application key used to identify the application (optional)
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteNote(noteId: kotlin.Long, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, latitude: kotlin.Double? = null, longitude: kotlin.Double? = null, appKey: kotlin.String? = null) : SirqulResponse {
        val localVarResponse = deleteNoteWithHttpInfo(noteId = noteId, deviceId = deviceId, accountId = accountId, latitude = latitude, longitude = longitude, appKey = appKey)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /note/delete
     * Delete Note
     * Sets a comment (note) as deleted.
     * @param noteId The ID of the note to delete
     * @param deviceId The unique device identifier that made the request (either deviceId or accountId must be used) (optional)
     * @param accountId The unique accountId that made the request (either deviceId or accountId must be used) (optional)
     * @param latitude The current location of the user (optional)
     * @param longitude The current location of the user (optional)
     * @param appKey The application key used to identify the application (optional)
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteNoteWithHttpInfo(noteId: kotlin.Long, deviceId: kotlin.String?, accountId: kotlin.Long?, latitude: kotlin.Double?, longitude: kotlin.Double?, appKey: kotlin.String?) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = deleteNoteRequestConfig(noteId = noteId, deviceId = deviceId, accountId = accountId, latitude = latitude, longitude = longitude, appKey = appKey)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteNote
     *
     * @param noteId The ID of the note to delete
     * @param deviceId The unique device identifier that made the request (either deviceId or accountId must be used) (optional)
     * @param accountId The unique accountId that made the request (either deviceId or accountId must be used) (optional)
     * @param latitude The current location of the user (optional)
     * @param longitude The current location of the user (optional)
     * @param appKey The application key used to identify the application (optional)
     * @return RequestConfig
     */
    fun deleteNoteRequestConfig(noteId: kotlin.Long, deviceId: kotlin.String?, accountId: kotlin.Long?, latitude: kotlin.Double?, longitude: kotlin.Double?, appKey: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                put("noteId", listOf(noteId.toString()))
                if (latitude != null) {
                    put("latitude", listOf(latitude.toString()))
                }
                if (longitude != null) {
                    put("longitude", listOf(longitude.toString()))
                }
                if (appKey != null) {
                    put("appKey", listOf(appKey.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/note/delete",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /note/get
     * Get Note
     * Get for a note based on its Id.
     * @param noteId the id of the note to get
     * @param deviceId The unique device identifier that made the request (either deviceId or accountId must be used) (optional)
     * @param accountId The unique accountId that made the request (either deviceId or accountId must be used) (optional)
     * @param returnFullResponse Determines whether to return the NoteFullResponse for the item (optional)
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getNote(noteId: kotlin.Long, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, returnFullResponse: kotlin.Boolean? = null) : SirqulResponse {
        val localVarResponse = getNoteWithHttpInfo(noteId = noteId, deviceId = deviceId, accountId = accountId, returnFullResponse = returnFullResponse)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /note/get
     * Get Note
     * Get for a note based on its Id.
     * @param noteId the id of the note to get
     * @param deviceId The unique device identifier that made the request (either deviceId or accountId must be used) (optional)
     * @param accountId The unique accountId that made the request (either deviceId or accountId must be used) (optional)
     * @param returnFullResponse Determines whether to return the NoteFullResponse for the item (optional)
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getNoteWithHttpInfo(noteId: kotlin.Long, deviceId: kotlin.String?, accountId: kotlin.Long?, returnFullResponse: kotlin.Boolean?) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = getNoteRequestConfig(noteId = noteId, deviceId = deviceId, accountId = accountId, returnFullResponse = returnFullResponse)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getNote
     *
     * @param noteId the id of the note to get
     * @param deviceId The unique device identifier that made the request (either deviceId or accountId must be used) (optional)
     * @param accountId The unique accountId that made the request (either deviceId or accountId must be used) (optional)
     * @param returnFullResponse Determines whether to return the NoteFullResponse for the item (optional)
     * @return RequestConfig
     */
    fun getNoteRequestConfig(noteId: kotlin.Long, deviceId: kotlin.String?, accountId: kotlin.Long?, returnFullResponse: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (returnFullResponse != null) {
                    put("returnFullResponse", listOf(returnFullResponse.toString()))
                }
                put("noteId", listOf(noteId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/note/get",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter sortField
     */
     enum class SortFieldSearchNotes(val value: kotlin.String) {
         @Json(name = "ID") ID("ID"),
         @Json(name = "CREATED") CREATED("CREATED"),
         @Json(name = "UPDATED") UPDATED("UPDATED"),
         @Json(name = "DELETED") DELETED("DELETED"),
         @Json(name = "SEARCH_TAGS") SEARCH_TAGS("SEARCH_TAGS"),
         @Json(name = "ACTIVE") ACTIVE("ACTIVE"),
         @Json(name = "OWNER_DISPLAY") OWNER_DISPLAY("OWNER_DISPLAY"),
         @Json(name = "NOTABLE_TYPE") NOTABLE_TYPE("NOTABLE_TYPE"),
         @Json(name = "NOTE_TAG") NOTE_TAG("NOTE_TAG"),
         @Json(name = "NOTE_COUNT") NOTE_COUNT("NOTE_COUNT"),
         @Json(name = "LIKES") LIKES("LIKES"),
         @Json(name = "DISLIKES") DISLIKES("DISLIKES");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * POST /note/search
     * Search Notes
     * Search for notes on a notable object.
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param notableType The notable object type {ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, OFFER, OFFER_LOCATION, RETAILER, RETAILER_LOCATION, THEME_DESCRIPTOR} (optional)
     * @param notableId The id of the notable object (optional)
     * @param noteTypes Comma separated list of noteType strings to filter results with (optional)
     * @param appKey The application key used to identify the application (optional)
     * @param keyword The keyword used to search (optional)
     * @param flagCountMinimum return items that has flagCount &gt;&#x3D; flagCountMinimum if this is set, return all items, even ones with flagCount &gt;&#x3D; flagThreshold (optional)
     * @param flagsExceedThreshold return items that has flagCount &gt;&#x3D; flagThreshold, which are hidden by default (optional)
     * @param includeInactive include inactive in the result (optional)
     * @param sortField The column to sort the search on (optional)
     * @param descending The order to return the search results (optional)
     * @param returnFullResponse Determines whether to return the NoteFullResponse for each search item (optional)
     * @param updatedSince return items that have been updated since this date (time-stamp in milliseconds) (optional)
     * @param updatedBefore return items that have been updated before this date (time-stamp in milliseconds) (optional)
     * @param start The record to begin the return set on (optional)
     * @param limit The number of records to return (optional)
     * @return kotlin.collections.List<NoteResponse>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun searchNotes(deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, notableType: kotlin.String? = null, notableId: kotlin.Long? = null, noteTypes: kotlin.String? = null, appKey: kotlin.String? = null, keyword: kotlin.String? = null, flagCountMinimum: kotlin.Long? = null, flagsExceedThreshold: kotlin.Boolean? = null, includeInactive: kotlin.Boolean? = null, sortField: SortFieldSearchNotes? = null, descending: kotlin.Boolean? = null, returnFullResponse: kotlin.Boolean? = null, updatedSince: kotlin.Long? = null, updatedBefore: kotlin.Long? = null, start: kotlin.Int? = null, limit: kotlin.Int? = null) : kotlin.collections.List<NoteResponse> {
        val localVarResponse = searchNotesWithHttpInfo(deviceId = deviceId, accountId = accountId, notableType = notableType, notableId = notableId, noteTypes = noteTypes, appKey = appKey, keyword = keyword, flagCountMinimum = flagCountMinimum, flagsExceedThreshold = flagsExceedThreshold, includeInactive = includeInactive, sortField = sortField, descending = descending, returnFullResponse = returnFullResponse, updatedSince = updatedSince, updatedBefore = updatedBefore, start = start, limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<NoteResponse>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /note/search
     * Search Notes
     * Search for notes on a notable object.
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param notableType The notable object type {ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, OFFER, OFFER_LOCATION, RETAILER, RETAILER_LOCATION, THEME_DESCRIPTOR} (optional)
     * @param notableId The id of the notable object (optional)
     * @param noteTypes Comma separated list of noteType strings to filter results with (optional)
     * @param appKey The application key used to identify the application (optional)
     * @param keyword The keyword used to search (optional)
     * @param flagCountMinimum return items that has flagCount &gt;&#x3D; flagCountMinimum if this is set, return all items, even ones with flagCount &gt;&#x3D; flagThreshold (optional)
     * @param flagsExceedThreshold return items that has flagCount &gt;&#x3D; flagThreshold, which are hidden by default (optional)
     * @param includeInactive include inactive in the result (optional)
     * @param sortField The column to sort the search on (optional)
     * @param descending The order to return the search results (optional)
     * @param returnFullResponse Determines whether to return the NoteFullResponse for each search item (optional)
     * @param updatedSince return items that have been updated since this date (time-stamp in milliseconds) (optional)
     * @param updatedBefore return items that have been updated before this date (time-stamp in milliseconds) (optional)
     * @param start The record to begin the return set on (optional)
     * @param limit The number of records to return (optional)
     * @return ApiResponse<kotlin.collections.List<NoteResponse>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun searchNotesWithHttpInfo(deviceId: kotlin.String?, accountId: kotlin.Long?, notableType: kotlin.String?, notableId: kotlin.Long?, noteTypes: kotlin.String?, appKey: kotlin.String?, keyword: kotlin.String?, flagCountMinimum: kotlin.Long?, flagsExceedThreshold: kotlin.Boolean?, includeInactive: kotlin.Boolean?, sortField: SortFieldSearchNotes?, descending: kotlin.Boolean?, returnFullResponse: kotlin.Boolean?, updatedSince: kotlin.Long?, updatedBefore: kotlin.Long?, start: kotlin.Int?, limit: kotlin.Int?) : ApiResponse<kotlin.collections.List<NoteResponse>?> {
        val localVariableConfig = searchNotesRequestConfig(deviceId = deviceId, accountId = accountId, notableType = notableType, notableId = notableId, noteTypes = noteTypes, appKey = appKey, keyword = keyword, flagCountMinimum = flagCountMinimum, flagsExceedThreshold = flagsExceedThreshold, includeInactive = includeInactive, sortField = sortField, descending = descending, returnFullResponse = returnFullResponse, updatedSince = updatedSince, updatedBefore = updatedBefore, start = start, limit = limit)

        return request<Unit, kotlin.collections.List<NoteResponse>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation searchNotes
     *
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param notableType The notable object type {ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, OFFER, OFFER_LOCATION, RETAILER, RETAILER_LOCATION, THEME_DESCRIPTOR} (optional)
     * @param notableId The id of the notable object (optional)
     * @param noteTypes Comma separated list of noteType strings to filter results with (optional)
     * @param appKey The application key used to identify the application (optional)
     * @param keyword The keyword used to search (optional)
     * @param flagCountMinimum return items that has flagCount &gt;&#x3D; flagCountMinimum if this is set, return all items, even ones with flagCount &gt;&#x3D; flagThreshold (optional)
     * @param flagsExceedThreshold return items that has flagCount &gt;&#x3D; flagThreshold, which are hidden by default (optional)
     * @param includeInactive include inactive in the result (optional)
     * @param sortField The column to sort the search on (optional)
     * @param descending The order to return the search results (optional)
     * @param returnFullResponse Determines whether to return the NoteFullResponse for each search item (optional)
     * @param updatedSince return items that have been updated since this date (time-stamp in milliseconds) (optional)
     * @param updatedBefore return items that have been updated before this date (time-stamp in milliseconds) (optional)
     * @param start The record to begin the return set on (optional)
     * @param limit The number of records to return (optional)
     * @return RequestConfig
     */
    fun searchNotesRequestConfig(deviceId: kotlin.String?, accountId: kotlin.Long?, notableType: kotlin.String?, notableId: kotlin.Long?, noteTypes: kotlin.String?, appKey: kotlin.String?, keyword: kotlin.String?, flagCountMinimum: kotlin.Long?, flagsExceedThreshold: kotlin.Boolean?, includeInactive: kotlin.Boolean?, sortField: SortFieldSearchNotes?, descending: kotlin.Boolean?, returnFullResponse: kotlin.Boolean?, updatedSince: kotlin.Long?, updatedBefore: kotlin.Long?, start: kotlin.Int?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (notableType != null) {
                    put("notableType", listOf(notableType.toString()))
                }
                if (notableId != null) {
                    put("notableId", listOf(notableId.toString()))
                }
                if (noteTypes != null) {
                    put("noteTypes", listOf(noteTypes.toString()))
                }
                if (appKey != null) {
                    put("appKey", listOf(appKey.toString()))
                }
                if (keyword != null) {
                    put("keyword", listOf(keyword.toString()))
                }
                if (flagCountMinimum != null) {
                    put("flagCountMinimum", listOf(flagCountMinimum.toString()))
                }
                if (flagsExceedThreshold != null) {
                    put("flagsExceedThreshold", listOf(flagsExceedThreshold.toString()))
                }
                if (includeInactive != null) {
                    put("includeInactive", listOf(includeInactive.toString()))
                }
                if (sortField != null) {
                    put("sortField", listOf(sortField.value))
                }
                if (descending != null) {
                    put("descending", listOf(descending.toString()))
                }
                if (returnFullResponse != null) {
                    put("returnFullResponse", listOf(returnFullResponse.toString()))
                }
                if (updatedSince != null) {
                    put("updatedSince", listOf(updatedSince.toString()))
                }
                if (updatedBefore != null) {
                    put("updatedBefore", listOf(updatedBefore.toString()))
                }
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/note/search",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /note/update
     * Update Note
     * Update an existing comment (note). Only the creator of the note have permission to update.
     * @param noteId The id of the note, used when editing a comment
     * @param deviceId The unique device identifier that made the request (either deviceId or accountId must be used) (optional)
     * @param accountId The unique accountId that made the request (either deviceId or accountId must be used) (optional)
     * @param comment The message the user wishes to leave a comment on (optional)
     * @param noteType The custom string defined by the client (used for differentiating on various note types) (optional)
     * @param assetIds A comma separated list of asset IDs to add with the note (optional)
     * @param tags search tags (optional)
     * @param permissionableType This is used for sending out group notifications. For example, when someone adds a note to an asset which is also a part of an album, everyone in the album will receive a notification. This is achieved by passing in the permissionable type (in this case \&quot;album\&quot;), and the permissionable id (the album id). Possible types: {ALBUM, ALBUM_CONTEST, GAME_LEVEL, THEME_DESCRIPTOR} (optional)
     * @param permissionableId The id of the permissionable object (for sending group notifications) (optional)
     * @param appKey The application key used to identify the application (optional)
     * @param locationDescription The description of the location (optional)
     * @param latitude The current location of the user (optional)
     * @param longitude The current location of the user (optional)
     * @param metaData meta data to update with the note (optional)
     * @param returnFullResponse whether to return the full response or not (optional)
     * @param active Sets the active flag for the note (optional)
     * @param updateAsset main flag for updating asset in note, must set to true if you want to update the note&#39;s asset (optional)
     * @param assetReturnNulls Return null fields for asset response when updating an asset (optional)
     * @param assetAlbumId the album the asset will be added to (optional) (optional)
     * @param assetCollectionId the collection ID that the asset is associated with (optional)
     * @param assetAddToDefaultAlbum the default album to add the asset to (optional)
     * @param assetAddToMediaLibrary the media library to add the asset to (optional)
     * @param assetVersionCode the version code of the asset (optional)
     * @param assetVersionName the version name of the asset (optional)
     * @param assetMetaData the meta data of the asset (optional)
     * @param assetCaption the caption of the asset (optional)
     * @param assetMedia the media of the asset (optional)
     * @param assetMediaUrl the media URL of the asset (optional)
     * @param assetMediaString the media string of the asset (optional)
     * @param assetMediaStringFileName the media string file name of the asset (optional)
     * @param assetMediaStringContentType the media string content type of the asset (optional)
     * @param assetAttachedMedia the attached media of the asset (optional)
     * @param assetAttachedMediaUrl the attached media URL of the asset (optional)
     * @param assetAttachedMediaString the attached media string of the asset (optional)
     * @param assetAttachedMediaStringFileName the attached media string file name of the asset (optional)
     * @param assetAttachedMediaStringContentType the attached media string content type of the asset (optional)
     * @param assetLocationDescription the location description for the asset (optional)
     * @param assetApp the application for the asset (optional)
     * @param assetSearchTags the search tags used for the asset (optional)
     * @param assetLatitude the latitude of the asset (optional)
     * @param assetLongitude the longitude of the asset (optional)
     * @return NoteResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updateNote(noteId: kotlin.Long, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, comment: kotlin.String? = null, noteType: kotlin.String? = null, assetIds: kotlin.String? = null, tags: kotlin.String? = null, permissionableType: kotlin.String? = null, permissionableId: kotlin.Long? = null, appKey: kotlin.String? = null, locationDescription: kotlin.String? = null, latitude: kotlin.Double? = null, longitude: kotlin.Double? = null, metaData: kotlin.String? = null, returnFullResponse: kotlin.Boolean? = null, active: kotlin.Boolean? = null, updateAsset: kotlin.Boolean? = null, assetReturnNulls: kotlin.Boolean? = null, assetAlbumId: kotlin.Long? = null, assetCollectionId: kotlin.Long? = null, assetAddToDefaultAlbum: kotlin.String? = null, assetAddToMediaLibrary: kotlin.Boolean? = null, assetVersionCode: kotlin.Int? = null, assetVersionName: kotlin.String? = null, assetMetaData: kotlin.String? = null, assetCaption: kotlin.String? = null, assetMedia: java.io.File? = null, assetMediaUrl: kotlin.String? = null, assetMediaString: kotlin.String? = null, assetMediaStringFileName: kotlin.String? = null, assetMediaStringContentType: kotlin.String? = null, assetAttachedMedia: java.io.File? = null, assetAttachedMediaUrl: kotlin.String? = null, assetAttachedMediaString: kotlin.String? = null, assetAttachedMediaStringFileName: kotlin.String? = null, assetAttachedMediaStringContentType: kotlin.String? = null, assetLocationDescription: kotlin.String? = null, assetApp: kotlin.String? = null, assetSearchTags: kotlin.String? = null, assetLatitude: kotlin.Double? = null, assetLongitude: kotlin.Double? = null) : NoteResponse {
        val localVarResponse = updateNoteWithHttpInfo(noteId = noteId, deviceId = deviceId, accountId = accountId, comment = comment, noteType = noteType, assetIds = assetIds, tags = tags, permissionableType = permissionableType, permissionableId = permissionableId, appKey = appKey, locationDescription = locationDescription, latitude = latitude, longitude = longitude, metaData = metaData, returnFullResponse = returnFullResponse, active = active, updateAsset = updateAsset, assetReturnNulls = assetReturnNulls, assetAlbumId = assetAlbumId, assetCollectionId = assetCollectionId, assetAddToDefaultAlbum = assetAddToDefaultAlbum, assetAddToMediaLibrary = assetAddToMediaLibrary, assetVersionCode = assetVersionCode, assetVersionName = assetVersionName, assetMetaData = assetMetaData, assetCaption = assetCaption, assetMedia = assetMedia, assetMediaUrl = assetMediaUrl, assetMediaString = assetMediaString, assetMediaStringFileName = assetMediaStringFileName, assetMediaStringContentType = assetMediaStringContentType, assetAttachedMedia = assetAttachedMedia, assetAttachedMediaUrl = assetAttachedMediaUrl, assetAttachedMediaString = assetAttachedMediaString, assetAttachedMediaStringFileName = assetAttachedMediaStringFileName, assetAttachedMediaStringContentType = assetAttachedMediaStringContentType, assetLocationDescription = assetLocationDescription, assetApp = assetApp, assetSearchTags = assetSearchTags, assetLatitude = assetLatitude, assetLongitude = assetLongitude)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as NoteResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /note/update
     * Update Note
     * Update an existing comment (note). Only the creator of the note have permission to update.
     * @param noteId The id of the note, used when editing a comment
     * @param deviceId The unique device identifier that made the request (either deviceId or accountId must be used) (optional)
     * @param accountId The unique accountId that made the request (either deviceId or accountId must be used) (optional)
     * @param comment The message the user wishes to leave a comment on (optional)
     * @param noteType The custom string defined by the client (used for differentiating on various note types) (optional)
     * @param assetIds A comma separated list of asset IDs to add with the note (optional)
     * @param tags search tags (optional)
     * @param permissionableType This is used for sending out group notifications. For example, when someone adds a note to an asset which is also a part of an album, everyone in the album will receive a notification. This is achieved by passing in the permissionable type (in this case \&quot;album\&quot;), and the permissionable id (the album id). Possible types: {ALBUM, ALBUM_CONTEST, GAME_LEVEL, THEME_DESCRIPTOR} (optional)
     * @param permissionableId The id of the permissionable object (for sending group notifications) (optional)
     * @param appKey The application key used to identify the application (optional)
     * @param locationDescription The description of the location (optional)
     * @param latitude The current location of the user (optional)
     * @param longitude The current location of the user (optional)
     * @param metaData meta data to update with the note (optional)
     * @param returnFullResponse whether to return the full response or not (optional)
     * @param active Sets the active flag for the note (optional)
     * @param updateAsset main flag for updating asset in note, must set to true if you want to update the note&#39;s asset (optional)
     * @param assetReturnNulls Return null fields for asset response when updating an asset (optional)
     * @param assetAlbumId the album the asset will be added to (optional) (optional)
     * @param assetCollectionId the collection ID that the asset is associated with (optional)
     * @param assetAddToDefaultAlbum the default album to add the asset to (optional)
     * @param assetAddToMediaLibrary the media library to add the asset to (optional)
     * @param assetVersionCode the version code of the asset (optional)
     * @param assetVersionName the version name of the asset (optional)
     * @param assetMetaData the meta data of the asset (optional)
     * @param assetCaption the caption of the asset (optional)
     * @param assetMedia the media of the asset (optional)
     * @param assetMediaUrl the media URL of the asset (optional)
     * @param assetMediaString the media string of the asset (optional)
     * @param assetMediaStringFileName the media string file name of the asset (optional)
     * @param assetMediaStringContentType the media string content type of the asset (optional)
     * @param assetAttachedMedia the attached media of the asset (optional)
     * @param assetAttachedMediaUrl the attached media URL of the asset (optional)
     * @param assetAttachedMediaString the attached media string of the asset (optional)
     * @param assetAttachedMediaStringFileName the attached media string file name of the asset (optional)
     * @param assetAttachedMediaStringContentType the attached media string content type of the asset (optional)
     * @param assetLocationDescription the location description for the asset (optional)
     * @param assetApp the application for the asset (optional)
     * @param assetSearchTags the search tags used for the asset (optional)
     * @param assetLatitude the latitude of the asset (optional)
     * @param assetLongitude the longitude of the asset (optional)
     * @return ApiResponse<NoteResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun updateNoteWithHttpInfo(noteId: kotlin.Long, deviceId: kotlin.String?, accountId: kotlin.Long?, comment: kotlin.String?, noteType: kotlin.String?, assetIds: kotlin.String?, tags: kotlin.String?, permissionableType: kotlin.String?, permissionableId: kotlin.Long?, appKey: kotlin.String?, locationDescription: kotlin.String?, latitude: kotlin.Double?, longitude: kotlin.Double?, metaData: kotlin.String?, returnFullResponse: kotlin.Boolean?, active: kotlin.Boolean?, updateAsset: kotlin.Boolean?, assetReturnNulls: kotlin.Boolean?, assetAlbumId: kotlin.Long?, assetCollectionId: kotlin.Long?, assetAddToDefaultAlbum: kotlin.String?, assetAddToMediaLibrary: kotlin.Boolean?, assetVersionCode: kotlin.Int?, assetVersionName: kotlin.String?, assetMetaData: kotlin.String?, assetCaption: kotlin.String?, assetMedia: java.io.File?, assetMediaUrl: kotlin.String?, assetMediaString: kotlin.String?, assetMediaStringFileName: kotlin.String?, assetMediaStringContentType: kotlin.String?, assetAttachedMedia: java.io.File?, assetAttachedMediaUrl: kotlin.String?, assetAttachedMediaString: kotlin.String?, assetAttachedMediaStringFileName: kotlin.String?, assetAttachedMediaStringContentType: kotlin.String?, assetLocationDescription: kotlin.String?, assetApp: kotlin.String?, assetSearchTags: kotlin.String?, assetLatitude: kotlin.Double?, assetLongitude: kotlin.Double?) : ApiResponse<NoteResponse?> {
        val localVariableConfig = updateNoteRequestConfig(noteId = noteId, deviceId = deviceId, accountId = accountId, comment = comment, noteType = noteType, assetIds = assetIds, tags = tags, permissionableType = permissionableType, permissionableId = permissionableId, appKey = appKey, locationDescription = locationDescription, latitude = latitude, longitude = longitude, metaData = metaData, returnFullResponse = returnFullResponse, active = active, updateAsset = updateAsset, assetReturnNulls = assetReturnNulls, assetAlbumId = assetAlbumId, assetCollectionId = assetCollectionId, assetAddToDefaultAlbum = assetAddToDefaultAlbum, assetAddToMediaLibrary = assetAddToMediaLibrary, assetVersionCode = assetVersionCode, assetVersionName = assetVersionName, assetMetaData = assetMetaData, assetCaption = assetCaption, assetMedia = assetMedia, assetMediaUrl = assetMediaUrl, assetMediaString = assetMediaString, assetMediaStringFileName = assetMediaStringFileName, assetMediaStringContentType = assetMediaStringContentType, assetAttachedMedia = assetAttachedMedia, assetAttachedMediaUrl = assetAttachedMediaUrl, assetAttachedMediaString = assetAttachedMediaString, assetAttachedMediaStringFileName = assetAttachedMediaStringFileName, assetAttachedMediaStringContentType = assetAttachedMediaStringContentType, assetLocationDescription = assetLocationDescription, assetApp = assetApp, assetSearchTags = assetSearchTags, assetLatitude = assetLatitude, assetLongitude = assetLongitude)

        return request<Unit, NoteResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateNote
     *
     * @param noteId The id of the note, used when editing a comment
     * @param deviceId The unique device identifier that made the request (either deviceId or accountId must be used) (optional)
     * @param accountId The unique accountId that made the request (either deviceId or accountId must be used) (optional)
     * @param comment The message the user wishes to leave a comment on (optional)
     * @param noteType The custom string defined by the client (used for differentiating on various note types) (optional)
     * @param assetIds A comma separated list of asset IDs to add with the note (optional)
     * @param tags search tags (optional)
     * @param permissionableType This is used for sending out group notifications. For example, when someone adds a note to an asset which is also a part of an album, everyone in the album will receive a notification. This is achieved by passing in the permissionable type (in this case \&quot;album\&quot;), and the permissionable id (the album id). Possible types: {ALBUM, ALBUM_CONTEST, GAME_LEVEL, THEME_DESCRIPTOR} (optional)
     * @param permissionableId The id of the permissionable object (for sending group notifications) (optional)
     * @param appKey The application key used to identify the application (optional)
     * @param locationDescription The description of the location (optional)
     * @param latitude The current location of the user (optional)
     * @param longitude The current location of the user (optional)
     * @param metaData meta data to update with the note (optional)
     * @param returnFullResponse whether to return the full response or not (optional)
     * @param active Sets the active flag for the note (optional)
     * @param updateAsset main flag for updating asset in note, must set to true if you want to update the note&#39;s asset (optional)
     * @param assetReturnNulls Return null fields for asset response when updating an asset (optional)
     * @param assetAlbumId the album the asset will be added to (optional) (optional)
     * @param assetCollectionId the collection ID that the asset is associated with (optional)
     * @param assetAddToDefaultAlbum the default album to add the asset to (optional)
     * @param assetAddToMediaLibrary the media library to add the asset to (optional)
     * @param assetVersionCode the version code of the asset (optional)
     * @param assetVersionName the version name of the asset (optional)
     * @param assetMetaData the meta data of the asset (optional)
     * @param assetCaption the caption of the asset (optional)
     * @param assetMedia the media of the asset (optional)
     * @param assetMediaUrl the media URL of the asset (optional)
     * @param assetMediaString the media string of the asset (optional)
     * @param assetMediaStringFileName the media string file name of the asset (optional)
     * @param assetMediaStringContentType the media string content type of the asset (optional)
     * @param assetAttachedMedia the attached media of the asset (optional)
     * @param assetAttachedMediaUrl the attached media URL of the asset (optional)
     * @param assetAttachedMediaString the attached media string of the asset (optional)
     * @param assetAttachedMediaStringFileName the attached media string file name of the asset (optional)
     * @param assetAttachedMediaStringContentType the attached media string content type of the asset (optional)
     * @param assetLocationDescription the location description for the asset (optional)
     * @param assetApp the application for the asset (optional)
     * @param assetSearchTags the search tags used for the asset (optional)
     * @param assetLatitude the latitude of the asset (optional)
     * @param assetLongitude the longitude of the asset (optional)
     * @return RequestConfig
     */
    fun updateNoteRequestConfig(noteId: kotlin.Long, deviceId: kotlin.String?, accountId: kotlin.Long?, comment: kotlin.String?, noteType: kotlin.String?, assetIds: kotlin.String?, tags: kotlin.String?, permissionableType: kotlin.String?, permissionableId: kotlin.Long?, appKey: kotlin.String?, locationDescription: kotlin.String?, latitude: kotlin.Double?, longitude: kotlin.Double?, metaData: kotlin.String?, returnFullResponse: kotlin.Boolean?, active: kotlin.Boolean?, updateAsset: kotlin.Boolean?, assetReturnNulls: kotlin.Boolean?, assetAlbumId: kotlin.Long?, assetCollectionId: kotlin.Long?, assetAddToDefaultAlbum: kotlin.String?, assetAddToMediaLibrary: kotlin.Boolean?, assetVersionCode: kotlin.Int?, assetVersionName: kotlin.String?, assetMetaData: kotlin.String?, assetCaption: kotlin.String?, assetMedia: java.io.File?, assetMediaUrl: kotlin.String?, assetMediaString: kotlin.String?, assetMediaStringFileName: kotlin.String?, assetMediaStringContentType: kotlin.String?, assetAttachedMedia: java.io.File?, assetAttachedMediaUrl: kotlin.String?, assetAttachedMediaString: kotlin.String?, assetAttachedMediaStringFileName: kotlin.String?, assetAttachedMediaStringContentType: kotlin.String?, assetLocationDescription: kotlin.String?, assetApp: kotlin.String?, assetSearchTags: kotlin.String?, assetLatitude: kotlin.Double?, assetLongitude: kotlin.Double?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                put("noteId", listOf(noteId.toString()))
                if (comment != null) {
                    put("comment", listOf(comment.toString()))
                }
                if (noteType != null) {
                    put("noteType", listOf(noteType.toString()))
                }
                if (assetIds != null) {
                    put("assetIds", listOf(assetIds.toString()))
                }
                if (tags != null) {
                    put("tags", listOf(tags.toString()))
                }
                if (permissionableType != null) {
                    put("permissionableType", listOf(permissionableType.toString()))
                }
                if (permissionableId != null) {
                    put("permissionableId", listOf(permissionableId.toString()))
                }
                if (appKey != null) {
                    put("appKey", listOf(appKey.toString()))
                }
                if (locationDescription != null) {
                    put("locationDescription", listOf(locationDescription.toString()))
                }
                if (latitude != null) {
                    put("latitude", listOf(latitude.toString()))
                }
                if (longitude != null) {
                    put("longitude", listOf(longitude.toString()))
                }
                if (metaData != null) {
                    put("metaData", listOf(metaData.toString()))
                }
                if (returnFullResponse != null) {
                    put("returnFullResponse", listOf(returnFullResponse.toString()))
                }
                if (active != null) {
                    put("active", listOf(active.toString()))
                }
                if (updateAsset != null) {
                    put("updateAsset", listOf(updateAsset.toString()))
                }
                if (assetReturnNulls != null) {
                    put("assetReturnNulls", listOf(assetReturnNulls.toString()))
                }
                if (assetAlbumId != null) {
                    put("assetAlbumId", listOf(assetAlbumId.toString()))
                }
                if (assetCollectionId != null) {
                    put("assetCollectionId", listOf(assetCollectionId.toString()))
                }
                if (assetAddToDefaultAlbum != null) {
                    put("assetAddToDefaultAlbum", listOf(assetAddToDefaultAlbum.toString()))
                }
                if (assetAddToMediaLibrary != null) {
                    put("assetAddToMediaLibrary", listOf(assetAddToMediaLibrary.toString()))
                }
                if (assetVersionCode != null) {
                    put("assetVersionCode", listOf(assetVersionCode.toString()))
                }
                if (assetVersionName != null) {
                    put("assetVersionName", listOf(assetVersionName.toString()))
                }
                if (assetMetaData != null) {
                    put("assetMetaData", listOf(assetMetaData.toString()))
                }
                if (assetCaption != null) {
                    put("assetCaption", listOf(assetCaption.toString()))
                }
                if (assetMedia != null) {
                    put("assetMedia", listOf(assetMedia.toString()))
                }
                if (assetMediaUrl != null) {
                    put("assetMediaUrl", listOf(assetMediaUrl.toString()))
                }
                if (assetMediaString != null) {
                    put("assetMediaString", listOf(assetMediaString.toString()))
                }
                if (assetMediaStringFileName != null) {
                    put("assetMediaStringFileName", listOf(assetMediaStringFileName.toString()))
                }
                if (assetMediaStringContentType != null) {
                    put("assetMediaStringContentType", listOf(assetMediaStringContentType.toString()))
                }
                if (assetAttachedMedia != null) {
                    put("assetAttachedMedia", listOf(assetAttachedMedia.toString()))
                }
                if (assetAttachedMediaUrl != null) {
                    put("assetAttachedMediaUrl", listOf(assetAttachedMediaUrl.toString()))
                }
                if (assetAttachedMediaString != null) {
                    put("assetAttachedMediaString", listOf(assetAttachedMediaString.toString()))
                }
                if (assetAttachedMediaStringFileName != null) {
                    put("assetAttachedMediaStringFileName", listOf(assetAttachedMediaStringFileName.toString()))
                }
                if (assetAttachedMediaStringContentType != null) {
                    put("assetAttachedMediaStringContentType", listOf(assetAttachedMediaStringContentType.toString()))
                }
                if (assetLocationDescription != null) {
                    put("assetLocationDescription", listOf(assetLocationDescription.toString()))
                }
                if (assetApp != null) {
                    put("assetApp", listOf(assetApp.toString()))
                }
                if (assetSearchTags != null) {
                    put("assetSearchTags", listOf(assetSearchTags.toString()))
                }
                if (assetLatitude != null) {
                    put("assetLatitude", listOf(assetLatitude.toString()))
                }
                if (assetLongitude != null) {
                    put("assetLongitude", listOf(assetLongitude.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/note/update",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
