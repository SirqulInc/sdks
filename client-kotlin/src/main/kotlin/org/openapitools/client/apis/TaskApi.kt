/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import org.openapitools.client.models.SirqulResponse
import org.openapitools.client.models.TaskResponse

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

open class TaskApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost")
        }
    }

    /**
     * enum for parameter visibility
     */
     enum class VisibilityCreateTask(val value: kotlin.String) {
         @Json(name = "PUBLIC") PUBLIC("PUBLIC"),
         @Json(name = "PRIVATE") PRIVATE("PRIVATE"),
         @Json(name = "FRIENDS") FRIENDS("FRIENDS");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * POST /api/{version}/task/create
     * Create Task
     * Create a Task
     * @param version 
     * @param accountId The logged in user.
     * @param name The name of the task
     * @param appKey The application to target (optional)
     * @param groupingId Client defined identifier for grouping tasks (optional)
     * @param endpointURL The URL for making an HTTP call (optional)
     * @param payload The parameters for making an HTTP call (optional)
     * @param scheduledDate The date and time of the task (optional)
     * @param startDate The starting date of the task (optional)
     * @param endDate The ending date of the task (optional)
     * @param cronExpression The cron expression that represents the task&#39;s schedule (optional)
     * @param visibility The determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited) (optional)
     * @param active Sets whether the Task is active or not (inactive Tasks are not processed) (optional, default to true)
     * @return TaskResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createTask(version: java.math.BigDecimal, accountId: kotlin.Long, name: kotlin.String, appKey: kotlin.String? = null, groupingId: kotlin.String? = null, endpointURL: kotlin.String? = null, payload: kotlin.String? = null, scheduledDate: kotlin.Long? = null, startDate: kotlin.Long? = null, endDate: kotlin.Long? = null, cronExpression: kotlin.String? = null, visibility: VisibilityCreateTask? = null, active: kotlin.Boolean? = true) : TaskResponse {
        val localVarResponse = createTaskWithHttpInfo(version = version, accountId = accountId, name = name, appKey = appKey, groupingId = groupingId, endpointURL = endpointURL, payload = payload, scheduledDate = scheduledDate, startDate = startDate, endDate = endDate, cronExpression = cronExpression, visibility = visibility, active = active)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TaskResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/{version}/task/create
     * Create Task
     * Create a Task
     * @param version 
     * @param accountId The logged in user.
     * @param name The name of the task
     * @param appKey The application to target (optional)
     * @param groupingId Client defined identifier for grouping tasks (optional)
     * @param endpointURL The URL for making an HTTP call (optional)
     * @param payload The parameters for making an HTTP call (optional)
     * @param scheduledDate The date and time of the task (optional)
     * @param startDate The starting date of the task (optional)
     * @param endDate The ending date of the task (optional)
     * @param cronExpression The cron expression that represents the task&#39;s schedule (optional)
     * @param visibility The determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited) (optional)
     * @param active Sets whether the Task is active or not (inactive Tasks are not processed) (optional, default to true)
     * @return ApiResponse<TaskResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createTaskWithHttpInfo(version: java.math.BigDecimal, accountId: kotlin.Long, name: kotlin.String, appKey: kotlin.String?, groupingId: kotlin.String?, endpointURL: kotlin.String?, payload: kotlin.String?, scheduledDate: kotlin.Long?, startDate: kotlin.Long?, endDate: kotlin.Long?, cronExpression: kotlin.String?, visibility: VisibilityCreateTask?, active: kotlin.Boolean?) : ApiResponse<TaskResponse?> {
        val localVariableConfig = createTaskRequestConfig(version = version, accountId = accountId, name = name, appKey = appKey, groupingId = groupingId, endpointURL = endpointURL, payload = payload, scheduledDate = scheduledDate, startDate = startDate, endDate = endDate, cronExpression = cronExpression, visibility = visibility, active = active)

        return request<Unit, TaskResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createTask
     *
     * @param version 
     * @param accountId The logged in user.
     * @param name The name of the task
     * @param appKey The application to target (optional)
     * @param groupingId Client defined identifier for grouping tasks (optional)
     * @param endpointURL The URL for making an HTTP call (optional)
     * @param payload The parameters for making an HTTP call (optional)
     * @param scheduledDate The date and time of the task (optional)
     * @param startDate The starting date of the task (optional)
     * @param endDate The ending date of the task (optional)
     * @param cronExpression The cron expression that represents the task&#39;s schedule (optional)
     * @param visibility The determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited) (optional)
     * @param active Sets whether the Task is active or not (inactive Tasks are not processed) (optional, default to true)
     * @return RequestConfig
     */
    fun createTaskRequestConfig(version: java.math.BigDecimal, accountId: kotlin.Long, name: kotlin.String, appKey: kotlin.String?, groupingId: kotlin.String?, endpointURL: kotlin.String?, payload: kotlin.String?, scheduledDate: kotlin.Long?, startDate: kotlin.Long?, endDate: kotlin.Long?, cronExpression: kotlin.String?, visibility: VisibilityCreateTask?, active: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("name", listOf(name.toString()))
                if (appKey != null) {
                    put("appKey", listOf(appKey.toString()))
                }
                if (groupingId != null) {
                    put("groupingId", listOf(groupingId.toString()))
                }
                if (endpointURL != null) {
                    put("endpointURL", listOf(endpointURL.toString()))
                }
                if (payload != null) {
                    put("payload", listOf(payload.toString()))
                }
                if (scheduledDate != null) {
                    put("scheduledDate", listOf(scheduledDate.toString()))
                }
                if (startDate != null) {
                    put("startDate", listOf(startDate.toString()))
                }
                if (endDate != null) {
                    put("endDate", listOf(endDate.toString()))
                }
                if (cronExpression != null) {
                    put("cronExpression", listOf(cronExpression.toString()))
                }
                if (visibility != null) {
                    put("visibility", listOf(visibility.value))
                }
                if (active != null) {
                    put("active", listOf(active.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/{version}/task/create".replace("{"+"version"+"}", encodeURIComponent(version.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/{version}/task/delete
     * Delete Task
     * Delete a Task
     * @param version 
     * @param accountId The logged in user.
     * @param taskId The id of the Task to delete.
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteTask(version: java.math.BigDecimal, accountId: kotlin.Long, taskId: kotlin.Long) : SirqulResponse {
        val localVarResponse = deleteTaskWithHttpInfo(version = version, accountId = accountId, taskId = taskId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/{version}/task/delete
     * Delete Task
     * Delete a Task
     * @param version 
     * @param accountId The logged in user.
     * @param taskId The id of the Task to delete.
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteTaskWithHttpInfo(version: java.math.BigDecimal, accountId: kotlin.Long, taskId: kotlin.Long) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = deleteTaskRequestConfig(version = version, accountId = accountId, taskId = taskId)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteTask
     *
     * @param version 
     * @param accountId The logged in user.
     * @param taskId The id of the Task to delete.
     * @return RequestConfig
     */
    fun deleteTaskRequestConfig(version: java.math.BigDecimal, accountId: kotlin.Long, taskId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("taskId", listOf(taskId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/{version}/task/delete".replace("{"+"version"+"}", encodeURIComponent(version.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /api/{version}/task/get
     * Get Task
     * Get a Task
     * @param version 
     * @param accountId The logged in user.
     * @param taskId The id of the Task to return.
     * @return TaskResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getTask(version: java.math.BigDecimal, accountId: kotlin.Long, taskId: kotlin.Long) : TaskResponse {
        val localVarResponse = getTaskWithHttpInfo(version = version, accountId = accountId, taskId = taskId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TaskResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/{version}/task/get
     * Get Task
     * Get a Task
     * @param version 
     * @param accountId The logged in user.
     * @param taskId The id of the Task to return.
     * @return ApiResponse<TaskResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getTaskWithHttpInfo(version: java.math.BigDecimal, accountId: kotlin.Long, taskId: kotlin.Long) : ApiResponse<TaskResponse?> {
        val localVariableConfig = getTaskRequestConfig(version = version, accountId = accountId, taskId = taskId)

        return request<Unit, TaskResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getTask
     *
     * @param version 
     * @param accountId The logged in user.
     * @param taskId The id of the Task to return.
     * @return RequestConfig
     */
    fun getTaskRequestConfig(version: java.math.BigDecimal, accountId: kotlin.Long, taskId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("taskId", listOf(taskId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/{version}/task/get".replace("{"+"version"+"}", encodeURIComponent(version.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /api/{version}/task/search
     * Search Tasks
     * Search on Tasks
     * @param version 
     * @param accountId The logged in user.
     * @param groupingId Filter results by a grouping identifier defined by the client (optional)
     * @param filter A comma separated list of filters:  * MINE - Return tasks that the user has created * SHARED - Return tasks that have been shared to the user * FOLLOWER - Return tasks that have been created by the user&#39;&#39;s followers (the content needs to have been APPROVED or FEATURED) * FOLLOWING - Return tasks that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED) * PUBLIC - Return all PUBLIC tasks that have been APPROVED or FEATURED * ALL_PUBLIC - Return all PUBLIC tasks regardless of whether they are approved or not (ignores the approval status) * LIKED - Return all tasks that the user has liked * FEATURED - Return all tasks that have been featured * PENDING - Return all pending tasks  (optional, default to "MINE")
     * @param statuses Filter results by status (comma separated list). Values include: NEW, ERROR, COMPLETE, PROCESSING, TEMPLATE (optional, default to "NEW,ERROR,COMPLETE,PROCESSING")
     * @param templateTypes Template Types (optional)
     * @param appKey Filter the list by a specific application (optional)
     * @param keyword Keyword search on the task names. (optional)
     * @param sortField The field to sort by. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, SCHEDULED_DATE, START_DATE, END_DATE (optional, default to "CREATED")
     * @param descending Determines whether the sorted list is in descending or ascending order (optional, default to true)
     * @param start Start the result set at some index. (optional, default to 0)
     * @param limit Limit the result to some number. (optional, default to 20)
     * @param activeOnly Determines whether to return only active results (optional, default to true)
     * @return kotlin.collections.List<TaskResponse>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun searchTasks(version: java.math.BigDecimal, accountId: kotlin.Long, groupingId: kotlin.String? = null, filter: kotlin.String? = "MINE", statuses: kotlin.String? = "NEW,ERROR,COMPLETE,PROCESSING", templateTypes: kotlin.String? = null, appKey: kotlin.String? = null, keyword: kotlin.String? = null, sortField: kotlin.String? = "CREATED", descending: kotlin.Boolean? = true, start: kotlin.Int? = 0, limit: kotlin.Int? = 20, activeOnly: kotlin.Boolean? = true) : kotlin.collections.List<TaskResponse> {
        val localVarResponse = searchTasksWithHttpInfo(version = version, accountId = accountId, groupingId = groupingId, filter = filter, statuses = statuses, templateTypes = templateTypes, appKey = appKey, keyword = keyword, sortField = sortField, descending = descending, start = start, limit = limit, activeOnly = activeOnly)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<TaskResponse>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/{version}/task/search
     * Search Tasks
     * Search on Tasks
     * @param version 
     * @param accountId The logged in user.
     * @param groupingId Filter results by a grouping identifier defined by the client (optional)
     * @param filter A comma separated list of filters:  * MINE - Return tasks that the user has created * SHARED - Return tasks that have been shared to the user * FOLLOWER - Return tasks that have been created by the user&#39;&#39;s followers (the content needs to have been APPROVED or FEATURED) * FOLLOWING - Return tasks that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED) * PUBLIC - Return all PUBLIC tasks that have been APPROVED or FEATURED * ALL_PUBLIC - Return all PUBLIC tasks regardless of whether they are approved or not (ignores the approval status) * LIKED - Return all tasks that the user has liked * FEATURED - Return all tasks that have been featured * PENDING - Return all pending tasks  (optional, default to "MINE")
     * @param statuses Filter results by status (comma separated list). Values include: NEW, ERROR, COMPLETE, PROCESSING, TEMPLATE (optional, default to "NEW,ERROR,COMPLETE,PROCESSING")
     * @param templateTypes Template Types (optional)
     * @param appKey Filter the list by a specific application (optional)
     * @param keyword Keyword search on the task names. (optional)
     * @param sortField The field to sort by. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, SCHEDULED_DATE, START_DATE, END_DATE (optional, default to "CREATED")
     * @param descending Determines whether the sorted list is in descending or ascending order (optional, default to true)
     * @param start Start the result set at some index. (optional, default to 0)
     * @param limit Limit the result to some number. (optional, default to 20)
     * @param activeOnly Determines whether to return only active results (optional, default to true)
     * @return ApiResponse<kotlin.collections.List<TaskResponse>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun searchTasksWithHttpInfo(version: java.math.BigDecimal, accountId: kotlin.Long, groupingId: kotlin.String?, filter: kotlin.String?, statuses: kotlin.String?, templateTypes: kotlin.String?, appKey: kotlin.String?, keyword: kotlin.String?, sortField: kotlin.String?, descending: kotlin.Boolean?, start: kotlin.Int?, limit: kotlin.Int?, activeOnly: kotlin.Boolean?) : ApiResponse<kotlin.collections.List<TaskResponse>?> {
        val localVariableConfig = searchTasksRequestConfig(version = version, accountId = accountId, groupingId = groupingId, filter = filter, statuses = statuses, templateTypes = templateTypes, appKey = appKey, keyword = keyword, sortField = sortField, descending = descending, start = start, limit = limit, activeOnly = activeOnly)

        return request<Unit, kotlin.collections.List<TaskResponse>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation searchTasks
     *
     * @param version 
     * @param accountId The logged in user.
     * @param groupingId Filter results by a grouping identifier defined by the client (optional)
     * @param filter A comma separated list of filters:  * MINE - Return tasks that the user has created * SHARED - Return tasks that have been shared to the user * FOLLOWER - Return tasks that have been created by the user&#39;&#39;s followers (the content needs to have been APPROVED or FEATURED) * FOLLOWING - Return tasks that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED) * PUBLIC - Return all PUBLIC tasks that have been APPROVED or FEATURED * ALL_PUBLIC - Return all PUBLIC tasks regardless of whether they are approved or not (ignores the approval status) * LIKED - Return all tasks that the user has liked * FEATURED - Return all tasks that have been featured * PENDING - Return all pending tasks  (optional, default to "MINE")
     * @param statuses Filter results by status (comma separated list). Values include: NEW, ERROR, COMPLETE, PROCESSING, TEMPLATE (optional, default to "NEW,ERROR,COMPLETE,PROCESSING")
     * @param templateTypes Template Types (optional)
     * @param appKey Filter the list by a specific application (optional)
     * @param keyword Keyword search on the task names. (optional)
     * @param sortField The field to sort by. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, SCHEDULED_DATE, START_DATE, END_DATE (optional, default to "CREATED")
     * @param descending Determines whether the sorted list is in descending or ascending order (optional, default to true)
     * @param start Start the result set at some index. (optional, default to 0)
     * @param limit Limit the result to some number. (optional, default to 20)
     * @param activeOnly Determines whether to return only active results (optional, default to true)
     * @return RequestConfig
     */
    fun searchTasksRequestConfig(version: java.math.BigDecimal, accountId: kotlin.Long, groupingId: kotlin.String?, filter: kotlin.String?, statuses: kotlin.String?, templateTypes: kotlin.String?, appKey: kotlin.String?, keyword: kotlin.String?, sortField: kotlin.String?, descending: kotlin.Boolean?, start: kotlin.Int?, limit: kotlin.Int?, activeOnly: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                if (groupingId != null) {
                    put("groupingId", listOf(groupingId.toString()))
                }
                if (filter != null) {
                    put("filter", listOf(filter.toString()))
                }
                if (statuses != null) {
                    put("statuses", listOf(statuses.toString()))
                }
                if (templateTypes != null) {
                    put("templateTypes", listOf(templateTypes.toString()))
                }
                if (appKey != null) {
                    put("appKey", listOf(appKey.toString()))
                }
                if (keyword != null) {
                    put("keyword", listOf(keyword.toString()))
                }
                if (sortField != null) {
                    put("sortField", listOf(sortField.toString()))
                }
                if (descending != null) {
                    put("descending", listOf(descending.toString()))
                }
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (activeOnly != null) {
                    put("activeOnly", listOf(activeOnly.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/{version}/task/search".replace("{"+"version"+"}", encodeURIComponent(version.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter visibility
     */
     enum class VisibilityUpdateTask(val value: kotlin.String) {
         @Json(name = "PUBLIC") PUBLIC("PUBLIC"),
         @Json(name = "PRIVATE") PRIVATE("PRIVATE"),
         @Json(name = "FRIENDS") FRIENDS("FRIENDS");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * POST /api/{version}/task/update
     * Update Task
     * Update a Task
     * @param version 
     * @param taskId Task Id
     * @param accountId The logged in user.
     * @param name The name of the task (optional)
     * @param appKey The application to target (optional)
     * @param groupingId Client defined identifier for grouping tasks (optional)
     * @param endpointURL The URL for making an HTTP call (optional)
     * @param payload The parameters for making an HTTP call (optional)
     * @param scheduledDate The date and time of the task (optional)
     * @param startDate The starting date of the task (optional)
     * @param endDate The ending date of the task (optional)
     * @param cronExpression The cron expression that represents the task&#39;s schedule (optional)
     * @param visibility The determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited) (optional)
     * @param active Sets whether the Task is active or not (inactive Tasks are not processed) (optional)
     * @return TaskResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updateTask(version: java.math.BigDecimal, taskId: kotlin.Long, accountId: kotlin.Long, name: kotlin.String? = null, appKey: kotlin.String? = null, groupingId: kotlin.String? = null, endpointURL: kotlin.String? = null, payload: kotlin.String? = null, scheduledDate: kotlin.Long? = null, startDate: kotlin.Long? = null, endDate: kotlin.Long? = null, cronExpression: kotlin.String? = null, visibility: VisibilityUpdateTask? = null, active: kotlin.Boolean? = null) : TaskResponse {
        val localVarResponse = updateTaskWithHttpInfo(version = version, taskId = taskId, accountId = accountId, name = name, appKey = appKey, groupingId = groupingId, endpointURL = endpointURL, payload = payload, scheduledDate = scheduledDate, startDate = startDate, endDate = endDate, cronExpression = cronExpression, visibility = visibility, active = active)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TaskResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/{version}/task/update
     * Update Task
     * Update a Task
     * @param version 
     * @param taskId Task Id
     * @param accountId The logged in user.
     * @param name The name of the task (optional)
     * @param appKey The application to target (optional)
     * @param groupingId Client defined identifier for grouping tasks (optional)
     * @param endpointURL The URL for making an HTTP call (optional)
     * @param payload The parameters for making an HTTP call (optional)
     * @param scheduledDate The date and time of the task (optional)
     * @param startDate The starting date of the task (optional)
     * @param endDate The ending date of the task (optional)
     * @param cronExpression The cron expression that represents the task&#39;s schedule (optional)
     * @param visibility The determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited) (optional)
     * @param active Sets whether the Task is active or not (inactive Tasks are not processed) (optional)
     * @return ApiResponse<TaskResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun updateTaskWithHttpInfo(version: java.math.BigDecimal, taskId: kotlin.Long, accountId: kotlin.Long, name: kotlin.String?, appKey: kotlin.String?, groupingId: kotlin.String?, endpointURL: kotlin.String?, payload: kotlin.String?, scheduledDate: kotlin.Long?, startDate: kotlin.Long?, endDate: kotlin.Long?, cronExpression: kotlin.String?, visibility: VisibilityUpdateTask?, active: kotlin.Boolean?) : ApiResponse<TaskResponse?> {
        val localVariableConfig = updateTaskRequestConfig(version = version, taskId = taskId, accountId = accountId, name = name, appKey = appKey, groupingId = groupingId, endpointURL = endpointURL, payload = payload, scheduledDate = scheduledDate, startDate = startDate, endDate = endDate, cronExpression = cronExpression, visibility = visibility, active = active)

        return request<Unit, TaskResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateTask
     *
     * @param version 
     * @param taskId Task Id
     * @param accountId The logged in user.
     * @param name The name of the task (optional)
     * @param appKey The application to target (optional)
     * @param groupingId Client defined identifier for grouping tasks (optional)
     * @param endpointURL The URL for making an HTTP call (optional)
     * @param payload The parameters for making an HTTP call (optional)
     * @param scheduledDate The date and time of the task (optional)
     * @param startDate The starting date of the task (optional)
     * @param endDate The ending date of the task (optional)
     * @param cronExpression The cron expression that represents the task&#39;s schedule (optional)
     * @param visibility The determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited) (optional)
     * @param active Sets whether the Task is active or not (inactive Tasks are not processed) (optional)
     * @return RequestConfig
     */
    fun updateTaskRequestConfig(version: java.math.BigDecimal, taskId: kotlin.Long, accountId: kotlin.Long, name: kotlin.String?, appKey: kotlin.String?, groupingId: kotlin.String?, endpointURL: kotlin.String?, payload: kotlin.String?, scheduledDate: kotlin.Long?, startDate: kotlin.Long?, endDate: kotlin.Long?, cronExpression: kotlin.String?, visibility: VisibilityUpdateTask?, active: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("taskId", listOf(taskId.toString()))
                put("accountId", listOf(accountId.toString()))
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (appKey != null) {
                    put("appKey", listOf(appKey.toString()))
                }
                if (groupingId != null) {
                    put("groupingId", listOf(groupingId.toString()))
                }
                if (endpointURL != null) {
                    put("endpointURL", listOf(endpointURL.toString()))
                }
                if (payload != null) {
                    put("payload", listOf(payload.toString()))
                }
                if (scheduledDate != null) {
                    put("scheduledDate", listOf(scheduledDate.toString()))
                }
                if (startDate != null) {
                    put("startDate", listOf(startDate.toString()))
                }
                if (endDate != null) {
                    put("endDate", listOf(endDate.toString()))
                }
                if (cronExpression != null) {
                    put("cronExpression", listOf(cronExpression.toString()))
                }
                if (visibility != null) {
                    put("visibility", listOf(visibility.value))
                }
                if (active != null) {
                    put("active", listOf(active.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/{version}/task/update".replace("{"+"version"+"}", encodeURIComponent(version.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
