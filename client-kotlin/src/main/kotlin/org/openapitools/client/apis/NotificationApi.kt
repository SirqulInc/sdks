/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import org.openapitools.client.models.BlockedNotificationResponse
import org.openapitools.client.models.NotificationMessageListResponse
import org.openapitools.client.models.NotificationRecipientResponse
import org.openapitools.client.models.NotificationRecipientResponseListResponse
import org.openapitools.client.models.NotificationTemplateResponse
import org.openapitools.client.models.SirqulResponse

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

open class NotificationApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://dev.sirqul.com/api/3.18")
        }
    }

    /**
     * POST /notification/template/create
     * Create Notification Template
     * Create a notification template. Developers will only be able to create notification templates for their own applications.
     * @param accountId The account ID of the user.
     * @param conduit Filter results by notification type: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.
     * @param title title of the notification template
     * @param body body of the notification template
     * @param appKey Filter results by application. (optional)
     * @param event Filter results by event. (optional)
     * @param tags tags associated with the note template (optional)
     * @return NotificationTemplateResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createNotificationTemplate(accountId: kotlin.Long, conduit: kotlin.String, title: kotlin.String, body: kotlin.String, appKey: kotlin.String? = null, event: kotlin.String? = null, tags: kotlin.String? = null) : NotificationTemplateResponse {
        val localVarResponse = createNotificationTemplateWithHttpInfo(accountId = accountId, conduit = conduit, title = title, body = body, appKey = appKey, event = event, tags = tags)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as NotificationTemplateResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /notification/template/create
     * Create Notification Template
     * Create a notification template. Developers will only be able to create notification templates for their own applications.
     * @param accountId The account ID of the user.
     * @param conduit Filter results by notification type: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.
     * @param title title of the notification template
     * @param body body of the notification template
     * @param appKey Filter results by application. (optional)
     * @param event Filter results by event. (optional)
     * @param tags tags associated with the note template (optional)
     * @return ApiResponse<NotificationTemplateResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createNotificationTemplateWithHttpInfo(accountId: kotlin.Long, conduit: kotlin.String, title: kotlin.String, body: kotlin.String, appKey: kotlin.String?, event: kotlin.String?, tags: kotlin.String?) : ApiResponse<NotificationTemplateResponse?> {
        val localVariableConfig = createNotificationTemplateRequestConfig(accountId = accountId, conduit = conduit, title = title, body = body, appKey = appKey, event = event, tags = tags)

        return request<Unit, NotificationTemplateResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createNotificationTemplate
     *
     * @param accountId The account ID of the user.
     * @param conduit Filter results by notification type: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.
     * @param title title of the notification template
     * @param body body of the notification template
     * @param appKey Filter results by application. (optional)
     * @param event Filter results by event. (optional)
     * @param tags tags associated with the note template (optional)
     * @return RequestConfig
     */
    fun createNotificationTemplateRequestConfig(accountId: kotlin.Long, conduit: kotlin.String, title: kotlin.String, body: kotlin.String, appKey: kotlin.String?, event: kotlin.String?, tags: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                if (appKey != null) {
                    put("appKey", listOf(appKey.toString()))
                }
                if (event != null) {
                    put("event", listOf(event.toString()))
                }
                put("conduit", listOf(conduit.toString()))
                put("title", listOf(title.toString()))
                put("body", listOf(body.toString()))
                if (tags != null) {
                    put("tags", listOf(tags.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/notification/template/create",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /notification/blocked/batch
     * Create or update blocked notification settings
     * Create or update blocked notification settings
     * @param appKey The application key
     * @param `data` batch data payload (application specific)
     * @param accountId the account id of the user (optional)
     * @return BlockedNotificationResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createOrUpdateBlockedNotifications(appKey: kotlin.String, `data`: kotlin.String, accountId: kotlin.Long? = null) : BlockedNotificationResponse {
        val localVarResponse = createOrUpdateBlockedNotificationsWithHttpInfo(appKey = appKey, `data` = `data`, accountId = accountId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BlockedNotificationResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /notification/blocked/batch
     * Create or update blocked notification settings
     * Create or update blocked notification settings
     * @param appKey The application key
     * @param `data` batch data payload (application specific)
     * @param accountId the account id of the user (optional)
     * @return ApiResponse<BlockedNotificationResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createOrUpdateBlockedNotificationsWithHttpInfo(appKey: kotlin.String, `data`: kotlin.String, accountId: kotlin.Long?) : ApiResponse<BlockedNotificationResponse?> {
        val localVariableConfig = createOrUpdateBlockedNotificationsRequestConfig(appKey = appKey, `data` = `data`, accountId = accountId)

        return request<Unit, BlockedNotificationResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createOrUpdateBlockedNotifications
     *
     * @param appKey The application key
     * @param `data` batch data payload (application specific)
     * @param accountId the account id of the user (optional)
     * @return RequestConfig
     */
    fun createOrUpdateBlockedNotificationsRequestConfig(appKey: kotlin.String, `data`: kotlin.String, accountId: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                put("appKey", listOf(appKey.toString()))
                put("data", listOf(`data`.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/notification/blocked/batch",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /notification/template/delete
     * Delete Notification Template
     * Deletes a notification template. Developers will only be able to delete notification templates for their own applications.
     * @param accountId the account id of the user
     * @param notificationTemplateId the id of the notification template to delete
     * @return NotificationTemplateResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteNotificationTemplate(accountId: kotlin.Long, notificationTemplateId: kotlin.Long) : NotificationTemplateResponse {
        val localVarResponse = deleteNotificationTemplateWithHttpInfo(accountId = accountId, notificationTemplateId = notificationTemplateId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as NotificationTemplateResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /notification/template/delete
     * Delete Notification Template
     * Deletes a notification template. Developers will only be able to delete notification templates for their own applications.
     * @param accountId the account id of the user
     * @param notificationTemplateId the id of the notification template to delete
     * @return ApiResponse<NotificationTemplateResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteNotificationTemplateWithHttpInfo(accountId: kotlin.Long, notificationTemplateId: kotlin.Long) : ApiResponse<NotificationTemplateResponse?> {
        val localVariableConfig = deleteNotificationTemplateRequestConfig(accountId = accountId, notificationTemplateId = notificationTemplateId)

        return request<Unit, NotificationTemplateResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteNotificationTemplate
     *
     * @param accountId the account id of the user
     * @param notificationTemplateId the id of the notification template to delete
     * @return RequestConfig
     */
    fun deleteNotificationTemplateRequestConfig(accountId: kotlin.Long, notificationTemplateId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("notificationTemplateId", listOf(notificationTemplateId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/notification/template/delete",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /notification/template/get
     * Get Notification Template
     * Get the details of a notification template. Developers will only be able to see notification templates for their own applications.
     * @param accountId the id of the account
     * @param notificationTemplateId the id of the notification template to get
     * @return NotificationTemplateResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getNotificationTemplate(accountId: kotlin.Long, notificationTemplateId: kotlin.Long) : NotificationTemplateResponse {
        val localVarResponse = getNotificationTemplateWithHttpInfo(accountId = accountId, notificationTemplateId = notificationTemplateId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as NotificationTemplateResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /notification/template/get
     * Get Notification Template
     * Get the details of a notification template. Developers will only be able to see notification templates for their own applications.
     * @param accountId the id of the account
     * @param notificationTemplateId the id of the notification template to get
     * @return ApiResponse<NotificationTemplateResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getNotificationTemplateWithHttpInfo(accountId: kotlin.Long, notificationTemplateId: kotlin.Long) : ApiResponse<NotificationTemplateResponse?> {
        val localVariableConfig = getNotificationTemplateRequestConfig(accountId = accountId, notificationTemplateId = notificationTemplateId)

        return request<Unit, NotificationTemplateResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getNotificationTemplate
     *
     * @param accountId the id of the account
     * @param notificationTemplateId the id of the notification template to get
     * @return RequestConfig
     */
    fun getNotificationTemplateRequestConfig(accountId: kotlin.Long, notificationTemplateId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("notificationTemplateId", listOf(notificationTemplateId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/notification/template/get",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /notification/search
     * Get Notifications
     * Get a list of notifications for a user. If the \&quot;markAsRead\&quot; parameter is set to true, the returned notifications will be marked as \&quot;read\&quot; after the response has been sent. By default, read messages will not be returned, so to see read messages, set \&quot;returnReadMessages\&quot; to true.
     * @param deviceId the unique id of the device making the request (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param connectionAccountId the account id used to view another person&#39;s notifications (optional)
     * @param appKey the application key to filter messages by application (optional)
     * @param eventType comma separated list of EVENTS. Filters search results to only include these events. Don&#39;t include this parameter or pass in an empty string to return all event types. (optional)
     * @param contentIds comma separated list of content ids to search notifications on (optional)
     * @param contentTypes comma separated list of content types to search notifications on (optional)
     * @param parentIds comma separated list of parent ids to search notifications on (optional)
     * @param parentTypes comma separated list of parent types to search notifications on (optional)
     * @param actionCategory Action category used to filter notifications (optional)
     * @param conduits comma separated list of conduits to search notifications on (optional)
     * @param keyword search notifications via keyword (optional)
     * @param returnReadMessages if set to true, will return notifications that have been marked as read (optional)
     * @param markAsRead if set to true, the returned notifications will be marked as \\\&quot;read\\\&quot; after the response has been sent (optional)
     * @param fromDate filter notifications from this date (optional)
     * @param latitude latitude used to update the user&#39;s current location (optional)
     * @param longitude longitude used to update the user&#39;s current location (optional)
     * @param returnSent whether to include notifications sent by the requester in the response (optional)
     * @param ignoreFlagged whether to ignore flagged notifications (optional)
     * @param start start of the pagination (optional)
     * @param limit limit of the pagination (optional)
     * @return NotificationMessageListResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getNotifications(deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, connectionAccountId: kotlin.Long? = null, appKey: kotlin.String? = null, eventType: kotlin.String? = null, contentIds: kotlin.String? = null, contentTypes: kotlin.String? = null, parentIds: kotlin.String? = null, parentTypes: kotlin.String? = null, actionCategory: kotlin.String? = null, conduits: kotlin.String? = null, keyword: kotlin.String? = null, returnReadMessages: kotlin.Boolean? = null, markAsRead: kotlin.Boolean? = null, fromDate: kotlin.Long? = null, latitude: kotlin.Double? = null, longitude: kotlin.Double? = null, returnSent: kotlin.Boolean? = null, ignoreFlagged: kotlin.Boolean? = null, start: kotlin.Int? = null, limit: kotlin.Int? = null) : NotificationMessageListResponse {
        val localVarResponse = getNotificationsWithHttpInfo(deviceId = deviceId, accountId = accountId, connectionAccountId = connectionAccountId, appKey = appKey, eventType = eventType, contentIds = contentIds, contentTypes = contentTypes, parentIds = parentIds, parentTypes = parentTypes, actionCategory = actionCategory, conduits = conduits, keyword = keyword, returnReadMessages = returnReadMessages, markAsRead = markAsRead, fromDate = fromDate, latitude = latitude, longitude = longitude, returnSent = returnSent, ignoreFlagged = ignoreFlagged, start = start, limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as NotificationMessageListResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /notification/search
     * Get Notifications
     * Get a list of notifications for a user. If the \&quot;markAsRead\&quot; parameter is set to true, the returned notifications will be marked as \&quot;read\&quot; after the response has been sent. By default, read messages will not be returned, so to see read messages, set \&quot;returnReadMessages\&quot; to true.
     * @param deviceId the unique id of the device making the request (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param connectionAccountId the account id used to view another person&#39;s notifications (optional)
     * @param appKey the application key to filter messages by application (optional)
     * @param eventType comma separated list of EVENTS. Filters search results to only include these events. Don&#39;t include this parameter or pass in an empty string to return all event types. (optional)
     * @param contentIds comma separated list of content ids to search notifications on (optional)
     * @param contentTypes comma separated list of content types to search notifications on (optional)
     * @param parentIds comma separated list of parent ids to search notifications on (optional)
     * @param parentTypes comma separated list of parent types to search notifications on (optional)
     * @param actionCategory Action category used to filter notifications (optional)
     * @param conduits comma separated list of conduits to search notifications on (optional)
     * @param keyword search notifications via keyword (optional)
     * @param returnReadMessages if set to true, will return notifications that have been marked as read (optional)
     * @param markAsRead if set to true, the returned notifications will be marked as \\\&quot;read\\\&quot; after the response has been sent (optional)
     * @param fromDate filter notifications from this date (optional)
     * @param latitude latitude used to update the user&#39;s current location (optional)
     * @param longitude longitude used to update the user&#39;s current location (optional)
     * @param returnSent whether to include notifications sent by the requester in the response (optional)
     * @param ignoreFlagged whether to ignore flagged notifications (optional)
     * @param start start of the pagination (optional)
     * @param limit limit of the pagination (optional)
     * @return ApiResponse<NotificationMessageListResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getNotificationsWithHttpInfo(deviceId: kotlin.String?, accountId: kotlin.Long?, connectionAccountId: kotlin.Long?, appKey: kotlin.String?, eventType: kotlin.String?, contentIds: kotlin.String?, contentTypes: kotlin.String?, parentIds: kotlin.String?, parentTypes: kotlin.String?, actionCategory: kotlin.String?, conduits: kotlin.String?, keyword: kotlin.String?, returnReadMessages: kotlin.Boolean?, markAsRead: kotlin.Boolean?, fromDate: kotlin.Long?, latitude: kotlin.Double?, longitude: kotlin.Double?, returnSent: kotlin.Boolean?, ignoreFlagged: kotlin.Boolean?, start: kotlin.Int?, limit: kotlin.Int?) : ApiResponse<NotificationMessageListResponse?> {
        val localVariableConfig = getNotificationsRequestConfig(deviceId = deviceId, accountId = accountId, connectionAccountId = connectionAccountId, appKey = appKey, eventType = eventType, contentIds = contentIds, contentTypes = contentTypes, parentIds = parentIds, parentTypes = parentTypes, actionCategory = actionCategory, conduits = conduits, keyword = keyword, returnReadMessages = returnReadMessages, markAsRead = markAsRead, fromDate = fromDate, latitude = latitude, longitude = longitude, returnSent = returnSent, ignoreFlagged = ignoreFlagged, start = start, limit = limit)

        return request<Unit, NotificationMessageListResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getNotifications
     *
     * @param deviceId the unique id of the device making the request (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param connectionAccountId the account id used to view another person&#39;s notifications (optional)
     * @param appKey the application key to filter messages by application (optional)
     * @param eventType comma separated list of EVENTS. Filters search results to only include these events. Don&#39;t include this parameter or pass in an empty string to return all event types. (optional)
     * @param contentIds comma separated list of content ids to search notifications on (optional)
     * @param contentTypes comma separated list of content types to search notifications on (optional)
     * @param parentIds comma separated list of parent ids to search notifications on (optional)
     * @param parentTypes comma separated list of parent types to search notifications on (optional)
     * @param actionCategory Action category used to filter notifications (optional)
     * @param conduits comma separated list of conduits to search notifications on (optional)
     * @param keyword search notifications via keyword (optional)
     * @param returnReadMessages if set to true, will return notifications that have been marked as read (optional)
     * @param markAsRead if set to true, the returned notifications will be marked as \\\&quot;read\\\&quot; after the response has been sent (optional)
     * @param fromDate filter notifications from this date (optional)
     * @param latitude latitude used to update the user&#39;s current location (optional)
     * @param longitude longitude used to update the user&#39;s current location (optional)
     * @param returnSent whether to include notifications sent by the requester in the response (optional)
     * @param ignoreFlagged whether to ignore flagged notifications (optional)
     * @param start start of the pagination (optional)
     * @param limit limit of the pagination (optional)
     * @return RequestConfig
     */
    fun getNotificationsRequestConfig(deviceId: kotlin.String?, accountId: kotlin.Long?, connectionAccountId: kotlin.Long?, appKey: kotlin.String?, eventType: kotlin.String?, contentIds: kotlin.String?, contentTypes: kotlin.String?, parentIds: kotlin.String?, parentTypes: kotlin.String?, actionCategory: kotlin.String?, conduits: kotlin.String?, keyword: kotlin.String?, returnReadMessages: kotlin.Boolean?, markAsRead: kotlin.Boolean?, fromDate: kotlin.Long?, latitude: kotlin.Double?, longitude: kotlin.Double?, returnSent: kotlin.Boolean?, ignoreFlagged: kotlin.Boolean?, start: kotlin.Int?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (connectionAccountId != null) {
                    put("connectionAccountId", listOf(connectionAccountId.toString()))
                }
                if (appKey != null) {
                    put("appKey", listOf(appKey.toString()))
                }
                if (eventType != null) {
                    put("eventType", listOf(eventType.toString()))
                }
                if (contentIds != null) {
                    put("contentIds", listOf(contentIds.toString()))
                }
                if (contentTypes != null) {
                    put("contentTypes", listOf(contentTypes.toString()))
                }
                if (parentIds != null) {
                    put("parentIds", listOf(parentIds.toString()))
                }
                if (parentTypes != null) {
                    put("parentTypes", listOf(parentTypes.toString()))
                }
                if (actionCategory != null) {
                    put("actionCategory", listOf(actionCategory.toString()))
                }
                if (conduits != null) {
                    put("conduits", listOf(conduits.toString()))
                }
                if (keyword != null) {
                    put("keyword", listOf(keyword.toString()))
                }
                if (returnReadMessages != null) {
                    put("returnReadMessages", listOf(returnReadMessages.toString()))
                }
                if (markAsRead != null) {
                    put("markAsRead", listOf(markAsRead.toString()))
                }
                if (fromDate != null) {
                    put("fromDate", listOf(fromDate.toString()))
                }
                if (latitude != null) {
                    put("latitude", listOf(latitude.toString()))
                }
                if (longitude != null) {
                    put("longitude", listOf(longitude.toString()))
                }
                if (returnSent != null) {
                    put("returnSent", listOf(returnSent.toString()))
                }
                if (ignoreFlagged != null) {
                    put("ignoreFlagged", listOf(ignoreFlagged.toString()))
                }
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/notification/search",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter pushType
     */
     enum class PushTypeRegisterNotificationToken(val value: kotlin.String) {
         @Json(name = "APNS") APNS("APNS"),
         @Json(name = "GCM") GCM("GCM"),
         @Json(name = "BAIDU") BAIDU("BAIDU"),
         @Json(name = "XGPUSH") XGPUSH("XGPUSH"),
         @Json(name = "JPUSH") JPUSH("JPUSH");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * POST /notification/token
     * Register Notification Token
     * Register a token to send application dependent notifications like Google Cloud Messaging, or Apple Push Notifications.
     * @param token A token that is generated by the device to sign requests for the notification service providers
     * @param pushType The type of push notification. Possible values include: APNS, GCM
     * @param deviceId The unique id of the device making the request (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param environment Determines if the token is a DEVELOPMENT or PRODUCTION token (optional)
     * @param appKey The application key (optional)
     * @param gameType This parameter is deprecated (use appKey instead) (optional)
     * @param active Sets whether the token is active or not (non-active tokens are not used) (optional)
     * @param latitude Latitude used to update the user&#39;s current location (optional)
     * @param longitude Longitude used to update the user&#39;s current location (optional)
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun registerNotificationToken(token: kotlin.String, pushType: PushTypeRegisterNotificationToken, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, environment: kotlin.String? = null, appKey: kotlin.String? = null, gameType: kotlin.String? = null, active: kotlin.Boolean? = null, latitude: kotlin.Double? = null, longitude: kotlin.Double? = null) : SirqulResponse {
        val localVarResponse = registerNotificationTokenWithHttpInfo(token = token, pushType = pushType, deviceId = deviceId, accountId = accountId, environment = environment, appKey = appKey, gameType = gameType, active = active, latitude = latitude, longitude = longitude)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /notification/token
     * Register Notification Token
     * Register a token to send application dependent notifications like Google Cloud Messaging, or Apple Push Notifications.
     * @param token A token that is generated by the device to sign requests for the notification service providers
     * @param pushType The type of push notification. Possible values include: APNS, GCM
     * @param deviceId The unique id of the device making the request (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param environment Determines if the token is a DEVELOPMENT or PRODUCTION token (optional)
     * @param appKey The application key (optional)
     * @param gameType This parameter is deprecated (use appKey instead) (optional)
     * @param active Sets whether the token is active or not (non-active tokens are not used) (optional)
     * @param latitude Latitude used to update the user&#39;s current location (optional)
     * @param longitude Longitude used to update the user&#39;s current location (optional)
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun registerNotificationTokenWithHttpInfo(token: kotlin.String, pushType: PushTypeRegisterNotificationToken, deviceId: kotlin.String?, accountId: kotlin.Long?, environment: kotlin.String?, appKey: kotlin.String?, gameType: kotlin.String?, active: kotlin.Boolean?, latitude: kotlin.Double?, longitude: kotlin.Double?) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = registerNotificationTokenRequestConfig(token = token, pushType = pushType, deviceId = deviceId, accountId = accountId, environment = environment, appKey = appKey, gameType = gameType, active = active, latitude = latitude, longitude = longitude)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation registerNotificationToken
     *
     * @param token A token that is generated by the device to sign requests for the notification service providers
     * @param pushType The type of push notification. Possible values include: APNS, GCM
     * @param deviceId The unique id of the device making the request (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param environment Determines if the token is a DEVELOPMENT or PRODUCTION token (optional)
     * @param appKey The application key (optional)
     * @param gameType This parameter is deprecated (use appKey instead) (optional)
     * @param active Sets whether the token is active or not (non-active tokens are not used) (optional)
     * @param latitude Latitude used to update the user&#39;s current location (optional)
     * @param longitude Longitude used to update the user&#39;s current location (optional)
     * @return RequestConfig
     */
    fun registerNotificationTokenRequestConfig(token: kotlin.String, pushType: PushTypeRegisterNotificationToken, deviceId: kotlin.String?, accountId: kotlin.Long?, environment: kotlin.String?, appKey: kotlin.String?, gameType: kotlin.String?, active: kotlin.Boolean?, latitude: kotlin.Double?, longitude: kotlin.Double?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                put("token", listOf(token.toString()))
                put("pushType", listOf(pushType.value))
                if (environment != null) {
                    put("environment", listOf(environment.toString()))
                }
                if (appKey != null) {
                    put("appKey", listOf(appKey.toString()))
                }
                if (gameType != null) {
                    put("gameType", listOf(gameType.toString()))
                }
                if (active != null) {
                    put("active", listOf(active.toString()))
                }
                if (latitude != null) {
                    put("latitude", listOf(latitude.toString()))
                }
                if (longitude != null) {
                    put("longitude", listOf(longitude.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/notification/token",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /notification/blocked/search
     * Search on the user&#39;s blocked notification settings
     * Search on the user&#39;s blocked notification settings
     * @param appKey The application key
     * @param accountId the account id of the user (optional)
     * @param searchTags search tags to filter results (optional)
     * @param events events to filter by (comma separated) (optional)
     * @param conduits conduits to filter by (comma separated) (optional)
     * @param customTypes custom types to filter by (comma separated) (optional)
     * @param contentTypes content types to filter by (comma separated) (optional)
     * @param contentIds content ids to filter by (comma separated) (optional)
     * @param sortField sort field for results (optional)
     * @param descending whether to sort descending (optional)
     * @param start start of the pagination (optional)
     * @param limit limit of the pagination (optional)
     * @return BlockedNotificationResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun searchBlockedNotifications(appKey: kotlin.String, accountId: kotlin.Long? = null, searchTags: kotlin.String? = null, events: kotlin.String? = null, conduits: kotlin.String? = null, customTypes: kotlin.String? = null, contentTypes: kotlin.String? = null, contentIds: kotlin.String? = null, sortField: kotlin.String? = null, descending: kotlin.Boolean? = null, start: kotlin.Int? = null, limit: kotlin.Int? = null) : BlockedNotificationResponse {
        val localVarResponse = searchBlockedNotificationsWithHttpInfo(appKey = appKey, accountId = accountId, searchTags = searchTags, events = events, conduits = conduits, customTypes = customTypes, contentTypes = contentTypes, contentIds = contentIds, sortField = sortField, descending = descending, start = start, limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BlockedNotificationResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /notification/blocked/search
     * Search on the user&#39;s blocked notification settings
     * Search on the user&#39;s blocked notification settings
     * @param appKey The application key
     * @param accountId the account id of the user (optional)
     * @param searchTags search tags to filter results (optional)
     * @param events events to filter by (comma separated) (optional)
     * @param conduits conduits to filter by (comma separated) (optional)
     * @param customTypes custom types to filter by (comma separated) (optional)
     * @param contentTypes content types to filter by (comma separated) (optional)
     * @param contentIds content ids to filter by (comma separated) (optional)
     * @param sortField sort field for results (optional)
     * @param descending whether to sort descending (optional)
     * @param start start of the pagination (optional)
     * @param limit limit of the pagination (optional)
     * @return ApiResponse<BlockedNotificationResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun searchBlockedNotificationsWithHttpInfo(appKey: kotlin.String, accountId: kotlin.Long?, searchTags: kotlin.String?, events: kotlin.String?, conduits: kotlin.String?, customTypes: kotlin.String?, contentTypes: kotlin.String?, contentIds: kotlin.String?, sortField: kotlin.String?, descending: kotlin.Boolean?, start: kotlin.Int?, limit: kotlin.Int?) : ApiResponse<BlockedNotificationResponse?> {
        val localVariableConfig = searchBlockedNotificationsRequestConfig(appKey = appKey, accountId = accountId, searchTags = searchTags, events = events, conduits = conduits, customTypes = customTypes, contentTypes = contentTypes, contentIds = contentIds, sortField = sortField, descending = descending, start = start, limit = limit)

        return request<Unit, BlockedNotificationResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation searchBlockedNotifications
     *
     * @param appKey The application key
     * @param accountId the account id of the user (optional)
     * @param searchTags search tags to filter results (optional)
     * @param events events to filter by (comma separated) (optional)
     * @param conduits conduits to filter by (comma separated) (optional)
     * @param customTypes custom types to filter by (comma separated) (optional)
     * @param contentTypes content types to filter by (comma separated) (optional)
     * @param contentIds content ids to filter by (comma separated) (optional)
     * @param sortField sort field for results (optional)
     * @param descending whether to sort descending (optional)
     * @param start start of the pagination (optional)
     * @param limit limit of the pagination (optional)
     * @return RequestConfig
     */
    fun searchBlockedNotificationsRequestConfig(appKey: kotlin.String, accountId: kotlin.Long?, searchTags: kotlin.String?, events: kotlin.String?, conduits: kotlin.String?, customTypes: kotlin.String?, contentTypes: kotlin.String?, contentIds: kotlin.String?, sortField: kotlin.String?, descending: kotlin.Boolean?, start: kotlin.Int?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                put("appKey", listOf(appKey.toString()))
                if (searchTags != null) {
                    put("searchTags", listOf(searchTags.toString()))
                }
                if (events != null) {
                    put("events", listOf(events.toString()))
                }
                if (conduits != null) {
                    put("conduits", listOf(conduits.toString()))
                }
                if (customTypes != null) {
                    put("customTypes", listOf(customTypes.toString()))
                }
                if (contentTypes != null) {
                    put("contentTypes", listOf(contentTypes.toString()))
                }
                if (contentIds != null) {
                    put("contentIds", listOf(contentIds.toString()))
                }
                if (sortField != null) {
                    put("sortField", listOf(sortField.toString()))
                }
                if (descending != null) {
                    put("descending", listOf(descending.toString()))
                }
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/notification/blocked/search",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /notification/template/search
     * Search Notification Templates
     * Search for notification templates on owned applications.
     * @param accountId The account ID of the user.
     * @param sortField Specifies how results are ordered.ID - order results by the notificationTemplateId CREATED - order results by the created date UPDATED - order results by the updated date TITLE - order results by title EVENT - order results by event CONDUIT - order results by conduit APP_NAME - order results by the application name (&#39;global&#39; templates will not have an application and will be returned last if &#39;descending&#39; is set to false.
     * @param descending Specified whether the results are returned in descending or ascending order.
     * @param start The start of the pagination.
     * @param limit The limit of the pagination.
     * @param appKey Filter results by application. (optional)
     * @param event Filter results by event. (optional)
     * @param conduit Filter results by notification type: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION. (optional)
     * @param globalOnly Returns only templates that have been reserved for system use on all applications (only for admin accounts). (optional)
     * @param reservedOnly Returns only templates that use reserved events. (optional)
     * @param keyword Filter results by keyword on the title, tags. (optional)
     * @return NotificationTemplateResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun searchNotificationTemplate(accountId: kotlin.Long, sortField: kotlin.String, descending: kotlin.Boolean, start: kotlin.Int, limit: kotlin.Int, appKey: kotlin.String? = null, event: kotlin.String? = null, conduit: kotlin.String? = null, globalOnly: kotlin.Boolean? = null, reservedOnly: kotlin.Boolean? = null, keyword: kotlin.String? = null) : NotificationTemplateResponse {
        val localVarResponse = searchNotificationTemplateWithHttpInfo(accountId = accountId, sortField = sortField, descending = descending, start = start, limit = limit, appKey = appKey, event = event, conduit = conduit, globalOnly = globalOnly, reservedOnly = reservedOnly, keyword = keyword)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as NotificationTemplateResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /notification/template/search
     * Search Notification Templates
     * Search for notification templates on owned applications.
     * @param accountId The account ID of the user.
     * @param sortField Specifies how results are ordered.ID - order results by the notificationTemplateId CREATED - order results by the created date UPDATED - order results by the updated date TITLE - order results by title EVENT - order results by event CONDUIT - order results by conduit APP_NAME - order results by the application name (&#39;global&#39; templates will not have an application and will be returned last if &#39;descending&#39; is set to false.
     * @param descending Specified whether the results are returned in descending or ascending order.
     * @param start The start of the pagination.
     * @param limit The limit of the pagination.
     * @param appKey Filter results by application. (optional)
     * @param event Filter results by event. (optional)
     * @param conduit Filter results by notification type: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION. (optional)
     * @param globalOnly Returns only templates that have been reserved for system use on all applications (only for admin accounts). (optional)
     * @param reservedOnly Returns only templates that use reserved events. (optional)
     * @param keyword Filter results by keyword on the title, tags. (optional)
     * @return ApiResponse<NotificationTemplateResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun searchNotificationTemplateWithHttpInfo(accountId: kotlin.Long, sortField: kotlin.String, descending: kotlin.Boolean, start: kotlin.Int, limit: kotlin.Int, appKey: kotlin.String?, event: kotlin.String?, conduit: kotlin.String?, globalOnly: kotlin.Boolean?, reservedOnly: kotlin.Boolean?, keyword: kotlin.String?) : ApiResponse<NotificationTemplateResponse?> {
        val localVariableConfig = searchNotificationTemplateRequestConfig(accountId = accountId, sortField = sortField, descending = descending, start = start, limit = limit, appKey = appKey, event = event, conduit = conduit, globalOnly = globalOnly, reservedOnly = reservedOnly, keyword = keyword)

        return request<Unit, NotificationTemplateResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation searchNotificationTemplate
     *
     * @param accountId The account ID of the user.
     * @param sortField Specifies how results are ordered.ID - order results by the notificationTemplateId CREATED - order results by the created date UPDATED - order results by the updated date TITLE - order results by title EVENT - order results by event CONDUIT - order results by conduit APP_NAME - order results by the application name (&#39;global&#39; templates will not have an application and will be returned last if &#39;descending&#39; is set to false.
     * @param descending Specified whether the results are returned in descending or ascending order.
     * @param start The start of the pagination.
     * @param limit The limit of the pagination.
     * @param appKey Filter results by application. (optional)
     * @param event Filter results by event. (optional)
     * @param conduit Filter results by notification type: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION. (optional)
     * @param globalOnly Returns only templates that have been reserved for system use on all applications (only for admin accounts). (optional)
     * @param reservedOnly Returns only templates that use reserved events. (optional)
     * @param keyword Filter results by keyword on the title, tags. (optional)
     * @return RequestConfig
     */
    fun searchNotificationTemplateRequestConfig(accountId: kotlin.Long, sortField: kotlin.String, descending: kotlin.Boolean, start: kotlin.Int, limit: kotlin.Int, appKey: kotlin.String?, event: kotlin.String?, conduit: kotlin.String?, globalOnly: kotlin.Boolean?, reservedOnly: kotlin.Boolean?, keyword: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                if (appKey != null) {
                    put("appKey", listOf(appKey.toString()))
                }
                if (event != null) {
                    put("event", listOf(event.toString()))
                }
                if (conduit != null) {
                    put("conduit", listOf(conduit.toString()))
                }
                if (globalOnly != null) {
                    put("globalOnly", listOf(globalOnly.toString()))
                }
                if (reservedOnly != null) {
                    put("reservedOnly", listOf(reservedOnly.toString()))
                }
                if (keyword != null) {
                    put("keyword", listOf(keyword.toString()))
                }
                put("sortField", listOf(sortField.toString()))
                put("descending", listOf(descending.toString()))
                put("start", listOf(start.toString()))
                put("limit", listOf(limit.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/notification/template/search",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter sortField
     */
     enum class SortFieldSearchRecipients(val value: kotlin.String) {
         @Json(name = "ID") ID("ID"),
         @Json(name = "HAS_SMS") HAS_SMS("HAS_SMS"),
         @Json(name = "HAS_EMAIL") HAS_EMAIL("HAS_EMAIL"),
         @Json(name = "HAS_APNS") HAS_APNS("HAS_APNS"),
         @Json(name = "HAS_GCM") HAS_GCM("HAS_GCM"),
         @Json(name = "APPLICATION_ID") APPLICATION_ID("APPLICATION_ID"),
         @Json(name = "APPLICATION_NAME") APPLICATION_NAME("APPLICATION_NAME"),
         @Json(name = "ACCOUNT_ID") ACCOUNT_ID("ACCOUNT_ID"),
         @Json(name = "ACCOUNT_USERNAME") ACCOUNT_USERNAME("ACCOUNT_USERNAME"),
         @Json(name = "ACCOUNT_DISPLAY") ACCOUNT_DISPLAY("ACCOUNT_DISPLAY"),
         @Json(name = "ACCOUNT_TYPE") ACCOUNT_TYPE("ACCOUNT_TYPE");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /notification/recipient/search
     * Search for Recipients
     * Search for application users to send notifications.
     * @param sortField The field to sort by. Possible values include: {ACCOUNT_DISPLAY, CREATED, UPDATED, ACTIVE, DELETED, LAST_LOGGED_IN, CONTACT_EMAIL, RETAILER_LOCATION_NAME, RETAILER_NAME, APPLICATION_NAME}
     * @param deviceId the unique id of the device making the request (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param appKey filters results by application. If this is empty, will return all recipients for all applications that the user has access to. (optional)
     * @param conduit the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION. (optional)
     * @param keyword search by keyword on user&#39;s display name and email (optional)
     * @param audienceId This parameter is deprecated. filter results by audience (optional)
     * @param audienceIds filter results by audiences (comma separated list of audience ids) (optional)
     * @param connectionGroupIds filter results by connection groups (comma separated list of connection group ids) (optional)
     * @param recipientAccountIds filter results by accounts (comma separated list of account ids) (optional)
     * @param descending Determines whether the sorted list is in descending or ascending order (optional)
     * @param start start of the pagination (optional)
     * @param limit limit of the pagination (hard limit of 1000) (optional)
     * @return kotlin.collections.List<NotificationRecipientResponse>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun searchRecipients(sortField: SortFieldSearchRecipients, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, appKey: kotlin.String? = null, conduit: kotlin.String? = null, keyword: kotlin.String? = null, audienceId: kotlin.Long? = null, audienceIds: kotlin.String? = null, connectionGroupIds: kotlin.String? = null, recipientAccountIds: kotlin.String? = null, descending: kotlin.Boolean? = null, start: kotlin.Int? = null, limit: kotlin.Int? = null) : kotlin.collections.List<NotificationRecipientResponse> {
        val localVarResponse = searchRecipientsWithHttpInfo(sortField = sortField, deviceId = deviceId, accountId = accountId, appKey = appKey, conduit = conduit, keyword = keyword, audienceId = audienceId, audienceIds = audienceIds, connectionGroupIds = connectionGroupIds, recipientAccountIds = recipientAccountIds, descending = descending, start = start, limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<NotificationRecipientResponse>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /notification/recipient/search
     * Search for Recipients
     * Search for application users to send notifications.
     * @param sortField The field to sort by. Possible values include: {ACCOUNT_DISPLAY, CREATED, UPDATED, ACTIVE, DELETED, LAST_LOGGED_IN, CONTACT_EMAIL, RETAILER_LOCATION_NAME, RETAILER_NAME, APPLICATION_NAME}
     * @param deviceId the unique id of the device making the request (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param appKey filters results by application. If this is empty, will return all recipients for all applications that the user has access to. (optional)
     * @param conduit the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION. (optional)
     * @param keyword search by keyword on user&#39;s display name and email (optional)
     * @param audienceId This parameter is deprecated. filter results by audience (optional)
     * @param audienceIds filter results by audiences (comma separated list of audience ids) (optional)
     * @param connectionGroupIds filter results by connection groups (comma separated list of connection group ids) (optional)
     * @param recipientAccountIds filter results by accounts (comma separated list of account ids) (optional)
     * @param descending Determines whether the sorted list is in descending or ascending order (optional)
     * @param start start of the pagination (optional)
     * @param limit limit of the pagination (hard limit of 1000) (optional)
     * @return ApiResponse<kotlin.collections.List<NotificationRecipientResponse>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun searchRecipientsWithHttpInfo(sortField: SortFieldSearchRecipients, deviceId: kotlin.String?, accountId: kotlin.Long?, appKey: kotlin.String?, conduit: kotlin.String?, keyword: kotlin.String?, audienceId: kotlin.Long?, audienceIds: kotlin.String?, connectionGroupIds: kotlin.String?, recipientAccountIds: kotlin.String?, descending: kotlin.Boolean?, start: kotlin.Int?, limit: kotlin.Int?) : ApiResponse<kotlin.collections.List<NotificationRecipientResponse>?> {
        val localVariableConfig = searchRecipientsRequestConfig(sortField = sortField, deviceId = deviceId, accountId = accountId, appKey = appKey, conduit = conduit, keyword = keyword, audienceId = audienceId, audienceIds = audienceIds, connectionGroupIds = connectionGroupIds, recipientAccountIds = recipientAccountIds, descending = descending, start = start, limit = limit)

        return request<Unit, kotlin.collections.List<NotificationRecipientResponse>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation searchRecipients
     *
     * @param sortField The field to sort by. Possible values include: {ACCOUNT_DISPLAY, CREATED, UPDATED, ACTIVE, DELETED, LAST_LOGGED_IN, CONTACT_EMAIL, RETAILER_LOCATION_NAME, RETAILER_NAME, APPLICATION_NAME}
     * @param deviceId the unique id of the device making the request (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param appKey filters results by application. If this is empty, will return all recipients for all applications that the user has access to. (optional)
     * @param conduit the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION. (optional)
     * @param keyword search by keyword on user&#39;s display name and email (optional)
     * @param audienceId This parameter is deprecated. filter results by audience (optional)
     * @param audienceIds filter results by audiences (comma separated list of audience ids) (optional)
     * @param connectionGroupIds filter results by connection groups (comma separated list of connection group ids) (optional)
     * @param recipientAccountIds filter results by accounts (comma separated list of account ids) (optional)
     * @param descending Determines whether the sorted list is in descending or ascending order (optional)
     * @param start start of the pagination (optional)
     * @param limit limit of the pagination (hard limit of 1000) (optional)
     * @return RequestConfig
     */
    fun searchRecipientsRequestConfig(sortField: SortFieldSearchRecipients, deviceId: kotlin.String?, accountId: kotlin.Long?, appKey: kotlin.String?, conduit: kotlin.String?, keyword: kotlin.String?, audienceId: kotlin.Long?, audienceIds: kotlin.String?, connectionGroupIds: kotlin.String?, recipientAccountIds: kotlin.String?, descending: kotlin.Boolean?, start: kotlin.Int?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (appKey != null) {
                    put("appKey", listOf(appKey.toString()))
                }
                if (conduit != null) {
                    put("conduit", listOf(conduit.toString()))
                }
                if (keyword != null) {
                    put("keyword", listOf(keyword.toString()))
                }
                if (audienceId != null) {
                    put("audienceId", listOf(audienceId.toString()))
                }
                if (audienceIds != null) {
                    put("audienceIds", listOf(audienceIds.toString()))
                }
                if (connectionGroupIds != null) {
                    put("connectionGroupIds", listOf(connectionGroupIds.toString()))
                }
                if (recipientAccountIds != null) {
                    put("recipientAccountIds", listOf(recipientAccountIds.toString()))
                }
                put("sortField", listOf(sortField.value))
                if (descending != null) {
                    put("descending", listOf(descending.toString()))
                }
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/notification/recipient/search",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /notification/recipient/search/count
     * Search for Recipients (Counts/Grouped)
     * Search for application users to send notifications (count/grouped variant).
     * @param deviceId the unique id of the device making the request (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param appKey filters results by application. If this is empty, will return all recipients for all applications that the user has access to. (optional)
     * @param conduit the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION. (optional)
     * @param keyword search by keyword on user&#39;s display name and email (optional)
     * @param audienceId This parameter is deprecated. filter results by audience (optional)
     * @param audienceIds filter results by audiences (comma separated list of audience ids) (optional)
     * @param connectionGroupIds filter results by connection groups (comma separated list of connection group ids) (optional)
     * @param sortField The field to sort by (see API docs for allowed values). (optional)
     * @param descending Determines whether the sorted list is in descending or ascending order (optional)
     * @param start start of the pagination (optional)
     * @param limit limit of the pagination (optional)
     * @return NotificationRecipientResponseListResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun searchRecipientsCount(deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, appKey: kotlin.String? = null, conduit: kotlin.String? = null, keyword: kotlin.String? = null, audienceId: kotlin.Long? = null, audienceIds: kotlin.String? = null, connectionGroupIds: kotlin.String? = null, sortField: kotlin.String? = null, descending: kotlin.Boolean? = null, start: kotlin.Int? = null, limit: kotlin.Int? = null) : NotificationRecipientResponseListResponse {
        val localVarResponse = searchRecipientsCountWithHttpInfo(deviceId = deviceId, accountId = accountId, appKey = appKey, conduit = conduit, keyword = keyword, audienceId = audienceId, audienceIds = audienceIds, connectionGroupIds = connectionGroupIds, sortField = sortField, descending = descending, start = start, limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as NotificationRecipientResponseListResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /notification/recipient/search/count
     * Search for Recipients (Counts/Grouped)
     * Search for application users to send notifications (count/grouped variant).
     * @param deviceId the unique id of the device making the request (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param appKey filters results by application. If this is empty, will return all recipients for all applications that the user has access to. (optional)
     * @param conduit the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION. (optional)
     * @param keyword search by keyword on user&#39;s display name and email (optional)
     * @param audienceId This parameter is deprecated. filter results by audience (optional)
     * @param audienceIds filter results by audiences (comma separated list of audience ids) (optional)
     * @param connectionGroupIds filter results by connection groups (comma separated list of connection group ids) (optional)
     * @param sortField The field to sort by (see API docs for allowed values). (optional)
     * @param descending Determines whether the sorted list is in descending or ascending order (optional)
     * @param start start of the pagination (optional)
     * @param limit limit of the pagination (optional)
     * @return ApiResponse<NotificationRecipientResponseListResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun searchRecipientsCountWithHttpInfo(deviceId: kotlin.String?, accountId: kotlin.Long?, appKey: kotlin.String?, conduit: kotlin.String?, keyword: kotlin.String?, audienceId: kotlin.Long?, audienceIds: kotlin.String?, connectionGroupIds: kotlin.String?, sortField: kotlin.String?, descending: kotlin.Boolean?, start: kotlin.Int?, limit: kotlin.Int?) : ApiResponse<NotificationRecipientResponseListResponse?> {
        val localVariableConfig = searchRecipientsCountRequestConfig(deviceId = deviceId, accountId = accountId, appKey = appKey, conduit = conduit, keyword = keyword, audienceId = audienceId, audienceIds = audienceIds, connectionGroupIds = connectionGroupIds, sortField = sortField, descending = descending, start = start, limit = limit)

        return request<Unit, NotificationRecipientResponseListResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation searchRecipientsCount
     *
     * @param deviceId the unique id of the device making the request (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param appKey filters results by application. If this is empty, will return all recipients for all applications that the user has access to. (optional)
     * @param conduit the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION. (optional)
     * @param keyword search by keyword on user&#39;s display name and email (optional)
     * @param audienceId This parameter is deprecated. filter results by audience (optional)
     * @param audienceIds filter results by audiences (comma separated list of audience ids) (optional)
     * @param connectionGroupIds filter results by connection groups (comma separated list of connection group ids) (optional)
     * @param sortField The field to sort by (see API docs for allowed values). (optional)
     * @param descending Determines whether the sorted list is in descending or ascending order (optional)
     * @param start start of the pagination (optional)
     * @param limit limit of the pagination (optional)
     * @return RequestConfig
     */
    fun searchRecipientsCountRequestConfig(deviceId: kotlin.String?, accountId: kotlin.Long?, appKey: kotlin.String?, conduit: kotlin.String?, keyword: kotlin.String?, audienceId: kotlin.Long?, audienceIds: kotlin.String?, connectionGroupIds: kotlin.String?, sortField: kotlin.String?, descending: kotlin.Boolean?, start: kotlin.Int?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (appKey != null) {
                    put("appKey", listOf(appKey.toString()))
                }
                if (conduit != null) {
                    put("conduit", listOf(conduit.toString()))
                }
                if (keyword != null) {
                    put("keyword", listOf(keyword.toString()))
                }
                if (audienceId != null) {
                    put("audienceId", listOf(audienceId.toString()))
                }
                if (audienceIds != null) {
                    put("audienceIds", listOf(audienceIds.toString()))
                }
                if (connectionGroupIds != null) {
                    put("connectionGroupIds", listOf(connectionGroupIds.toString()))
                }
                if (sortField != null) {
                    put("sortField", listOf(sortField.toString()))
                }
                if (descending != null) {
                    put("descending", listOf(descending.toString()))
                }
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/notification/recipient/search/count",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /notification/batch
     * Send Batch Notifications
     * Send notifications to all users of an application. Only someone with permissions to the application can do this.
     * @param accountId The account id of the application owner/manager
     * @param appKey The application key for updating an existing application
     * @param customMessage Message string that will be displayed in on the notification
     * @param conduit The type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION. (optional)
     * @param contentId Default notification pay-load field (usage is dependent on the app and the type of event) (optional)
     * @param contentName Default notification pay-load field (usage is dependent on the app and the type of event) (optional)
     * @param contentType Default notification pay-load field (usage is dependent on the app and the type of event) (optional)
     * @param parentId Default notification pay-load field (usage is dependent on the app and the type of event) (optional)
     * @param parentType Default notification pay-load field (usage is dependent on the app and the type of event) (optional)
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sendBatchNotifications(accountId: kotlin.Long, appKey: kotlin.String, customMessage: kotlin.String, conduit: kotlin.String? = null, contentId: kotlin.Long? = null, contentName: kotlin.String? = null, contentType: kotlin.String? = null, parentId: kotlin.Long? = null, parentType: kotlin.String? = null) : SirqulResponse {
        val localVarResponse = sendBatchNotificationsWithHttpInfo(accountId = accountId, appKey = appKey, customMessage = customMessage, conduit = conduit, contentId = contentId, contentName = contentName, contentType = contentType, parentId = parentId, parentType = parentType)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /notification/batch
     * Send Batch Notifications
     * Send notifications to all users of an application. Only someone with permissions to the application can do this.
     * @param accountId The account id of the application owner/manager
     * @param appKey The application key for updating an existing application
     * @param customMessage Message string that will be displayed in on the notification
     * @param conduit The type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION. (optional)
     * @param contentId Default notification pay-load field (usage is dependent on the app and the type of event) (optional)
     * @param contentName Default notification pay-load field (usage is dependent on the app and the type of event) (optional)
     * @param contentType Default notification pay-load field (usage is dependent on the app and the type of event) (optional)
     * @param parentId Default notification pay-load field (usage is dependent on the app and the type of event) (optional)
     * @param parentType Default notification pay-load field (usage is dependent on the app and the type of event) (optional)
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sendBatchNotificationsWithHttpInfo(accountId: kotlin.Long, appKey: kotlin.String, customMessage: kotlin.String, conduit: kotlin.String?, contentId: kotlin.Long?, contentName: kotlin.String?, contentType: kotlin.String?, parentId: kotlin.Long?, parentType: kotlin.String?) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = sendBatchNotificationsRequestConfig(accountId = accountId, appKey = appKey, customMessage = customMessage, conduit = conduit, contentId = contentId, contentName = contentName, contentType = contentType, parentId = parentId, parentType = parentType)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sendBatchNotifications
     *
     * @param accountId The account id of the application owner/manager
     * @param appKey The application key for updating an existing application
     * @param customMessage Message string that will be displayed in on the notification
     * @param conduit The type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION. (optional)
     * @param contentId Default notification pay-load field (usage is dependent on the app and the type of event) (optional)
     * @param contentName Default notification pay-load field (usage is dependent on the app and the type of event) (optional)
     * @param contentType Default notification pay-load field (usage is dependent on the app and the type of event) (optional)
     * @param parentId Default notification pay-load field (usage is dependent on the app and the type of event) (optional)
     * @param parentType Default notification pay-load field (usage is dependent on the app and the type of event) (optional)
     * @return RequestConfig
     */
    fun sendBatchNotificationsRequestConfig(accountId: kotlin.Long, appKey: kotlin.String, customMessage: kotlin.String, conduit: kotlin.String?, contentId: kotlin.Long?, contentName: kotlin.String?, contentType: kotlin.String?, parentId: kotlin.Long?, parentType: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("appKey", listOf(appKey.toString()))
                if (conduit != null) {
                    put("conduit", listOf(conduit.toString()))
                }
                put("customMessage", listOf(customMessage.toString()))
                if (contentId != null) {
                    put("contentId", listOf(contentId.toString()))
                }
                if (contentName != null) {
                    put("contentName", listOf(contentName.toString()))
                }
                if (contentType != null) {
                    put("contentType", listOf(contentType.toString()))
                }
                if (parentId != null) {
                    put("parentId", listOf(parentId.toString()))
                }
                if (parentType != null) {
                    put("parentType", listOf(parentType.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/notification/batch",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /notification/custom
     * Send Custom Notifications
     * Send your own custom notification to a user. NOTE: the EventType of these notifications will be CUSTOM. Notifications sent to yourself will currently be ignored.
     * @param deviceId the unique id of the device making the request (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param receiverAccountIds comma separated list of account IDs that will receive the notification (optional)
     * @param includeFriendGroup determines whether to send to all of the user&#39;s friends, this flag must be true or receiverAccountIds must not be empty (optional)
     * @param appKey the application key (optional)
     * @param gameType This parameter is deprecated. (optional)
     * @param conduit the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION. (optional)
     * @param contentId default notification pay-load field (usage is dependent on the app and the type of event) (optional)
     * @param contentName default notification pay-load field (usage is dependent on the app and the type of event) (optional)
     * @param contentType default notification pay-load field (usage is dependent on the app and the type of event) (optional)
     * @param parentId default notification pay-load field (usage is dependent on the app and the type of event) (optional)
     * @param parentType default notification pay-load field (usage is dependent on the app and the type of event) (optional)
     * @param actionCategory  (optional)
     * @param subject the subject line of an email #@param customPayload custom json definition of notification pay-load (usage is dependent on the app and the type of event) (optional)
     * @param customMessage message string that will be displayed in on the notification (optional)
     * @param friendOnlyAPNS only sends APNS to people who are friends of the user (still saves the notification message for feed polling) (optional)
     * @param latitude latitude used to update the user&#39;s current location (optional)
     * @param longitude longitude used to update the user&#39;s current location (optional)
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sendCustomNotifications(deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, receiverAccountIds: kotlin.String? = null, includeFriendGroup: kotlin.Boolean? = null, appKey: kotlin.String? = null, gameType: kotlin.String? = null, conduit: kotlin.String? = null, contentId: kotlin.Long? = null, contentName: kotlin.String? = null, contentType: kotlin.String? = null, parentId: kotlin.Long? = null, parentType: kotlin.String? = null, actionCategory: kotlin.String? = null, subject: kotlin.String? = null, customMessage: kotlin.String? = null, friendOnlyAPNS: kotlin.Boolean? = null, latitude: kotlin.Double? = null, longitude: kotlin.Double? = null) : SirqulResponse {
        val localVarResponse = sendCustomNotificationsWithHttpInfo(deviceId = deviceId, accountId = accountId, receiverAccountIds = receiverAccountIds, includeFriendGroup = includeFriendGroup, appKey = appKey, gameType = gameType, conduit = conduit, contentId = contentId, contentName = contentName, contentType = contentType, parentId = parentId, parentType = parentType, actionCategory = actionCategory, subject = subject, customMessage = customMessage, friendOnlyAPNS = friendOnlyAPNS, latitude = latitude, longitude = longitude)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /notification/custom
     * Send Custom Notifications
     * Send your own custom notification to a user. NOTE: the EventType of these notifications will be CUSTOM. Notifications sent to yourself will currently be ignored.
     * @param deviceId the unique id of the device making the request (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param receiverAccountIds comma separated list of account IDs that will receive the notification (optional)
     * @param includeFriendGroup determines whether to send to all of the user&#39;s friends, this flag must be true or receiverAccountIds must not be empty (optional)
     * @param appKey the application key (optional)
     * @param gameType This parameter is deprecated. (optional)
     * @param conduit the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION. (optional)
     * @param contentId default notification pay-load field (usage is dependent on the app and the type of event) (optional)
     * @param contentName default notification pay-load field (usage is dependent on the app and the type of event) (optional)
     * @param contentType default notification pay-load field (usage is dependent on the app and the type of event) (optional)
     * @param parentId default notification pay-load field (usage is dependent on the app and the type of event) (optional)
     * @param parentType default notification pay-load field (usage is dependent on the app and the type of event) (optional)
     * @param actionCategory  (optional)
     * @param subject the subject line of an email #@param customPayload custom json definition of notification pay-load (usage is dependent on the app and the type of event) (optional)
     * @param customMessage message string that will be displayed in on the notification (optional)
     * @param friendOnlyAPNS only sends APNS to people who are friends of the user (still saves the notification message for feed polling) (optional)
     * @param latitude latitude used to update the user&#39;s current location (optional)
     * @param longitude longitude used to update the user&#39;s current location (optional)
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sendCustomNotificationsWithHttpInfo(deviceId: kotlin.String?, accountId: kotlin.Long?, receiverAccountIds: kotlin.String?, includeFriendGroup: kotlin.Boolean?, appKey: kotlin.String?, gameType: kotlin.String?, conduit: kotlin.String?, contentId: kotlin.Long?, contentName: kotlin.String?, contentType: kotlin.String?, parentId: kotlin.Long?, parentType: kotlin.String?, actionCategory: kotlin.String?, subject: kotlin.String?, customMessage: kotlin.String?, friendOnlyAPNS: kotlin.Boolean?, latitude: kotlin.Double?, longitude: kotlin.Double?) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = sendCustomNotificationsRequestConfig(deviceId = deviceId, accountId = accountId, receiverAccountIds = receiverAccountIds, includeFriendGroup = includeFriendGroup, appKey = appKey, gameType = gameType, conduit = conduit, contentId = contentId, contentName = contentName, contentType = contentType, parentId = parentId, parentType = parentType, actionCategory = actionCategory, subject = subject, customMessage = customMessage, friendOnlyAPNS = friendOnlyAPNS, latitude = latitude, longitude = longitude)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sendCustomNotifications
     *
     * @param deviceId the unique id of the device making the request (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param receiverAccountIds comma separated list of account IDs that will receive the notification (optional)
     * @param includeFriendGroup determines whether to send to all of the user&#39;s friends, this flag must be true or receiverAccountIds must not be empty (optional)
     * @param appKey the application key (optional)
     * @param gameType This parameter is deprecated. (optional)
     * @param conduit the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION. (optional)
     * @param contentId default notification pay-load field (usage is dependent on the app and the type of event) (optional)
     * @param contentName default notification pay-load field (usage is dependent on the app and the type of event) (optional)
     * @param contentType default notification pay-load field (usage is dependent on the app and the type of event) (optional)
     * @param parentId default notification pay-load field (usage is dependent on the app and the type of event) (optional)
     * @param parentType default notification pay-load field (usage is dependent on the app and the type of event) (optional)
     * @param actionCategory  (optional)
     * @param subject the subject line of an email #@param customPayload custom json definition of notification pay-load (usage is dependent on the app and the type of event) (optional)
     * @param customMessage message string that will be displayed in on the notification (optional)
     * @param friendOnlyAPNS only sends APNS to people who are friends of the user (still saves the notification message for feed polling) (optional)
     * @param latitude latitude used to update the user&#39;s current location (optional)
     * @param longitude longitude used to update the user&#39;s current location (optional)
     * @return RequestConfig
     */
    fun sendCustomNotificationsRequestConfig(deviceId: kotlin.String?, accountId: kotlin.Long?, receiverAccountIds: kotlin.String?, includeFriendGroup: kotlin.Boolean?, appKey: kotlin.String?, gameType: kotlin.String?, conduit: kotlin.String?, contentId: kotlin.Long?, contentName: kotlin.String?, contentType: kotlin.String?, parentId: kotlin.Long?, parentType: kotlin.String?, actionCategory: kotlin.String?, subject: kotlin.String?, customMessage: kotlin.String?, friendOnlyAPNS: kotlin.Boolean?, latitude: kotlin.Double?, longitude: kotlin.Double?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (receiverAccountIds != null) {
                    put("receiverAccountIds", listOf(receiverAccountIds.toString()))
                }
                if (includeFriendGroup != null) {
                    put("includeFriendGroup", listOf(includeFriendGroup.toString()))
                }
                if (appKey != null) {
                    put("appKey", listOf(appKey.toString()))
                }
                if (gameType != null) {
                    put("gameType", listOf(gameType.toString()))
                }
                if (conduit != null) {
                    put("conduit", listOf(conduit.toString()))
                }
                if (contentId != null) {
                    put("contentId", listOf(contentId.toString()))
                }
                if (contentName != null) {
                    put("contentName", listOf(contentName.toString()))
                }
                if (contentType != null) {
                    put("contentType", listOf(contentType.toString()))
                }
                if (parentId != null) {
                    put("parentId", listOf(parentId.toString()))
                }
                if (parentType != null) {
                    put("parentType", listOf(parentType.toString()))
                }
                if (actionCategory != null) {
                    put("actionCategory", listOf(actionCategory.toString()))
                }
                if (subject != null) {
                    put("subject", listOf(subject.toString()))
                }
                if (customMessage != null) {
                    put("customMessage", listOf(customMessage.toString()))
                }
                if (friendOnlyAPNS != null) {
                    put("friendOnlyAPNS", listOf(friendOnlyAPNS.toString()))
                }
                if (latitude != null) {
                    put("latitude", listOf(latitude.toString()))
                }
                if (longitude != null) {
                    put("longitude", listOf(longitude.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/notification/custom",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /notification/template/update
     * Update Notification Template
     * Update a notification template. Developers will only be able to update notification templates for their own applications.
     * @param accountId The account ID of the user.
     * @param notificationTemplateId The notification template ID to update.
     * @param title The title of the message (this would become the subject title for emails). There is a 191 character limit. (optional)
     * @param body The body of the message. (optional)
     * @param tags The search tags on the template used during search queries. (optional)
     * @return NotificationTemplateResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updateNotificationTemplate(accountId: kotlin.Long, notificationTemplateId: kotlin.Long, title: kotlin.String? = null, body: kotlin.String? = null, tags: kotlin.String? = null) : NotificationTemplateResponse {
        val localVarResponse = updateNotificationTemplateWithHttpInfo(accountId = accountId, notificationTemplateId = notificationTemplateId, title = title, body = body, tags = tags)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as NotificationTemplateResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /notification/template/update
     * Update Notification Template
     * Update a notification template. Developers will only be able to update notification templates for their own applications.
     * @param accountId The account ID of the user.
     * @param notificationTemplateId The notification template ID to update.
     * @param title The title of the message (this would become the subject title for emails). There is a 191 character limit. (optional)
     * @param body The body of the message. (optional)
     * @param tags The search tags on the template used during search queries. (optional)
     * @return ApiResponse<NotificationTemplateResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun updateNotificationTemplateWithHttpInfo(accountId: kotlin.Long, notificationTemplateId: kotlin.Long, title: kotlin.String?, body: kotlin.String?, tags: kotlin.String?) : ApiResponse<NotificationTemplateResponse?> {
        val localVariableConfig = updateNotificationTemplateRequestConfig(accountId = accountId, notificationTemplateId = notificationTemplateId, title = title, body = body, tags = tags)

        return request<Unit, NotificationTemplateResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateNotificationTemplate
     *
     * @param accountId The account ID of the user.
     * @param notificationTemplateId The notification template ID to update.
     * @param title The title of the message (this would become the subject title for emails). There is a 191 character limit. (optional)
     * @param body The body of the message. (optional)
     * @param tags The search tags on the template used during search queries. (optional)
     * @return RequestConfig
     */
    fun updateNotificationTemplateRequestConfig(accountId: kotlin.Long, notificationTemplateId: kotlin.Long, title: kotlin.String?, body: kotlin.String?, tags: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("notificationTemplateId", listOf(notificationTemplateId.toString()))
                if (title != null) {
                    put("title", listOf(title.toString()))
                }
                if (body != null) {
                    put("body", listOf(body.toString()))
                }
                if (tags != null) {
                    put("tags", listOf(tags.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/notification/template/update",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
