/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import org.openapitools.client.models.AccountMiniResponse
import org.openapitools.client.models.Leg
import org.openapitools.client.models.LegResponse
import org.openapitools.client.models.PredictedLocationResponse
import org.openapitools.client.models.PreferredLocationResponse
import org.openapitools.client.models.SirqulResponse
import org.openapitools.client.models.StepResponse

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

open class TrackingApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://dev.sirqul.com/api/3.18")
        }
    }

    /**
     * POST /tracking/batch/create
     * Create Batch Tracking
     * Batch create tracking legs
     * @param `data` JSON array of tracking legs &#x60;&#x60;&#x60;json [   \&quot;distance\&quot;: \&quot;0.08\&quot;,   \&quot;duration\&quot;: \&quot;10000\&quot;,   \&quot;startLatitude\&quot;: \&quot;47.614603\&quot;,   \&quot;startLongitude\&quot;: \&quot;-122.350518\&quot;,   \&quot;endLatitude\&quot;: \&quot;47.614384\&quot;,   \&quot;endLongitude\&quot;: \&quot;-122.349161\&quot;,   \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,   \&quot;endDate\&quot;: \&quot;1361924020000\&quot;,   \&quot;steps\&quot;: [     {       \&quot;distance\&quot;: \&quot;0.03\&quot;,       \&quot;duration\&quot;: \&quot;5000\&quot;,       \&quot;startLat\&quot;: \&quot;47.614603\&quot;,       \&quot;startLng\&quot;: \&quot;-122.350518\&quot;,       \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,       \&quot;endLat\&quot;: \&quot;47.614941\&quot;,       \&quot;endLng\&quot;: \&quot;-122.350062\&quot;,       \&quot;endDate\&quot;: \&quot;1361924015000\&quot;     },{       \&quot;distance\&quot;: \&quot;0.05\&quot;,       \&quot;duration\&quot;: \&quot;5000\&quot;,       \&quot;startLat\&quot;: \&quot;47.614941\&quot;,       \&quot;startLng\&quot;: \&quot;-122.350062\&quot;,       \&quot;startDate\&quot;: \&quot;1361924015000\&quot;,       \&quot;endLat\&quot;: \&quot;47.614384\&quot;,       \&quot;endLng\&quot;: \&quot;-122.349161\&quot;,       \&quot;endDate\&quot;: \&quot;1361924020000\&quot;     }   ] ] &#x60;&#x60;&#x60; 
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param generateAccounts Whether to generate accounts for tracking entries when the owner does not exist (optional)
     * @param updateAccountLocations Whether to update the account&#39;s current location from the incoming tracking data (optional)
     * @param defaultTag The default tag to apply to incoming legs when no tag is provided (optional, default to "PASSIVE")
     * @param slaveUID  (optional)
     * @return kotlin.collections.List<Leg>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun batchSaveTracking(`data`: kotlin.String, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, generateAccounts: kotlin.Boolean? = null, updateAccountLocations: kotlin.Boolean? = null, defaultTag: kotlin.String? = "PASSIVE", slaveUID: kotlin.String? = null) : kotlin.collections.List<Leg> {
        val localVarResponse = batchSaveTrackingWithHttpInfo(`data` = `data`, deviceId = deviceId, accountId = accountId, generateAccounts = generateAccounts, updateAccountLocations = updateAccountLocations, defaultTag = defaultTag, slaveUID = slaveUID)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<Leg>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /tracking/batch/create
     * Create Batch Tracking
     * Batch create tracking legs
     * @param `data` JSON array of tracking legs &#x60;&#x60;&#x60;json [   \&quot;distance\&quot;: \&quot;0.08\&quot;,   \&quot;duration\&quot;: \&quot;10000\&quot;,   \&quot;startLatitude\&quot;: \&quot;47.614603\&quot;,   \&quot;startLongitude\&quot;: \&quot;-122.350518\&quot;,   \&quot;endLatitude\&quot;: \&quot;47.614384\&quot;,   \&quot;endLongitude\&quot;: \&quot;-122.349161\&quot;,   \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,   \&quot;endDate\&quot;: \&quot;1361924020000\&quot;,   \&quot;steps\&quot;: [     {       \&quot;distance\&quot;: \&quot;0.03\&quot;,       \&quot;duration\&quot;: \&quot;5000\&quot;,       \&quot;startLat\&quot;: \&quot;47.614603\&quot;,       \&quot;startLng\&quot;: \&quot;-122.350518\&quot;,       \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,       \&quot;endLat\&quot;: \&quot;47.614941\&quot;,       \&quot;endLng\&quot;: \&quot;-122.350062\&quot;,       \&quot;endDate\&quot;: \&quot;1361924015000\&quot;     },{       \&quot;distance\&quot;: \&quot;0.05\&quot;,       \&quot;duration\&quot;: \&quot;5000\&quot;,       \&quot;startLat\&quot;: \&quot;47.614941\&quot;,       \&quot;startLng\&quot;: \&quot;-122.350062\&quot;,       \&quot;startDate\&quot;: \&quot;1361924015000\&quot;,       \&quot;endLat\&quot;: \&quot;47.614384\&quot;,       \&quot;endLng\&quot;: \&quot;-122.349161\&quot;,       \&quot;endDate\&quot;: \&quot;1361924020000\&quot;     }   ] ] &#x60;&#x60;&#x60; 
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param generateAccounts Whether to generate accounts for tracking entries when the owner does not exist (optional)
     * @param updateAccountLocations Whether to update the account&#39;s current location from the incoming tracking data (optional)
     * @param defaultTag The default tag to apply to incoming legs when no tag is provided (optional, default to "PASSIVE")
     * @param slaveUID  (optional)
     * @return ApiResponse<kotlin.collections.List<Leg>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun batchSaveTrackingWithHttpInfo(`data`: kotlin.String, deviceId: kotlin.String?, accountId: kotlin.Long?, generateAccounts: kotlin.Boolean?, updateAccountLocations: kotlin.Boolean?, defaultTag: kotlin.String?, slaveUID: kotlin.String?) : ApiResponse<kotlin.collections.List<Leg>?> {
        val localVariableConfig = batchSaveTrackingRequestConfig(`data` = `data`, deviceId = deviceId, accountId = accountId, generateAccounts = generateAccounts, updateAccountLocations = updateAccountLocations, defaultTag = defaultTag, slaveUID = slaveUID)

        return request<Unit, kotlin.collections.List<Leg>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation batchSaveTracking
     *
     * @param `data` JSON array of tracking legs &#x60;&#x60;&#x60;json [   \&quot;distance\&quot;: \&quot;0.08\&quot;,   \&quot;duration\&quot;: \&quot;10000\&quot;,   \&quot;startLatitude\&quot;: \&quot;47.614603\&quot;,   \&quot;startLongitude\&quot;: \&quot;-122.350518\&quot;,   \&quot;endLatitude\&quot;: \&quot;47.614384\&quot;,   \&quot;endLongitude\&quot;: \&quot;-122.349161\&quot;,   \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,   \&quot;endDate\&quot;: \&quot;1361924020000\&quot;,   \&quot;steps\&quot;: [     {       \&quot;distance\&quot;: \&quot;0.03\&quot;,       \&quot;duration\&quot;: \&quot;5000\&quot;,       \&quot;startLat\&quot;: \&quot;47.614603\&quot;,       \&quot;startLng\&quot;: \&quot;-122.350518\&quot;,       \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,       \&quot;endLat\&quot;: \&quot;47.614941\&quot;,       \&quot;endLng\&quot;: \&quot;-122.350062\&quot;,       \&quot;endDate\&quot;: \&quot;1361924015000\&quot;     },{       \&quot;distance\&quot;: \&quot;0.05\&quot;,       \&quot;duration\&quot;: \&quot;5000\&quot;,       \&quot;startLat\&quot;: \&quot;47.614941\&quot;,       \&quot;startLng\&quot;: \&quot;-122.350062\&quot;,       \&quot;startDate\&quot;: \&quot;1361924015000\&quot;,       \&quot;endLat\&quot;: \&quot;47.614384\&quot;,       \&quot;endLng\&quot;: \&quot;-122.349161\&quot;,       \&quot;endDate\&quot;: \&quot;1361924020000\&quot;     }   ] ] &#x60;&#x60;&#x60; 
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param generateAccounts Whether to generate accounts for tracking entries when the owner does not exist (optional)
     * @param updateAccountLocations Whether to update the account&#39;s current location from the incoming tracking data (optional)
     * @param defaultTag The default tag to apply to incoming legs when no tag is provided (optional, default to "PASSIVE")
     * @param slaveUID  (optional)
     * @return RequestConfig
     */
    fun batchSaveTrackingRequestConfig(`data`: kotlin.String, deviceId: kotlin.String?, accountId: kotlin.Long?, generateAccounts: kotlin.Boolean?, updateAccountLocations: kotlin.Boolean?, defaultTag: kotlin.String?, slaveUID: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                put("data", listOf(`data`.toString()))
                if (generateAccounts != null) {
                    put("generateAccounts", listOf(generateAccounts.toString()))
                }
                if (updateAccountLocations != null) {
                    put("updateAccountLocations", listOf(updateAccountLocations.toString()))
                }
                if (defaultTag != null) {
                    put("defaultTag", listOf(defaultTag.toString()))
                }
                if (slaveUID != null) {
                    put("slaveUID", listOf(slaveUID.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/tracking/batch/create",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter distanceUnit
     */
     enum class DistanceUnitGetPredictedLocations(val value: kotlin.String) {
         @Json(name = "MILES") MILES("MILES"),
         @Json(name = "KILOMETERS") KILOMETERS("KILOMETERS");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter sortOrder
     */
     enum class SortOrderGetPredictedLocations(val value: kotlin.String) {
         @Json(name = "MATCHES") MATCHES("MATCHES"),
         @Json(name = "DISTANCE") DISTANCE("DISTANCE"),
         @Json(name = "WEIGHTED") WEIGHTED("WEIGHTED");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /tracking/predicted/get
     * Get Predicted Locations
     * Get the predicted location for a customer based on previous behavior.  If a customer resides in a place for a period of time this is marked as a preferred location.  We look back over the previous few days and the previous days of the week from the day specified.  If for instance the day was a Wednesday then this would check the days before, including: Tuesday, Monday, Sunday, etc. It will also check some number of previous Wednesdays in the past few weeks.
     * @param accountId The account id of the customer
     * @param latitude latitude to return a more likely result set based on the user&#39;s current location (optional)
     * @param longitude longitude to return a more likely result set based on the user&#39;s current location (optional)
     * @param dateCheck Used to specify which day to get predicted locations for. So if you want to look at where they might be tomorrow, pass in tomorrow&#39;s date (timestamp in milliseconds). If no value is passed in, the current date will be used. (optional)
     * @param hourCheck Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see predicted locations for the mornings and evening you can pass in \&quot;8,9,10,11,17,18,19,20\&quot;. (optional)
     * @param threshold The minimum number matches in 1 hour to be considered a likely location. (optional, default to 1L)
     * @param distanceUnit Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS} (optional, default to DistanceUnit.MILES)
     * @param searchRange Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \&quot;0\&quot; (zero) will ignore the radius restriction. (optional, default to 0.0)
     * @param sortOrder The ordering algorithm for sorting the returned results: {MATCHES, DISTANCE, WEIGHTED} (optional, default to SortOrder.MATCHES)
     * @return PredictedLocationResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getPredictedLocations(accountId: kotlin.Long, latitude: kotlin.Double? = null, longitude: kotlin.Double? = null, dateCheck: kotlin.Long? = null, hourCheck: kotlin.String? = null, threshold: kotlin.Long? = 1L, distanceUnit: DistanceUnitGetPredictedLocations? = DistanceUnitGetPredictedLocations.MILES, searchRange: kotlin.Double? = 0.0, sortOrder: SortOrderGetPredictedLocations? = SortOrderGetPredictedLocations.MATCHES) : PredictedLocationResponse {
        val localVarResponse = getPredictedLocationsWithHttpInfo(accountId = accountId, latitude = latitude, longitude = longitude, dateCheck = dateCheck, hourCheck = hourCheck, threshold = threshold, distanceUnit = distanceUnit, searchRange = searchRange, sortOrder = sortOrder)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PredictedLocationResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /tracking/predicted/get
     * Get Predicted Locations
     * Get the predicted location for a customer based on previous behavior.  If a customer resides in a place for a period of time this is marked as a preferred location.  We look back over the previous few days and the previous days of the week from the day specified.  If for instance the day was a Wednesday then this would check the days before, including: Tuesday, Monday, Sunday, etc. It will also check some number of previous Wednesdays in the past few weeks.
     * @param accountId The account id of the customer
     * @param latitude latitude to return a more likely result set based on the user&#39;s current location (optional)
     * @param longitude longitude to return a more likely result set based on the user&#39;s current location (optional)
     * @param dateCheck Used to specify which day to get predicted locations for. So if you want to look at where they might be tomorrow, pass in tomorrow&#39;s date (timestamp in milliseconds). If no value is passed in, the current date will be used. (optional)
     * @param hourCheck Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see predicted locations for the mornings and evening you can pass in \&quot;8,9,10,11,17,18,19,20\&quot;. (optional)
     * @param threshold The minimum number matches in 1 hour to be considered a likely location. (optional, default to 1L)
     * @param distanceUnit Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS} (optional, default to DistanceUnit.MILES)
     * @param searchRange Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \&quot;0\&quot; (zero) will ignore the radius restriction. (optional, default to 0.0)
     * @param sortOrder The ordering algorithm for sorting the returned results: {MATCHES, DISTANCE, WEIGHTED} (optional, default to SortOrder.MATCHES)
     * @return ApiResponse<PredictedLocationResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getPredictedLocationsWithHttpInfo(accountId: kotlin.Long, latitude: kotlin.Double?, longitude: kotlin.Double?, dateCheck: kotlin.Long?, hourCheck: kotlin.String?, threshold: kotlin.Long?, distanceUnit: DistanceUnitGetPredictedLocations?, searchRange: kotlin.Double?, sortOrder: SortOrderGetPredictedLocations?) : ApiResponse<PredictedLocationResponse?> {
        val localVariableConfig = getPredictedLocationsRequestConfig(accountId = accountId, latitude = latitude, longitude = longitude, dateCheck = dateCheck, hourCheck = hourCheck, threshold = threshold, distanceUnit = distanceUnit, searchRange = searchRange, sortOrder = sortOrder)

        return request<Unit, PredictedLocationResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getPredictedLocations
     *
     * @param accountId The account id of the customer
     * @param latitude latitude to return a more likely result set based on the user&#39;s current location (optional)
     * @param longitude longitude to return a more likely result set based on the user&#39;s current location (optional)
     * @param dateCheck Used to specify which day to get predicted locations for. So if you want to look at where they might be tomorrow, pass in tomorrow&#39;s date (timestamp in milliseconds). If no value is passed in, the current date will be used. (optional)
     * @param hourCheck Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see predicted locations for the mornings and evening you can pass in \&quot;8,9,10,11,17,18,19,20\&quot;. (optional)
     * @param threshold The minimum number matches in 1 hour to be considered a likely location. (optional, default to 1L)
     * @param distanceUnit Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS} (optional, default to DistanceUnit.MILES)
     * @param searchRange Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \&quot;0\&quot; (zero) will ignore the radius restriction. (optional, default to 0.0)
     * @param sortOrder The ordering algorithm for sorting the returned results: {MATCHES, DISTANCE, WEIGHTED} (optional, default to SortOrder.MATCHES)
     * @return RequestConfig
     */
    fun getPredictedLocationsRequestConfig(accountId: kotlin.Long, latitude: kotlin.Double?, longitude: kotlin.Double?, dateCheck: kotlin.Long?, hourCheck: kotlin.String?, threshold: kotlin.Long?, distanceUnit: DistanceUnitGetPredictedLocations?, searchRange: kotlin.Double?, sortOrder: SortOrderGetPredictedLocations?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                if (latitude != null) {
                    put("latitude", listOf(latitude.toString()))
                }
                if (longitude != null) {
                    put("longitude", listOf(longitude.toString()))
                }
                if (dateCheck != null) {
                    put("dateCheck", listOf(dateCheck.toString()))
                }
                if (hourCheck != null) {
                    put("hourCheck", listOf(hourCheck.toString()))
                }
                if (threshold != null) {
                    put("threshold", listOf(threshold.toString()))
                }
                if (distanceUnit != null) {
                    put("distanceUnit", listOf(distanceUnit.value))
                }
                if (searchRange != null) {
                    put("searchRange", listOf(searchRange.toString()))
                }
                if (sortOrder != null) {
                    put("sortOrder", listOf(sortOrder.value))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/tracking/predicted/get",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /tracking/path/get
     * Get Tracking Path
     * Get the path (lat/long coordinates) between 2 steps previously logged for a customer.
     * @param accountId The account id of the customer
     * @param startStepId The stepId to begin from
     * @param endStepId The stepId to end with
     * @return kotlin.collections.List<StepResponse>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getPredictedPath(accountId: kotlin.Long, startStepId: kotlin.Long, endStepId: kotlin.Long) : kotlin.collections.List<StepResponse> {
        val localVarResponse = getPredictedPathWithHttpInfo(accountId = accountId, startStepId = startStepId, endStepId = endStepId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<StepResponse>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /tracking/path/get
     * Get Tracking Path
     * Get the path (lat/long coordinates) between 2 steps previously logged for a customer.
     * @param accountId The account id of the customer
     * @param startStepId The stepId to begin from
     * @param endStepId The stepId to end with
     * @return ApiResponse<kotlin.collections.List<StepResponse>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getPredictedPathWithHttpInfo(accountId: kotlin.Long, startStepId: kotlin.Long, endStepId: kotlin.Long) : ApiResponse<kotlin.collections.List<StepResponse>?> {
        val localVariableConfig = getPredictedPathRequestConfig(accountId = accountId, startStepId = startStepId, endStepId = endStepId)

        return request<Unit, kotlin.collections.List<StepResponse>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getPredictedPath
     *
     * @param accountId The account id of the customer
     * @param startStepId The stepId to begin from
     * @param endStepId The stepId to end with
     * @return RequestConfig
     */
    fun getPredictedPathRequestConfig(accountId: kotlin.Long, startStepId: kotlin.Long, endStepId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("startStepId", listOf(startStepId.toString()))
                put("endStepId", listOf(endStepId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/tracking/path/get",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter distanceUnit
     */
     enum class DistanceUnitGetPreferredLocations(val value: kotlin.String) {
         @Json(name = "MILES") MILES("MILES"),
         @Json(name = "KILOMETERS") KILOMETERS("KILOMETERS");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /tracking/preferred/search
     * Search Preferred Locations
     * Search on preferred locations for a user, which is created when a customer resides in a place for a period of time.
     * @param accountId The account id of the customer
     * @param latitude latitude to return a more likely result set based on the user&#39;s current location (optional)
     * @param longitude longitude to return a more likely result set based on the user&#39;s current location (optional)
     * @param dateCheck Used to specify which day to get preferred locations for. So if you want to look at where they might be tomorrow, pass in tomorrow&#39;s date (timestamp in milliseconds). If no value is passed in, results from all time will be returned. (optional)
     * @param hourCheck Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see preferred locations for the mornings and evening you can pass in \&quot;8,9,10,11,17,18,19,20\&quot;. (optional)
     * @param sortField Specifies how the results will be ordered. Supported values include: CREATED - the time of when the preferred location data was processed. PREFERRED_DATE - the time of when the user sent in the tracking data. HOUR - the hour of when the user sent in the tracking data. DURATION - the duration of the preferred location (optional, default to "PREFERRED_DATE")
     * @param descending Determines whether the sorted list is in descending or ascending order (optional, default to true)
     * @param start The start index for pagination (optional, default to 0)
     * @param limit The limit for pagination (optional, default to 20)
     * @param searchRange Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \&quot;0\&quot; (zero) will ignore the radius restriction. (optional, default to 0.0)
     * @param distanceUnit Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS} (optional, default to DistanceUnit.MILES)
     * @return kotlin.collections.List<PreferredLocationResponse>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getPreferredLocations(accountId: kotlin.Long, latitude: kotlin.Double? = null, longitude: kotlin.Double? = null, dateCheck: kotlin.Long? = null, hourCheck: kotlin.String? = null, sortField: kotlin.String? = "PREFERRED_DATE", descending: kotlin.Boolean? = true, start: kotlin.Int? = 0, limit: kotlin.Int? = 20, searchRange: kotlin.Double? = 0.0, distanceUnit: DistanceUnitGetPreferredLocations? = DistanceUnitGetPreferredLocations.MILES) : kotlin.collections.List<PreferredLocationResponse> {
        val localVarResponse = getPreferredLocationsWithHttpInfo(accountId = accountId, latitude = latitude, longitude = longitude, dateCheck = dateCheck, hourCheck = hourCheck, sortField = sortField, descending = descending, start = start, limit = limit, searchRange = searchRange, distanceUnit = distanceUnit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<PreferredLocationResponse>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /tracking/preferred/search
     * Search Preferred Locations
     * Search on preferred locations for a user, which is created when a customer resides in a place for a period of time.
     * @param accountId The account id of the customer
     * @param latitude latitude to return a more likely result set based on the user&#39;s current location (optional)
     * @param longitude longitude to return a more likely result set based on the user&#39;s current location (optional)
     * @param dateCheck Used to specify which day to get preferred locations for. So if you want to look at where they might be tomorrow, pass in tomorrow&#39;s date (timestamp in milliseconds). If no value is passed in, results from all time will be returned. (optional)
     * @param hourCheck Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see preferred locations for the mornings and evening you can pass in \&quot;8,9,10,11,17,18,19,20\&quot;. (optional)
     * @param sortField Specifies how the results will be ordered. Supported values include: CREATED - the time of when the preferred location data was processed. PREFERRED_DATE - the time of when the user sent in the tracking data. HOUR - the hour of when the user sent in the tracking data. DURATION - the duration of the preferred location (optional, default to "PREFERRED_DATE")
     * @param descending Determines whether the sorted list is in descending or ascending order (optional, default to true)
     * @param start The start index for pagination (optional, default to 0)
     * @param limit The limit for pagination (optional, default to 20)
     * @param searchRange Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \&quot;0\&quot; (zero) will ignore the radius restriction. (optional, default to 0.0)
     * @param distanceUnit Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS} (optional, default to DistanceUnit.MILES)
     * @return ApiResponse<kotlin.collections.List<PreferredLocationResponse>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getPreferredLocationsWithHttpInfo(accountId: kotlin.Long, latitude: kotlin.Double?, longitude: kotlin.Double?, dateCheck: kotlin.Long?, hourCheck: kotlin.String?, sortField: kotlin.String?, descending: kotlin.Boolean?, start: kotlin.Int?, limit: kotlin.Int?, searchRange: kotlin.Double?, distanceUnit: DistanceUnitGetPreferredLocations?) : ApiResponse<kotlin.collections.List<PreferredLocationResponse>?> {
        val localVariableConfig = getPreferredLocationsRequestConfig(accountId = accountId, latitude = latitude, longitude = longitude, dateCheck = dateCheck, hourCheck = hourCheck, sortField = sortField, descending = descending, start = start, limit = limit, searchRange = searchRange, distanceUnit = distanceUnit)

        return request<Unit, kotlin.collections.List<PreferredLocationResponse>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getPreferredLocations
     *
     * @param accountId The account id of the customer
     * @param latitude latitude to return a more likely result set based on the user&#39;s current location (optional)
     * @param longitude longitude to return a more likely result set based on the user&#39;s current location (optional)
     * @param dateCheck Used to specify which day to get preferred locations for. So if you want to look at where they might be tomorrow, pass in tomorrow&#39;s date (timestamp in milliseconds). If no value is passed in, results from all time will be returned. (optional)
     * @param hourCheck Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see preferred locations for the mornings and evening you can pass in \&quot;8,9,10,11,17,18,19,20\&quot;. (optional)
     * @param sortField Specifies how the results will be ordered. Supported values include: CREATED - the time of when the preferred location data was processed. PREFERRED_DATE - the time of when the user sent in the tracking data. HOUR - the hour of when the user sent in the tracking data. DURATION - the duration of the preferred location (optional, default to "PREFERRED_DATE")
     * @param descending Determines whether the sorted list is in descending or ascending order (optional, default to true)
     * @param start The start index for pagination (optional, default to 0)
     * @param limit The limit for pagination (optional, default to 20)
     * @param searchRange Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \&quot;0\&quot; (zero) will ignore the radius restriction. (optional, default to 0.0)
     * @param distanceUnit Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS} (optional, default to DistanceUnit.MILES)
     * @return RequestConfig
     */
    fun getPreferredLocationsRequestConfig(accountId: kotlin.Long, latitude: kotlin.Double?, longitude: kotlin.Double?, dateCheck: kotlin.Long?, hourCheck: kotlin.String?, sortField: kotlin.String?, descending: kotlin.Boolean?, start: kotlin.Int?, limit: kotlin.Int?, searchRange: kotlin.Double?, distanceUnit: DistanceUnitGetPreferredLocations?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                if (latitude != null) {
                    put("latitude", listOf(latitude.toString()))
                }
                if (longitude != null) {
                    put("longitude", listOf(longitude.toString()))
                }
                if (dateCheck != null) {
                    put("dateCheck", listOf(dateCheck.toString()))
                }
                if (hourCheck != null) {
                    put("hourCheck", listOf(hourCheck.toString()))
                }
                if (sortField != null) {
                    put("sortField", listOf(sortField.toString()))
                }
                if (descending != null) {
                    put("descending", listOf(descending.toString()))
                }
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (searchRange != null) {
                    put("searchRange", listOf(searchRange.toString()))
                }
                if (distanceUnit != null) {
                    put("distanceUnit", listOf(distanceUnit.value))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/tracking/preferred/search",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /tracking/search
     * Search Tracking
     * Retrieve tracking data to be able to show where a user has been.
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param ownerId the account id of the person the user wants to tracking data for (optional)
     * @param trackingDeviceId the id of the tracking device (optional)
     * @param startDate the start date in (UTC milliseconds) to filter the tracking results. If no startDate is passed in, the last 30 days will be returned. (optional)
     * @param endDate the end date in (UTC milliseconds) to filter the tracking results (optional)
     * @param tags filter results by tag (optional)
     * @param getLastPoint gets the last known location of the user (optional, default to false)
     * @return kotlin.collections.List<LegResponse>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getTrackingLegs(deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, ownerId: kotlin.Long? = null, trackingDeviceId: kotlin.String? = null, startDate: kotlin.Long? = null, endDate: kotlin.Long? = null, tags: kotlin.String? = null, getLastPoint: kotlin.Boolean? = false) : kotlin.collections.List<LegResponse> {
        val localVarResponse = getTrackingLegsWithHttpInfo(deviceId = deviceId, accountId = accountId, ownerId = ownerId, trackingDeviceId = trackingDeviceId, startDate = startDate, endDate = endDate, tags = tags, getLastPoint = getLastPoint)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<LegResponse>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /tracking/search
     * Search Tracking
     * Retrieve tracking data to be able to show where a user has been.
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param ownerId the account id of the person the user wants to tracking data for (optional)
     * @param trackingDeviceId the id of the tracking device (optional)
     * @param startDate the start date in (UTC milliseconds) to filter the tracking results. If no startDate is passed in, the last 30 days will be returned. (optional)
     * @param endDate the end date in (UTC milliseconds) to filter the tracking results (optional)
     * @param tags filter results by tag (optional)
     * @param getLastPoint gets the last known location of the user (optional, default to false)
     * @return ApiResponse<kotlin.collections.List<LegResponse>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getTrackingLegsWithHttpInfo(deviceId: kotlin.String?, accountId: kotlin.Long?, ownerId: kotlin.Long?, trackingDeviceId: kotlin.String?, startDate: kotlin.Long?, endDate: kotlin.Long?, tags: kotlin.String?, getLastPoint: kotlin.Boolean?) : ApiResponse<kotlin.collections.List<LegResponse>?> {
        val localVariableConfig = getTrackingLegsRequestConfig(deviceId = deviceId, accountId = accountId, ownerId = ownerId, trackingDeviceId = trackingDeviceId, startDate = startDate, endDate = endDate, tags = tags, getLastPoint = getLastPoint)

        return request<Unit, kotlin.collections.List<LegResponse>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getTrackingLegs
     *
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param ownerId the account id of the person the user wants to tracking data for (optional)
     * @param trackingDeviceId the id of the tracking device (optional)
     * @param startDate the start date in (UTC milliseconds) to filter the tracking results. If no startDate is passed in, the last 30 days will be returned. (optional)
     * @param endDate the end date in (UTC milliseconds) to filter the tracking results (optional)
     * @param tags filter results by tag (optional)
     * @param getLastPoint gets the last known location of the user (optional, default to false)
     * @return RequestConfig
     */
    fun getTrackingLegsRequestConfig(deviceId: kotlin.String?, accountId: kotlin.Long?, ownerId: kotlin.Long?, trackingDeviceId: kotlin.String?, startDate: kotlin.Long?, endDate: kotlin.Long?, tags: kotlin.String?, getLastPoint: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (ownerId != null) {
                    put("ownerId", listOf(ownerId.toString()))
                }
                if (trackingDeviceId != null) {
                    put("trackingDeviceId", listOf(trackingDeviceId.toString()))
                }
                if (startDate != null) {
                    put("startDate", listOf(startDate.toString()))
                }
                if (endDate != null) {
                    put("endDate", listOf(endDate.toString()))
                }
                if (tags != null) {
                    put("tags", listOf(tags.toString()))
                }
                if (getLastPoint != null) {
                    put("getLastPoint", listOf(getLastPoint.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/tracking/search",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /tracking/leg/create
     * Create Tracking Leg
     * Send tracking points to be able to generate pathing data
     * @param startLat the latitude of the first point
     * @param startLng the longitude of the first point
     * @param startDate the start date (in UTC milliseconds) of the first point
     * @param endLat the latitude of the last point
     * @param endLng the longitude of the last point
     * @param endDate the end date (in UTC milliseconds) of the last point
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param distance the total distance (optional)
     * @param duration the total duration (optional)
     * @param steps JSON array of tracking vectors used for smoother pathing data. If null then the leg data will be used to generate a single step, if an empty array then no steps will be generated. &#x60;&#x60;&#x60;json [{   \&quot;distance\&quot;: \&quot;0.03\&quot;,   \&quot;duration\&quot;: \&quot;5000\&quot;,   \&quot;startLat\&quot;: \&quot;47.614603\&quot;,   \&quot;startLng\&quot;: \&quot;-122.350518\&quot;,   \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,   \&quot;endLat\&quot;: \&quot;47.614941\&quot;,   \&quot;endLng\&quot;: \&quot;-122.350062\&quot;,   \&quot;endDate\&quot;: \&quot;1361924015000\&quot; }] &#x60;&#x60;&#x60;  (optional)
     * @param tags name the leg for searching (optional)
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun saveTrackingLeg(startLat: kotlin.Double, startLng: kotlin.Double, startDate: kotlin.Long, endLat: kotlin.Double, endLng: kotlin.Double, endDate: kotlin.Long, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, distance: kotlin.Double? = null, duration: kotlin.Long? = null, steps: kotlin.String? = null, tags: kotlin.String? = null) : SirqulResponse {
        val localVarResponse = saveTrackingLegWithHttpInfo(startLat = startLat, startLng = startLng, startDate = startDate, endLat = endLat, endLng = endLng, endDate = endDate, deviceId = deviceId, accountId = accountId, distance = distance, duration = duration, steps = steps, tags = tags)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /tracking/leg/create
     * Create Tracking Leg
     * Send tracking points to be able to generate pathing data
     * @param startLat the latitude of the first point
     * @param startLng the longitude of the first point
     * @param startDate the start date (in UTC milliseconds) of the first point
     * @param endLat the latitude of the last point
     * @param endLng the longitude of the last point
     * @param endDate the end date (in UTC milliseconds) of the last point
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param distance the total distance (optional)
     * @param duration the total duration (optional)
     * @param steps JSON array of tracking vectors used for smoother pathing data. If null then the leg data will be used to generate a single step, if an empty array then no steps will be generated. &#x60;&#x60;&#x60;json [{   \&quot;distance\&quot;: \&quot;0.03\&quot;,   \&quot;duration\&quot;: \&quot;5000\&quot;,   \&quot;startLat\&quot;: \&quot;47.614603\&quot;,   \&quot;startLng\&quot;: \&quot;-122.350518\&quot;,   \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,   \&quot;endLat\&quot;: \&quot;47.614941\&quot;,   \&quot;endLng\&quot;: \&quot;-122.350062\&quot;,   \&quot;endDate\&quot;: \&quot;1361924015000\&quot; }] &#x60;&#x60;&#x60;  (optional)
     * @param tags name the leg for searching (optional)
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun saveTrackingLegWithHttpInfo(startLat: kotlin.Double, startLng: kotlin.Double, startDate: kotlin.Long, endLat: kotlin.Double, endLng: kotlin.Double, endDate: kotlin.Long, deviceId: kotlin.String?, accountId: kotlin.Long?, distance: kotlin.Double?, duration: kotlin.Long?, steps: kotlin.String?, tags: kotlin.String?) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = saveTrackingLegRequestConfig(startLat = startLat, startLng = startLng, startDate = startDate, endLat = endLat, endLng = endLng, endDate = endDate, deviceId = deviceId, accountId = accountId, distance = distance, duration = duration, steps = steps, tags = tags)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation saveTrackingLeg
     *
     * @param startLat the latitude of the first point
     * @param startLng the longitude of the first point
     * @param startDate the start date (in UTC milliseconds) of the first point
     * @param endLat the latitude of the last point
     * @param endLng the longitude of the last point
     * @param endDate the end date (in UTC milliseconds) of the last point
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param distance the total distance (optional)
     * @param duration the total duration (optional)
     * @param steps JSON array of tracking vectors used for smoother pathing data. If null then the leg data will be used to generate a single step, if an empty array then no steps will be generated. &#x60;&#x60;&#x60;json [{   \&quot;distance\&quot;: \&quot;0.03\&quot;,   \&quot;duration\&quot;: \&quot;5000\&quot;,   \&quot;startLat\&quot;: \&quot;47.614603\&quot;,   \&quot;startLng\&quot;: \&quot;-122.350518\&quot;,   \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,   \&quot;endLat\&quot;: \&quot;47.614941\&quot;,   \&quot;endLng\&quot;: \&quot;-122.350062\&quot;,   \&quot;endDate\&quot;: \&quot;1361924015000\&quot; }] &#x60;&#x60;&#x60;  (optional)
     * @param tags name the leg for searching (optional)
     * @return RequestConfig
     */
    fun saveTrackingLegRequestConfig(startLat: kotlin.Double, startLng: kotlin.Double, startDate: kotlin.Long, endLat: kotlin.Double, endLng: kotlin.Double, endDate: kotlin.Long, deviceId: kotlin.String?, accountId: kotlin.Long?, distance: kotlin.Double?, duration: kotlin.Long?, steps: kotlin.String?, tags: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (distance != null) {
                    put("distance", listOf(distance.toString()))
                }
                if (duration != null) {
                    put("duration", listOf(duration.toString()))
                }
                put("startLat", listOf(startLat.toString()))
                put("startLng", listOf(startLng.toString()))
                put("startDate", listOf(startDate.toString()))
                put("endLat", listOf(endLat.toString()))
                put("endLng", listOf(endLng.toString()))
                put("endDate", listOf(endDate.toString()))
                if (steps != null) {
                    put("steps", listOf(steps.toString()))
                }
                if (tags != null) {
                    put("tags", listOf(tags.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/tracking/leg/create",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /tracking/step/create
     * Create Tracking Step
     * Send tracking points to be able to generate pathing data
     * @param legId the leg to add the step to
     * @param startLat the latitude of the first point
     * @param startLng the longitude of the first point
     * @param startDate the start date (in UTC milliseconds) of the first point
     * @param endLat the latitude of the last point
     * @param endLng the longitude of the last point
     * @param endDate the end date (in UTC milliseconds) of the last point
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param distance the total distance (optional)
     * @param duration the total duration (optional)
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun saveTrackingStep(legId: kotlin.Long, startLat: kotlin.Double, startLng: kotlin.Double, startDate: kotlin.Long, endLat: kotlin.Double, endLng: kotlin.Double, endDate: kotlin.Long, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, distance: kotlin.Double? = null, duration: kotlin.Long? = null) : SirqulResponse {
        val localVarResponse = saveTrackingStepWithHttpInfo(legId = legId, startLat = startLat, startLng = startLng, startDate = startDate, endLat = endLat, endLng = endLng, endDate = endDate, deviceId = deviceId, accountId = accountId, distance = distance, duration = duration)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /tracking/step/create
     * Create Tracking Step
     * Send tracking points to be able to generate pathing data
     * @param legId the leg to add the step to
     * @param startLat the latitude of the first point
     * @param startLng the longitude of the first point
     * @param startDate the start date (in UTC milliseconds) of the first point
     * @param endLat the latitude of the last point
     * @param endLng the longitude of the last point
     * @param endDate the end date (in UTC milliseconds) of the last point
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param distance the total distance (optional)
     * @param duration the total duration (optional)
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun saveTrackingStepWithHttpInfo(legId: kotlin.Long, startLat: kotlin.Double, startLng: kotlin.Double, startDate: kotlin.Long, endLat: kotlin.Double, endLng: kotlin.Double, endDate: kotlin.Long, deviceId: kotlin.String?, accountId: kotlin.Long?, distance: kotlin.Double?, duration: kotlin.Long?) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = saveTrackingStepRequestConfig(legId = legId, startLat = startLat, startLng = startLng, startDate = startDate, endLat = endLat, endLng = endLng, endDate = endDate, deviceId = deviceId, accountId = accountId, distance = distance, duration = duration)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation saveTrackingStep
     *
     * @param legId the leg to add the step to
     * @param startLat the latitude of the first point
     * @param startLng the longitude of the first point
     * @param startDate the start date (in UTC milliseconds) of the first point
     * @param endLat the latitude of the last point
     * @param endLng the longitude of the last point
     * @param endDate the end date (in UTC milliseconds) of the last point
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param distance the total distance (optional)
     * @param duration the total duration (optional)
     * @return RequestConfig
     */
    fun saveTrackingStepRequestConfig(legId: kotlin.Long, startLat: kotlin.Double, startLng: kotlin.Double, startDate: kotlin.Long, endLat: kotlin.Double, endLng: kotlin.Double, endDate: kotlin.Long, deviceId: kotlin.String?, accountId: kotlin.Long?, distance: kotlin.Double?, duration: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                put("legId", listOf(legId.toString()))
                if (distance != null) {
                    put("distance", listOf(distance.toString()))
                }
                if (duration != null) {
                    put("duration", listOf(duration.toString()))
                }
                put("startLat", listOf(startLat.toString()))
                put("startLng", listOf(startLng.toString()))
                put("startDate", listOf(startDate.toString()))
                put("endLat", listOf(endLat.toString()))
                put("endLng", listOf(endLng.toString()))
                put("endDate", listOf(endDate.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/tracking/step/create",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /tracking/list
     * List Tracking
     * Search for all accounts that have tracking legs data by the given constraints.
     * @param accountId The account id of the user
     * @param keyword Used for LIKE search of first or last name on the acocunt (optional)
     * @param startDate Range to begin in UTC milliseconds (optional)
     * @param endDate Range to end in UTC milliseconds (optional)
     * @param tags Exact match on tag field of Legs&#39;s searchTag (optional)
     * @param audienceIds  (optional)
     * @param latitude Origin latitude to perform searching constraints with given range (optional)
     * @param longitude Origin longitude to perform searching constraints with given range (optional)
     * @param range The radius, in miles, to perform the search for (optional, default to 5.0)
     * @param sortField The column to sort the search on. Possible values include: {LEG_START_DATE, ACCOUNT_DISPLAY} (optional, default to "LEG_START_DATE")
     * @param descending The order to return the results. Default is false, which will return the results in ascending order. (optional, default to true)
     * @param start The index into the record set to start with. Default is 0. (optional, default to 0)
     * @param limit The total number of records to return. Default is 20. (optional, default to 20)
     * @param activeOnly Determines whether to return only active results. Default is false. (optional, default to false)
     * @return kotlin.collections.List<AccountMiniResponse>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun searchAccountsWithTrackingLegs(accountId: kotlin.Long, keyword: kotlin.String? = null, startDate: kotlin.Long? = null, endDate: kotlin.Long? = null, tags: kotlin.String? = null, audienceIds: kotlin.String? = null, latitude: kotlin.Double? = null, longitude: kotlin.Double? = null, range: kotlin.Double? = 5.0, sortField: kotlin.String? = "LEG_START_DATE", descending: kotlin.Boolean? = true, start: kotlin.Int? = 0, limit: kotlin.Int? = 20, activeOnly: kotlin.Boolean? = false) : kotlin.collections.List<AccountMiniResponse> {
        val localVarResponse = searchAccountsWithTrackingLegsWithHttpInfo(accountId = accountId, keyword = keyword, startDate = startDate, endDate = endDate, tags = tags, audienceIds = audienceIds, latitude = latitude, longitude = longitude, range = range, sortField = sortField, descending = descending, start = start, limit = limit, activeOnly = activeOnly)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<AccountMiniResponse>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /tracking/list
     * List Tracking
     * Search for all accounts that have tracking legs data by the given constraints.
     * @param accountId The account id of the user
     * @param keyword Used for LIKE search of first or last name on the acocunt (optional)
     * @param startDate Range to begin in UTC milliseconds (optional)
     * @param endDate Range to end in UTC milliseconds (optional)
     * @param tags Exact match on tag field of Legs&#39;s searchTag (optional)
     * @param audienceIds  (optional)
     * @param latitude Origin latitude to perform searching constraints with given range (optional)
     * @param longitude Origin longitude to perform searching constraints with given range (optional)
     * @param range The radius, in miles, to perform the search for (optional, default to 5.0)
     * @param sortField The column to sort the search on. Possible values include: {LEG_START_DATE, ACCOUNT_DISPLAY} (optional, default to "LEG_START_DATE")
     * @param descending The order to return the results. Default is false, which will return the results in ascending order. (optional, default to true)
     * @param start The index into the record set to start with. Default is 0. (optional, default to 0)
     * @param limit The total number of records to return. Default is 20. (optional, default to 20)
     * @param activeOnly Determines whether to return only active results. Default is false. (optional, default to false)
     * @return ApiResponse<kotlin.collections.List<AccountMiniResponse>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun searchAccountsWithTrackingLegsWithHttpInfo(accountId: kotlin.Long, keyword: kotlin.String?, startDate: kotlin.Long?, endDate: kotlin.Long?, tags: kotlin.String?, audienceIds: kotlin.String?, latitude: kotlin.Double?, longitude: kotlin.Double?, range: kotlin.Double?, sortField: kotlin.String?, descending: kotlin.Boolean?, start: kotlin.Int?, limit: kotlin.Int?, activeOnly: kotlin.Boolean?) : ApiResponse<kotlin.collections.List<AccountMiniResponse>?> {
        val localVariableConfig = searchAccountsWithTrackingLegsRequestConfig(accountId = accountId, keyword = keyword, startDate = startDate, endDate = endDate, tags = tags, audienceIds = audienceIds, latitude = latitude, longitude = longitude, range = range, sortField = sortField, descending = descending, start = start, limit = limit, activeOnly = activeOnly)

        return request<Unit, kotlin.collections.List<AccountMiniResponse>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation searchAccountsWithTrackingLegs
     *
     * @param accountId The account id of the user
     * @param keyword Used for LIKE search of first or last name on the acocunt (optional)
     * @param startDate Range to begin in UTC milliseconds (optional)
     * @param endDate Range to end in UTC milliseconds (optional)
     * @param tags Exact match on tag field of Legs&#39;s searchTag (optional)
     * @param audienceIds  (optional)
     * @param latitude Origin latitude to perform searching constraints with given range (optional)
     * @param longitude Origin longitude to perform searching constraints with given range (optional)
     * @param range The radius, in miles, to perform the search for (optional, default to 5.0)
     * @param sortField The column to sort the search on. Possible values include: {LEG_START_DATE, ACCOUNT_DISPLAY} (optional, default to "LEG_START_DATE")
     * @param descending The order to return the results. Default is false, which will return the results in ascending order. (optional, default to true)
     * @param start The index into the record set to start with. Default is 0. (optional, default to 0)
     * @param limit The total number of records to return. Default is 20. (optional, default to 20)
     * @param activeOnly Determines whether to return only active results. Default is false. (optional, default to false)
     * @return RequestConfig
     */
    fun searchAccountsWithTrackingLegsRequestConfig(accountId: kotlin.Long, keyword: kotlin.String?, startDate: kotlin.Long?, endDate: kotlin.Long?, tags: kotlin.String?, audienceIds: kotlin.String?, latitude: kotlin.Double?, longitude: kotlin.Double?, range: kotlin.Double?, sortField: kotlin.String?, descending: kotlin.Boolean?, start: kotlin.Int?, limit: kotlin.Int?, activeOnly: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                if (keyword != null) {
                    put("keyword", listOf(keyword.toString()))
                }
                if (startDate != null) {
                    put("startDate", listOf(startDate.toString()))
                }
                if (endDate != null) {
                    put("endDate", listOf(endDate.toString()))
                }
                if (tags != null) {
                    put("tags", listOf(tags.toString()))
                }
                if (audienceIds != null) {
                    put("audienceIds", listOf(audienceIds.toString()))
                }
                if (latitude != null) {
                    put("latitude", listOf(latitude.toString()))
                }
                if (longitude != null) {
                    put("longitude", listOf(longitude.toString()))
                }
                if (range != null) {
                    put("range", listOf(range.toString()))
                }
                if (sortField != null) {
                    put("sortField", listOf(sortField.toString()))
                }
                if (descending != null) {
                    put("descending", listOf(descending.toString()))
                }
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (activeOnly != null) {
                    put("activeOnly", listOf(activeOnly.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/tracking/list",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /tracking/searchByBillable
     * Search Tracking (Billable)
     * Retrieve tracking data for billable/account scoped queries.
     * @param accountId The account id to search tracking for
     * @param appKey The application key
     * @param trackingDeviceId The id of the tracking device (optional)
     * @param startDate The start date in (UTC milliseconds) to filter the tracking results (optional)
     * @param endDate The end date in (UTC milliseconds) to filter the tracking results (optional)
     * @param tags Filter results by tag (optional)
     * @param start The start index for pagination (optional, default to 0)
     * @param limit The limit for pagination (optional, default to 100)
     * @return kotlin.collections.List<LegResponse>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun searchTrackingLegs(accountId: kotlin.Long, appKey: kotlin.String, trackingDeviceId: kotlin.String? = null, startDate: kotlin.Long? = null, endDate: kotlin.Long? = null, tags: kotlin.String? = null, start: kotlin.Int? = 0, limit: kotlin.Int? = 100) : kotlin.collections.List<LegResponse> {
        val localVarResponse = searchTrackingLegsWithHttpInfo(accountId = accountId, appKey = appKey, trackingDeviceId = trackingDeviceId, startDate = startDate, endDate = endDate, tags = tags, start = start, limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<LegResponse>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /tracking/searchByBillable
     * Search Tracking (Billable)
     * Retrieve tracking data for billable/account scoped queries.
     * @param accountId The account id to search tracking for
     * @param appKey The application key
     * @param trackingDeviceId The id of the tracking device (optional)
     * @param startDate The start date in (UTC milliseconds) to filter the tracking results (optional)
     * @param endDate The end date in (UTC milliseconds) to filter the tracking results (optional)
     * @param tags Filter results by tag (optional)
     * @param start The start index for pagination (optional, default to 0)
     * @param limit The limit for pagination (optional, default to 100)
     * @return ApiResponse<kotlin.collections.List<LegResponse>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun searchTrackingLegsWithHttpInfo(accountId: kotlin.Long, appKey: kotlin.String, trackingDeviceId: kotlin.String?, startDate: kotlin.Long?, endDate: kotlin.Long?, tags: kotlin.String?, start: kotlin.Int?, limit: kotlin.Int?) : ApiResponse<kotlin.collections.List<LegResponse>?> {
        val localVariableConfig = searchTrackingLegsRequestConfig(accountId = accountId, appKey = appKey, trackingDeviceId = trackingDeviceId, startDate = startDate, endDate = endDate, tags = tags, start = start, limit = limit)

        return request<Unit, kotlin.collections.List<LegResponse>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation searchTrackingLegs
     *
     * @param accountId The account id to search tracking for
     * @param appKey The application key
     * @param trackingDeviceId The id of the tracking device (optional)
     * @param startDate The start date in (UTC milliseconds) to filter the tracking results (optional)
     * @param endDate The end date in (UTC milliseconds) to filter the tracking results (optional)
     * @param tags Filter results by tag (optional)
     * @param start The start index for pagination (optional, default to 0)
     * @param limit The limit for pagination (optional, default to 100)
     * @return RequestConfig
     */
    fun searchTrackingLegsRequestConfig(accountId: kotlin.Long, appKey: kotlin.String, trackingDeviceId: kotlin.String?, startDate: kotlin.Long?, endDate: kotlin.Long?, tags: kotlin.String?, start: kotlin.Int?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("appKey", listOf(appKey.toString()))
                if (trackingDeviceId != null) {
                    put("trackingDeviceId", listOf(trackingDeviceId.toString()))
                }
                if (startDate != null) {
                    put("startDate", listOf(startDate.toString()))
                }
                if (endDate != null) {
                    put("endDate", listOf(endDate.toString()))
                }
                if (tags != null) {
                    put("tags", listOf(tags.toString()))
                }
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/tracking/searchByBillable",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
