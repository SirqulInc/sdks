/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import org.openapitools.client.models.SirqulResponse
import org.openapitools.client.models.UserPermissionsResponse

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

open class UserPermissionsApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://dev.sirqul.com/api/3.18")
        }
    }

    /**
     * enum for parameter permissionableType
     */
     enum class PermissionableTypeAddUsersToPermissionable(val value: kotlin.String) {
         @Json(name = "ACCOUNT") ACCOUNT("ACCOUNT"),
         @Json(name = "GAMELEVEL") GAMELEVEL("GAMELEVEL"),
         @Json(name = "ALBUM_CONTEST") ALBUM_CONTEST("ALBUM_CONTEST"),
         @Json(name = "THEME_DESCRIPTOR") THEME_DESCRIPTOR("THEME_DESCRIPTOR"),
         @Json(name = "SCHEDULED_NOTIFICATION") SCHEDULED_NOTIFICATION("SCHEDULED_NOTIFICATION"),
         @Json(name = "TASK") TASK("TASK"),
         @Json(name = "TRIGGER") TRIGGER("TRIGGER");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * POST /consumer/permissions/add
     * Add User
     * Adds a user to a permissionable object.
     * @param permissionableType the permissionable type of the object
     * @param permissionableId the id of the permissionable object
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param read the read permission of the users/groups (optional, default to true)
     * @param write the write permission of the users/groups (optional, default to false)
     * @param delete the delete permission of the users/groups (optional, default to false)
     * @param add the add permission of the users/groups (optional, default to false)
     * @param connectionIds a comma separated list of connection ids (NOT the account ids) (optional)
     * @param connectionAccountIds a comma separated list of account ids (optional)
     * @param connectionGroupIds a comma separated list of connection group ids (these are groups made by the user) (optional)
     * @param pending sets whether the added users are marked as pending (and will require the album admins to accept) - admins can set this to false (to accept) (optional, default to false)
     * @param admin sets whether the added users will become admins or not (optional)
     * @param includeFriendGroup flag to determine whether to include the built-in \&quot;friends\&quot; group (optional, default to false)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @param audienceIds comma separated list of audience ids. This is a feature only available to the permissionable&#39;s application owner (and its employees). This will add all users from these audiences to the permissionable object. Notifications will not be sent to users if this feature is used. (optional)
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun addUsersToPermissionable(permissionableType: PermissionableTypeAddUsersToPermissionable, permissionableId: kotlin.Long, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, read: kotlin.Boolean? = true, write: kotlin.Boolean? = false, delete: kotlin.Boolean? = false, add: kotlin.Boolean? = false, connectionIds: kotlin.String? = null, connectionAccountIds: kotlin.String? = null, connectionGroupIds: kotlin.String? = null, pending: kotlin.Boolean? = false, admin: kotlin.Boolean? = null, includeFriendGroup: kotlin.Boolean? = false, latitude: kotlin.Double? = null, longitude: kotlin.Double? = null, audienceIds: kotlin.String? = null) : SirqulResponse {
        val localVarResponse = addUsersToPermissionableWithHttpInfo(permissionableType = permissionableType, permissionableId = permissionableId, deviceId = deviceId, accountId = accountId, read = read, write = write, delete = delete, add = add, connectionIds = connectionIds, connectionAccountIds = connectionAccountIds, connectionGroupIds = connectionGroupIds, pending = pending, admin = admin, includeFriendGroup = includeFriendGroup, latitude = latitude, longitude = longitude, audienceIds = audienceIds)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /consumer/permissions/add
     * Add User
     * Adds a user to a permissionable object.
     * @param permissionableType the permissionable type of the object
     * @param permissionableId the id of the permissionable object
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param read the read permission of the users/groups (optional, default to true)
     * @param write the write permission of the users/groups (optional, default to false)
     * @param delete the delete permission of the users/groups (optional, default to false)
     * @param add the add permission of the users/groups (optional, default to false)
     * @param connectionIds a comma separated list of connection ids (NOT the account ids) (optional)
     * @param connectionAccountIds a comma separated list of account ids (optional)
     * @param connectionGroupIds a comma separated list of connection group ids (these are groups made by the user) (optional)
     * @param pending sets whether the added users are marked as pending (and will require the album admins to accept) - admins can set this to false (to accept) (optional, default to false)
     * @param admin sets whether the added users will become admins or not (optional)
     * @param includeFriendGroup flag to determine whether to include the built-in \&quot;friends\&quot; group (optional, default to false)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @param audienceIds comma separated list of audience ids. This is a feature only available to the permissionable&#39;s application owner (and its employees). This will add all users from these audiences to the permissionable object. Notifications will not be sent to users if this feature is used. (optional)
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun addUsersToPermissionableWithHttpInfo(permissionableType: PermissionableTypeAddUsersToPermissionable, permissionableId: kotlin.Long, deviceId: kotlin.String?, accountId: kotlin.Long?, read: kotlin.Boolean?, write: kotlin.Boolean?, delete: kotlin.Boolean?, add: kotlin.Boolean?, connectionIds: kotlin.String?, connectionAccountIds: kotlin.String?, connectionGroupIds: kotlin.String?, pending: kotlin.Boolean?, admin: kotlin.Boolean?, includeFriendGroup: kotlin.Boolean?, latitude: kotlin.Double?, longitude: kotlin.Double?, audienceIds: kotlin.String?) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = addUsersToPermissionableRequestConfig(permissionableType = permissionableType, permissionableId = permissionableId, deviceId = deviceId, accountId = accountId, read = read, write = write, delete = delete, add = add, connectionIds = connectionIds, connectionAccountIds = connectionAccountIds, connectionGroupIds = connectionGroupIds, pending = pending, admin = admin, includeFriendGroup = includeFriendGroup, latitude = latitude, longitude = longitude, audienceIds = audienceIds)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation addUsersToPermissionable
     *
     * @param permissionableType the permissionable type of the object
     * @param permissionableId the id of the permissionable object
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param read the read permission of the users/groups (optional, default to true)
     * @param write the write permission of the users/groups (optional, default to false)
     * @param delete the delete permission of the users/groups (optional, default to false)
     * @param add the add permission of the users/groups (optional, default to false)
     * @param connectionIds a comma separated list of connection ids (NOT the account ids) (optional)
     * @param connectionAccountIds a comma separated list of account ids (optional)
     * @param connectionGroupIds a comma separated list of connection group ids (these are groups made by the user) (optional)
     * @param pending sets whether the added users are marked as pending (and will require the album admins to accept) - admins can set this to false (to accept) (optional, default to false)
     * @param admin sets whether the added users will become admins or not (optional)
     * @param includeFriendGroup flag to determine whether to include the built-in \&quot;friends\&quot; group (optional, default to false)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @param audienceIds comma separated list of audience ids. This is a feature only available to the permissionable&#39;s application owner (and its employees). This will add all users from these audiences to the permissionable object. Notifications will not be sent to users if this feature is used. (optional)
     * @return RequestConfig
     */
    fun addUsersToPermissionableRequestConfig(permissionableType: PermissionableTypeAddUsersToPermissionable, permissionableId: kotlin.Long, deviceId: kotlin.String?, accountId: kotlin.Long?, read: kotlin.Boolean?, write: kotlin.Boolean?, delete: kotlin.Boolean?, add: kotlin.Boolean?, connectionIds: kotlin.String?, connectionAccountIds: kotlin.String?, connectionGroupIds: kotlin.String?, pending: kotlin.Boolean?, admin: kotlin.Boolean?, includeFriendGroup: kotlin.Boolean?, latitude: kotlin.Double?, longitude: kotlin.Double?, audienceIds: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                put("permissionableType", listOf(permissionableType.value))
                put("permissionableId", listOf(permissionableId.toString()))
                if (read != null) {
                    put("read", listOf(read.toString()))
                }
                if (write != null) {
                    put("write", listOf(write.toString()))
                }
                if (delete != null) {
                    put("delete", listOf(delete.toString()))
                }
                if (add != null) {
                    put("add", listOf(add.toString()))
                }
                if (connectionIds != null) {
                    put("connectionIds", listOf(connectionIds.toString()))
                }
                if (connectionAccountIds != null) {
                    put("connectionAccountIds", listOf(connectionAccountIds.toString()))
                }
                if (connectionGroupIds != null) {
                    put("connectionGroupIds", listOf(connectionGroupIds.toString()))
                }
                if (pending != null) {
                    put("pending", listOf(pending.toString()))
                }
                if (admin != null) {
                    put("admin", listOf(admin.toString()))
                }
                if (includeFriendGroup != null) {
                    put("includeFriendGroup", listOf(includeFriendGroup.toString()))
                }
                if (latitude != null) {
                    put("latitude", listOf(latitude.toString()))
                }
                if (longitude != null) {
                    put("longitude", listOf(longitude.toString()))
                }
                if (audienceIds != null) {
                    put("audienceIds", listOf(audienceIds.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/consumer/permissions/add",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter permissionableType
     */
     enum class PermissionableTypeApprovePermissionable(val value: kotlin.String) {
         @Json(name = "ACCOUNT") ACCOUNT("ACCOUNT"),
         @Json(name = "GAMELEVEL") GAMELEVEL("GAMELEVEL"),
         @Json(name = "ALBUM_CONTEST") ALBUM_CONTEST("ALBUM_CONTEST"),
         @Json(name = "THEME_DESCRIPTOR") THEME_DESCRIPTOR("THEME_DESCRIPTOR"),
         @Json(name = "SCHEDULED_NOTIFICATION") SCHEDULED_NOTIFICATION("SCHEDULED_NOTIFICATION"),
         @Json(name = "TASK") TASK("TASK"),
         @Json(name = "TRIGGER") TRIGGER("TRIGGER");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter approvalStatus
     */
     enum class ApprovalStatusApprovePermissionable(val value: kotlin.String) {
         @Json(name = "PENDING") PENDING("PENDING"),
         @Json(name = "REJECTED") REJECTED("REJECTED"),
         @Json(name = "APPROVED") APPROVED("APPROVED"),
         @Json(name = "FEATURED") FEATURED("FEATURED");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * POST /permissionable/approve
     * Approve Permissionable
     * Sets the approval status of a permissionable object.
     * @param permissionableType The permissionable type of the object
     * @param permissionableId The id of the permissionable object
     * @param deviceId A unique ID given by the device (deviceId or accountId required) (optional)
     * @param accountId The account ID of the user (deviceId or accountId required) (optional)
     * @param approvalStatus The approval status to set {PENDING, REJECTED, APPROVED, FEATURED} (optional, default to ApprovalStatus.APPROVED)
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun approvePermissionable(permissionableType: PermissionableTypeApprovePermissionable, permissionableId: kotlin.Long, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, approvalStatus: ApprovalStatusApprovePermissionable? = ApprovalStatusApprovePermissionable.APPROVED) : SirqulResponse {
        val localVarResponse = approvePermissionableWithHttpInfo(permissionableType = permissionableType, permissionableId = permissionableId, deviceId = deviceId, accountId = accountId, approvalStatus = approvalStatus)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /permissionable/approve
     * Approve Permissionable
     * Sets the approval status of a permissionable object.
     * @param permissionableType The permissionable type of the object
     * @param permissionableId The id of the permissionable object
     * @param deviceId A unique ID given by the device (deviceId or accountId required) (optional)
     * @param accountId The account ID of the user (deviceId or accountId required) (optional)
     * @param approvalStatus The approval status to set {PENDING, REJECTED, APPROVED, FEATURED} (optional, default to ApprovalStatus.APPROVED)
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun approvePermissionableWithHttpInfo(permissionableType: PermissionableTypeApprovePermissionable, permissionableId: kotlin.Long, deviceId: kotlin.String?, accountId: kotlin.Long?, approvalStatus: ApprovalStatusApprovePermissionable?) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = approvePermissionableRequestConfig(permissionableType = permissionableType, permissionableId = permissionableId, deviceId = deviceId, accountId = accountId, approvalStatus = approvalStatus)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation approvePermissionable
     *
     * @param permissionableType The permissionable type of the object
     * @param permissionableId The id of the permissionable object
     * @param deviceId A unique ID given by the device (deviceId or accountId required) (optional)
     * @param accountId The account ID of the user (deviceId or accountId required) (optional)
     * @param approvalStatus The approval status to set {PENDING, REJECTED, APPROVED, FEATURED} (optional, default to ApprovalStatus.APPROVED)
     * @return RequestConfig
     */
    fun approvePermissionableRequestConfig(permissionableType: PermissionableTypeApprovePermissionable, permissionableId: kotlin.Long, deviceId: kotlin.String?, accountId: kotlin.Long?, approvalStatus: ApprovalStatusApprovePermissionable?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                put("permissionableType", listOf(permissionableType.value))
                put("permissionableId", listOf(permissionableId.toString()))
                if (approvalStatus != null) {
                    put("approvalStatus", listOf(approvalStatus.value))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/permissionable/approve",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /consumer/permissions/leave
     * Leave
     * Used when the user wants to leave from someone else&#39;s permissionable object
     * @param permissionableType the permissionable type PermissionableType
     * @param permissionableId the id of the permissionable object
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun leaveFromPermissionable(permissionableType: kotlin.String, permissionableId: kotlin.Long, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, latitude: kotlin.Double? = null, longitude: kotlin.Double? = null) : SirqulResponse {
        val localVarResponse = leaveFromPermissionableWithHttpInfo(permissionableType = permissionableType, permissionableId = permissionableId, deviceId = deviceId, accountId = accountId, latitude = latitude, longitude = longitude)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /consumer/permissions/leave
     * Leave
     * Used when the user wants to leave from someone else&#39;s permissionable object
     * @param permissionableType the permissionable type PermissionableType
     * @param permissionableId the id of the permissionable object
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun leaveFromPermissionableWithHttpInfo(permissionableType: kotlin.String, permissionableId: kotlin.Long, deviceId: kotlin.String?, accountId: kotlin.Long?, latitude: kotlin.Double?, longitude: kotlin.Double?) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = leaveFromPermissionableRequestConfig(permissionableType = permissionableType, permissionableId = permissionableId, deviceId = deviceId, accountId = accountId, latitude = latitude, longitude = longitude)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation leaveFromPermissionable
     *
     * @param permissionableType the permissionable type PermissionableType
     * @param permissionableId the id of the permissionable object
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @return RequestConfig
     */
    fun leaveFromPermissionableRequestConfig(permissionableType: kotlin.String, permissionableId: kotlin.Long, deviceId: kotlin.String?, accountId: kotlin.Long?, latitude: kotlin.Double?, longitude: kotlin.Double?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                put("permissionableType", listOf(permissionableType.toString()))
                put("permissionableId", listOf(permissionableId.toString()))
                if (latitude != null) {
                    put("latitude", listOf(latitude.toString()))
                }
                if (longitude != null) {
                    put("longitude", listOf(longitude.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/consumer/permissions/leave",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter permissionableType
     */
     enum class PermissionableTypeRemoveUsersFromPermissionable(val value: kotlin.String) {
         @Json(name = "ACCOUNT") ACCOUNT("ACCOUNT"),
         @Json(name = "GAMELEVEL") GAMELEVEL("GAMELEVEL"),
         @Json(name = "ALBUM_CONTEST") ALBUM_CONTEST("ALBUM_CONTEST"),
         @Json(name = "THEME_DESCRIPTOR") THEME_DESCRIPTOR("THEME_DESCRIPTOR"),
         @Json(name = "SCHEDULED_NOTIFICATION") SCHEDULED_NOTIFICATION("SCHEDULED_NOTIFICATION"),
         @Json(name = "TASK") TASK("TASK"),
         @Json(name = "TRIGGER") TRIGGER("TRIGGER");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * POST /consumer/permissions/remove
     * Remove User
     * Used to remove someone (assuming they have permission) from a permissionable object
     * @param permissionableType the permissionable type of the object
     * @param permissionableId the id of the permissionable object
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param connectionIds a comma separated list of connection ids (NOT the account ids) (optional)
     * @param connectionAccountIds a comma separated list of account ids (optional)
     * @param connectionGroupIds a comma separated list of connection group ids (these are groups made by the user) (optional)
     * @param removeFriendGroup flag to determine whether to remove the built-in \&quot;friends\&quot; group (optional, default to false)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @param audienceIds comma separated list of audience ids. This will remove all users from these audiences from the permissionable object. Notifications will not be sent to users if this feature is used. (optional)
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun removeUsersFromPermissionable(permissionableType: PermissionableTypeRemoveUsersFromPermissionable, permissionableId: kotlin.Long, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, connectionIds: kotlin.String? = null, connectionAccountIds: kotlin.String? = null, connectionGroupIds: kotlin.String? = null, removeFriendGroup: kotlin.Boolean? = false, latitude: kotlin.Double? = null, longitude: kotlin.Double? = null, audienceIds: kotlin.String? = null) : SirqulResponse {
        val localVarResponse = removeUsersFromPermissionableWithHttpInfo(permissionableType = permissionableType, permissionableId = permissionableId, deviceId = deviceId, accountId = accountId, connectionIds = connectionIds, connectionAccountIds = connectionAccountIds, connectionGroupIds = connectionGroupIds, removeFriendGroup = removeFriendGroup, latitude = latitude, longitude = longitude, audienceIds = audienceIds)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /consumer/permissions/remove
     * Remove User
     * Used to remove someone (assuming they have permission) from a permissionable object
     * @param permissionableType the permissionable type of the object
     * @param permissionableId the id of the permissionable object
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param connectionIds a comma separated list of connection ids (NOT the account ids) (optional)
     * @param connectionAccountIds a comma separated list of account ids (optional)
     * @param connectionGroupIds a comma separated list of connection group ids (these are groups made by the user) (optional)
     * @param removeFriendGroup flag to determine whether to remove the built-in \&quot;friends\&quot; group (optional, default to false)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @param audienceIds comma separated list of audience ids. This will remove all users from these audiences from the permissionable object. Notifications will not be sent to users if this feature is used. (optional)
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun removeUsersFromPermissionableWithHttpInfo(permissionableType: PermissionableTypeRemoveUsersFromPermissionable, permissionableId: kotlin.Long, deviceId: kotlin.String?, accountId: kotlin.Long?, connectionIds: kotlin.String?, connectionAccountIds: kotlin.String?, connectionGroupIds: kotlin.String?, removeFriendGroup: kotlin.Boolean?, latitude: kotlin.Double?, longitude: kotlin.Double?, audienceIds: kotlin.String?) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = removeUsersFromPermissionableRequestConfig(permissionableType = permissionableType, permissionableId = permissionableId, deviceId = deviceId, accountId = accountId, connectionIds = connectionIds, connectionAccountIds = connectionAccountIds, connectionGroupIds = connectionGroupIds, removeFriendGroup = removeFriendGroup, latitude = latitude, longitude = longitude, audienceIds = audienceIds)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation removeUsersFromPermissionable
     *
     * @param permissionableType the permissionable type of the object
     * @param permissionableId the id of the permissionable object
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param connectionIds a comma separated list of connection ids (NOT the account ids) (optional)
     * @param connectionAccountIds a comma separated list of account ids (optional)
     * @param connectionGroupIds a comma separated list of connection group ids (these are groups made by the user) (optional)
     * @param removeFriendGroup flag to determine whether to remove the built-in \&quot;friends\&quot; group (optional, default to false)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @param audienceIds comma separated list of audience ids. This will remove all users from these audiences from the permissionable object. Notifications will not be sent to users if this feature is used. (optional)
     * @return RequestConfig
     */
    fun removeUsersFromPermissionableRequestConfig(permissionableType: PermissionableTypeRemoveUsersFromPermissionable, permissionableId: kotlin.Long, deviceId: kotlin.String?, accountId: kotlin.Long?, connectionIds: kotlin.String?, connectionAccountIds: kotlin.String?, connectionGroupIds: kotlin.String?, removeFriendGroup: kotlin.Boolean?, latitude: kotlin.Double?, longitude: kotlin.Double?, audienceIds: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                put("permissionableType", listOf(permissionableType.value))
                put("permissionableId", listOf(permissionableId.toString()))
                if (connectionIds != null) {
                    put("connectionIds", listOf(connectionIds.toString()))
                }
                if (connectionAccountIds != null) {
                    put("connectionAccountIds", listOf(connectionAccountIds.toString()))
                }
                if (connectionGroupIds != null) {
                    put("connectionGroupIds", listOf(connectionGroupIds.toString()))
                }
                if (removeFriendGroup != null) {
                    put("removeFriendGroup", listOf(removeFriendGroup.toString()))
                }
                if (latitude != null) {
                    put("latitude", listOf(latitude.toString()))
                }
                if (longitude != null) {
                    put("longitude", listOf(longitude.toString()))
                }
                if (audienceIds != null) {
                    put("audienceIds", listOf(audienceIds.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/consumer/permissions/remove",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter permissionableType
     */
     enum class PermissionableTypeSearchPermissionables(val value: kotlin.String) {
         @Json(name = "ACCOUNT") ACCOUNT("ACCOUNT"),
         @Json(name = "GAMELEVEL") GAMELEVEL("GAMELEVEL"),
         @Json(name = "ALBUM_CONTEST") ALBUM_CONTEST("ALBUM_CONTEST"),
         @Json(name = "THEME_DESCRIPTOR") THEME_DESCRIPTOR("THEME_DESCRIPTOR"),
         @Json(name = "SCHEDULED_NOTIFICATION") SCHEDULED_NOTIFICATION("SCHEDULED_NOTIFICATION"),
         @Json(name = "TASK") TASK("TASK"),
         @Json(name = "TRIGGER") TRIGGER("TRIGGER");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /permissions/search
     * Search Permissionables
     * Search on UserPermissions
     * @param deviceId A unique ID given by the device (deviceId or accountId required) (optional)
     * @param accountId The account ID of the user (deviceId or accountId required) (optional)
     * @param connectionAccountId Filter results for a specific user account (optional)
     * @param connectionAccountIds Comma separated list of account IDs to filter results with (optional)
     * @param permissionableType Filter user permissions by the permissionable object type (optional)
     * @param permissionableId The id of the permissionable object to filter by (optional)
     * @param keyword Keyword to search within permissionable records (optional)
     * @param sortField Field to sort results on (optional)
     * @param descending Sort descending when true (optional)
     * @param pending Return user permissions that are pending (optional)
     * @param admin Return user permissions that are admins (optional)
     * @param start the start index for pagination (optional, default to 0)
     * @param limit the limit for pagination (optional, default to 20)
     * @return kotlin.collections.List<UserPermissionsResponse>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun searchPermissionables(deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, connectionAccountId: kotlin.Long? = null, connectionAccountIds: kotlin.String? = null, permissionableType: PermissionableTypeSearchPermissionables? = null, permissionableId: kotlin.Long? = null, keyword: kotlin.String? = null, sortField: kotlin.String? = null, descending: kotlin.Boolean? = null, pending: kotlin.Boolean? = null, admin: kotlin.Boolean? = null, start: kotlin.Int? = 0, limit: kotlin.Int? = 20) : kotlin.collections.List<UserPermissionsResponse> {
        val localVarResponse = searchPermissionablesWithHttpInfo(deviceId = deviceId, accountId = accountId, connectionAccountId = connectionAccountId, connectionAccountIds = connectionAccountIds, permissionableType = permissionableType, permissionableId = permissionableId, keyword = keyword, sortField = sortField, descending = descending, pending = pending, admin = admin, start = start, limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UserPermissionsResponse>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /permissions/search
     * Search Permissionables
     * Search on UserPermissions
     * @param deviceId A unique ID given by the device (deviceId or accountId required) (optional)
     * @param accountId The account ID of the user (deviceId or accountId required) (optional)
     * @param connectionAccountId Filter results for a specific user account (optional)
     * @param connectionAccountIds Comma separated list of account IDs to filter results with (optional)
     * @param permissionableType Filter user permissions by the permissionable object type (optional)
     * @param permissionableId The id of the permissionable object to filter by (optional)
     * @param keyword Keyword to search within permissionable records (optional)
     * @param sortField Field to sort results on (optional)
     * @param descending Sort descending when true (optional)
     * @param pending Return user permissions that are pending (optional)
     * @param admin Return user permissions that are admins (optional)
     * @param start the start index for pagination (optional, default to 0)
     * @param limit the limit for pagination (optional, default to 20)
     * @return ApiResponse<kotlin.collections.List<UserPermissionsResponse>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun searchPermissionablesWithHttpInfo(deviceId: kotlin.String?, accountId: kotlin.Long?, connectionAccountId: kotlin.Long?, connectionAccountIds: kotlin.String?, permissionableType: PermissionableTypeSearchPermissionables?, permissionableId: kotlin.Long?, keyword: kotlin.String?, sortField: kotlin.String?, descending: kotlin.Boolean?, pending: kotlin.Boolean?, admin: kotlin.Boolean?, start: kotlin.Int?, limit: kotlin.Int?) : ApiResponse<kotlin.collections.List<UserPermissionsResponse>?> {
        val localVariableConfig = searchPermissionablesRequestConfig(deviceId = deviceId, accountId = accountId, connectionAccountId = connectionAccountId, connectionAccountIds = connectionAccountIds, permissionableType = permissionableType, permissionableId = permissionableId, keyword = keyword, sortField = sortField, descending = descending, pending = pending, admin = admin, start = start, limit = limit)

        return request<Unit, kotlin.collections.List<UserPermissionsResponse>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation searchPermissionables
     *
     * @param deviceId A unique ID given by the device (deviceId or accountId required) (optional)
     * @param accountId The account ID of the user (deviceId or accountId required) (optional)
     * @param connectionAccountId Filter results for a specific user account (optional)
     * @param connectionAccountIds Comma separated list of account IDs to filter results with (optional)
     * @param permissionableType Filter user permissions by the permissionable object type (optional)
     * @param permissionableId The id of the permissionable object to filter by (optional)
     * @param keyword Keyword to search within permissionable records (optional)
     * @param sortField Field to sort results on (optional)
     * @param descending Sort descending when true (optional)
     * @param pending Return user permissions that are pending (optional)
     * @param admin Return user permissions that are admins (optional)
     * @param start the start index for pagination (optional, default to 0)
     * @param limit the limit for pagination (optional, default to 20)
     * @return RequestConfig
     */
    fun searchPermissionablesRequestConfig(deviceId: kotlin.String?, accountId: kotlin.Long?, connectionAccountId: kotlin.Long?, connectionAccountIds: kotlin.String?, permissionableType: PermissionableTypeSearchPermissionables?, permissionableId: kotlin.Long?, keyword: kotlin.String?, sortField: kotlin.String?, descending: kotlin.Boolean?, pending: kotlin.Boolean?, admin: kotlin.Boolean?, start: kotlin.Int?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (connectionAccountId != null) {
                    put("connectionAccountId", listOf(connectionAccountId.toString()))
                }
                if (connectionAccountIds != null) {
                    put("connectionAccountIds", listOf(connectionAccountIds.toString()))
                }
                if (permissionableType != null) {
                    put("permissionableType", listOf(permissionableType.value))
                }
                if (permissionableId != null) {
                    put("permissionableId", listOf(permissionableId.toString()))
                }
                if (keyword != null) {
                    put("keyword", listOf(keyword.toString()))
                }
                if (sortField != null) {
                    put("sortField", listOf(sortField.toString()))
                }
                if (descending != null) {
                    put("descending", listOf(descending.toString()))
                }
                if (pending != null) {
                    put("pending", listOf(pending.toString()))
                }
                if (admin != null) {
                    put("admin", listOf(admin.toString()))
                }
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/permissions/search",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter permissionableType
     */
     enum class PermissionableTypeSearchPermissionablesFollowingDistance(val value: kotlin.String) {
         @Json(name = "ACCOUNT") ACCOUNT("ACCOUNT"),
         @Json(name = "GAMELEVEL") GAMELEVEL("GAMELEVEL"),
         @Json(name = "ALBUM_CONTEST") ALBUM_CONTEST("ALBUM_CONTEST"),
         @Json(name = "THEME_DESCRIPTOR") THEME_DESCRIPTOR("THEME_DESCRIPTOR"),
         @Json(name = "SCHEDULED_NOTIFICATION") SCHEDULED_NOTIFICATION("SCHEDULED_NOTIFICATION"),
         @Json(name = "TASK") TASK("TASK"),
         @Json(name = "TRIGGER") TRIGGER("TRIGGER");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /permissions/distancesearch
     * Search Permissionables by Distnace
     * Search on UserPermissions by distance
     * @param latitude The latitude of the current account
     * @param longitude The longitude of the current account
     * @param deviceId A unique ID given by the device (deviceId or accountId required) (optional)
     * @param accountId The account ID of the user (deviceId or accountId required) (optional)
     * @param connectionAccountId Filter results for a specific user account (optional)
     * @param connectionAccountIds Comma separated list of account IDs to filter results with (optional)
     * @param permissionableType Filter user permissions by the permissionable object type (optional)
     * @param permissionableId The id of the permissionable object to filter by (optional)
     * @param searchRange The search range in miles (optional, default to 5.0)
     * @param keyword Keyword to search within permissionable records (optional)
     * @param pending Return user permissions that are pending (optional)
     * @param admin Return user permissions that are admins (optional)
     * @param start The start index for pagination (optional, default to 0)
     * @param limit The limit for pagination (optional, default to 20)
     * @return kotlin.collections.List<UserPermissionsResponse>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun searchPermissionablesFollowingDistance(latitude: kotlin.Double, longitude: kotlin.Double, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, connectionAccountId: kotlin.Long? = null, connectionAccountIds: kotlin.String? = null, permissionableType: PermissionableTypeSearchPermissionablesFollowingDistance? = null, permissionableId: kotlin.Long? = null, searchRange: kotlin.Double? = 5.0, keyword: kotlin.String? = null, pending: kotlin.Boolean? = null, admin: kotlin.Boolean? = null, start: kotlin.Int? = 0, limit: kotlin.Int? = 20) : kotlin.collections.List<UserPermissionsResponse> {
        val localVarResponse = searchPermissionablesFollowingDistanceWithHttpInfo(latitude = latitude, longitude = longitude, deviceId = deviceId, accountId = accountId, connectionAccountId = connectionAccountId, connectionAccountIds = connectionAccountIds, permissionableType = permissionableType, permissionableId = permissionableId, searchRange = searchRange, keyword = keyword, pending = pending, admin = admin, start = start, limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UserPermissionsResponse>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /permissions/distancesearch
     * Search Permissionables by Distnace
     * Search on UserPermissions by distance
     * @param latitude The latitude of the current account
     * @param longitude The longitude of the current account
     * @param deviceId A unique ID given by the device (deviceId or accountId required) (optional)
     * @param accountId The account ID of the user (deviceId or accountId required) (optional)
     * @param connectionAccountId Filter results for a specific user account (optional)
     * @param connectionAccountIds Comma separated list of account IDs to filter results with (optional)
     * @param permissionableType Filter user permissions by the permissionable object type (optional)
     * @param permissionableId The id of the permissionable object to filter by (optional)
     * @param searchRange The search range in miles (optional, default to 5.0)
     * @param keyword Keyword to search within permissionable records (optional)
     * @param pending Return user permissions that are pending (optional)
     * @param admin Return user permissions that are admins (optional)
     * @param start The start index for pagination (optional, default to 0)
     * @param limit The limit for pagination (optional, default to 20)
     * @return ApiResponse<kotlin.collections.List<UserPermissionsResponse>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun searchPermissionablesFollowingDistanceWithHttpInfo(latitude: kotlin.Double, longitude: kotlin.Double, deviceId: kotlin.String?, accountId: kotlin.Long?, connectionAccountId: kotlin.Long?, connectionAccountIds: kotlin.String?, permissionableType: PermissionableTypeSearchPermissionablesFollowingDistance?, permissionableId: kotlin.Long?, searchRange: kotlin.Double?, keyword: kotlin.String?, pending: kotlin.Boolean?, admin: kotlin.Boolean?, start: kotlin.Int?, limit: kotlin.Int?) : ApiResponse<kotlin.collections.List<UserPermissionsResponse>?> {
        val localVariableConfig = searchPermissionablesFollowingDistanceRequestConfig(latitude = latitude, longitude = longitude, deviceId = deviceId, accountId = accountId, connectionAccountId = connectionAccountId, connectionAccountIds = connectionAccountIds, permissionableType = permissionableType, permissionableId = permissionableId, searchRange = searchRange, keyword = keyword, pending = pending, admin = admin, start = start, limit = limit)

        return request<Unit, kotlin.collections.List<UserPermissionsResponse>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation searchPermissionablesFollowingDistance
     *
     * @param latitude The latitude of the current account
     * @param longitude The longitude of the current account
     * @param deviceId A unique ID given by the device (deviceId or accountId required) (optional)
     * @param accountId The account ID of the user (deviceId or accountId required) (optional)
     * @param connectionAccountId Filter results for a specific user account (optional)
     * @param connectionAccountIds Comma separated list of account IDs to filter results with (optional)
     * @param permissionableType Filter user permissions by the permissionable object type (optional)
     * @param permissionableId The id of the permissionable object to filter by (optional)
     * @param searchRange The search range in miles (optional, default to 5.0)
     * @param keyword Keyword to search within permissionable records (optional)
     * @param pending Return user permissions that are pending (optional)
     * @param admin Return user permissions that are admins (optional)
     * @param start The start index for pagination (optional, default to 0)
     * @param limit The limit for pagination (optional, default to 20)
     * @return RequestConfig
     */
    fun searchPermissionablesFollowingDistanceRequestConfig(latitude: kotlin.Double, longitude: kotlin.Double, deviceId: kotlin.String?, accountId: kotlin.Long?, connectionAccountId: kotlin.Long?, connectionAccountIds: kotlin.String?, permissionableType: PermissionableTypeSearchPermissionablesFollowingDistance?, permissionableId: kotlin.Long?, searchRange: kotlin.Double?, keyword: kotlin.String?, pending: kotlin.Boolean?, admin: kotlin.Boolean?, start: kotlin.Int?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (connectionAccountId != null) {
                    put("connectionAccountId", listOf(connectionAccountId.toString()))
                }
                if (connectionAccountIds != null) {
                    put("connectionAccountIds", listOf(connectionAccountIds.toString()))
                }
                if (permissionableType != null) {
                    put("permissionableType", listOf(permissionableType.value))
                }
                if (permissionableId != null) {
                    put("permissionableId", listOf(permissionableId.toString()))
                }
                put("latitude", listOf(latitude.toString()))
                put("longitude", listOf(longitude.toString()))
                if (searchRange != null) {
                    put("searchRange", listOf(searchRange.toString()))
                }
                if (keyword != null) {
                    put("keyword", listOf(keyword.toString()))
                }
                if (pending != null) {
                    put("pending", listOf(pending.toString()))
                }
                if (admin != null) {
                    put("admin", listOf(admin.toString()))
                }
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/permissions/distancesearch",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
