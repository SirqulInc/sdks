/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import org.openapitools.client.models.AccountMiniResponse
import org.openapitools.client.models.AssignmentResponse
import org.openapitools.client.models.AssignmentStatusResponse
import org.openapitools.client.models.SirqulResponse

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

open class AssignmentApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://dev.sirqul.com/api/3.18")
        }
    }

    /**
     * GET /assignment/assignee/search
     * Search Assignment Assignees
     * Search for avaiable users for creating or updating assignment.
     * @param accountId The account id sending the request
     * @param keyword The keyword to filter the returned results (optional)
     * @return kotlin.collections.List<AccountMiniResponse>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun assigmentAssigneeAccountSearch(accountId: kotlin.Long, keyword: kotlin.String? = null) : kotlin.collections.List<AccountMiniResponse> {
        val localVarResponse = assigmentAssigneeAccountSearchWithHttpInfo(accountId = accountId, keyword = keyword)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<AccountMiniResponse>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /assignment/assignee/search
     * Search Assignment Assignees
     * Search for avaiable users for creating or updating assignment.
     * @param accountId The account id sending the request
     * @param keyword The keyword to filter the returned results (optional)
     * @return ApiResponse<kotlin.collections.List<AccountMiniResponse>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun assigmentAssigneeAccountSearchWithHttpInfo(accountId: kotlin.Long, keyword: kotlin.String?) : ApiResponse<kotlin.collections.List<AccountMiniResponse>?> {
        val localVariableConfig = assigmentAssigneeAccountSearchRequestConfig(accountId = accountId, keyword = keyword)

        return request<Unit, kotlin.collections.List<AccountMiniResponse>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation assigmentAssigneeAccountSearch
     *
     * @param accountId The account id sending the request
     * @param keyword The keyword to filter the returned results (optional)
     * @return RequestConfig
     */
    fun assigmentAssigneeAccountSearchRequestConfig(accountId: kotlin.Long, keyword: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                if (keyword != null) {
                    put("keyword", listOf(keyword.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/assignment/assignee/search",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /assignment/create
     * Create Assignment
     * Create an assignment.
     * @param accountId the user account id
     * @param name the name for the assignment
     * @param assigneeAccountId the account id to assign to
     * @param description the desciprtion for the assignment (optional)
     * @param retailerLocationId the retailer location id (optional)
     * @param tags the tags (optional)
     * @param active determines whether the assignment is active or inactive (optional)
     * @return AssignmentResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun assignmentCreate(accountId: kotlin.Long, name: kotlin.String, assigneeAccountId: kotlin.Long, description: kotlin.String? = null, retailerLocationId: kotlin.Long? = null, tags: kotlin.String? = null, active: kotlin.Boolean? = null) : AssignmentResponse {
        val localVarResponse = assignmentCreateWithHttpInfo(accountId = accountId, name = name, assigneeAccountId = assigneeAccountId, description = description, retailerLocationId = retailerLocationId, tags = tags, active = active)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AssignmentResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /assignment/create
     * Create Assignment
     * Create an assignment.
     * @param accountId the user account id
     * @param name the name for the assignment
     * @param assigneeAccountId the account id to assign to
     * @param description the desciprtion for the assignment (optional)
     * @param retailerLocationId the retailer location id (optional)
     * @param tags the tags (optional)
     * @param active determines whether the assignment is active or inactive (optional)
     * @return ApiResponse<AssignmentResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun assignmentCreateWithHttpInfo(accountId: kotlin.Long, name: kotlin.String, assigneeAccountId: kotlin.Long, description: kotlin.String?, retailerLocationId: kotlin.Long?, tags: kotlin.String?, active: kotlin.Boolean?) : ApiResponse<AssignmentResponse?> {
        val localVariableConfig = assignmentCreateRequestConfig(accountId = accountId, name = name, assigneeAccountId = assigneeAccountId, description = description, retailerLocationId = retailerLocationId, tags = tags, active = active)

        return request<Unit, AssignmentResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation assignmentCreate
     *
     * @param accountId the user account id
     * @param name the name for the assignment
     * @param assigneeAccountId the account id to assign to
     * @param description the desciprtion for the assignment (optional)
     * @param retailerLocationId the retailer location id (optional)
     * @param tags the tags (optional)
     * @param active determines whether the assignment is active or inactive (optional)
     * @return RequestConfig
     */
    fun assignmentCreateRequestConfig(accountId: kotlin.Long, name: kotlin.String, assigneeAccountId: kotlin.Long, description: kotlin.String?, retailerLocationId: kotlin.Long?, tags: kotlin.String?, active: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("name", listOf(name.toString()))
                if (description != null) {
                    put("description", listOf(description.toString()))
                }
                put("assigneeAccountId", listOf(assigneeAccountId.toString()))
                if (retailerLocationId != null) {
                    put("retailerLocationId", listOf(retailerLocationId.toString()))
                }
                if (tags != null) {
                    put("tags", listOf(tags.toString()))
                }
                if (active != null) {
                    put("active", listOf(active.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/assignment/create",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /assignment/delete
     * Delete Assignment
     * Delete an assignment.
     * @param accountId the user account id
     * @param assignmentId the assignment id
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun assignmentDelete(accountId: kotlin.Long, assignmentId: kotlin.Long) : SirqulResponse {
        val localVarResponse = assignmentDeleteWithHttpInfo(accountId = accountId, assignmentId = assignmentId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /assignment/delete
     * Delete Assignment
     * Delete an assignment.
     * @param accountId the user account id
     * @param assignmentId the assignment id
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun assignmentDeleteWithHttpInfo(accountId: kotlin.Long, assignmentId: kotlin.Long) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = assignmentDeleteRequestConfig(accountId = accountId, assignmentId = assignmentId)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation assignmentDelete
     *
     * @param accountId the user account id
     * @param assignmentId the assignment id
     * @return RequestConfig
     */
    fun assignmentDeleteRequestConfig(accountId: kotlin.Long, assignmentId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("assignmentId", listOf(assignmentId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/assignment/delete",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /assignment/get
     * Get Assignment
     * Get the details of an assignment.
     * @param accountId the user account id
     * @param assignmentId the assignment id
     * @return AssignmentResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun assignmentGet(accountId: kotlin.Long, assignmentId: kotlin.Long) : AssignmentResponse {
        val localVarResponse = assignmentGetWithHttpInfo(accountId = accountId, assignmentId = assignmentId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AssignmentResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /assignment/get
     * Get Assignment
     * Get the details of an assignment.
     * @param accountId the user account id
     * @param assignmentId the assignment id
     * @return ApiResponse<AssignmentResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun assignmentGetWithHttpInfo(accountId: kotlin.Long, assignmentId: kotlin.Long) : ApiResponse<AssignmentResponse?> {
        val localVariableConfig = assignmentGetRequestConfig(accountId = accountId, assignmentId = assignmentId)

        return request<Unit, AssignmentResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation assignmentGet
     *
     * @param accountId the user account id
     * @param assignmentId the assignment id
     * @return RequestConfig
     */
    fun assignmentGetRequestConfig(accountId: kotlin.Long, assignmentId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("assignmentId", listOf(assignmentId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/assignment/get",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter sortField
     */
     enum class SortFieldAssignmentSearch(val value: kotlin.String) {
         @Json(name = "ID") ID("ID"),
         @Json(name = "CREATED") CREATED("CREATED"),
         @Json(name = "UPDATED") UPDATED("UPDATED"),
         @Json(name = "DELETED") DELETED("DELETED"),
         @Json(name = "SEARCH_TAGS") SEARCH_TAGS("SEARCH_TAGS"),
         @Json(name = "ACTIVE") ACTIVE("ACTIVE"),
         @Json(name = "ASSIGNEE_ID") ASSIGNEE_ID("ASSIGNEE_ID"),
         @Json(name = "CREATOR_ID") CREATOR_ID("CREATOR_ID"),
         @Json(name = "LOCATION_ID") LOCATION_ID("LOCATION_ID"),
         @Json(name = "LOCATION_NAME") LOCATION_NAME("LOCATION_NAME"),
         @Json(name = "CURRENT_STATUS") CURRENT_STATUS("CURRENT_STATUS"),
         @Json(name = "CURRENT_STATUS_TYPE") CURRENT_STATUS_TYPE("CURRENT_STATUS_TYPE"),
         @Json(name = "STATUSES") STATUSES("STATUSES");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter currentStatusType
     */
     enum class CurrentStatusTypeAssignmentSearch(val value: kotlin.String) {
         @Json(name = "NEW") NEW("NEW"),
         @Json(name = "IN_PROGRESS") IN_PROGRESS("IN_PROGRESS"),
         @Json(name = "SUBSCRIBED") SUBSCRIBED("SUBSCRIBED"),
         @Json(name = "ARCHIVED") ARCHIVED("ARCHIVED");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /assignment/search
     * Search Assignments
     * Search for assignments by the given parameters.
     * @param accountId the account sending the request
     * @param sortField sort by table field
     * @param descending return results in descending order or not
     * @param activeOnly return active results only or not
     * @param start The record to begin the return set on
     * @param limit The number of records to return
     * @param creatorAccountId the creator of the assignment (optional)
     * @param assigneeAccountIds filter results by assignee accounts. If not provided, all assignments that are assigned to accounts that are managed by the requested account will be returned. (optional)
     * @param retailerLocationIds filter results by retailer locations (optional)
     * @param currentStatusType filter results by assignment status (optional)
     * @param keyword filter results by keyword search that matches the assignee, creator, or retailer location name (optional)
     * @return kotlin.collections.List<AssignmentResponse>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun assignmentSearch(accountId: kotlin.Long, sortField: SortFieldAssignmentSearch, descending: kotlin.Boolean, activeOnly: kotlin.Boolean, start: kotlin.Int, limit: kotlin.Int, creatorAccountId: kotlin.Long? = null, assigneeAccountIds: kotlin.String? = null, retailerLocationIds: kotlin.String? = null, currentStatusType: CurrentStatusTypeAssignmentSearch? = null, keyword: kotlin.String? = null) : kotlin.collections.List<AssignmentResponse> {
        val localVarResponse = assignmentSearchWithHttpInfo(accountId = accountId, sortField = sortField, descending = descending, activeOnly = activeOnly, start = start, limit = limit, creatorAccountId = creatorAccountId, assigneeAccountIds = assigneeAccountIds, retailerLocationIds = retailerLocationIds, currentStatusType = currentStatusType, keyword = keyword)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<AssignmentResponse>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /assignment/search
     * Search Assignments
     * Search for assignments by the given parameters.
     * @param accountId the account sending the request
     * @param sortField sort by table field
     * @param descending return results in descending order or not
     * @param activeOnly return active results only or not
     * @param start The record to begin the return set on
     * @param limit The number of records to return
     * @param creatorAccountId the creator of the assignment (optional)
     * @param assigneeAccountIds filter results by assignee accounts. If not provided, all assignments that are assigned to accounts that are managed by the requested account will be returned. (optional)
     * @param retailerLocationIds filter results by retailer locations (optional)
     * @param currentStatusType filter results by assignment status (optional)
     * @param keyword filter results by keyword search that matches the assignee, creator, or retailer location name (optional)
     * @return ApiResponse<kotlin.collections.List<AssignmentResponse>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun assignmentSearchWithHttpInfo(accountId: kotlin.Long, sortField: SortFieldAssignmentSearch, descending: kotlin.Boolean, activeOnly: kotlin.Boolean, start: kotlin.Int, limit: kotlin.Int, creatorAccountId: kotlin.Long?, assigneeAccountIds: kotlin.String?, retailerLocationIds: kotlin.String?, currentStatusType: CurrentStatusTypeAssignmentSearch?, keyword: kotlin.String?) : ApiResponse<kotlin.collections.List<AssignmentResponse>?> {
        val localVariableConfig = assignmentSearchRequestConfig(accountId = accountId, sortField = sortField, descending = descending, activeOnly = activeOnly, start = start, limit = limit, creatorAccountId = creatorAccountId, assigneeAccountIds = assigneeAccountIds, retailerLocationIds = retailerLocationIds, currentStatusType = currentStatusType, keyword = keyword)

        return request<Unit, kotlin.collections.List<AssignmentResponse>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation assignmentSearch
     *
     * @param accountId the account sending the request
     * @param sortField sort by table field
     * @param descending return results in descending order or not
     * @param activeOnly return active results only or not
     * @param start The record to begin the return set on
     * @param limit The number of records to return
     * @param creatorAccountId the creator of the assignment (optional)
     * @param assigneeAccountIds filter results by assignee accounts. If not provided, all assignments that are assigned to accounts that are managed by the requested account will be returned. (optional)
     * @param retailerLocationIds filter results by retailer locations (optional)
     * @param currentStatusType filter results by assignment status (optional)
     * @param keyword filter results by keyword search that matches the assignee, creator, or retailer location name (optional)
     * @return RequestConfig
     */
    fun assignmentSearchRequestConfig(accountId: kotlin.Long, sortField: SortFieldAssignmentSearch, descending: kotlin.Boolean, activeOnly: kotlin.Boolean, start: kotlin.Int, limit: kotlin.Int, creatorAccountId: kotlin.Long?, assigneeAccountIds: kotlin.String?, retailerLocationIds: kotlin.String?, currentStatusType: CurrentStatusTypeAssignmentSearch?, keyword: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                if (creatorAccountId != null) {
                    put("creatorAccountId", listOf(creatorAccountId.toString()))
                }
                if (assigneeAccountIds != null) {
                    put("assigneeAccountIds", listOf(assigneeAccountIds.toString()))
                }
                if (retailerLocationIds != null) {
                    put("retailerLocationIds", listOf(retailerLocationIds.toString()))
                }
                if (currentStatusType != null) {
                    put("currentStatusType", listOf(currentStatusType.value))
                }
                if (keyword != null) {
                    put("keyword", listOf(keyword.toString()))
                }
                put("sortField", listOf(sortField.value))
                put("descending", listOf(descending.toString()))
                put("activeOnly", listOf(activeOnly.toString()))
                put("start", listOf(start.toString()))
                put("limit", listOf(limit.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/assignment/search",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter toDo
     */
     enum class ToDoAssignmentStatusCreate(val value: kotlin.String) {
         @Json(name = "SITE_VISIT") SITE_VISIT("SITE_VISIT"),
         @Json(name = "PHONE") PHONE("PHONE"),
         @Json(name = "RECONTACT") RECONTACT("RECONTACT"),
         @Json(name = "RENEWAL") RENEWAL("RENEWAL"),
         @Json(name = "CREDIT") CREDIT("CREDIT");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter connection
     */
     enum class ConnectionAssignmentStatusCreate(val value: kotlin.String) {
         @Json(name = "INITIAL") INITIAL("INITIAL"),
         @Json(name = "FOLLOW_UP") FOLLOW_UP("FOLLOW_UP"),
         @Json(name = "DECLINED") DECLINED("DECLINED");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter method
     */
     enum class MethodAssignmentStatusCreate(val value: kotlin.String) {
         @Json(name = "PHONE") PHONE("PHONE"),
         @Json(name = "SITE_VISIT") SITE_VISIT("SITE_VISIT"),
         @Json(name = "EMAIL") EMAIL("EMAIL");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter status
     */
     enum class StatusAssignmentStatusCreate(val value: kotlin.String) {
         @Json(name = "ARCHIVED") ARCHIVED("ARCHIVED"),
         @Json(name = "SUBSCRIBED") SUBSCRIBED("SUBSCRIBED"),
         @Json(name = "UNSUBSCRIBED") UNSUBSCRIBED("UNSUBSCRIBED"),
         @Json(name = "CONTACTED") CONTACTED("CONTACTED"),
         @Json(name = "DECLINED") DECLINED("DECLINED"),
         @Json(name = "NOT_CONTACTED") NOT_CONTACTED("NOT_CONTACTED");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter closure
     */
     enum class ClosureAssignmentStatusCreate(val value: kotlin.String) {
         @Json(name = "PHONE") PHONE("PHONE"),
         @Json(name = "SITE_VISIT") SITE_VISIT("SITE_VISIT"),
         @Json(name = "PHONE_SITE") PHONE_SITE("PHONE_SITE"),
         @Json(name = "WEB") WEB("WEB");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * POST /assignment/status/create
     * Create Assignment Status
     * Create an assignment status.
     * @param accountId the user account id
     * @param assignmentId the assignment id
     * @param scheduledNotificationId the scheduled notification id for reminders (optional)
     * @param toDo the type of to do. Possible values include: SITE_VISIT, PHONE, RECONTACT, RENEWAL, CREDIT (optional)
     * @param connection the connection type. Possible values include: INITIAL, FOLLOW_UP, DECLINED (optional)
     * @param method the communication method type. Possible values include: PHONE, SITE_VISIT, EMAIL (optional)
     * @param status the status type. Possible values include: ARCHIVED, SUBSCRIBED, UNSUBSCRIBED, CONTACTED, DECLINED, NOT_CONTACTED (optional)
     * @param closure the closure type. Possible values include: PHONE, SITE_VISIT, PHONE_SITE, WEB (optional)
     * @param message the message from the assignee (optional)
     * @param followUp the date to follow up by (optional)
     * @param active determines whether the assignment status is active or inactive (optional)
     * @return AssignmentStatusResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun assignmentStatusCreate(accountId: kotlin.Long, assignmentId: kotlin.Long, scheduledNotificationId: kotlin.Long? = null, toDo: ToDoAssignmentStatusCreate? = null, connection: ConnectionAssignmentStatusCreate? = null, method: MethodAssignmentStatusCreate? = null, status: StatusAssignmentStatusCreate? = null, closure: ClosureAssignmentStatusCreate? = null, message: kotlin.String? = null, followUp: kotlin.Long? = null, active: kotlin.Boolean? = null) : AssignmentStatusResponse {
        val localVarResponse = assignmentStatusCreateWithHttpInfo(accountId = accountId, assignmentId = assignmentId, scheduledNotificationId = scheduledNotificationId, toDo = toDo, connection = connection, method = method, status = status, closure = closure, message = message, followUp = followUp, active = active)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AssignmentStatusResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /assignment/status/create
     * Create Assignment Status
     * Create an assignment status.
     * @param accountId the user account id
     * @param assignmentId the assignment id
     * @param scheduledNotificationId the scheduled notification id for reminders (optional)
     * @param toDo the type of to do. Possible values include: SITE_VISIT, PHONE, RECONTACT, RENEWAL, CREDIT (optional)
     * @param connection the connection type. Possible values include: INITIAL, FOLLOW_UP, DECLINED (optional)
     * @param method the communication method type. Possible values include: PHONE, SITE_VISIT, EMAIL (optional)
     * @param status the status type. Possible values include: ARCHIVED, SUBSCRIBED, UNSUBSCRIBED, CONTACTED, DECLINED, NOT_CONTACTED (optional)
     * @param closure the closure type. Possible values include: PHONE, SITE_VISIT, PHONE_SITE, WEB (optional)
     * @param message the message from the assignee (optional)
     * @param followUp the date to follow up by (optional)
     * @param active determines whether the assignment status is active or inactive (optional)
     * @return ApiResponse<AssignmentStatusResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun assignmentStatusCreateWithHttpInfo(accountId: kotlin.Long, assignmentId: kotlin.Long, scheduledNotificationId: kotlin.Long?, toDo: ToDoAssignmentStatusCreate?, connection: ConnectionAssignmentStatusCreate?, method: MethodAssignmentStatusCreate?, status: StatusAssignmentStatusCreate?, closure: ClosureAssignmentStatusCreate?, message: kotlin.String?, followUp: kotlin.Long?, active: kotlin.Boolean?) : ApiResponse<AssignmentStatusResponse?> {
        val localVariableConfig = assignmentStatusCreateRequestConfig(accountId = accountId, assignmentId = assignmentId, scheduledNotificationId = scheduledNotificationId, toDo = toDo, connection = connection, method = method, status = status, closure = closure, message = message, followUp = followUp, active = active)

        return request<Unit, AssignmentStatusResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation assignmentStatusCreate
     *
     * @param accountId the user account id
     * @param assignmentId the assignment id
     * @param scheduledNotificationId the scheduled notification id for reminders (optional)
     * @param toDo the type of to do. Possible values include: SITE_VISIT, PHONE, RECONTACT, RENEWAL, CREDIT (optional)
     * @param connection the connection type. Possible values include: INITIAL, FOLLOW_UP, DECLINED (optional)
     * @param method the communication method type. Possible values include: PHONE, SITE_VISIT, EMAIL (optional)
     * @param status the status type. Possible values include: ARCHIVED, SUBSCRIBED, UNSUBSCRIBED, CONTACTED, DECLINED, NOT_CONTACTED (optional)
     * @param closure the closure type. Possible values include: PHONE, SITE_VISIT, PHONE_SITE, WEB (optional)
     * @param message the message from the assignee (optional)
     * @param followUp the date to follow up by (optional)
     * @param active determines whether the assignment status is active or inactive (optional)
     * @return RequestConfig
     */
    fun assignmentStatusCreateRequestConfig(accountId: kotlin.Long, assignmentId: kotlin.Long, scheduledNotificationId: kotlin.Long?, toDo: ToDoAssignmentStatusCreate?, connection: ConnectionAssignmentStatusCreate?, method: MethodAssignmentStatusCreate?, status: StatusAssignmentStatusCreate?, closure: ClosureAssignmentStatusCreate?, message: kotlin.String?, followUp: kotlin.Long?, active: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("assignmentId", listOf(assignmentId.toString()))
                if (scheduledNotificationId != null) {
                    put("scheduledNotificationId", listOf(scheduledNotificationId.toString()))
                }
                if (toDo != null) {
                    put("toDo", listOf(toDo.value))
                }
                if (connection != null) {
                    put("connection", listOf(connection.value))
                }
                if (method != null) {
                    put("method", listOf(method.value))
                }
                if (status != null) {
                    put("status", listOf(status.value))
                }
                if (closure != null) {
                    put("closure", listOf(closure.value))
                }
                if (message != null) {
                    put("message", listOf(message.toString()))
                }
                if (followUp != null) {
                    put("followUp", listOf(followUp.toString()))
                }
                if (active != null) {
                    put("active", listOf(active.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/assignment/status/create",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /assignment/status/delete
     * Deletes Assignment Status
     * Deletes an assignment status.
     * @param accountId the user account id
     * @param assignmentStatusId the assignment status id
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun assignmentStatusDelete(accountId: kotlin.Long, assignmentStatusId: kotlin.Long) : SirqulResponse {
        val localVarResponse = assignmentStatusDeleteWithHttpInfo(accountId = accountId, assignmentStatusId = assignmentStatusId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /assignment/status/delete
     * Deletes Assignment Status
     * Deletes an assignment status.
     * @param accountId the user account id
     * @param assignmentStatusId the assignment status id
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun assignmentStatusDeleteWithHttpInfo(accountId: kotlin.Long, assignmentStatusId: kotlin.Long) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = assignmentStatusDeleteRequestConfig(accountId = accountId, assignmentStatusId = assignmentStatusId)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation assignmentStatusDelete
     *
     * @param accountId the user account id
     * @param assignmentStatusId the assignment status id
     * @return RequestConfig
     */
    fun assignmentStatusDeleteRequestConfig(accountId: kotlin.Long, assignmentStatusId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("assignmentStatusId", listOf(assignmentStatusId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/assignment/status/delete",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /assignment/status/get
     * Get Assignment Status
     * Get an assignment status.
     * @param accountId the user account id
     * @param assignmentStatusId the assignment status id
     * @return AssignmentStatusResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun assignmentStatusGet(accountId: kotlin.Long, assignmentStatusId: kotlin.Long) : AssignmentStatusResponse {
        val localVarResponse = assignmentStatusGetWithHttpInfo(accountId = accountId, assignmentStatusId = assignmentStatusId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AssignmentStatusResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /assignment/status/get
     * Get Assignment Status
     * Get an assignment status.
     * @param accountId the user account id
     * @param assignmentStatusId the assignment status id
     * @return ApiResponse<AssignmentStatusResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun assignmentStatusGetWithHttpInfo(accountId: kotlin.Long, assignmentStatusId: kotlin.Long) : ApiResponse<AssignmentStatusResponse?> {
        val localVariableConfig = assignmentStatusGetRequestConfig(accountId = accountId, assignmentStatusId = assignmentStatusId)

        return request<Unit, AssignmentStatusResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation assignmentStatusGet
     *
     * @param accountId the user account id
     * @param assignmentStatusId the assignment status id
     * @return RequestConfig
     */
    fun assignmentStatusGetRequestConfig(accountId: kotlin.Long, assignmentStatusId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("assignmentStatusId", listOf(assignmentStatusId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/assignment/status/get",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter sortField
     */
     enum class SortFieldAssignmentStatusSearch(val value: kotlin.String) {
         @Json(name = "ID") ID("ID"),
         @Json(name = "CREATED") CREATED("CREATED"),
         @Json(name = "UPDATED") UPDATED("UPDATED"),
         @Json(name = "DELETED") DELETED("DELETED"),
         @Json(name = "SEARCH_TAGS") SEARCH_TAGS("SEARCH_TAGS"),
         @Json(name = "ACTIVE") ACTIVE("ACTIVE"),
         @Json(name = "ASSIGNEE_ID") ASSIGNEE_ID("ASSIGNEE_ID"),
         @Json(name = "CREATOR_ID") CREATOR_ID("CREATOR_ID"),
         @Json(name = "LOCATION_ID") LOCATION_ID("LOCATION_ID"),
         @Json(name = "LOCATION_NAME") LOCATION_NAME("LOCATION_NAME"),
         @Json(name = "CURRENT_STATUS") CURRENT_STATUS("CURRENT_STATUS"),
         @Json(name = "CURRENT_STATUS_TYPE") CURRENT_STATUS_TYPE("CURRENT_STATUS_TYPE"),
         @Json(name = "TODO") TODO("TODO"),
         @Json(name = "CONNECTION") CONNECTION("CONNECTION"),
         @Json(name = "METHOD") METHOD("METHOD"),
         @Json(name = "STATUS") STATUS("STATUS"),
         @Json(name = "CLOSURE") CLOSURE("CLOSURE"),
         @Json(name = "MESSAGE") MESSAGE("MESSAGE"),
         @Json(name = "FOLLOW_UP") FOLLOW_UP("FOLLOW_UP");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter statusType
     */
     enum class StatusTypeAssignmentStatusSearch(val value: kotlin.String) {
         @Json(name = "ARCHIVED") ARCHIVED("ARCHIVED"),
         @Json(name = "SUBSCRIBED") SUBSCRIBED("SUBSCRIBED"),
         @Json(name = "UNSUBSCRIBED") UNSUBSCRIBED("UNSUBSCRIBED"),
         @Json(name = "CONTACTED") CONTACTED("CONTACTED"),
         @Json(name = "DECLINED") DECLINED("DECLINED"),
         @Json(name = "NOT_CONTACTED") NOT_CONTACTED("NOT_CONTACTED");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /assignment/status/search
     * Search Assignment Statuses
     * Search on assignment statuses.
     * @param accountId the user account id
     * @param sortField the field to sort by. Possible values include: ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, CURRENT_STATUS, TODO, CONNECTION, METHOD, STATUS, CLOSURE, MESSAGE, FOLLOW_UP
     * @param descending determines whether the sorted list is in descending or ascending order
     * @param activeOnly determines whether to only return active results
     * @param start the start index for pagination
     * @param limit the limit for pagination
     * @param assignmentId the assignment id (optional)
     * @param creatorAccountId filter results by the account who created the status (optional)
     * @param assigneeAccountId filter results by the assignee account (optional)
     * @param retailerLocationId filter results by by retailer location (optional)
     * @param statusType filter results by the status type (optional)
     * @param keyword filter results by keyword search (optional)
     * @return kotlin.collections.List<AssignmentStatusResponse>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun assignmentStatusSearch(accountId: kotlin.Long, sortField: SortFieldAssignmentStatusSearch, descending: kotlin.Boolean, activeOnly: kotlin.Boolean, start: kotlin.Int, limit: kotlin.Int, assignmentId: kotlin.Long? = null, creatorAccountId: kotlin.Long? = null, assigneeAccountId: kotlin.Long? = null, retailerLocationId: kotlin.Long? = null, statusType: StatusTypeAssignmentStatusSearch? = null, keyword: kotlin.String? = null) : kotlin.collections.List<AssignmentStatusResponse> {
        val localVarResponse = assignmentStatusSearchWithHttpInfo(accountId = accountId, sortField = sortField, descending = descending, activeOnly = activeOnly, start = start, limit = limit, assignmentId = assignmentId, creatorAccountId = creatorAccountId, assigneeAccountId = assigneeAccountId, retailerLocationId = retailerLocationId, statusType = statusType, keyword = keyword)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<AssignmentStatusResponse>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /assignment/status/search
     * Search Assignment Statuses
     * Search on assignment statuses.
     * @param accountId the user account id
     * @param sortField the field to sort by. Possible values include: ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, CURRENT_STATUS, TODO, CONNECTION, METHOD, STATUS, CLOSURE, MESSAGE, FOLLOW_UP
     * @param descending determines whether the sorted list is in descending or ascending order
     * @param activeOnly determines whether to only return active results
     * @param start the start index for pagination
     * @param limit the limit for pagination
     * @param assignmentId the assignment id (optional)
     * @param creatorAccountId filter results by the account who created the status (optional)
     * @param assigneeAccountId filter results by the assignee account (optional)
     * @param retailerLocationId filter results by by retailer location (optional)
     * @param statusType filter results by the status type (optional)
     * @param keyword filter results by keyword search (optional)
     * @return ApiResponse<kotlin.collections.List<AssignmentStatusResponse>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun assignmentStatusSearchWithHttpInfo(accountId: kotlin.Long, sortField: SortFieldAssignmentStatusSearch, descending: kotlin.Boolean, activeOnly: kotlin.Boolean, start: kotlin.Int, limit: kotlin.Int, assignmentId: kotlin.Long?, creatorAccountId: kotlin.Long?, assigneeAccountId: kotlin.Long?, retailerLocationId: kotlin.Long?, statusType: StatusTypeAssignmentStatusSearch?, keyword: kotlin.String?) : ApiResponse<kotlin.collections.List<AssignmentStatusResponse>?> {
        val localVariableConfig = assignmentStatusSearchRequestConfig(accountId = accountId, sortField = sortField, descending = descending, activeOnly = activeOnly, start = start, limit = limit, assignmentId = assignmentId, creatorAccountId = creatorAccountId, assigneeAccountId = assigneeAccountId, retailerLocationId = retailerLocationId, statusType = statusType, keyword = keyword)

        return request<Unit, kotlin.collections.List<AssignmentStatusResponse>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation assignmentStatusSearch
     *
     * @param accountId the user account id
     * @param sortField the field to sort by. Possible values include: ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, CURRENT_STATUS, TODO, CONNECTION, METHOD, STATUS, CLOSURE, MESSAGE, FOLLOW_UP
     * @param descending determines whether the sorted list is in descending or ascending order
     * @param activeOnly determines whether to only return active results
     * @param start the start index for pagination
     * @param limit the limit for pagination
     * @param assignmentId the assignment id (optional)
     * @param creatorAccountId filter results by the account who created the status (optional)
     * @param assigneeAccountId filter results by the assignee account (optional)
     * @param retailerLocationId filter results by by retailer location (optional)
     * @param statusType filter results by the status type (optional)
     * @param keyword filter results by keyword search (optional)
     * @return RequestConfig
     */
    fun assignmentStatusSearchRequestConfig(accountId: kotlin.Long, sortField: SortFieldAssignmentStatusSearch, descending: kotlin.Boolean, activeOnly: kotlin.Boolean, start: kotlin.Int, limit: kotlin.Int, assignmentId: kotlin.Long?, creatorAccountId: kotlin.Long?, assigneeAccountId: kotlin.Long?, retailerLocationId: kotlin.Long?, statusType: StatusTypeAssignmentStatusSearch?, keyword: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                if (assignmentId != null) {
                    put("assignmentId", listOf(assignmentId.toString()))
                }
                if (creatorAccountId != null) {
                    put("creatorAccountId", listOf(creatorAccountId.toString()))
                }
                if (assigneeAccountId != null) {
                    put("assigneeAccountId", listOf(assigneeAccountId.toString()))
                }
                if (retailerLocationId != null) {
                    put("retailerLocationId", listOf(retailerLocationId.toString()))
                }
                if (statusType != null) {
                    put("statusType", listOf(statusType.value))
                }
                if (keyword != null) {
                    put("keyword", listOf(keyword.toString()))
                }
                put("sortField", listOf(sortField.value))
                put("descending", listOf(descending.toString()))
                put("activeOnly", listOf(activeOnly.toString()))
                put("start", listOf(start.toString()))
                put("limit", listOf(limit.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/assignment/status/search",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter toDo
     */
     enum class ToDoAssignmentStatusUpdate(val value: kotlin.String) {
         @Json(name = "SITE_VISIT") SITE_VISIT("SITE_VISIT"),
         @Json(name = "PHONE") PHONE("PHONE"),
         @Json(name = "RECONTACT") RECONTACT("RECONTACT"),
         @Json(name = "RENEWAL") RENEWAL("RENEWAL"),
         @Json(name = "CREDIT") CREDIT("CREDIT");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter connection
     */
     enum class ConnectionAssignmentStatusUpdate(val value: kotlin.String) {
         @Json(name = "INITIAL") INITIAL("INITIAL"),
         @Json(name = "FOLLOW_UP") FOLLOW_UP("FOLLOW_UP"),
         @Json(name = "DECLINED") DECLINED("DECLINED");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter method
     */
     enum class MethodAssignmentStatusUpdate(val value: kotlin.String) {
         @Json(name = "PHONE") PHONE("PHONE"),
         @Json(name = "SITE_VISIT") SITE_VISIT("SITE_VISIT"),
         @Json(name = "EMAIL") EMAIL("EMAIL");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter status
     */
     enum class StatusAssignmentStatusUpdate(val value: kotlin.String) {
         @Json(name = "ARCHIVED") ARCHIVED("ARCHIVED"),
         @Json(name = "SUBSCRIBED") SUBSCRIBED("SUBSCRIBED"),
         @Json(name = "UNSUBSCRIBED") UNSUBSCRIBED("UNSUBSCRIBED"),
         @Json(name = "CONTACTED") CONTACTED("CONTACTED"),
         @Json(name = "DECLINED") DECLINED("DECLINED"),
         @Json(name = "NOT_CONTACTED") NOT_CONTACTED("NOT_CONTACTED");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter closure
     */
     enum class ClosureAssignmentStatusUpdate(val value: kotlin.String) {
         @Json(name = "PHONE") PHONE("PHONE"),
         @Json(name = "SITE_VISIT") SITE_VISIT("SITE_VISIT"),
         @Json(name = "PHONE_SITE") PHONE_SITE("PHONE_SITE"),
         @Json(name = "WEB") WEB("WEB");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * POST /assignment/status/update
     * Update Assignment Status
     * Updates an assignment status.
     * @param accountId the user account id
     * @param assignmentStatusId the assignment status id
     * @param scheduledNotificationId the scheduled notification id for reminders (optional)
     * @param toDo the type of to do. Possible values include: SITE_VISIT, PHONE, RECONTACT, RENEWAL, CREDIT (optional)
     * @param connection the connection type. Possible values include: INITIAL, FOLLOW_UP, DECLINED (optional)
     * @param method the communication method type. Possible values include: PHONE, SITE_VISIT, EMAIL (optional)
     * @param status the status type. Possible values include: ARCHIVED, SUBSCRIBED, UNSUBSCRIBED, CONTACTED, DECLINED, NOT_CONTACTED (optional)
     * @param closure the closure type. Possible values include: PHONE, SITE_VISIT, PHONE_SITE, WEB (optional)
     * @param message the message from the assignee (optional)
     * @param followUp the date to follow up by (optional)
     * @param active determines whether the assignment status is active or inactive (optional)
     * @return AssignmentStatusResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun assignmentStatusUpdate(accountId: kotlin.Long, assignmentStatusId: kotlin.Long, scheduledNotificationId: kotlin.Long? = null, toDo: ToDoAssignmentStatusUpdate? = null, connection: ConnectionAssignmentStatusUpdate? = null, method: MethodAssignmentStatusUpdate? = null, status: StatusAssignmentStatusUpdate? = null, closure: ClosureAssignmentStatusUpdate? = null, message: kotlin.String? = null, followUp: kotlin.Long? = null, active: kotlin.Boolean? = null) : AssignmentStatusResponse {
        val localVarResponse = assignmentStatusUpdateWithHttpInfo(accountId = accountId, assignmentStatusId = assignmentStatusId, scheduledNotificationId = scheduledNotificationId, toDo = toDo, connection = connection, method = method, status = status, closure = closure, message = message, followUp = followUp, active = active)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AssignmentStatusResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /assignment/status/update
     * Update Assignment Status
     * Updates an assignment status.
     * @param accountId the user account id
     * @param assignmentStatusId the assignment status id
     * @param scheduledNotificationId the scheduled notification id for reminders (optional)
     * @param toDo the type of to do. Possible values include: SITE_VISIT, PHONE, RECONTACT, RENEWAL, CREDIT (optional)
     * @param connection the connection type. Possible values include: INITIAL, FOLLOW_UP, DECLINED (optional)
     * @param method the communication method type. Possible values include: PHONE, SITE_VISIT, EMAIL (optional)
     * @param status the status type. Possible values include: ARCHIVED, SUBSCRIBED, UNSUBSCRIBED, CONTACTED, DECLINED, NOT_CONTACTED (optional)
     * @param closure the closure type. Possible values include: PHONE, SITE_VISIT, PHONE_SITE, WEB (optional)
     * @param message the message from the assignee (optional)
     * @param followUp the date to follow up by (optional)
     * @param active determines whether the assignment status is active or inactive (optional)
     * @return ApiResponse<AssignmentStatusResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun assignmentStatusUpdateWithHttpInfo(accountId: kotlin.Long, assignmentStatusId: kotlin.Long, scheduledNotificationId: kotlin.Long?, toDo: ToDoAssignmentStatusUpdate?, connection: ConnectionAssignmentStatusUpdate?, method: MethodAssignmentStatusUpdate?, status: StatusAssignmentStatusUpdate?, closure: ClosureAssignmentStatusUpdate?, message: kotlin.String?, followUp: kotlin.Long?, active: kotlin.Boolean?) : ApiResponse<AssignmentStatusResponse?> {
        val localVariableConfig = assignmentStatusUpdateRequestConfig(accountId = accountId, assignmentStatusId = assignmentStatusId, scheduledNotificationId = scheduledNotificationId, toDo = toDo, connection = connection, method = method, status = status, closure = closure, message = message, followUp = followUp, active = active)

        return request<Unit, AssignmentStatusResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation assignmentStatusUpdate
     *
     * @param accountId the user account id
     * @param assignmentStatusId the assignment status id
     * @param scheduledNotificationId the scheduled notification id for reminders (optional)
     * @param toDo the type of to do. Possible values include: SITE_VISIT, PHONE, RECONTACT, RENEWAL, CREDIT (optional)
     * @param connection the connection type. Possible values include: INITIAL, FOLLOW_UP, DECLINED (optional)
     * @param method the communication method type. Possible values include: PHONE, SITE_VISIT, EMAIL (optional)
     * @param status the status type. Possible values include: ARCHIVED, SUBSCRIBED, UNSUBSCRIBED, CONTACTED, DECLINED, NOT_CONTACTED (optional)
     * @param closure the closure type. Possible values include: PHONE, SITE_VISIT, PHONE_SITE, WEB (optional)
     * @param message the message from the assignee (optional)
     * @param followUp the date to follow up by (optional)
     * @param active determines whether the assignment status is active or inactive (optional)
     * @return RequestConfig
     */
    fun assignmentStatusUpdateRequestConfig(accountId: kotlin.Long, assignmentStatusId: kotlin.Long, scheduledNotificationId: kotlin.Long?, toDo: ToDoAssignmentStatusUpdate?, connection: ConnectionAssignmentStatusUpdate?, method: MethodAssignmentStatusUpdate?, status: StatusAssignmentStatusUpdate?, closure: ClosureAssignmentStatusUpdate?, message: kotlin.String?, followUp: kotlin.Long?, active: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("assignmentStatusId", listOf(assignmentStatusId.toString()))
                if (scheduledNotificationId != null) {
                    put("scheduledNotificationId", listOf(scheduledNotificationId.toString()))
                }
                if (toDo != null) {
                    put("toDo", listOf(toDo.value))
                }
                if (connection != null) {
                    put("connection", listOf(connection.value))
                }
                if (method != null) {
                    put("method", listOf(method.value))
                }
                if (status != null) {
                    put("status", listOf(status.value))
                }
                if (closure != null) {
                    put("closure", listOf(closure.value))
                }
                if (message != null) {
                    put("message", listOf(message.toString()))
                }
                if (followUp != null) {
                    put("followUp", listOf(followUp.toString()))
                }
                if (active != null) {
                    put("active", listOf(active.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/assignment/status/update",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /assignment/update
     * Update Assignment
     * Updates an assignment.
     * @param accountId the user account id
     * @param assignmentId the assignment id
     * @param name the name of the assignment (optional)
     * @param description the description of the assignment (optional)
     * @param assigneeAccountId the account id to assign to (optional)
     * @param retailerLocationId the retailer location id (optional)
     * @param tags the tags (optional)
     * @param active determines whether the assignment is active or inactive (optional)
     * @return AssignmentResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun assignmentUpdate(accountId: kotlin.Long, assignmentId: kotlin.Long, name: kotlin.String? = null, description: kotlin.String? = null, assigneeAccountId: kotlin.Long? = null, retailerLocationId: kotlin.Long? = null, tags: kotlin.String? = null, active: kotlin.Boolean? = null) : AssignmentResponse {
        val localVarResponse = assignmentUpdateWithHttpInfo(accountId = accountId, assignmentId = assignmentId, name = name, description = description, assigneeAccountId = assigneeAccountId, retailerLocationId = retailerLocationId, tags = tags, active = active)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AssignmentResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /assignment/update
     * Update Assignment
     * Updates an assignment.
     * @param accountId the user account id
     * @param assignmentId the assignment id
     * @param name the name of the assignment (optional)
     * @param description the description of the assignment (optional)
     * @param assigneeAccountId the account id to assign to (optional)
     * @param retailerLocationId the retailer location id (optional)
     * @param tags the tags (optional)
     * @param active determines whether the assignment is active or inactive (optional)
     * @return ApiResponse<AssignmentResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun assignmentUpdateWithHttpInfo(accountId: kotlin.Long, assignmentId: kotlin.Long, name: kotlin.String?, description: kotlin.String?, assigneeAccountId: kotlin.Long?, retailerLocationId: kotlin.Long?, tags: kotlin.String?, active: kotlin.Boolean?) : ApiResponse<AssignmentResponse?> {
        val localVariableConfig = assignmentUpdateRequestConfig(accountId = accountId, assignmentId = assignmentId, name = name, description = description, assigneeAccountId = assigneeAccountId, retailerLocationId = retailerLocationId, tags = tags, active = active)

        return request<Unit, AssignmentResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation assignmentUpdate
     *
     * @param accountId the user account id
     * @param assignmentId the assignment id
     * @param name the name of the assignment (optional)
     * @param description the description of the assignment (optional)
     * @param assigneeAccountId the account id to assign to (optional)
     * @param retailerLocationId the retailer location id (optional)
     * @param tags the tags (optional)
     * @param active determines whether the assignment is active or inactive (optional)
     * @return RequestConfig
     */
    fun assignmentUpdateRequestConfig(accountId: kotlin.Long, assignmentId: kotlin.Long, name: kotlin.String?, description: kotlin.String?, assigneeAccountId: kotlin.Long?, retailerLocationId: kotlin.Long?, tags: kotlin.String?, active: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("assignmentId", listOf(assignmentId.toString()))
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (description != null) {
                    put("description", listOf(description.toString()))
                }
                if (assigneeAccountId != null) {
                    put("assigneeAccountId", listOf(assigneeAccountId.toString()))
                }
                if (retailerLocationId != null) {
                    put("retailerLocationId", listOf(retailerLocationId.toString()))
                }
                if (tags != null) {
                    put("tags", listOf(tags.toString()))
                }
                if (active != null) {
                    put("active", listOf(active.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/assignment/update",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
