/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import org.openapitools.client.models.CountResponse
import org.openapitools.client.models.ProfileResponse
import org.openapitools.client.models.SirqulResponse
import org.openapitools.client.models.TicketListResponse
import org.openapitools.client.models.TicketOfferResponse

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

open class TicketApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://dev.sirqul.com/api/3.18")
        }
    }

    /**
     * GET /ticket/count
     * Get Ticket Count
     * Gets the ticket count.
     * @param deviceId the id of the device that owns the tickets (optional)
     * @param accountId the id of the account that owns the tickets (optional)
     * @param gameType this is deprecated. (optional)
     * @param appKey the applicationkey (optional)
     * @param ticketType the type of ticket (optional)
     * @return CountResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getTicketCount(deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, gameType: kotlin.String? = null, appKey: kotlin.String? = null, ticketType: kotlin.String? = null) : CountResponse {
        val localVarResponse = getTicketCountWithHttpInfo(deviceId = deviceId, accountId = accountId, gameType = gameType, appKey = appKey, ticketType = ticketType)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CountResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /ticket/count
     * Get Ticket Count
     * Gets the ticket count.
     * @param deviceId the id of the device that owns the tickets (optional)
     * @param accountId the id of the account that owns the tickets (optional)
     * @param gameType this is deprecated. (optional)
     * @param appKey the applicationkey (optional)
     * @param ticketType the type of ticket (optional)
     * @return ApiResponse<CountResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getTicketCountWithHttpInfo(deviceId: kotlin.String?, accountId: kotlin.Long?, gameType: kotlin.String?, appKey: kotlin.String?, ticketType: kotlin.String?) : ApiResponse<CountResponse?> {
        val localVariableConfig = getTicketCountRequestConfig(deviceId = deviceId, accountId = accountId, gameType = gameType, appKey = appKey, ticketType = ticketType)

        return request<Unit, CountResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getTicketCount
     *
     * @param deviceId the id of the device that owns the tickets (optional)
     * @param accountId the id of the account that owns the tickets (optional)
     * @param gameType this is deprecated. (optional)
     * @param appKey the applicationkey (optional)
     * @param ticketType the type of ticket (optional)
     * @return RequestConfig
     */
    fun getTicketCountRequestConfig(deviceId: kotlin.String?, accountId: kotlin.Long?, gameType: kotlin.String?, appKey: kotlin.String?, ticketType: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (gameType != null) {
                    put("gameType", listOf(gameType.toString()))
                }
                if (appKey != null) {
                    put("appKey", listOf(appKey.toString()))
                }
                if (ticketType != null) {
                    put("ticketType", listOf(ticketType.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/ticket/count",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /ticket/getList
     * Get Ticket List
     * Gets the list of tickets.
     * @param deviceId the id of the device that owns the tickets (optional)
     * @param accountId the id of the account that owns the tickets (optional)
     * @param ticketObjectType comma separated list of TicketObjectType (optional)
     * @param actionType comma separated list of TicketActionType (optional)
     * @param ticketIds the ids of the tickets to get (optional)
     * @param objectIds the ids of the objects to get (optional)
     * @param receiptTokens  (optional)
     * @param gameType  (optional)
     * @param appKey the application key (optional)
     * @return TicketListResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getTicketList(deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, ticketObjectType: kotlin.String? = null, actionType: kotlin.String? = null, ticketIds: kotlin.String? = null, objectIds: kotlin.String? = null, receiptTokens: kotlin.String? = null, gameType: kotlin.String? = null, appKey: kotlin.String? = null) : TicketListResponse {
        val localVarResponse = getTicketListWithHttpInfo(deviceId = deviceId, accountId = accountId, ticketObjectType = ticketObjectType, actionType = actionType, ticketIds = ticketIds, objectIds = objectIds, receiptTokens = receiptTokens, gameType = gameType, appKey = appKey)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TicketListResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /ticket/getList
     * Get Ticket List
     * Gets the list of tickets.
     * @param deviceId the id of the device that owns the tickets (optional)
     * @param accountId the id of the account that owns the tickets (optional)
     * @param ticketObjectType comma separated list of TicketObjectType (optional)
     * @param actionType comma separated list of TicketActionType (optional)
     * @param ticketIds the ids of the tickets to get (optional)
     * @param objectIds the ids of the objects to get (optional)
     * @param receiptTokens  (optional)
     * @param gameType  (optional)
     * @param appKey the application key (optional)
     * @return ApiResponse<TicketListResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getTicketListWithHttpInfo(deviceId: kotlin.String?, accountId: kotlin.Long?, ticketObjectType: kotlin.String?, actionType: kotlin.String?, ticketIds: kotlin.String?, objectIds: kotlin.String?, receiptTokens: kotlin.String?, gameType: kotlin.String?, appKey: kotlin.String?) : ApiResponse<TicketListResponse?> {
        val localVariableConfig = getTicketListRequestConfig(deviceId = deviceId, accountId = accountId, ticketObjectType = ticketObjectType, actionType = actionType, ticketIds = ticketIds, objectIds = objectIds, receiptTokens = receiptTokens, gameType = gameType, appKey = appKey)

        return request<Unit, TicketListResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getTicketList
     *
     * @param deviceId the id of the device that owns the tickets (optional)
     * @param accountId the id of the account that owns the tickets (optional)
     * @param ticketObjectType comma separated list of TicketObjectType (optional)
     * @param actionType comma separated list of TicketActionType (optional)
     * @param ticketIds the ids of the tickets to get (optional)
     * @param objectIds the ids of the objects to get (optional)
     * @param receiptTokens  (optional)
     * @param gameType  (optional)
     * @param appKey the application key (optional)
     * @return RequestConfig
     */
    fun getTicketListRequestConfig(deviceId: kotlin.String?, accountId: kotlin.Long?, ticketObjectType: kotlin.String?, actionType: kotlin.String?, ticketIds: kotlin.String?, objectIds: kotlin.String?, receiptTokens: kotlin.String?, gameType: kotlin.String?, appKey: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (ticketObjectType != null) {
                    put("ticketObjectType", listOf(ticketObjectType.toString()))
                }
                if (actionType != null) {
                    put("actionType", listOf(actionType.toString()))
                }
                if (ticketIds != null) {
                    put("ticketIds", listOf(ticketIds.toString()))
                }
                if (objectIds != null) {
                    put("objectIds", listOf(objectIds.toString()))
                }
                if (receiptTokens != null) {
                    put("receiptTokens", listOf(receiptTokens.toString()))
                }
                if (gameType != null) {
                    put("gameType", listOf(gameType.toString()))
                }
                if (appKey != null) {
                    put("appKey", listOf(appKey.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/ticket/getList",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /purchase/gift
     * Gift Tickets
     * Gift tickets to another user.
     * @param receiverAccountId the id of the account receiving the tickets
     * @param ticketId the id of the tickets
     * @param deviceId the id of the device (optional)
     * @param accountId the id of the gift owner (optional)
     * @param assetId the id of the asset (optional)
     * @param customMessage a message that can be written to go along with the gift (optional)
     * @param gameType the type of game associated with the tickets (optional)
     * @param appKey the application key (optional)
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun giftPurchase(receiverAccountId: kotlin.Long, ticketId: kotlin.Long, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, assetId: kotlin.Long? = null, customMessage: kotlin.String? = null, gameType: kotlin.String? = null, appKey: kotlin.String? = null) : SirqulResponse {
        val localVarResponse = giftPurchaseWithHttpInfo(receiverAccountId = receiverAccountId, ticketId = ticketId, deviceId = deviceId, accountId = accountId, assetId = assetId, customMessage = customMessage, gameType = gameType, appKey = appKey)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /purchase/gift
     * Gift Tickets
     * Gift tickets to another user.
     * @param receiverAccountId the id of the account receiving the tickets
     * @param ticketId the id of the tickets
     * @param deviceId the id of the device (optional)
     * @param accountId the id of the gift owner (optional)
     * @param assetId the id of the asset (optional)
     * @param customMessage a message that can be written to go along with the gift (optional)
     * @param gameType the type of game associated with the tickets (optional)
     * @param appKey the application key (optional)
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun giftPurchaseWithHttpInfo(receiverAccountId: kotlin.Long, ticketId: kotlin.Long, deviceId: kotlin.String?, accountId: kotlin.Long?, assetId: kotlin.Long?, customMessage: kotlin.String?, gameType: kotlin.String?, appKey: kotlin.String?) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = giftPurchaseRequestConfig(receiverAccountId = receiverAccountId, ticketId = ticketId, deviceId = deviceId, accountId = accountId, assetId = assetId, customMessage = customMessage, gameType = gameType, appKey = appKey)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation giftPurchase
     *
     * @param receiverAccountId the id of the account receiving the tickets
     * @param ticketId the id of the tickets
     * @param deviceId the id of the device (optional)
     * @param accountId the id of the gift owner (optional)
     * @param assetId the id of the asset (optional)
     * @param customMessage a message that can be written to go along with the gift (optional)
     * @param gameType the type of game associated with the tickets (optional)
     * @param appKey the application key (optional)
     * @return RequestConfig
     */
    fun giftPurchaseRequestConfig(receiverAccountId: kotlin.Long, ticketId: kotlin.Long, deviceId: kotlin.String?, accountId: kotlin.Long?, assetId: kotlin.Long?, customMessage: kotlin.String?, gameType: kotlin.String?, appKey: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                put("receiverAccountId", listOf(receiverAccountId.toString()))
                put("ticketId", listOf(ticketId.toString()))
                if (assetId != null) {
                    put("assetId", listOf(assetId.toString()))
                }
                if (customMessage != null) {
                    put("customMessage", listOf(customMessage.toString()))
                }
                if (gameType != null) {
                    put("gameType", listOf(gameType.toString()))
                }
                if (appKey != null) {
                    put("appKey", listOf(appKey.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/purchase/gift",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /ticket/save
     * Save Ticket
     * Allow user to acquire a purchase item and generate a ticket record. Used to redeem tickets or add tickets to the system.
     * @param actionType the action being performed, values: COMPLETED, // ADD TICKETS FOR COMPLETING A MISSION, CHALLENGE, GAME, PACK, LEVEL, LEVEL OBJECT REDEEMED, // REMOVE TICKETS FOR BUYING PACKS, HINTS, AND PEN TOOLS OPTIONS, ETC USERS_PLAYED, // ADD TICKETS FOR LEVELS PLAYED BY OTHER USERS TOURNAMENT_OWNER, // ADD TICKETS FOR TOURNAMENTS BY OTHER USERS PURCHASED, // ADD TICKET VIA IN APP PURCHASING SUMATION, // SUMATION OF TICKETS EARNED FROM CHILDREN GIFTED, // TRANSFERING OF PURCHASE ITEMS TO OTHER PEOPLE REFUNDED // FOR REFUNDING TICKETS BACK TO THE USER
     * @param ticketObjectType the type of object being purchased, values: GAME_OBJECT, GAME_LEVEL, PACK, GAME, MISSION, PROFILE, APPLICATION, TICKETS, ASSET, CUSTOM
     * @param returnNulls whether to return nulls or not (optional)
     * @param deviceId the device id that owns the tickets (optional)
     * @param accountId the account id that owns the tickets (optional)
     * @param gameType This parameter is deprecated. deprecated, use the appKey (optional)
     * @param appKey the application key (optional)
     * @param objectId the ID of the item being purchased (optional)
     * @param purchaseCode a unique string identifier defined by the application owner or Executive (optional)
     * @param receiptToken a unique transaction identifier from the purchase provider (i.e. the transaction ID from iTunes, Google Play, etc) (optional)
     * @param receiptData the receipt/transaction data for validating a purchase via iTunes/Gooogle/etc. This should be in string format. (optional)
     * @param count the count of tickets (optional)
     * @param ticketType the ticket type (optional)
     * @param purchaseProvider the provider for making the purchase {ITUNES, ITUNES_SANDBOX, GOOGLE} (optional)
     * @param purchaseType a comma separated list of purchase types { SIRQUL, // purchasing from the sirqul store using tickets IOS, // purchasing from the itunes store for iPhone, iPod, iPod Touch GOOGLE, // purchasing from the google android store AMAZON, // purchasing from the amazon android store MAC, // purchasing from the itunes store for OSX WP8, // purhasing from the windows phone 8 store FREE } (optional)
     * @param returnProfileResponse returns a ProfileResponse if true, otherwise will return an AppResponse (optional)
     * @param includeProfileResponse if returnProfileResponse is false, will return an AppResponse with profile data if true (optional)
     * @param appVersion the application version (optional)
     * @return ProfileResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun saveTicket(actionType: kotlin.String, ticketObjectType: kotlin.String, returnNulls: kotlin.Boolean? = null, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, gameType: kotlin.String? = null, appKey: kotlin.String? = null, objectId: kotlin.Long? = null, purchaseCode: kotlin.String? = null, receiptToken: kotlin.String? = null, receiptData: kotlin.String? = null, count: kotlin.Long? = null, ticketType: kotlin.String? = null, purchaseProvider: kotlin.String? = null, purchaseType: kotlin.String? = null, returnProfileResponse: kotlin.Boolean? = null, includeProfileResponse: kotlin.Boolean? = null, appVersion: kotlin.String? = null) : ProfileResponse {
        val localVarResponse = saveTicketWithHttpInfo(actionType = actionType, ticketObjectType = ticketObjectType, returnNulls = returnNulls, deviceId = deviceId, accountId = accountId, gameType = gameType, appKey = appKey, objectId = objectId, purchaseCode = purchaseCode, receiptToken = receiptToken, receiptData = receiptData, count = count, ticketType = ticketType, purchaseProvider = purchaseProvider, purchaseType = purchaseType, returnProfileResponse = returnProfileResponse, includeProfileResponse = includeProfileResponse, appVersion = appVersion)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ProfileResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /ticket/save
     * Save Ticket
     * Allow user to acquire a purchase item and generate a ticket record. Used to redeem tickets or add tickets to the system.
     * @param actionType the action being performed, values: COMPLETED, // ADD TICKETS FOR COMPLETING A MISSION, CHALLENGE, GAME, PACK, LEVEL, LEVEL OBJECT REDEEMED, // REMOVE TICKETS FOR BUYING PACKS, HINTS, AND PEN TOOLS OPTIONS, ETC USERS_PLAYED, // ADD TICKETS FOR LEVELS PLAYED BY OTHER USERS TOURNAMENT_OWNER, // ADD TICKETS FOR TOURNAMENTS BY OTHER USERS PURCHASED, // ADD TICKET VIA IN APP PURCHASING SUMATION, // SUMATION OF TICKETS EARNED FROM CHILDREN GIFTED, // TRANSFERING OF PURCHASE ITEMS TO OTHER PEOPLE REFUNDED // FOR REFUNDING TICKETS BACK TO THE USER
     * @param ticketObjectType the type of object being purchased, values: GAME_OBJECT, GAME_LEVEL, PACK, GAME, MISSION, PROFILE, APPLICATION, TICKETS, ASSET, CUSTOM
     * @param returnNulls whether to return nulls or not (optional)
     * @param deviceId the device id that owns the tickets (optional)
     * @param accountId the account id that owns the tickets (optional)
     * @param gameType This parameter is deprecated. deprecated, use the appKey (optional)
     * @param appKey the application key (optional)
     * @param objectId the ID of the item being purchased (optional)
     * @param purchaseCode a unique string identifier defined by the application owner or Executive (optional)
     * @param receiptToken a unique transaction identifier from the purchase provider (i.e. the transaction ID from iTunes, Google Play, etc) (optional)
     * @param receiptData the receipt/transaction data for validating a purchase via iTunes/Gooogle/etc. This should be in string format. (optional)
     * @param count the count of tickets (optional)
     * @param ticketType the ticket type (optional)
     * @param purchaseProvider the provider for making the purchase {ITUNES, ITUNES_SANDBOX, GOOGLE} (optional)
     * @param purchaseType a comma separated list of purchase types { SIRQUL, // purchasing from the sirqul store using tickets IOS, // purchasing from the itunes store for iPhone, iPod, iPod Touch GOOGLE, // purchasing from the google android store AMAZON, // purchasing from the amazon android store MAC, // purchasing from the itunes store for OSX WP8, // purhasing from the windows phone 8 store FREE } (optional)
     * @param returnProfileResponse returns a ProfileResponse if true, otherwise will return an AppResponse (optional)
     * @param includeProfileResponse if returnProfileResponse is false, will return an AppResponse with profile data if true (optional)
     * @param appVersion the application version (optional)
     * @return ApiResponse<ProfileResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun saveTicketWithHttpInfo(actionType: kotlin.String, ticketObjectType: kotlin.String, returnNulls: kotlin.Boolean?, deviceId: kotlin.String?, accountId: kotlin.Long?, gameType: kotlin.String?, appKey: kotlin.String?, objectId: kotlin.Long?, purchaseCode: kotlin.String?, receiptToken: kotlin.String?, receiptData: kotlin.String?, count: kotlin.Long?, ticketType: kotlin.String?, purchaseProvider: kotlin.String?, purchaseType: kotlin.String?, returnProfileResponse: kotlin.Boolean?, includeProfileResponse: kotlin.Boolean?, appVersion: kotlin.String?) : ApiResponse<ProfileResponse?> {
        val localVariableConfig = saveTicketRequestConfig(actionType = actionType, ticketObjectType = ticketObjectType, returnNulls = returnNulls, deviceId = deviceId, accountId = accountId, gameType = gameType, appKey = appKey, objectId = objectId, purchaseCode = purchaseCode, receiptToken = receiptToken, receiptData = receiptData, count = count, ticketType = ticketType, purchaseProvider = purchaseProvider, purchaseType = purchaseType, returnProfileResponse = returnProfileResponse, includeProfileResponse = includeProfileResponse, appVersion = appVersion)

        return request<Unit, ProfileResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation saveTicket
     *
     * @param actionType the action being performed, values: COMPLETED, // ADD TICKETS FOR COMPLETING A MISSION, CHALLENGE, GAME, PACK, LEVEL, LEVEL OBJECT REDEEMED, // REMOVE TICKETS FOR BUYING PACKS, HINTS, AND PEN TOOLS OPTIONS, ETC USERS_PLAYED, // ADD TICKETS FOR LEVELS PLAYED BY OTHER USERS TOURNAMENT_OWNER, // ADD TICKETS FOR TOURNAMENTS BY OTHER USERS PURCHASED, // ADD TICKET VIA IN APP PURCHASING SUMATION, // SUMATION OF TICKETS EARNED FROM CHILDREN GIFTED, // TRANSFERING OF PURCHASE ITEMS TO OTHER PEOPLE REFUNDED // FOR REFUNDING TICKETS BACK TO THE USER
     * @param ticketObjectType the type of object being purchased, values: GAME_OBJECT, GAME_LEVEL, PACK, GAME, MISSION, PROFILE, APPLICATION, TICKETS, ASSET, CUSTOM
     * @param returnNulls whether to return nulls or not (optional)
     * @param deviceId the device id that owns the tickets (optional)
     * @param accountId the account id that owns the tickets (optional)
     * @param gameType This parameter is deprecated. deprecated, use the appKey (optional)
     * @param appKey the application key (optional)
     * @param objectId the ID of the item being purchased (optional)
     * @param purchaseCode a unique string identifier defined by the application owner or Executive (optional)
     * @param receiptToken a unique transaction identifier from the purchase provider (i.e. the transaction ID from iTunes, Google Play, etc) (optional)
     * @param receiptData the receipt/transaction data for validating a purchase via iTunes/Gooogle/etc. This should be in string format. (optional)
     * @param count the count of tickets (optional)
     * @param ticketType the ticket type (optional)
     * @param purchaseProvider the provider for making the purchase {ITUNES, ITUNES_SANDBOX, GOOGLE} (optional)
     * @param purchaseType a comma separated list of purchase types { SIRQUL, // purchasing from the sirqul store using tickets IOS, // purchasing from the itunes store for iPhone, iPod, iPod Touch GOOGLE, // purchasing from the google android store AMAZON, // purchasing from the amazon android store MAC, // purchasing from the itunes store for OSX WP8, // purhasing from the windows phone 8 store FREE } (optional)
     * @param returnProfileResponse returns a ProfileResponse if true, otherwise will return an AppResponse (optional)
     * @param includeProfileResponse if returnProfileResponse is false, will return an AppResponse with profile data if true (optional)
     * @param appVersion the application version (optional)
     * @return RequestConfig
     */
    fun saveTicketRequestConfig(actionType: kotlin.String, ticketObjectType: kotlin.String, returnNulls: kotlin.Boolean?, deviceId: kotlin.String?, accountId: kotlin.Long?, gameType: kotlin.String?, appKey: kotlin.String?, objectId: kotlin.Long?, purchaseCode: kotlin.String?, receiptToken: kotlin.String?, receiptData: kotlin.String?, count: kotlin.Long?, ticketType: kotlin.String?, purchaseProvider: kotlin.String?, purchaseType: kotlin.String?, returnProfileResponse: kotlin.Boolean?, includeProfileResponse: kotlin.Boolean?, appVersion: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (returnNulls != null) {
                    put("returnNulls", listOf(returnNulls.toString()))
                }
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (gameType != null) {
                    put("gameType", listOf(gameType.toString()))
                }
                if (appKey != null) {
                    put("appKey", listOf(appKey.toString()))
                }
                put("actionType", listOf(actionType.toString()))
                put("ticketObjectType", listOf(ticketObjectType.toString()))
                if (objectId != null) {
                    put("objectId", listOf(objectId.toString()))
                }
                if (purchaseCode != null) {
                    put("purchaseCode", listOf(purchaseCode.toString()))
                }
                if (receiptToken != null) {
                    put("receiptToken", listOf(receiptToken.toString()))
                }
                if (receiptData != null) {
                    put("receiptData", listOf(receiptData.toString()))
                }
                if (count != null) {
                    put("count", listOf(count.toString()))
                }
                if (ticketType != null) {
                    put("ticketType", listOf(ticketType.toString()))
                }
                if (purchaseProvider != null) {
                    put("purchaseProvider", listOf(purchaseProvider.toString()))
                }
                if (purchaseType != null) {
                    put("purchaseType", listOf(purchaseType.toString()))
                }
                if (returnProfileResponse != null) {
                    put("returnProfileResponse", listOf(returnProfileResponse.toString()))
                }
                if (includeProfileResponse != null) {
                    put("includeProfileResponse", listOf(includeProfileResponse.toString()))
                }
                if (appVersion != null) {
                    put("appVersion", listOf(appVersion.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/ticket/save",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /ticket/save/fileUpload
     * Save Ticket with Reciept
     * Similar to the Save Ticket endpoint but allows the receiptData to be in binary format. This must be a multi-part post
     * @param actionType the action being performed { COMPLETED, // ADD TICKETS FOR COMPLETING A MISSION, CHALLENGE, GAME, PACK, LEVEL, LEVEL OBJECT REDEEMED, // REMOVE TICKETS FOR BUYING PACKS, HINTS, AND PEN TOOLS OPTIONS, ETC USERS_PLAYED, // ADD TICKETS FOR LEVELS PLAYED BY OTHER USERS TOURNAMENT_OWNER, // ADD TICKETS FOR TOURNAMENTS BY OTHER USERS PURCHASED, // ADD TICKET VIA IN APP PURCHASING SUMATION, // SUMATION OF TICKETS EARNED FROM CHILDREN GIFTED, // TRANSFERING OF PURCHASE ITEMS TO OTHER PEOPLE REFUNDED // FOR REFUNDING TICKETS BACK TO THE USER }
     * @param ticketObjectType the type of object being purchased {GAME_OBJECT, GAME_LEVEL, PACK, GAME, MISSION, PROFILE, APPLICATION, TICKETS, ASSET, CUSTOM}
     * @param receiptData the receipt/transaction data for validating a purchase via iTunes/Gooogle/etc. This should be in binary format.
     * @param returnNulls whether to return nulls or not (optional)
     * @param deviceId the device id (optional)
     * @param accountId the account id (optional)
     * @param gameType This parameter is deprecated. deprecated, use the appKey (optional)
     * @param appKey the application key (optional)
     * @param objectId the ID of the item being purchased (optional)
     * @param purchaseCode a unique string identifier defined by the application owner or Executive (optional)
     * @param receiptToken a unique transaction identifier from the purchase provider (i.e. the transaction ID from iTunes, Google Play, etc) (optional)
     * @param count the count of tickets (optional)
     * @param ticketType the ticket type (optional)
     * @param purchaseProvider the provider for making the purchase {ITUNES, ITUNES_SANDBOX, GOOGLE} (optional)
     * @param purchaseType a comma separated list of purchase types { SIRQUL, // purchasing from the sirqul store using tickets IOS, // purchasing from the itunes store for iPhone, iPod, iPod Touch GOOGLE, // purchasing from the google android store AMAZON, // purchasing from the amazon android store MAC, // purchasing from the itunes store for OSX WP8, // purhasing from the windows phone 8 store FREE } (optional)
     * @param returnProfileResponse returns a ProfileResponse if true, otherwise will return an AppResponse (optional)
     * @param includeProfileResponse if returnProfileResponse is false, will return an AppResponse with profile data if true (optional)
     * @param appVersion the application version (optional)
     * @return ProfileResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun saveTicketViaFileUpload(actionType: kotlin.String, ticketObjectType: kotlin.String, receiptData: java.io.File, returnNulls: kotlin.Boolean? = null, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, gameType: kotlin.String? = null, appKey: kotlin.String? = null, objectId: kotlin.Long? = null, purchaseCode: kotlin.String? = null, receiptToken: kotlin.String? = null, count: kotlin.Long? = null, ticketType: kotlin.String? = null, purchaseProvider: kotlin.String? = null, purchaseType: kotlin.String? = null, returnProfileResponse: kotlin.Boolean? = null, includeProfileResponse: kotlin.Boolean? = null, appVersion: kotlin.String? = null) : ProfileResponse {
        val localVarResponse = saveTicketViaFileUploadWithHttpInfo(actionType = actionType, ticketObjectType = ticketObjectType, receiptData = receiptData, returnNulls = returnNulls, deviceId = deviceId, accountId = accountId, gameType = gameType, appKey = appKey, objectId = objectId, purchaseCode = purchaseCode, receiptToken = receiptToken, count = count, ticketType = ticketType, purchaseProvider = purchaseProvider, purchaseType = purchaseType, returnProfileResponse = returnProfileResponse, includeProfileResponse = includeProfileResponse, appVersion = appVersion)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ProfileResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /ticket/save/fileUpload
     * Save Ticket with Reciept
     * Similar to the Save Ticket endpoint but allows the receiptData to be in binary format. This must be a multi-part post
     * @param actionType the action being performed { COMPLETED, // ADD TICKETS FOR COMPLETING A MISSION, CHALLENGE, GAME, PACK, LEVEL, LEVEL OBJECT REDEEMED, // REMOVE TICKETS FOR BUYING PACKS, HINTS, AND PEN TOOLS OPTIONS, ETC USERS_PLAYED, // ADD TICKETS FOR LEVELS PLAYED BY OTHER USERS TOURNAMENT_OWNER, // ADD TICKETS FOR TOURNAMENTS BY OTHER USERS PURCHASED, // ADD TICKET VIA IN APP PURCHASING SUMATION, // SUMATION OF TICKETS EARNED FROM CHILDREN GIFTED, // TRANSFERING OF PURCHASE ITEMS TO OTHER PEOPLE REFUNDED // FOR REFUNDING TICKETS BACK TO THE USER }
     * @param ticketObjectType the type of object being purchased {GAME_OBJECT, GAME_LEVEL, PACK, GAME, MISSION, PROFILE, APPLICATION, TICKETS, ASSET, CUSTOM}
     * @param receiptData the receipt/transaction data for validating a purchase via iTunes/Gooogle/etc. This should be in binary format.
     * @param returnNulls whether to return nulls or not (optional)
     * @param deviceId the device id (optional)
     * @param accountId the account id (optional)
     * @param gameType This parameter is deprecated. deprecated, use the appKey (optional)
     * @param appKey the application key (optional)
     * @param objectId the ID of the item being purchased (optional)
     * @param purchaseCode a unique string identifier defined by the application owner or Executive (optional)
     * @param receiptToken a unique transaction identifier from the purchase provider (i.e. the transaction ID from iTunes, Google Play, etc) (optional)
     * @param count the count of tickets (optional)
     * @param ticketType the ticket type (optional)
     * @param purchaseProvider the provider for making the purchase {ITUNES, ITUNES_SANDBOX, GOOGLE} (optional)
     * @param purchaseType a comma separated list of purchase types { SIRQUL, // purchasing from the sirqul store using tickets IOS, // purchasing from the itunes store for iPhone, iPod, iPod Touch GOOGLE, // purchasing from the google android store AMAZON, // purchasing from the amazon android store MAC, // purchasing from the itunes store for OSX WP8, // purhasing from the windows phone 8 store FREE } (optional)
     * @param returnProfileResponse returns a ProfileResponse if true, otherwise will return an AppResponse (optional)
     * @param includeProfileResponse if returnProfileResponse is false, will return an AppResponse with profile data if true (optional)
     * @param appVersion the application version (optional)
     * @return ApiResponse<ProfileResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun saveTicketViaFileUploadWithHttpInfo(actionType: kotlin.String, ticketObjectType: kotlin.String, receiptData: java.io.File, returnNulls: kotlin.Boolean?, deviceId: kotlin.String?, accountId: kotlin.Long?, gameType: kotlin.String?, appKey: kotlin.String?, objectId: kotlin.Long?, purchaseCode: kotlin.String?, receiptToken: kotlin.String?, count: kotlin.Long?, ticketType: kotlin.String?, purchaseProvider: kotlin.String?, purchaseType: kotlin.String?, returnProfileResponse: kotlin.Boolean?, includeProfileResponse: kotlin.Boolean?, appVersion: kotlin.String?) : ApiResponse<ProfileResponse?> {
        val localVariableConfig = saveTicketViaFileUploadRequestConfig(actionType = actionType, ticketObjectType = ticketObjectType, receiptData = receiptData, returnNulls = returnNulls, deviceId = deviceId, accountId = accountId, gameType = gameType, appKey = appKey, objectId = objectId, purchaseCode = purchaseCode, receiptToken = receiptToken, count = count, ticketType = ticketType, purchaseProvider = purchaseProvider, purchaseType = purchaseType, returnProfileResponse = returnProfileResponse, includeProfileResponse = includeProfileResponse, appVersion = appVersion)

        return request<Unit, ProfileResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation saveTicketViaFileUpload
     *
     * @param actionType the action being performed { COMPLETED, // ADD TICKETS FOR COMPLETING A MISSION, CHALLENGE, GAME, PACK, LEVEL, LEVEL OBJECT REDEEMED, // REMOVE TICKETS FOR BUYING PACKS, HINTS, AND PEN TOOLS OPTIONS, ETC USERS_PLAYED, // ADD TICKETS FOR LEVELS PLAYED BY OTHER USERS TOURNAMENT_OWNER, // ADD TICKETS FOR TOURNAMENTS BY OTHER USERS PURCHASED, // ADD TICKET VIA IN APP PURCHASING SUMATION, // SUMATION OF TICKETS EARNED FROM CHILDREN GIFTED, // TRANSFERING OF PURCHASE ITEMS TO OTHER PEOPLE REFUNDED // FOR REFUNDING TICKETS BACK TO THE USER }
     * @param ticketObjectType the type of object being purchased {GAME_OBJECT, GAME_LEVEL, PACK, GAME, MISSION, PROFILE, APPLICATION, TICKETS, ASSET, CUSTOM}
     * @param receiptData the receipt/transaction data for validating a purchase via iTunes/Gooogle/etc. This should be in binary format.
     * @param returnNulls whether to return nulls or not (optional)
     * @param deviceId the device id (optional)
     * @param accountId the account id (optional)
     * @param gameType This parameter is deprecated. deprecated, use the appKey (optional)
     * @param appKey the application key (optional)
     * @param objectId the ID of the item being purchased (optional)
     * @param purchaseCode a unique string identifier defined by the application owner or Executive (optional)
     * @param receiptToken a unique transaction identifier from the purchase provider (i.e. the transaction ID from iTunes, Google Play, etc) (optional)
     * @param count the count of tickets (optional)
     * @param ticketType the ticket type (optional)
     * @param purchaseProvider the provider for making the purchase {ITUNES, ITUNES_SANDBOX, GOOGLE} (optional)
     * @param purchaseType a comma separated list of purchase types { SIRQUL, // purchasing from the sirqul store using tickets IOS, // purchasing from the itunes store for iPhone, iPod, iPod Touch GOOGLE, // purchasing from the google android store AMAZON, // purchasing from the amazon android store MAC, // purchasing from the itunes store for OSX WP8, // purhasing from the windows phone 8 store FREE } (optional)
     * @param returnProfileResponse returns a ProfileResponse if true, otherwise will return an AppResponse (optional)
     * @param includeProfileResponse if returnProfileResponse is false, will return an AppResponse with profile data if true (optional)
     * @param appVersion the application version (optional)
     * @return RequestConfig
     */
    fun saveTicketViaFileUploadRequestConfig(actionType: kotlin.String, ticketObjectType: kotlin.String, receiptData: java.io.File, returnNulls: kotlin.Boolean?, deviceId: kotlin.String?, accountId: kotlin.Long?, gameType: kotlin.String?, appKey: kotlin.String?, objectId: kotlin.Long?, purchaseCode: kotlin.String?, receiptToken: kotlin.String?, count: kotlin.Long?, ticketType: kotlin.String?, purchaseProvider: kotlin.String?, purchaseType: kotlin.String?, returnProfileResponse: kotlin.Boolean?, includeProfileResponse: kotlin.Boolean?, appVersion: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (returnNulls != null) {
                    put("returnNulls", listOf(returnNulls.toString()))
                }
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (gameType != null) {
                    put("gameType", listOf(gameType.toString()))
                }
                if (appKey != null) {
                    put("appKey", listOf(appKey.toString()))
                }
                put("actionType", listOf(actionType.toString()))
                put("ticketObjectType", listOf(ticketObjectType.toString()))
                if (objectId != null) {
                    put("objectId", listOf(objectId.toString()))
                }
                if (purchaseCode != null) {
                    put("purchaseCode", listOf(purchaseCode.toString()))
                }
                if (receiptToken != null) {
                    put("receiptToken", listOf(receiptToken.toString()))
                }
                put("receiptData", listOf(receiptData.toString()))
                if (count != null) {
                    put("count", listOf(count.toString()))
                }
                if (ticketType != null) {
                    put("ticketType", listOf(ticketType.toString()))
                }
                if (purchaseProvider != null) {
                    put("purchaseProvider", listOf(purchaseProvider.toString()))
                }
                if (purchaseType != null) {
                    put("purchaseType", listOf(purchaseType.toString()))
                }
                if (returnProfileResponse != null) {
                    put("returnProfileResponse", listOf(returnProfileResponse.toString()))
                }
                if (includeProfileResponse != null) {
                    put("includeProfileResponse", listOf(includeProfileResponse.toString()))
                }
                if (appVersion != null) {
                    put("appVersion", listOf(appVersion.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/ticket/save/fileUpload",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /ticket/ticketoffers
     * Get Ticket Offers
     * Get a list offers for tickets owned by sirqul.  Purchasing these will add the number of tickets to the account specified by the offer.
     * @return TicketOfferResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun ticketOffers() : TicketOfferResponse {
        val localVarResponse = ticketOffersWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TicketOfferResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /ticket/ticketoffers
     * Get Ticket Offers
     * Get a list offers for tickets owned by sirqul.  Purchasing these will add the number of tickets to the account specified by the offer.
     * @return ApiResponse<TicketOfferResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun ticketOffersWithHttpInfo() : ApiResponse<TicketOfferResponse?> {
        val localVariableConfig = ticketOffersRequestConfig()

        return request<Unit, TicketOfferResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation ticketOffers
     *
     * @return RequestConfig
     */
    fun ticketOffersRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/ticket/ticketoffers",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
