/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import org.openapitools.client.models.RankFullResponse
import org.openapitools.client.models.SirqulResponse

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

open class RankingApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://dev.sirqul.com/api/3.18")
        }
    }

    /**
     * GET /ranking/historical/search
     * Search Historical Rankings
     * Get historical leaderboard rankings by time-frame.
     * @param appKey the application key for filtering results by application
     * @param rankType the rank type to return
     * @param startDate timestamp in milliseconds to filter results with
     * @param endDate timestamp in milliseconds to filter results with
     * @param deviceId a unique id given by the device (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (optional)
     * @param sortField determines how to order and rank the results. Possible values include: TOTAL, MONTHLY, WEEKLY, DAILY, TOP, LOWEST (optional, default to "TOTAL")
     * @param descending determines whether to return results in ascending or descending order (optional, default to true)
     * @param start the start index for pagination (optional, default to 0)
     * @param limit the limit for pagination (optional, default to 100)
     * @return RankFullResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getHistoricalRankings(appKey: kotlin.String, rankType: kotlin.String, startDate: kotlin.Long, endDate: kotlin.Long, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, sortField: kotlin.String? = "TOTAL", descending: kotlin.Boolean? = true, start: kotlin.Int? = 0, limit: kotlin.Int? = 100) : RankFullResponse {
        val localVarResponse = getHistoricalRankingsWithHttpInfo(appKey = appKey, rankType = rankType, startDate = startDate, endDate = endDate, deviceId = deviceId, accountId = accountId, sortField = sortField, descending = descending, start = start, limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RankFullResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /ranking/historical/search
     * Search Historical Rankings
     * Get historical leaderboard rankings by time-frame.
     * @param appKey the application key for filtering results by application
     * @param rankType the rank type to return
     * @param startDate timestamp in milliseconds to filter results with
     * @param endDate timestamp in milliseconds to filter results with
     * @param deviceId a unique id given by the device (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (optional)
     * @param sortField determines how to order and rank the results. Possible values include: TOTAL, MONTHLY, WEEKLY, DAILY, TOP, LOWEST (optional, default to "TOTAL")
     * @param descending determines whether to return results in ascending or descending order (optional, default to true)
     * @param start the start index for pagination (optional, default to 0)
     * @param limit the limit for pagination (optional, default to 100)
     * @return ApiResponse<RankFullResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getHistoricalRankingsWithHttpInfo(appKey: kotlin.String, rankType: kotlin.String, startDate: kotlin.Long, endDate: kotlin.Long, deviceId: kotlin.String?, accountId: kotlin.Long?, sortField: kotlin.String?, descending: kotlin.Boolean?, start: kotlin.Int?, limit: kotlin.Int?) : ApiResponse<RankFullResponse?> {
        val localVariableConfig = getHistoricalRankingsRequestConfig(appKey = appKey, rankType = rankType, startDate = startDate, endDate = endDate, deviceId = deviceId, accountId = accountId, sortField = sortField, descending = descending, start = start, limit = limit)

        return request<Unit, RankFullResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getHistoricalRankings
     *
     * @param appKey the application key for filtering results by application
     * @param rankType the rank type to return
     * @param startDate timestamp in milliseconds to filter results with
     * @param endDate timestamp in milliseconds to filter results with
     * @param deviceId a unique id given by the device (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (optional)
     * @param sortField determines how to order and rank the results. Possible values include: TOTAL, MONTHLY, WEEKLY, DAILY, TOP, LOWEST (optional, default to "TOTAL")
     * @param descending determines whether to return results in ascending or descending order (optional, default to true)
     * @param start the start index for pagination (optional, default to 0)
     * @param limit the limit for pagination (optional, default to 100)
     * @return RequestConfig
     */
    fun getHistoricalRankingsRequestConfig(appKey: kotlin.String, rankType: kotlin.String, startDate: kotlin.Long, endDate: kotlin.Long, deviceId: kotlin.String?, accountId: kotlin.Long?, sortField: kotlin.String?, descending: kotlin.Boolean?, start: kotlin.Int?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                put("appKey", listOf(appKey.toString()))
                put("rankType", listOf(rankType.toString()))
                put("startDate", listOf(startDate.toString()))
                put("endDate", listOf(endDate.toString()))
                if (sortField != null) {
                    put("sortField", listOf(sortField.toString()))
                }
                if (descending != null) {
                    put("descending", listOf(descending.toString()))
                }
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/ranking/historical/search",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /ranking/search
     * Search Rankings
     * Get leader board rankings. This is an all in one endpoint that can return multiple ranking types and also the current user rank.
     * @param deviceId a unique id given by the device (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param gameType This parameter is deprecated. (optional)
     * @param appKey the application key for filtering results by application (required for non-EXECUTIVE users) (optional)
     * @param q This parameter is deprecated. (optional)
     * @param keyword keyword to search for (optional)
     * @param rankType a comma separated list of rank types to return. Possible default rank types: POINTS, DOWNLOADS, INVITATIONS (optional, default to "POINTS,DOWNLOADS,INVITATIONS")
     * @param leaderboardMode the type of search to perform. Possible values include: GLOBAL - searches scores globally (all users in the system are included in the ranking) LOCAL - filters results by select users and on users that have logged into the same device CUSTOM - allows for custom filtering using the params: withinAccountIds, albumId, audienceId (optional, default to "GLOBAL")
     * @param withinAccountIds comma separated list of account ids. If performing a LOCAL or CUSTOM search, the query will include these accounts. (optional)
     * @param returnUserRank determines whether to return the user&#39;s current rank in the response. This can be turned off for sequential paginated requests. (optional, default to true)
     * @param albumId album id to use when performing CUSTOM filters (optional)
     * @param audienceId audience id to use when performing CUSTOM filters (optional)
     * @param sortField determines how to order and rank the results. Possible values include: TOTAL - order results by total score MONTHLY - order results by monthly score WEEKLY - order results by weekly score DAILY - order results by daily score TOP - order results by top score LOWEST - order results by lowest score (optional, default to "TOTAL")
     * @param descending determines whether to return results in ascending or descending order (optional, default to true)
     * @param i This parameter is deprecated. (optional)
     * @param start the start index for pagination (optional, default to 0)
     * @param l This parameter is deprecated. (optional)
     * @param limit the limit for pagination (optional, default to 100)
     * @return RankFullResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getRankings(deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, gameType: kotlin.String? = null, appKey: kotlin.String? = null, q: kotlin.String? = null, keyword: kotlin.String? = null, rankType: kotlin.String? = "POINTS,DOWNLOADS,INVITATIONS", leaderboardMode: kotlin.String? = "GLOBAL", withinAccountIds: kotlin.String? = null, returnUserRank: kotlin.Boolean? = true, albumId: kotlin.Long? = null, audienceId: kotlin.Long? = null, sortField: kotlin.String? = "TOTAL", descending: kotlin.Boolean? = true, i: kotlin.Int? = null, start: kotlin.Int? = 0, l: kotlin.Int? = null, limit: kotlin.Int? = 100) : RankFullResponse {
        val localVarResponse = getRankingsWithHttpInfo(deviceId = deviceId, accountId = accountId, gameType = gameType, appKey = appKey, q = q, keyword = keyword, rankType = rankType, leaderboardMode = leaderboardMode, withinAccountIds = withinAccountIds, returnUserRank = returnUserRank, albumId = albumId, audienceId = audienceId, sortField = sortField, descending = descending, i = i, start = start, l = l, limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RankFullResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /ranking/search
     * Search Rankings
     * Get leader board rankings. This is an all in one endpoint that can return multiple ranking types and also the current user rank.
     * @param deviceId a unique id given by the device (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param gameType This parameter is deprecated. (optional)
     * @param appKey the application key for filtering results by application (required for non-EXECUTIVE users) (optional)
     * @param q This parameter is deprecated. (optional)
     * @param keyword keyword to search for (optional)
     * @param rankType a comma separated list of rank types to return. Possible default rank types: POINTS, DOWNLOADS, INVITATIONS (optional, default to "POINTS,DOWNLOADS,INVITATIONS")
     * @param leaderboardMode the type of search to perform. Possible values include: GLOBAL - searches scores globally (all users in the system are included in the ranking) LOCAL - filters results by select users and on users that have logged into the same device CUSTOM - allows for custom filtering using the params: withinAccountIds, albumId, audienceId (optional, default to "GLOBAL")
     * @param withinAccountIds comma separated list of account ids. If performing a LOCAL or CUSTOM search, the query will include these accounts. (optional)
     * @param returnUserRank determines whether to return the user&#39;s current rank in the response. This can be turned off for sequential paginated requests. (optional, default to true)
     * @param albumId album id to use when performing CUSTOM filters (optional)
     * @param audienceId audience id to use when performing CUSTOM filters (optional)
     * @param sortField determines how to order and rank the results. Possible values include: TOTAL - order results by total score MONTHLY - order results by monthly score WEEKLY - order results by weekly score DAILY - order results by daily score TOP - order results by top score LOWEST - order results by lowest score (optional, default to "TOTAL")
     * @param descending determines whether to return results in ascending or descending order (optional, default to true)
     * @param i This parameter is deprecated. (optional)
     * @param start the start index for pagination (optional, default to 0)
     * @param l This parameter is deprecated. (optional)
     * @param limit the limit for pagination (optional, default to 100)
     * @return ApiResponse<RankFullResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getRankingsWithHttpInfo(deviceId: kotlin.String?, accountId: kotlin.Long?, gameType: kotlin.String?, appKey: kotlin.String?, q: kotlin.String?, keyword: kotlin.String?, rankType: kotlin.String?, leaderboardMode: kotlin.String?, withinAccountIds: kotlin.String?, returnUserRank: kotlin.Boolean?, albumId: kotlin.Long?, audienceId: kotlin.Long?, sortField: kotlin.String?, descending: kotlin.Boolean?, i: kotlin.Int?, start: kotlin.Int?, l: kotlin.Int?, limit: kotlin.Int?) : ApiResponse<RankFullResponse?> {
        val localVariableConfig = getRankingsRequestConfig(deviceId = deviceId, accountId = accountId, gameType = gameType, appKey = appKey, q = q, keyword = keyword, rankType = rankType, leaderboardMode = leaderboardMode, withinAccountIds = withinAccountIds, returnUserRank = returnUserRank, albumId = albumId, audienceId = audienceId, sortField = sortField, descending = descending, i = i, start = start, l = l, limit = limit)

        return request<Unit, RankFullResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getRankings
     *
     * @param deviceId a unique id given by the device (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param gameType This parameter is deprecated. (optional)
     * @param appKey the application key for filtering results by application (required for non-EXECUTIVE users) (optional)
     * @param q This parameter is deprecated. (optional)
     * @param keyword keyword to search for (optional)
     * @param rankType a comma separated list of rank types to return. Possible default rank types: POINTS, DOWNLOADS, INVITATIONS (optional, default to "POINTS,DOWNLOADS,INVITATIONS")
     * @param leaderboardMode the type of search to perform. Possible values include: GLOBAL - searches scores globally (all users in the system are included in the ranking) LOCAL - filters results by select users and on users that have logged into the same device CUSTOM - allows for custom filtering using the params: withinAccountIds, albumId, audienceId (optional, default to "GLOBAL")
     * @param withinAccountIds comma separated list of account ids. If performing a LOCAL or CUSTOM search, the query will include these accounts. (optional)
     * @param returnUserRank determines whether to return the user&#39;s current rank in the response. This can be turned off for sequential paginated requests. (optional, default to true)
     * @param albumId album id to use when performing CUSTOM filters (optional)
     * @param audienceId audience id to use when performing CUSTOM filters (optional)
     * @param sortField determines how to order and rank the results. Possible values include: TOTAL - order results by total score MONTHLY - order results by monthly score WEEKLY - order results by weekly score DAILY - order results by daily score TOP - order results by top score LOWEST - order results by lowest score (optional, default to "TOTAL")
     * @param descending determines whether to return results in ascending or descending order (optional, default to true)
     * @param i This parameter is deprecated. (optional)
     * @param start the start index for pagination (optional, default to 0)
     * @param l This parameter is deprecated. (optional)
     * @param limit the limit for pagination (optional, default to 100)
     * @return RequestConfig
     */
    fun getRankingsRequestConfig(deviceId: kotlin.String?, accountId: kotlin.Long?, gameType: kotlin.String?, appKey: kotlin.String?, q: kotlin.String?, keyword: kotlin.String?, rankType: kotlin.String?, leaderboardMode: kotlin.String?, withinAccountIds: kotlin.String?, returnUserRank: kotlin.Boolean?, albumId: kotlin.Long?, audienceId: kotlin.Long?, sortField: kotlin.String?, descending: kotlin.Boolean?, i: kotlin.Int?, start: kotlin.Int?, l: kotlin.Int?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (gameType != null) {
                    put("gameType", listOf(gameType.toString()))
                }
                if (appKey != null) {
                    put("appKey", listOf(appKey.toString()))
                }
                if (q != null) {
                    put("q", listOf(q.toString()))
                }
                if (keyword != null) {
                    put("keyword", listOf(keyword.toString()))
                }
                if (rankType != null) {
                    put("rankType", listOf(rankType.toString()))
                }
                if (leaderboardMode != null) {
                    put("leaderboardMode", listOf(leaderboardMode.toString()))
                }
                if (withinAccountIds != null) {
                    put("withinAccountIds", listOf(withinAccountIds.toString()))
                }
                if (returnUserRank != null) {
                    put("returnUserRank", listOf(returnUserRank.toString()))
                }
                if (albumId != null) {
                    put("albumId", listOf(albumId.toString()))
                }
                if (audienceId != null) {
                    put("audienceId", listOf(audienceId.toString()))
                }
                if (sortField != null) {
                    put("sortField", listOf(sortField.toString()))
                }
                if (descending != null) {
                    put("descending", listOf(descending.toString()))
                }
                if (i != null) {
                    put("_i", listOf(i.toString()))
                }
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (l != null) {
                    put("_l", listOf(l.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/ranking/search",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /ranking/personal/ranks
     * Get Personal Rankings
     * Returns the user&#39;s ranks for one or more rank types and modes.
     * @param deviceId a unique id given by the device (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (optional)
     * @param appKey the application key for filtering results by application (required) (optional)
     * @param rankType pass in all rankTypes and children rankTypes (optional)
     * @param returnUserRank determines whether to return the user&#39;s current rank in the response, for each rankType (optional, default to false)
     * @param leaderboardMode the type of search to perform. Possible values include: GLOBAL, LOCAL, SEARCH, CUSTOM (optional, default to "GLOBAL")
     * @param sortField determines how to order and rank the results. Possible values include: TOTAL, MONTHLY, WEEKLY, DAILY, TOP, LOWEST (optional, default to "TOTAL")
     * @param keyword keyword to search for (on rankType) (optional)
     * @param descending determines whether to return results in descending order (optional, default to true)
     * @param start the start index for pagination (optional, default to 0)
     * @param limit the limit for pagination (optional, default to 100)
     * @return kotlin.Any
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getUserRank(deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, appKey: kotlin.String? = null, rankType: kotlin.String? = null, returnUserRank: kotlin.Boolean? = false, leaderboardMode: kotlin.String? = "GLOBAL", sortField: kotlin.String? = "TOTAL", keyword: kotlin.String? = null, descending: kotlin.Boolean? = true, start: kotlin.Int? = 0, limit: kotlin.Int? = 100) : kotlin.Any {
        val localVarResponse = getUserRankWithHttpInfo(deviceId = deviceId, accountId = accountId, appKey = appKey, rankType = rankType, returnUserRank = returnUserRank, leaderboardMode = leaderboardMode, sortField = sortField, keyword = keyword, descending = descending, start = start, limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /ranking/personal/ranks
     * Get Personal Rankings
     * Returns the user&#39;s ranks for one or more rank types and modes.
     * @param deviceId a unique id given by the device (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (optional)
     * @param appKey the application key for filtering results by application (required) (optional)
     * @param rankType pass in all rankTypes and children rankTypes (optional)
     * @param returnUserRank determines whether to return the user&#39;s current rank in the response, for each rankType (optional, default to false)
     * @param leaderboardMode the type of search to perform. Possible values include: GLOBAL, LOCAL, SEARCH, CUSTOM (optional, default to "GLOBAL")
     * @param sortField determines how to order and rank the results. Possible values include: TOTAL, MONTHLY, WEEKLY, DAILY, TOP, LOWEST (optional, default to "TOTAL")
     * @param keyword keyword to search for (on rankType) (optional)
     * @param descending determines whether to return results in descending order (optional, default to true)
     * @param start the start index for pagination (optional, default to 0)
     * @param limit the limit for pagination (optional, default to 100)
     * @return ApiResponse<kotlin.Any?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getUserRankWithHttpInfo(deviceId: kotlin.String?, accountId: kotlin.Long?, appKey: kotlin.String?, rankType: kotlin.String?, returnUserRank: kotlin.Boolean?, leaderboardMode: kotlin.String?, sortField: kotlin.String?, keyword: kotlin.String?, descending: kotlin.Boolean?, start: kotlin.Int?, limit: kotlin.Int?) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = getUserRankRequestConfig(deviceId = deviceId, accountId = accountId, appKey = appKey, rankType = rankType, returnUserRank = returnUserRank, leaderboardMode = leaderboardMode, sortField = sortField, keyword = keyword, descending = descending, start = start, limit = limit)

        return request<Unit, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getUserRank
     *
     * @param deviceId a unique id given by the device (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (optional)
     * @param appKey the application key for filtering results by application (required) (optional)
     * @param rankType pass in all rankTypes and children rankTypes (optional)
     * @param returnUserRank determines whether to return the user&#39;s current rank in the response, for each rankType (optional, default to false)
     * @param leaderboardMode the type of search to perform. Possible values include: GLOBAL, LOCAL, SEARCH, CUSTOM (optional, default to "GLOBAL")
     * @param sortField determines how to order and rank the results. Possible values include: TOTAL, MONTHLY, WEEKLY, DAILY, TOP, LOWEST (optional, default to "TOTAL")
     * @param keyword keyword to search for (on rankType) (optional)
     * @param descending determines whether to return results in descending order (optional, default to true)
     * @param start the start index for pagination (optional, default to 0)
     * @param limit the limit for pagination (optional, default to 100)
     * @return RequestConfig
     */
    fun getUserRankRequestConfig(deviceId: kotlin.String?, accountId: kotlin.Long?, appKey: kotlin.String?, rankType: kotlin.String?, returnUserRank: kotlin.Boolean?, leaderboardMode: kotlin.String?, sortField: kotlin.String?, keyword: kotlin.String?, descending: kotlin.Boolean?, start: kotlin.Int?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (appKey != null) {
                    put("appKey", listOf(appKey.toString()))
                }
                if (rankType != null) {
                    put("rankType", listOf(rankType.toString()))
                }
                if (returnUserRank != null) {
                    put("returnUserRank", listOf(returnUserRank.toString()))
                }
                if (leaderboardMode != null) {
                    put("leaderboardMode", listOf(leaderboardMode.toString()))
                }
                if (sortField != null) {
                    put("sortField", listOf(sortField.toString()))
                }
                if (keyword != null) {
                    put("keyword", listOf(keyword.toString()))
                }
                if (descending != null) {
                    put("descending", listOf(descending.toString()))
                }
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/ranking/personal/ranks",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /ranking/override
     * Override User Rank
     * Allows an admin of an application to override a user&#39;s scores for a leaderboard.
     * @param accountId the logged in user&#39;s account id (must have permissions to manage data for the application)
     * @param ownerAccountId the end user&#39;s account id to override
     * @param appKey the application key the leaderboard is for
     * @param rankType the rankType of the leaderboard
     * @param totalScore the total score to update (optional)
     * @param totalCount the total count to update (optional)
     * @param totalTime the total time to update (optional)
     * @param dailyScore the daily score to update (optional)
     * @param dailyCount the daily count to update (optional)
     * @param dailyTime the daily time to update (optional)
     * @param weeklyScore the weekly score to update (optional)
     * @param weeklyCount the weekly count to update (optional)
     * @param weeklyTime the weekly time to update (optional)
     * @param monthlyScore the monthly score to update (optional)
     * @param monthlyCount the monthly count to update (optional)
     * @param monthlyTime the monthly time to update (optional)
     * @param topScore the top score to update (optional)
     * @param lowestScore the lowest score to update (optional)
     * @param streakCount the streak count to update (optional)
     * @param streakBestCount the best streak count to update (optional)
     * @param startDate the start date to update (optional)
     * @param endDate the end date to update (optional)
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun overrideUserRank(accountId: kotlin.Long, ownerAccountId: kotlin.Long, appKey: kotlin.String, rankType: kotlin.String, totalScore: kotlin.Long? = null, totalCount: kotlin.Long? = null, totalTime: kotlin.Long? = null, dailyScore: kotlin.Long? = null, dailyCount: kotlin.Long? = null, dailyTime: kotlin.Long? = null, weeklyScore: kotlin.Long? = null, weeklyCount: kotlin.Long? = null, weeklyTime: kotlin.Long? = null, monthlyScore: kotlin.Long? = null, monthlyCount: kotlin.Long? = null, monthlyTime: kotlin.Long? = null, topScore: kotlin.Long? = null, lowestScore: kotlin.Long? = null, streakCount: kotlin.Long? = null, streakBestCount: kotlin.Long? = null, startDate: kotlin.Long? = null, endDate: kotlin.Long? = null) : SirqulResponse {
        val localVarResponse = overrideUserRankWithHttpInfo(accountId = accountId, ownerAccountId = ownerAccountId, appKey = appKey, rankType = rankType, totalScore = totalScore, totalCount = totalCount, totalTime = totalTime, dailyScore = dailyScore, dailyCount = dailyCount, dailyTime = dailyTime, weeklyScore = weeklyScore, weeklyCount = weeklyCount, weeklyTime = weeklyTime, monthlyScore = monthlyScore, monthlyCount = monthlyCount, monthlyTime = monthlyTime, topScore = topScore, lowestScore = lowestScore, streakCount = streakCount, streakBestCount = streakBestCount, startDate = startDate, endDate = endDate)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /ranking/override
     * Override User Rank
     * Allows an admin of an application to override a user&#39;s scores for a leaderboard.
     * @param accountId the logged in user&#39;s account id (must have permissions to manage data for the application)
     * @param ownerAccountId the end user&#39;s account id to override
     * @param appKey the application key the leaderboard is for
     * @param rankType the rankType of the leaderboard
     * @param totalScore the total score to update (optional)
     * @param totalCount the total count to update (optional)
     * @param totalTime the total time to update (optional)
     * @param dailyScore the daily score to update (optional)
     * @param dailyCount the daily count to update (optional)
     * @param dailyTime the daily time to update (optional)
     * @param weeklyScore the weekly score to update (optional)
     * @param weeklyCount the weekly count to update (optional)
     * @param weeklyTime the weekly time to update (optional)
     * @param monthlyScore the monthly score to update (optional)
     * @param monthlyCount the monthly count to update (optional)
     * @param monthlyTime the monthly time to update (optional)
     * @param topScore the top score to update (optional)
     * @param lowestScore the lowest score to update (optional)
     * @param streakCount the streak count to update (optional)
     * @param streakBestCount the best streak count to update (optional)
     * @param startDate the start date to update (optional)
     * @param endDate the end date to update (optional)
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun overrideUserRankWithHttpInfo(accountId: kotlin.Long, ownerAccountId: kotlin.Long, appKey: kotlin.String, rankType: kotlin.String, totalScore: kotlin.Long?, totalCount: kotlin.Long?, totalTime: kotlin.Long?, dailyScore: kotlin.Long?, dailyCount: kotlin.Long?, dailyTime: kotlin.Long?, weeklyScore: kotlin.Long?, weeklyCount: kotlin.Long?, weeklyTime: kotlin.Long?, monthlyScore: kotlin.Long?, monthlyCount: kotlin.Long?, monthlyTime: kotlin.Long?, topScore: kotlin.Long?, lowestScore: kotlin.Long?, streakCount: kotlin.Long?, streakBestCount: kotlin.Long?, startDate: kotlin.Long?, endDate: kotlin.Long?) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = overrideUserRankRequestConfig(accountId = accountId, ownerAccountId = ownerAccountId, appKey = appKey, rankType = rankType, totalScore = totalScore, totalCount = totalCount, totalTime = totalTime, dailyScore = dailyScore, dailyCount = dailyCount, dailyTime = dailyTime, weeklyScore = weeklyScore, weeklyCount = weeklyCount, weeklyTime = weeklyTime, monthlyScore = monthlyScore, monthlyCount = monthlyCount, monthlyTime = monthlyTime, topScore = topScore, lowestScore = lowestScore, streakCount = streakCount, streakBestCount = streakBestCount, startDate = startDate, endDate = endDate)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation overrideUserRank
     *
     * @param accountId the logged in user&#39;s account id (must have permissions to manage data for the application)
     * @param ownerAccountId the end user&#39;s account id to override
     * @param appKey the application key the leaderboard is for
     * @param rankType the rankType of the leaderboard
     * @param totalScore the total score to update (optional)
     * @param totalCount the total count to update (optional)
     * @param totalTime the total time to update (optional)
     * @param dailyScore the daily score to update (optional)
     * @param dailyCount the daily count to update (optional)
     * @param dailyTime the daily time to update (optional)
     * @param weeklyScore the weekly score to update (optional)
     * @param weeklyCount the weekly count to update (optional)
     * @param weeklyTime the weekly time to update (optional)
     * @param monthlyScore the monthly score to update (optional)
     * @param monthlyCount the monthly count to update (optional)
     * @param monthlyTime the monthly time to update (optional)
     * @param topScore the top score to update (optional)
     * @param lowestScore the lowest score to update (optional)
     * @param streakCount the streak count to update (optional)
     * @param streakBestCount the best streak count to update (optional)
     * @param startDate the start date to update (optional)
     * @param endDate the end date to update (optional)
     * @return RequestConfig
     */
    fun overrideUserRankRequestConfig(accountId: kotlin.Long, ownerAccountId: kotlin.Long, appKey: kotlin.String, rankType: kotlin.String, totalScore: kotlin.Long?, totalCount: kotlin.Long?, totalTime: kotlin.Long?, dailyScore: kotlin.Long?, dailyCount: kotlin.Long?, dailyTime: kotlin.Long?, weeklyScore: kotlin.Long?, weeklyCount: kotlin.Long?, weeklyTime: kotlin.Long?, monthlyScore: kotlin.Long?, monthlyCount: kotlin.Long?, monthlyTime: kotlin.Long?, topScore: kotlin.Long?, lowestScore: kotlin.Long?, streakCount: kotlin.Long?, streakBestCount: kotlin.Long?, startDate: kotlin.Long?, endDate: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("ownerAccountId", listOf(ownerAccountId.toString()))
                put("appKey", listOf(appKey.toString()))
                put("rankType", listOf(rankType.toString()))
                if (totalScore != null) {
                    put("totalScore", listOf(totalScore.toString()))
                }
                if (totalCount != null) {
                    put("totalCount", listOf(totalCount.toString()))
                }
                if (totalTime != null) {
                    put("totalTime", listOf(totalTime.toString()))
                }
                if (dailyScore != null) {
                    put("dailyScore", listOf(dailyScore.toString()))
                }
                if (dailyCount != null) {
                    put("dailyCount", listOf(dailyCount.toString()))
                }
                if (dailyTime != null) {
                    put("dailyTime", listOf(dailyTime.toString()))
                }
                if (weeklyScore != null) {
                    put("weeklyScore", listOf(weeklyScore.toString()))
                }
                if (weeklyCount != null) {
                    put("weeklyCount", listOf(weeklyCount.toString()))
                }
                if (weeklyTime != null) {
                    put("weeklyTime", listOf(weeklyTime.toString()))
                }
                if (monthlyScore != null) {
                    put("monthlyScore", listOf(monthlyScore.toString()))
                }
                if (monthlyCount != null) {
                    put("monthlyCount", listOf(monthlyCount.toString()))
                }
                if (monthlyTime != null) {
                    put("monthlyTime", listOf(monthlyTime.toString()))
                }
                if (topScore != null) {
                    put("topScore", listOf(topScore.toString()))
                }
                if (lowestScore != null) {
                    put("lowestScore", listOf(lowestScore.toString()))
                }
                if (streakCount != null) {
                    put("streakCount", listOf(streakCount.toString()))
                }
                if (streakBestCount != null) {
                    put("streakBestCount", listOf(streakBestCount.toString()))
                }
                if (startDate != null) {
                    put("startDate", listOf(startDate.toString()))
                }
                if (endDate != null) {
                    put("endDate", listOf(endDate.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/ranking/override",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /ranking/update
     * Update Ranking
     * Update the rank value 
     * @param accountId the account id of the user
     * @param appKey the application key for filtering results by application
     * @param rankType a unique label for identifying the ranking. This can be any alphanumeric string (no spaces or special characters) with a maximum length of 64 characters. There are also default rank types to use which include: POINTS, DOWNLOADS, INVITATIONS, CREATIONS, VOTES, REDEEMED, ACTIONS
     * @param increment the value to increment (optional, default to 1L)
     * @param timeIncrement the time value to increment (optional)
     * @param tag the analytic tag for this achievement (used to validate scores) (optional)
     * @param startDate custom date you can save along with the score for the user (optional)
     * @param endDate custom date you can save along with the score for the user (optional)
     * @param updateGlobal update the global rankings if true, default is false (optional)
     * @param createLeaderboard create the leaderboard if it does not exist (default false) (optional, default to false)
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updateRankings(accountId: kotlin.Long, appKey: kotlin.String, rankType: kotlin.String, increment: kotlin.Long? = 1L, timeIncrement: kotlin.Long? = null, tag: kotlin.String? = null, startDate: kotlin.Long? = null, endDate: kotlin.Long? = null, updateGlobal: kotlin.Boolean? = null, createLeaderboard: kotlin.Boolean? = false) : SirqulResponse {
        val localVarResponse = updateRankingsWithHttpInfo(accountId = accountId, appKey = appKey, rankType = rankType, increment = increment, timeIncrement = timeIncrement, tag = tag, startDate = startDate, endDate = endDate, updateGlobal = updateGlobal, createLeaderboard = createLeaderboard)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /ranking/update
     * Update Ranking
     * Update the rank value 
     * @param accountId the account id of the user
     * @param appKey the application key for filtering results by application
     * @param rankType a unique label for identifying the ranking. This can be any alphanumeric string (no spaces or special characters) with a maximum length of 64 characters. There are also default rank types to use which include: POINTS, DOWNLOADS, INVITATIONS, CREATIONS, VOTES, REDEEMED, ACTIONS
     * @param increment the value to increment (optional, default to 1L)
     * @param timeIncrement the time value to increment (optional)
     * @param tag the analytic tag for this achievement (used to validate scores) (optional)
     * @param startDate custom date you can save along with the score for the user (optional)
     * @param endDate custom date you can save along with the score for the user (optional)
     * @param updateGlobal update the global rankings if true, default is false (optional)
     * @param createLeaderboard create the leaderboard if it does not exist (default false) (optional, default to false)
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun updateRankingsWithHttpInfo(accountId: kotlin.Long, appKey: kotlin.String, rankType: kotlin.String, increment: kotlin.Long?, timeIncrement: kotlin.Long?, tag: kotlin.String?, startDate: kotlin.Long?, endDate: kotlin.Long?, updateGlobal: kotlin.Boolean?, createLeaderboard: kotlin.Boolean?) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = updateRankingsRequestConfig(accountId = accountId, appKey = appKey, rankType = rankType, increment = increment, timeIncrement = timeIncrement, tag = tag, startDate = startDate, endDate = endDate, updateGlobal = updateGlobal, createLeaderboard = createLeaderboard)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateRankings
     *
     * @param accountId the account id of the user
     * @param appKey the application key for filtering results by application
     * @param rankType a unique label for identifying the ranking. This can be any alphanumeric string (no spaces or special characters) with a maximum length of 64 characters. There are also default rank types to use which include: POINTS, DOWNLOADS, INVITATIONS, CREATIONS, VOTES, REDEEMED, ACTIONS
     * @param increment the value to increment (optional, default to 1L)
     * @param timeIncrement the time value to increment (optional)
     * @param tag the analytic tag for this achievement (used to validate scores) (optional)
     * @param startDate custom date you can save along with the score for the user (optional)
     * @param endDate custom date you can save along with the score for the user (optional)
     * @param updateGlobal update the global rankings if true, default is false (optional)
     * @param createLeaderboard create the leaderboard if it does not exist (default false) (optional, default to false)
     * @return RequestConfig
     */
    fun updateRankingsRequestConfig(accountId: kotlin.Long, appKey: kotlin.String, rankType: kotlin.String, increment: kotlin.Long?, timeIncrement: kotlin.Long?, tag: kotlin.String?, startDate: kotlin.Long?, endDate: kotlin.Long?, updateGlobal: kotlin.Boolean?, createLeaderboard: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("appKey", listOf(appKey.toString()))
                put("rankType", listOf(rankType.toString()))
                if (increment != null) {
                    put("increment", listOf(increment.toString()))
                }
                if (timeIncrement != null) {
                    put("timeIncrement", listOf(timeIncrement.toString()))
                }
                if (tag != null) {
                    put("tag", listOf(tag.toString()))
                }
                if (startDate != null) {
                    put("startDate", listOf(startDate.toString()))
                }
                if (endDate != null) {
                    put("endDate", listOf(endDate.toString()))
                }
                if (updateGlobal != null) {
                    put("updateGlobal", listOf(updateGlobal.toString()))
                }
                if (createLeaderboard != null) {
                    put("createLeaderboard", listOf(createLeaderboard.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/ranking/update",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
