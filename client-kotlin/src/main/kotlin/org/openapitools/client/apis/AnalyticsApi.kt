/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import org.openapitools.client.models.ChartData
import org.openapitools.client.models.SirqulResponse
import org.openapitools.client.models.UserActivityResponse

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

open class AnalyticsApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://dev.sirqul.com/api/3.18")
        }
    }

    /**
     * GET /analytics/useractivity
     * Get User Activity
     * Get an activity feed by user.
     * @param start The start of the pagination
     * @param limit The limit of the pagination
     * @param accountId the account id of the user
     * @return kotlin.collections.List<UserActivityResponse>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun activities(start: kotlin.Int, limit: kotlin.Int, accountId: kotlin.Long) : kotlin.collections.List<UserActivityResponse> {
        val localVarResponse = activitiesWithHttpInfo(start = start, limit = limit, accountId = accountId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UserActivityResponse>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /analytics/useractivity
     * Get User Activity
     * Get an activity feed by user.
     * @param start The start of the pagination
     * @param limit The limit of the pagination
     * @param accountId the account id of the user
     * @return ApiResponse<kotlin.collections.List<UserActivityResponse>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun activitiesWithHttpInfo(start: kotlin.Int, limit: kotlin.Int, accountId: kotlin.Long) : ApiResponse<kotlin.collections.List<UserActivityResponse>?> {
        val localVariableConfig = activitiesRequestConfig(start = start, limit = limit, accountId = accountId)

        return request<Unit, kotlin.collections.List<UserActivityResponse>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation activities
     *
     * @param start The start of the pagination
     * @param limit The limit of the pagination
     * @param accountId the account id of the user
     * @return RequestConfig
     */
    fun activitiesRequestConfig(start: kotlin.Int, limit: kotlin.Int, accountId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("start", listOf(start.toString()))
                put("limit", listOf(limit.toString()))
                put("accountId", listOf(accountId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/analytics/useractivity",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter groupByRoot
     */
     enum class GroupByRootAggregatedFilteredUsage(val value: kotlin.String) {
         @Json(name = "TAG_COUNT") TAG_COUNT("TAG_COUNT"),
         @Json(name = "TAG") TAG("TAG"),
         @Json(name = "TOKEN") TOKEN("TOKEN"),
         @Json(name = "MODEL") MODEL("MODEL"),
         @Json(name = "DEVICE_TYPE") DEVICE_TYPE("DEVICE_TYPE"),
         @Json(name = "DEVICE") DEVICE("DEVICE"),
         @Json(name = "DEVICE_OS") DEVICE_OS("DEVICE_OS"),
         @Json(name = "DEVICE_ID") DEVICE_ID("DEVICE_ID"),
         @Json(name = "IP_ADDRESS") IP_ADDRESS("IP_ADDRESS"),
         @Json(name = "STATE") STATE("STATE"),
         @Json(name = "CITY") CITY("CITY"),
         @Json(name = "ZIP") ZIP("ZIP"),
         @Json(name = "COUNTRY") COUNTRY("COUNTRY"),
         @Json(name = "CREATED") CREATED("CREATED"),
         @Json(name = "UPDATED") UPDATED("UPDATED"),
         @Json(name = "LAST_UPDATED") LAST_UPDATED("LAST_UPDATED"),
         @Json(name = "CLIENT_TIME") CLIENT_TIME("CLIENT_TIME"),
         @Json(name = "ACTIVE") ACTIVE("ACTIVE"),
         @Json(name = "CUSTOM_ID") CUSTOM_ID("CUSTOM_ID"),
         @Json(name = "CUSTOM_TYPE") CUSTOM_TYPE("CUSTOM_TYPE"),
         @Json(name = "CUSTOM_VALUE") CUSTOM_VALUE("CUSTOM_VALUE"),
         @Json(name = "CUSTOM_VALUE2") CUSTOM_VALUE2("CUSTOM_VALUE2"),
         @Json(name = "CUSTOM_LONG") CUSTOM_LONG("CUSTOM_LONG"),
         @Json(name = "CUSTOM_LONG2") CUSTOM_LONG2("CUSTOM_LONG2"),
         @Json(name = "CUSTOM_MESSAGE") CUSTOM_MESSAGE("CUSTOM_MESSAGE"),
         @Json(name = "CUSTOM_MESSAGE2") CUSTOM_MESSAGE2("CUSTOM_MESSAGE2"),
         @Json(name = "ACCOUNT_ID") ACCOUNT_ID("ACCOUNT_ID"),
         @Json(name = "ACCOUNT_USERNAME") ACCOUNT_USERNAME("ACCOUNT_USERNAME"),
         @Json(name = "ACCOUNT_DISPLAY") ACCOUNT_DISPLAY("ACCOUNT_DISPLAY"),
         @Json(name = "ACCOUNT_CREATED") ACCOUNT_CREATED("ACCOUNT_CREATED"),
         @Json(name = "ACCOUNT_GENDER") ACCOUNT_GENDER("ACCOUNT_GENDER"),
         @Json(name = "ACCOUNT_AGE_GROUP") ACCOUNT_AGE_GROUP("ACCOUNT_AGE_GROUP"),
         @Json(name = "APPLICATION_ID") APPLICATION_ID("APPLICATION_ID"),
         @Json(name = "APPLICATION_KEY") APPLICATION_KEY("APPLICATION_KEY"),
         @Json(name = "APPLICATION_NAME") APPLICATION_NAME("APPLICATION_NAME");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter groupBy
     */
     enum class GroupByAggregatedFilteredUsage(val value: kotlin.String) {
         @Json(name = "TAG_COUNT") TAG_COUNT("TAG_COUNT"),
         @Json(name = "TAG") TAG("TAG"),
         @Json(name = "TOKEN") TOKEN("TOKEN"),
         @Json(name = "MODEL") MODEL("MODEL"),
         @Json(name = "DEVICE_TYPE") DEVICE_TYPE("DEVICE_TYPE"),
         @Json(name = "DEVICE") DEVICE("DEVICE"),
         @Json(name = "DEVICE_OS") DEVICE_OS("DEVICE_OS"),
         @Json(name = "DEVICE_ID") DEVICE_ID("DEVICE_ID"),
         @Json(name = "IP_ADDRESS") IP_ADDRESS("IP_ADDRESS"),
         @Json(name = "STATE") STATE("STATE"),
         @Json(name = "CITY") CITY("CITY"),
         @Json(name = "ZIP") ZIP("ZIP"),
         @Json(name = "COUNTRY") COUNTRY("COUNTRY"),
         @Json(name = "CREATED") CREATED("CREATED"),
         @Json(name = "UPDATED") UPDATED("UPDATED"),
         @Json(name = "LAST_UPDATED") LAST_UPDATED("LAST_UPDATED"),
         @Json(name = "CLIENT_TIME") CLIENT_TIME("CLIENT_TIME"),
         @Json(name = "ACTIVE") ACTIVE("ACTIVE"),
         @Json(name = "CUSTOM_ID") CUSTOM_ID("CUSTOM_ID"),
         @Json(name = "CUSTOM_TYPE") CUSTOM_TYPE("CUSTOM_TYPE"),
         @Json(name = "CUSTOM_VALUE") CUSTOM_VALUE("CUSTOM_VALUE"),
         @Json(name = "CUSTOM_VALUE2") CUSTOM_VALUE2("CUSTOM_VALUE2"),
         @Json(name = "CUSTOM_LONG") CUSTOM_LONG("CUSTOM_LONG"),
         @Json(name = "CUSTOM_LONG2") CUSTOM_LONG2("CUSTOM_LONG2"),
         @Json(name = "CUSTOM_MESSAGE") CUSTOM_MESSAGE("CUSTOM_MESSAGE"),
         @Json(name = "CUSTOM_MESSAGE2") CUSTOM_MESSAGE2("CUSTOM_MESSAGE2"),
         @Json(name = "ACCOUNT_ID") ACCOUNT_ID("ACCOUNT_ID"),
         @Json(name = "ACCOUNT_USERNAME") ACCOUNT_USERNAME("ACCOUNT_USERNAME"),
         @Json(name = "ACCOUNT_DISPLAY") ACCOUNT_DISPLAY("ACCOUNT_DISPLAY"),
         @Json(name = "ACCOUNT_CREATED") ACCOUNT_CREATED("ACCOUNT_CREATED"),
         @Json(name = "ACCOUNT_GENDER") ACCOUNT_GENDER("ACCOUNT_GENDER"),
         @Json(name = "ACCOUNT_AGE_GROUP") ACCOUNT_AGE_GROUP("ACCOUNT_AGE_GROUP"),
         @Json(name = "APPLICATION_ID") APPLICATION_ID("APPLICATION_ID"),
         @Json(name = "APPLICATION_KEY") APPLICATION_KEY("APPLICATION_KEY"),
         @Json(name = "APPLICATION_NAME") APPLICATION_NAME("APPLICATION_NAME");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter distinctCount
     */
     enum class DistinctCountAggregatedFilteredUsage(val value: kotlin.String) {
         @Json(name = "TAG_COUNT") TAG_COUNT("TAG_COUNT"),
         @Json(name = "TAG") TAG("TAG"),
         @Json(name = "TOKEN") TOKEN("TOKEN"),
         @Json(name = "MODEL") MODEL("MODEL"),
         @Json(name = "DEVICE_TYPE") DEVICE_TYPE("DEVICE_TYPE"),
         @Json(name = "DEVICE") DEVICE("DEVICE"),
         @Json(name = "DEVICE_OS") DEVICE_OS("DEVICE_OS"),
         @Json(name = "DEVICE_ID") DEVICE_ID("DEVICE_ID"),
         @Json(name = "IP_ADDRESS") IP_ADDRESS("IP_ADDRESS"),
         @Json(name = "STATE") STATE("STATE"),
         @Json(name = "CITY") CITY("CITY"),
         @Json(name = "ZIP") ZIP("ZIP"),
         @Json(name = "COUNTRY") COUNTRY("COUNTRY"),
         @Json(name = "CREATED") CREATED("CREATED"),
         @Json(name = "UPDATED") UPDATED("UPDATED"),
         @Json(name = "LAST_UPDATED") LAST_UPDATED("LAST_UPDATED"),
         @Json(name = "CLIENT_TIME") CLIENT_TIME("CLIENT_TIME"),
         @Json(name = "ACTIVE") ACTIVE("ACTIVE"),
         @Json(name = "CUSTOM_ID") CUSTOM_ID("CUSTOM_ID"),
         @Json(name = "CUSTOM_TYPE") CUSTOM_TYPE("CUSTOM_TYPE"),
         @Json(name = "CUSTOM_VALUE") CUSTOM_VALUE("CUSTOM_VALUE"),
         @Json(name = "CUSTOM_VALUE2") CUSTOM_VALUE2("CUSTOM_VALUE2"),
         @Json(name = "CUSTOM_LONG") CUSTOM_LONG("CUSTOM_LONG"),
         @Json(name = "CUSTOM_LONG2") CUSTOM_LONG2("CUSTOM_LONG2"),
         @Json(name = "CUSTOM_MESSAGE") CUSTOM_MESSAGE("CUSTOM_MESSAGE"),
         @Json(name = "CUSTOM_MESSAGE2") CUSTOM_MESSAGE2("CUSTOM_MESSAGE2"),
         @Json(name = "ACCOUNT_ID") ACCOUNT_ID("ACCOUNT_ID"),
         @Json(name = "ACCOUNT_USERNAME") ACCOUNT_USERNAME("ACCOUNT_USERNAME"),
         @Json(name = "ACCOUNT_DISPLAY") ACCOUNT_DISPLAY("ACCOUNT_DISPLAY"),
         @Json(name = "ACCOUNT_CREATED") ACCOUNT_CREATED("ACCOUNT_CREATED"),
         @Json(name = "ACCOUNT_GENDER") ACCOUNT_GENDER("ACCOUNT_GENDER"),
         @Json(name = "ACCOUNT_AGE_GROUP") ACCOUNT_AGE_GROUP("ACCOUNT_AGE_GROUP"),
         @Json(name = "APPLICATION_ID") APPLICATION_ID("APPLICATION_ID"),
         @Json(name = "APPLICATION_KEY") APPLICATION_KEY("APPLICATION_KEY"),
         @Json(name = "APPLICATION_NAME") APPLICATION_NAME("APPLICATION_NAME");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter sortField
     */
     enum class SortFieldAggregatedFilteredUsage(val value: kotlin.String) {
         @Json(name = "TAG_COUNT") TAG_COUNT("TAG_COUNT"),
         @Json(name = "TAG") TAG("TAG"),
         @Json(name = "TOKEN") TOKEN("TOKEN"),
         @Json(name = "MODEL") MODEL("MODEL"),
         @Json(name = "DEVICE_TYPE") DEVICE_TYPE("DEVICE_TYPE"),
         @Json(name = "DEVICE") DEVICE("DEVICE"),
         @Json(name = "DEVICE_OS") DEVICE_OS("DEVICE_OS"),
         @Json(name = "DEVICE_ID") DEVICE_ID("DEVICE_ID"),
         @Json(name = "IP_ADDRESS") IP_ADDRESS("IP_ADDRESS"),
         @Json(name = "STATE") STATE("STATE"),
         @Json(name = "CITY") CITY("CITY"),
         @Json(name = "ZIP") ZIP("ZIP"),
         @Json(name = "COUNTRY") COUNTRY("COUNTRY"),
         @Json(name = "CREATED") CREATED("CREATED"),
         @Json(name = "UPDATED") UPDATED("UPDATED"),
         @Json(name = "LAST_UPDATED") LAST_UPDATED("LAST_UPDATED"),
         @Json(name = "CLIENT_TIME") CLIENT_TIME("CLIENT_TIME"),
         @Json(name = "ACTIVE") ACTIVE("ACTIVE"),
         @Json(name = "CUSTOM_ID") CUSTOM_ID("CUSTOM_ID"),
         @Json(name = "CUSTOM_TYPE") CUSTOM_TYPE("CUSTOM_TYPE"),
         @Json(name = "CUSTOM_VALUE") CUSTOM_VALUE("CUSTOM_VALUE"),
         @Json(name = "CUSTOM_VALUE2") CUSTOM_VALUE2("CUSTOM_VALUE2"),
         @Json(name = "CUSTOM_LONG") CUSTOM_LONG("CUSTOM_LONG"),
         @Json(name = "CUSTOM_LONG2") CUSTOM_LONG2("CUSTOM_LONG2"),
         @Json(name = "CUSTOM_MESSAGE") CUSTOM_MESSAGE("CUSTOM_MESSAGE"),
         @Json(name = "CUSTOM_MESSAGE2") CUSTOM_MESSAGE2("CUSTOM_MESSAGE2"),
         @Json(name = "ACCOUNT_ID") ACCOUNT_ID("ACCOUNT_ID"),
         @Json(name = "ACCOUNT_USERNAME") ACCOUNT_USERNAME("ACCOUNT_USERNAME"),
         @Json(name = "ACCOUNT_DISPLAY") ACCOUNT_DISPLAY("ACCOUNT_DISPLAY"),
         @Json(name = "ACCOUNT_CREATED") ACCOUNT_CREATED("ACCOUNT_CREATED"),
         @Json(name = "ACCOUNT_GENDER") ACCOUNT_GENDER("ACCOUNT_GENDER"),
         @Json(name = "ACCOUNT_AGE_GROUP") ACCOUNT_AGE_GROUP("ACCOUNT_AGE_GROUP"),
         @Json(name = "APPLICATION_ID") APPLICATION_ID("APPLICATION_ID"),
         @Json(name = "APPLICATION_KEY") APPLICATION_KEY("APPLICATION_KEY"),
         @Json(name = "APPLICATION_NAME") APPLICATION_NAME("APPLICATION_NAME");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter responseFormat
     */
     enum class ResponseFormatAggregatedFilteredUsage(val value: kotlin.String) {
         @Json(name = "HTML") HTML("HTML"),
         @Json(name = "XML") XML("XML"),
         @Json(name = "JSON") JSON("JSON"),
         @Json(name = "CSV") CSV("CSV");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /analytics/aggregatedFilteredUsage
     * Get Aggregated Filtered Usage
     * Query analytics to get data used for nested graphs and charts
     * @param deviceId The unique id of the device making the request (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param applicationId This parameter is deprecated. (optional)
     * @param appKey The application key used to filter results by application (optional)
     * @param startDate Used to search for results after or equal to this date (UNIX time-stamp in milliseconds) (optional)
     * @param endDate Used to search for results before or equal to this date (UNIX time-stamp in milliseconds) (optional)
     * @param deviceType The device type to filter results by (performs a LIKE search) (optional)
     * @param device The device to filter results by (performs a LIKE search) (optional)
     * @param deviceOS The device OS to filter results by (performs a LIKE search) (optional)
     * @param gender The gender to filter results by {MALE, FEMALE} (optional)
     * @param ageGroup Comma separated list of age groups to filter by {AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS} (optional)
     * @param country The country to filter results by (performs a wild-card search) (optional)
     * @param state The state to filter results by (performs a wild-card search) (optional)
     * @param city The city to filter results by (performs a wild-card search) (optional)
     * @param zip The zip to filter results by (performs a wild-card search) (optional)
     * @param model The model to filter results by (performs a wild-card search) (optional)
     * @param tag The tag to filter results by (performs a wild-card search) (optional)
     * @param userAccountId The account id to filter results for a particular user (optional)
     * @param userAccountDisplay The user display to filter results by (performs a wild-card search) (optional)
     * @param userAccountUsername The username to filter results by (performs a wild-card search) (optional)
     * @param groupByRoot Determines how to group results. For example, passing in &#39;CREATED&#39; will return results by date. Passing in &#39;ACCOUNT&#39; will return results by user {TAG, CUSTOM_ID, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, ACCOUNT, APPLICATION_ID, APPLICATION_NAME_BY_ID} (optional)
     * @param groupBy Determines how to group the nested data. {TAG, CUSTOM_ID, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, ACCOUNT, APPLICATION_ID, APPLICATION_NAME_BY_ID} (optional)
     * @param distinctCount Performs a unique query on the specified column. For example, passing in &#39;ACCOUNT&#39; will return the number of unique users. {TAG, CUSTOM_ID, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, ACCOUNT, APPLICATION_ID, NEW_ACCOUNT} (optional)
     * @param sortField Determines whether the results will be sorted by day or by number of hits {CREATED, TAG_COUNT} (optional)
     * @param descending Determines whether to return results in descending order (optional)
     * @param hideUnknown Determines whether to return data that has empty or unknown values (optional)
     * @param responseFormat Determines whether to return a JOSN or XML representation of the graph results (optional)
     * @param l This parameter is deprecated. (optional)
     * @param limit Used to limit results to get a cleaner graph. The results that gets filtered out will be combined (optional)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @return ChartData
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun aggregatedFilteredUsage(deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, applicationId: kotlin.Long? = null, appKey: kotlin.String? = null, startDate: kotlin.Long? = null, endDate: kotlin.Long? = null, deviceType: kotlin.String? = null, device: kotlin.String? = null, deviceOS: kotlin.String? = null, gender: kotlin.String? = null, ageGroup: kotlin.String? = null, country: kotlin.String? = null, state: kotlin.String? = null, city: kotlin.String? = null, zip: kotlin.String? = null, model: kotlin.String? = null, tag: kotlin.String? = null, userAccountId: kotlin.Long? = null, userAccountDisplay: kotlin.String? = null, userAccountUsername: kotlin.String? = null, groupByRoot: GroupByRootAggregatedFilteredUsage? = null, groupBy: GroupByAggregatedFilteredUsage? = null, distinctCount: DistinctCountAggregatedFilteredUsage? = null, sortField: SortFieldAggregatedFilteredUsage? = null, descending: kotlin.Boolean? = null, hideUnknown: kotlin.Boolean? = null, responseFormat: ResponseFormatAggregatedFilteredUsage? = null, l: kotlin.Int? = null, limit: kotlin.Int? = null, latitude: kotlin.Double? = null, longitude: kotlin.Double? = null) : ChartData {
        val localVarResponse = aggregatedFilteredUsageWithHttpInfo(deviceId = deviceId, accountId = accountId, applicationId = applicationId, appKey = appKey, startDate = startDate, endDate = endDate, deviceType = deviceType, device = device, deviceOS = deviceOS, gender = gender, ageGroup = ageGroup, country = country, state = state, city = city, zip = zip, model = model, tag = tag, userAccountId = userAccountId, userAccountDisplay = userAccountDisplay, userAccountUsername = userAccountUsername, groupByRoot = groupByRoot, groupBy = groupBy, distinctCount = distinctCount, sortField = sortField, descending = descending, hideUnknown = hideUnknown, responseFormat = responseFormat, l = l, limit = limit, latitude = latitude, longitude = longitude)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ChartData
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /analytics/aggregatedFilteredUsage
     * Get Aggregated Filtered Usage
     * Query analytics to get data used for nested graphs and charts
     * @param deviceId The unique id of the device making the request (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param applicationId This parameter is deprecated. (optional)
     * @param appKey The application key used to filter results by application (optional)
     * @param startDate Used to search for results after or equal to this date (UNIX time-stamp in milliseconds) (optional)
     * @param endDate Used to search for results before or equal to this date (UNIX time-stamp in milliseconds) (optional)
     * @param deviceType The device type to filter results by (performs a LIKE search) (optional)
     * @param device The device to filter results by (performs a LIKE search) (optional)
     * @param deviceOS The device OS to filter results by (performs a LIKE search) (optional)
     * @param gender The gender to filter results by {MALE, FEMALE} (optional)
     * @param ageGroup Comma separated list of age groups to filter by {AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS} (optional)
     * @param country The country to filter results by (performs a wild-card search) (optional)
     * @param state The state to filter results by (performs a wild-card search) (optional)
     * @param city The city to filter results by (performs a wild-card search) (optional)
     * @param zip The zip to filter results by (performs a wild-card search) (optional)
     * @param model The model to filter results by (performs a wild-card search) (optional)
     * @param tag The tag to filter results by (performs a wild-card search) (optional)
     * @param userAccountId The account id to filter results for a particular user (optional)
     * @param userAccountDisplay The user display to filter results by (performs a wild-card search) (optional)
     * @param userAccountUsername The username to filter results by (performs a wild-card search) (optional)
     * @param groupByRoot Determines how to group results. For example, passing in &#39;CREATED&#39; will return results by date. Passing in &#39;ACCOUNT&#39; will return results by user {TAG, CUSTOM_ID, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, ACCOUNT, APPLICATION_ID, APPLICATION_NAME_BY_ID} (optional)
     * @param groupBy Determines how to group the nested data. {TAG, CUSTOM_ID, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, ACCOUNT, APPLICATION_ID, APPLICATION_NAME_BY_ID} (optional)
     * @param distinctCount Performs a unique query on the specified column. For example, passing in &#39;ACCOUNT&#39; will return the number of unique users. {TAG, CUSTOM_ID, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, ACCOUNT, APPLICATION_ID, NEW_ACCOUNT} (optional)
     * @param sortField Determines whether the results will be sorted by day or by number of hits {CREATED, TAG_COUNT} (optional)
     * @param descending Determines whether to return results in descending order (optional)
     * @param hideUnknown Determines whether to return data that has empty or unknown values (optional)
     * @param responseFormat Determines whether to return a JOSN or XML representation of the graph results (optional)
     * @param l This parameter is deprecated. (optional)
     * @param limit Used to limit results to get a cleaner graph. The results that gets filtered out will be combined (optional)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @return ApiResponse<ChartData?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun aggregatedFilteredUsageWithHttpInfo(deviceId: kotlin.String?, accountId: kotlin.Long?, applicationId: kotlin.Long?, appKey: kotlin.String?, startDate: kotlin.Long?, endDate: kotlin.Long?, deviceType: kotlin.String?, device: kotlin.String?, deviceOS: kotlin.String?, gender: kotlin.String?, ageGroup: kotlin.String?, country: kotlin.String?, state: kotlin.String?, city: kotlin.String?, zip: kotlin.String?, model: kotlin.String?, tag: kotlin.String?, userAccountId: kotlin.Long?, userAccountDisplay: kotlin.String?, userAccountUsername: kotlin.String?, groupByRoot: GroupByRootAggregatedFilteredUsage?, groupBy: GroupByAggregatedFilteredUsage?, distinctCount: DistinctCountAggregatedFilteredUsage?, sortField: SortFieldAggregatedFilteredUsage?, descending: kotlin.Boolean?, hideUnknown: kotlin.Boolean?, responseFormat: ResponseFormatAggregatedFilteredUsage?, l: kotlin.Int?, limit: kotlin.Int?, latitude: kotlin.Double?, longitude: kotlin.Double?) : ApiResponse<ChartData?> {
        val localVariableConfig = aggregatedFilteredUsageRequestConfig(deviceId = deviceId, accountId = accountId, applicationId = applicationId, appKey = appKey, startDate = startDate, endDate = endDate, deviceType = deviceType, device = device, deviceOS = deviceOS, gender = gender, ageGroup = ageGroup, country = country, state = state, city = city, zip = zip, model = model, tag = tag, userAccountId = userAccountId, userAccountDisplay = userAccountDisplay, userAccountUsername = userAccountUsername, groupByRoot = groupByRoot, groupBy = groupBy, distinctCount = distinctCount, sortField = sortField, descending = descending, hideUnknown = hideUnknown, responseFormat = responseFormat, l = l, limit = limit, latitude = latitude, longitude = longitude)

        return request<Unit, ChartData>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation aggregatedFilteredUsage
     *
     * @param deviceId The unique id of the device making the request (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param applicationId This parameter is deprecated. (optional)
     * @param appKey The application key used to filter results by application (optional)
     * @param startDate Used to search for results after or equal to this date (UNIX time-stamp in milliseconds) (optional)
     * @param endDate Used to search for results before or equal to this date (UNIX time-stamp in milliseconds) (optional)
     * @param deviceType The device type to filter results by (performs a LIKE search) (optional)
     * @param device The device to filter results by (performs a LIKE search) (optional)
     * @param deviceOS The device OS to filter results by (performs a LIKE search) (optional)
     * @param gender The gender to filter results by {MALE, FEMALE} (optional)
     * @param ageGroup Comma separated list of age groups to filter by {AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS} (optional)
     * @param country The country to filter results by (performs a wild-card search) (optional)
     * @param state The state to filter results by (performs a wild-card search) (optional)
     * @param city The city to filter results by (performs a wild-card search) (optional)
     * @param zip The zip to filter results by (performs a wild-card search) (optional)
     * @param model The model to filter results by (performs a wild-card search) (optional)
     * @param tag The tag to filter results by (performs a wild-card search) (optional)
     * @param userAccountId The account id to filter results for a particular user (optional)
     * @param userAccountDisplay The user display to filter results by (performs a wild-card search) (optional)
     * @param userAccountUsername The username to filter results by (performs a wild-card search) (optional)
     * @param groupByRoot Determines how to group results. For example, passing in &#39;CREATED&#39; will return results by date. Passing in &#39;ACCOUNT&#39; will return results by user {TAG, CUSTOM_ID, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, ACCOUNT, APPLICATION_ID, APPLICATION_NAME_BY_ID} (optional)
     * @param groupBy Determines how to group the nested data. {TAG, CUSTOM_ID, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, ACCOUNT, APPLICATION_ID, APPLICATION_NAME_BY_ID} (optional)
     * @param distinctCount Performs a unique query on the specified column. For example, passing in &#39;ACCOUNT&#39; will return the number of unique users. {TAG, CUSTOM_ID, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, ACCOUNT, APPLICATION_ID, NEW_ACCOUNT} (optional)
     * @param sortField Determines whether the results will be sorted by day or by number of hits {CREATED, TAG_COUNT} (optional)
     * @param descending Determines whether to return results in descending order (optional)
     * @param hideUnknown Determines whether to return data that has empty or unknown values (optional)
     * @param responseFormat Determines whether to return a JOSN or XML representation of the graph results (optional)
     * @param l This parameter is deprecated. (optional)
     * @param limit Used to limit results to get a cleaner graph. The results that gets filtered out will be combined (optional)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @return RequestConfig
     */
    fun aggregatedFilteredUsageRequestConfig(deviceId: kotlin.String?, accountId: kotlin.Long?, applicationId: kotlin.Long?, appKey: kotlin.String?, startDate: kotlin.Long?, endDate: kotlin.Long?, deviceType: kotlin.String?, device: kotlin.String?, deviceOS: kotlin.String?, gender: kotlin.String?, ageGroup: kotlin.String?, country: kotlin.String?, state: kotlin.String?, city: kotlin.String?, zip: kotlin.String?, model: kotlin.String?, tag: kotlin.String?, userAccountId: kotlin.Long?, userAccountDisplay: kotlin.String?, userAccountUsername: kotlin.String?, groupByRoot: GroupByRootAggregatedFilteredUsage?, groupBy: GroupByAggregatedFilteredUsage?, distinctCount: DistinctCountAggregatedFilteredUsage?, sortField: SortFieldAggregatedFilteredUsage?, descending: kotlin.Boolean?, hideUnknown: kotlin.Boolean?, responseFormat: ResponseFormatAggregatedFilteredUsage?, l: kotlin.Int?, limit: kotlin.Int?, latitude: kotlin.Double?, longitude: kotlin.Double?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (applicationId != null) {
                    put("applicationId", listOf(applicationId.toString()))
                }
                if (appKey != null) {
                    put("appKey", listOf(appKey.toString()))
                }
                if (startDate != null) {
                    put("startDate", listOf(startDate.toString()))
                }
                if (endDate != null) {
                    put("endDate", listOf(endDate.toString()))
                }
                if (deviceType != null) {
                    put("deviceType", listOf(deviceType.toString()))
                }
                if (device != null) {
                    put("device", listOf(device.toString()))
                }
                if (deviceOS != null) {
                    put("deviceOS", listOf(deviceOS.toString()))
                }
                if (gender != null) {
                    put("gender", listOf(gender.toString()))
                }
                if (ageGroup != null) {
                    put("ageGroup", listOf(ageGroup.toString()))
                }
                if (country != null) {
                    put("country", listOf(country.toString()))
                }
                if (state != null) {
                    put("state", listOf(state.toString()))
                }
                if (city != null) {
                    put("city", listOf(city.toString()))
                }
                if (zip != null) {
                    put("zip", listOf(zip.toString()))
                }
                if (model != null) {
                    put("model", listOf(model.toString()))
                }
                if (tag != null) {
                    put("tag", listOf(tag.toString()))
                }
                if (userAccountId != null) {
                    put("userAccountId", listOf(userAccountId.toString()))
                }
                if (userAccountDisplay != null) {
                    put("userAccountDisplay", listOf(userAccountDisplay.toString()))
                }
                if (userAccountUsername != null) {
                    put("userAccountUsername", listOf(userAccountUsername.toString()))
                }
                if (groupByRoot != null) {
                    put("groupByRoot", listOf(groupByRoot.value))
                }
                if (groupBy != null) {
                    put("groupBy", listOf(groupBy.value))
                }
                if (distinctCount != null) {
                    put("distinctCount", listOf(distinctCount.value))
                }
                if (sortField != null) {
                    put("sortField", listOf(sortField.value))
                }
                if (descending != null) {
                    put("descending", listOf(descending.toString()))
                }
                if (hideUnknown != null) {
                    put("hideUnknown", listOf(hideUnknown.toString()))
                }
                if (responseFormat != null) {
                    put("responseFormat", listOf(responseFormat.value))
                }
                if (l != null) {
                    put("_l", listOf(l.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (latitude != null) {
                    put("latitude", listOf(latitude.toString()))
                }
                if (longitude != null) {
                    put("longitude", listOf(longitude.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/analytics/aggregatedFilteredUsage",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter groupBy
     */
     enum class GroupByFilteredUsage(val value: kotlin.String) {
         @Json(name = "TAG_COUNT") TAG_COUNT("TAG_COUNT"),
         @Json(name = "TAG") TAG("TAG"),
         @Json(name = "TOKEN") TOKEN("TOKEN"),
         @Json(name = "MODEL") MODEL("MODEL"),
         @Json(name = "DEVICE_TYPE") DEVICE_TYPE("DEVICE_TYPE"),
         @Json(name = "DEVICE") DEVICE("DEVICE"),
         @Json(name = "DEVICE_OS") DEVICE_OS("DEVICE_OS"),
         @Json(name = "DEVICE_ID") DEVICE_ID("DEVICE_ID"),
         @Json(name = "IP_ADDRESS") IP_ADDRESS("IP_ADDRESS"),
         @Json(name = "STATE") STATE("STATE"),
         @Json(name = "CITY") CITY("CITY"),
         @Json(name = "ZIP") ZIP("ZIP"),
         @Json(name = "COUNTRY") COUNTRY("COUNTRY"),
         @Json(name = "CREATED") CREATED("CREATED"),
         @Json(name = "UPDATED") UPDATED("UPDATED"),
         @Json(name = "LAST_UPDATED") LAST_UPDATED("LAST_UPDATED"),
         @Json(name = "CLIENT_TIME") CLIENT_TIME("CLIENT_TIME"),
         @Json(name = "ACTIVE") ACTIVE("ACTIVE"),
         @Json(name = "CUSTOM_ID") CUSTOM_ID("CUSTOM_ID"),
         @Json(name = "CUSTOM_TYPE") CUSTOM_TYPE("CUSTOM_TYPE"),
         @Json(name = "CUSTOM_VALUE") CUSTOM_VALUE("CUSTOM_VALUE"),
         @Json(name = "CUSTOM_VALUE2") CUSTOM_VALUE2("CUSTOM_VALUE2"),
         @Json(name = "CUSTOM_LONG") CUSTOM_LONG("CUSTOM_LONG"),
         @Json(name = "CUSTOM_LONG2") CUSTOM_LONG2("CUSTOM_LONG2"),
         @Json(name = "CUSTOM_MESSAGE") CUSTOM_MESSAGE("CUSTOM_MESSAGE"),
         @Json(name = "CUSTOM_MESSAGE2") CUSTOM_MESSAGE2("CUSTOM_MESSAGE2"),
         @Json(name = "ACCOUNT_ID") ACCOUNT_ID("ACCOUNT_ID"),
         @Json(name = "ACCOUNT_USERNAME") ACCOUNT_USERNAME("ACCOUNT_USERNAME"),
         @Json(name = "ACCOUNT_DISPLAY") ACCOUNT_DISPLAY("ACCOUNT_DISPLAY"),
         @Json(name = "ACCOUNT_CREATED") ACCOUNT_CREATED("ACCOUNT_CREATED"),
         @Json(name = "ACCOUNT_GENDER") ACCOUNT_GENDER("ACCOUNT_GENDER"),
         @Json(name = "ACCOUNT_AGE_GROUP") ACCOUNT_AGE_GROUP("ACCOUNT_AGE_GROUP"),
         @Json(name = "APPLICATION_ID") APPLICATION_ID("APPLICATION_ID"),
         @Json(name = "APPLICATION_KEY") APPLICATION_KEY("APPLICATION_KEY"),
         @Json(name = "APPLICATION_NAME") APPLICATION_NAME("APPLICATION_NAME");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter distinctCount
     */
     enum class DistinctCountFilteredUsage(val value: kotlin.String) {
         @Json(name = "TAG_COUNT") TAG_COUNT("TAG_COUNT"),
         @Json(name = "TAG") TAG("TAG"),
         @Json(name = "TOKEN") TOKEN("TOKEN"),
         @Json(name = "MODEL") MODEL("MODEL"),
         @Json(name = "DEVICE_TYPE") DEVICE_TYPE("DEVICE_TYPE"),
         @Json(name = "DEVICE") DEVICE("DEVICE"),
         @Json(name = "DEVICE_OS") DEVICE_OS("DEVICE_OS"),
         @Json(name = "DEVICE_ID") DEVICE_ID("DEVICE_ID"),
         @Json(name = "IP_ADDRESS") IP_ADDRESS("IP_ADDRESS"),
         @Json(name = "STATE") STATE("STATE"),
         @Json(name = "CITY") CITY("CITY"),
         @Json(name = "ZIP") ZIP("ZIP"),
         @Json(name = "COUNTRY") COUNTRY("COUNTRY"),
         @Json(name = "CREATED") CREATED("CREATED"),
         @Json(name = "UPDATED") UPDATED("UPDATED"),
         @Json(name = "LAST_UPDATED") LAST_UPDATED("LAST_UPDATED"),
         @Json(name = "CLIENT_TIME") CLIENT_TIME("CLIENT_TIME"),
         @Json(name = "ACTIVE") ACTIVE("ACTIVE"),
         @Json(name = "CUSTOM_ID") CUSTOM_ID("CUSTOM_ID"),
         @Json(name = "CUSTOM_TYPE") CUSTOM_TYPE("CUSTOM_TYPE"),
         @Json(name = "CUSTOM_VALUE") CUSTOM_VALUE("CUSTOM_VALUE"),
         @Json(name = "CUSTOM_VALUE2") CUSTOM_VALUE2("CUSTOM_VALUE2"),
         @Json(name = "CUSTOM_LONG") CUSTOM_LONG("CUSTOM_LONG"),
         @Json(name = "CUSTOM_LONG2") CUSTOM_LONG2("CUSTOM_LONG2"),
         @Json(name = "CUSTOM_MESSAGE") CUSTOM_MESSAGE("CUSTOM_MESSAGE"),
         @Json(name = "CUSTOM_MESSAGE2") CUSTOM_MESSAGE2("CUSTOM_MESSAGE2"),
         @Json(name = "ACCOUNT_ID") ACCOUNT_ID("ACCOUNT_ID"),
         @Json(name = "ACCOUNT_USERNAME") ACCOUNT_USERNAME("ACCOUNT_USERNAME"),
         @Json(name = "ACCOUNT_DISPLAY") ACCOUNT_DISPLAY("ACCOUNT_DISPLAY"),
         @Json(name = "ACCOUNT_CREATED") ACCOUNT_CREATED("ACCOUNT_CREATED"),
         @Json(name = "ACCOUNT_GENDER") ACCOUNT_GENDER("ACCOUNT_GENDER"),
         @Json(name = "ACCOUNT_AGE_GROUP") ACCOUNT_AGE_GROUP("ACCOUNT_AGE_GROUP"),
         @Json(name = "APPLICATION_ID") APPLICATION_ID("APPLICATION_ID"),
         @Json(name = "APPLICATION_KEY") APPLICATION_KEY("APPLICATION_KEY"),
         @Json(name = "APPLICATION_NAME") APPLICATION_NAME("APPLICATION_NAME");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter sumColumn
     */
     enum class SumColumnFilteredUsage(val value: kotlin.String) {
         @Json(name = "TAG_COUNT") TAG_COUNT("TAG_COUNT"),
         @Json(name = "TAG") TAG("TAG"),
         @Json(name = "TOKEN") TOKEN("TOKEN"),
         @Json(name = "MODEL") MODEL("MODEL"),
         @Json(name = "DEVICE_TYPE") DEVICE_TYPE("DEVICE_TYPE"),
         @Json(name = "DEVICE") DEVICE("DEVICE"),
         @Json(name = "DEVICE_OS") DEVICE_OS("DEVICE_OS"),
         @Json(name = "DEVICE_ID") DEVICE_ID("DEVICE_ID"),
         @Json(name = "IP_ADDRESS") IP_ADDRESS("IP_ADDRESS"),
         @Json(name = "STATE") STATE("STATE"),
         @Json(name = "CITY") CITY("CITY"),
         @Json(name = "ZIP") ZIP("ZIP"),
         @Json(name = "COUNTRY") COUNTRY("COUNTRY"),
         @Json(name = "CREATED") CREATED("CREATED"),
         @Json(name = "UPDATED") UPDATED("UPDATED"),
         @Json(name = "LAST_UPDATED") LAST_UPDATED("LAST_UPDATED"),
         @Json(name = "CLIENT_TIME") CLIENT_TIME("CLIENT_TIME"),
         @Json(name = "ACTIVE") ACTIVE("ACTIVE"),
         @Json(name = "CUSTOM_ID") CUSTOM_ID("CUSTOM_ID"),
         @Json(name = "CUSTOM_TYPE") CUSTOM_TYPE("CUSTOM_TYPE"),
         @Json(name = "CUSTOM_VALUE") CUSTOM_VALUE("CUSTOM_VALUE"),
         @Json(name = "CUSTOM_VALUE2") CUSTOM_VALUE2("CUSTOM_VALUE2"),
         @Json(name = "CUSTOM_LONG") CUSTOM_LONG("CUSTOM_LONG"),
         @Json(name = "CUSTOM_LONG2") CUSTOM_LONG2("CUSTOM_LONG2"),
         @Json(name = "CUSTOM_MESSAGE") CUSTOM_MESSAGE("CUSTOM_MESSAGE"),
         @Json(name = "CUSTOM_MESSAGE2") CUSTOM_MESSAGE2("CUSTOM_MESSAGE2"),
         @Json(name = "ACCOUNT_ID") ACCOUNT_ID("ACCOUNT_ID"),
         @Json(name = "ACCOUNT_USERNAME") ACCOUNT_USERNAME("ACCOUNT_USERNAME"),
         @Json(name = "ACCOUNT_DISPLAY") ACCOUNT_DISPLAY("ACCOUNT_DISPLAY"),
         @Json(name = "ACCOUNT_CREATED") ACCOUNT_CREATED("ACCOUNT_CREATED"),
         @Json(name = "ACCOUNT_GENDER") ACCOUNT_GENDER("ACCOUNT_GENDER"),
         @Json(name = "ACCOUNT_AGE_GROUP") ACCOUNT_AGE_GROUP("ACCOUNT_AGE_GROUP"),
         @Json(name = "APPLICATION_ID") APPLICATION_ID("APPLICATION_ID"),
         @Json(name = "APPLICATION_KEY") APPLICATION_KEY("APPLICATION_KEY"),
         @Json(name = "APPLICATION_NAME") APPLICATION_NAME("APPLICATION_NAME");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter sortField
     */
     enum class SortFieldFilteredUsage(val value: kotlin.String) {
         @Json(name = "TAG_COUNT") TAG_COUNT("TAG_COUNT"),
         @Json(name = "TAG") TAG("TAG"),
         @Json(name = "TOKEN") TOKEN("TOKEN"),
         @Json(name = "MODEL") MODEL("MODEL"),
         @Json(name = "DEVICE_TYPE") DEVICE_TYPE("DEVICE_TYPE"),
         @Json(name = "DEVICE") DEVICE("DEVICE"),
         @Json(name = "DEVICE_OS") DEVICE_OS("DEVICE_OS"),
         @Json(name = "DEVICE_ID") DEVICE_ID("DEVICE_ID"),
         @Json(name = "IP_ADDRESS") IP_ADDRESS("IP_ADDRESS"),
         @Json(name = "STATE") STATE("STATE"),
         @Json(name = "CITY") CITY("CITY"),
         @Json(name = "ZIP") ZIP("ZIP"),
         @Json(name = "COUNTRY") COUNTRY("COUNTRY"),
         @Json(name = "CREATED") CREATED("CREATED"),
         @Json(name = "UPDATED") UPDATED("UPDATED"),
         @Json(name = "LAST_UPDATED") LAST_UPDATED("LAST_UPDATED"),
         @Json(name = "CLIENT_TIME") CLIENT_TIME("CLIENT_TIME"),
         @Json(name = "ACTIVE") ACTIVE("ACTIVE"),
         @Json(name = "CUSTOM_ID") CUSTOM_ID("CUSTOM_ID"),
         @Json(name = "CUSTOM_TYPE") CUSTOM_TYPE("CUSTOM_TYPE"),
         @Json(name = "CUSTOM_VALUE") CUSTOM_VALUE("CUSTOM_VALUE"),
         @Json(name = "CUSTOM_VALUE2") CUSTOM_VALUE2("CUSTOM_VALUE2"),
         @Json(name = "CUSTOM_LONG") CUSTOM_LONG("CUSTOM_LONG"),
         @Json(name = "CUSTOM_LONG2") CUSTOM_LONG2("CUSTOM_LONG2"),
         @Json(name = "CUSTOM_MESSAGE") CUSTOM_MESSAGE("CUSTOM_MESSAGE"),
         @Json(name = "CUSTOM_MESSAGE2") CUSTOM_MESSAGE2("CUSTOM_MESSAGE2"),
         @Json(name = "ACCOUNT_ID") ACCOUNT_ID("ACCOUNT_ID"),
         @Json(name = "ACCOUNT_USERNAME") ACCOUNT_USERNAME("ACCOUNT_USERNAME"),
         @Json(name = "ACCOUNT_DISPLAY") ACCOUNT_DISPLAY("ACCOUNT_DISPLAY"),
         @Json(name = "ACCOUNT_CREATED") ACCOUNT_CREATED("ACCOUNT_CREATED"),
         @Json(name = "ACCOUNT_GENDER") ACCOUNT_GENDER("ACCOUNT_GENDER"),
         @Json(name = "ACCOUNT_AGE_GROUP") ACCOUNT_AGE_GROUP("ACCOUNT_AGE_GROUP"),
         @Json(name = "APPLICATION_ID") APPLICATION_ID("APPLICATION_ID"),
         @Json(name = "APPLICATION_KEY") APPLICATION_KEY("APPLICATION_KEY"),
         @Json(name = "APPLICATION_NAME") APPLICATION_NAME("APPLICATION_NAME");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter responseFormat
     */
     enum class ResponseFormatFilteredUsage(val value: kotlin.String) {
         @Json(name = "HTML") HTML("HTML"),
         @Json(name = "XML") XML("XML"),
         @Json(name = "JSON") JSON("JSON"),
         @Json(name = "CSV") CSV("CSV");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /analytics/filteredUsage
     * Get Filtered Usage
     * Query analytics to get data used for graphs and charts
     * @param deviceId The unique id of the device making the request (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param applicationId This parameter is deprecated. (optional)
     * @param appKey The application key used to filter results by application (optional)
     * @param startDate Used to search for results after or equal to this date (UNIX time-stamp in milliseconds) (optional)
     * @param endDate Used to search for results before or equal to this date (UNIX time-stamp in milliseconds) (optional)
     * @param deviceType The device type to filter results by (performs a LIKE search) (optional)
     * @param device The device to filter results by (performs a LIKE search) (optional)
     * @param deviceOS The device OS to filter results by (performs a LIKE search) (optional)
     * @param gender The gender to filter results by {MALE, FEMALE} (optional)
     * @param ageGroup Comma separated list of age groups to filter by {AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS} (optional)
     * @param country The country to filter results by (performs a wild-card search) (optional)
     * @param state The state to filter results by (performs a wild-card search) (optional)
     * @param city The city to filter results by (performs a wild-card search) (optional)
     * @param zip The zip to filter results by (performs a wild-card search) (optional)
     * @param model The model to filter results by (performs a wild-card search) (optional)
     * @param tag The tag to filter results by (performs a wild-card search) (optional)
     * @param userAccountId The account id to filter results for a particular user (optional)
     * @param userAccountDisplay The user display to filter results by (performs a wild-card search) (optional)
     * @param userAccountUsername The username to filter results by (performs a wild-card search) (optional)
     * @param customId The ID for the custom table column (optional)
     * @param customType The type defined for the custom table column (optional)
     * @param customValue The value for the custom table column (optional)
     * @param customValue2 The value for another custom table column (optional)
     * @param customLong The value that supports Longs for custom table column (optional)
     * @param customLong2 The value that supports Longs for custom table column (optional)
     * @param customMessage The message for the custom table column (optional)
     * @param customMessage2 The message for the custom table column (optional)
     * @param groupBy Determines how to group results. For example, passing in &#39;CREATED&#39; will return results by date. Passing in &#39;ACCOUNT&#39; will return results by user {TAG, CUSTOM_ID, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, DEVICE_ID, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, ACCOUNT, APPLICATION_ID} (optional)
     * @param distinctCount Performs a unique query on the specified column. For example, passing in &#39;ACCOUNT&#39; will return the number of unique users. {TAG, CUSTOM_ID, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, DEVICE_ID, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, ACCOUNT, APPLICATION_ID} (optional)
     * @param sumColumn sum of the column values (optional)
     * @param sortField Determines whether the results will be sorted by day or by number of hits {CREATED, TAG_COUNT} (optional)
     * @param descending Determines whether to return results in descending order (optional)
     * @param hideUnknown Determines whether to return data that has empty or unknown values (optional)
     * @param responseFormat Determines whether to return a JOSN or XML representation of the graph results (optional)
     * @param l This parameter is deprecated. (optional)
     * @param limit Used to limit results to get a cleaner graph. The results that gets filtered out will be combined (optional)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @return ChartData
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun filteredUsage(deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, applicationId: kotlin.Long? = null, appKey: kotlin.String? = null, startDate: kotlin.Long? = null, endDate: kotlin.Long? = null, deviceType: kotlin.String? = null, device: kotlin.String? = null, deviceOS: kotlin.String? = null, gender: kotlin.String? = null, ageGroup: kotlin.String? = null, country: kotlin.String? = null, state: kotlin.String? = null, city: kotlin.String? = null, zip: kotlin.String? = null, model: kotlin.String? = null, tag: kotlin.String? = null, userAccountId: kotlin.Long? = null, userAccountDisplay: kotlin.String? = null, userAccountUsername: kotlin.String? = null, customId: kotlin.Long? = null, customType: kotlin.String? = null, customValue: kotlin.Double? = null, customValue2: kotlin.Double? = null, customLong: kotlin.Long? = null, customLong2: kotlin.Long? = null, customMessage: kotlin.String? = null, customMessage2: kotlin.String? = null, groupBy: GroupByFilteredUsage? = null, distinctCount: DistinctCountFilteredUsage? = null, sumColumn: SumColumnFilteredUsage? = null, sortField: SortFieldFilteredUsage? = null, descending: kotlin.Boolean? = null, hideUnknown: kotlin.Boolean? = null, responseFormat: ResponseFormatFilteredUsage? = null, l: kotlin.Int? = null, limit: kotlin.Int? = null, latitude: kotlin.Double? = null, longitude: kotlin.Double? = null) : ChartData {
        val localVarResponse = filteredUsageWithHttpInfo(deviceId = deviceId, accountId = accountId, applicationId = applicationId, appKey = appKey, startDate = startDate, endDate = endDate, deviceType = deviceType, device = device, deviceOS = deviceOS, gender = gender, ageGroup = ageGroup, country = country, state = state, city = city, zip = zip, model = model, tag = tag, userAccountId = userAccountId, userAccountDisplay = userAccountDisplay, userAccountUsername = userAccountUsername, customId = customId, customType = customType, customValue = customValue, customValue2 = customValue2, customLong = customLong, customLong2 = customLong2, customMessage = customMessage, customMessage2 = customMessage2, groupBy = groupBy, distinctCount = distinctCount, sumColumn = sumColumn, sortField = sortField, descending = descending, hideUnknown = hideUnknown, responseFormat = responseFormat, l = l, limit = limit, latitude = latitude, longitude = longitude)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ChartData
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /analytics/filteredUsage
     * Get Filtered Usage
     * Query analytics to get data used for graphs and charts
     * @param deviceId The unique id of the device making the request (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param applicationId This parameter is deprecated. (optional)
     * @param appKey The application key used to filter results by application (optional)
     * @param startDate Used to search for results after or equal to this date (UNIX time-stamp in milliseconds) (optional)
     * @param endDate Used to search for results before or equal to this date (UNIX time-stamp in milliseconds) (optional)
     * @param deviceType The device type to filter results by (performs a LIKE search) (optional)
     * @param device The device to filter results by (performs a LIKE search) (optional)
     * @param deviceOS The device OS to filter results by (performs a LIKE search) (optional)
     * @param gender The gender to filter results by {MALE, FEMALE} (optional)
     * @param ageGroup Comma separated list of age groups to filter by {AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS} (optional)
     * @param country The country to filter results by (performs a wild-card search) (optional)
     * @param state The state to filter results by (performs a wild-card search) (optional)
     * @param city The city to filter results by (performs a wild-card search) (optional)
     * @param zip The zip to filter results by (performs a wild-card search) (optional)
     * @param model The model to filter results by (performs a wild-card search) (optional)
     * @param tag The tag to filter results by (performs a wild-card search) (optional)
     * @param userAccountId The account id to filter results for a particular user (optional)
     * @param userAccountDisplay The user display to filter results by (performs a wild-card search) (optional)
     * @param userAccountUsername The username to filter results by (performs a wild-card search) (optional)
     * @param customId The ID for the custom table column (optional)
     * @param customType The type defined for the custom table column (optional)
     * @param customValue The value for the custom table column (optional)
     * @param customValue2 The value for another custom table column (optional)
     * @param customLong The value that supports Longs for custom table column (optional)
     * @param customLong2 The value that supports Longs for custom table column (optional)
     * @param customMessage The message for the custom table column (optional)
     * @param customMessage2 The message for the custom table column (optional)
     * @param groupBy Determines how to group results. For example, passing in &#39;CREATED&#39; will return results by date. Passing in &#39;ACCOUNT&#39; will return results by user {TAG, CUSTOM_ID, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, DEVICE_ID, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, ACCOUNT, APPLICATION_ID} (optional)
     * @param distinctCount Performs a unique query on the specified column. For example, passing in &#39;ACCOUNT&#39; will return the number of unique users. {TAG, CUSTOM_ID, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, DEVICE_ID, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, ACCOUNT, APPLICATION_ID} (optional)
     * @param sumColumn sum of the column values (optional)
     * @param sortField Determines whether the results will be sorted by day or by number of hits {CREATED, TAG_COUNT} (optional)
     * @param descending Determines whether to return results in descending order (optional)
     * @param hideUnknown Determines whether to return data that has empty or unknown values (optional)
     * @param responseFormat Determines whether to return a JOSN or XML representation of the graph results (optional)
     * @param l This parameter is deprecated. (optional)
     * @param limit Used to limit results to get a cleaner graph. The results that gets filtered out will be combined (optional)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @return ApiResponse<ChartData?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun filteredUsageWithHttpInfo(deviceId: kotlin.String?, accountId: kotlin.Long?, applicationId: kotlin.Long?, appKey: kotlin.String?, startDate: kotlin.Long?, endDate: kotlin.Long?, deviceType: kotlin.String?, device: kotlin.String?, deviceOS: kotlin.String?, gender: kotlin.String?, ageGroup: kotlin.String?, country: kotlin.String?, state: kotlin.String?, city: kotlin.String?, zip: kotlin.String?, model: kotlin.String?, tag: kotlin.String?, userAccountId: kotlin.Long?, userAccountDisplay: kotlin.String?, userAccountUsername: kotlin.String?, customId: kotlin.Long?, customType: kotlin.String?, customValue: kotlin.Double?, customValue2: kotlin.Double?, customLong: kotlin.Long?, customLong2: kotlin.Long?, customMessage: kotlin.String?, customMessage2: kotlin.String?, groupBy: GroupByFilteredUsage?, distinctCount: DistinctCountFilteredUsage?, sumColumn: SumColumnFilteredUsage?, sortField: SortFieldFilteredUsage?, descending: kotlin.Boolean?, hideUnknown: kotlin.Boolean?, responseFormat: ResponseFormatFilteredUsage?, l: kotlin.Int?, limit: kotlin.Int?, latitude: kotlin.Double?, longitude: kotlin.Double?) : ApiResponse<ChartData?> {
        val localVariableConfig = filteredUsageRequestConfig(deviceId = deviceId, accountId = accountId, applicationId = applicationId, appKey = appKey, startDate = startDate, endDate = endDate, deviceType = deviceType, device = device, deviceOS = deviceOS, gender = gender, ageGroup = ageGroup, country = country, state = state, city = city, zip = zip, model = model, tag = tag, userAccountId = userAccountId, userAccountDisplay = userAccountDisplay, userAccountUsername = userAccountUsername, customId = customId, customType = customType, customValue = customValue, customValue2 = customValue2, customLong = customLong, customLong2 = customLong2, customMessage = customMessage, customMessage2 = customMessage2, groupBy = groupBy, distinctCount = distinctCount, sumColumn = sumColumn, sortField = sortField, descending = descending, hideUnknown = hideUnknown, responseFormat = responseFormat, l = l, limit = limit, latitude = latitude, longitude = longitude)

        return request<Unit, ChartData>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation filteredUsage
     *
     * @param deviceId The unique id of the device making the request (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param applicationId This parameter is deprecated. (optional)
     * @param appKey The application key used to filter results by application (optional)
     * @param startDate Used to search for results after or equal to this date (UNIX time-stamp in milliseconds) (optional)
     * @param endDate Used to search for results before or equal to this date (UNIX time-stamp in milliseconds) (optional)
     * @param deviceType The device type to filter results by (performs a LIKE search) (optional)
     * @param device The device to filter results by (performs a LIKE search) (optional)
     * @param deviceOS The device OS to filter results by (performs a LIKE search) (optional)
     * @param gender The gender to filter results by {MALE, FEMALE} (optional)
     * @param ageGroup Comma separated list of age groups to filter by {AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS} (optional)
     * @param country The country to filter results by (performs a wild-card search) (optional)
     * @param state The state to filter results by (performs a wild-card search) (optional)
     * @param city The city to filter results by (performs a wild-card search) (optional)
     * @param zip The zip to filter results by (performs a wild-card search) (optional)
     * @param model The model to filter results by (performs a wild-card search) (optional)
     * @param tag The tag to filter results by (performs a wild-card search) (optional)
     * @param userAccountId The account id to filter results for a particular user (optional)
     * @param userAccountDisplay The user display to filter results by (performs a wild-card search) (optional)
     * @param userAccountUsername The username to filter results by (performs a wild-card search) (optional)
     * @param customId The ID for the custom table column (optional)
     * @param customType The type defined for the custom table column (optional)
     * @param customValue The value for the custom table column (optional)
     * @param customValue2 The value for another custom table column (optional)
     * @param customLong The value that supports Longs for custom table column (optional)
     * @param customLong2 The value that supports Longs for custom table column (optional)
     * @param customMessage The message for the custom table column (optional)
     * @param customMessage2 The message for the custom table column (optional)
     * @param groupBy Determines how to group results. For example, passing in &#39;CREATED&#39; will return results by date. Passing in &#39;ACCOUNT&#39; will return results by user {TAG, CUSTOM_ID, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, DEVICE_ID, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, ACCOUNT, APPLICATION_ID} (optional)
     * @param distinctCount Performs a unique query on the specified column. For example, passing in &#39;ACCOUNT&#39; will return the number of unique users. {TAG, CUSTOM_ID, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, DEVICE_ID, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, ACCOUNT, APPLICATION_ID} (optional)
     * @param sumColumn sum of the column values (optional)
     * @param sortField Determines whether the results will be sorted by day or by number of hits {CREATED, TAG_COUNT} (optional)
     * @param descending Determines whether to return results in descending order (optional)
     * @param hideUnknown Determines whether to return data that has empty or unknown values (optional)
     * @param responseFormat Determines whether to return a JOSN or XML representation of the graph results (optional)
     * @param l This parameter is deprecated. (optional)
     * @param limit Used to limit results to get a cleaner graph. The results that gets filtered out will be combined (optional)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @return RequestConfig
     */
    fun filteredUsageRequestConfig(deviceId: kotlin.String?, accountId: kotlin.Long?, applicationId: kotlin.Long?, appKey: kotlin.String?, startDate: kotlin.Long?, endDate: kotlin.Long?, deviceType: kotlin.String?, device: kotlin.String?, deviceOS: kotlin.String?, gender: kotlin.String?, ageGroup: kotlin.String?, country: kotlin.String?, state: kotlin.String?, city: kotlin.String?, zip: kotlin.String?, model: kotlin.String?, tag: kotlin.String?, userAccountId: kotlin.Long?, userAccountDisplay: kotlin.String?, userAccountUsername: kotlin.String?, customId: kotlin.Long?, customType: kotlin.String?, customValue: kotlin.Double?, customValue2: kotlin.Double?, customLong: kotlin.Long?, customLong2: kotlin.Long?, customMessage: kotlin.String?, customMessage2: kotlin.String?, groupBy: GroupByFilteredUsage?, distinctCount: DistinctCountFilteredUsage?, sumColumn: SumColumnFilteredUsage?, sortField: SortFieldFilteredUsage?, descending: kotlin.Boolean?, hideUnknown: kotlin.Boolean?, responseFormat: ResponseFormatFilteredUsage?, l: kotlin.Int?, limit: kotlin.Int?, latitude: kotlin.Double?, longitude: kotlin.Double?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (applicationId != null) {
                    put("applicationId", listOf(applicationId.toString()))
                }
                if (appKey != null) {
                    put("appKey", listOf(appKey.toString()))
                }
                if (startDate != null) {
                    put("startDate", listOf(startDate.toString()))
                }
                if (endDate != null) {
                    put("endDate", listOf(endDate.toString()))
                }
                if (deviceType != null) {
                    put("deviceType", listOf(deviceType.toString()))
                }
                if (device != null) {
                    put("device", listOf(device.toString()))
                }
                if (deviceOS != null) {
                    put("deviceOS", listOf(deviceOS.toString()))
                }
                if (gender != null) {
                    put("gender", listOf(gender.toString()))
                }
                if (ageGroup != null) {
                    put("ageGroup", listOf(ageGroup.toString()))
                }
                if (country != null) {
                    put("country", listOf(country.toString()))
                }
                if (state != null) {
                    put("state", listOf(state.toString()))
                }
                if (city != null) {
                    put("city", listOf(city.toString()))
                }
                if (zip != null) {
                    put("zip", listOf(zip.toString()))
                }
                if (model != null) {
                    put("model", listOf(model.toString()))
                }
                if (tag != null) {
                    put("tag", listOf(tag.toString()))
                }
                if (userAccountId != null) {
                    put("userAccountId", listOf(userAccountId.toString()))
                }
                if (userAccountDisplay != null) {
                    put("userAccountDisplay", listOf(userAccountDisplay.toString()))
                }
                if (userAccountUsername != null) {
                    put("userAccountUsername", listOf(userAccountUsername.toString()))
                }
                if (customId != null) {
                    put("customId", listOf(customId.toString()))
                }
                if (customType != null) {
                    put("customType", listOf(customType.toString()))
                }
                if (customValue != null) {
                    put("customValue", listOf(customValue.toString()))
                }
                if (customValue2 != null) {
                    put("customValue2", listOf(customValue2.toString()))
                }
                if (customLong != null) {
                    put("customLong", listOf(customLong.toString()))
                }
                if (customLong2 != null) {
                    put("customLong2", listOf(customLong2.toString()))
                }
                if (customMessage != null) {
                    put("customMessage", listOf(customMessage.toString()))
                }
                if (customMessage2 != null) {
                    put("customMessage2", listOf(customMessage2.toString()))
                }
                if (groupBy != null) {
                    put("groupBy", listOf(groupBy.value))
                }
                if (distinctCount != null) {
                    put("distinctCount", listOf(distinctCount.value))
                }
                if (sumColumn != null) {
                    put("sumColumn", listOf(sumColumn.value))
                }
                if (sortField != null) {
                    put("sortField", listOf(sortField.value))
                }
                if (descending != null) {
                    put("descending", listOf(descending.toString()))
                }
                if (hideUnknown != null) {
                    put("hideUnknown", listOf(hideUnknown.toString()))
                }
                if (responseFormat != null) {
                    put("responseFormat", listOf(responseFormat.value))
                }
                if (l != null) {
                    put("_l", listOf(l.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (latitude != null) {
                    put("latitude", listOf(latitude.toString()))
                }
                if (longitude != null) {
                    put("longitude", listOf(longitude.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/analytics/filteredUsage",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /analytics/usage
     * Create Usage Record
     * Record an analytic record for a known state within the application.
     * @param tag The tag to apply: the name of the action or thing being logged.
     * @param deviceId The client deviceID (optional)
     * @param accountId The logged in user ID (optional)
     * @param applicationId This parameter is deprecated. This is deprecated, use appKey. (optional)
     * @param appKey The application key unique to each application. (optional)
     * @param appVersion The current build version of the application (optional)
     * @param device The name of the device being used (iPhone5,1 , HTC Nexus One, x86_64, etc.) (optional)
     * @param deviceType The type of device (Handheld or Desktop) (optional)
     * @param deviceOS The operating system that the device is using (iPhone OS 5.0, Android OS 2.3.6, Windows 7 Service Pack 1, etc) (optional)
     * @param model The model of the device (iPhone5,1 , Nexus One, etc.) (optional)
     * @param latitude The current position of the user (optional)
     * @param longitude The current position of the user (optional)
     * @param customId A customId used to associate the usage record with some other record in the system (optional)
     * @param customType The type of record the customId is recorded for (optional)
     * @param achievementIncrement This parameter is deprecated. This is deprecated, use \&quot;customValue\&quot;. Determines how many achievement points and/or ranking points the user gets if this analytic is associated with an achievement (optional)
     * @param city The current city of the user (optional)
     * @param state The current state of the user (optional)
     * @param country The current country of the user (optional)
     * @param zip The current zip of the user (optional)
     * @param locationDescription The general description of the user&#39;s location (optional)
     * @param clientTime Timestamp sent from device (optional)
     * @param errorMessage This parameter is deprecated. (optional)
     * @param ip the ip address of the client device (optional)
     * @param userAgent this is a description of the client (might contain the device&#39;s OS, browser version etc - its a common term) (optional)
     * @param backgroundEvent This is deprecated. (optional)
     * @param customMessage a custom message for the usage record (optional)
     * @param customMessage2 a custom message for the usage record (optional)
     * @param customValue a custom value for the usage record (optional)
     * @param customValue2 a custom value for the usage record (optional)
     * @param customLong a custom long value for the usage record (optional)
     * @param customLong2 a custom long value for the usage record (optional)
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun usage(tag: kotlin.String, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, applicationId: kotlin.Long? = null, appKey: kotlin.String? = null, appVersion: kotlin.String? = null, device: kotlin.String? = null, deviceType: kotlin.String? = null, deviceOS: kotlin.String? = null, model: kotlin.String? = null, latitude: kotlin.Double? = null, longitude: kotlin.Double? = null, customId: kotlin.Long? = null, customType: kotlin.String? = null, achievementIncrement: kotlin.Long? = null, city: kotlin.String? = null, state: kotlin.String? = null, country: kotlin.String? = null, zip: kotlin.String? = null, locationDescription: kotlin.String? = null, clientTime: kotlin.Long? = null, errorMessage: kotlin.String? = null, ip: kotlin.String? = null, userAgent: kotlin.String? = null, backgroundEvent: kotlin.Boolean? = null, customMessage: kotlin.String? = null, customMessage2: kotlin.String? = null, customValue: kotlin.Double? = null, customValue2: kotlin.Double? = null, customLong: kotlin.Long? = null, customLong2: kotlin.Long? = null) : SirqulResponse {
        val localVarResponse = usageWithHttpInfo(tag = tag, deviceId = deviceId, accountId = accountId, applicationId = applicationId, appKey = appKey, appVersion = appVersion, device = device, deviceType = deviceType, deviceOS = deviceOS, model = model, latitude = latitude, longitude = longitude, customId = customId, customType = customType, achievementIncrement = achievementIncrement, city = city, state = state, country = country, zip = zip, locationDescription = locationDescription, clientTime = clientTime, errorMessage = errorMessage, ip = ip, userAgent = userAgent, backgroundEvent = backgroundEvent, customMessage = customMessage, customMessage2 = customMessage2, customValue = customValue, customValue2 = customValue2, customLong = customLong, customLong2 = customLong2)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /analytics/usage
     * Create Usage Record
     * Record an analytic record for a known state within the application.
     * @param tag The tag to apply: the name of the action or thing being logged.
     * @param deviceId The client deviceID (optional)
     * @param accountId The logged in user ID (optional)
     * @param applicationId This parameter is deprecated. This is deprecated, use appKey. (optional)
     * @param appKey The application key unique to each application. (optional)
     * @param appVersion The current build version of the application (optional)
     * @param device The name of the device being used (iPhone5,1 , HTC Nexus One, x86_64, etc.) (optional)
     * @param deviceType The type of device (Handheld or Desktop) (optional)
     * @param deviceOS The operating system that the device is using (iPhone OS 5.0, Android OS 2.3.6, Windows 7 Service Pack 1, etc) (optional)
     * @param model The model of the device (iPhone5,1 , Nexus One, etc.) (optional)
     * @param latitude The current position of the user (optional)
     * @param longitude The current position of the user (optional)
     * @param customId A customId used to associate the usage record with some other record in the system (optional)
     * @param customType The type of record the customId is recorded for (optional)
     * @param achievementIncrement This parameter is deprecated. This is deprecated, use \&quot;customValue\&quot;. Determines how many achievement points and/or ranking points the user gets if this analytic is associated with an achievement (optional)
     * @param city The current city of the user (optional)
     * @param state The current state of the user (optional)
     * @param country The current country of the user (optional)
     * @param zip The current zip of the user (optional)
     * @param locationDescription The general description of the user&#39;s location (optional)
     * @param clientTime Timestamp sent from device (optional)
     * @param errorMessage This parameter is deprecated. (optional)
     * @param ip the ip address of the client device (optional)
     * @param userAgent this is a description of the client (might contain the device&#39;s OS, browser version etc - its a common term) (optional)
     * @param backgroundEvent This is deprecated. (optional)
     * @param customMessage a custom message for the usage record (optional)
     * @param customMessage2 a custom message for the usage record (optional)
     * @param customValue a custom value for the usage record (optional)
     * @param customValue2 a custom value for the usage record (optional)
     * @param customLong a custom long value for the usage record (optional)
     * @param customLong2 a custom long value for the usage record (optional)
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun usageWithHttpInfo(tag: kotlin.String, deviceId: kotlin.String?, accountId: kotlin.Long?, applicationId: kotlin.Long?, appKey: kotlin.String?, appVersion: kotlin.String?, device: kotlin.String?, deviceType: kotlin.String?, deviceOS: kotlin.String?, model: kotlin.String?, latitude: kotlin.Double?, longitude: kotlin.Double?, customId: kotlin.Long?, customType: kotlin.String?, achievementIncrement: kotlin.Long?, city: kotlin.String?, state: kotlin.String?, country: kotlin.String?, zip: kotlin.String?, locationDescription: kotlin.String?, clientTime: kotlin.Long?, errorMessage: kotlin.String?, ip: kotlin.String?, userAgent: kotlin.String?, backgroundEvent: kotlin.Boolean?, customMessage: kotlin.String?, customMessage2: kotlin.String?, customValue: kotlin.Double?, customValue2: kotlin.Double?, customLong: kotlin.Long?, customLong2: kotlin.Long?) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = usageRequestConfig(tag = tag, deviceId = deviceId, accountId = accountId, applicationId = applicationId, appKey = appKey, appVersion = appVersion, device = device, deviceType = deviceType, deviceOS = deviceOS, model = model, latitude = latitude, longitude = longitude, customId = customId, customType = customType, achievementIncrement = achievementIncrement, city = city, state = state, country = country, zip = zip, locationDescription = locationDescription, clientTime = clientTime, errorMessage = errorMessage, ip = ip, userAgent = userAgent, backgroundEvent = backgroundEvent, customMessage = customMessage, customMessage2 = customMessage2, customValue = customValue, customValue2 = customValue2, customLong = customLong, customLong2 = customLong2)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation usage
     *
     * @param tag The tag to apply: the name of the action or thing being logged.
     * @param deviceId The client deviceID (optional)
     * @param accountId The logged in user ID (optional)
     * @param applicationId This parameter is deprecated. This is deprecated, use appKey. (optional)
     * @param appKey The application key unique to each application. (optional)
     * @param appVersion The current build version of the application (optional)
     * @param device The name of the device being used (iPhone5,1 , HTC Nexus One, x86_64, etc.) (optional)
     * @param deviceType The type of device (Handheld or Desktop) (optional)
     * @param deviceOS The operating system that the device is using (iPhone OS 5.0, Android OS 2.3.6, Windows 7 Service Pack 1, etc) (optional)
     * @param model The model of the device (iPhone5,1 , Nexus One, etc.) (optional)
     * @param latitude The current position of the user (optional)
     * @param longitude The current position of the user (optional)
     * @param customId A customId used to associate the usage record with some other record in the system (optional)
     * @param customType The type of record the customId is recorded for (optional)
     * @param achievementIncrement This parameter is deprecated. This is deprecated, use \&quot;customValue\&quot;. Determines how many achievement points and/or ranking points the user gets if this analytic is associated with an achievement (optional)
     * @param city The current city of the user (optional)
     * @param state The current state of the user (optional)
     * @param country The current country of the user (optional)
     * @param zip The current zip of the user (optional)
     * @param locationDescription The general description of the user&#39;s location (optional)
     * @param clientTime Timestamp sent from device (optional)
     * @param errorMessage This parameter is deprecated. (optional)
     * @param ip the ip address of the client device (optional)
     * @param userAgent this is a description of the client (might contain the device&#39;s OS, browser version etc - its a common term) (optional)
     * @param backgroundEvent This is deprecated. (optional)
     * @param customMessage a custom message for the usage record (optional)
     * @param customMessage2 a custom message for the usage record (optional)
     * @param customValue a custom value for the usage record (optional)
     * @param customValue2 a custom value for the usage record (optional)
     * @param customLong a custom long value for the usage record (optional)
     * @param customLong2 a custom long value for the usage record (optional)
     * @return RequestConfig
     */
    fun usageRequestConfig(tag: kotlin.String, deviceId: kotlin.String?, accountId: kotlin.Long?, applicationId: kotlin.Long?, appKey: kotlin.String?, appVersion: kotlin.String?, device: kotlin.String?, deviceType: kotlin.String?, deviceOS: kotlin.String?, model: kotlin.String?, latitude: kotlin.Double?, longitude: kotlin.Double?, customId: kotlin.Long?, customType: kotlin.String?, achievementIncrement: kotlin.Long?, city: kotlin.String?, state: kotlin.String?, country: kotlin.String?, zip: kotlin.String?, locationDescription: kotlin.String?, clientTime: kotlin.Long?, errorMessage: kotlin.String?, ip: kotlin.String?, userAgent: kotlin.String?, backgroundEvent: kotlin.Boolean?, customMessage: kotlin.String?, customMessage2: kotlin.String?, customValue: kotlin.Double?, customValue2: kotlin.Double?, customLong: kotlin.Long?, customLong2: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("tag", listOf(tag.toString()))
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (applicationId != null) {
                    put("applicationId", listOf(applicationId.toString()))
                }
                if (appKey != null) {
                    put("appKey", listOf(appKey.toString()))
                }
                if (appVersion != null) {
                    put("appVersion", listOf(appVersion.toString()))
                }
                if (device != null) {
                    put("device", listOf(device.toString()))
                }
                if (deviceType != null) {
                    put("deviceType", listOf(deviceType.toString()))
                }
                if (deviceOS != null) {
                    put("deviceOS", listOf(deviceOS.toString()))
                }
                if (model != null) {
                    put("model", listOf(model.toString()))
                }
                if (latitude != null) {
                    put("latitude", listOf(latitude.toString()))
                }
                if (longitude != null) {
                    put("longitude", listOf(longitude.toString()))
                }
                if (customId != null) {
                    put("customId", listOf(customId.toString()))
                }
                if (customType != null) {
                    put("customType", listOf(customType.toString()))
                }
                if (achievementIncrement != null) {
                    put("achievementIncrement", listOf(achievementIncrement.toString()))
                }
                if (city != null) {
                    put("city", listOf(city.toString()))
                }
                if (state != null) {
                    put("state", listOf(state.toString()))
                }
                if (country != null) {
                    put("country", listOf(country.toString()))
                }
                if (zip != null) {
                    put("zip", listOf(zip.toString()))
                }
                if (locationDescription != null) {
                    put("locationDescription", listOf(locationDescription.toString()))
                }
                if (clientTime != null) {
                    put("clientTime", listOf(clientTime.toString()))
                }
                if (errorMessage != null) {
                    put("errorMessage", listOf(errorMessage.toString()))
                }
                if (ip != null) {
                    put("ip", listOf(ip.toString()))
                }
                if (userAgent != null) {
                    put("userAgent", listOf(userAgent.toString()))
                }
                if (backgroundEvent != null) {
                    put("backgroundEvent", listOf(backgroundEvent.toString()))
                }
                if (customMessage != null) {
                    put("customMessage", listOf(customMessage.toString()))
                }
                if (customMessage2 != null) {
                    put("customMessage2", listOf(customMessage2.toString()))
                }
                if (customValue != null) {
                    put("customValue", listOf(customValue.toString()))
                }
                if (customValue2 != null) {
                    put("customValue2", listOf(customValue2.toString()))
                }
                if (customLong != null) {
                    put("customLong", listOf(customLong.toString()))
                }
                if (customLong2 != null) {
                    put("customLong2", listOf(customLong2.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/analytics/usage",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /analytics/usage/batch
     * Create Multiple Usage Records
     * Sends multiple analytics. Can be used to send in the user&#39;s stored usage when they did not have internet access. Should not include more than 100 items per batch.
     * @param appKey The application key unique to each application.
     * @param device The name of the device being used (iPhone5,1 , HTC Nexus One, x86_64, etc.)
     * @param `data` The analytic data AnalyticListResponse
     * @param deviceId The unique id of the device making the request (optional)
     * @param accountId The account ID of the logged in user making the request (optional)
     * @param appVersion The current build version of the application (optional)
     * @param deviceType The type of device (Handheld or Desktop) (optional)
     * @param deviceOS The operating system that the device is using (iPhone OS 5.0, Android OS 2.3.6, Windows 7 Service Pack 1, etc.) (optional)
     * @param model The model of the device (iPhone5,1 , Nexus One, etc.) (optional)
     * @param updateRanking Will create a leaderboard if one does not exist for the \&quot;tag\&quot; yet (optional)
     * @param returnSummaryResponse Returns a summary response of the achievements that have been completed due to the analytics (optional)
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun usageBatch(appKey: kotlin.String, device: kotlin.String, `data`: kotlin.String, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, appVersion: kotlin.String? = null, deviceType: kotlin.String? = null, deviceOS: kotlin.String? = null, model: kotlin.String? = null, updateRanking: kotlin.Boolean? = null, returnSummaryResponse: kotlin.Boolean? = null) : SirqulResponse {
        val localVarResponse = usageBatchWithHttpInfo(appKey = appKey, device = device, `data` = `data`, deviceId = deviceId, accountId = accountId, appVersion = appVersion, deviceType = deviceType, deviceOS = deviceOS, model = model, updateRanking = updateRanking, returnSummaryResponse = returnSummaryResponse)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /analytics/usage/batch
     * Create Multiple Usage Records
     * Sends multiple analytics. Can be used to send in the user&#39;s stored usage when they did not have internet access. Should not include more than 100 items per batch.
     * @param appKey The application key unique to each application.
     * @param device The name of the device being used (iPhone5,1 , HTC Nexus One, x86_64, etc.)
     * @param `data` The analytic data AnalyticListResponse
     * @param deviceId The unique id of the device making the request (optional)
     * @param accountId The account ID of the logged in user making the request (optional)
     * @param appVersion The current build version of the application (optional)
     * @param deviceType The type of device (Handheld or Desktop) (optional)
     * @param deviceOS The operating system that the device is using (iPhone OS 5.0, Android OS 2.3.6, Windows 7 Service Pack 1, etc.) (optional)
     * @param model The model of the device (iPhone5,1 , Nexus One, etc.) (optional)
     * @param updateRanking Will create a leaderboard if one does not exist for the \&quot;tag\&quot; yet (optional)
     * @param returnSummaryResponse Returns a summary response of the achievements that have been completed due to the analytics (optional)
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun usageBatchWithHttpInfo(appKey: kotlin.String, device: kotlin.String, `data`: kotlin.String, deviceId: kotlin.String?, accountId: kotlin.Long?, appVersion: kotlin.String?, deviceType: kotlin.String?, deviceOS: kotlin.String?, model: kotlin.String?, updateRanking: kotlin.Boolean?, returnSummaryResponse: kotlin.Boolean?) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = usageBatchRequestConfig(appKey = appKey, device = device, `data` = `data`, deviceId = deviceId, accountId = accountId, appVersion = appVersion, deviceType = deviceType, deviceOS = deviceOS, model = model, updateRanking = updateRanking, returnSummaryResponse = returnSummaryResponse)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation usageBatch
     *
     * @param appKey The application key unique to each application.
     * @param device The name of the device being used (iPhone5,1 , HTC Nexus One, x86_64, etc.)
     * @param `data` The analytic data AnalyticListResponse
     * @param deviceId The unique id of the device making the request (optional)
     * @param accountId The account ID of the logged in user making the request (optional)
     * @param appVersion The current build version of the application (optional)
     * @param deviceType The type of device (Handheld or Desktop) (optional)
     * @param deviceOS The operating system that the device is using (iPhone OS 5.0, Android OS 2.3.6, Windows 7 Service Pack 1, etc.) (optional)
     * @param model The model of the device (iPhone5,1 , Nexus One, etc.) (optional)
     * @param updateRanking Will create a leaderboard if one does not exist for the \&quot;tag\&quot; yet (optional)
     * @param returnSummaryResponse Returns a summary response of the achievements that have been completed due to the analytics (optional)
     * @return RequestConfig
     */
    fun usageBatchRequestConfig(appKey: kotlin.String, device: kotlin.String, `data`: kotlin.String, deviceId: kotlin.String?, accountId: kotlin.Long?, appVersion: kotlin.String?, deviceType: kotlin.String?, deviceOS: kotlin.String?, model: kotlin.String?, updateRanking: kotlin.Boolean?, returnSummaryResponse: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                put("appKey", listOf(appKey.toString()))
                if (appVersion != null) {
                    put("appVersion", listOf(appVersion.toString()))
                }
                put("device", listOf(device.toString()))
                if (deviceType != null) {
                    put("deviceType", listOf(deviceType.toString()))
                }
                if (deviceOS != null) {
                    put("deviceOS", listOf(deviceOS.toString()))
                }
                if (model != null) {
                    put("model", listOf(model.toString()))
                }
                put("data", listOf(`data`.toString()))
                if (updateRanking != null) {
                    put("updateRanking", listOf(updateRanking.toString()))
                }
                if (returnSummaryResponse != null) {
                    put("returnSummaryResponse", listOf(returnSummaryResponse.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/analytics/usage/batch",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
