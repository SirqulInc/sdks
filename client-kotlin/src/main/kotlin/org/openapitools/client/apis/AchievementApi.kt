/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import org.openapitools.client.models.AchievementProgressResponse
import org.openapitools.client.models.AchievementResponse
import org.openapitools.client.models.AchievementShortResponse
import org.openapitools.client.models.AchievementTierResponse
import org.openapitools.client.models.SirqulResponse

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

open class AchievementApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://dev.sirqul.com/api/3.18")
        }
    }

    /**
     * POST /achievement/tier/search
     * Searches an Achievement Tier
     * Searches a tier of an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.
     * @param deviceId a unique id given by the device (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param appKey the application key (optional)
     * @param keyword the keyword used to filter resutls with (this returns results that have the keyword in the title or the description of the achievement tier) (optional)
     * @param achievementType filter results by achievementType (these are exact case sensitive matches) (optional)
     * @param rankType filter results by the rankType (these are the exact case sensitive matches) (optional)
     * @param sortField the field to sort by. See {@link AchievementApiMap} (optional)
     * @param descending determines whether the sort list is in descending or ascending order (of the achievement) (optional)
     * @param descendingGoal determines whether the results are in descending or ascending order by the tier goal count (after the initial sort on the achievement) (optional)
     * @param start The start of the index for pagination (optional)
     * @param limit the limit for pagination (has a hard limit of 1000) (optional)
     * @return AchievementTierResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun achievementTierSearchPost(deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, appKey: kotlin.String? = null, keyword: kotlin.String? = null, achievementType: kotlin.Long? = null, rankType: kotlin.String? = null, sortField: kotlin.String? = null, descending: kotlin.Boolean? = null, descendingGoal: kotlin.Boolean? = null, start: kotlin.Long? = null, limit: kotlin.Long? = null) : AchievementTierResponse {
        val localVarResponse = achievementTierSearchPostWithHttpInfo(deviceId = deviceId, accountId = accountId, appKey = appKey, keyword = keyword, achievementType = achievementType, rankType = rankType, sortField = sortField, descending = descending, descendingGoal = descendingGoal, start = start, limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AchievementTierResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /achievement/tier/search
     * Searches an Achievement Tier
     * Searches a tier of an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.
     * @param deviceId a unique id given by the device (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param appKey the application key (optional)
     * @param keyword the keyword used to filter resutls with (this returns results that have the keyword in the title or the description of the achievement tier) (optional)
     * @param achievementType filter results by achievementType (these are exact case sensitive matches) (optional)
     * @param rankType filter results by the rankType (these are the exact case sensitive matches) (optional)
     * @param sortField the field to sort by. See {@link AchievementApiMap} (optional)
     * @param descending determines whether the sort list is in descending or ascending order (of the achievement) (optional)
     * @param descendingGoal determines whether the results are in descending or ascending order by the tier goal count (after the initial sort on the achievement) (optional)
     * @param start The start of the index for pagination (optional)
     * @param limit the limit for pagination (has a hard limit of 1000) (optional)
     * @return ApiResponse<AchievementTierResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun achievementTierSearchPostWithHttpInfo(deviceId: kotlin.String?, accountId: kotlin.Long?, appKey: kotlin.String?, keyword: kotlin.String?, achievementType: kotlin.Long?, rankType: kotlin.String?, sortField: kotlin.String?, descending: kotlin.Boolean?, descendingGoal: kotlin.Boolean?, start: kotlin.Long?, limit: kotlin.Long?) : ApiResponse<AchievementTierResponse?> {
        val localVariableConfig = achievementTierSearchPostRequestConfig(deviceId = deviceId, accountId = accountId, appKey = appKey, keyword = keyword, achievementType = achievementType, rankType = rankType, sortField = sortField, descending = descending, descendingGoal = descendingGoal, start = start, limit = limit)

        return request<Unit, AchievementTierResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation achievementTierSearchPost
     *
     * @param deviceId a unique id given by the device (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param appKey the application key (optional)
     * @param keyword the keyword used to filter resutls with (this returns results that have the keyword in the title or the description of the achievement tier) (optional)
     * @param achievementType filter results by achievementType (these are exact case sensitive matches) (optional)
     * @param rankType filter results by the rankType (these are the exact case sensitive matches) (optional)
     * @param sortField the field to sort by. See {@link AchievementApiMap} (optional)
     * @param descending determines whether the sort list is in descending or ascending order (of the achievement) (optional)
     * @param descendingGoal determines whether the results are in descending or ascending order by the tier goal count (after the initial sort on the achievement) (optional)
     * @param start The start of the index for pagination (optional)
     * @param limit the limit for pagination (has a hard limit of 1000) (optional)
     * @return RequestConfig
     */
    fun achievementTierSearchPostRequestConfig(deviceId: kotlin.String?, accountId: kotlin.Long?, appKey: kotlin.String?, keyword: kotlin.String?, achievementType: kotlin.Long?, rankType: kotlin.String?, sortField: kotlin.String?, descending: kotlin.Boolean?, descendingGoal: kotlin.Boolean?, start: kotlin.Long?, limit: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (appKey != null) {
                    put("appKey", listOf(appKey.toString()))
                }
                if (keyword != null) {
                    put("keyword", listOf(keyword.toString()))
                }
                if (achievementType != null) {
                    put("achievementType", listOf(achievementType.toString()))
                }
                if (rankType != null) {
                    put("rankType", listOf(rankType.toString()))
                }
                if (sortField != null) {
                    put("sortField", listOf(sortField.toString()))
                }
                if (descending != null) {
                    put("descending", listOf(descending.toString()))
                }
                if (descendingGoal != null) {
                    put("descendingGoal", listOf(descendingGoal.toString()))
                }
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/achievement/tier/search",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /achievement/create
     * Create Achievement
     * Updates an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.
     * @param appKey the application key the achievement is for
     * @param title the title of the achievement (255 character limit)
     * @param deviceId a unique id given by the device (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param analyticsTag the analytics tag that will trigger when a user&#39;s achievement count gets updated (optional)
     * @param description the description of the achievement (optional)
     * @param rankType the rank type for updating leader boards (optional)
     * @param rankIncrement determines how much the rank count is incremented (optional)
     * @param minIncrement restrict scores to be above or equal to this minimum value (optional)
     * @param maxIncrement restrict scores to be below or equal to this maximum value (optional)
     * @param validate determines whether the customId on analytics are used to validate a user&#39;s achievement progress. (optional)
     * @param active achievement is active or inactive (optional)
     * @param triggerDefinition if provided will define what triggers to run after a tier is completed (optional)
     * @return AchievementResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createAchievement(appKey: kotlin.String, title: kotlin.String, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, analyticsTag: kotlin.String? = null, description: kotlin.String? = null, rankType: kotlin.String? = null, rankIncrement: kotlin.Int? = null, minIncrement: kotlin.Int? = null, maxIncrement: kotlin.Int? = null, validate: kotlin.Boolean? = null, active: kotlin.Boolean? = null, triggerDefinition: kotlin.String? = null) : AchievementResponse {
        val localVarResponse = createAchievementWithHttpInfo(appKey = appKey, title = title, deviceId = deviceId, accountId = accountId, analyticsTag = analyticsTag, description = description, rankType = rankType, rankIncrement = rankIncrement, minIncrement = minIncrement, maxIncrement = maxIncrement, validate = validate, active = active, triggerDefinition = triggerDefinition)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AchievementResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /achievement/create
     * Create Achievement
     * Updates an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.
     * @param appKey the application key the achievement is for
     * @param title the title of the achievement (255 character limit)
     * @param deviceId a unique id given by the device (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param analyticsTag the analytics tag that will trigger when a user&#39;s achievement count gets updated (optional)
     * @param description the description of the achievement (optional)
     * @param rankType the rank type for updating leader boards (optional)
     * @param rankIncrement determines how much the rank count is incremented (optional)
     * @param minIncrement restrict scores to be above or equal to this minimum value (optional)
     * @param maxIncrement restrict scores to be below or equal to this maximum value (optional)
     * @param validate determines whether the customId on analytics are used to validate a user&#39;s achievement progress. (optional)
     * @param active achievement is active or inactive (optional)
     * @param triggerDefinition if provided will define what triggers to run after a tier is completed (optional)
     * @return ApiResponse<AchievementResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createAchievementWithHttpInfo(appKey: kotlin.String, title: kotlin.String, deviceId: kotlin.String?, accountId: kotlin.Long?, analyticsTag: kotlin.String?, description: kotlin.String?, rankType: kotlin.String?, rankIncrement: kotlin.Int?, minIncrement: kotlin.Int?, maxIncrement: kotlin.Int?, validate: kotlin.Boolean?, active: kotlin.Boolean?, triggerDefinition: kotlin.String?) : ApiResponse<AchievementResponse?> {
        val localVariableConfig = createAchievementRequestConfig(appKey = appKey, title = title, deviceId = deviceId, accountId = accountId, analyticsTag = analyticsTag, description = description, rankType = rankType, rankIncrement = rankIncrement, minIncrement = minIncrement, maxIncrement = maxIncrement, validate = validate, active = active, triggerDefinition = triggerDefinition)

        return request<Unit, AchievementResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createAchievement
     *
     * @param appKey the application key the achievement is for
     * @param title the title of the achievement (255 character limit)
     * @param deviceId a unique id given by the device (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param analyticsTag the analytics tag that will trigger when a user&#39;s achievement count gets updated (optional)
     * @param description the description of the achievement (optional)
     * @param rankType the rank type for updating leader boards (optional)
     * @param rankIncrement determines how much the rank count is incremented (optional)
     * @param minIncrement restrict scores to be above or equal to this minimum value (optional)
     * @param maxIncrement restrict scores to be below or equal to this maximum value (optional)
     * @param validate determines whether the customId on analytics are used to validate a user&#39;s achievement progress. (optional)
     * @param active achievement is active or inactive (optional)
     * @param triggerDefinition if provided will define what triggers to run after a tier is completed (optional)
     * @return RequestConfig
     */
    fun createAchievementRequestConfig(appKey: kotlin.String, title: kotlin.String, deviceId: kotlin.String?, accountId: kotlin.Long?, analyticsTag: kotlin.String?, description: kotlin.String?, rankType: kotlin.String?, rankIncrement: kotlin.Int?, minIncrement: kotlin.Int?, maxIncrement: kotlin.Int?, validate: kotlin.Boolean?, active: kotlin.Boolean?, triggerDefinition: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                put("appKey", listOf(appKey.toString()))
                if (analyticsTag != null) {
                    put("analyticsTag", listOf(analyticsTag.toString()))
                }
                put("title", listOf(title.toString()))
                if (description != null) {
                    put("description", listOf(description.toString()))
                }
                if (rankType != null) {
                    put("rankType", listOf(rankType.toString()))
                }
                if (rankIncrement != null) {
                    put("rankIncrement", listOf(rankIncrement.toString()))
                }
                if (minIncrement != null) {
                    put("minIncrement", listOf(minIncrement.toString()))
                }
                if (maxIncrement != null) {
                    put("maxIncrement", listOf(maxIncrement.toString()))
                }
                if (validate != null) {
                    put("validate", listOf(validate.toString()))
                }
                if (active != null) {
                    put("active", listOf(active.toString()))
                }
                if (triggerDefinition != null) {
                    put("triggerDefinition", listOf(triggerDefinition.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/achievement/create",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /achievement/tier/create
     * Create Achievement Tier
     * Create a tier of an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.
     * @param achievementId the achievement id for adding a new tier
     * @param scoreAllInstances score all instances
     * @param deviceId a unique id given by the device (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param icon achievement tier icon image file (optional)
     * @param iconAssetId the icon assetId, if icon is provided, icon will overrule (optional)
     * @param title the title of the achievement tier (optional)
     * @param description the description of the achievement tier (optional)
     * @param goalCount the count requirement for completing the achievement tier (optional)
     * @param missionId The ID of the mission to associate with the achievement (optional)
     * @param gameId The ID of the game to associate with the achievement (optional)
     * @param packId The ID of the pack to associate with the achievement (optional)
     * @param gameLevelId The ID of the game level to associate with the achievement (optional)
     * @param gameObjectId The ID of the game object to associate with the achievement (optional)
     * @return AchievementTierResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createAchievementTier(achievementId: kotlin.Long, scoreAllInstances: kotlin.Boolean, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, icon: java.io.File? = null, iconAssetId: kotlin.Long? = null, title: kotlin.String? = null, description: kotlin.String? = null, goalCount: kotlin.Long? = null, missionId: kotlin.Long? = null, gameId: kotlin.Long? = null, packId: kotlin.Long? = null, gameLevelId: kotlin.Long? = null, gameObjectId: kotlin.Int? = null) : AchievementTierResponse {
        val localVarResponse = createAchievementTierWithHttpInfo(achievementId = achievementId, scoreAllInstances = scoreAllInstances, deviceId = deviceId, accountId = accountId, icon = icon, iconAssetId = iconAssetId, title = title, description = description, goalCount = goalCount, missionId = missionId, gameId = gameId, packId = packId, gameLevelId = gameLevelId, gameObjectId = gameObjectId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AchievementTierResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /achievement/tier/create
     * Create Achievement Tier
     * Create a tier of an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.
     * @param achievementId the achievement id for adding a new tier
     * @param scoreAllInstances score all instances
     * @param deviceId a unique id given by the device (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param icon achievement tier icon image file (optional)
     * @param iconAssetId the icon assetId, if icon is provided, icon will overrule (optional)
     * @param title the title of the achievement tier (optional)
     * @param description the description of the achievement tier (optional)
     * @param goalCount the count requirement for completing the achievement tier (optional)
     * @param missionId The ID of the mission to associate with the achievement (optional)
     * @param gameId The ID of the game to associate with the achievement (optional)
     * @param packId The ID of the pack to associate with the achievement (optional)
     * @param gameLevelId The ID of the game level to associate with the achievement (optional)
     * @param gameObjectId The ID of the game object to associate with the achievement (optional)
     * @return ApiResponse<AchievementTierResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createAchievementTierWithHttpInfo(achievementId: kotlin.Long, scoreAllInstances: kotlin.Boolean, deviceId: kotlin.String?, accountId: kotlin.Long?, icon: java.io.File?, iconAssetId: kotlin.Long?, title: kotlin.String?, description: kotlin.String?, goalCount: kotlin.Long?, missionId: kotlin.Long?, gameId: kotlin.Long?, packId: kotlin.Long?, gameLevelId: kotlin.Long?, gameObjectId: kotlin.Int?) : ApiResponse<AchievementTierResponse?> {
        val localVariableConfig = createAchievementTierRequestConfig(achievementId = achievementId, scoreAllInstances = scoreAllInstances, deviceId = deviceId, accountId = accountId, icon = icon, iconAssetId = iconAssetId, title = title, description = description, goalCount = goalCount, missionId = missionId, gameId = gameId, packId = packId, gameLevelId = gameLevelId, gameObjectId = gameObjectId)

        return request<Unit, AchievementTierResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createAchievementTier
     *
     * @param achievementId the achievement id for adding a new tier
     * @param scoreAllInstances score all instances
     * @param deviceId a unique id given by the device (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param icon achievement tier icon image file (optional)
     * @param iconAssetId the icon assetId, if icon is provided, icon will overrule (optional)
     * @param title the title of the achievement tier (optional)
     * @param description the description of the achievement tier (optional)
     * @param goalCount the count requirement for completing the achievement tier (optional)
     * @param missionId The ID of the mission to associate with the achievement (optional)
     * @param gameId The ID of the game to associate with the achievement (optional)
     * @param packId The ID of the pack to associate with the achievement (optional)
     * @param gameLevelId The ID of the game level to associate with the achievement (optional)
     * @param gameObjectId The ID of the game object to associate with the achievement (optional)
     * @return RequestConfig
     */
    fun createAchievementTierRequestConfig(achievementId: kotlin.Long, scoreAllInstances: kotlin.Boolean, deviceId: kotlin.String?, accountId: kotlin.Long?, icon: java.io.File?, iconAssetId: kotlin.Long?, title: kotlin.String?, description: kotlin.String?, goalCount: kotlin.Long?, missionId: kotlin.Long?, gameId: kotlin.Long?, packId: kotlin.Long?, gameLevelId: kotlin.Long?, gameObjectId: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                put("achievementId", listOf(achievementId.toString()))
                if (icon != null) {
                    put("icon", listOf(icon.toString()))
                }
                if (iconAssetId != null) {
                    put("iconAssetId", listOf(iconAssetId.toString()))
                }
                if (title != null) {
                    put("title", listOf(title.toString()))
                }
                if (description != null) {
                    put("description", listOf(description.toString()))
                }
                if (goalCount != null) {
                    put("goalCount", listOf(goalCount.toString()))
                }
                if (missionId != null) {
                    put("missionId", listOf(missionId.toString()))
                }
                if (gameId != null) {
                    put("gameId", listOf(gameId.toString()))
                }
                if (packId != null) {
                    put("packId", listOf(packId.toString()))
                }
                if (gameLevelId != null) {
                    put("gameLevelId", listOf(gameLevelId.toString()))
                }
                if (gameObjectId != null) {
                    put("gameObjectId", listOf(gameObjectId.toString()))
                }
                put("scoreAllInstances", listOf(scoreAllInstances.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/achievement/tier/create",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /achievement/delete
     * Delete Achievement
     * Deletes an achievement (for developer/retailer use). User must have permissions to the application the achievement was created for.
     * @param achievementId The ID of the achievement
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteAchievement(achievementId: kotlin.Long, accountId: kotlin.Long? = null) : SirqulResponse {
        val localVarResponse = deleteAchievementWithHttpInfo(achievementId = achievementId, accountId = accountId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /achievement/delete
     * Delete Achievement
     * Deletes an achievement (for developer/retailer use). User must have permissions to the application the achievement was created for.
     * @param achievementId The ID of the achievement
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteAchievementWithHttpInfo(achievementId: kotlin.Long, accountId: kotlin.Long?) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = deleteAchievementRequestConfig(achievementId = achievementId, accountId = accountId)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteAchievement
     *
     * @param achievementId The ID of the achievement
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @return RequestConfig
     */
    fun deleteAchievementRequestConfig(achievementId: kotlin.Long, accountId: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                put("achievementId", listOf(achievementId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/achievement/delete",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /achievement/tier/delete
     * Delete Achievement Tier
     * Deletes an achievement tier (for developer/retailer use). User must have permissions to the application the achievement was created for.
     * @param achievementTierId the achievement id for deletion
     * @param accountId the account id of the user (deviceId or accountId required). (optional)
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteAchievementTier(achievementTierId: kotlin.Long, accountId: kotlin.Long? = null) : SirqulResponse {
        val localVarResponse = deleteAchievementTierWithHttpInfo(achievementTierId = achievementTierId, accountId = accountId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /achievement/tier/delete
     * Delete Achievement Tier
     * Deletes an achievement tier (for developer/retailer use). User must have permissions to the application the achievement was created for.
     * @param achievementTierId the achievement id for deletion
     * @param accountId the account id of the user (deviceId or accountId required). (optional)
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteAchievementTierWithHttpInfo(achievementTierId: kotlin.Long, accountId: kotlin.Long?) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = deleteAchievementTierRequestConfig(achievementTierId = achievementTierId, accountId = accountId)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteAchievementTier
     *
     * @param achievementTierId the achievement id for deletion
     * @param accountId the account id of the user (deviceId or accountId required). (optional)
     * @return RequestConfig
     */
    fun deleteAchievementTierRequestConfig(achievementTierId: kotlin.Long, accountId: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                put("achievementTierId", listOf(achievementTierId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/achievement/tier/delete",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /achievement/get
     * Get Achievement
     * Get an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.
     * @param achievementId The ID of the achievement
     * @param deviceId a unique id given by the device (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param achievementType achievementType (optional)
     * @return AchievementTierResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAchievement(achievementId: kotlin.Long, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, achievementType: kotlin.String? = null) : AchievementTierResponse {
        val localVarResponse = getAchievementWithHttpInfo(achievementId = achievementId, deviceId = deviceId, accountId = accountId, achievementType = achievementType)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AchievementTierResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /achievement/get
     * Get Achievement
     * Get an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.
     * @param achievementId The ID of the achievement
     * @param deviceId a unique id given by the device (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param achievementType achievementType (optional)
     * @return ApiResponse<AchievementTierResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getAchievementWithHttpInfo(achievementId: kotlin.Long, deviceId: kotlin.String?, accountId: kotlin.Long?, achievementType: kotlin.String?) : ApiResponse<AchievementTierResponse?> {
        val localVariableConfig = getAchievementRequestConfig(achievementId = achievementId, deviceId = deviceId, accountId = accountId, achievementType = achievementType)

        return request<Unit, AchievementTierResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAchievement
     *
     * @param achievementId The ID of the achievement
     * @param deviceId a unique id given by the device (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param achievementType achievementType (optional)
     * @return RequestConfig
     */
    fun getAchievementRequestConfig(achievementId: kotlin.Long, deviceId: kotlin.String?, accountId: kotlin.Long?, achievementType: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                put("achievementId", listOf(achievementId.toString()))
                if (achievementType != null) {
                    put("achievementType", listOf(achievementType.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/achievement/get",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /achievement/tier/get
     * Gets an achievement tier
     * Gets an achievement tier (for developer/retailer use). User must have permissions to the application the achievement is created for.
     * @param accountId the account id of the user (deviceId or accountId required)
     * @param achievementTierId the achievement tier id that is being retrieved
     * @return AchievementTierResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAchievementTier(accountId: kotlin.Long, achievementTierId: kotlin.Long) : AchievementTierResponse {
        val localVarResponse = getAchievementTierWithHttpInfo(accountId = accountId, achievementTierId = achievementTierId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AchievementTierResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /achievement/tier/get
     * Gets an achievement tier
     * Gets an achievement tier (for developer/retailer use). User must have permissions to the application the achievement is created for.
     * @param accountId the account id of the user (deviceId or accountId required)
     * @param achievementTierId the achievement tier id that is being retrieved
     * @return ApiResponse<AchievementTierResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getAchievementTierWithHttpInfo(accountId: kotlin.Long, achievementTierId: kotlin.Long) : ApiResponse<AchievementTierResponse?> {
        val localVariableConfig = getAchievementTierRequestConfig(accountId = accountId, achievementTierId = achievementTierId)

        return request<Unit, AchievementTierResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAchievementTier
     *
     * @param accountId the account id of the user (deviceId or accountId required)
     * @param achievementTierId the achievement tier id that is being retrieved
     * @return RequestConfig
     */
    fun getAchievementTierRequestConfig(accountId: kotlin.Long, achievementTierId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("achievementTierId", listOf(achievementTierId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/achievement/tier/get",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /achievement/progress/get
     * Get Achievement Progress
     * Gets a list of user achievements.
     * @param returnNulls determines whether to return null fields in the response (default to true)
     * @param appKey the application key for filtering results by application
     * @param includeUndiscovered determines whether to return achievements that the user has not discovered yet (default to true)
     * @param deviceId a unique id given by the device (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param connectionAccountEmail the email of the account to view achievements (optional)
     * @param connectionAccountId the id of the account to view achievements (optional)
     * @param rankType filter results by achievement rankType (optional)
     * @param achievementType filter results by achievement type (optional)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @return kotlin.collections.List<AchievementProgressResponse>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getUserAchievements(returnNulls: kotlin.Boolean = true, appKey: kotlin.String, includeUndiscovered: kotlin.Boolean = true, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, connectionAccountEmail: kotlin.String? = null, connectionAccountId: kotlin.Long? = null, rankType: kotlin.String? = null, achievementType: kotlin.String? = null, latitude: kotlin.Double? = null, longitude: kotlin.Double? = null) : kotlin.collections.List<AchievementProgressResponse> {
        val localVarResponse = getUserAchievementsWithHttpInfo(returnNulls = returnNulls, appKey = appKey, includeUndiscovered = includeUndiscovered, deviceId = deviceId, accountId = accountId, connectionAccountEmail = connectionAccountEmail, connectionAccountId = connectionAccountId, rankType = rankType, achievementType = achievementType, latitude = latitude, longitude = longitude)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<AchievementProgressResponse>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /achievement/progress/get
     * Get Achievement Progress
     * Gets a list of user achievements.
     * @param returnNulls determines whether to return null fields in the response (default to true)
     * @param appKey the application key for filtering results by application
     * @param includeUndiscovered determines whether to return achievements that the user has not discovered yet (default to true)
     * @param deviceId a unique id given by the device (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param connectionAccountEmail the email of the account to view achievements (optional)
     * @param connectionAccountId the id of the account to view achievements (optional)
     * @param rankType filter results by achievement rankType (optional)
     * @param achievementType filter results by achievement type (optional)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @return ApiResponse<kotlin.collections.List<AchievementProgressResponse>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getUserAchievementsWithHttpInfo(returnNulls: kotlin.Boolean, appKey: kotlin.String, includeUndiscovered: kotlin.Boolean, deviceId: kotlin.String?, accountId: kotlin.Long?, connectionAccountEmail: kotlin.String?, connectionAccountId: kotlin.Long?, rankType: kotlin.String?, achievementType: kotlin.String?, latitude: kotlin.Double?, longitude: kotlin.Double?) : ApiResponse<kotlin.collections.List<AchievementProgressResponse>?> {
        val localVariableConfig = getUserAchievementsRequestConfig(returnNulls = returnNulls, appKey = appKey, includeUndiscovered = includeUndiscovered, deviceId = deviceId, accountId = accountId, connectionAccountEmail = connectionAccountEmail, connectionAccountId = connectionAccountId, rankType = rankType, achievementType = achievementType, latitude = latitude, longitude = longitude)

        return request<Unit, kotlin.collections.List<AchievementProgressResponse>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getUserAchievements
     *
     * @param returnNulls determines whether to return null fields in the response (default to true)
     * @param appKey the application key for filtering results by application
     * @param includeUndiscovered determines whether to return achievements that the user has not discovered yet (default to true)
     * @param deviceId a unique id given by the device (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param connectionAccountEmail the email of the account to view achievements (optional)
     * @param connectionAccountId the id of the account to view achievements (optional)
     * @param rankType filter results by achievement rankType (optional)
     * @param achievementType filter results by achievement type (optional)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @return RequestConfig
     */
    fun getUserAchievementsRequestConfig(returnNulls: kotlin.Boolean, appKey: kotlin.String, includeUndiscovered: kotlin.Boolean, deviceId: kotlin.String?, accountId: kotlin.Long?, connectionAccountEmail: kotlin.String?, connectionAccountId: kotlin.Long?, rankType: kotlin.String?, achievementType: kotlin.String?, latitude: kotlin.Double?, longitude: kotlin.Double?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("returnNulls", listOf(returnNulls.toString()))
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (connectionAccountEmail != null) {
                    put("connectionAccountEmail", listOf(connectionAccountEmail.toString()))
                }
                if (connectionAccountId != null) {
                    put("connectionAccountId", listOf(connectionAccountId.toString()))
                }
                put("appKey", listOf(appKey.toString()))
                if (rankType != null) {
                    put("rankType", listOf(rankType.toString()))
                }
                if (achievementType != null) {
                    put("achievementType", listOf(achievementType.toString()))
                }
                put("includeUndiscovered", listOf(includeUndiscovered.toString()))
                if (latitude != null) {
                    put("latitude", listOf(latitude.toString()))
                }
                if (longitude != null) {
                    put("longitude", listOf(longitude.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/achievement/progress/get",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /achievement/tag/list
     * List Achievement Tags
     * List achievement tags by application
     * @param appKey filter results by application key (optional)
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listAchievementTags(appKey: kotlin.String? = null) : SirqulResponse {
        val localVarResponse = listAchievementTagsWithHttpInfo(appKey = appKey)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /achievement/tag/list
     * List Achievement Tags
     * List achievement tags by application
     * @param appKey filter results by application key (optional)
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listAchievementTagsWithHttpInfo(appKey: kotlin.String?) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = listAchievementTagsRequestConfig(appKey = appKey)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listAchievementTags
     *
     * @param appKey filter results by application key (optional)
     * @return RequestConfig
     */
    fun listAchievementTagsRequestConfig(appKey: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (appKey != null) {
                    put("appKey", listOf(appKey.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/achievement/tag/list",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter sortField
     */
     enum class SortFieldListAchievements(val value: kotlin.String) {
         @Json(name = "CREATED") CREATED("CREATED"),
         @Json(name = "UPDATED") UPDATED("UPDATED"),
         @Json(name = "DELETED") DELETED("DELETED"),
         @Json(name = "SEARCH_TAGS") SEARCH_TAGS("SEARCH_TAGS"),
         @Json(name = "ACTIVE") ACTIVE("ACTIVE"),
         @Json(name = "TITLE") TITLE("TITLE"),
         @Json(name = "DESCRIPTION") DESCRIPTION("DESCRIPTION"),
         @Json(name = "RANK_TYPE") RANK_TYPE("RANK_TYPE"),
         @Json(name = "APPLICATION_ID") APPLICATION_ID("APPLICATION_ID"),
         @Json(name = "APPLICATION_NAME") APPLICATION_NAME("APPLICATION_NAME"),
         @Json(name = "BILLABLE_ID") BILLABLE_ID("BILLABLE_ID");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /achievement/list
     * List Achievements
     * List achievements by billable.
     * @param sortField the field to sort by. See AchievementApiMap
     * @param descending determines whether the sorted list is in descending or ascending order
     * @param start the start index for pagination
     * @param limit the limit for pagination (has a hard limit of 1000)
     * @param activeOnly Filter results to only return active achievements
     * @param deviceId a unique id given by the device (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param appKey the application key (optional)
     * @param keyword the keyword used to filter results with (this returns results that have the keyword in the title or description of the achievement) (optional)
     * @param achievementType filter results by the achievementType (these are exact case sensitive matches) (optional)
     * @param rankType filter results by the rankType (these are exact case sensitive matches) (optional)
     * @return kotlin.collections.List<AchievementShortResponse>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listAchievements(sortField: SortFieldListAchievements, descending: kotlin.Boolean, start: kotlin.Int, limit: kotlin.Int, activeOnly: kotlin.Boolean, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, appKey: kotlin.String? = null, keyword: kotlin.String? = null, achievementType: kotlin.String? = null, rankType: kotlin.String? = null) : kotlin.collections.List<AchievementShortResponse> {
        val localVarResponse = listAchievementsWithHttpInfo(sortField = sortField, descending = descending, start = start, limit = limit, activeOnly = activeOnly, deviceId = deviceId, accountId = accountId, appKey = appKey, keyword = keyword, achievementType = achievementType, rankType = rankType)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<AchievementShortResponse>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /achievement/list
     * List Achievements
     * List achievements by billable.
     * @param sortField the field to sort by. See AchievementApiMap
     * @param descending determines whether the sorted list is in descending or ascending order
     * @param start the start index for pagination
     * @param limit the limit for pagination (has a hard limit of 1000)
     * @param activeOnly Filter results to only return active achievements
     * @param deviceId a unique id given by the device (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param appKey the application key (optional)
     * @param keyword the keyword used to filter results with (this returns results that have the keyword in the title or description of the achievement) (optional)
     * @param achievementType filter results by the achievementType (these are exact case sensitive matches) (optional)
     * @param rankType filter results by the rankType (these are exact case sensitive matches) (optional)
     * @return ApiResponse<kotlin.collections.List<AchievementShortResponse>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listAchievementsWithHttpInfo(sortField: SortFieldListAchievements, descending: kotlin.Boolean, start: kotlin.Int, limit: kotlin.Int, activeOnly: kotlin.Boolean, deviceId: kotlin.String?, accountId: kotlin.Long?, appKey: kotlin.String?, keyword: kotlin.String?, achievementType: kotlin.String?, rankType: kotlin.String?) : ApiResponse<kotlin.collections.List<AchievementShortResponse>?> {
        val localVariableConfig = listAchievementsRequestConfig(sortField = sortField, descending = descending, start = start, limit = limit, activeOnly = activeOnly, deviceId = deviceId, accountId = accountId, appKey = appKey, keyword = keyword, achievementType = achievementType, rankType = rankType)

        return request<Unit, kotlin.collections.List<AchievementShortResponse>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listAchievements
     *
     * @param sortField the field to sort by. See AchievementApiMap
     * @param descending determines whether the sorted list is in descending or ascending order
     * @param start the start index for pagination
     * @param limit the limit for pagination (has a hard limit of 1000)
     * @param activeOnly Filter results to only return active achievements
     * @param deviceId a unique id given by the device (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param appKey the application key (optional)
     * @param keyword the keyword used to filter results with (this returns results that have the keyword in the title or description of the achievement) (optional)
     * @param achievementType filter results by the achievementType (these are exact case sensitive matches) (optional)
     * @param rankType filter results by the rankType (these are exact case sensitive matches) (optional)
     * @return RequestConfig
     */
    fun listAchievementsRequestConfig(sortField: SortFieldListAchievements, descending: kotlin.Boolean, start: kotlin.Int, limit: kotlin.Int, activeOnly: kotlin.Boolean, deviceId: kotlin.String?, accountId: kotlin.Long?, appKey: kotlin.String?, keyword: kotlin.String?, achievementType: kotlin.String?, rankType: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (appKey != null) {
                    put("appKey", listOf(appKey.toString()))
                }
                if (keyword != null) {
                    put("keyword", listOf(keyword.toString()))
                }
                if (achievementType != null) {
                    put("achievementType", listOf(achievementType.toString()))
                }
                if (rankType != null) {
                    put("rankType", listOf(rankType.toString()))
                }
                put("sortField", listOf(sortField.value))
                put("descending", listOf(descending.toString()))
                put("start", listOf(start.toString()))
                put("limit", listOf(limit.toString()))
                put("activeOnly", listOf(activeOnly.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/achievement/list",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter sortField
     */
     enum class SortFieldSearchAchievements(val value: kotlin.String) {
         @Json(name = "CREATED") CREATED("CREATED"),
         @Json(name = "UPDATED") UPDATED("UPDATED"),
         @Json(name = "DELETED") DELETED("DELETED"),
         @Json(name = "SEARCH_TAGS") SEARCH_TAGS("SEARCH_TAGS"),
         @Json(name = "ACTIVE") ACTIVE("ACTIVE"),
         @Json(name = "TITLE") TITLE("TITLE"),
         @Json(name = "DESCRIPTION") DESCRIPTION("DESCRIPTION"),
         @Json(name = "RANK_TYPE") RANK_TYPE("RANK_TYPE"),
         @Json(name = "APPLICATION_ID") APPLICATION_ID("APPLICATION_ID"),
         @Json(name = "APPLICATION_NAME") APPLICATION_NAME("APPLICATION_NAME"),
         @Json(name = "BILLABLE_ID") BILLABLE_ID("BILLABLE_ID");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /achievement/search
     * Search Achievements
     * Searches achievements by application for consumers.
     * @param appKey the application key
     * @param sortField the field to sort by. See AchievementApiMap (default to SortField.TITLE)
     * @param descending determines whether the sorted list is in descending or ascending order (default to false)
     * @param includeTiers return tiers, only applicable for version &gt;3.18 (default to false)
     * @param includeInactiveTiers return inactive tiers, only applicable when includeTiers is true, only applicable for version &gt;3.18 (default to false)
     * @param start the start index for pagination (default to 0)
     * @param limit the limit for pagination (has a hard limit of 1000) (default to 100)
     * @param deviceId a unique id given by the device (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param keyword the keyword used to filter results with (this returns results that have the keyword in the title or description of the achievement) (optional)
     * @param achievementType filter results by the achievementType (these are exact case sensitive matches) (optional)
     * @param rankType filter results by the rankType (these are exact case sensitive matches) (optional)
     * @return kotlin.collections.List<AchievementShortResponse>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun searchAchievements(appKey: kotlin.String, sortField: SortFieldSearchAchievements = SortFieldSearchAchievements.TITLE, descending: kotlin.Boolean = false, includeTiers: kotlin.Boolean = false, includeInactiveTiers: kotlin.Boolean = false, start: kotlin.Int = 0, limit: kotlin.Int = 100, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, keyword: kotlin.String? = null, achievementType: kotlin.String? = null, rankType: kotlin.String? = null) : kotlin.collections.List<AchievementShortResponse> {
        val localVarResponse = searchAchievementsWithHttpInfo(appKey = appKey, sortField = sortField, descending = descending, includeTiers = includeTiers, includeInactiveTiers = includeInactiveTiers, start = start, limit = limit, deviceId = deviceId, accountId = accountId, keyword = keyword, achievementType = achievementType, rankType = rankType)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<AchievementShortResponse>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /achievement/search
     * Search Achievements
     * Searches achievements by application for consumers.
     * @param appKey the application key
     * @param sortField the field to sort by. See AchievementApiMap (default to SortField.TITLE)
     * @param descending determines whether the sorted list is in descending or ascending order (default to false)
     * @param includeTiers return tiers, only applicable for version &gt;3.18 (default to false)
     * @param includeInactiveTiers return inactive tiers, only applicable when includeTiers is true, only applicable for version &gt;3.18 (default to false)
     * @param start the start index for pagination (default to 0)
     * @param limit the limit for pagination (has a hard limit of 1000) (default to 100)
     * @param deviceId a unique id given by the device (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param keyword the keyword used to filter results with (this returns results that have the keyword in the title or description of the achievement) (optional)
     * @param achievementType filter results by the achievementType (these are exact case sensitive matches) (optional)
     * @param rankType filter results by the rankType (these are exact case sensitive matches) (optional)
     * @return ApiResponse<kotlin.collections.List<AchievementShortResponse>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun searchAchievementsWithHttpInfo(appKey: kotlin.String, sortField: SortFieldSearchAchievements, descending: kotlin.Boolean, includeTiers: kotlin.Boolean, includeInactiveTiers: kotlin.Boolean, start: kotlin.Int, limit: kotlin.Int, deviceId: kotlin.String?, accountId: kotlin.Long?, keyword: kotlin.String?, achievementType: kotlin.String?, rankType: kotlin.String?) : ApiResponse<kotlin.collections.List<AchievementShortResponse>?> {
        val localVariableConfig = searchAchievementsRequestConfig(appKey = appKey, sortField = sortField, descending = descending, includeTiers = includeTiers, includeInactiveTiers = includeInactiveTiers, start = start, limit = limit, deviceId = deviceId, accountId = accountId, keyword = keyword, achievementType = achievementType, rankType = rankType)

        return request<Unit, kotlin.collections.List<AchievementShortResponse>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation searchAchievements
     *
     * @param appKey the application key
     * @param sortField the field to sort by. See AchievementApiMap (default to SortField.TITLE)
     * @param descending determines whether the sorted list is in descending or ascending order (default to false)
     * @param includeTiers return tiers, only applicable for version &gt;3.18 (default to false)
     * @param includeInactiveTiers return inactive tiers, only applicable when includeTiers is true, only applicable for version &gt;3.18 (default to false)
     * @param start the start index for pagination (default to 0)
     * @param limit the limit for pagination (has a hard limit of 1000) (default to 100)
     * @param deviceId a unique id given by the device (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param keyword the keyword used to filter results with (this returns results that have the keyword in the title or description of the achievement) (optional)
     * @param achievementType filter results by the achievementType (these are exact case sensitive matches) (optional)
     * @param rankType filter results by the rankType (these are exact case sensitive matches) (optional)
     * @return RequestConfig
     */
    fun searchAchievementsRequestConfig(appKey: kotlin.String, sortField: SortFieldSearchAchievements, descending: kotlin.Boolean, includeTiers: kotlin.Boolean, includeInactiveTiers: kotlin.Boolean, start: kotlin.Int, limit: kotlin.Int, deviceId: kotlin.String?, accountId: kotlin.Long?, keyword: kotlin.String?, achievementType: kotlin.String?, rankType: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                put("appKey", listOf(appKey.toString()))
                if (keyword != null) {
                    put("keyword", listOf(keyword.toString()))
                }
                if (achievementType != null) {
                    put("achievementType", listOf(achievementType.toString()))
                }
                if (rankType != null) {
                    put("rankType", listOf(rankType.toString()))
                }
                put("sortField", listOf(sortField.value))
                put("descending", listOf(descending.toString()))
                put("includeTiers", listOf(includeTiers.toString()))
                put("includeInactiveTiers", listOf(includeInactiveTiers.toString()))
                put("start", listOf(start.toString()))
                put("limit", listOf(limit.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/achievement/search",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /achievement/update
     * Update Achievement
     * Updates an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.
     * @param deviceId a unique id given by the device (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param achievementId the achievement ID for updating an existing achievement (optional)
     * @param analyticsTag the analytics tag that will trigger when a user&#39;s achievement count gets updated (optional)
     * @param title the title of the achievement (255 character limit) (optional)
     * @param description the description of the achievement (optional)
     * @param rankType the rank type for updating leader boards (optional)
     * @param rankIncrement determines how much the rank count is incremented (optional)
     * @param minIncrement restrict scores to be above or equal to this minimum value (optional)
     * @param nullMinIncrement enable to ignore usage of minIncrement (optional)
     * @param maxIncrement restrict scores to be below or equal to this maximum value (optional)
     * @param nullMaxIncrement enable to ignore usage of maxIncrement (optional)
     * @param validate determines whether the customId on analytics are used to validate a user&#39;s achievement progress. (optional)
     * @param active if it&#39;s active or inactive (optional)
     * @param triggerDefinition if provided will define what triggers to run after a tier is completed (optional)
     * @return AchievementResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updateAchievement(deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, achievementId: kotlin.Long? = null, analyticsTag: kotlin.String? = null, title: kotlin.String? = null, description: kotlin.String? = null, rankType: kotlin.String? = null, rankIncrement: kotlin.Int? = null, minIncrement: kotlin.Int? = null, nullMinIncrement: kotlin.Boolean? = null, maxIncrement: kotlin.Int? = null, nullMaxIncrement: kotlin.Boolean? = null, validate: kotlin.Boolean? = null, active: kotlin.Boolean? = null, triggerDefinition: kotlin.String? = null) : AchievementResponse {
        val localVarResponse = updateAchievementWithHttpInfo(deviceId = deviceId, accountId = accountId, achievementId = achievementId, analyticsTag = analyticsTag, title = title, description = description, rankType = rankType, rankIncrement = rankIncrement, minIncrement = minIncrement, nullMinIncrement = nullMinIncrement, maxIncrement = maxIncrement, nullMaxIncrement = nullMaxIncrement, validate = validate, active = active, triggerDefinition = triggerDefinition)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AchievementResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /achievement/update
     * Update Achievement
     * Updates an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.
     * @param deviceId a unique id given by the device (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param achievementId the achievement ID for updating an existing achievement (optional)
     * @param analyticsTag the analytics tag that will trigger when a user&#39;s achievement count gets updated (optional)
     * @param title the title of the achievement (255 character limit) (optional)
     * @param description the description of the achievement (optional)
     * @param rankType the rank type for updating leader boards (optional)
     * @param rankIncrement determines how much the rank count is incremented (optional)
     * @param minIncrement restrict scores to be above or equal to this minimum value (optional)
     * @param nullMinIncrement enable to ignore usage of minIncrement (optional)
     * @param maxIncrement restrict scores to be below or equal to this maximum value (optional)
     * @param nullMaxIncrement enable to ignore usage of maxIncrement (optional)
     * @param validate determines whether the customId on analytics are used to validate a user&#39;s achievement progress. (optional)
     * @param active if it&#39;s active or inactive (optional)
     * @param triggerDefinition if provided will define what triggers to run after a tier is completed (optional)
     * @return ApiResponse<AchievementResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun updateAchievementWithHttpInfo(deviceId: kotlin.String?, accountId: kotlin.Long?, achievementId: kotlin.Long?, analyticsTag: kotlin.String?, title: kotlin.String?, description: kotlin.String?, rankType: kotlin.String?, rankIncrement: kotlin.Int?, minIncrement: kotlin.Int?, nullMinIncrement: kotlin.Boolean?, maxIncrement: kotlin.Int?, nullMaxIncrement: kotlin.Boolean?, validate: kotlin.Boolean?, active: kotlin.Boolean?, triggerDefinition: kotlin.String?) : ApiResponse<AchievementResponse?> {
        val localVariableConfig = updateAchievementRequestConfig(deviceId = deviceId, accountId = accountId, achievementId = achievementId, analyticsTag = analyticsTag, title = title, description = description, rankType = rankType, rankIncrement = rankIncrement, minIncrement = minIncrement, nullMinIncrement = nullMinIncrement, maxIncrement = maxIncrement, nullMaxIncrement = nullMaxIncrement, validate = validate, active = active, triggerDefinition = triggerDefinition)

        return request<Unit, AchievementResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateAchievement
     *
     * @param deviceId a unique id given by the device (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param achievementId the achievement ID for updating an existing achievement (optional)
     * @param analyticsTag the analytics tag that will trigger when a user&#39;s achievement count gets updated (optional)
     * @param title the title of the achievement (255 character limit) (optional)
     * @param description the description of the achievement (optional)
     * @param rankType the rank type for updating leader boards (optional)
     * @param rankIncrement determines how much the rank count is incremented (optional)
     * @param minIncrement restrict scores to be above or equal to this minimum value (optional)
     * @param nullMinIncrement enable to ignore usage of minIncrement (optional)
     * @param maxIncrement restrict scores to be below or equal to this maximum value (optional)
     * @param nullMaxIncrement enable to ignore usage of maxIncrement (optional)
     * @param validate determines whether the customId on analytics are used to validate a user&#39;s achievement progress. (optional)
     * @param active if it&#39;s active or inactive (optional)
     * @param triggerDefinition if provided will define what triggers to run after a tier is completed (optional)
     * @return RequestConfig
     */
    fun updateAchievementRequestConfig(deviceId: kotlin.String?, accountId: kotlin.Long?, achievementId: kotlin.Long?, analyticsTag: kotlin.String?, title: kotlin.String?, description: kotlin.String?, rankType: kotlin.String?, rankIncrement: kotlin.Int?, minIncrement: kotlin.Int?, nullMinIncrement: kotlin.Boolean?, maxIncrement: kotlin.Int?, nullMaxIncrement: kotlin.Boolean?, validate: kotlin.Boolean?, active: kotlin.Boolean?, triggerDefinition: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (achievementId != null) {
                    put("achievementId", listOf(achievementId.toString()))
                }
                if (analyticsTag != null) {
                    put("analyticsTag", listOf(analyticsTag.toString()))
                }
                if (title != null) {
                    put("title", listOf(title.toString()))
                }
                if (description != null) {
                    put("description", listOf(description.toString()))
                }
                if (rankType != null) {
                    put("rankType", listOf(rankType.toString()))
                }
                if (rankIncrement != null) {
                    put("rankIncrement", listOf(rankIncrement.toString()))
                }
                if (minIncrement != null) {
                    put("minIncrement", listOf(minIncrement.toString()))
                }
                if (nullMinIncrement != null) {
                    put("nullMinIncrement", listOf(nullMinIncrement.toString()))
                }
                if (maxIncrement != null) {
                    put("maxIncrement", listOf(maxIncrement.toString()))
                }
                if (nullMaxIncrement != null) {
                    put("nullMaxIncrement", listOf(nullMaxIncrement.toString()))
                }
                if (validate != null) {
                    put("validate", listOf(validate.toString()))
                }
                if (active != null) {
                    put("active", listOf(active.toString()))
                }
                if (triggerDefinition != null) {
                    put("triggerDefinition", listOf(triggerDefinition.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/achievement/update",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /achievement/tier/update
     * Update Achievement Tier
     * Updates a tier of an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.
     * @param achievementTierId the achievement tier id for updating
     * @param deviceId a unique id given by the device (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param icon achievement tier icon image file (optional)
     * @param iconAssetId the icon assetId, if icon is provided, icon will overrule (optional)
     * @param title the title of the achievement tier (optional)
     * @param description the description of the achievement tier (optional)
     * @param goalCount the count requirement for completing the achievement tier (optional)
     * @param missionId The ID of the mission to associate with the achievement (optional)
     * @param gameId The ID of the game to associate with the achievement (optional)
     * @param packId The ID of the pack to associate with the achievement (optional)
     * @param gameLevelId The ID of the game level to associate with the achievement (optional)
     * @param gameObjectId The ID of the game object to associate with the achievement (optional)
     * @param scoreAllInstances score all instances (optional)
     * @return AchievementTierResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updateAchievementTier(achievementTierId: kotlin.Long, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, icon: java.io.File? = null, iconAssetId: kotlin.Long? = null, title: kotlin.String? = null, description: kotlin.String? = null, goalCount: kotlin.Long? = null, missionId: kotlin.Long? = null, gameId: kotlin.Long? = null, packId: kotlin.Long? = null, gameLevelId: kotlin.Long? = null, gameObjectId: kotlin.Long? = null, scoreAllInstances: kotlin.Boolean? = null) : AchievementTierResponse {
        val localVarResponse = updateAchievementTierWithHttpInfo(achievementTierId = achievementTierId, deviceId = deviceId, accountId = accountId, icon = icon, iconAssetId = iconAssetId, title = title, description = description, goalCount = goalCount, missionId = missionId, gameId = gameId, packId = packId, gameLevelId = gameLevelId, gameObjectId = gameObjectId, scoreAllInstances = scoreAllInstances)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AchievementTierResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /achievement/tier/update
     * Update Achievement Tier
     * Updates a tier of an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.
     * @param achievementTierId the achievement tier id for updating
     * @param deviceId a unique id given by the device (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param icon achievement tier icon image file (optional)
     * @param iconAssetId the icon assetId, if icon is provided, icon will overrule (optional)
     * @param title the title of the achievement tier (optional)
     * @param description the description of the achievement tier (optional)
     * @param goalCount the count requirement for completing the achievement tier (optional)
     * @param missionId The ID of the mission to associate with the achievement (optional)
     * @param gameId The ID of the game to associate with the achievement (optional)
     * @param packId The ID of the pack to associate with the achievement (optional)
     * @param gameLevelId The ID of the game level to associate with the achievement (optional)
     * @param gameObjectId The ID of the game object to associate with the achievement (optional)
     * @param scoreAllInstances score all instances (optional)
     * @return ApiResponse<AchievementTierResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun updateAchievementTierWithHttpInfo(achievementTierId: kotlin.Long, deviceId: kotlin.String?, accountId: kotlin.Long?, icon: java.io.File?, iconAssetId: kotlin.Long?, title: kotlin.String?, description: kotlin.String?, goalCount: kotlin.Long?, missionId: kotlin.Long?, gameId: kotlin.Long?, packId: kotlin.Long?, gameLevelId: kotlin.Long?, gameObjectId: kotlin.Long?, scoreAllInstances: kotlin.Boolean?) : ApiResponse<AchievementTierResponse?> {
        val localVariableConfig = updateAchievementTierRequestConfig(achievementTierId = achievementTierId, deviceId = deviceId, accountId = accountId, icon = icon, iconAssetId = iconAssetId, title = title, description = description, goalCount = goalCount, missionId = missionId, gameId = gameId, packId = packId, gameLevelId = gameLevelId, gameObjectId = gameObjectId, scoreAllInstances = scoreAllInstances)

        return request<Unit, AchievementTierResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateAchievementTier
     *
     * @param achievementTierId the achievement tier id for updating
     * @param deviceId a unique id given by the device (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param icon achievement tier icon image file (optional)
     * @param iconAssetId the icon assetId, if icon is provided, icon will overrule (optional)
     * @param title the title of the achievement tier (optional)
     * @param description the description of the achievement tier (optional)
     * @param goalCount the count requirement for completing the achievement tier (optional)
     * @param missionId The ID of the mission to associate with the achievement (optional)
     * @param gameId The ID of the game to associate with the achievement (optional)
     * @param packId The ID of the pack to associate with the achievement (optional)
     * @param gameLevelId The ID of the game level to associate with the achievement (optional)
     * @param gameObjectId The ID of the game object to associate with the achievement (optional)
     * @param scoreAllInstances score all instances (optional)
     * @return RequestConfig
     */
    fun updateAchievementTierRequestConfig(achievementTierId: kotlin.Long, deviceId: kotlin.String?, accountId: kotlin.Long?, icon: java.io.File?, iconAssetId: kotlin.Long?, title: kotlin.String?, description: kotlin.String?, goalCount: kotlin.Long?, missionId: kotlin.Long?, gameId: kotlin.Long?, packId: kotlin.Long?, gameLevelId: kotlin.Long?, gameObjectId: kotlin.Long?, scoreAllInstances: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                put("achievementTierId", listOf(achievementTierId.toString()))
                if (icon != null) {
                    put("icon", listOf(icon.toString()))
                }
                if (iconAssetId != null) {
                    put("iconAssetId", listOf(iconAssetId.toString()))
                }
                if (title != null) {
                    put("title", listOf(title.toString()))
                }
                if (description != null) {
                    put("description", listOf(description.toString()))
                }
                if (goalCount != null) {
                    put("goalCount", listOf(goalCount.toString()))
                }
                if (missionId != null) {
                    put("missionId", listOf(missionId.toString()))
                }
                if (gameId != null) {
                    put("gameId", listOf(gameId.toString()))
                }
                if (packId != null) {
                    put("packId", listOf(packId.toString()))
                }
                if (gameLevelId != null) {
                    put("gameLevelId", listOf(gameLevelId.toString()))
                }
                if (gameObjectId != null) {
                    put("gameObjectId", listOf(gameObjectId.toString()))
                }
                if (scoreAllInstances != null) {
                    put("scoreAllInstances", listOf(scoreAllInstances.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/achievement/tier/update",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /achievement/progress/update
     * Update Achievement Progress
     * Update user achievement progress.
     * @param accountId the account id of the user
     * @param achievementId the achievement id (achievementId or tag required) (optional)
     * @param tag the analytic tag to identify an achievement (achievementId or tag required) (optional)
     * @param customId a custom identifier used for validation (optional)
     * @param increment the amount to increment an achievement progress by (if no increment is sent in, the server defaults to using the achievement&#39;s rankIncrement value) (optional)
     * @param startDate a custom start date that the client can set (not yet used in server logic) (optional)
     * @param endDate a custom end date that the client can set (not yet used in server logic) (optional)
     * @param returnProgress determines whether to return the achievement progress response (optional)
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updateUserAchievement(accountId: kotlin.Long, achievementId: kotlin.Long? = null, tag: kotlin.String? = null, customId: kotlin.Long? = null, increment: kotlin.Long? = null, startDate: kotlin.Long? = null, endDate: kotlin.Long? = null, returnProgress: kotlin.Boolean? = null) : SirqulResponse {
        val localVarResponse = updateUserAchievementWithHttpInfo(accountId = accountId, achievementId = achievementId, tag = tag, customId = customId, increment = increment, startDate = startDate, endDate = endDate, returnProgress = returnProgress)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /achievement/progress/update
     * Update Achievement Progress
     * Update user achievement progress.
     * @param accountId the account id of the user
     * @param achievementId the achievement id (achievementId or tag required) (optional)
     * @param tag the analytic tag to identify an achievement (achievementId or tag required) (optional)
     * @param customId a custom identifier used for validation (optional)
     * @param increment the amount to increment an achievement progress by (if no increment is sent in, the server defaults to using the achievement&#39;s rankIncrement value) (optional)
     * @param startDate a custom start date that the client can set (not yet used in server logic) (optional)
     * @param endDate a custom end date that the client can set (not yet used in server logic) (optional)
     * @param returnProgress determines whether to return the achievement progress response (optional)
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun updateUserAchievementWithHttpInfo(accountId: kotlin.Long, achievementId: kotlin.Long?, tag: kotlin.String?, customId: kotlin.Long?, increment: kotlin.Long?, startDate: kotlin.Long?, endDate: kotlin.Long?, returnProgress: kotlin.Boolean?) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = updateUserAchievementRequestConfig(accountId = accountId, achievementId = achievementId, tag = tag, customId = customId, increment = increment, startDate = startDate, endDate = endDate, returnProgress = returnProgress)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateUserAchievement
     *
     * @param accountId the account id of the user
     * @param achievementId the achievement id (achievementId or tag required) (optional)
     * @param tag the analytic tag to identify an achievement (achievementId or tag required) (optional)
     * @param customId a custom identifier used for validation (optional)
     * @param increment the amount to increment an achievement progress by (if no increment is sent in, the server defaults to using the achievement&#39;s rankIncrement value) (optional)
     * @param startDate a custom start date that the client can set (not yet used in server logic) (optional)
     * @param endDate a custom end date that the client can set (not yet used in server logic) (optional)
     * @param returnProgress determines whether to return the achievement progress response (optional)
     * @return RequestConfig
     */
    fun updateUserAchievementRequestConfig(accountId: kotlin.Long, achievementId: kotlin.Long?, tag: kotlin.String?, customId: kotlin.Long?, increment: kotlin.Long?, startDate: kotlin.Long?, endDate: kotlin.Long?, returnProgress: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                if (achievementId != null) {
                    put("achievementId", listOf(achievementId.toString()))
                }
                if (tag != null) {
                    put("tag", listOf(tag.toString()))
                }
                if (customId != null) {
                    put("customId", listOf(customId.toString()))
                }
                if (increment != null) {
                    put("increment", listOf(increment.toString()))
                }
                if (startDate != null) {
                    put("startDate", listOf(startDate.toString()))
                }
                if (endDate != null) {
                    put("endDate", listOf(endDate.toString()))
                }
                if (returnProgress != null) {
                    put("returnProgress", listOf(returnProgress.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/achievement/progress/update",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
