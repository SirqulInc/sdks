/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import org.openapitools.client.models.EventAttendanceResponse
import org.openapitools.client.models.OfferResponse
import org.openapitools.client.models.OfferShortResponse
import org.openapitools.client.models.SirqulResponse

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

open class EventApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://dev.sirqul.com/api/3.18")
        }
    }

    /**
     * POST /event/attend
     * Attend Event
     *  Specify whether the user is attending an event at a particular location. This can also be used as a \&quot;check-in\&quot; action.
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id (deviceId or accountId required) (optional)
     * @param appKey The application of where to send notifications about the attend action (optional)
     * @param listingId The scheduled broadcast or marketing experience id (optional)
     * @param retailerLocationId The retailer location where the event is being held (optional)
     * @param offerLocationId The actual event being held (optional)
     * @param transactionId The wallet item to update the status of, if provided then ignore the listingId, retailerLocationId, and the offerLocationId (optional)
     * @param status Sets whether the user is: undecided (0), attending (1), attending and checked in (2), or not attending (3) (optional)
     * @param latitude The location of the status update (optional)
     * @param longitude The location of the status update (optional)
     * @return OfferResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun attendEvent(deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, appKey: kotlin.String? = null, listingId: kotlin.Long? = null, retailerLocationId: kotlin.Long? = null, offerLocationId: kotlin.Long? = null, transactionId: kotlin.Long? = null, status: kotlin.Int? = null, latitude: kotlin.Double? = null, longitude: kotlin.Double? = null) : OfferResponse {
        val localVarResponse = attendEventWithHttpInfo(deviceId = deviceId, accountId = accountId, appKey = appKey, listingId = listingId, retailerLocationId = retailerLocationId, offerLocationId = offerLocationId, transactionId = transactionId, status = status, latitude = latitude, longitude = longitude)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OfferResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /event/attend
     * Attend Event
     *  Specify whether the user is attending an event at a particular location. This can also be used as a \&quot;check-in\&quot; action.
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id (deviceId or accountId required) (optional)
     * @param appKey The application of where to send notifications about the attend action (optional)
     * @param listingId The scheduled broadcast or marketing experience id (optional)
     * @param retailerLocationId The retailer location where the event is being held (optional)
     * @param offerLocationId The actual event being held (optional)
     * @param transactionId The wallet item to update the status of, if provided then ignore the listingId, retailerLocationId, and the offerLocationId (optional)
     * @param status Sets whether the user is: undecided (0), attending (1), attending and checked in (2), or not attending (3) (optional)
     * @param latitude The location of the status update (optional)
     * @param longitude The location of the status update (optional)
     * @return ApiResponse<OfferResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun attendEventWithHttpInfo(deviceId: kotlin.String?, accountId: kotlin.Long?, appKey: kotlin.String?, listingId: kotlin.Long?, retailerLocationId: kotlin.Long?, offerLocationId: kotlin.Long?, transactionId: kotlin.Long?, status: kotlin.Int?, latitude: kotlin.Double?, longitude: kotlin.Double?) : ApiResponse<OfferResponse?> {
        val localVariableConfig = attendEventRequestConfig(deviceId = deviceId, accountId = accountId, appKey = appKey, listingId = listingId, retailerLocationId = retailerLocationId, offerLocationId = offerLocationId, transactionId = transactionId, status = status, latitude = latitude, longitude = longitude)

        return request<Unit, OfferResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation attendEvent
     *
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id (deviceId or accountId required) (optional)
     * @param appKey The application of where to send notifications about the attend action (optional)
     * @param listingId The scheduled broadcast or marketing experience id (optional)
     * @param retailerLocationId The retailer location where the event is being held (optional)
     * @param offerLocationId The actual event being held (optional)
     * @param transactionId The wallet item to update the status of, if provided then ignore the listingId, retailerLocationId, and the offerLocationId (optional)
     * @param status Sets whether the user is: undecided (0), attending (1), attending and checked in (2), or not attending (3) (optional)
     * @param latitude The location of the status update (optional)
     * @param longitude The location of the status update (optional)
     * @return RequestConfig
     */
    fun attendEventRequestConfig(deviceId: kotlin.String?, accountId: kotlin.Long?, appKey: kotlin.String?, listingId: kotlin.Long?, retailerLocationId: kotlin.Long?, offerLocationId: kotlin.Long?, transactionId: kotlin.Long?, status: kotlin.Int?, latitude: kotlin.Double?, longitude: kotlin.Double?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (appKey != null) {
                    put("appKey", listOf(appKey.toString()))
                }
                if (listingId != null) {
                    put("listingId", listOf(listingId.toString()))
                }
                if (retailerLocationId != null) {
                    put("retailerLocationId", listOf(retailerLocationId.toString()))
                }
                if (offerLocationId != null) {
                    put("offerLocationId", listOf(offerLocationId.toString()))
                }
                if (transactionId != null) {
                    put("transactionId", listOf(transactionId.toString()))
                }
                if (status != null) {
                    put("status", listOf(status.toString()))
                }
                if (latitude != null) {
                    put("latitude", listOf(latitude.toString()))
                }
                if (longitude != null) {
                    put("longitude", listOf(longitude.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/event/attend",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /event/create
     * Create Event
     * Create a private event to share with associates.
     * @param accountId The logged in user.
     * @param title The event title
     * @param retailerLocationIds The retailer location to have the event at (optional)
     * @param subTitle The event sub title (optional)
     * @param details The event details (optional)
     * @param categoryIds The categories the associate the event with (optional)
     * @param filterIds The filters the associate the event with (optional)
     * @param active Is this event active (optional)
     * @param imageAssetId The image to show for the event (optional)
     * @param redeemableStart The event start date/time (optional)
     * @param redeemableEnd The event end date/time (optional)
     * @param metaData external custom client defined data (optional)
     * @return OfferResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createEvent(accountId: kotlin.Long, title: kotlin.String, retailerLocationIds: kotlin.String? = null, subTitle: kotlin.String? = null, details: kotlin.String? = null, categoryIds: kotlin.String? = null, filterIds: kotlin.String? = null, active: kotlin.Boolean? = null, imageAssetId: kotlin.Long? = null, redeemableStart: kotlin.Long? = null, redeemableEnd: kotlin.Long? = null, metaData: kotlin.String? = null) : OfferResponse {
        val localVarResponse = createEventWithHttpInfo(accountId = accountId, title = title, retailerLocationIds = retailerLocationIds, subTitle = subTitle, details = details, categoryIds = categoryIds, filterIds = filterIds, active = active, imageAssetId = imageAssetId, redeemableStart = redeemableStart, redeemableEnd = redeemableEnd, metaData = metaData)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OfferResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /event/create
     * Create Event
     * Create a private event to share with associates.
     * @param accountId The logged in user.
     * @param title The event title
     * @param retailerLocationIds The retailer location to have the event at (optional)
     * @param subTitle The event sub title (optional)
     * @param details The event details (optional)
     * @param categoryIds The categories the associate the event with (optional)
     * @param filterIds The filters the associate the event with (optional)
     * @param active Is this event active (optional)
     * @param imageAssetId The image to show for the event (optional)
     * @param redeemableStart The event start date/time (optional)
     * @param redeemableEnd The event end date/time (optional)
     * @param metaData external custom client defined data (optional)
     * @return ApiResponse<OfferResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createEventWithHttpInfo(accountId: kotlin.Long, title: kotlin.String, retailerLocationIds: kotlin.String?, subTitle: kotlin.String?, details: kotlin.String?, categoryIds: kotlin.String?, filterIds: kotlin.String?, active: kotlin.Boolean?, imageAssetId: kotlin.Long?, redeemableStart: kotlin.Long?, redeemableEnd: kotlin.Long?, metaData: kotlin.String?) : ApiResponse<OfferResponse?> {
        val localVariableConfig = createEventRequestConfig(accountId = accountId, title = title, retailerLocationIds = retailerLocationIds, subTitle = subTitle, details = details, categoryIds = categoryIds, filterIds = filterIds, active = active, imageAssetId = imageAssetId, redeemableStart = redeemableStart, redeemableEnd = redeemableEnd, metaData = metaData)

        return request<Unit, OfferResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createEvent
     *
     * @param accountId The logged in user.
     * @param title The event title
     * @param retailerLocationIds The retailer location to have the event at (optional)
     * @param subTitle The event sub title (optional)
     * @param details The event details (optional)
     * @param categoryIds The categories the associate the event with (optional)
     * @param filterIds The filters the associate the event with (optional)
     * @param active Is this event active (optional)
     * @param imageAssetId The image to show for the event (optional)
     * @param redeemableStart The event start date/time (optional)
     * @param redeemableEnd The event end date/time (optional)
     * @param metaData external custom client defined data (optional)
     * @return RequestConfig
     */
    fun createEventRequestConfig(accountId: kotlin.Long, title: kotlin.String, retailerLocationIds: kotlin.String?, subTitle: kotlin.String?, details: kotlin.String?, categoryIds: kotlin.String?, filterIds: kotlin.String?, active: kotlin.Boolean?, imageAssetId: kotlin.Long?, redeemableStart: kotlin.Long?, redeemableEnd: kotlin.Long?, metaData: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                if (retailerLocationIds != null) {
                    put("retailerLocationIds", listOf(retailerLocationIds.toString()))
                }
                put("title", listOf(title.toString()))
                if (subTitle != null) {
                    put("subTitle", listOf(subTitle.toString()))
                }
                if (details != null) {
                    put("details", listOf(details.toString()))
                }
                if (categoryIds != null) {
                    put("categoryIds", listOf(categoryIds.toString()))
                }
                if (filterIds != null) {
                    put("filterIds", listOf(filterIds.toString()))
                }
                if (active != null) {
                    put("active", listOf(active.toString()))
                }
                if (imageAssetId != null) {
                    put("imageAssetId", listOf(imageAssetId.toString()))
                }
                if (redeemableStart != null) {
                    put("redeemableStart", listOf(redeemableStart.toString()))
                }
                if (redeemableEnd != null) {
                    put("redeemableEnd", listOf(redeemableEnd.toString()))
                }
                if (metaData != null) {
                    put("metaData", listOf(metaData.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/event/create",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /event/delete
     * Delete Event
     * Delete an event that the user has permissions to.
     * @param accountId the id of the logged in user
     * @param eventId the id of the event to update
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteEvent(accountId: kotlin.Long, eventId: kotlin.Long) : SirqulResponse {
        val localVarResponse = deleteEventWithHttpInfo(accountId = accountId, eventId = eventId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /event/delete
     * Delete Event
     * Delete an event that the user has permissions to.
     * @param accountId the id of the logged in user
     * @param eventId the id of the event to update
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteEventWithHttpInfo(accountId: kotlin.Long, eventId: kotlin.Long) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = deleteEventRequestConfig(accountId = accountId, eventId = eventId)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteEvent
     *
     * @param accountId the id of the logged in user
     * @param eventId the id of the event to update
     * @return RequestConfig
     */
    fun deleteEventRequestConfig(accountId: kotlin.Long, eventId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("eventId", listOf(eventId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/event/delete",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /event/get
     * Get Event
     * Get an event.
     * @param accountId the id of the logged in user
     * @param eventId The id of the event to return
     * @return OfferResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getEvent(accountId: kotlin.Long, eventId: kotlin.Long) : OfferResponse {
        val localVarResponse = getEventWithHttpInfo(accountId = accountId, eventId = eventId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OfferResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /event/get
     * Get Event
     * Get an event.
     * @param accountId the id of the logged in user
     * @param eventId The id of the event to return
     * @return ApiResponse<OfferResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getEventWithHttpInfo(accountId: kotlin.Long, eventId: kotlin.Long) : ApiResponse<OfferResponse?> {
        val localVariableConfig = getEventRequestConfig(accountId = accountId, eventId = eventId)

        return request<Unit, OfferResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getEvent
     *
     * @param accountId the id of the logged in user
     * @param eventId The id of the event to return
     * @return RequestConfig
     */
    fun getEventRequestConfig(accountId: kotlin.Long, eventId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("eventId", listOf(eventId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/event/get",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter sortField
     */
     enum class SortFieldSearchEventTransactions(val value: kotlin.String) {
         @Json(name = "ID") ID("ID"),
         @Json(name = "CREATED") CREATED("CREATED"),
         @Json(name = "UPDATED") UPDATED("UPDATED"),
         @Json(name = "DELETED") DELETED("DELETED"),
         @Json(name = "SEARCH_TAGS") SEARCH_TAGS("SEARCH_TAGS"),
         @Json(name = "ACTIVE") ACTIVE("ACTIVE"),
         @Json(name = "ACTIVATED") ACTIVATED("ACTIVATED"),
         @Json(name = "EXPIRES") EXPIRES("EXPIRES"),
         @Json(name = "TITLE") TITLE("TITLE"),
         @Json(name = "SUBTITLE") SUBTITLE("SUBTITLE"),
         @Json(name = "DETAILS") DETAILS("DETAILS"),
         @Json(name = "OFFER_TYPE") OFFER_TYPE("OFFER_TYPE"),
         @Json(name = "SPECIAL_OFFER_TYPE") SPECIAL_OFFER_TYPE("SPECIAL_OFFER_TYPE"),
         @Json(name = "OFFER_VISIBILITY") OFFER_VISIBILITY("OFFER_VISIBILITY"),
         @Json(name = "REDEEMABLE_START") REDEEMABLE_START("REDEEMABLE_START"),
         @Json(name = "REDEEMABLE_END") REDEEMABLE_END("REDEEMABLE_END"),
         @Json(name = "CUSTOMER_ID") CUSTOMER_ID("CUSTOMER_ID"),
         @Json(name = "CUSTOMER_DISPLAY") CUSTOMER_DISPLAY("CUSTOMER_DISPLAY"),
         @Json(name = "RETAILER_ID") RETAILER_ID("RETAILER_ID"),
         @Json(name = "RETAILER_NAME") RETAILER_NAME("RETAILER_NAME"),
         @Json(name = "RETAILER_LOCATION_ID") RETAILER_LOCATION_ID("RETAILER_LOCATION_ID"),
         @Json(name = "RETAILER_LOCATION_NAME") RETAILER_LOCATION_NAME("RETAILER_LOCATION_NAME"),
         @Json(name = "BILLABLE_ENTITY_ID") BILLABLE_ENTITY_ID("BILLABLE_ENTITY_ID"),
         @Json(name = "BILLABLE_ENTITY_NAME") BILLABLE_ENTITY_NAME("BILLABLE_ENTITY_NAME"),
         @Json(name = "RESPONSIBLE_DISPLAY") RESPONSIBLE_DISPLAY("RESPONSIBLE_DISPLAY");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /event/attendance/search
     * Search Event Attendance
     * Searches on event type transactions. This can be used to see who is attending an event.
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param appKey The application key (optional)
     * @param keyword The keyword to search for (optional)
     * @param retailerId Filter results for this retailer (optional)
     * @param retailerLocationId Filter results for this retailer location (optional)
     * @param excludeRetailerLocationId Exclude results from this retailer location (optional)
     * @param listingId Filter results for this event listing (optional)
     * @param offerId Filter results for this offer (optional)
     * @param offerLocationId Filter results for this offer location (optional)
     * @param customerAccountIds Filter results by accounts (optional)
     * @param affiliatedCategoryIds Comma separated list of category ids to determine whether the attendee is affiliated with the category (optional)
     * @param startDate Filter on attendance starting on or after this date (milliseconds since epoch) (optional)
     * @param endDate Filter on attendance starting on or before this date (milliseconds since epoch) (optional)
     * @param statuses Comma separated list of transaction statuses to filter on (optional)
     * @param sortField Determines what to sort the results by {CREATED, UPDATED, SEARCH_TAGS, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, CUSTOMER_ID, CUSTOMER_DISPLAY, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY} (optional)
     * @param descending Determines whether the results are in descending order (optional)
     * @param start The start index for pagination (optional)
     * @param limit The limit for pagination (optional)
     * @return kotlin.collections.List<EventAttendanceResponse>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun searchEventTransactions(deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, appKey: kotlin.String? = null, keyword: kotlin.String? = null, retailerId: kotlin.Long? = null, retailerLocationId: kotlin.Long? = null, excludeRetailerLocationId: kotlin.Long? = null, listingId: kotlin.Long? = null, offerId: kotlin.Long? = null, offerLocationId: kotlin.Long? = null, customerAccountIds: kotlin.String? = null, affiliatedCategoryIds: kotlin.String? = null, startDate: kotlin.Long? = null, endDate: kotlin.Long? = null, statuses: kotlin.String? = null, sortField: SortFieldSearchEventTransactions? = null, descending: kotlin.Boolean? = null, start: kotlin.Int? = null, limit: kotlin.Int? = null) : kotlin.collections.List<EventAttendanceResponse> {
        val localVarResponse = searchEventTransactionsWithHttpInfo(deviceId = deviceId, accountId = accountId, appKey = appKey, keyword = keyword, retailerId = retailerId, retailerLocationId = retailerLocationId, excludeRetailerLocationId = excludeRetailerLocationId, listingId = listingId, offerId = offerId, offerLocationId = offerLocationId, customerAccountIds = customerAccountIds, affiliatedCategoryIds = affiliatedCategoryIds, startDate = startDate, endDate = endDate, statuses = statuses, sortField = sortField, descending = descending, start = start, limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<EventAttendanceResponse>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /event/attendance/search
     * Search Event Attendance
     * Searches on event type transactions. This can be used to see who is attending an event.
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param appKey The application key (optional)
     * @param keyword The keyword to search for (optional)
     * @param retailerId Filter results for this retailer (optional)
     * @param retailerLocationId Filter results for this retailer location (optional)
     * @param excludeRetailerLocationId Exclude results from this retailer location (optional)
     * @param listingId Filter results for this event listing (optional)
     * @param offerId Filter results for this offer (optional)
     * @param offerLocationId Filter results for this offer location (optional)
     * @param customerAccountIds Filter results by accounts (optional)
     * @param affiliatedCategoryIds Comma separated list of category ids to determine whether the attendee is affiliated with the category (optional)
     * @param startDate Filter on attendance starting on or after this date (milliseconds since epoch) (optional)
     * @param endDate Filter on attendance starting on or before this date (milliseconds since epoch) (optional)
     * @param statuses Comma separated list of transaction statuses to filter on (optional)
     * @param sortField Determines what to sort the results by {CREATED, UPDATED, SEARCH_TAGS, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, CUSTOMER_ID, CUSTOMER_DISPLAY, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY} (optional)
     * @param descending Determines whether the results are in descending order (optional)
     * @param start The start index for pagination (optional)
     * @param limit The limit for pagination (optional)
     * @return ApiResponse<kotlin.collections.List<EventAttendanceResponse>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun searchEventTransactionsWithHttpInfo(deviceId: kotlin.String?, accountId: kotlin.Long?, appKey: kotlin.String?, keyword: kotlin.String?, retailerId: kotlin.Long?, retailerLocationId: kotlin.Long?, excludeRetailerLocationId: kotlin.Long?, listingId: kotlin.Long?, offerId: kotlin.Long?, offerLocationId: kotlin.Long?, customerAccountIds: kotlin.String?, affiliatedCategoryIds: kotlin.String?, startDate: kotlin.Long?, endDate: kotlin.Long?, statuses: kotlin.String?, sortField: SortFieldSearchEventTransactions?, descending: kotlin.Boolean?, start: kotlin.Int?, limit: kotlin.Int?) : ApiResponse<kotlin.collections.List<EventAttendanceResponse>?> {
        val localVariableConfig = searchEventTransactionsRequestConfig(deviceId = deviceId, accountId = accountId, appKey = appKey, keyword = keyword, retailerId = retailerId, retailerLocationId = retailerLocationId, excludeRetailerLocationId = excludeRetailerLocationId, listingId = listingId, offerId = offerId, offerLocationId = offerLocationId, customerAccountIds = customerAccountIds, affiliatedCategoryIds = affiliatedCategoryIds, startDate = startDate, endDate = endDate, statuses = statuses, sortField = sortField, descending = descending, start = start, limit = limit)

        return request<Unit, kotlin.collections.List<EventAttendanceResponse>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation searchEventTransactions
     *
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param appKey The application key (optional)
     * @param keyword The keyword to search for (optional)
     * @param retailerId Filter results for this retailer (optional)
     * @param retailerLocationId Filter results for this retailer location (optional)
     * @param excludeRetailerLocationId Exclude results from this retailer location (optional)
     * @param listingId Filter results for this event listing (optional)
     * @param offerId Filter results for this offer (optional)
     * @param offerLocationId Filter results for this offer location (optional)
     * @param customerAccountIds Filter results by accounts (optional)
     * @param affiliatedCategoryIds Comma separated list of category ids to determine whether the attendee is affiliated with the category (optional)
     * @param startDate Filter on attendance starting on or after this date (milliseconds since epoch) (optional)
     * @param endDate Filter on attendance starting on or before this date (milliseconds since epoch) (optional)
     * @param statuses Comma separated list of transaction statuses to filter on (optional)
     * @param sortField Determines what to sort the results by {CREATED, UPDATED, SEARCH_TAGS, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, CUSTOMER_ID, CUSTOMER_DISPLAY, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY} (optional)
     * @param descending Determines whether the results are in descending order (optional)
     * @param start The start index for pagination (optional)
     * @param limit The limit for pagination (optional)
     * @return RequestConfig
     */
    fun searchEventTransactionsRequestConfig(deviceId: kotlin.String?, accountId: kotlin.Long?, appKey: kotlin.String?, keyword: kotlin.String?, retailerId: kotlin.Long?, retailerLocationId: kotlin.Long?, excludeRetailerLocationId: kotlin.Long?, listingId: kotlin.Long?, offerId: kotlin.Long?, offerLocationId: kotlin.Long?, customerAccountIds: kotlin.String?, affiliatedCategoryIds: kotlin.String?, startDate: kotlin.Long?, endDate: kotlin.Long?, statuses: kotlin.String?, sortField: SortFieldSearchEventTransactions?, descending: kotlin.Boolean?, start: kotlin.Int?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (appKey != null) {
                    put("appKey", listOf(appKey.toString()))
                }
                if (keyword != null) {
                    put("keyword", listOf(keyword.toString()))
                }
                if (retailerId != null) {
                    put("retailerId", listOf(retailerId.toString()))
                }
                if (retailerLocationId != null) {
                    put("retailerLocationId", listOf(retailerLocationId.toString()))
                }
                if (excludeRetailerLocationId != null) {
                    put("excludeRetailerLocationId", listOf(excludeRetailerLocationId.toString()))
                }
                if (listingId != null) {
                    put("listingId", listOf(listingId.toString()))
                }
                if (offerId != null) {
                    put("offerId", listOf(offerId.toString()))
                }
                if (offerLocationId != null) {
                    put("offerLocationId", listOf(offerLocationId.toString()))
                }
                if (customerAccountIds != null) {
                    put("customerAccountIds", listOf(customerAccountIds.toString()))
                }
                if (affiliatedCategoryIds != null) {
                    put("affiliatedCategoryIds", listOf(affiliatedCategoryIds.toString()))
                }
                if (startDate != null) {
                    put("startDate", listOf(startDate.toString()))
                }
                if (endDate != null) {
                    put("endDate", listOf(endDate.toString()))
                }
                if (statuses != null) {
                    put("statuses", listOf(statuses.toString()))
                }
                if (sortField != null) {
                    put("sortField", listOf(sortField.value))
                }
                if (descending != null) {
                    put("descending", listOf(descending.toString()))
                }
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/event/attendance/search",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter sortField
     */
     enum class SortFieldSearchEvents(val value: kotlin.String) {
         @Json(name = "ID") ID("ID"),
         @Json(name = "CREATED") CREATED("CREATED"),
         @Json(name = "UPDATED") UPDATED("UPDATED"),
         @Json(name = "DELETED") DELETED("DELETED"),
         @Json(name = "SEARCH_TAGS") SEARCH_TAGS("SEARCH_TAGS"),
         @Json(name = "ACTIVE") ACTIVE("ACTIVE"),
         @Json(name = "ACTIVATED") ACTIVATED("ACTIVATED"),
         @Json(name = "EXPIRES") EXPIRES("EXPIRES"),
         @Json(name = "REDEEMABLE_START") REDEEMABLE_START("REDEEMABLE_START"),
         @Json(name = "REDEEMABLE_END") REDEEMABLE_END("REDEEMABLE_END"),
         @Json(name = "TITLE") TITLE("TITLE"),
         @Json(name = "SUBTITLE") SUBTITLE("SUBTITLE"),
         @Json(name = "DETAILS") DETAILS("DETAILS"),
         @Json(name = "OFFER_TYPE") OFFER_TYPE("OFFER_TYPE"),
         @Json(name = "SPECIAL_OFFER_TYPE") SPECIAL_OFFER_TYPE("SPECIAL_OFFER_TYPE"),
         @Json(name = "OFFER_VISIBILITY") OFFER_VISIBILITY("OFFER_VISIBILITY"),
         @Json(name = "ESTIMATED_VALUE") ESTIMATED_VALUE("ESTIMATED_VALUE"),
         @Json(name = "VOUCHER_PRICE") VOUCHER_PRICE("VOUCHER_PRICE"),
         @Json(name = "VOUCHER_DISCOUNT_PRICE") VOUCHER_DISCOUNT_PRICE("VOUCHER_DISCOUNT_PRICE"),
         @Json(name = "FULL_PRICE") FULL_PRICE("FULL_PRICE"),
         @Json(name = "DICOUNT_PRICE") DICOUNT_PRICE("DICOUNT_PRICE"),
         @Json(name = "TICKETS_REWARD") TICKETS_REWARD("TICKETS_REWARD"),
         @Json(name = "AVAILABILITY_DATE") AVAILABILITY_DATE("AVAILABILITY_DATE"),
         @Json(name = "RELEASE_DATE") RELEASE_DATE("RELEASE_DATE"),
         @Json(name = "RETAILER_ID") RETAILER_ID("RETAILER_ID"),
         @Json(name = "RETAILER_NAME") RETAILER_NAME("RETAILER_NAME"),
         @Json(name = "RETAILER_LOCATION_ID") RETAILER_LOCATION_ID("RETAILER_LOCATION_ID"),
         @Json(name = "RETAILER_LOCATION_NAME") RETAILER_LOCATION_NAME("RETAILER_LOCATION_NAME"),
         @Json(name = "BILLABLE_ENTITY_ID") BILLABLE_ENTITY_ID("BILLABLE_ENTITY_ID"),
         @Json(name = "BILLABLE_ENTITY_NAME") BILLABLE_ENTITY_NAME("BILLABLE_ENTITY_NAME"),
         @Json(name = "RESPONSIBLE_DISPLAY") RESPONSIBLE_DISPLAY("RESPONSIBLE_DISPLAY");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /event/search
     * Search Events
     * Searches on events that the account has access to.
     * @param accountId The logged in user.
     * @param keyword The keyword used to search (optional)
     * @param activeOnly Return only active results (optional)
     * @param categoryIds the IDs of the categories that this event is associated with (optional)
     * @param filterIds the IDs of the filters that this event is associated with (optional)
     * @param offerAudienceIds Offer audience ids to filter on (optional)
     * @param transactionAudienceIds Transaction audience ids to filter on (optional)
     * @param sortField The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, DETAILS, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, ESTIMATED_VALUE, VOUCHER_PRICE, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY (optional)
     * @param descending The order to return the search results (optional)
     * @param startDate Filter the events to return only those that start on or after the date (optional)
     * @param endDate Filter the events to return only those that start on or before the date (optional)
     * @param start The record to begin the return set on (optional)
     * @param limit The number of records to return (optional)
     * @return kotlin.collections.List<OfferShortResponse>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun searchEvents(accountId: kotlin.Long, keyword: kotlin.String? = null, activeOnly: kotlin.Boolean? = null, categoryIds: kotlin.String? = null, filterIds: kotlin.String? = null, offerAudienceIds: kotlin.String? = null, transactionAudienceIds: kotlin.String? = null, sortField: SortFieldSearchEvents? = null, descending: kotlin.Boolean? = null, startDate: kotlin.Long? = null, endDate: kotlin.Long? = null, start: kotlin.Int? = null, limit: kotlin.Int? = null) : kotlin.collections.List<OfferShortResponse> {
        val localVarResponse = searchEventsWithHttpInfo(accountId = accountId, keyword = keyword, activeOnly = activeOnly, categoryIds = categoryIds, filterIds = filterIds, offerAudienceIds = offerAudienceIds, transactionAudienceIds = transactionAudienceIds, sortField = sortField, descending = descending, startDate = startDate, endDate = endDate, start = start, limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<OfferShortResponse>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /event/search
     * Search Events
     * Searches on events that the account has access to.
     * @param accountId The logged in user.
     * @param keyword The keyword used to search (optional)
     * @param activeOnly Return only active results (optional)
     * @param categoryIds the IDs of the categories that this event is associated with (optional)
     * @param filterIds the IDs of the filters that this event is associated with (optional)
     * @param offerAudienceIds Offer audience ids to filter on (optional)
     * @param transactionAudienceIds Transaction audience ids to filter on (optional)
     * @param sortField The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, DETAILS, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, ESTIMATED_VALUE, VOUCHER_PRICE, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY (optional)
     * @param descending The order to return the search results (optional)
     * @param startDate Filter the events to return only those that start on or after the date (optional)
     * @param endDate Filter the events to return only those that start on or before the date (optional)
     * @param start The record to begin the return set on (optional)
     * @param limit The number of records to return (optional)
     * @return ApiResponse<kotlin.collections.List<OfferShortResponse>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun searchEventsWithHttpInfo(accountId: kotlin.Long, keyword: kotlin.String?, activeOnly: kotlin.Boolean?, categoryIds: kotlin.String?, filterIds: kotlin.String?, offerAudienceIds: kotlin.String?, transactionAudienceIds: kotlin.String?, sortField: SortFieldSearchEvents?, descending: kotlin.Boolean?, startDate: kotlin.Long?, endDate: kotlin.Long?, start: kotlin.Int?, limit: kotlin.Int?) : ApiResponse<kotlin.collections.List<OfferShortResponse>?> {
        val localVariableConfig = searchEventsRequestConfig(accountId = accountId, keyword = keyword, activeOnly = activeOnly, categoryIds = categoryIds, filterIds = filterIds, offerAudienceIds = offerAudienceIds, transactionAudienceIds = transactionAudienceIds, sortField = sortField, descending = descending, startDate = startDate, endDate = endDate, start = start, limit = limit)

        return request<Unit, kotlin.collections.List<OfferShortResponse>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation searchEvents
     *
     * @param accountId The logged in user.
     * @param keyword The keyword used to search (optional)
     * @param activeOnly Return only active results (optional)
     * @param categoryIds the IDs of the categories that this event is associated with (optional)
     * @param filterIds the IDs of the filters that this event is associated with (optional)
     * @param offerAudienceIds Offer audience ids to filter on (optional)
     * @param transactionAudienceIds Transaction audience ids to filter on (optional)
     * @param sortField The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, DETAILS, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, ESTIMATED_VALUE, VOUCHER_PRICE, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY (optional)
     * @param descending The order to return the search results (optional)
     * @param startDate Filter the events to return only those that start on or after the date (optional)
     * @param endDate Filter the events to return only those that start on or before the date (optional)
     * @param start The record to begin the return set on (optional)
     * @param limit The number of records to return (optional)
     * @return RequestConfig
     */
    fun searchEventsRequestConfig(accountId: kotlin.Long, keyword: kotlin.String?, activeOnly: kotlin.Boolean?, categoryIds: kotlin.String?, filterIds: kotlin.String?, offerAudienceIds: kotlin.String?, transactionAudienceIds: kotlin.String?, sortField: SortFieldSearchEvents?, descending: kotlin.Boolean?, startDate: kotlin.Long?, endDate: kotlin.Long?, start: kotlin.Int?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                if (keyword != null) {
                    put("keyword", listOf(keyword.toString()))
                }
                if (activeOnly != null) {
                    put("activeOnly", listOf(activeOnly.toString()))
                }
                if (categoryIds != null) {
                    put("categoryIds", listOf(categoryIds.toString()))
                }
                if (filterIds != null) {
                    put("filterIds", listOf(filterIds.toString()))
                }
                if (offerAudienceIds != null) {
                    put("offerAudienceIds", listOf(offerAudienceIds.toString()))
                }
                if (transactionAudienceIds != null) {
                    put("transactionAudienceIds", listOf(transactionAudienceIds.toString()))
                }
                if (sortField != null) {
                    put("sortField", listOf(sortField.value))
                }
                if (descending != null) {
                    put("descending", listOf(descending.toString()))
                }
                if (startDate != null) {
                    put("startDate", listOf(startDate.toString()))
                }
                if (endDate != null) {
                    put("endDate", listOf(endDate.toString()))
                }
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/event/search",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /event/update
     * Update Event
     * Update a private event to share with associates.
     * @param accountId The logged in user.
     * @param eventId The id of the event to update
     * @param retailerLocationIds The retailer location to have the event at (optional)
     * @param title The event title (optional)
     * @param subTitle The event sub title (optional)
     * @param details The event details (optional)
     * @param categoryIds The categories the associate the event with (optional)
     * @param filterIds The filters the associate the event with (optional)
     * @param active Is this event active (optional)
     * @param imageAssetId The image to show for the event (optional)
     * @param redeemableStart The event start date/time (optional)
     * @param redeemableEnd The event end date/time (optional)
     * @return OfferResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updateEvent(accountId: kotlin.Long, eventId: kotlin.Long, retailerLocationIds: kotlin.String? = null, title: kotlin.String? = null, subTitle: kotlin.String? = null, details: kotlin.String? = null, categoryIds: kotlin.String? = null, filterIds: kotlin.String? = null, active: kotlin.Boolean? = null, imageAssetId: kotlin.Long? = null, redeemableStart: kotlin.Long? = null, redeemableEnd: kotlin.Long? = null) : OfferResponse {
        val localVarResponse = updateEventWithHttpInfo(accountId = accountId, eventId = eventId, retailerLocationIds = retailerLocationIds, title = title, subTitle = subTitle, details = details, categoryIds = categoryIds, filterIds = filterIds, active = active, imageAssetId = imageAssetId, redeemableStart = redeemableStart, redeemableEnd = redeemableEnd)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OfferResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /event/update
     * Update Event
     * Update a private event to share with associates.
     * @param accountId The logged in user.
     * @param eventId The id of the event to update
     * @param retailerLocationIds The retailer location to have the event at (optional)
     * @param title The event title (optional)
     * @param subTitle The event sub title (optional)
     * @param details The event details (optional)
     * @param categoryIds The categories the associate the event with (optional)
     * @param filterIds The filters the associate the event with (optional)
     * @param active Is this event active (optional)
     * @param imageAssetId The image to show for the event (optional)
     * @param redeemableStart The event start date/time (optional)
     * @param redeemableEnd The event end date/time (optional)
     * @return ApiResponse<OfferResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun updateEventWithHttpInfo(accountId: kotlin.Long, eventId: kotlin.Long, retailerLocationIds: kotlin.String?, title: kotlin.String?, subTitle: kotlin.String?, details: kotlin.String?, categoryIds: kotlin.String?, filterIds: kotlin.String?, active: kotlin.Boolean?, imageAssetId: kotlin.Long?, redeemableStart: kotlin.Long?, redeemableEnd: kotlin.Long?) : ApiResponse<OfferResponse?> {
        val localVariableConfig = updateEventRequestConfig(accountId = accountId, eventId = eventId, retailerLocationIds = retailerLocationIds, title = title, subTitle = subTitle, details = details, categoryIds = categoryIds, filterIds = filterIds, active = active, imageAssetId = imageAssetId, redeemableStart = redeemableStart, redeemableEnd = redeemableEnd)

        return request<Unit, OfferResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateEvent
     *
     * @param accountId The logged in user.
     * @param eventId The id of the event to update
     * @param retailerLocationIds The retailer location to have the event at (optional)
     * @param title The event title (optional)
     * @param subTitle The event sub title (optional)
     * @param details The event details (optional)
     * @param categoryIds The categories the associate the event with (optional)
     * @param filterIds The filters the associate the event with (optional)
     * @param active Is this event active (optional)
     * @param imageAssetId The image to show for the event (optional)
     * @param redeemableStart The event start date/time (optional)
     * @param redeemableEnd The event end date/time (optional)
     * @return RequestConfig
     */
    fun updateEventRequestConfig(accountId: kotlin.Long, eventId: kotlin.Long, retailerLocationIds: kotlin.String?, title: kotlin.String?, subTitle: kotlin.String?, details: kotlin.String?, categoryIds: kotlin.String?, filterIds: kotlin.String?, active: kotlin.Boolean?, imageAssetId: kotlin.Long?, redeemableStart: kotlin.Long?, redeemableEnd: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("eventId", listOf(eventId.toString()))
                if (retailerLocationIds != null) {
                    put("retailerLocationIds", listOf(retailerLocationIds.toString()))
                }
                if (title != null) {
                    put("title", listOf(title.toString()))
                }
                if (subTitle != null) {
                    put("subTitle", listOf(subTitle.toString()))
                }
                if (details != null) {
                    put("details", listOf(details.toString()))
                }
                if (categoryIds != null) {
                    put("categoryIds", listOf(categoryIds.toString()))
                }
                if (filterIds != null) {
                    put("filterIds", listOf(filterIds.toString()))
                }
                if (active != null) {
                    put("active", listOf(active.toString()))
                }
                if (imageAssetId != null) {
                    put("imageAssetId", listOf(imageAssetId.toString()))
                }
                if (redeemableStart != null) {
                    put("redeemableStart", listOf(redeemableStart.toString()))
                }
                if (redeemableEnd != null) {
                    put("redeemableEnd", listOf(redeemableEnd.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/event/update",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
