/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import org.openapitools.client.models.DisbursementResponse

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

open class DisbursementApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://dev.sirqul.com/api/3.18")
        }
    }

    /**
     * GET /disbursement/check
     * Check Disbursements
     * Checks the status of a captured disbrusement to see if it has been settled.
     * @param disbursementId the ID of the disbursement being checked on
     * @return DisbursementResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun checkDisbursements(disbursementId: kotlin.Long) : DisbursementResponse {
        val localVarResponse = checkDisbursementsWithHttpInfo(disbursementId = disbursementId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DisbursementResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /disbursement/check
     * Check Disbursements
     * Checks the status of a captured disbrusement to see if it has been settled.
     * @param disbursementId the ID of the disbursement being checked on
     * @return ApiResponse<DisbursementResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun checkDisbursementsWithHttpInfo(disbursementId: kotlin.Long) : ApiResponse<DisbursementResponse?> {
        val localVariableConfig = checkDisbursementsRequestConfig(disbursementId = disbursementId)

        return request<Unit, DisbursementResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation checkDisbursements
     *
     * @param disbursementId the ID of the disbursement being checked on
     * @return RequestConfig
     */
    fun checkDisbursementsRequestConfig(disbursementId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("disbursementId", listOf(disbursementId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/disbursement/check",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter provider
     */
     enum class ProviderCreateDisbursement(val value: kotlin.String) {
         @Json(name = "AUTHORIZE_NET") AUTHORIZE_NET("AUTHORIZE_NET"),
         @Json(name = "AMAZON_FPS") AMAZON_FPS("AMAZON_FPS"),
         @Json(name = "BILL_COM") BILL_COM("BILL_COM");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * POST /disbursement/create
     * Create Disbursement
     * Creates a Disbursement for sending money to a retailer
     * @param accountId the ID of the logging in user (must be an EXECUTIVE account)
     * @param receiverAccountId the ID of the account receiving the disbursement
     * @param originalSenderAccountId the ID of the original sender account
     * @param amount the dollar amount of the disbursement
     * @param provider the provider (e.g. Authorize.net, Bill.com, etc.)
     * @param scheduledDate the date that the disbursement is scheduled to go out to the payment provider (optional)
     * @param title a title given for the disbursement (optional)
     * @param comment a comment that could be made for a disbursement (optional)
     * @param externalId external ID, which can be used as a way to reference the disbursement (optional)
     * @param introspectionParams This is for specifying parameters to make an http callback request for validating that the disbursement is valid (optional)
     * @return DisbursementResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createDisbursement(accountId: kotlin.Long, receiverAccountId: kotlin.Long, originalSenderAccountId: kotlin.Long, amount: java.math.BigDecimal, provider: ProviderCreateDisbursement, scheduledDate: kotlin.Long? = null, title: kotlin.String? = null, comment: kotlin.String? = null, externalId: kotlin.String? = null, introspectionParams: kotlin.String? = null) : DisbursementResponse {
        val localVarResponse = createDisbursementWithHttpInfo(accountId = accountId, receiverAccountId = receiverAccountId, originalSenderAccountId = originalSenderAccountId, amount = amount, provider = provider, scheduledDate = scheduledDate, title = title, comment = comment, externalId = externalId, introspectionParams = introspectionParams)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DisbursementResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /disbursement/create
     * Create Disbursement
     * Creates a Disbursement for sending money to a retailer
     * @param accountId the ID of the logging in user (must be an EXECUTIVE account)
     * @param receiverAccountId the ID of the account receiving the disbursement
     * @param originalSenderAccountId the ID of the original sender account
     * @param amount the dollar amount of the disbursement
     * @param provider the provider (e.g. Authorize.net, Bill.com, etc.)
     * @param scheduledDate the date that the disbursement is scheduled to go out to the payment provider (optional)
     * @param title a title given for the disbursement (optional)
     * @param comment a comment that could be made for a disbursement (optional)
     * @param externalId external ID, which can be used as a way to reference the disbursement (optional)
     * @param introspectionParams This is for specifying parameters to make an http callback request for validating that the disbursement is valid (optional)
     * @return ApiResponse<DisbursementResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createDisbursementWithHttpInfo(accountId: kotlin.Long, receiverAccountId: kotlin.Long, originalSenderAccountId: kotlin.Long, amount: java.math.BigDecimal, provider: ProviderCreateDisbursement, scheduledDate: kotlin.Long?, title: kotlin.String?, comment: kotlin.String?, externalId: kotlin.String?, introspectionParams: kotlin.String?) : ApiResponse<DisbursementResponse?> {
        val localVariableConfig = createDisbursementRequestConfig(accountId = accountId, receiverAccountId = receiverAccountId, originalSenderAccountId = originalSenderAccountId, amount = amount, provider = provider, scheduledDate = scheduledDate, title = title, comment = comment, externalId = externalId, introspectionParams = introspectionParams)

        return request<Unit, DisbursementResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createDisbursement
     *
     * @param accountId the ID of the logging in user (must be an EXECUTIVE account)
     * @param receiverAccountId the ID of the account receiving the disbursement
     * @param originalSenderAccountId the ID of the original sender account
     * @param amount the dollar amount of the disbursement
     * @param provider the provider (e.g. Authorize.net, Bill.com, etc.)
     * @param scheduledDate the date that the disbursement is scheduled to go out to the payment provider (optional)
     * @param title a title given for the disbursement (optional)
     * @param comment a comment that could be made for a disbursement (optional)
     * @param externalId external ID, which can be used as a way to reference the disbursement (optional)
     * @param introspectionParams This is for specifying parameters to make an http callback request for validating that the disbursement is valid (optional)
     * @return RequestConfig
     */
    fun createDisbursementRequestConfig(accountId: kotlin.Long, receiverAccountId: kotlin.Long, originalSenderAccountId: kotlin.Long, amount: java.math.BigDecimal, provider: ProviderCreateDisbursement, scheduledDate: kotlin.Long?, title: kotlin.String?, comment: kotlin.String?, externalId: kotlin.String?, introspectionParams: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("receiverAccountId", listOf(receiverAccountId.toString()))
                put("originalSenderAccountId", listOf(originalSenderAccountId.toString()))
                put("amount", listOf(amount.toString()))
                put("provider", listOf(provider.value))
                if (scheduledDate != null) {
                    put("scheduledDate", listOf(scheduledDate.toString()))
                }
                if (title != null) {
                    put("title", listOf(title.toString()))
                }
                if (comment != null) {
                    put("comment", listOf(comment.toString()))
                }
                if (externalId != null) {
                    put("externalId", listOf(externalId.toString()))
                }
                if (introspectionParams != null) {
                    put("introspectionParams", listOf(introspectionParams.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/disbursement/create",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /disbursement/get
     * Get Disbursement
     * Get Disbursement details
     * @param accountId The logged in user.
     * @param disbursementId the id of the disbursement
     * @return DisbursementResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getDisbursement(accountId: kotlin.Long, disbursementId: kotlin.Long) : DisbursementResponse {
        val localVarResponse = getDisbursementWithHttpInfo(accountId = accountId, disbursementId = disbursementId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DisbursementResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /disbursement/get
     * Get Disbursement
     * Get Disbursement details
     * @param accountId The logged in user.
     * @param disbursementId the id of the disbursement
     * @return ApiResponse<DisbursementResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getDisbursementWithHttpInfo(accountId: kotlin.Long, disbursementId: kotlin.Long) : ApiResponse<DisbursementResponse?> {
        val localVariableConfig = getDisbursementRequestConfig(accountId = accountId, disbursementId = disbursementId)

        return request<Unit, DisbursementResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getDisbursement
     *
     * @param accountId The logged in user.
     * @param disbursementId the id of the disbursement
     * @return RequestConfig
     */
    fun getDisbursementRequestConfig(accountId: kotlin.Long, disbursementId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("disbursementId", listOf(disbursementId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/disbursement/get",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /disbursement/search
     * Search Disbursements
     * Search Disbursements
     * @param accountId the id of the logged in user
     * @param receiverAccountId filter results by the id of the account receiving the disbursement (optional)
     * @param statuses comma separated list of status values to search for, possilbe values include: NEW, APPROVED, VALIDATING, ERROR, AUTHORIZED, CAPTURED, SETTLED (optional)
     * @param providers comma separated list of payment providers to search for, possbile values include: AUTHORIZE_NET, AMAZON_FPS, BILL_COM (optional)
     * @param beforeDate the date for searching disbursements before it has been processed (optional)
     * @param afterDate the date for searching disbursements before it has been processed (optional)
     * @param start the start index for pagination (optional, default to 0)
     * @param limit the limit per result set for pagination (optional, default to 20)
     * @param activeOnly search on disbursements that are active only (optional, default to false)
     * @param externalId search results by this external ID (that can be used to reference the disbursement) (optional)
     * @return kotlin.collections.List<DisbursementResponse>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun searchDisbursements(accountId: kotlin.Long, receiverAccountId: kotlin.Long? = null, statuses: kotlin.String? = null, providers: kotlin.String? = null, beforeDate: kotlin.Long? = null, afterDate: kotlin.Long? = null, start: kotlin.Int? = 0, limit: kotlin.Int? = 20, activeOnly: kotlin.Boolean? = false, externalId: kotlin.String? = null) : kotlin.collections.List<DisbursementResponse> {
        val localVarResponse = searchDisbursementsWithHttpInfo(accountId = accountId, receiverAccountId = receiverAccountId, statuses = statuses, providers = providers, beforeDate = beforeDate, afterDate = afterDate, start = start, limit = limit, activeOnly = activeOnly, externalId = externalId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<DisbursementResponse>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /disbursement/search
     * Search Disbursements
     * Search Disbursements
     * @param accountId the id of the logged in user
     * @param receiverAccountId filter results by the id of the account receiving the disbursement (optional)
     * @param statuses comma separated list of status values to search for, possilbe values include: NEW, APPROVED, VALIDATING, ERROR, AUTHORIZED, CAPTURED, SETTLED (optional)
     * @param providers comma separated list of payment providers to search for, possbile values include: AUTHORIZE_NET, AMAZON_FPS, BILL_COM (optional)
     * @param beforeDate the date for searching disbursements before it has been processed (optional)
     * @param afterDate the date for searching disbursements before it has been processed (optional)
     * @param start the start index for pagination (optional, default to 0)
     * @param limit the limit per result set for pagination (optional, default to 20)
     * @param activeOnly search on disbursements that are active only (optional, default to false)
     * @param externalId search results by this external ID (that can be used to reference the disbursement) (optional)
     * @return ApiResponse<kotlin.collections.List<DisbursementResponse>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun searchDisbursementsWithHttpInfo(accountId: kotlin.Long, receiverAccountId: kotlin.Long?, statuses: kotlin.String?, providers: kotlin.String?, beforeDate: kotlin.Long?, afterDate: kotlin.Long?, start: kotlin.Int?, limit: kotlin.Int?, activeOnly: kotlin.Boolean?, externalId: kotlin.String?) : ApiResponse<kotlin.collections.List<DisbursementResponse>?> {
        val localVariableConfig = searchDisbursementsRequestConfig(accountId = accountId, receiverAccountId = receiverAccountId, statuses = statuses, providers = providers, beforeDate = beforeDate, afterDate = afterDate, start = start, limit = limit, activeOnly = activeOnly, externalId = externalId)

        return request<Unit, kotlin.collections.List<DisbursementResponse>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation searchDisbursements
     *
     * @param accountId the id of the logged in user
     * @param receiverAccountId filter results by the id of the account receiving the disbursement (optional)
     * @param statuses comma separated list of status values to search for, possilbe values include: NEW, APPROVED, VALIDATING, ERROR, AUTHORIZED, CAPTURED, SETTLED (optional)
     * @param providers comma separated list of payment providers to search for, possbile values include: AUTHORIZE_NET, AMAZON_FPS, BILL_COM (optional)
     * @param beforeDate the date for searching disbursements before it has been processed (optional)
     * @param afterDate the date for searching disbursements before it has been processed (optional)
     * @param start the start index for pagination (optional, default to 0)
     * @param limit the limit per result set for pagination (optional, default to 20)
     * @param activeOnly search on disbursements that are active only (optional, default to false)
     * @param externalId search results by this external ID (that can be used to reference the disbursement) (optional)
     * @return RequestConfig
     */
    fun searchDisbursementsRequestConfig(accountId: kotlin.Long, receiverAccountId: kotlin.Long?, statuses: kotlin.String?, providers: kotlin.String?, beforeDate: kotlin.Long?, afterDate: kotlin.Long?, start: kotlin.Int?, limit: kotlin.Int?, activeOnly: kotlin.Boolean?, externalId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                if (receiverAccountId != null) {
                    put("receiverAccountId", listOf(receiverAccountId.toString()))
                }
                if (statuses != null) {
                    put("statuses", listOf(statuses.toString()))
                }
                if (providers != null) {
                    put("providers", listOf(providers.toString()))
                }
                if (beforeDate != null) {
                    put("beforeDate", listOf(beforeDate.toString()))
                }
                if (afterDate != null) {
                    put("afterDate", listOf(afterDate.toString()))
                }
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (activeOnly != null) {
                    put("activeOnly", listOf(activeOnly.toString()))
                }
                if (externalId != null) {
                    put("externalId", listOf(externalId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/disbursement/search",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter provider
     */
     enum class ProviderUpdateDisbursement(val value: kotlin.String) {
         @Json(name = "AUTHORIZE_NET") AUTHORIZE_NET("AUTHORIZE_NET"),
         @Json(name = "AMAZON_FPS") AMAZON_FPS("AMAZON_FPS"),
         @Json(name = "BILL_COM") BILL_COM("BILL_COM");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * POST /disbursement/update
     * Update Disbursement
     * Update Disbursement
     * @param accountId the id of the logged in user
     * @param disbursementId the id of the disbursement being updated
     * @param amount the disbursement dollar amount being updated (optional)
     * @param provider the payments and/or billing provider (e.g. Authorize.net, Bill.com, etc.) (optional)
     * @param scheduledDate the date that the disbursement is scheduled to go out to the payment provider (optional)
     * @param title the title given to the disbursement (optional)
     * @param comment a comment that can be made on a disbursement (optional)
     * @param externalId an external ID that can be used to reference the disbursement (optional)
     * @param retry determines whether to try sending the disbursement again in the case of a previous failure (optional)
     * @param introspectionParams for specifying parameters to make an http callback request for validating that the disbursement is valid (optional)
     * @return DisbursementResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updateDisbursement(accountId: kotlin.Long, disbursementId: kotlin.Long, amount: java.math.BigDecimal? = null, provider: ProviderUpdateDisbursement? = null, scheduledDate: kotlin.Long? = null, title: kotlin.String? = null, comment: kotlin.String? = null, externalId: kotlin.String? = null, retry: kotlin.Boolean? = null, introspectionParams: kotlin.String? = null) : DisbursementResponse {
        val localVarResponse = updateDisbursementWithHttpInfo(accountId = accountId, disbursementId = disbursementId, amount = amount, provider = provider, scheduledDate = scheduledDate, title = title, comment = comment, externalId = externalId, retry = retry, introspectionParams = introspectionParams)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DisbursementResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /disbursement/update
     * Update Disbursement
     * Update Disbursement
     * @param accountId the id of the logged in user
     * @param disbursementId the id of the disbursement being updated
     * @param amount the disbursement dollar amount being updated (optional)
     * @param provider the payments and/or billing provider (e.g. Authorize.net, Bill.com, etc.) (optional)
     * @param scheduledDate the date that the disbursement is scheduled to go out to the payment provider (optional)
     * @param title the title given to the disbursement (optional)
     * @param comment a comment that can be made on a disbursement (optional)
     * @param externalId an external ID that can be used to reference the disbursement (optional)
     * @param retry determines whether to try sending the disbursement again in the case of a previous failure (optional)
     * @param introspectionParams for specifying parameters to make an http callback request for validating that the disbursement is valid (optional)
     * @return ApiResponse<DisbursementResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun updateDisbursementWithHttpInfo(accountId: kotlin.Long, disbursementId: kotlin.Long, amount: java.math.BigDecimal?, provider: ProviderUpdateDisbursement?, scheduledDate: kotlin.Long?, title: kotlin.String?, comment: kotlin.String?, externalId: kotlin.String?, retry: kotlin.Boolean?, introspectionParams: kotlin.String?) : ApiResponse<DisbursementResponse?> {
        val localVariableConfig = updateDisbursementRequestConfig(accountId = accountId, disbursementId = disbursementId, amount = amount, provider = provider, scheduledDate = scheduledDate, title = title, comment = comment, externalId = externalId, retry = retry, introspectionParams = introspectionParams)

        return request<Unit, DisbursementResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateDisbursement
     *
     * @param accountId the id of the logged in user
     * @param disbursementId the id of the disbursement being updated
     * @param amount the disbursement dollar amount being updated (optional)
     * @param provider the payments and/or billing provider (e.g. Authorize.net, Bill.com, etc.) (optional)
     * @param scheduledDate the date that the disbursement is scheduled to go out to the payment provider (optional)
     * @param title the title given to the disbursement (optional)
     * @param comment a comment that can be made on a disbursement (optional)
     * @param externalId an external ID that can be used to reference the disbursement (optional)
     * @param retry determines whether to try sending the disbursement again in the case of a previous failure (optional)
     * @param introspectionParams for specifying parameters to make an http callback request for validating that the disbursement is valid (optional)
     * @return RequestConfig
     */
    fun updateDisbursementRequestConfig(accountId: kotlin.Long, disbursementId: kotlin.Long, amount: java.math.BigDecimal?, provider: ProviderUpdateDisbursement?, scheduledDate: kotlin.Long?, title: kotlin.String?, comment: kotlin.String?, externalId: kotlin.String?, retry: kotlin.Boolean?, introspectionParams: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("disbursementId", listOf(disbursementId.toString()))
                if (amount != null) {
                    put("amount", listOf(amount.toString()))
                }
                if (provider != null) {
                    put("provider", listOf(provider.value))
                }
                if (scheduledDate != null) {
                    put("scheduledDate", listOf(scheduledDate.toString()))
                }
                if (title != null) {
                    put("title", listOf(title.toString()))
                }
                if (comment != null) {
                    put("comment", listOf(comment.toString()))
                }
                if (externalId != null) {
                    put("externalId", listOf(externalId.toString()))
                }
                if (retry != null) {
                    put("retry", listOf(retry.toString()))
                }
                if (introspectionParams != null) {
                    put("introspectionParams", listOf(introspectionParams.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/disbursement/update",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
