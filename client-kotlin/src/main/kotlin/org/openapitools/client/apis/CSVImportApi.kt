/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import org.openapitools.client.models.CsvImportResponse
import org.openapitools.client.models.SirqulResponse

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

open class CSVImportApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://dev.sirqul.com/api/3.18")
        }
    }

    /**
     * enum for parameter responseGroup
     */
     enum class ResponseGroupGetStatusCSV(val value: kotlin.String) {
         @Json(name = "SUMMARY") SUMMARY("SUMMARY"),
         @Json(name = "DETAILS") DETAILS("DETAILS"),
         @Json(name = "ERRORS") ERRORS("ERRORS"),
         @Json(name = "ALL") ALL("ALL");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /csvimport/batch/status/details
     * Detail Status
     * 
     * @param accountId the id of the logged in user
     * @param batchId the id of the batch
     * @param responseGroup The group of categories to return: SUMMARY, DETAILS, ERRORS, OR ALL
     * @param start the start of the pagination
     * @param limit the limit of the pagination
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getStatusCSV(accountId: kotlin.Long, batchId: kotlin.Long, responseGroup: ResponseGroupGetStatusCSV, start: kotlin.Long, limit: kotlin.Long) : SirqulResponse {
        val localVarResponse = getStatusCSVWithHttpInfo(accountId = accountId, batchId = batchId, responseGroup = responseGroup, start = start, limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /csvimport/batch/status/details
     * Detail Status
     * 
     * @param accountId the id of the logged in user
     * @param batchId the id of the batch
     * @param responseGroup The group of categories to return: SUMMARY, DETAILS, ERRORS, OR ALL
     * @param start the start of the pagination
     * @param limit the limit of the pagination
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getStatusCSVWithHttpInfo(accountId: kotlin.Long, batchId: kotlin.Long, responseGroup: ResponseGroupGetStatusCSV, start: kotlin.Long, limit: kotlin.Long) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = getStatusCSVRequestConfig(accountId = accountId, batchId = batchId, responseGroup = responseGroup, start = start, limit = limit)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getStatusCSV
     *
     * @param accountId the id of the logged in user
     * @param batchId the id of the batch
     * @param responseGroup The group of categories to return: SUMMARY, DETAILS, ERRORS, OR ALL
     * @param start the start of the pagination
     * @param limit the limit of the pagination
     * @return RequestConfig
     */
    fun getStatusCSVRequestConfig(accountId: kotlin.Long, batchId: kotlin.Long, responseGroup: ResponseGroupGetStatusCSV, start: kotlin.Long, limit: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("batchId", listOf(batchId.toString()))
                put("responseGroup", listOf(responseGroup.value))
                put("start", listOf(start.toString()))
                put("limit", listOf(limit.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/csvimport/batch/status/details",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /csvimport/batch/list
     * Search Status
     * Retrieves batches for a user.
     * @param accountId the id of the account
     * @param start the start of the pagination
     * @param limit the limit of the pagination
     * @return CsvImportResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listStatusCSV(accountId: kotlin.Long, start: kotlin.Int, limit: kotlin.Int) : CsvImportResponse {
        val localVarResponse = listStatusCSVWithHttpInfo(accountId = accountId, start = start, limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CsvImportResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /csvimport/batch/list
     * Search Status
     * Retrieves batches for a user.
     * @param accountId the id of the account
     * @param start the start of the pagination
     * @param limit the limit of the pagination
     * @return ApiResponse<CsvImportResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listStatusCSVWithHttpInfo(accountId: kotlin.Long, start: kotlin.Int, limit: kotlin.Int) : ApiResponse<CsvImportResponse?> {
        val localVariableConfig = listStatusCSVRequestConfig(accountId = accountId, start = start, limit = limit)

        return request<Unit, CsvImportResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listStatusCSV
     *
     * @param accountId the id of the account
     * @param start the start of the pagination
     * @param limit the limit of the pagination
     * @return RequestConfig
     */
    fun listStatusCSVRequestConfig(accountId: kotlin.Long, start: kotlin.Int, limit: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("start", listOf(start.toString()))
                put("limit", listOf(limit.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/csvimport/batch/list",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /csvimport/batch/status
     * Batch Status
     * Checks status of batch upload.
     * @param accountId the id of the account
     * @param batchId the id of the batch to get its status
     * @return CsvImportResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun statusCSV(accountId: kotlin.Long, batchId: kotlin.Long) : CsvImportResponse {
        val localVarResponse = statusCSVWithHttpInfo(accountId = accountId, batchId = batchId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CsvImportResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /csvimport/batch/status
     * Batch Status
     * Checks status of batch upload.
     * @param accountId the id of the account
     * @param batchId the id of the batch to get its status
     * @return ApiResponse<CsvImportResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun statusCSVWithHttpInfo(accountId: kotlin.Long, batchId: kotlin.Long) : ApiResponse<CsvImportResponse?> {
        val localVariableConfig = statusCSVRequestConfig(accountId = accountId, batchId = batchId)

        return request<Unit, CsvImportResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation statusCSV
     *
     * @param accountId the id of the account
     * @param batchId the id of the batch to get its status
     * @return RequestConfig
     */
    fun statusCSVRequestConfig(accountId: kotlin.Long, batchId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("batchId", listOf(batchId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/csvimport/batch/status",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter uploadType
     */
     enum class UploadTypeUploadCSV(val value: kotlin.String) {
         @Json(name = "OFFERS") OFFERS("OFFERS"),
         @Json(name = "RETAILERS") RETAILERS("RETAILERS"),
         @Json(name = "RETAILERLOCATIONS") RETAILERLOCATIONS("RETAILERLOCATIONS"),
         @Json(name = "CATEGORIES") CATEGORIES("CATEGORIES"),
         @Json(name = "FILTERS") FILTERS("FILTERS");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter fileFormat
     */
     enum class FileFormatUploadCSV(val value: kotlin.String) {
         @Json(name = "EXCEL") EXCEL("EXCEL"),
         @Json(name = "MYSQL") MYSQL("MYSQL"),
         @Json(name = "RFC4180") RFC4180("RFC4180"),
         @Json(name = "TDF") TDF("TDF");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * POST /csvimport/upload
     * Upload CSV
     * Uploads a CSV import file.
     * @param accountId the id of the account
     * @param uploadType the upload type: OFFERS, RETAILERS, RETAILERLOCATIONS, CATEGORIES, OR FILTERS
     * @param importFile the import file to reference
     * @param fileFormat the format of the file
     * @param appKey the application key (optional)
     * @return CsvImportResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun uploadCSV(accountId: kotlin.Long, uploadType: UploadTypeUploadCSV, importFile: java.io.File, fileFormat: FileFormatUploadCSV, appKey: kotlin.String? = null) : CsvImportResponse {
        val localVarResponse = uploadCSVWithHttpInfo(accountId = accountId, uploadType = uploadType, importFile = importFile, fileFormat = fileFormat, appKey = appKey)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CsvImportResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /csvimport/upload
     * Upload CSV
     * Uploads a CSV import file.
     * @param accountId the id of the account
     * @param uploadType the upload type: OFFERS, RETAILERS, RETAILERLOCATIONS, CATEGORIES, OR FILTERS
     * @param importFile the import file to reference
     * @param fileFormat the format of the file
     * @param appKey the application key (optional)
     * @return ApiResponse<CsvImportResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun uploadCSVWithHttpInfo(accountId: kotlin.Long, uploadType: UploadTypeUploadCSV, importFile: java.io.File, fileFormat: FileFormatUploadCSV, appKey: kotlin.String?) : ApiResponse<CsvImportResponse?> {
        val localVariableConfig = uploadCSVRequestConfig(accountId = accountId, uploadType = uploadType, importFile = importFile, fileFormat = fileFormat, appKey = appKey)

        return request<Unit, CsvImportResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation uploadCSV
     *
     * @param accountId the id of the account
     * @param uploadType the upload type: OFFERS, RETAILERS, RETAILERLOCATIONS, CATEGORIES, OR FILTERS
     * @param importFile the import file to reference
     * @param fileFormat the format of the file
     * @param appKey the application key (optional)
     * @return RequestConfig
     */
    fun uploadCSVRequestConfig(accountId: kotlin.Long, uploadType: UploadTypeUploadCSV, importFile: java.io.File, fileFormat: FileFormatUploadCSV, appKey: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("uploadType", listOf(uploadType.value))
                put("importFile", listOf(importFile.toString()))
                if (appKey != null) {
                    put("appKey", listOf(appKey.toString()))
                }
                put("fileFormat", listOf(fileFormat.value))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/csvimport/upload",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
