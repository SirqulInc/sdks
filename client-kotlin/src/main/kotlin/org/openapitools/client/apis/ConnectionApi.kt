/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import org.openapitools.client.models.ConnectionGroupResponse
import org.openapitools.client.models.ConnectionInfoResponse
import org.openapitools.client.models.ConnectionListResponse
import org.openapitools.client.models.ConnectionResponse
import org.openapitools.client.models.SirqulResponse

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

open class ConnectionApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost")
        }
    }

    /**
     * POST /api/{version}/consumer/connection/group/addConnection
     * Add Connection
     * Adds a connection to a group.
     * @param version 
     * @param returnNulls whether to return nulls or not
     * @param groupId the group id
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param connectionId the connection id (optional)
     * @param connectionAccountId the connection account id (optional)
     * @param pendingId the pending id (optional)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun addConnectionToGroup(version: java.math.BigDecimal, returnNulls: kotlin.Boolean, groupId: kotlin.Long, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, connectionId: kotlin.Long? = null, connectionAccountId: kotlin.Long? = null, pendingId: kotlin.Long? = null, latitude: kotlin.Double? = null, longitude: kotlin.Double? = null) : SirqulResponse {
        val localVarResponse = addConnectionToGroupWithHttpInfo(version = version, returnNulls = returnNulls, groupId = groupId, deviceId = deviceId, accountId = accountId, connectionId = connectionId, connectionAccountId = connectionAccountId, pendingId = pendingId, latitude = latitude, longitude = longitude)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/{version}/consumer/connection/group/addConnection
     * Add Connection
     * Adds a connection to a group.
     * @param version 
     * @param returnNulls whether to return nulls or not
     * @param groupId the group id
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param connectionId the connection id (optional)
     * @param connectionAccountId the connection account id (optional)
     * @param pendingId the pending id (optional)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun addConnectionToGroupWithHttpInfo(version: java.math.BigDecimal, returnNulls: kotlin.Boolean, groupId: kotlin.Long, deviceId: kotlin.String?, accountId: kotlin.Long?, connectionId: kotlin.Long?, connectionAccountId: kotlin.Long?, pendingId: kotlin.Long?, latitude: kotlin.Double?, longitude: kotlin.Double?) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = addConnectionToGroupRequestConfig(version = version, returnNulls = returnNulls, groupId = groupId, deviceId = deviceId, accountId = accountId, connectionId = connectionId, connectionAccountId = connectionAccountId, pendingId = pendingId, latitude = latitude, longitude = longitude)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation addConnectionToGroup
     *
     * @param version 
     * @param returnNulls whether to return nulls or not
     * @param groupId the group id
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param connectionId the connection id (optional)
     * @param connectionAccountId the connection account id (optional)
     * @param pendingId the pending id (optional)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @return RequestConfig
     */
    fun addConnectionToGroupRequestConfig(version: java.math.BigDecimal, returnNulls: kotlin.Boolean, groupId: kotlin.Long, deviceId: kotlin.String?, accountId: kotlin.Long?, connectionId: kotlin.Long?, connectionAccountId: kotlin.Long?, pendingId: kotlin.Long?, latitude: kotlin.Double?, longitude: kotlin.Double?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("returnNulls", listOf(returnNulls.toString()))
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (connectionId != null) {
                    put("connectionId", listOf(connectionId.toString()))
                }
                if (connectionAccountId != null) {
                    put("connectionAccountId", listOf(connectionAccountId.toString()))
                }
                if (pendingId != null) {
                    put("pendingId", listOf(pendingId.toString()))
                }
                put("groupId", listOf(groupId.toString()))
                if (latitude != null) {
                    put("latitude", listOf(latitude.toString()))
                }
                if (longitude != null) {
                    put("longitude", listOf(longitude.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/{version}/consumer/connection/group/addConnection".replace("{"+"version"+"}", encodeURIComponent(version.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/{version}/connection/group/addConnections
     * Add Connections
     * Adds a list of connections to a group.
     * @param version 
     * @param connectionGroupId the connection group ID
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param connectionIds comma separated list of connection ids (optional)
     * @param connectionAccountIds comma separated list of connection account ids (optional)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun addConnectionsToGroup(version: java.math.BigDecimal, connectionGroupId: kotlin.Long, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, connectionIds: kotlin.String? = null, connectionAccountIds: kotlin.String? = null, latitude: kotlin.Double? = null, longitude: kotlin.Double? = null) : SirqulResponse {
        val localVarResponse = addConnectionsToGroupWithHttpInfo(version = version, connectionGroupId = connectionGroupId, deviceId = deviceId, accountId = accountId, connectionIds = connectionIds, connectionAccountIds = connectionAccountIds, latitude = latitude, longitude = longitude)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/{version}/connection/group/addConnections
     * Add Connections
     * Adds a list of connections to a group.
     * @param version 
     * @param connectionGroupId the connection group ID
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param connectionIds comma separated list of connection ids (optional)
     * @param connectionAccountIds comma separated list of connection account ids (optional)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun addConnectionsToGroupWithHttpInfo(version: java.math.BigDecimal, connectionGroupId: kotlin.Long, deviceId: kotlin.String?, accountId: kotlin.Long?, connectionIds: kotlin.String?, connectionAccountIds: kotlin.String?, latitude: kotlin.Double?, longitude: kotlin.Double?) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = addConnectionsToGroupRequestConfig(version = version, connectionGroupId = connectionGroupId, deviceId = deviceId, accountId = accountId, connectionIds = connectionIds, connectionAccountIds = connectionAccountIds, latitude = latitude, longitude = longitude)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation addConnectionsToGroup
     *
     * @param version 
     * @param connectionGroupId the connection group ID
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param connectionIds comma separated list of connection ids (optional)
     * @param connectionAccountIds comma separated list of connection account ids (optional)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @return RequestConfig
     */
    fun addConnectionsToGroupRequestConfig(version: java.math.BigDecimal, connectionGroupId: kotlin.Long, deviceId: kotlin.String?, accountId: kotlin.Long?, connectionIds: kotlin.String?, connectionAccountIds: kotlin.String?, latitude: kotlin.Double?, longitude: kotlin.Double?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (connectionIds != null) {
                    put("connectionIds", listOf(connectionIds.toString()))
                }
                if (connectionAccountIds != null) {
                    put("connectionAccountIds", listOf(connectionAccountIds.toString()))
                }
                put("connectionGroupId", listOf(connectionGroupId.toString()))
                if (latitude != null) {
                    put("latitude", listOf(latitude.toString()))
                }
                if (longitude != null) {
                    put("longitude", listOf(longitude.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/{version}/connection/group/addConnections".replace("{"+"version"+"}", encodeURIComponent(version.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/{version}/consumer/connection/group/addSubGroup
     * Add Connection Groups
     * Add sub groups to a group.
     * @param version 
     * @param returnNulls whether to return nulls or not
     * @param groupId the parent group id
     * @param subGroupIds comma separated list of group IDs to add to the parent group
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @return ConnectionGroupResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun addSubGroups(version: java.math.BigDecimal, returnNulls: kotlin.Boolean, groupId: kotlin.Long, subGroupIds: kotlin.String, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, latitude: kotlin.Double? = null, longitude: kotlin.Double? = null) : ConnectionGroupResponse {
        val localVarResponse = addSubGroupsWithHttpInfo(version = version, returnNulls = returnNulls, groupId = groupId, subGroupIds = subGroupIds, deviceId = deviceId, accountId = accountId, latitude = latitude, longitude = longitude)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ConnectionGroupResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/{version}/consumer/connection/group/addSubGroup
     * Add Connection Groups
     * Add sub groups to a group.
     * @param version 
     * @param returnNulls whether to return nulls or not
     * @param groupId the parent group id
     * @param subGroupIds comma separated list of group IDs to add to the parent group
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @return ApiResponse<ConnectionGroupResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun addSubGroupsWithHttpInfo(version: java.math.BigDecimal, returnNulls: kotlin.Boolean, groupId: kotlin.Long, subGroupIds: kotlin.String, deviceId: kotlin.String?, accountId: kotlin.Long?, latitude: kotlin.Double?, longitude: kotlin.Double?) : ApiResponse<ConnectionGroupResponse?> {
        val localVariableConfig = addSubGroupsRequestConfig(version = version, returnNulls = returnNulls, groupId = groupId, subGroupIds = subGroupIds, deviceId = deviceId, accountId = accountId, latitude = latitude, longitude = longitude)

        return request<Unit, ConnectionGroupResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation addSubGroups
     *
     * @param version 
     * @param returnNulls whether to return nulls or not
     * @param groupId the parent group id
     * @param subGroupIds comma separated list of group IDs to add to the parent group
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @return RequestConfig
     */
    fun addSubGroupsRequestConfig(version: java.math.BigDecimal, returnNulls: kotlin.Boolean, groupId: kotlin.Long, subGroupIds: kotlin.String, deviceId: kotlin.String?, accountId: kotlin.Long?, latitude: kotlin.Double?, longitude: kotlin.Double?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("returnNulls", listOf(returnNulls.toString()))
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                put("groupId", listOf(groupId.toString()))
                put("subGroupIds", listOf(subGroupIds.toString()))
                if (latitude != null) {
                    put("latitude", listOf(latitude.toString()))
                }
                if (longitude != null) {
                    put("longitude", listOf(longitude.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/{version}/consumer/connection/group/addSubGroup".replace("{"+"version"+"}", encodeURIComponent(version.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/{version}/consumer/connection/add
     * Create or Update Connection
     * Creates or updates the connection of the user and another account. Allows a user to follow, block, mark as trusted, and/or add someone to a group.
     * @param version 
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param connectionId the connection id for editing (optional)
     * @param connectionAccountId the connection account id (i.e. the account id of another user) (optional)
     * @param pendingId the pending id (usually for people who do not have a Sirqul account but are already friends via other third party apps) (optional)
     * @param groupId optional group id if the user wants to add this person into a group (optional)
     * @param gameType This parameter is deprecated. (optional)
     * @param appKey the application key (optional)
     * @param isTrusted determines whether the user is trusting this account (optional)
     * @param ignoreFriendRequest determines whether the user has set to ignore the user&#39;s friend request (optional)
     * @param isContact determines whether the user is a contact of this account (optional)
     * @param isBlocked determines whether the user is blocking this account (optional)
     * @param isFollowing determines whether the user is following this account (optional)
     * @param connectionResponse whether to return the connection response or not (optional)
     * @return ConnectionResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createOrUpdateConnection(version: java.math.BigDecimal, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, connectionId: kotlin.Long? = null, connectionAccountId: kotlin.Long? = null, pendingId: kotlin.Long? = null, groupId: kotlin.Long? = null, gameType: kotlin.String? = null, appKey: kotlin.String? = null, isTrusted: kotlin.Boolean? = null, ignoreFriendRequest: kotlin.Boolean? = null, isContact: kotlin.Boolean? = null, isBlocked: kotlin.Boolean? = null, isFollowing: kotlin.Boolean? = null, connectionResponse: kotlin.Boolean? = null) : ConnectionResponse {
        val localVarResponse = createOrUpdateConnectionWithHttpInfo(version = version, deviceId = deviceId, accountId = accountId, connectionId = connectionId, connectionAccountId = connectionAccountId, pendingId = pendingId, groupId = groupId, gameType = gameType, appKey = appKey, isTrusted = isTrusted, ignoreFriendRequest = ignoreFriendRequest, isContact = isContact, isBlocked = isBlocked, isFollowing = isFollowing, connectionResponse = connectionResponse)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ConnectionResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/{version}/consumer/connection/add
     * Create or Update Connection
     * Creates or updates the connection of the user and another account. Allows a user to follow, block, mark as trusted, and/or add someone to a group.
     * @param version 
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param connectionId the connection id for editing (optional)
     * @param connectionAccountId the connection account id (i.e. the account id of another user) (optional)
     * @param pendingId the pending id (usually for people who do not have a Sirqul account but are already friends via other third party apps) (optional)
     * @param groupId optional group id if the user wants to add this person into a group (optional)
     * @param gameType This parameter is deprecated. (optional)
     * @param appKey the application key (optional)
     * @param isTrusted determines whether the user is trusting this account (optional)
     * @param ignoreFriendRequest determines whether the user has set to ignore the user&#39;s friend request (optional)
     * @param isContact determines whether the user is a contact of this account (optional)
     * @param isBlocked determines whether the user is blocking this account (optional)
     * @param isFollowing determines whether the user is following this account (optional)
     * @param connectionResponse whether to return the connection response or not (optional)
     * @return ApiResponse<ConnectionResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createOrUpdateConnectionWithHttpInfo(version: java.math.BigDecimal, deviceId: kotlin.String?, accountId: kotlin.Long?, connectionId: kotlin.Long?, connectionAccountId: kotlin.Long?, pendingId: kotlin.Long?, groupId: kotlin.Long?, gameType: kotlin.String?, appKey: kotlin.String?, isTrusted: kotlin.Boolean?, ignoreFriendRequest: kotlin.Boolean?, isContact: kotlin.Boolean?, isBlocked: kotlin.Boolean?, isFollowing: kotlin.Boolean?, connectionResponse: kotlin.Boolean?) : ApiResponse<ConnectionResponse?> {
        val localVariableConfig = createOrUpdateConnectionRequestConfig(version = version, deviceId = deviceId, accountId = accountId, connectionId = connectionId, connectionAccountId = connectionAccountId, pendingId = pendingId, groupId = groupId, gameType = gameType, appKey = appKey, isTrusted = isTrusted, ignoreFriendRequest = ignoreFriendRequest, isContact = isContact, isBlocked = isBlocked, isFollowing = isFollowing, connectionResponse = connectionResponse)

        return request<Unit, ConnectionResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createOrUpdateConnection
     *
     * @param version 
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param connectionId the connection id for editing (optional)
     * @param connectionAccountId the connection account id (i.e. the account id of another user) (optional)
     * @param pendingId the pending id (usually for people who do not have a Sirqul account but are already friends via other third party apps) (optional)
     * @param groupId optional group id if the user wants to add this person into a group (optional)
     * @param gameType This parameter is deprecated. (optional)
     * @param appKey the application key (optional)
     * @param isTrusted determines whether the user is trusting this account (optional)
     * @param ignoreFriendRequest determines whether the user has set to ignore the user&#39;s friend request (optional)
     * @param isContact determines whether the user is a contact of this account (optional)
     * @param isBlocked determines whether the user is blocking this account (optional)
     * @param isFollowing determines whether the user is following this account (optional)
     * @param connectionResponse whether to return the connection response or not (optional)
     * @return RequestConfig
     */
    fun createOrUpdateConnectionRequestConfig(version: java.math.BigDecimal, deviceId: kotlin.String?, accountId: kotlin.Long?, connectionId: kotlin.Long?, connectionAccountId: kotlin.Long?, pendingId: kotlin.Long?, groupId: kotlin.Long?, gameType: kotlin.String?, appKey: kotlin.String?, isTrusted: kotlin.Boolean?, ignoreFriendRequest: kotlin.Boolean?, isContact: kotlin.Boolean?, isBlocked: kotlin.Boolean?, isFollowing: kotlin.Boolean?, connectionResponse: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (connectionId != null) {
                    put("connectionId", listOf(connectionId.toString()))
                }
                if (connectionAccountId != null) {
                    put("connectionAccountId", listOf(connectionAccountId.toString()))
                }
                if (pendingId != null) {
                    put("pendingId", listOf(pendingId.toString()))
                }
                if (groupId != null) {
                    put("groupId", listOf(groupId.toString()))
                }
                if (gameType != null) {
                    put("gameType", listOf(gameType.toString()))
                }
                if (appKey != null) {
                    put("appKey", listOf(appKey.toString()))
                }
                if (isTrusted != null) {
                    put("isTrusted", listOf(isTrusted.toString()))
                }
                if (ignoreFriendRequest != null) {
                    put("ignoreFriendRequest", listOf(ignoreFriendRequest.toString()))
                }
                if (isContact != null) {
                    put("isContact", listOf(isContact.toString()))
                }
                if (isBlocked != null) {
                    put("isBlocked", listOf(isBlocked.toString()))
                }
                if (isFollowing != null) {
                    put("isFollowing", listOf(isFollowing.toString()))
                }
                if (connectionResponse != null) {
                    put("connectionResponse", listOf(connectionResponse.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/{version}/consumer/connection/add".replace("{"+"version"+"}", encodeURIComponent(version.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/{version}/consumer/connection/group
     * Create or Update Connection Group
     * Creates a new private group.
     * @param version 
     * @param returnNulls whether to return nulls or not
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param name the name of the group (optional)
     * @param groupId the group id to update a group (don&#39;t pass anything in if you want to create a new group) (optional)
     * @param assetId the asset to attach to the group (optional)
     * @param connections comma separated list of connection IDs (optional)
     * @param description the description of the group (optional)
     * @param canViewProfileInfo determines whether the connections in the group can see the user&#39;s profile info (optional)
     * @param canViewGameInfo determines whether the connections in the group can see the user&#39;s game info (optional)
     * @param canViewFriendInfo determines whether the connections in the group can see the user&#39;s friends/connections (optional)
     * @param active Sets whether the connection group is active or inactive (optional)
     * @param latitude the latitude of the group (optional)
     * @param longitude the longitude of the group (optional)
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createOrUpdateGroup(version: java.math.BigDecimal, returnNulls: kotlin.Boolean, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, name: kotlin.String? = null, groupId: kotlin.Long? = null, assetId: kotlin.Long? = null, connections: kotlin.String? = null, description: kotlin.String? = null, canViewProfileInfo: kotlin.Boolean? = null, canViewGameInfo: kotlin.Boolean? = null, canViewFriendInfo: kotlin.Boolean? = null, active: kotlin.Boolean? = null, latitude: kotlin.Double? = null, longitude: kotlin.Double? = null) : SirqulResponse {
        val localVarResponse = createOrUpdateGroupWithHttpInfo(version = version, returnNulls = returnNulls, deviceId = deviceId, accountId = accountId, name = name, groupId = groupId, assetId = assetId, connections = connections, description = description, canViewProfileInfo = canViewProfileInfo, canViewGameInfo = canViewGameInfo, canViewFriendInfo = canViewFriendInfo, active = active, latitude = latitude, longitude = longitude)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/{version}/consumer/connection/group
     * Create or Update Connection Group
     * Creates a new private group.
     * @param version 
     * @param returnNulls whether to return nulls or not
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param name the name of the group (optional)
     * @param groupId the group id to update a group (don&#39;t pass anything in if you want to create a new group) (optional)
     * @param assetId the asset to attach to the group (optional)
     * @param connections comma separated list of connection IDs (optional)
     * @param description the description of the group (optional)
     * @param canViewProfileInfo determines whether the connections in the group can see the user&#39;s profile info (optional)
     * @param canViewGameInfo determines whether the connections in the group can see the user&#39;s game info (optional)
     * @param canViewFriendInfo determines whether the connections in the group can see the user&#39;s friends/connections (optional)
     * @param active Sets whether the connection group is active or inactive (optional)
     * @param latitude the latitude of the group (optional)
     * @param longitude the longitude of the group (optional)
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createOrUpdateGroupWithHttpInfo(version: java.math.BigDecimal, returnNulls: kotlin.Boolean, deviceId: kotlin.String?, accountId: kotlin.Long?, name: kotlin.String?, groupId: kotlin.Long?, assetId: kotlin.Long?, connections: kotlin.String?, description: kotlin.String?, canViewProfileInfo: kotlin.Boolean?, canViewGameInfo: kotlin.Boolean?, canViewFriendInfo: kotlin.Boolean?, active: kotlin.Boolean?, latitude: kotlin.Double?, longitude: kotlin.Double?) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = createOrUpdateGroupRequestConfig(version = version, returnNulls = returnNulls, deviceId = deviceId, accountId = accountId, name = name, groupId = groupId, assetId = assetId, connections = connections, description = description, canViewProfileInfo = canViewProfileInfo, canViewGameInfo = canViewGameInfo, canViewFriendInfo = canViewFriendInfo, active = active, latitude = latitude, longitude = longitude)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createOrUpdateGroup
     *
     * @param version 
     * @param returnNulls whether to return nulls or not
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param name the name of the group (optional)
     * @param groupId the group id to update a group (don&#39;t pass anything in if you want to create a new group) (optional)
     * @param assetId the asset to attach to the group (optional)
     * @param connections comma separated list of connection IDs (optional)
     * @param description the description of the group (optional)
     * @param canViewProfileInfo determines whether the connections in the group can see the user&#39;s profile info (optional)
     * @param canViewGameInfo determines whether the connections in the group can see the user&#39;s game info (optional)
     * @param canViewFriendInfo determines whether the connections in the group can see the user&#39;s friends/connections (optional)
     * @param active Sets whether the connection group is active or inactive (optional)
     * @param latitude the latitude of the group (optional)
     * @param longitude the longitude of the group (optional)
     * @return RequestConfig
     */
    fun createOrUpdateGroupRequestConfig(version: java.math.BigDecimal, returnNulls: kotlin.Boolean, deviceId: kotlin.String?, accountId: kotlin.Long?, name: kotlin.String?, groupId: kotlin.Long?, assetId: kotlin.Long?, connections: kotlin.String?, description: kotlin.String?, canViewProfileInfo: kotlin.Boolean?, canViewGameInfo: kotlin.Boolean?, canViewFriendInfo: kotlin.Boolean?, active: kotlin.Boolean?, latitude: kotlin.Double?, longitude: kotlin.Double?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("returnNulls", listOf(returnNulls.toString()))
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (groupId != null) {
                    put("groupId", listOf(groupId.toString()))
                }
                if (assetId != null) {
                    put("assetId", listOf(assetId.toString()))
                }
                if (connections != null) {
                    put("connections", listOf(connections.toString()))
                }
                if (description != null) {
                    put("description", listOf(description.toString()))
                }
                if (canViewProfileInfo != null) {
                    put("canViewProfileInfo", listOf(canViewProfileInfo.toString()))
                }
                if (canViewGameInfo != null) {
                    put("canViewGameInfo", listOf(canViewGameInfo.toString()))
                }
                if (canViewFriendInfo != null) {
                    put("canViewFriendInfo", listOf(canViewFriendInfo.toString()))
                }
                if (active != null) {
                    put("active", listOf(active.toString()))
                }
                if (latitude != null) {
                    put("latitude", listOf(latitude.toString()))
                }
                if (longitude != null) {
                    put("longitude", listOf(longitude.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/{version}/consumer/connection/group".replace("{"+"version"+"}", encodeURIComponent(version.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/{version}/consumer/follow/accept
     * Accept Follow Request
     * Accept someone&#39;s follow request.
     * @param version 
     * @param accountId the account id of the user
     * @param connectionAccountId the account ID of the user who initiated the follow
     * @param appKey the application key for sending notifications
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun followAccept(version: java.math.BigDecimal, accountId: kotlin.Long, connectionAccountId: kotlin.Long, appKey: kotlin.String) : SirqulResponse {
        val localVarResponse = followAcceptWithHttpInfo(version = version, accountId = accountId, connectionAccountId = connectionAccountId, appKey = appKey)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/{version}/consumer/follow/accept
     * Accept Follow Request
     * Accept someone&#39;s follow request.
     * @param version 
     * @param accountId the account id of the user
     * @param connectionAccountId the account ID of the user who initiated the follow
     * @param appKey the application key for sending notifications
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun followAcceptWithHttpInfo(version: java.math.BigDecimal, accountId: kotlin.Long, connectionAccountId: kotlin.Long, appKey: kotlin.String) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = followAcceptRequestConfig(version = version, accountId = accountId, connectionAccountId = connectionAccountId, appKey = appKey)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation followAccept
     *
     * @param version 
     * @param accountId the account id of the user
     * @param connectionAccountId the account ID of the user who initiated the follow
     * @param appKey the application key for sending notifications
     * @return RequestConfig
     */
    fun followAcceptRequestConfig(version: java.math.BigDecimal, accountId: kotlin.Long, connectionAccountId: kotlin.Long, appKey: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("connectionAccountId", listOf(connectionAccountId.toString()))
                put("appKey", listOf(appKey.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/{version}/consumer/follow/accept".replace("{"+"version"+"}", encodeURIComponent(version.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/{version}/consumer/follow/reject
     * Reject Follow Request
     * Reject someone&#39;s follow request or remove them as a follower.
     * @param version 
     * @param accountId the account id of the user
     * @param connectionAccountId the account ID of the user who initiated the follow
     * @param appKey the application key for sending notifications
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun followReject(version: java.math.BigDecimal, accountId: kotlin.Long, connectionAccountId: kotlin.Long, appKey: kotlin.String) : SirqulResponse {
        val localVarResponse = followRejectWithHttpInfo(version = version, accountId = accountId, connectionAccountId = connectionAccountId, appKey = appKey)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/{version}/consumer/follow/reject
     * Reject Follow Request
     * Reject someone&#39;s follow request or remove them as a follower.
     * @param version 
     * @param accountId the account id of the user
     * @param connectionAccountId the account ID of the user who initiated the follow
     * @param appKey the application key for sending notifications
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun followRejectWithHttpInfo(version: java.math.BigDecimal, accountId: kotlin.Long, connectionAccountId: kotlin.Long, appKey: kotlin.String) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = followRejectRequestConfig(version = version, accountId = accountId, connectionAccountId = connectionAccountId, appKey = appKey)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation followReject
     *
     * @param version 
     * @param accountId the account id of the user
     * @param connectionAccountId the account ID of the user who initiated the follow
     * @param appKey the application key for sending notifications
     * @return RequestConfig
     */
    fun followRejectRequestConfig(version: java.math.BigDecimal, accountId: kotlin.Long, connectionAccountId: kotlin.Long, appKey: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("connectionAccountId", listOf(connectionAccountId.toString()))
                put("appKey", listOf(appKey.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/{version}/consumer/follow/reject".replace("{"+"version"+"}", encodeURIComponent(version.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/{version}/consumer/follow/remove
     * Remove Follower / Unfollow
     * Unfollow someone you are following or remove them as a follower.
     * @param version 
     * @param accountId the account id of the user
     * @param connectionAccountId the account ID of the user who you want to unfollow
     * @param appKey the application key for sending notifications
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun followRemove(version: java.math.BigDecimal, accountId: kotlin.Long, connectionAccountId: kotlin.Long, appKey: kotlin.String) : SirqulResponse {
        val localVarResponse = followRemoveWithHttpInfo(version = version, accountId = accountId, connectionAccountId = connectionAccountId, appKey = appKey)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/{version}/consumer/follow/remove
     * Remove Follower / Unfollow
     * Unfollow someone you are following or remove them as a follower.
     * @param version 
     * @param accountId the account id of the user
     * @param connectionAccountId the account ID of the user who you want to unfollow
     * @param appKey the application key for sending notifications
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun followRemoveWithHttpInfo(version: java.math.BigDecimal, accountId: kotlin.Long, connectionAccountId: kotlin.Long, appKey: kotlin.String) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = followRemoveRequestConfig(version = version, accountId = accountId, connectionAccountId = connectionAccountId, appKey = appKey)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation followRemove
     *
     * @param version 
     * @param accountId the account id of the user
     * @param connectionAccountId the account ID of the user who you want to unfollow
     * @param appKey the application key for sending notifications
     * @return RequestConfig
     */
    fun followRemoveRequestConfig(version: java.math.BigDecimal, accountId: kotlin.Long, connectionAccountId: kotlin.Long, appKey: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("connectionAccountId", listOf(connectionAccountId.toString()))
                put("appKey", listOf(appKey.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/{version}/consumer/follow/remove".replace("{"+"version"+"}", encodeURIComponent(version.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/{version}/consumer/follow/request
     * Send Follow Request
     * Send a request to follow someone.
     * @param version 
     * @param accountId the account id of the user
     * @param connectionAccountId the account ID of the user who you want to follow
     * @param appKey the application key for sending notifications
     * @param approvalNeeded determines if the other user needs to confirm the follow request (optional, default to true)
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun followRequest(version: java.math.BigDecimal, accountId: kotlin.Long, connectionAccountId: kotlin.Long, appKey: kotlin.String, approvalNeeded: kotlin.Boolean? = true) : SirqulResponse {
        val localVarResponse = followRequestWithHttpInfo(version = version, accountId = accountId, connectionAccountId = connectionAccountId, appKey = appKey, approvalNeeded = approvalNeeded)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/{version}/consumer/follow/request
     * Send Follow Request
     * Send a request to follow someone.
     * @param version 
     * @param accountId the account id of the user
     * @param connectionAccountId the account ID of the user who you want to follow
     * @param appKey the application key for sending notifications
     * @param approvalNeeded determines if the other user needs to confirm the follow request (optional, default to true)
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun followRequestWithHttpInfo(version: java.math.BigDecimal, accountId: kotlin.Long, connectionAccountId: kotlin.Long, appKey: kotlin.String, approvalNeeded: kotlin.Boolean?) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = followRequestRequestConfig(version = version, accountId = accountId, connectionAccountId = connectionAccountId, appKey = appKey, approvalNeeded = approvalNeeded)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation followRequest
     *
     * @param version 
     * @param accountId the account id of the user
     * @param connectionAccountId the account ID of the user who you want to follow
     * @param appKey the application key for sending notifications
     * @param approvalNeeded determines if the other user needs to confirm the follow request (optional, default to true)
     * @return RequestConfig
     */
    fun followRequestRequestConfig(version: java.math.BigDecimal, accountId: kotlin.Long, connectionAccountId: kotlin.Long, appKey: kotlin.String, approvalNeeded: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("connectionAccountId", listOf(connectionAccountId.toString()))
                put("appKey", listOf(appKey.toString()))
                if (approvalNeeded != null) {
                    put("approvalNeeded", listOf(approvalNeeded.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/{version}/consumer/follow/request".replace("{"+"version"+"}", encodeURIComponent(version.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/{version}/consumer/friend/accept
     * Accept Friend
     * Accept a friend request and optionally sends a notification.
     * @param version 
     * @param friendAccountId the friend&#39;s account id
     * @param notifyFriend determines whether to send a notification to the afflicting party
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param gameType This parameter is deprecated. (optional)
     * @param appKey the application key (optional)
     * @param notificationMessage optional message to send in a notification (optional)
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun friendAccept(version: java.math.BigDecimal, friendAccountId: kotlin.Long, notifyFriend: kotlin.Boolean, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, gameType: kotlin.String? = null, appKey: kotlin.String? = null, notificationMessage: kotlin.String? = null) : SirqulResponse {
        val localVarResponse = friendAcceptWithHttpInfo(version = version, friendAccountId = friendAccountId, notifyFriend = notifyFriend, deviceId = deviceId, accountId = accountId, gameType = gameType, appKey = appKey, notificationMessage = notificationMessage)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/{version}/consumer/friend/accept
     * Accept Friend
     * Accept a friend request and optionally sends a notification.
     * @param version 
     * @param friendAccountId the friend&#39;s account id
     * @param notifyFriend determines whether to send a notification to the afflicting party
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param gameType This parameter is deprecated. (optional)
     * @param appKey the application key (optional)
     * @param notificationMessage optional message to send in a notification (optional)
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun friendAcceptWithHttpInfo(version: java.math.BigDecimal, friendAccountId: kotlin.Long, notifyFriend: kotlin.Boolean, deviceId: kotlin.String?, accountId: kotlin.Long?, gameType: kotlin.String?, appKey: kotlin.String?, notificationMessage: kotlin.String?) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = friendAcceptRequestConfig(version = version, friendAccountId = friendAccountId, notifyFriend = notifyFriend, deviceId = deviceId, accountId = accountId, gameType = gameType, appKey = appKey, notificationMessage = notificationMessage)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation friendAccept
     *
     * @param version 
     * @param friendAccountId the friend&#39;s account id
     * @param notifyFriend determines whether to send a notification to the afflicting party
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param gameType This parameter is deprecated. (optional)
     * @param appKey the application key (optional)
     * @param notificationMessage optional message to send in a notification (optional)
     * @return RequestConfig
     */
    fun friendAcceptRequestConfig(version: java.math.BigDecimal, friendAccountId: kotlin.Long, notifyFriend: kotlin.Boolean, deviceId: kotlin.String?, accountId: kotlin.Long?, gameType: kotlin.String?, appKey: kotlin.String?, notificationMessage: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                put("friendAccountId", listOf(friendAccountId.toString()))
                if (gameType != null) {
                    put("gameType", listOf(gameType.toString()))
                }
                if (appKey != null) {
                    put("appKey", listOf(appKey.toString()))
                }
                put("notifyFriend", listOf(notifyFriend.toString()))
                if (notificationMessage != null) {
                    put("notificationMessage", listOf(notificationMessage.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/{version}/consumer/friend/accept".replace("{"+"version"+"}", encodeURIComponent(version.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/{version}/consumer/friend/reject
     * Decline Friend
     * Request a friend request and optionally sends a notification.
     * @param version 
     * @param friendAccountId the friend&#39;s account id
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param gameType This parameter is deprecated. (optional)
     * @param appKey the application key (optional)
     * @param notifyFriend determines whether to send a notification to the afflicting party (optional)
     * @param notificationMessage optional message to send in a notification (optional)
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun friendReject(version: java.math.BigDecimal, friendAccountId: kotlin.Long, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, gameType: kotlin.String? = null, appKey: kotlin.String? = null, notifyFriend: kotlin.Boolean? = null, notificationMessage: kotlin.String? = null) : SirqulResponse {
        val localVarResponse = friendRejectWithHttpInfo(version = version, friendAccountId = friendAccountId, deviceId = deviceId, accountId = accountId, gameType = gameType, appKey = appKey, notifyFriend = notifyFriend, notificationMessage = notificationMessage)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/{version}/consumer/friend/reject
     * Decline Friend
     * Request a friend request and optionally sends a notification.
     * @param version 
     * @param friendAccountId the friend&#39;s account id
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param gameType This parameter is deprecated. (optional)
     * @param appKey the application key (optional)
     * @param notifyFriend determines whether to send a notification to the afflicting party (optional)
     * @param notificationMessage optional message to send in a notification (optional)
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun friendRejectWithHttpInfo(version: java.math.BigDecimal, friendAccountId: kotlin.Long, deviceId: kotlin.String?, accountId: kotlin.Long?, gameType: kotlin.String?, appKey: kotlin.String?, notifyFriend: kotlin.Boolean?, notificationMessage: kotlin.String?) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = friendRejectRequestConfig(version = version, friendAccountId = friendAccountId, deviceId = deviceId, accountId = accountId, gameType = gameType, appKey = appKey, notifyFriend = notifyFriend, notificationMessage = notificationMessage)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation friendReject
     *
     * @param version 
     * @param friendAccountId the friend&#39;s account id
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param gameType This parameter is deprecated. (optional)
     * @param appKey the application key (optional)
     * @param notifyFriend determines whether to send a notification to the afflicting party (optional)
     * @param notificationMessage optional message to send in a notification (optional)
     * @return RequestConfig
     */
    fun friendRejectRequestConfig(version: java.math.BigDecimal, friendAccountId: kotlin.Long, deviceId: kotlin.String?, accountId: kotlin.Long?, gameType: kotlin.String?, appKey: kotlin.String?, notifyFriend: kotlin.Boolean?, notificationMessage: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                put("friendAccountId", listOf(friendAccountId.toString()))
                if (gameType != null) {
                    put("gameType", listOf(gameType.toString()))
                }
                if (appKey != null) {
                    put("appKey", listOf(appKey.toString()))
                }
                if (notifyFriend != null) {
                    put("notifyFriend", listOf(notifyFriend.toString()))
                }
                if (notificationMessage != null) {
                    put("notificationMessage", listOf(notificationMessage.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/{version}/consumer/friend/reject".replace("{"+"version"+"}", encodeURIComponent(version.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/{version}/consumer/friend/remove
     * Delete Friend
     * Removes a friend from the user&#39;s friends list.
     * @param version 
     * @param friendAccountId the account ID of the friend to remove
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param notifyFriend optionally notifies the connection that they have been removed as a friend (optional)
     * @param removeFromGroups optionally removes the connection from the user&#39;s groups (optional)
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun friendRemove(version: java.math.BigDecimal, friendAccountId: kotlin.Long, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, notifyFriend: kotlin.Boolean? = null, removeFromGroups: kotlin.Boolean? = null) : SirqulResponse {
        val localVarResponse = friendRemoveWithHttpInfo(version = version, friendAccountId = friendAccountId, deviceId = deviceId, accountId = accountId, notifyFriend = notifyFriend, removeFromGroups = removeFromGroups)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/{version}/consumer/friend/remove
     * Delete Friend
     * Removes a friend from the user&#39;s friends list.
     * @param version 
     * @param friendAccountId the account ID of the friend to remove
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param notifyFriend optionally notifies the connection that they have been removed as a friend (optional)
     * @param removeFromGroups optionally removes the connection from the user&#39;s groups (optional)
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun friendRemoveWithHttpInfo(version: java.math.BigDecimal, friendAccountId: kotlin.Long, deviceId: kotlin.String?, accountId: kotlin.Long?, notifyFriend: kotlin.Boolean?, removeFromGroups: kotlin.Boolean?) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = friendRemoveRequestConfig(version = version, friendAccountId = friendAccountId, deviceId = deviceId, accountId = accountId, notifyFriend = notifyFriend, removeFromGroups = removeFromGroups)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation friendRemove
     *
     * @param version 
     * @param friendAccountId the account ID of the friend to remove
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param notifyFriend optionally notifies the connection that they have been removed as a friend (optional)
     * @param removeFromGroups optionally removes the connection from the user&#39;s groups (optional)
     * @return RequestConfig
     */
    fun friendRemoveRequestConfig(version: java.math.BigDecimal, friendAccountId: kotlin.Long, deviceId: kotlin.String?, accountId: kotlin.Long?, notifyFriend: kotlin.Boolean?, removeFromGroups: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                put("friendAccountId", listOf(friendAccountId.toString()))
                if (notifyFriend != null) {
                    put("notifyFriend", listOf(notifyFriend.toString()))
                }
                if (removeFromGroups != null) {
                    put("removeFromGroups", listOf(removeFromGroups.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/{version}/consumer/friend/remove".replace("{"+"version"+"}", encodeURIComponent(version.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/{version}/consumer/friend/request
     * Request Friend
     * Sends a friend request notification to another user.
     * @param version 
     * @param friendAccountId the friend&#39;s account id
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param gameType This parameter is deprecated. (optional)
     * @param appKey the application key (optional)
     * @param notificationMessage optional message to send in a notification (optional)
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun friendRequest(version: java.math.BigDecimal, friendAccountId: kotlin.Long, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, gameType: kotlin.String? = null, appKey: kotlin.String? = null, notificationMessage: kotlin.String? = null) : SirqulResponse {
        val localVarResponse = friendRequestWithHttpInfo(version = version, friendAccountId = friendAccountId, deviceId = deviceId, accountId = accountId, gameType = gameType, appKey = appKey, notificationMessage = notificationMessage)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/{version}/consumer/friend/request
     * Request Friend
     * Sends a friend request notification to another user.
     * @param version 
     * @param friendAccountId the friend&#39;s account id
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param gameType This parameter is deprecated. (optional)
     * @param appKey the application key (optional)
     * @param notificationMessage optional message to send in a notification (optional)
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun friendRequestWithHttpInfo(version: java.math.BigDecimal, friendAccountId: kotlin.Long, deviceId: kotlin.String?, accountId: kotlin.Long?, gameType: kotlin.String?, appKey: kotlin.String?, notificationMessage: kotlin.String?) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = friendRequestRequestConfig(version = version, friendAccountId = friendAccountId, deviceId = deviceId, accountId = accountId, gameType = gameType, appKey = appKey, notificationMessage = notificationMessage)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation friendRequest
     *
     * @param version 
     * @param friendAccountId the friend&#39;s account id
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param gameType This parameter is deprecated. (optional)
     * @param appKey the application key (optional)
     * @param notificationMessage optional message to send in a notification (optional)
     * @return RequestConfig
     */
    fun friendRequestRequestConfig(version: java.math.BigDecimal, friendAccountId: kotlin.Long, deviceId: kotlin.String?, accountId: kotlin.Long?, gameType: kotlin.String?, appKey: kotlin.String?, notificationMessage: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                put("friendAccountId", listOf(friendAccountId.toString()))
                if (gameType != null) {
                    put("gameType", listOf(gameType.toString()))
                }
                if (appKey != null) {
                    put("appKey", listOf(appKey.toString()))
                }
                if (notificationMessage != null) {
                    put("notificationMessage", listOf(notificationMessage.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/{version}/consumer/friend/request".replace("{"+"version"+"}", encodeURIComponent(version.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /api/{version}/consumer/connection/getRequested
     * Get Sent Friend Requests
     * Gets the connection sent friend requests.
     * @param version 
     * @param deviceId the ID of the device (optional)
     * @param accountId the id of the account (optional)
     * @return ConnectionListResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getConnectionSentFriendRequests(version: java.math.BigDecimal, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null) : ConnectionListResponse {
        val localVarResponse = getConnectionSentFriendRequestsWithHttpInfo(version = version, deviceId = deviceId, accountId = accountId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ConnectionListResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/{version}/consumer/connection/getRequested
     * Get Sent Friend Requests
     * Gets the connection sent friend requests.
     * @param version 
     * @param deviceId the ID of the device (optional)
     * @param accountId the id of the account (optional)
     * @return ApiResponse<ConnectionListResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getConnectionSentFriendRequestsWithHttpInfo(version: java.math.BigDecimal, deviceId: kotlin.String?, accountId: kotlin.Long?) : ApiResponse<ConnectionListResponse?> {
        val localVariableConfig = getConnectionSentFriendRequestsRequestConfig(version = version, deviceId = deviceId, accountId = accountId)

        return request<Unit, ConnectionListResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getConnectionSentFriendRequests
     *
     * @param version 
     * @param deviceId the ID of the device (optional)
     * @param accountId the id of the account (optional)
     * @return RequestConfig
     */
    fun getConnectionSentFriendRequestsRequestConfig(version: java.math.BigDecimal, deviceId: kotlin.String?, accountId: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/{version}/consumer/connection/getRequested".replace("{"+"version"+"}", encodeURIComponent(version.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /api/{version}/consumer/connection/get
     * Search Connections
     * Gets the connections.
     * @param version 
     * @param returnNulls whether to return nulls or not
     * @param filter a comma separated list of ConnectionApiMap. (NOTE on FOLLOWER vs FOLLOWING: FOLLOWER will get me a list of followers, FOLLOWING will get me a list of people I am following)
     * @param sortField sorts the response list by ConnectionApiMap
     * @param descending sorts the response list by descending order if true
     * @param start start index of the pagination
     * @param limit limit of the pagination
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id (deviceId or accountId required) (optional)
     * @param connectionAccountId optional parameter to search on other account&#39;s connections (optional)
     * @param q This parameter is deprecated. (optional)
     * @param keyword an optional keyword to search on, this parameter is ignored if empty (optional)
     * @param i This parameter is deprecated. (optional)
     * @param l This parameter is deprecated. (optional)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @return ConnectionListResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getConnections(version: java.math.BigDecimal, returnNulls: kotlin.Boolean, filter: kotlin.String, sortField: kotlin.String, descending: kotlin.Boolean, start: kotlin.Int, limit: kotlin.Int, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, connectionAccountId: kotlin.Long? = null, q: kotlin.String? = null, keyword: kotlin.String? = null, i: kotlin.Int? = null, l: kotlin.Int? = null, latitude: kotlin.Double? = null, longitude: kotlin.Double? = null) : ConnectionListResponse {
        val localVarResponse = getConnectionsWithHttpInfo(version = version, returnNulls = returnNulls, filter = filter, sortField = sortField, descending = descending, start = start, limit = limit, deviceId = deviceId, accountId = accountId, connectionAccountId = connectionAccountId, q = q, keyword = keyword, i = i, l = l, latitude = latitude, longitude = longitude)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ConnectionListResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/{version}/consumer/connection/get
     * Search Connections
     * Gets the connections.
     * @param version 
     * @param returnNulls whether to return nulls or not
     * @param filter a comma separated list of ConnectionApiMap. (NOTE on FOLLOWER vs FOLLOWING: FOLLOWER will get me a list of followers, FOLLOWING will get me a list of people I am following)
     * @param sortField sorts the response list by ConnectionApiMap
     * @param descending sorts the response list by descending order if true
     * @param start start index of the pagination
     * @param limit limit of the pagination
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id (deviceId or accountId required) (optional)
     * @param connectionAccountId optional parameter to search on other account&#39;s connections (optional)
     * @param q This parameter is deprecated. (optional)
     * @param keyword an optional keyword to search on, this parameter is ignored if empty (optional)
     * @param i This parameter is deprecated. (optional)
     * @param l This parameter is deprecated. (optional)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @return ApiResponse<ConnectionListResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getConnectionsWithHttpInfo(version: java.math.BigDecimal, returnNulls: kotlin.Boolean, filter: kotlin.String, sortField: kotlin.String, descending: kotlin.Boolean, start: kotlin.Int, limit: kotlin.Int, deviceId: kotlin.String?, accountId: kotlin.Long?, connectionAccountId: kotlin.Long?, q: kotlin.String?, keyword: kotlin.String?, i: kotlin.Int?, l: kotlin.Int?, latitude: kotlin.Double?, longitude: kotlin.Double?) : ApiResponse<ConnectionListResponse?> {
        val localVariableConfig = getConnectionsRequestConfig(version = version, returnNulls = returnNulls, filter = filter, sortField = sortField, descending = descending, start = start, limit = limit, deviceId = deviceId, accountId = accountId, connectionAccountId = connectionAccountId, q = q, keyword = keyword, i = i, l = l, latitude = latitude, longitude = longitude)

        return request<Unit, ConnectionListResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getConnections
     *
     * @param version 
     * @param returnNulls whether to return nulls or not
     * @param filter a comma separated list of ConnectionApiMap. (NOTE on FOLLOWER vs FOLLOWING: FOLLOWER will get me a list of followers, FOLLOWING will get me a list of people I am following)
     * @param sortField sorts the response list by ConnectionApiMap
     * @param descending sorts the response list by descending order if true
     * @param start start index of the pagination
     * @param limit limit of the pagination
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id (deviceId or accountId required) (optional)
     * @param connectionAccountId optional parameter to search on other account&#39;s connections (optional)
     * @param q This parameter is deprecated. (optional)
     * @param keyword an optional keyword to search on, this parameter is ignored if empty (optional)
     * @param i This parameter is deprecated. (optional)
     * @param l This parameter is deprecated. (optional)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @return RequestConfig
     */
    fun getConnectionsRequestConfig(version: java.math.BigDecimal, returnNulls: kotlin.Boolean, filter: kotlin.String, sortField: kotlin.String, descending: kotlin.Boolean, start: kotlin.Int, limit: kotlin.Int, deviceId: kotlin.String?, accountId: kotlin.Long?, connectionAccountId: kotlin.Long?, q: kotlin.String?, keyword: kotlin.String?, i: kotlin.Int?, l: kotlin.Int?, latitude: kotlin.Double?, longitude: kotlin.Double?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("returnNulls", listOf(returnNulls.toString()))
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (connectionAccountId != null) {
                    put("connectionAccountId", listOf(connectionAccountId.toString()))
                }
                put("filter", listOf(filter.toString()))
                if (q != null) {
                    put("q", listOf(q.toString()))
                }
                if (keyword != null) {
                    put("keyword", listOf(keyword.toString()))
                }
                put("sortField", listOf(sortField.toString()))
                put("descending", listOf(descending.toString()))
                if (i != null) {
                    put("_i", listOf(i.toString()))
                }
                put("start", listOf(start.toString()))
                if (l != null) {
                    put("_l", listOf(l.toString()))
                }
                put("limit", listOf(limit.toString()))
                if (latitude != null) {
                    put("latitude", listOf(latitude.toString()))
                }
                if (longitude != null) {
                    put("longitude", listOf(longitude.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/{version}/consumer/connection/get".replace("{"+"version"+"}", encodeURIComponent(version.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /api/{version}/consumer/connection/group/details/get
     * Get Connection Group
     * 
     * @param version 
     * @param combineConnections whether to combine connections or not
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param groupId the group id (optional)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @return ConnectionGroupResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getGroupDetails(version: java.math.BigDecimal, combineConnections: kotlin.Boolean, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, groupId: kotlin.Long? = null, latitude: kotlin.Double? = null, longitude: kotlin.Double? = null) : ConnectionGroupResponse {
        val localVarResponse = getGroupDetailsWithHttpInfo(version = version, combineConnections = combineConnections, deviceId = deviceId, accountId = accountId, groupId = groupId, latitude = latitude, longitude = longitude)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ConnectionGroupResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/{version}/consumer/connection/group/details/get
     * Get Connection Group
     * 
     * @param version 
     * @param combineConnections whether to combine connections or not
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param groupId the group id (optional)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @return ApiResponse<ConnectionGroupResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getGroupDetailsWithHttpInfo(version: java.math.BigDecimal, combineConnections: kotlin.Boolean, deviceId: kotlin.String?, accountId: kotlin.Long?, groupId: kotlin.Long?, latitude: kotlin.Double?, longitude: kotlin.Double?) : ApiResponse<ConnectionGroupResponse?> {
        val localVariableConfig = getGroupDetailsRequestConfig(version = version, combineConnections = combineConnections, deviceId = deviceId, accountId = accountId, groupId = groupId, latitude = latitude, longitude = longitude)

        return request<Unit, ConnectionGroupResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getGroupDetails
     *
     * @param version 
     * @param combineConnections whether to combine connections or not
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param groupId the group id (optional)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @return RequestConfig
     */
    fun getGroupDetailsRequestConfig(version: java.math.BigDecimal, combineConnections: kotlin.Boolean, deviceId: kotlin.String?, accountId: kotlin.Long?, groupId: kotlin.Long?, latitude: kotlin.Double?, longitude: kotlin.Double?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (groupId != null) {
                    put("groupId", listOf(groupId.toString()))
                }
                put("combineConnections", listOf(combineConnections.toString()))
                if (latitude != null) {
                    put("latitude", listOf(latitude.toString()))
                }
                if (longitude != null) {
                    put("longitude", listOf(longitude.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/{version}/consumer/connection/group/details/get".replace("{"+"version"+"}", encodeURIComponent(version.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter sortField
     */
     enum class SortFieldGroupSearch(val value: kotlin.String) {
         @Json(name = "CREATED") CREATED("CREATED"),
         @Json(name = "UPDATED") UPDATED("UPDATED"),
         @Json(name = "ACTIVE") ACTIVE("ACTIVE"),
         @Json(name = "NAME") NAME("NAME"),
         @Json(name = "DESCRIPTION") DESCRIPTION("DESCRIPTION"),
         @Json(name = "CAN_VIEW_PROFILE_INFO") CAN_VIEW_PROFILE_INFO("CAN_VIEW_PROFILE_INFO"),
         @Json(name = "CAN_VIEW_GAME_INFO") CAN_VIEW_GAME_INFO("CAN_VIEW_GAME_INFO"),
         @Json(name = "CAN_VIEW_FRIEND_INFO") CAN_VIEW_FRIEND_INFO("CAN_VIEW_FRIEND_INFO"),
         @Json(name = "INVITE_CODE") INVITE_CODE("INVITE_CODE"),
         @Json(name = "OWNER_DISPLAY") OWNER_DISPLAY("OWNER_DISPLAY"),
         @Json(name = "OWNER_USERNAME") OWNER_USERNAME("OWNER_USERNAME");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /api/{version}/connection/group/search
     * Search Connection Groups
     * Gets a user&#39;s private groups and default groups.
     * @param version 
     * @param sortField the field to sort by
     * @param descending whether to return results in descending or ascending order
     * @param activeOnly to search on active only or not
     * @param start The start of the pagination
     * @param limit the limit of the pagination
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @param keyword keyword search string (optional)
     * @return kotlin.collections.List<ConnectionInfoResponse>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun groupSearch(version: java.math.BigDecimal, sortField: SortFieldGroupSearch, descending: kotlin.Boolean, activeOnly: kotlin.Boolean, start: kotlin.Int, limit: kotlin.Int, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, latitude: kotlin.Double? = null, longitude: kotlin.Double? = null, keyword: kotlin.String? = null) : kotlin.collections.List<ConnectionInfoResponse> {
        val localVarResponse = groupSearchWithHttpInfo(version = version, sortField = sortField, descending = descending, activeOnly = activeOnly, start = start, limit = limit, deviceId = deviceId, accountId = accountId, latitude = latitude, longitude = longitude, keyword = keyword)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<ConnectionInfoResponse>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/{version}/connection/group/search
     * Search Connection Groups
     * Gets a user&#39;s private groups and default groups.
     * @param version 
     * @param sortField the field to sort by
     * @param descending whether to return results in descending or ascending order
     * @param activeOnly to search on active only or not
     * @param start The start of the pagination
     * @param limit the limit of the pagination
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @param keyword keyword search string (optional)
     * @return ApiResponse<kotlin.collections.List<ConnectionInfoResponse>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun groupSearchWithHttpInfo(version: java.math.BigDecimal, sortField: SortFieldGroupSearch, descending: kotlin.Boolean, activeOnly: kotlin.Boolean, start: kotlin.Int, limit: kotlin.Int, deviceId: kotlin.String?, accountId: kotlin.Long?, latitude: kotlin.Double?, longitude: kotlin.Double?, keyword: kotlin.String?) : ApiResponse<kotlin.collections.List<ConnectionInfoResponse>?> {
        val localVariableConfig = groupSearchRequestConfig(version = version, sortField = sortField, descending = descending, activeOnly = activeOnly, start = start, limit = limit, deviceId = deviceId, accountId = accountId, latitude = latitude, longitude = longitude, keyword = keyword)

        return request<Unit, kotlin.collections.List<ConnectionInfoResponse>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation groupSearch
     *
     * @param version 
     * @param sortField the field to sort by
     * @param descending whether to return results in descending or ascending order
     * @param activeOnly to search on active only or not
     * @param start The start of the pagination
     * @param limit the limit of the pagination
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @param keyword keyword search string (optional)
     * @return RequestConfig
     */
    fun groupSearchRequestConfig(version: java.math.BigDecimal, sortField: SortFieldGroupSearch, descending: kotlin.Boolean, activeOnly: kotlin.Boolean, start: kotlin.Int, limit: kotlin.Int, deviceId: kotlin.String?, accountId: kotlin.Long?, latitude: kotlin.Double?, longitude: kotlin.Double?, keyword: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (latitude != null) {
                    put("latitude", listOf(latitude.toString()))
                }
                if (longitude != null) {
                    put("longitude", listOf(longitude.toString()))
                }
                if (keyword != null) {
                    put("keyword", listOf(keyword.toString()))
                }
                put("sortField", listOf(sortField.value))
                put("descending", listOf(descending.toString()))
                put("activeOnly", listOf(activeOnly.toString()))
                put("start", listOf(start.toString()))
                put("limit", listOf(limit.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/{version}/connection/group/search".replace("{"+"version"+"}", encodeURIComponent(version.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/{version}/consumer/connection/group/removeConnection
     * Delete Connection
     * Removes the connection from group.
     * @param version 
     * @param returnNulls whether to return nulls or not
     * @param groupId the group id
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param connectionId the connection id (optional)
     * @param connectionAccountId the connection account id (optional)
     * @param pendingId the pending id (optional)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun removeConnectionFromGroup(version: java.math.BigDecimal, returnNulls: kotlin.Boolean, groupId: kotlin.Long, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, connectionId: kotlin.Long? = null, connectionAccountId: kotlin.Long? = null, pendingId: kotlin.Long? = null, latitude: kotlin.Double? = null, longitude: kotlin.Double? = null) : SirqulResponse {
        val localVarResponse = removeConnectionFromGroupWithHttpInfo(version = version, returnNulls = returnNulls, groupId = groupId, deviceId = deviceId, accountId = accountId, connectionId = connectionId, connectionAccountId = connectionAccountId, pendingId = pendingId, latitude = latitude, longitude = longitude)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/{version}/consumer/connection/group/removeConnection
     * Delete Connection
     * Removes the connection from group.
     * @param version 
     * @param returnNulls whether to return nulls or not
     * @param groupId the group id
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param connectionId the connection id (optional)
     * @param connectionAccountId the connection account id (optional)
     * @param pendingId the pending id (optional)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun removeConnectionFromGroupWithHttpInfo(version: java.math.BigDecimal, returnNulls: kotlin.Boolean, groupId: kotlin.Long, deviceId: kotlin.String?, accountId: kotlin.Long?, connectionId: kotlin.Long?, connectionAccountId: kotlin.Long?, pendingId: kotlin.Long?, latitude: kotlin.Double?, longitude: kotlin.Double?) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = removeConnectionFromGroupRequestConfig(version = version, returnNulls = returnNulls, groupId = groupId, deviceId = deviceId, accountId = accountId, connectionId = connectionId, connectionAccountId = connectionAccountId, pendingId = pendingId, latitude = latitude, longitude = longitude)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation removeConnectionFromGroup
     *
     * @param version 
     * @param returnNulls whether to return nulls or not
     * @param groupId the group id
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param connectionId the connection id (optional)
     * @param connectionAccountId the connection account id (optional)
     * @param pendingId the pending id (optional)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @return RequestConfig
     */
    fun removeConnectionFromGroupRequestConfig(version: java.math.BigDecimal, returnNulls: kotlin.Boolean, groupId: kotlin.Long, deviceId: kotlin.String?, accountId: kotlin.Long?, connectionId: kotlin.Long?, connectionAccountId: kotlin.Long?, pendingId: kotlin.Long?, latitude: kotlin.Double?, longitude: kotlin.Double?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("returnNulls", listOf(returnNulls.toString()))
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (connectionId != null) {
                    put("connectionId", listOf(connectionId.toString()))
                }
                if (connectionAccountId != null) {
                    put("connectionAccountId", listOf(connectionAccountId.toString()))
                }
                if (pendingId != null) {
                    put("pendingId", listOf(pendingId.toString()))
                }
                put("groupId", listOf(groupId.toString()))
                if (latitude != null) {
                    put("latitude", listOf(latitude.toString()))
                }
                if (longitude != null) {
                    put("longitude", listOf(longitude.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/{version}/consumer/connection/group/removeConnection".replace("{"+"version"+"}", encodeURIComponent(version.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/{version}/connection/group/removeConnections
     * Remove Connections
     * Remove a list of connections from a group.
     * @param version 
     * @param connectionGroupId connection group id
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param connectionIds comma separated list of connection ids (optional)
     * @param connectionAccountIds comma separated list of connection account ids (optional)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun removeConnectionsFromGroup(version: java.math.BigDecimal, connectionGroupId: kotlin.Long, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, connectionIds: kotlin.String? = null, connectionAccountIds: kotlin.String? = null, latitude: kotlin.Double? = null, longitude: kotlin.Double? = null) : SirqulResponse {
        val localVarResponse = removeConnectionsFromGroupWithHttpInfo(version = version, connectionGroupId = connectionGroupId, deviceId = deviceId, accountId = accountId, connectionIds = connectionIds, connectionAccountIds = connectionAccountIds, latitude = latitude, longitude = longitude)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/{version}/connection/group/removeConnections
     * Remove Connections
     * Remove a list of connections from a group.
     * @param version 
     * @param connectionGroupId connection group id
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param connectionIds comma separated list of connection ids (optional)
     * @param connectionAccountIds comma separated list of connection account ids (optional)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun removeConnectionsFromGroupWithHttpInfo(version: java.math.BigDecimal, connectionGroupId: kotlin.Long, deviceId: kotlin.String?, accountId: kotlin.Long?, connectionIds: kotlin.String?, connectionAccountIds: kotlin.String?, latitude: kotlin.Double?, longitude: kotlin.Double?) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = removeConnectionsFromGroupRequestConfig(version = version, connectionGroupId = connectionGroupId, deviceId = deviceId, accountId = accountId, connectionIds = connectionIds, connectionAccountIds = connectionAccountIds, latitude = latitude, longitude = longitude)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation removeConnectionsFromGroup
     *
     * @param version 
     * @param connectionGroupId connection group id
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param connectionIds comma separated list of connection ids (optional)
     * @param connectionAccountIds comma separated list of connection account ids (optional)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @return RequestConfig
     */
    fun removeConnectionsFromGroupRequestConfig(version: java.math.BigDecimal, connectionGroupId: kotlin.Long, deviceId: kotlin.String?, accountId: kotlin.Long?, connectionIds: kotlin.String?, connectionAccountIds: kotlin.String?, latitude: kotlin.Double?, longitude: kotlin.Double?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (connectionIds != null) {
                    put("connectionIds", listOf(connectionIds.toString()))
                }
                if (connectionAccountIds != null) {
                    put("connectionAccountIds", listOf(connectionAccountIds.toString()))
                }
                put("connectionGroupId", listOf(connectionGroupId.toString()))
                if (latitude != null) {
                    put("latitude", listOf(latitude.toString()))
                }
                if (longitude != null) {
                    put("longitude", listOf(longitude.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/{version}/connection/group/removeConnections".replace("{"+"version"+"}", encodeURIComponent(version.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/{version}/consumer/connection/group/remove
     * Delete Connection Group
     * Remove a user&#39;s group.
     * @param version 
     * @param returnNulls whether to return nulls or not
     * @param groupId the group id
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun removeGroup(version: java.math.BigDecimal, returnNulls: kotlin.Boolean, groupId: kotlin.Long, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, latitude: kotlin.Double? = null, longitude: kotlin.Double? = null) : SirqulResponse {
        val localVarResponse = removeGroupWithHttpInfo(version = version, returnNulls = returnNulls, groupId = groupId, deviceId = deviceId, accountId = accountId, latitude = latitude, longitude = longitude)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/{version}/consumer/connection/group/remove
     * Delete Connection Group
     * Remove a user&#39;s group.
     * @param version 
     * @param returnNulls whether to return nulls or not
     * @param groupId the group id
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun removeGroupWithHttpInfo(version: java.math.BigDecimal, returnNulls: kotlin.Boolean, groupId: kotlin.Long, deviceId: kotlin.String?, accountId: kotlin.Long?, latitude: kotlin.Double?, longitude: kotlin.Double?) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = removeGroupRequestConfig(version = version, returnNulls = returnNulls, groupId = groupId, deviceId = deviceId, accountId = accountId, latitude = latitude, longitude = longitude)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation removeGroup
     *
     * @param version 
     * @param returnNulls whether to return nulls or not
     * @param groupId the group id
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @return RequestConfig
     */
    fun removeGroupRequestConfig(version: java.math.BigDecimal, returnNulls: kotlin.Boolean, groupId: kotlin.Long, deviceId: kotlin.String?, accountId: kotlin.Long?, latitude: kotlin.Double?, longitude: kotlin.Double?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("returnNulls", listOf(returnNulls.toString()))
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                put("groupId", listOf(groupId.toString()))
                if (latitude != null) {
                    put("latitude", listOf(latitude.toString()))
                }
                if (longitude != null) {
                    put("longitude", listOf(longitude.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/{version}/consumer/connection/group/remove".replace("{"+"version"+"}", encodeURIComponent(version.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/{version}/consumer/connection/group/removeSubGroup
     * Remove Connection Groups
     * Remove sub groups from a group
     * @param version 
     * @param returnNulls whether to return nulls or not
     * @param groupId the parent group id
     * @param subGroupIds comma separated list of group IDs to remove from the parent group
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun removeSubGroups(version: java.math.BigDecimal, returnNulls: kotlin.Boolean, groupId: kotlin.Long, subGroupIds: kotlin.String, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, latitude: kotlin.Double? = null, longitude: kotlin.Double? = null) : SirqulResponse {
        val localVarResponse = removeSubGroupsWithHttpInfo(version = version, returnNulls = returnNulls, groupId = groupId, subGroupIds = subGroupIds, deviceId = deviceId, accountId = accountId, latitude = latitude, longitude = longitude)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/{version}/consumer/connection/group/removeSubGroup
     * Remove Connection Groups
     * Remove sub groups from a group
     * @param version 
     * @param returnNulls whether to return nulls or not
     * @param groupId the parent group id
     * @param subGroupIds comma separated list of group IDs to remove from the parent group
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun removeSubGroupsWithHttpInfo(version: java.math.BigDecimal, returnNulls: kotlin.Boolean, groupId: kotlin.Long, subGroupIds: kotlin.String, deviceId: kotlin.String?, accountId: kotlin.Long?, latitude: kotlin.Double?, longitude: kotlin.Double?) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = removeSubGroupsRequestConfig(version = version, returnNulls = returnNulls, groupId = groupId, subGroupIds = subGroupIds, deviceId = deviceId, accountId = accountId, latitude = latitude, longitude = longitude)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation removeSubGroups
     *
     * @param version 
     * @param returnNulls whether to return nulls or not
     * @param groupId the parent group id
     * @param subGroupIds comma separated list of group IDs to remove from the parent group
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @return RequestConfig
     */
    fun removeSubGroupsRequestConfig(version: java.math.BigDecimal, returnNulls: kotlin.Boolean, groupId: kotlin.Long, subGroupIds: kotlin.String, deviceId: kotlin.String?, accountId: kotlin.Long?, latitude: kotlin.Double?, longitude: kotlin.Double?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("returnNulls", listOf(returnNulls.toString()))
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                put("groupId", listOf(groupId.toString()))
                put("subGroupIds", listOf(subGroupIds.toString()))
                if (latitude != null) {
                    put("latitude", listOf(latitude.toString()))
                }
                if (longitude != null) {
                    put("longitude", listOf(longitude.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/{version}/consumer/connection/group/removeSubGroup".replace("{"+"version"+"}", encodeURIComponent(version.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /api/{version}/connection/search
     * Search Possible Connections
     * Search for accounts that the user may not have a connection with.
     * @param version 
     * @param returnNulls return all json attributes if true. defualt is true.
     * @param start start index of the pagination
     * @param limit limit of the pagination
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id (deviceId or accountId required) (optional)
     * @param q This parameter is deprecated. (optional)
     * @param keyword keyword to search on, optional and this parameter is ignored if empt (optional)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @param gameType This parameter is deprecated. (optional)
     * @param appKey the public application key, if provided only looks for users of that application (optional)
     * @param i This parameter is deprecated. (optional)
     * @param l This parameter is deprecated. (optional)
     * @param sortField the field to sort on (optional)
     * @param hasLocation whether the search has location or not (optional)
     * @return ConnectionListResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun searchConnections(version: java.math.BigDecimal, returnNulls: kotlin.Boolean, start: kotlin.Int, limit: kotlin.Int, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, q: kotlin.String? = null, keyword: kotlin.String? = null, latitude: kotlin.Double? = null, longitude: kotlin.Double? = null, gameType: kotlin.String? = null, appKey: kotlin.String? = null, i: kotlin.Int? = null, l: kotlin.Int? = null, sortField: kotlin.String? = null, hasLocation: kotlin.Boolean? = null) : ConnectionListResponse {
        val localVarResponse = searchConnectionsWithHttpInfo(version = version, returnNulls = returnNulls, start = start, limit = limit, deviceId = deviceId, accountId = accountId, q = q, keyword = keyword, latitude = latitude, longitude = longitude, gameType = gameType, appKey = appKey, i = i, l = l, sortField = sortField, hasLocation = hasLocation)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ConnectionListResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/{version}/connection/search
     * Search Possible Connections
     * Search for accounts that the user may not have a connection with.
     * @param version 
     * @param returnNulls return all json attributes if true. defualt is true.
     * @param start start index of the pagination
     * @param limit limit of the pagination
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id (deviceId or accountId required) (optional)
     * @param q This parameter is deprecated. (optional)
     * @param keyword keyword to search on, optional and this parameter is ignored if empt (optional)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @param gameType This parameter is deprecated. (optional)
     * @param appKey the public application key, if provided only looks for users of that application (optional)
     * @param i This parameter is deprecated. (optional)
     * @param l This parameter is deprecated. (optional)
     * @param sortField the field to sort on (optional)
     * @param hasLocation whether the search has location or not (optional)
     * @return ApiResponse<ConnectionListResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun searchConnectionsWithHttpInfo(version: java.math.BigDecimal, returnNulls: kotlin.Boolean, start: kotlin.Int, limit: kotlin.Int, deviceId: kotlin.String?, accountId: kotlin.Long?, q: kotlin.String?, keyword: kotlin.String?, latitude: kotlin.Double?, longitude: kotlin.Double?, gameType: kotlin.String?, appKey: kotlin.String?, i: kotlin.Int?, l: kotlin.Int?, sortField: kotlin.String?, hasLocation: kotlin.Boolean?) : ApiResponse<ConnectionListResponse?> {
        val localVariableConfig = searchConnectionsRequestConfig(version = version, returnNulls = returnNulls, start = start, limit = limit, deviceId = deviceId, accountId = accountId, q = q, keyword = keyword, latitude = latitude, longitude = longitude, gameType = gameType, appKey = appKey, i = i, l = l, sortField = sortField, hasLocation = hasLocation)

        return request<Unit, ConnectionListResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation searchConnections
     *
     * @param version 
     * @param returnNulls return all json attributes if true. defualt is true.
     * @param start start index of the pagination
     * @param limit limit of the pagination
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id (deviceId or accountId required) (optional)
     * @param q This parameter is deprecated. (optional)
     * @param keyword keyword to search on, optional and this parameter is ignored if empt (optional)
     * @param latitude the current latitude of the user (optional)
     * @param longitude the current longitude of the user (optional)
     * @param gameType This parameter is deprecated. (optional)
     * @param appKey the public application key, if provided only looks for users of that application (optional)
     * @param i This parameter is deprecated. (optional)
     * @param l This parameter is deprecated. (optional)
     * @param sortField the field to sort on (optional)
     * @param hasLocation whether the search has location or not (optional)
     * @return RequestConfig
     */
    fun searchConnectionsRequestConfig(version: java.math.BigDecimal, returnNulls: kotlin.Boolean, start: kotlin.Int, limit: kotlin.Int, deviceId: kotlin.String?, accountId: kotlin.Long?, q: kotlin.String?, keyword: kotlin.String?, latitude: kotlin.Double?, longitude: kotlin.Double?, gameType: kotlin.String?, appKey: kotlin.String?, i: kotlin.Int?, l: kotlin.Int?, sortField: kotlin.String?, hasLocation: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("returnNulls", listOf(returnNulls.toString()))
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (q != null) {
                    put("q", listOf(q.toString()))
                }
                if (keyword != null) {
                    put("keyword", listOf(keyword.toString()))
                }
                if (latitude != null) {
                    put("latitude", listOf(latitude.toString()))
                }
                if (longitude != null) {
                    put("longitude", listOf(longitude.toString()))
                }
                if (gameType != null) {
                    put("gameType", listOf(gameType.toString()))
                }
                if (appKey != null) {
                    put("appKey", listOf(appKey.toString()))
                }
                if (i != null) {
                    put("_i", listOf(i.toString()))
                }
                put("start", listOf(start.toString()))
                if (l != null) {
                    put("_l", listOf(l.toString()))
                }
                put("limit", listOf(limit.toString()))
                if (sortField != null) {
                    put("sortField", listOf(sortField.toString()))
                }
                if (hasLocation != null) {
                    put("hasLocation", listOf(hasLocation.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/{version}/connection/search".replace("{"+"version"+"}", encodeURIComponent(version.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
