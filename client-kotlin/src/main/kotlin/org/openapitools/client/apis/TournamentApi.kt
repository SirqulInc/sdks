/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import org.openapitools.client.models.MissionShortResponse
import org.openapitools.client.models.SirqulResponse
import org.openapitools.client.models.TournamentResponse

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

open class TournamentApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://dev.sirqul.com/api/3.18")
        }
    }

    /**
     * enum for parameter splitReward
     */
     enum class SplitRewardCreateTournament(val value: kotlin.String) {
         @Json(name = "EVEN") EVEN("EVEN"),
         @Json(name = "ALL") ALL("ALL"),
         @Json(name = "FIRST") FIRST("FIRST"),
         @Json(name = "RANDOM") RANDOM("RANDOM");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter missionType
     */
     enum class MissionTypeCreateTournament(val value: kotlin.String) {
         @Json(name = "TOURNAMENT") TOURNAMENT("TOURNAMENT"),
         @Json(name = "POOLPLAY") POOLPLAY("POOLPLAY"),
         @Json(name = "MULTISTAGE") MULTISTAGE("MULTISTAGE");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter visibility
     */
     enum class VisibilityCreateTournament(val value: kotlin.String) {
         @Json(name = "PUBLIC") PUBLIC("PUBLIC"),
         @Json(name = "LISTABLE") LISTABLE("LISTABLE"),
         @Json(name = "REWARDABLE") REWARDABLE("REWARDABLE"),
         @Json(name = "TRIGGERABLE") TRIGGERABLE("TRIGGERABLE"),
         @Json(name = "PRIVATE") PRIVATE("PRIVATE");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * POST /tournament/create
     * Create Tournament
     * Create a tournament.
     * @param accountId The logged in user.
     * @param appKey The appKey the tournament is created for.
     * @param title The title of the tournament
     * @param costToPlay The number of tickets required to pay to enter the tournament
     * @param startDate The date/time to start the tournament
     * @param subType Custom string client apps can use for searching/filtering tournaments (optional)
     * @param imageAssetId The asset ID to attach to the tournament (optional)
     * @param secondsBetweenLevels The number of seconds in between the start of each tournament game/group (optional, default to 600)
     * @param secondsForTieBreaker The number of seconds to extend the round end time in the case of a tie breaker (optional, default to 600)
     * @param secondsBetweenPacks The number of seconds in between the start of each tournament round (optional, default to 86400)
     * @param maximumLevelLength The maximum number of seconds the match is expected to end at, which gets used to determine when a match should end when there is no activity (optional, default to 1800)
     * @param costToPlayType The type of ticket required to pay (optional)
     * @param minimumToPlay The minimum number of players required to sign up for the tournament to be played (optional, default to 1)
     * @param startingLimit The starting number of players for a tournament (filled with AI&#39;s) (optional)
     * @param availableLimit The maximum number of players for a tournament (currently 128 but not enforced) (optional)
     * @param description The description of the tournament (optional)
     * @param metaData External custom client defined data (optional)
     * @param audienceIds The audiences associated with the tournament (optional)
     * @param active Activate/deactivate the tournament (optional)
     * @param enableBuyBack Determines whether to allow players to buy back into a tournament (optional, default to false)
     * @param offerIds The list of offers to give as a reward beyond the tickets (optional)
     * @param offerAssetId The artwork ID to attach to the reward tickets offers (optional)
     * @param fixedReward If set then do not update the ticket reward, auto set to true if offerIds provided (optional, default to false)
     * @param splitReward Set the rules for handling the reward in case of a tie, values: EVEN split the reward evenly ALL everyone gets the full reward value FIRST first score submitted RANDOM random player who scored (optional, default to SplitReward.ALL)
     * @param allocateTickets Flag to indicate owner should receive tickets for completed missions (optional)
     * @param tournamentData A text based string that will be passed into each tournament setup to populate the content (optional)
     * @param missionType The style of tournament to build, options are: TOURNAMENT, POOLPLAY (optional, default to MissionType.MULTISTAGE)
     * @param visibility Sets the visibility flag for the tournament (optional, default to Visibility.PUBLIC)
     * @param preliminaryGroups The number of initial preliminary groups in a multi-stage tournament (this is expected to be a power of two number) (optional, default to 1)
     * @param preliminaryGroupAdvancements This determines how many people can advance per round in a preliminary group (this is a comma separated list of integers) (optional, default to "1")
     * @param enableMultipleEntries This determines if multiple submissions/entries are allowed in a multi-stage album tournament (optional, default to false)
     * @param enableMultipleVotes This determines if users are allowed to vote multiple times per group in a multi-stage album tournament (optional, default to false)
     * @param featured This determines whether the tournament is \&quot;featured\&quot; or not (optional, default to false)
     * @param winnerTag This sets what analytic tag is used when a winner is determined (optional)
     * @param tieTag This sets what analytic tag is used when a tie has occurred (optional)
     * @return TournamentResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createTournament(accountId: kotlin.Long, appKey: kotlin.String, title: kotlin.String, costToPlay: kotlin.Int, startDate: kotlin.Long, subType: kotlin.String? = null, imageAssetId: kotlin.Long? = null, secondsBetweenLevels: kotlin.Int? = 600, secondsForTieBreaker: kotlin.Int? = 600, secondsBetweenPacks: kotlin.Int? = 86400, maximumLevelLength: kotlin.Int? = 1800, costToPlayType: kotlin.String? = null, minimumToPlay: kotlin.Int? = 1, startingLimit: kotlin.Int? = null, availableLimit: kotlin.Int? = null, description: kotlin.String? = null, metaData: kotlin.String? = null, audienceIds: kotlin.String? = null, active: kotlin.Boolean? = null, enableBuyBack: kotlin.Boolean? = false, offerIds: kotlin.String? = null, offerAssetId: kotlin.Long? = null, fixedReward: kotlin.Boolean? = false, splitReward: SplitRewardCreateTournament? = SplitRewardCreateTournament.ALL, allocateTickets: kotlin.Boolean? = null, tournamentData: kotlin.String? = null, missionType: MissionTypeCreateTournament? = MissionTypeCreateTournament.MULTISTAGE, visibility: VisibilityCreateTournament? = VisibilityCreateTournament.PUBLIC, preliminaryGroups: kotlin.Int? = 1, preliminaryGroupAdvancements: kotlin.String? = "1", enableMultipleEntries: kotlin.Boolean? = false, enableMultipleVotes: kotlin.Boolean? = false, featured: kotlin.Boolean? = false, winnerTag: kotlin.String? = null, tieTag: kotlin.String? = null) : TournamentResponse {
        val localVarResponse = createTournamentWithHttpInfo(accountId = accountId, appKey = appKey, title = title, costToPlay = costToPlay, startDate = startDate, subType = subType, imageAssetId = imageAssetId, secondsBetweenLevels = secondsBetweenLevels, secondsForTieBreaker = secondsForTieBreaker, secondsBetweenPacks = secondsBetweenPacks, maximumLevelLength = maximumLevelLength, costToPlayType = costToPlayType, minimumToPlay = minimumToPlay, startingLimit = startingLimit, availableLimit = availableLimit, description = description, metaData = metaData, audienceIds = audienceIds, active = active, enableBuyBack = enableBuyBack, offerIds = offerIds, offerAssetId = offerAssetId, fixedReward = fixedReward, splitReward = splitReward, allocateTickets = allocateTickets, tournamentData = tournamentData, missionType = missionType, visibility = visibility, preliminaryGroups = preliminaryGroups, preliminaryGroupAdvancements = preliminaryGroupAdvancements, enableMultipleEntries = enableMultipleEntries, enableMultipleVotes = enableMultipleVotes, featured = featured, winnerTag = winnerTag, tieTag = tieTag)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TournamentResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /tournament/create
     * Create Tournament
     * Create a tournament.
     * @param accountId The logged in user.
     * @param appKey The appKey the tournament is created for.
     * @param title The title of the tournament
     * @param costToPlay The number of tickets required to pay to enter the tournament
     * @param startDate The date/time to start the tournament
     * @param subType Custom string client apps can use for searching/filtering tournaments (optional)
     * @param imageAssetId The asset ID to attach to the tournament (optional)
     * @param secondsBetweenLevels The number of seconds in between the start of each tournament game/group (optional, default to 600)
     * @param secondsForTieBreaker The number of seconds to extend the round end time in the case of a tie breaker (optional, default to 600)
     * @param secondsBetweenPacks The number of seconds in between the start of each tournament round (optional, default to 86400)
     * @param maximumLevelLength The maximum number of seconds the match is expected to end at, which gets used to determine when a match should end when there is no activity (optional, default to 1800)
     * @param costToPlayType The type of ticket required to pay (optional)
     * @param minimumToPlay The minimum number of players required to sign up for the tournament to be played (optional, default to 1)
     * @param startingLimit The starting number of players for a tournament (filled with AI&#39;s) (optional)
     * @param availableLimit The maximum number of players for a tournament (currently 128 but not enforced) (optional)
     * @param description The description of the tournament (optional)
     * @param metaData External custom client defined data (optional)
     * @param audienceIds The audiences associated with the tournament (optional)
     * @param active Activate/deactivate the tournament (optional)
     * @param enableBuyBack Determines whether to allow players to buy back into a tournament (optional, default to false)
     * @param offerIds The list of offers to give as a reward beyond the tickets (optional)
     * @param offerAssetId The artwork ID to attach to the reward tickets offers (optional)
     * @param fixedReward If set then do not update the ticket reward, auto set to true if offerIds provided (optional, default to false)
     * @param splitReward Set the rules for handling the reward in case of a tie, values: EVEN split the reward evenly ALL everyone gets the full reward value FIRST first score submitted RANDOM random player who scored (optional, default to SplitReward.ALL)
     * @param allocateTickets Flag to indicate owner should receive tickets for completed missions (optional)
     * @param tournamentData A text based string that will be passed into each tournament setup to populate the content (optional)
     * @param missionType The style of tournament to build, options are: TOURNAMENT, POOLPLAY (optional, default to MissionType.MULTISTAGE)
     * @param visibility Sets the visibility flag for the tournament (optional, default to Visibility.PUBLIC)
     * @param preliminaryGroups The number of initial preliminary groups in a multi-stage tournament (this is expected to be a power of two number) (optional, default to 1)
     * @param preliminaryGroupAdvancements This determines how many people can advance per round in a preliminary group (this is a comma separated list of integers) (optional, default to "1")
     * @param enableMultipleEntries This determines if multiple submissions/entries are allowed in a multi-stage album tournament (optional, default to false)
     * @param enableMultipleVotes This determines if users are allowed to vote multiple times per group in a multi-stage album tournament (optional, default to false)
     * @param featured This determines whether the tournament is \&quot;featured\&quot; or not (optional, default to false)
     * @param winnerTag This sets what analytic tag is used when a winner is determined (optional)
     * @param tieTag This sets what analytic tag is used when a tie has occurred (optional)
     * @return ApiResponse<TournamentResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createTournamentWithHttpInfo(accountId: kotlin.Long, appKey: kotlin.String, title: kotlin.String, costToPlay: kotlin.Int, startDate: kotlin.Long, subType: kotlin.String?, imageAssetId: kotlin.Long?, secondsBetweenLevels: kotlin.Int?, secondsForTieBreaker: kotlin.Int?, secondsBetweenPacks: kotlin.Int?, maximumLevelLength: kotlin.Int?, costToPlayType: kotlin.String?, minimumToPlay: kotlin.Int?, startingLimit: kotlin.Int?, availableLimit: kotlin.Int?, description: kotlin.String?, metaData: kotlin.String?, audienceIds: kotlin.String?, active: kotlin.Boolean?, enableBuyBack: kotlin.Boolean?, offerIds: kotlin.String?, offerAssetId: kotlin.Long?, fixedReward: kotlin.Boolean?, splitReward: SplitRewardCreateTournament?, allocateTickets: kotlin.Boolean?, tournamentData: kotlin.String?, missionType: MissionTypeCreateTournament?, visibility: VisibilityCreateTournament?, preliminaryGroups: kotlin.Int?, preliminaryGroupAdvancements: kotlin.String?, enableMultipleEntries: kotlin.Boolean?, enableMultipleVotes: kotlin.Boolean?, featured: kotlin.Boolean?, winnerTag: kotlin.String?, tieTag: kotlin.String?) : ApiResponse<TournamentResponse?> {
        val localVariableConfig = createTournamentRequestConfig(accountId = accountId, appKey = appKey, title = title, costToPlay = costToPlay, startDate = startDate, subType = subType, imageAssetId = imageAssetId, secondsBetweenLevels = secondsBetweenLevels, secondsForTieBreaker = secondsForTieBreaker, secondsBetweenPacks = secondsBetweenPacks, maximumLevelLength = maximumLevelLength, costToPlayType = costToPlayType, minimumToPlay = minimumToPlay, startingLimit = startingLimit, availableLimit = availableLimit, description = description, metaData = metaData, audienceIds = audienceIds, active = active, enableBuyBack = enableBuyBack, offerIds = offerIds, offerAssetId = offerAssetId, fixedReward = fixedReward, splitReward = splitReward, allocateTickets = allocateTickets, tournamentData = tournamentData, missionType = missionType, visibility = visibility, preliminaryGroups = preliminaryGroups, preliminaryGroupAdvancements = preliminaryGroupAdvancements, enableMultipleEntries = enableMultipleEntries, enableMultipleVotes = enableMultipleVotes, featured = featured, winnerTag = winnerTag, tieTag = tieTag)

        return request<Unit, TournamentResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createTournament
     *
     * @param accountId The logged in user.
     * @param appKey The appKey the tournament is created for.
     * @param title The title of the tournament
     * @param costToPlay The number of tickets required to pay to enter the tournament
     * @param startDate The date/time to start the tournament
     * @param subType Custom string client apps can use for searching/filtering tournaments (optional)
     * @param imageAssetId The asset ID to attach to the tournament (optional)
     * @param secondsBetweenLevels The number of seconds in between the start of each tournament game/group (optional, default to 600)
     * @param secondsForTieBreaker The number of seconds to extend the round end time in the case of a tie breaker (optional, default to 600)
     * @param secondsBetweenPacks The number of seconds in between the start of each tournament round (optional, default to 86400)
     * @param maximumLevelLength The maximum number of seconds the match is expected to end at, which gets used to determine when a match should end when there is no activity (optional, default to 1800)
     * @param costToPlayType The type of ticket required to pay (optional)
     * @param minimumToPlay The minimum number of players required to sign up for the tournament to be played (optional, default to 1)
     * @param startingLimit The starting number of players for a tournament (filled with AI&#39;s) (optional)
     * @param availableLimit The maximum number of players for a tournament (currently 128 but not enforced) (optional)
     * @param description The description of the tournament (optional)
     * @param metaData External custom client defined data (optional)
     * @param audienceIds The audiences associated with the tournament (optional)
     * @param active Activate/deactivate the tournament (optional)
     * @param enableBuyBack Determines whether to allow players to buy back into a tournament (optional, default to false)
     * @param offerIds The list of offers to give as a reward beyond the tickets (optional)
     * @param offerAssetId The artwork ID to attach to the reward tickets offers (optional)
     * @param fixedReward If set then do not update the ticket reward, auto set to true if offerIds provided (optional, default to false)
     * @param splitReward Set the rules for handling the reward in case of a tie, values: EVEN split the reward evenly ALL everyone gets the full reward value FIRST first score submitted RANDOM random player who scored (optional, default to SplitReward.ALL)
     * @param allocateTickets Flag to indicate owner should receive tickets for completed missions (optional)
     * @param tournamentData A text based string that will be passed into each tournament setup to populate the content (optional)
     * @param missionType The style of tournament to build, options are: TOURNAMENT, POOLPLAY (optional, default to MissionType.MULTISTAGE)
     * @param visibility Sets the visibility flag for the tournament (optional, default to Visibility.PUBLIC)
     * @param preliminaryGroups The number of initial preliminary groups in a multi-stage tournament (this is expected to be a power of two number) (optional, default to 1)
     * @param preliminaryGroupAdvancements This determines how many people can advance per round in a preliminary group (this is a comma separated list of integers) (optional, default to "1")
     * @param enableMultipleEntries This determines if multiple submissions/entries are allowed in a multi-stage album tournament (optional, default to false)
     * @param enableMultipleVotes This determines if users are allowed to vote multiple times per group in a multi-stage album tournament (optional, default to false)
     * @param featured This determines whether the tournament is \&quot;featured\&quot; or not (optional, default to false)
     * @param winnerTag This sets what analytic tag is used when a winner is determined (optional)
     * @param tieTag This sets what analytic tag is used when a tie has occurred (optional)
     * @return RequestConfig
     */
    fun createTournamentRequestConfig(accountId: kotlin.Long, appKey: kotlin.String, title: kotlin.String, costToPlay: kotlin.Int, startDate: kotlin.Long, subType: kotlin.String?, imageAssetId: kotlin.Long?, secondsBetweenLevels: kotlin.Int?, secondsForTieBreaker: kotlin.Int?, secondsBetweenPacks: kotlin.Int?, maximumLevelLength: kotlin.Int?, costToPlayType: kotlin.String?, minimumToPlay: kotlin.Int?, startingLimit: kotlin.Int?, availableLimit: kotlin.Int?, description: kotlin.String?, metaData: kotlin.String?, audienceIds: kotlin.String?, active: kotlin.Boolean?, enableBuyBack: kotlin.Boolean?, offerIds: kotlin.String?, offerAssetId: kotlin.Long?, fixedReward: kotlin.Boolean?, splitReward: SplitRewardCreateTournament?, allocateTickets: kotlin.Boolean?, tournamentData: kotlin.String?, missionType: MissionTypeCreateTournament?, visibility: VisibilityCreateTournament?, preliminaryGroups: kotlin.Int?, preliminaryGroupAdvancements: kotlin.String?, enableMultipleEntries: kotlin.Boolean?, enableMultipleVotes: kotlin.Boolean?, featured: kotlin.Boolean?, winnerTag: kotlin.String?, tieTag: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("appKey", listOf(appKey.toString()))
                put("title", listOf(title.toString()))
                if (subType != null) {
                    put("subType", listOf(subType.toString()))
                }
                if (imageAssetId != null) {
                    put("imageAssetId", listOf(imageAssetId.toString()))
                }
                if (secondsBetweenLevels != null) {
                    put("secondsBetweenLevels", listOf(secondsBetweenLevels.toString()))
                }
                if (secondsForTieBreaker != null) {
                    put("secondsForTieBreaker", listOf(secondsForTieBreaker.toString()))
                }
                if (secondsBetweenPacks != null) {
                    put("secondsBetweenPacks", listOf(secondsBetweenPacks.toString()))
                }
                if (maximumLevelLength != null) {
                    put("maximumLevelLength", listOf(maximumLevelLength.toString()))
                }
                put("costToPlay", listOf(costToPlay.toString()))
                if (costToPlayType != null) {
                    put("costToPlayType", listOf(costToPlayType.toString()))
                }
                if (minimumToPlay != null) {
                    put("minimumToPlay", listOf(minimumToPlay.toString()))
                }
                if (startingLimit != null) {
                    put("startingLimit", listOf(startingLimit.toString()))
                }
                if (availableLimit != null) {
                    put("availableLimit", listOf(availableLimit.toString()))
                }
                if (description != null) {
                    put("description", listOf(description.toString()))
                }
                if (metaData != null) {
                    put("metaData", listOf(metaData.toString()))
                }
                put("startDate", listOf(startDate.toString()))
                if (audienceIds != null) {
                    put("audienceIds", listOf(audienceIds.toString()))
                }
                if (active != null) {
                    put("active", listOf(active.toString()))
                }
                if (enableBuyBack != null) {
                    put("enableBuyBack", listOf(enableBuyBack.toString()))
                }
                if (offerIds != null) {
                    put("offerIds", listOf(offerIds.toString()))
                }
                if (offerAssetId != null) {
                    put("offerAssetId", listOf(offerAssetId.toString()))
                }
                if (fixedReward != null) {
                    put("fixedReward", listOf(fixedReward.toString()))
                }
                if (splitReward != null) {
                    put("splitReward", listOf(splitReward.value))
                }
                if (allocateTickets != null) {
                    put("allocateTickets", listOf(allocateTickets.toString()))
                }
                if (tournamentData != null) {
                    put("tournamentData", listOf(tournamentData.toString()))
                }
                if (missionType != null) {
                    put("missionType", listOf(missionType.value))
                }
                if (visibility != null) {
                    put("visibility", listOf(visibility.value))
                }
                if (preliminaryGroups != null) {
                    put("preliminaryGroups", listOf(preliminaryGroups.toString()))
                }
                if (preliminaryGroupAdvancements != null) {
                    put("preliminaryGroupAdvancements", listOf(preliminaryGroupAdvancements.toString()))
                }
                if (enableMultipleEntries != null) {
                    put("enableMultipleEntries", listOf(enableMultipleEntries.toString()))
                }
                if (enableMultipleVotes != null) {
                    put("enableMultipleVotes", listOf(enableMultipleVotes.toString()))
                }
                if (featured != null) {
                    put("featured", listOf(featured.toString()))
                }
                if (winnerTag != null) {
                    put("winnerTag", listOf(winnerTag.toString()))
                }
                if (tieTag != null) {
                    put("tieTag", listOf(tieTag.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/tournament/create",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /tournament/delete
     * Delete Tournament
     * Delete a tournament.
     * @param accountId the id of the logged in user
     * @param missionId the id of the mission to delete
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteTournament(accountId: kotlin.Long, missionId: kotlin.Long) : SirqulResponse {
        val localVarResponse = deleteTournamentWithHttpInfo(accountId = accountId, missionId = missionId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /tournament/delete
     * Delete Tournament
     * Delete a tournament.
     * @param accountId the id of the logged in user
     * @param missionId the id of the mission to delete
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteTournamentWithHttpInfo(accountId: kotlin.Long, missionId: kotlin.Long) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = deleteTournamentRequestConfig(accountId = accountId, missionId = missionId)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteTournament
     *
     * @param accountId the id of the logged in user
     * @param missionId the id of the mission to delete
     * @return RequestConfig
     */
    fun deleteTournamentRequestConfig(accountId: kotlin.Long, missionId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("missionId", listOf(missionId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/tournament/delete",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter includeScores
     */
     enum class IncludeScoresGetTournament(val value: kotlin.String) {
         @Json(name = "ALL") ALL("ALL"),
         @Json(name = "MINE") MINE("MINE");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /tournament/get
     * Get Tournament
     * Get a tournament.
     * @param accountId The id of the logged in user
     * @param missionId The id of the mission to return (either missionId or joinCode is required) (optional)
     * @param joinCode Optional identifier for getting the tournament (either missionId or joinCode is required) (optional)
     * @param includeScores Determines which type of scores are returned. Possible values include: ALL, MINE (optional)
     * @param objectPreviewSize Determines the max number of game objects that will get returned for each game level response (optional, default to 50)
     * @return TournamentResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getTournament(accountId: kotlin.Long, missionId: kotlin.Long? = null, joinCode: kotlin.String? = null, includeScores: IncludeScoresGetTournament? = null, objectPreviewSize: kotlin.Int? = 50) : TournamentResponse {
        val localVarResponse = getTournamentWithHttpInfo(accountId = accountId, missionId = missionId, joinCode = joinCode, includeScores = includeScores, objectPreviewSize = objectPreviewSize)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TournamentResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /tournament/get
     * Get Tournament
     * Get a tournament.
     * @param accountId The id of the logged in user
     * @param missionId The id of the mission to return (either missionId or joinCode is required) (optional)
     * @param joinCode Optional identifier for getting the tournament (either missionId or joinCode is required) (optional)
     * @param includeScores Determines which type of scores are returned. Possible values include: ALL, MINE (optional)
     * @param objectPreviewSize Determines the max number of game objects that will get returned for each game level response (optional, default to 50)
     * @return ApiResponse<TournamentResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getTournamentWithHttpInfo(accountId: kotlin.Long, missionId: kotlin.Long?, joinCode: kotlin.String?, includeScores: IncludeScoresGetTournament?, objectPreviewSize: kotlin.Int?) : ApiResponse<TournamentResponse?> {
        val localVariableConfig = getTournamentRequestConfig(accountId = accountId, missionId = missionId, joinCode = joinCode, includeScores = includeScores, objectPreviewSize = objectPreviewSize)

        return request<Unit, TournamentResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getTournament
     *
     * @param accountId The id of the logged in user
     * @param missionId The id of the mission to return (either missionId or joinCode is required) (optional)
     * @param joinCode Optional identifier for getting the tournament (either missionId or joinCode is required) (optional)
     * @param includeScores Determines which type of scores are returned. Possible values include: ALL, MINE (optional)
     * @param objectPreviewSize Determines the max number of game objects that will get returned for each game level response (optional, default to 50)
     * @return RequestConfig
     */
    fun getTournamentRequestConfig(accountId: kotlin.Long, missionId: kotlin.Long?, joinCode: kotlin.String?, includeScores: IncludeScoresGetTournament?, objectPreviewSize: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                if (missionId != null) {
                    put("missionId", listOf(missionId.toString()))
                }
                if (joinCode != null) {
                    put("joinCode", listOf(joinCode.toString()))
                }
                if (includeScores != null) {
                    put("includeScores", listOf(includeScores.value))
                }
                if (objectPreviewSize != null) {
                    put("objectPreviewSize", listOf(objectPreviewSize.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/tournament/get",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter sortField
     */
     enum class SortFieldSearchObjects(val value: kotlin.String) {
         @Json(name = "ID") ID("ID"),
         @Json(name = "PLAYER_SCORE_COUNT") PLAYER_SCORE_COUNT("PLAYER_SCORE_COUNT");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /tournament/object/search
     * Search Tournament Objects
     * Search on game objects of tournaments
     * @param accountId the account ID
     * @param gameLevelId the game level id to filter results by
     * @param sortField the field to sort by (optional, default to SortField.PLAYER_SCORE_COUNT)
     * @param descending determines whether the sorted list is in descending or ascending order (optional, default to true)
     * @param start the start index for pagination (optional, default to 0)
     * @param limit the limit for pagination (optional, default to 20)
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun searchObjects(accountId: kotlin.Long, gameLevelId: kotlin.Long, sortField: SortFieldSearchObjects? = SortFieldSearchObjects.PLAYER_SCORE_COUNT, descending: kotlin.Boolean? = true, start: kotlin.Int? = 0, limit: kotlin.Int? = 20) : SirqulResponse {
        val localVarResponse = searchObjectsWithHttpInfo(accountId = accountId, gameLevelId = gameLevelId, sortField = sortField, descending = descending, start = start, limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /tournament/object/search
     * Search Tournament Objects
     * Search on game objects of tournaments
     * @param accountId the account ID
     * @param gameLevelId the game level id to filter results by
     * @param sortField the field to sort by (optional, default to SortField.PLAYER_SCORE_COUNT)
     * @param descending determines whether the sorted list is in descending or ascending order (optional, default to true)
     * @param start the start index for pagination (optional, default to 0)
     * @param limit the limit for pagination (optional, default to 20)
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun searchObjectsWithHttpInfo(accountId: kotlin.Long, gameLevelId: kotlin.Long, sortField: SortFieldSearchObjects?, descending: kotlin.Boolean?, start: kotlin.Int?, limit: kotlin.Int?) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = searchObjectsRequestConfig(accountId = accountId, gameLevelId = gameLevelId, sortField = sortField, descending = descending, start = start, limit = limit)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation searchObjects
     *
     * @param accountId the account ID
     * @param gameLevelId the game level id to filter results by
     * @param sortField the field to sort by (optional, default to SortField.PLAYER_SCORE_COUNT)
     * @param descending determines whether the sorted list is in descending or ascending order (optional, default to true)
     * @param start the start index for pagination (optional, default to 0)
     * @param limit the limit for pagination (optional, default to 20)
     * @return RequestConfig
     */
    fun searchObjectsRequestConfig(accountId: kotlin.Long, gameLevelId: kotlin.Long, sortField: SortFieldSearchObjects?, descending: kotlin.Boolean?, start: kotlin.Int?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("gameLevelId", listOf(gameLevelId.toString()))
                if (sortField != null) {
                    put("sortField", listOf(sortField.value))
                }
                if (descending != null) {
                    put("descending", listOf(descending.toString()))
                }
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/tournament/object/search",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter missionType
     */
     enum class MissionTypeSearchRounds(val value: kotlin.String) {
         @Json(name = "TOURNAMENT") TOURNAMENT("TOURNAMENT"),
         @Json(name = "POOLPLAY") POOLPLAY("POOLPLAY");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /tournament/round/search
     * Search Tournament Rounds
     * Search for the user&#39;s tournament games.
     * @param accountId the account ID
     * @param appKey the application key
     * @param status comma separated list of statuses to filter results by (optional, default to "ACCEPTED,ACTIVE")
     * @param missionType The style of tournament to search for, options are: TOURNAMENT, POOLPLAY (optional)
     * @param currentOnly search for games that are flagged current only (optional, default to true)
     * @param visibilities Filter tournament rounds by the mission visibility flag (optional, default to "PUBLIC")
     * @param start the start index for pagination (optional, default to 0)
     * @param limit the limit for pagination (optional, default to 20)
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun searchRounds(accountId: kotlin.Long, appKey: kotlin.String, status: kotlin.String? = "ACCEPTED,ACTIVE", missionType: MissionTypeSearchRounds? = null, currentOnly: kotlin.Boolean? = true, visibilities: kotlin.String? = "PUBLIC", start: kotlin.Int? = 0, limit: kotlin.Int? = 20) : SirqulResponse {
        val localVarResponse = searchRoundsWithHttpInfo(accountId = accountId, appKey = appKey, status = status, missionType = missionType, currentOnly = currentOnly, visibilities = visibilities, start = start, limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /tournament/round/search
     * Search Tournament Rounds
     * Search for the user&#39;s tournament games.
     * @param accountId the account ID
     * @param appKey the application key
     * @param status comma separated list of statuses to filter results by (optional, default to "ACCEPTED,ACTIVE")
     * @param missionType The style of tournament to search for, options are: TOURNAMENT, POOLPLAY (optional)
     * @param currentOnly search for games that are flagged current only (optional, default to true)
     * @param visibilities Filter tournament rounds by the mission visibility flag (optional, default to "PUBLIC")
     * @param start the start index for pagination (optional, default to 0)
     * @param limit the limit for pagination (optional, default to 20)
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun searchRoundsWithHttpInfo(accountId: kotlin.Long, appKey: kotlin.String, status: kotlin.String?, missionType: MissionTypeSearchRounds?, currentOnly: kotlin.Boolean?, visibilities: kotlin.String?, start: kotlin.Int?, limit: kotlin.Int?) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = searchRoundsRequestConfig(accountId = accountId, appKey = appKey, status = status, missionType = missionType, currentOnly = currentOnly, visibilities = visibilities, start = start, limit = limit)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation searchRounds
     *
     * @param accountId the account ID
     * @param appKey the application key
     * @param status comma separated list of statuses to filter results by (optional, default to "ACCEPTED,ACTIVE")
     * @param missionType The style of tournament to search for, options are: TOURNAMENT, POOLPLAY (optional)
     * @param currentOnly search for games that are flagged current only (optional, default to true)
     * @param visibilities Filter tournament rounds by the mission visibility flag (optional, default to "PUBLIC")
     * @param start the start index for pagination (optional, default to 0)
     * @param limit the limit for pagination (optional, default to 20)
     * @return RequestConfig
     */
    fun searchRoundsRequestConfig(accountId: kotlin.Long, appKey: kotlin.String, status: kotlin.String?, missionType: MissionTypeSearchRounds?, currentOnly: kotlin.Boolean?, visibilities: kotlin.String?, start: kotlin.Int?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("appKey", listOf(appKey.toString()))
                if (status != null) {
                    put("status", listOf(status.toString()))
                }
                if (missionType != null) {
                    put("missionType", listOf(missionType.value))
                }
                if (currentOnly != null) {
                    put("currentOnly", listOf(currentOnly.toString()))
                }
                if (visibilities != null) {
                    put("visibilities", listOf(visibilities.toString()))
                }
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/tournament/round/search",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter filter
     */
     enum class FilterSearchTournaments(val value: kotlin.String) {
         @Json(name = "ALL") ALL("ALL"),
         @Json(name = "UPCOMING") UPCOMING("UPCOMING"),
         @Json(name = "PAST") PAST("PAST"),
         @Json(name = "PRESENT") PRESENT("PRESENT"),
         @Json(name = "ACTIVE") ACTIVE("ACTIVE");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter sortField
     */
     enum class SortFieldSearchTournaments(val value: kotlin.String) {
         @Json(name = "ACTIVE") ACTIVE("ACTIVE"),
         @Json(name = "TITLE") TITLE("TITLE"),
         @Json(name = "DESCRIPTION") DESCRIPTION("DESCRIPTION"),
         @Json(name = "CREATED") CREATED("CREATED"),
         @Json(name = "UPDATED") UPDATED("UPDATED"),
         @Json(name = "MISSION_TYPE") MISSION_TYPE("MISSION_TYPE"),
         @Json(name = "OWNER_DISPLAY") OWNER_DISPLAY("OWNER_DISPLAY"),
         @Json(name = "START_DATE") START_DATE("START_DATE"),
         @Json(name = "END_DATE") END_DATE("END_DATE"),
         @Json(name = "STARTING_LIMIT") STARTING_LIMIT("STARTING_LIMIT"),
         @Json(name = "AVAILABLE_LIMIT") AVAILABLE_LIMIT("AVAILABLE_LIMIT"),
         @Json(name = "INVITE_COUNT") INVITE_COUNT("INVITE_COUNT"),
         @Json(name = "ACCEPTED_COUNT") ACCEPTED_COUNT("ACCEPTED_COUNT");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /tournament/search
     * Search Tournaments
     * Search for tournaments
     * @param accountId The logged in user.
     * @param appKey The application key
     * @param keyword the keyword to search tournament on (optional)
     * @param subType filter results by subType (optional)
     * @param includeInactive whether to include inactives in the search or not (optional, default to false)
     * @param missionTypes comma separated list of mission types to filter results, possbile values include: TOURNAMENT, POOLPLAY, MULTISTAGE (optional, default to "MULTISTAGE,TOURNAMENT,POOLPLAY")
     * @param filter filter tournaments by the tournament&#39;s current state (optional, default to Filter.UPCOMING)
     * @param sortField which field to sort on (optional, default to SortField.START_DATE)
     * @param descending Determines whether to return results in descending order. The default value will be true if the filter is \&quot;PAST\&quot;, otherwise the default value will be false. (optional)
     * @param visibility Comma separated list of visibility flags for search for, possible values include: PUBLIC, LISTABLE, REWARDABLE, TRIGGERABLE, PRIVATE (optional, default to "PUBLIC")
     * @param start Start the result set at some index. (optional, default to 0)
     * @param limit Limit the result to some number (optional, default to 20)
     * @return MissionShortResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun searchTournaments(accountId: kotlin.Long, appKey: kotlin.String, keyword: kotlin.String? = null, subType: kotlin.String? = null, includeInactive: kotlin.Boolean? = false, missionTypes: kotlin.String? = "MULTISTAGE,TOURNAMENT,POOLPLAY", filter: FilterSearchTournaments? = FilterSearchTournaments.UPCOMING, sortField: SortFieldSearchTournaments? = SortFieldSearchTournaments.START_DATE, descending: kotlin.Boolean? = null, visibility: kotlin.String? = "PUBLIC", start: kotlin.Int? = 0, limit: kotlin.Int? = 20) : MissionShortResponse {
        val localVarResponse = searchTournamentsWithHttpInfo(accountId = accountId, appKey = appKey, keyword = keyword, subType = subType, includeInactive = includeInactive, missionTypes = missionTypes, filter = filter, sortField = sortField, descending = descending, visibility = visibility, start = start, limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MissionShortResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /tournament/search
     * Search Tournaments
     * Search for tournaments
     * @param accountId The logged in user.
     * @param appKey The application key
     * @param keyword the keyword to search tournament on (optional)
     * @param subType filter results by subType (optional)
     * @param includeInactive whether to include inactives in the search or not (optional, default to false)
     * @param missionTypes comma separated list of mission types to filter results, possbile values include: TOURNAMENT, POOLPLAY, MULTISTAGE (optional, default to "MULTISTAGE,TOURNAMENT,POOLPLAY")
     * @param filter filter tournaments by the tournament&#39;s current state (optional, default to Filter.UPCOMING)
     * @param sortField which field to sort on (optional, default to SortField.START_DATE)
     * @param descending Determines whether to return results in descending order. The default value will be true if the filter is \&quot;PAST\&quot;, otherwise the default value will be false. (optional)
     * @param visibility Comma separated list of visibility flags for search for, possible values include: PUBLIC, LISTABLE, REWARDABLE, TRIGGERABLE, PRIVATE (optional, default to "PUBLIC")
     * @param start Start the result set at some index. (optional, default to 0)
     * @param limit Limit the result to some number (optional, default to 20)
     * @return ApiResponse<MissionShortResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun searchTournamentsWithHttpInfo(accountId: kotlin.Long, appKey: kotlin.String, keyword: kotlin.String?, subType: kotlin.String?, includeInactive: kotlin.Boolean?, missionTypes: kotlin.String?, filter: FilterSearchTournaments?, sortField: SortFieldSearchTournaments?, descending: kotlin.Boolean?, visibility: kotlin.String?, start: kotlin.Int?, limit: kotlin.Int?) : ApiResponse<MissionShortResponse?> {
        val localVariableConfig = searchTournamentsRequestConfig(accountId = accountId, appKey = appKey, keyword = keyword, subType = subType, includeInactive = includeInactive, missionTypes = missionTypes, filter = filter, sortField = sortField, descending = descending, visibility = visibility, start = start, limit = limit)

        return request<Unit, MissionShortResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation searchTournaments
     *
     * @param accountId The logged in user.
     * @param appKey The application key
     * @param keyword the keyword to search tournament on (optional)
     * @param subType filter results by subType (optional)
     * @param includeInactive whether to include inactives in the search or not (optional, default to false)
     * @param missionTypes comma separated list of mission types to filter results, possbile values include: TOURNAMENT, POOLPLAY, MULTISTAGE (optional, default to "MULTISTAGE,TOURNAMENT,POOLPLAY")
     * @param filter filter tournaments by the tournament&#39;s current state (optional, default to Filter.UPCOMING)
     * @param sortField which field to sort on (optional, default to SortField.START_DATE)
     * @param descending Determines whether to return results in descending order. The default value will be true if the filter is \&quot;PAST\&quot;, otherwise the default value will be false. (optional)
     * @param visibility Comma separated list of visibility flags for search for, possible values include: PUBLIC, LISTABLE, REWARDABLE, TRIGGERABLE, PRIVATE (optional, default to "PUBLIC")
     * @param start Start the result set at some index. (optional, default to 0)
     * @param limit Limit the result to some number (optional, default to 20)
     * @return RequestConfig
     */
    fun searchTournamentsRequestConfig(accountId: kotlin.Long, appKey: kotlin.String, keyword: kotlin.String?, subType: kotlin.String?, includeInactive: kotlin.Boolean?, missionTypes: kotlin.String?, filter: FilterSearchTournaments?, sortField: SortFieldSearchTournaments?, descending: kotlin.Boolean?, visibility: kotlin.String?, start: kotlin.Int?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("appKey", listOf(appKey.toString()))
                if (keyword != null) {
                    put("keyword", listOf(keyword.toString()))
                }
                if (subType != null) {
                    put("subType", listOf(subType.toString()))
                }
                if (includeInactive != null) {
                    put("includeInactive", listOf(includeInactive.toString()))
                }
                if (missionTypes != null) {
                    put("missionTypes", listOf(missionTypes.toString()))
                }
                if (filter != null) {
                    put("filter", listOf(filter.value))
                }
                if (sortField != null) {
                    put("sortField", listOf(sortField.value))
                }
                if (descending != null) {
                    put("descending", listOf(descending.toString()))
                }
                if (visibility != null) {
                    put("visibility", listOf(visibility.toString()))
                }
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/tournament/search",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /tournament/score
     * Submit Tournament Score
     * Submit an array of scores for a tournament match. 
     * @param accountId The logged in user account ID.
     * @param appKey The application key.
     * @param missionId The missionId to score for
     * @param gameId The gameId to score for
     * @param packId The packId to score for
     * @param scores a JSON Array of scores to submit for a tournament match &#x60;&#x60;&#x60;json [   {     \&quot;accountId\&quot;: 2,     \&quot;points\&quot;: 3   },   {     \&quot;accountId\&quot;: 1777662,     \&quot;points\&quot;: 7   } ] &#x60;&#x60;&#x60; 
     * @param gameLevelId The gameLevelId to score for (optional)
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun submitTournamentScore(accountId: kotlin.Long, appKey: kotlin.String, missionId: kotlin.Long, gameId: kotlin.Long, packId: kotlin.Long, scores: kotlin.String, gameLevelId: kotlin.Long? = null) : SirqulResponse {
        val localVarResponse = submitTournamentScoreWithHttpInfo(accountId = accountId, appKey = appKey, missionId = missionId, gameId = gameId, packId = packId, scores = scores, gameLevelId = gameLevelId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /tournament/score
     * Submit Tournament Score
     * Submit an array of scores for a tournament match. 
     * @param accountId The logged in user account ID.
     * @param appKey The application key.
     * @param missionId The missionId to score for
     * @param gameId The gameId to score for
     * @param packId The packId to score for
     * @param scores a JSON Array of scores to submit for a tournament match &#x60;&#x60;&#x60;json [   {     \&quot;accountId\&quot;: 2,     \&quot;points\&quot;: 3   },   {     \&quot;accountId\&quot;: 1777662,     \&quot;points\&quot;: 7   } ] &#x60;&#x60;&#x60; 
     * @param gameLevelId The gameLevelId to score for (optional)
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun submitTournamentScoreWithHttpInfo(accountId: kotlin.Long, appKey: kotlin.String, missionId: kotlin.Long, gameId: kotlin.Long, packId: kotlin.Long, scores: kotlin.String, gameLevelId: kotlin.Long?) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = submitTournamentScoreRequestConfig(accountId = accountId, appKey = appKey, missionId = missionId, gameId = gameId, packId = packId, scores = scores, gameLevelId = gameLevelId)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation submitTournamentScore
     *
     * @param accountId The logged in user account ID.
     * @param appKey The application key.
     * @param missionId The missionId to score for
     * @param gameId The gameId to score for
     * @param packId The packId to score for
     * @param scores a JSON Array of scores to submit for a tournament match &#x60;&#x60;&#x60;json [   {     \&quot;accountId\&quot;: 2,     \&quot;points\&quot;: 3   },   {     \&quot;accountId\&quot;: 1777662,     \&quot;points\&quot;: 7   } ] &#x60;&#x60;&#x60; 
     * @param gameLevelId The gameLevelId to score for (optional)
     * @return RequestConfig
     */
    fun submitTournamentScoreRequestConfig(accountId: kotlin.Long, appKey: kotlin.String, missionId: kotlin.Long, gameId: kotlin.Long, packId: kotlin.Long, scores: kotlin.String, gameLevelId: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("appKey", listOf(appKey.toString()))
                put("missionId", listOf(missionId.toString()))
                put("gameId", listOf(gameId.toString()))
                put("packId", listOf(packId.toString()))
                if (gameLevelId != null) {
                    put("gameLevelId", listOf(gameLevelId.toString()))
                }
                put("scores", listOf(scores.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/tournament/score",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /tournament/vote
     * Submit a vote for a multi-stage album tournament.
     * Submit a vote for a multi-stage album tournament.
     * @param accountId The logged in user.
     * @param appKey The application to target
     * @param missionId The tournament&#39;s primary id
     * @param gameObjectId The tournament game object the user wants to vote on
     * @param deviceId The unique id of the device making the request (optional) (optional)
     * @param checkIfDeviceAlreadyVoted When true, check if the device already voted to prevent duplicate votes from the same device (optional, default to false)
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun submitTournamentVote(accountId: kotlin.Long, appKey: kotlin.String, missionId: kotlin.Long, gameObjectId: kotlin.Long, deviceId: kotlin.String? = null, checkIfDeviceAlreadyVoted: kotlin.Boolean? = false) : SirqulResponse {
        val localVarResponse = submitTournamentVoteWithHttpInfo(accountId = accountId, appKey = appKey, missionId = missionId, gameObjectId = gameObjectId, deviceId = deviceId, checkIfDeviceAlreadyVoted = checkIfDeviceAlreadyVoted)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /tournament/vote
     * Submit a vote for a multi-stage album tournament.
     * Submit a vote for a multi-stage album tournament.
     * @param accountId The logged in user.
     * @param appKey The application to target
     * @param missionId The tournament&#39;s primary id
     * @param gameObjectId The tournament game object the user wants to vote on
     * @param deviceId The unique id of the device making the request (optional) (optional)
     * @param checkIfDeviceAlreadyVoted When true, check if the device already voted to prevent duplicate votes from the same device (optional, default to false)
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun submitTournamentVoteWithHttpInfo(accountId: kotlin.Long, appKey: kotlin.String, missionId: kotlin.Long, gameObjectId: kotlin.Long, deviceId: kotlin.String?, checkIfDeviceAlreadyVoted: kotlin.Boolean?) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = submitTournamentVoteRequestConfig(accountId = accountId, appKey = appKey, missionId = missionId, gameObjectId = gameObjectId, deviceId = deviceId, checkIfDeviceAlreadyVoted = checkIfDeviceAlreadyVoted)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation submitTournamentVote
     *
     * @param accountId The logged in user.
     * @param appKey The application to target
     * @param missionId The tournament&#39;s primary id
     * @param gameObjectId The tournament game object the user wants to vote on
     * @param deviceId The unique id of the device making the request (optional) (optional)
     * @param checkIfDeviceAlreadyVoted When true, check if the device already voted to prevent duplicate votes from the same device (optional, default to false)
     * @return RequestConfig
     */
    fun submitTournamentVoteRequestConfig(accountId: kotlin.Long, appKey: kotlin.String, missionId: kotlin.Long, gameObjectId: kotlin.Long, deviceId: kotlin.String?, checkIfDeviceAlreadyVoted: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                put("accountId", listOf(accountId.toString()))
                put("appKey", listOf(appKey.toString()))
                put("missionId", listOf(missionId.toString()))
                put("gameObjectId", listOf(gameObjectId.toString()))
                if (checkIfDeviceAlreadyVoted != null) {
                    put("checkIfDeviceAlreadyVoted", listOf(checkIfDeviceAlreadyVoted.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/tournament/vote",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /tournament/substitute
     * Substitute Tournament Player
     * Service to replace the user&#39;s opponent in the current level - pack - mission with an AI account.
     * @param accountId the id of the logged in user
     * @param missionId the id of the mission
     * @param packId the id of the pack
     * @param gameLevelId the id of the game level
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun substituteTournamentPlayer(accountId: kotlin.Long, missionId: kotlin.Long, packId: kotlin.Long, gameLevelId: kotlin.Long) : SirqulResponse {
        val localVarResponse = substituteTournamentPlayerWithHttpInfo(accountId = accountId, missionId = missionId, packId = packId, gameLevelId = gameLevelId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /tournament/substitute
     * Substitute Tournament Player
     * Service to replace the user&#39;s opponent in the current level - pack - mission with an AI account.
     * @param accountId the id of the logged in user
     * @param missionId the id of the mission
     * @param packId the id of the pack
     * @param gameLevelId the id of the game level
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun substituteTournamentPlayerWithHttpInfo(accountId: kotlin.Long, missionId: kotlin.Long, packId: kotlin.Long, gameLevelId: kotlin.Long) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = substituteTournamentPlayerRequestConfig(accountId = accountId, missionId = missionId, packId = packId, gameLevelId = gameLevelId)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation substituteTournamentPlayer
     *
     * @param accountId the id of the logged in user
     * @param missionId the id of the mission
     * @param packId the id of the pack
     * @param gameLevelId the id of the game level
     * @return RequestConfig
     */
    fun substituteTournamentPlayerRequestConfig(accountId: kotlin.Long, missionId: kotlin.Long, packId: kotlin.Long, gameLevelId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("missionId", listOf(missionId.toString()))
                put("packId", listOf(packId.toString()))
                put("gameLevelId", listOf(gameLevelId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/tournament/substitute",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter splitReward
     */
     enum class SplitRewardUpdateTournament(val value: kotlin.String) {
         @Json(name = "EVEN") EVEN("EVEN"),
         @Json(name = "ALL") ALL("ALL"),
         @Json(name = "FIRST") FIRST("FIRST"),
         @Json(name = "RANDOM") RANDOM("RANDOM");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter visibility
     */
     enum class VisibilityUpdateTournament(val value: kotlin.String) {
         @Json(name = "PUBLIC") PUBLIC("PUBLIC"),
         @Json(name = "LISTABLE") LISTABLE("LISTABLE"),
         @Json(name = "REWARDABLE") REWARDABLE("REWARDABLE"),
         @Json(name = "TRIGGERABLE") TRIGGERABLE("TRIGGERABLE"),
         @Json(name = "PRIVATE") PRIVATE("PRIVATE");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * POST /tournament/update
     * Update Tournament
     * Update a tournament.
     * @param accountId The logged in user.
     * @param missionId The mission/tournament to update
     * @param title The title of the tournament (optional)
     * @param subType Custom string client apps can use for searching/filtering missions (optional)
     * @param imageAssetId The asset ID to attach to the tournament (optional)
     * @param secondsBetweenLevels The number of seconds in between the start of each tournament game (optional)
     * @param secondsForTieBreaker The number of seconds to extend the round end time in the case of a tie breaker (optional)
     * @param secondsBetweenPacks The number of seconds in between the start of each tournament round (optional)
     * @param maximumLevelLength The maximum number of seconds the match is expected to end at, which gets used to determine when a match should end when there is no activity (optional)
     * @param costToPlay The number of tickets required to pay to enter the tournament (optional)
     * @param costToPlayType The type of ticket required to pay (optional)
     * @param minimumToPlay The minimum number of players required to sign up for the tournament to be played (optional)
     * @param startingLimit The starting number of players for a tournament (filled with AI&#39;s) (optional)
     * @param availableLimit The maximum number of players for a tournament (currently 128 but not enforced) (optional)
     * @param description The description of the tournament (optional)
     * @param metaData External custom client defined data (optional)
     * @param startDate The date/time to start the tournament (optional)
     * @param audienceIds The audiences associated with the tournament (optional)
     * @param active Activate/deactivate the mission (optional)
     * @param enableBuyBack Determines whether to allow players to buy back into a tournament (optional)
     * @param offerIds The list of offers to give as a reward beyond the tickets (optional)
     * @param offerAssetId The artwork ID to attach to the reward offer (optional)
     * @param fixedReward If set then do not update the ticket reward, auto set to true if offerIds provided (optional)
     * @param splitReward Set the rules for handling the reward in case of a tie, values: EVEN split the reward evenly ALL everyone gets the full reward value FIRST first score submitted RANDOM random player who scored (optional)
     * @param allocateTickets Flag to indicate owner should receive tickets for completed missions (optional)
     * @param tournamentData A text based string that will be passed into each tournament setup to populate the content (optional)
     * @param visibility Sets the visibility flag for the tournament (optional)
     * @param preliminaryGroups The number of initial preliminary groups in a multi-stage tournament (this is expected to be a power of two number) (optional)
     * @param preliminaryGroupAdvancements This determines how many people can advance per round in a preliminary group (this is a comma separated list of integers) (optional)
     * @param enableMultipleEntries This determines if multiple submissions/entries are allowed in a multi-stage album tournament (optional)
     * @param enableMultipleVotes This determines if users are allowed to vote multiple times per group in a multi-stage album tournament (optional)
     * @param featured This determines whether the tournament is \&quot;featured\&quot; or not (optional)
     * @param winnerTag This sets what analytic tag is used when a winner is determined (optional)
     * @param tieTag This sets what analytic tag is used when a winner is determined (optional)
     * @return TournamentResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updateTournament(accountId: kotlin.Long, missionId: kotlin.Long, title: kotlin.String? = null, subType: kotlin.String? = null, imageAssetId: kotlin.Long? = null, secondsBetweenLevels: kotlin.Int? = null, secondsForTieBreaker: kotlin.Int? = null, secondsBetweenPacks: kotlin.Int? = null, maximumLevelLength: kotlin.Int? = null, costToPlay: kotlin.Int? = null, costToPlayType: kotlin.String? = null, minimumToPlay: kotlin.Int? = null, startingLimit: kotlin.Int? = null, availableLimit: kotlin.Int? = null, description: kotlin.String? = null, metaData: kotlin.String? = null, startDate: kotlin.Long? = null, audienceIds: kotlin.String? = null, active: kotlin.Boolean? = null, enableBuyBack: kotlin.Boolean? = null, offerIds: kotlin.String? = null, offerAssetId: kotlin.Long? = null, fixedReward: kotlin.Boolean? = null, splitReward: SplitRewardUpdateTournament? = null, allocateTickets: kotlin.Boolean? = null, tournamentData: kotlin.String? = null, visibility: VisibilityUpdateTournament? = null, preliminaryGroups: kotlin.Int? = null, preliminaryGroupAdvancements: kotlin.String? = null, enableMultipleEntries: kotlin.Boolean? = null, enableMultipleVotes: kotlin.Boolean? = null, featured: kotlin.Boolean? = null, winnerTag: kotlin.String? = null, tieTag: kotlin.String? = null) : TournamentResponse {
        val localVarResponse = updateTournamentWithHttpInfo(accountId = accountId, missionId = missionId, title = title, subType = subType, imageAssetId = imageAssetId, secondsBetweenLevels = secondsBetweenLevels, secondsForTieBreaker = secondsForTieBreaker, secondsBetweenPacks = secondsBetweenPacks, maximumLevelLength = maximumLevelLength, costToPlay = costToPlay, costToPlayType = costToPlayType, minimumToPlay = minimumToPlay, startingLimit = startingLimit, availableLimit = availableLimit, description = description, metaData = metaData, startDate = startDate, audienceIds = audienceIds, active = active, enableBuyBack = enableBuyBack, offerIds = offerIds, offerAssetId = offerAssetId, fixedReward = fixedReward, splitReward = splitReward, allocateTickets = allocateTickets, tournamentData = tournamentData, visibility = visibility, preliminaryGroups = preliminaryGroups, preliminaryGroupAdvancements = preliminaryGroupAdvancements, enableMultipleEntries = enableMultipleEntries, enableMultipleVotes = enableMultipleVotes, featured = featured, winnerTag = winnerTag, tieTag = tieTag)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TournamentResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /tournament/update
     * Update Tournament
     * Update a tournament.
     * @param accountId The logged in user.
     * @param missionId The mission/tournament to update
     * @param title The title of the tournament (optional)
     * @param subType Custom string client apps can use for searching/filtering missions (optional)
     * @param imageAssetId The asset ID to attach to the tournament (optional)
     * @param secondsBetweenLevels The number of seconds in between the start of each tournament game (optional)
     * @param secondsForTieBreaker The number of seconds to extend the round end time in the case of a tie breaker (optional)
     * @param secondsBetweenPacks The number of seconds in between the start of each tournament round (optional)
     * @param maximumLevelLength The maximum number of seconds the match is expected to end at, which gets used to determine when a match should end when there is no activity (optional)
     * @param costToPlay The number of tickets required to pay to enter the tournament (optional)
     * @param costToPlayType The type of ticket required to pay (optional)
     * @param minimumToPlay The minimum number of players required to sign up for the tournament to be played (optional)
     * @param startingLimit The starting number of players for a tournament (filled with AI&#39;s) (optional)
     * @param availableLimit The maximum number of players for a tournament (currently 128 but not enforced) (optional)
     * @param description The description of the tournament (optional)
     * @param metaData External custom client defined data (optional)
     * @param startDate The date/time to start the tournament (optional)
     * @param audienceIds The audiences associated with the tournament (optional)
     * @param active Activate/deactivate the mission (optional)
     * @param enableBuyBack Determines whether to allow players to buy back into a tournament (optional)
     * @param offerIds The list of offers to give as a reward beyond the tickets (optional)
     * @param offerAssetId The artwork ID to attach to the reward offer (optional)
     * @param fixedReward If set then do not update the ticket reward, auto set to true if offerIds provided (optional)
     * @param splitReward Set the rules for handling the reward in case of a tie, values: EVEN split the reward evenly ALL everyone gets the full reward value FIRST first score submitted RANDOM random player who scored (optional)
     * @param allocateTickets Flag to indicate owner should receive tickets for completed missions (optional)
     * @param tournamentData A text based string that will be passed into each tournament setup to populate the content (optional)
     * @param visibility Sets the visibility flag for the tournament (optional)
     * @param preliminaryGroups The number of initial preliminary groups in a multi-stage tournament (this is expected to be a power of two number) (optional)
     * @param preliminaryGroupAdvancements This determines how many people can advance per round in a preliminary group (this is a comma separated list of integers) (optional)
     * @param enableMultipleEntries This determines if multiple submissions/entries are allowed in a multi-stage album tournament (optional)
     * @param enableMultipleVotes This determines if users are allowed to vote multiple times per group in a multi-stage album tournament (optional)
     * @param featured This determines whether the tournament is \&quot;featured\&quot; or not (optional)
     * @param winnerTag This sets what analytic tag is used when a winner is determined (optional)
     * @param tieTag This sets what analytic tag is used when a winner is determined (optional)
     * @return ApiResponse<TournamentResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun updateTournamentWithHttpInfo(accountId: kotlin.Long, missionId: kotlin.Long, title: kotlin.String?, subType: kotlin.String?, imageAssetId: kotlin.Long?, secondsBetweenLevels: kotlin.Int?, secondsForTieBreaker: kotlin.Int?, secondsBetweenPacks: kotlin.Int?, maximumLevelLength: kotlin.Int?, costToPlay: kotlin.Int?, costToPlayType: kotlin.String?, minimumToPlay: kotlin.Int?, startingLimit: kotlin.Int?, availableLimit: kotlin.Int?, description: kotlin.String?, metaData: kotlin.String?, startDate: kotlin.Long?, audienceIds: kotlin.String?, active: kotlin.Boolean?, enableBuyBack: kotlin.Boolean?, offerIds: kotlin.String?, offerAssetId: kotlin.Long?, fixedReward: kotlin.Boolean?, splitReward: SplitRewardUpdateTournament?, allocateTickets: kotlin.Boolean?, tournamentData: kotlin.String?, visibility: VisibilityUpdateTournament?, preliminaryGroups: kotlin.Int?, preliminaryGroupAdvancements: kotlin.String?, enableMultipleEntries: kotlin.Boolean?, enableMultipleVotes: kotlin.Boolean?, featured: kotlin.Boolean?, winnerTag: kotlin.String?, tieTag: kotlin.String?) : ApiResponse<TournamentResponse?> {
        val localVariableConfig = updateTournamentRequestConfig(accountId = accountId, missionId = missionId, title = title, subType = subType, imageAssetId = imageAssetId, secondsBetweenLevels = secondsBetweenLevels, secondsForTieBreaker = secondsForTieBreaker, secondsBetweenPacks = secondsBetweenPacks, maximumLevelLength = maximumLevelLength, costToPlay = costToPlay, costToPlayType = costToPlayType, minimumToPlay = minimumToPlay, startingLimit = startingLimit, availableLimit = availableLimit, description = description, metaData = metaData, startDate = startDate, audienceIds = audienceIds, active = active, enableBuyBack = enableBuyBack, offerIds = offerIds, offerAssetId = offerAssetId, fixedReward = fixedReward, splitReward = splitReward, allocateTickets = allocateTickets, tournamentData = tournamentData, visibility = visibility, preliminaryGroups = preliminaryGroups, preliminaryGroupAdvancements = preliminaryGroupAdvancements, enableMultipleEntries = enableMultipleEntries, enableMultipleVotes = enableMultipleVotes, featured = featured, winnerTag = winnerTag, tieTag = tieTag)

        return request<Unit, TournamentResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateTournament
     *
     * @param accountId The logged in user.
     * @param missionId The mission/tournament to update
     * @param title The title of the tournament (optional)
     * @param subType Custom string client apps can use for searching/filtering missions (optional)
     * @param imageAssetId The asset ID to attach to the tournament (optional)
     * @param secondsBetweenLevels The number of seconds in between the start of each tournament game (optional)
     * @param secondsForTieBreaker The number of seconds to extend the round end time in the case of a tie breaker (optional)
     * @param secondsBetweenPacks The number of seconds in between the start of each tournament round (optional)
     * @param maximumLevelLength The maximum number of seconds the match is expected to end at, which gets used to determine when a match should end when there is no activity (optional)
     * @param costToPlay The number of tickets required to pay to enter the tournament (optional)
     * @param costToPlayType The type of ticket required to pay (optional)
     * @param minimumToPlay The minimum number of players required to sign up for the tournament to be played (optional)
     * @param startingLimit The starting number of players for a tournament (filled with AI&#39;s) (optional)
     * @param availableLimit The maximum number of players for a tournament (currently 128 but not enforced) (optional)
     * @param description The description of the tournament (optional)
     * @param metaData External custom client defined data (optional)
     * @param startDate The date/time to start the tournament (optional)
     * @param audienceIds The audiences associated with the tournament (optional)
     * @param active Activate/deactivate the mission (optional)
     * @param enableBuyBack Determines whether to allow players to buy back into a tournament (optional)
     * @param offerIds The list of offers to give as a reward beyond the tickets (optional)
     * @param offerAssetId The artwork ID to attach to the reward offer (optional)
     * @param fixedReward If set then do not update the ticket reward, auto set to true if offerIds provided (optional)
     * @param splitReward Set the rules for handling the reward in case of a tie, values: EVEN split the reward evenly ALL everyone gets the full reward value FIRST first score submitted RANDOM random player who scored (optional)
     * @param allocateTickets Flag to indicate owner should receive tickets for completed missions (optional)
     * @param tournamentData A text based string that will be passed into each tournament setup to populate the content (optional)
     * @param visibility Sets the visibility flag for the tournament (optional)
     * @param preliminaryGroups The number of initial preliminary groups in a multi-stage tournament (this is expected to be a power of two number) (optional)
     * @param preliminaryGroupAdvancements This determines how many people can advance per round in a preliminary group (this is a comma separated list of integers) (optional)
     * @param enableMultipleEntries This determines if multiple submissions/entries are allowed in a multi-stage album tournament (optional)
     * @param enableMultipleVotes This determines if users are allowed to vote multiple times per group in a multi-stage album tournament (optional)
     * @param featured This determines whether the tournament is \&quot;featured\&quot; or not (optional)
     * @param winnerTag This sets what analytic tag is used when a winner is determined (optional)
     * @param tieTag This sets what analytic tag is used when a winner is determined (optional)
     * @return RequestConfig
     */
    fun updateTournamentRequestConfig(accountId: kotlin.Long, missionId: kotlin.Long, title: kotlin.String?, subType: kotlin.String?, imageAssetId: kotlin.Long?, secondsBetweenLevels: kotlin.Int?, secondsForTieBreaker: kotlin.Int?, secondsBetweenPacks: kotlin.Int?, maximumLevelLength: kotlin.Int?, costToPlay: kotlin.Int?, costToPlayType: kotlin.String?, minimumToPlay: kotlin.Int?, startingLimit: kotlin.Int?, availableLimit: kotlin.Int?, description: kotlin.String?, metaData: kotlin.String?, startDate: kotlin.Long?, audienceIds: kotlin.String?, active: kotlin.Boolean?, enableBuyBack: kotlin.Boolean?, offerIds: kotlin.String?, offerAssetId: kotlin.Long?, fixedReward: kotlin.Boolean?, splitReward: SplitRewardUpdateTournament?, allocateTickets: kotlin.Boolean?, tournamentData: kotlin.String?, visibility: VisibilityUpdateTournament?, preliminaryGroups: kotlin.Int?, preliminaryGroupAdvancements: kotlin.String?, enableMultipleEntries: kotlin.Boolean?, enableMultipleVotes: kotlin.Boolean?, featured: kotlin.Boolean?, winnerTag: kotlin.String?, tieTag: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("missionId", listOf(missionId.toString()))
                if (title != null) {
                    put("title", listOf(title.toString()))
                }
                if (subType != null) {
                    put("subType", listOf(subType.toString()))
                }
                if (imageAssetId != null) {
                    put("imageAssetId", listOf(imageAssetId.toString()))
                }
                if (secondsBetweenLevels != null) {
                    put("secondsBetweenLevels", listOf(secondsBetweenLevels.toString()))
                }
                if (secondsForTieBreaker != null) {
                    put("secondsForTieBreaker", listOf(secondsForTieBreaker.toString()))
                }
                if (secondsBetweenPacks != null) {
                    put("secondsBetweenPacks", listOf(secondsBetweenPacks.toString()))
                }
                if (maximumLevelLength != null) {
                    put("maximumLevelLength", listOf(maximumLevelLength.toString()))
                }
                if (costToPlay != null) {
                    put("costToPlay", listOf(costToPlay.toString()))
                }
                if (costToPlayType != null) {
                    put("costToPlayType", listOf(costToPlayType.toString()))
                }
                if (minimumToPlay != null) {
                    put("minimumToPlay", listOf(minimumToPlay.toString()))
                }
                if (startingLimit != null) {
                    put("startingLimit", listOf(startingLimit.toString()))
                }
                if (availableLimit != null) {
                    put("availableLimit", listOf(availableLimit.toString()))
                }
                if (description != null) {
                    put("description", listOf(description.toString()))
                }
                if (metaData != null) {
                    put("metaData", listOf(metaData.toString()))
                }
                if (startDate != null) {
                    put("startDate", listOf(startDate.toString()))
                }
                if (audienceIds != null) {
                    put("audienceIds", listOf(audienceIds.toString()))
                }
                if (active != null) {
                    put("active", listOf(active.toString()))
                }
                if (enableBuyBack != null) {
                    put("enableBuyBack", listOf(enableBuyBack.toString()))
                }
                if (offerIds != null) {
                    put("offerIds", listOf(offerIds.toString()))
                }
                if (offerAssetId != null) {
                    put("offerAssetId", listOf(offerAssetId.toString()))
                }
                if (fixedReward != null) {
                    put("fixedReward", listOf(fixedReward.toString()))
                }
                if (splitReward != null) {
                    put("splitReward", listOf(splitReward.value))
                }
                if (allocateTickets != null) {
                    put("allocateTickets", listOf(allocateTickets.toString()))
                }
                if (tournamentData != null) {
                    put("tournamentData", listOf(tournamentData.toString()))
                }
                if (visibility != null) {
                    put("visibility", listOf(visibility.value))
                }
                if (preliminaryGroups != null) {
                    put("preliminaryGroups", listOf(preliminaryGroups.toString()))
                }
                if (preliminaryGroupAdvancements != null) {
                    put("preliminaryGroupAdvancements", listOf(preliminaryGroupAdvancements.toString()))
                }
                if (enableMultipleEntries != null) {
                    put("enableMultipleEntries", listOf(enableMultipleEntries.toString()))
                }
                if (enableMultipleVotes != null) {
                    put("enableMultipleVotes", listOf(enableMultipleVotes.toString()))
                }
                if (featured != null) {
                    put("featured", listOf(featured.toString()))
                }
                if (winnerTag != null) {
                    put("winnerTag", listOf(winnerTag.toString()))
                }
                if (tieTag != null) {
                    put("tieTag", listOf(tieTag.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/tournament/update",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
