/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import org.openapitools.client.models.OfferTransactionResponse
import org.openapitools.client.models.SirqulResponse

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

open class WalletApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://dev.sirqul.com/api/3.18")
        }
    }

    /**
     * POST /wallet/create
     * Create Wallet Offers
     * Adds offers to the wallet
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param offerId The id of the offer being added (offerId or offeLocationId required) (optional)
     * @param offerLocationId The id of the offer location being added (offerId or offeLocationId required) (optional)
     * @param offerCart A JSON list of offers to purchase. &#x60;&#x60;&#x60;json [   {     \&quot;offerId\&quot;: 123,     \&quot;offerLocationId\&quot;: 234,     \&quot;quantity\&quot;: 2   },   {     \&quot;offerId\&quot;: 456,     \&quot;offerLocationId\&quot;: 567,     \&quot;quantity\&quot;: 1   } ] &#x60;&#x60;&#x60;  (optional)
     * @param promoCode The promoCode (optional)
     * @param currencyType Determines the method of purchasing offer. CASH &#x3D; use card on file, POINTS &#x3D; use points, TICKETS &#x3D; use tickets (optional, default to "CASH")
     * @param usePoints Sets the currencyType to POINTS (optional)
     * @param metaData External custom client defined data (optional)
     * @param appKey The application requesting the purchase, required when currencyType is TICKETS (optional)
     * @param status Custom status value to change to (0 or 1 for redeem, 5 or 6 for membership) (optional)
     * @return kotlin.collections.List<OfferTransactionResponse>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createOfferTransaction(deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, offerId: kotlin.Long? = null, offerLocationId: kotlin.Long? = null, offerCart: kotlin.String? = null, promoCode: kotlin.String? = null, currencyType: kotlin.String? = "CASH", usePoints: kotlin.Boolean? = null, metaData: kotlin.String? = null, appKey: kotlin.String? = null, status: kotlin.Int? = null) : kotlin.collections.List<OfferTransactionResponse> {
        val localVarResponse = createOfferTransactionWithHttpInfo(deviceId = deviceId, accountId = accountId, offerId = offerId, offerLocationId = offerLocationId, offerCart = offerCart, promoCode = promoCode, currencyType = currencyType, usePoints = usePoints, metaData = metaData, appKey = appKey, status = status)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<OfferTransactionResponse>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /wallet/create
     * Create Wallet Offers
     * Adds offers to the wallet
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param offerId The id of the offer being added (offerId or offeLocationId required) (optional)
     * @param offerLocationId The id of the offer location being added (offerId or offeLocationId required) (optional)
     * @param offerCart A JSON list of offers to purchase. &#x60;&#x60;&#x60;json [   {     \&quot;offerId\&quot;: 123,     \&quot;offerLocationId\&quot;: 234,     \&quot;quantity\&quot;: 2   },   {     \&quot;offerId\&quot;: 456,     \&quot;offerLocationId\&quot;: 567,     \&quot;quantity\&quot;: 1   } ] &#x60;&#x60;&#x60;  (optional)
     * @param promoCode The promoCode (optional)
     * @param currencyType Determines the method of purchasing offer. CASH &#x3D; use card on file, POINTS &#x3D; use points, TICKETS &#x3D; use tickets (optional, default to "CASH")
     * @param usePoints Sets the currencyType to POINTS (optional)
     * @param metaData External custom client defined data (optional)
     * @param appKey The application requesting the purchase, required when currencyType is TICKETS (optional)
     * @param status Custom status value to change to (0 or 1 for redeem, 5 or 6 for membership) (optional)
     * @return ApiResponse<kotlin.collections.List<OfferTransactionResponse>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createOfferTransactionWithHttpInfo(deviceId: kotlin.String?, accountId: kotlin.Long?, offerId: kotlin.Long?, offerLocationId: kotlin.Long?, offerCart: kotlin.String?, promoCode: kotlin.String?, currencyType: kotlin.String?, usePoints: kotlin.Boolean?, metaData: kotlin.String?, appKey: kotlin.String?, status: kotlin.Int?) : ApiResponse<kotlin.collections.List<OfferTransactionResponse>?> {
        val localVariableConfig = createOfferTransactionRequestConfig(deviceId = deviceId, accountId = accountId, offerId = offerId, offerLocationId = offerLocationId, offerCart = offerCart, promoCode = promoCode, currencyType = currencyType, usePoints = usePoints, metaData = metaData, appKey = appKey, status = status)

        return request<Unit, kotlin.collections.List<OfferTransactionResponse>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createOfferTransaction
     *
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param offerId The id of the offer being added (offerId or offeLocationId required) (optional)
     * @param offerLocationId The id of the offer location being added (offerId or offeLocationId required) (optional)
     * @param offerCart A JSON list of offers to purchase. &#x60;&#x60;&#x60;json [   {     \&quot;offerId\&quot;: 123,     \&quot;offerLocationId\&quot;: 234,     \&quot;quantity\&quot;: 2   },   {     \&quot;offerId\&quot;: 456,     \&quot;offerLocationId\&quot;: 567,     \&quot;quantity\&quot;: 1   } ] &#x60;&#x60;&#x60;  (optional)
     * @param promoCode The promoCode (optional)
     * @param currencyType Determines the method of purchasing offer. CASH &#x3D; use card on file, POINTS &#x3D; use points, TICKETS &#x3D; use tickets (optional, default to "CASH")
     * @param usePoints Sets the currencyType to POINTS (optional)
     * @param metaData External custom client defined data (optional)
     * @param appKey The application requesting the purchase, required when currencyType is TICKETS (optional)
     * @param status Custom status value to change to (0 or 1 for redeem, 5 or 6 for membership) (optional)
     * @return RequestConfig
     */
    fun createOfferTransactionRequestConfig(deviceId: kotlin.String?, accountId: kotlin.Long?, offerId: kotlin.Long?, offerLocationId: kotlin.Long?, offerCart: kotlin.String?, promoCode: kotlin.String?, currencyType: kotlin.String?, usePoints: kotlin.Boolean?, metaData: kotlin.String?, appKey: kotlin.String?, status: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (offerId != null) {
                    put("offerId", listOf(offerId.toString()))
                }
                if (offerLocationId != null) {
                    put("offerLocationId", listOf(offerLocationId.toString()))
                }
                if (offerCart != null) {
                    put("offerCart", listOf(offerCart.toString()))
                }
                if (promoCode != null) {
                    put("promoCode", listOf(promoCode.toString()))
                }
                if (currencyType != null) {
                    put("currencyType", listOf(currencyType.toString()))
                }
                if (usePoints != null) {
                    put("usePoints", listOf(usePoints.toString()))
                }
                if (metaData != null) {
                    put("metaData", listOf(metaData.toString()))
                }
                if (appKey != null) {
                    put("appKey", listOf(appKey.toString()))
                }
                if (status != null) {
                    put("status", listOf(status.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/wallet/create",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /wallet/delete
     * Delete Wallet Offer
     * Removes the transaction from the wallet by setting the deleted date to the current date/time.  Requires a valid account and transactionId.
     * @param transactionId The offer transaction id to remove
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteOfferTransaction(transactionId: kotlin.Long, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null) : SirqulResponse {
        val localVarResponse = deleteOfferTransactionWithHttpInfo(transactionId = transactionId, deviceId = deviceId, accountId = accountId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /wallet/delete
     * Delete Wallet Offer
     * Removes the transaction from the wallet by setting the deleted date to the current date/time.  Requires a valid account and transactionId.
     * @param transactionId The offer transaction id to remove
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteOfferTransactionWithHttpInfo(transactionId: kotlin.Long, deviceId: kotlin.String?, accountId: kotlin.Long?) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = deleteOfferTransactionRequestConfig(transactionId = transactionId, deviceId = deviceId, accountId = accountId)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteOfferTransaction
     *
     * @param transactionId The offer transaction id to remove
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @return RequestConfig
     */
    fun deleteOfferTransactionRequestConfig(transactionId: kotlin.Long, deviceId: kotlin.String?, accountId: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                put("transactionId", listOf(transactionId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/wallet/delete",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /wallet/get
     * Get Wallet Offer
     * 
     * @param transactionId The offer transaction id to get details of
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param includeMission If true then include mission data, false to not include (optional, default to false)
     * @param latitude The latitude location of the user (optional)
     * @param longitude The latitude location of the user (optional)
     * @param returnFullResponse Determines whether to return a detailed version of the response (optional, default to true)
     * @return OfferTransactionResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getOfferTransaction(transactionId: kotlin.Long, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, includeMission: kotlin.Boolean? = false, latitude: kotlin.Double? = null, longitude: kotlin.Double? = null, returnFullResponse: kotlin.Boolean? = true) : OfferTransactionResponse {
        val localVarResponse = getOfferTransactionWithHttpInfo(transactionId = transactionId, deviceId = deviceId, accountId = accountId, includeMission = includeMission, latitude = latitude, longitude = longitude, returnFullResponse = returnFullResponse)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OfferTransactionResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /wallet/get
     * Get Wallet Offer
     * 
     * @param transactionId The offer transaction id to get details of
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param includeMission If true then include mission data, false to not include (optional, default to false)
     * @param latitude The latitude location of the user (optional)
     * @param longitude The latitude location of the user (optional)
     * @param returnFullResponse Determines whether to return a detailed version of the response (optional, default to true)
     * @return ApiResponse<OfferTransactionResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getOfferTransactionWithHttpInfo(transactionId: kotlin.Long, deviceId: kotlin.String?, accountId: kotlin.Long?, includeMission: kotlin.Boolean?, latitude: kotlin.Double?, longitude: kotlin.Double?, returnFullResponse: kotlin.Boolean?) : ApiResponse<OfferTransactionResponse?> {
        val localVariableConfig = getOfferTransactionRequestConfig(transactionId = transactionId, deviceId = deviceId, accountId = accountId, includeMission = includeMission, latitude = latitude, longitude = longitude, returnFullResponse = returnFullResponse)

        return request<Unit, OfferTransactionResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getOfferTransaction
     *
     * @param transactionId The offer transaction id to get details of
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param includeMission If true then include mission data, false to not include (optional, default to false)
     * @param latitude The latitude location of the user (optional)
     * @param longitude The latitude location of the user (optional)
     * @param returnFullResponse Determines whether to return a detailed version of the response (optional, default to true)
     * @return RequestConfig
     */
    fun getOfferTransactionRequestConfig(transactionId: kotlin.Long, deviceId: kotlin.String?, accountId: kotlin.Long?, includeMission: kotlin.Boolean?, latitude: kotlin.Double?, longitude: kotlin.Double?, returnFullResponse: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                put("transactionId", listOf(transactionId.toString()))
                if (includeMission != null) {
                    put("includeMission", listOf(includeMission.toString()))
                }
                if (latitude != null) {
                    put("latitude", listOf(latitude.toString()))
                }
                if (longitude != null) {
                    put("longitude", listOf(longitude.toString()))
                }
                if (returnFullResponse != null) {
                    put("returnFullResponse", listOf(returnFullResponse.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/wallet/get",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /wallet/preview
     * Preview Wallet Offers
     * Preview the final cost of a transaction without charging the user
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param offerId The id of the offer being added (offerId or offeLocationId required) (optional)
     * @param offerLocationId The id of the offer location being added (offerId or offeLocationId required) (optional)
     * @param offerCart A JSON list of offers to purchase. (optional)
     * @param promoCode The promoCode (optional)
     * @param currencyType Determines the method of purchasing offer. CASH &#x3D; use card on file, POINTS &#x3D; use points, TICKETS &#x3D; use tickets (optional, default to "CASH")
     * @param usePoints Sets the currencyType to POINTS (optional)
     * @param metaData External custom client defined data (optional)
     * @param appKey The application requesting the purchase, required when currencyType is TICKETS (optional)
     * @return kotlin.collections.List<OfferTransactionResponse>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun previewOfferTransaction(deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, offerId: kotlin.Long? = null, offerLocationId: kotlin.Long? = null, offerCart: kotlin.String? = null, promoCode: kotlin.String? = null, currencyType: kotlin.String? = "CASH", usePoints: kotlin.Boolean? = null, metaData: kotlin.String? = null, appKey: kotlin.String? = null) : kotlin.collections.List<OfferTransactionResponse> {
        val localVarResponse = previewOfferTransactionWithHttpInfo(deviceId = deviceId, accountId = accountId, offerId = offerId, offerLocationId = offerLocationId, offerCart = offerCart, promoCode = promoCode, currencyType = currencyType, usePoints = usePoints, metaData = metaData, appKey = appKey)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<OfferTransactionResponse>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /wallet/preview
     * Preview Wallet Offers
     * Preview the final cost of a transaction without charging the user
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param offerId The id of the offer being added (offerId or offeLocationId required) (optional)
     * @param offerLocationId The id of the offer location being added (offerId or offeLocationId required) (optional)
     * @param offerCart A JSON list of offers to purchase. (optional)
     * @param promoCode The promoCode (optional)
     * @param currencyType Determines the method of purchasing offer. CASH &#x3D; use card on file, POINTS &#x3D; use points, TICKETS &#x3D; use tickets (optional, default to "CASH")
     * @param usePoints Sets the currencyType to POINTS (optional)
     * @param metaData External custom client defined data (optional)
     * @param appKey The application requesting the purchase, required when currencyType is TICKETS (optional)
     * @return ApiResponse<kotlin.collections.List<OfferTransactionResponse>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun previewOfferTransactionWithHttpInfo(deviceId: kotlin.String?, accountId: kotlin.Long?, offerId: kotlin.Long?, offerLocationId: kotlin.Long?, offerCart: kotlin.String?, promoCode: kotlin.String?, currencyType: kotlin.String?, usePoints: kotlin.Boolean?, metaData: kotlin.String?, appKey: kotlin.String?) : ApiResponse<kotlin.collections.List<OfferTransactionResponse>?> {
        val localVariableConfig = previewOfferTransactionRequestConfig(deviceId = deviceId, accountId = accountId, offerId = offerId, offerLocationId = offerLocationId, offerCart = offerCart, promoCode = promoCode, currencyType = currencyType, usePoints = usePoints, metaData = metaData, appKey = appKey)

        return request<Unit, kotlin.collections.List<OfferTransactionResponse>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation previewOfferTransaction
     *
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param offerId The id of the offer being added (offerId or offeLocationId required) (optional)
     * @param offerLocationId The id of the offer location being added (offerId or offeLocationId required) (optional)
     * @param offerCart A JSON list of offers to purchase. (optional)
     * @param promoCode The promoCode (optional)
     * @param currencyType Determines the method of purchasing offer. CASH &#x3D; use card on file, POINTS &#x3D; use points, TICKETS &#x3D; use tickets (optional, default to "CASH")
     * @param usePoints Sets the currencyType to POINTS (optional)
     * @param metaData External custom client defined data (optional)
     * @param appKey The application requesting the purchase, required when currencyType is TICKETS (optional)
     * @return RequestConfig
     */
    fun previewOfferTransactionRequestConfig(deviceId: kotlin.String?, accountId: kotlin.Long?, offerId: kotlin.Long?, offerLocationId: kotlin.Long?, offerCart: kotlin.String?, promoCode: kotlin.String?, currencyType: kotlin.String?, usePoints: kotlin.Boolean?, metaData: kotlin.String?, appKey: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (offerId != null) {
                    put("offerId", listOf(offerId.toString()))
                }
                if (offerLocationId != null) {
                    put("offerLocationId", listOf(offerLocationId.toString()))
                }
                if (offerCart != null) {
                    put("offerCart", listOf(offerCart.toString()))
                }
                if (promoCode != null) {
                    put("promoCode", listOf(promoCode.toString()))
                }
                if (currencyType != null) {
                    put("currencyType", listOf(currencyType.toString()))
                }
                if (usePoints != null) {
                    put("usePoints", listOf(usePoints.toString()))
                }
                if (metaData != null) {
                    put("metaData", listOf(metaData.toString()))
                }
                if (appKey != null) {
                    put("appKey", listOf(appKey.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/wallet/preview",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter offerType
     */
     enum class OfferTypeSearchOfferTransactions(val value: kotlin.String) {
         @Json(name = "VOUCHER") VOUCHER("VOUCHER"),
         @Json(name = "COUPON") COUPON("COUPON"),
         @Json(name = "PRODUCT") PRODUCT("PRODUCT"),
         @Json(name = "MEDIA") MEDIA("MEDIA"),
         @Json(name = "EVENT") EVENT("EVENT"),
         @Json(name = "DEVICE") DEVICE("DEVICE");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter sortField
     */
     enum class SortFieldSearchOfferTransactions(val value: kotlin.String) {
         @Json(name = "ID") ID("ID"),
         @Json(name = "CREATED") CREATED("CREATED"),
         @Json(name = "UPDATED") UPDATED("UPDATED"),
         @Json(name = "DELETED") DELETED("DELETED"),
         @Json(name = "SEARCH_TAGS") SEARCH_TAGS("SEARCH_TAGS"),
         @Json(name = "ACTIVE") ACTIVE("ACTIVE"),
         @Json(name = "ACTIVATED") ACTIVATED("ACTIVATED"),
         @Json(name = "EXPIRES") EXPIRES("EXPIRES"),
         @Json(name = "TITLE") TITLE("TITLE"),
         @Json(name = "SUBTITLE") SUBTITLE("SUBTITLE"),
         @Json(name = "DETAILS") DETAILS("DETAILS"),
         @Json(name = "OFFER_TYPE") OFFER_TYPE("OFFER_TYPE"),
         @Json(name = "SPECIAL_OFFER_TYPE") SPECIAL_OFFER_TYPE("SPECIAL_OFFER_TYPE"),
         @Json(name = "OFFER_VISIBILITY") OFFER_VISIBILITY("OFFER_VISIBILITY"),
         @Json(name = "REDEEMABLE_START") REDEEMABLE_START("REDEEMABLE_START"),
         @Json(name = "REDEEMABLE_END") REDEEMABLE_END("REDEEMABLE_END"),
         @Json(name = "CUSTOMER_ID") CUSTOMER_ID("CUSTOMER_ID"),
         @Json(name = "CUSTOMER_DISPLAY") CUSTOMER_DISPLAY("CUSTOMER_DISPLAY"),
         @Json(name = "RETAILER_ID") RETAILER_ID("RETAILER_ID"),
         @Json(name = "RETAILER_NAME") RETAILER_NAME("RETAILER_NAME"),
         @Json(name = "RETAILER_LOCATION_ID") RETAILER_LOCATION_ID("RETAILER_LOCATION_ID"),
         @Json(name = "RETAILER_LOCATION_NAME") RETAILER_LOCATION_NAME("RETAILER_LOCATION_NAME"),
         @Json(name = "BILLABLE_ENTITY_ID") BILLABLE_ENTITY_ID("BILLABLE_ENTITY_ID"),
         @Json(name = "BILLABLE_ENTITY_NAME") BILLABLE_ENTITY_NAME("BILLABLE_ENTITY_NAME"),
         @Json(name = "RESPONSIBLE_DISPLAY") RESPONSIBLE_DISPLAY("RESPONSIBLE_DISPLAY");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /wallet/search
     * Search Wallet Offers
     * Search on active offers currently in the user&#39;s wallet, or past offers the user has already redeemed.
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param keyword The keyword to search for (optional)
     * @param retailerId Filter results for this retailer (optional)
     * @param retailerIds Filter results for a list of retailers (optional)
     * @param retailerLocationId Filter results for this retailer location (optional)
     * @param retailerLocationIds Filter results for a list of retailer locations (optional)
     * @param excludeRetailerLocationIds Filter results to exclude retailer locations (optional)
     * @param offerId Filter results for this offer (optional)
     * @param offerIds Filter results for a list of offer (optional)
     * @param offerLocationId Filter results for this offer location (optional)
     * @param offerLocationIds Filter results for a list of offer locations (optional)
     * @param offerType Filter results to return a specific offer type (optional)
     * @param offerTypes Filter results to return specific offer types (optional)
     * @param specialOfferType Filter results to return a specific special offer type (optional)
     * @param specialOfferTypes Filter results to return specific special offer types (optional)
     * @param categoryIds Category Ids (optional)
     * @param filterIds Filter Ids (optional)
     * @param offerAudienceIds Offer Audience Ids (optional)
     * @param sortField Determines what to sort the results by (optional, default to SortField.CREATED)
     * @param descending Determines whether the results are in descending order (optional, default to true)
     * @param start The start index for pagination (optional, default to 0)
     * @param limit The limit for pagination (optional, default to 20)
     * @param latitude The latitude location of the user (optional)
     * @param longitude The latitude location of the user (optional)
     * @param redeemableStartDate Filter results by the offer redeemable date (optional)
     * @param redeemableEndDate Filter results by the offer redeemable date (optional)
     * @param filterByParentOffer Apply params to offer&#39;s parent (optional, default to false)
     * @param startedSince Filter results by the offer start date (optional)
     * @param startedBefore Filter results by the offer start date (optional)
     * @param endedSince Filter results by the offer end date (optional)
     * @param endedBefore Filter results by the offer end date (optional)
     * @param redeemed If true return redeemed transactions (status 2), otherwise return active transactions (status 0 or 1) (optional, default to false)
     * @param statuses Custom status value to change to (0 or 1 for redeem, 5 or 6 for membership) (optional)
     * @param reservationsOnly Returns only reservation transactions if true (optional, default to false)
     * @param activeOnly Active Only (optional, default to false)
     * @param returnFullResponse Determines whether to return a detailed version of the response (optional, default to false)
     * @param recurringStartedSince Filter results by the recurring billing start date (optional)
     * @param recurringStartedBefore Filter results by the recurring billing start date (optional)
     * @param recurringExpirationSince Filter results by the recurring billing expiration date (optional)
     * @param recurringExpirationBefore Filter results by the recurring billing expiration date (optional)
     * @return kotlin.collections.List<OfferTransactionResponse>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun searchOfferTransactions(deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, keyword: kotlin.String? = null, retailerId: kotlin.Long? = null, retailerIds: kotlin.String? = null, retailerLocationId: kotlin.Long? = null, retailerLocationIds: kotlin.String? = null, excludeRetailerLocationIds: kotlin.String? = null, offerId: kotlin.Long? = null, offerIds: kotlin.String? = null, offerLocationId: kotlin.Long? = null, offerLocationIds: kotlin.String? = null, offerType: OfferTypeSearchOfferTransactions? = null, offerTypes: kotlin.String? = null, specialOfferType: kotlin.String? = null, specialOfferTypes: kotlin.String? = null, categoryIds: kotlin.String? = null, filterIds: kotlin.String? = null, offerAudienceIds: kotlin.String? = null, sortField: SortFieldSearchOfferTransactions? = SortFieldSearchOfferTransactions.CREATED, descending: kotlin.Boolean? = true, start: kotlin.Int? = 0, limit: kotlin.Int? = 20, latitude: kotlin.Double? = null, longitude: kotlin.Double? = null, redeemableStartDate: kotlin.Long? = null, redeemableEndDate: kotlin.Long? = null, filterByParentOffer: kotlin.Boolean? = false, startedSince: kotlin.Long? = null, startedBefore: kotlin.Long? = null, endedSince: kotlin.Long? = null, endedBefore: kotlin.Long? = null, redeemed: kotlin.Boolean? = false, statuses: kotlin.String? = null, reservationsOnly: kotlin.Boolean? = false, activeOnly: kotlin.Boolean? = false, returnFullResponse: kotlin.Boolean? = false, recurringStartedSince: kotlin.Long? = null, recurringStartedBefore: kotlin.Long? = null, recurringExpirationSince: kotlin.Long? = null, recurringExpirationBefore: kotlin.Long? = null) : kotlin.collections.List<OfferTransactionResponse> {
        val localVarResponse = searchOfferTransactionsWithHttpInfo(deviceId = deviceId, accountId = accountId, keyword = keyword, retailerId = retailerId, retailerIds = retailerIds, retailerLocationId = retailerLocationId, retailerLocationIds = retailerLocationIds, excludeRetailerLocationIds = excludeRetailerLocationIds, offerId = offerId, offerIds = offerIds, offerLocationId = offerLocationId, offerLocationIds = offerLocationIds, offerType = offerType, offerTypes = offerTypes, specialOfferType = specialOfferType, specialOfferTypes = specialOfferTypes, categoryIds = categoryIds, filterIds = filterIds, offerAudienceIds = offerAudienceIds, sortField = sortField, descending = descending, start = start, limit = limit, latitude = latitude, longitude = longitude, redeemableStartDate = redeemableStartDate, redeemableEndDate = redeemableEndDate, filterByParentOffer = filterByParentOffer, startedSince = startedSince, startedBefore = startedBefore, endedSince = endedSince, endedBefore = endedBefore, redeemed = redeemed, statuses = statuses, reservationsOnly = reservationsOnly, activeOnly = activeOnly, returnFullResponse = returnFullResponse, recurringStartedSince = recurringStartedSince, recurringStartedBefore = recurringStartedBefore, recurringExpirationSince = recurringExpirationSince, recurringExpirationBefore = recurringExpirationBefore)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<OfferTransactionResponse>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /wallet/search
     * Search Wallet Offers
     * Search on active offers currently in the user&#39;s wallet, or past offers the user has already redeemed.
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param keyword The keyword to search for (optional)
     * @param retailerId Filter results for this retailer (optional)
     * @param retailerIds Filter results for a list of retailers (optional)
     * @param retailerLocationId Filter results for this retailer location (optional)
     * @param retailerLocationIds Filter results for a list of retailer locations (optional)
     * @param excludeRetailerLocationIds Filter results to exclude retailer locations (optional)
     * @param offerId Filter results for this offer (optional)
     * @param offerIds Filter results for a list of offer (optional)
     * @param offerLocationId Filter results for this offer location (optional)
     * @param offerLocationIds Filter results for a list of offer locations (optional)
     * @param offerType Filter results to return a specific offer type (optional)
     * @param offerTypes Filter results to return specific offer types (optional)
     * @param specialOfferType Filter results to return a specific special offer type (optional)
     * @param specialOfferTypes Filter results to return specific special offer types (optional)
     * @param categoryIds Category Ids (optional)
     * @param filterIds Filter Ids (optional)
     * @param offerAudienceIds Offer Audience Ids (optional)
     * @param sortField Determines what to sort the results by (optional, default to SortField.CREATED)
     * @param descending Determines whether the results are in descending order (optional, default to true)
     * @param start The start index for pagination (optional, default to 0)
     * @param limit The limit for pagination (optional, default to 20)
     * @param latitude The latitude location of the user (optional)
     * @param longitude The latitude location of the user (optional)
     * @param redeemableStartDate Filter results by the offer redeemable date (optional)
     * @param redeemableEndDate Filter results by the offer redeemable date (optional)
     * @param filterByParentOffer Apply params to offer&#39;s parent (optional, default to false)
     * @param startedSince Filter results by the offer start date (optional)
     * @param startedBefore Filter results by the offer start date (optional)
     * @param endedSince Filter results by the offer end date (optional)
     * @param endedBefore Filter results by the offer end date (optional)
     * @param redeemed If true return redeemed transactions (status 2), otherwise return active transactions (status 0 or 1) (optional, default to false)
     * @param statuses Custom status value to change to (0 or 1 for redeem, 5 or 6 for membership) (optional)
     * @param reservationsOnly Returns only reservation transactions if true (optional, default to false)
     * @param activeOnly Active Only (optional, default to false)
     * @param returnFullResponse Determines whether to return a detailed version of the response (optional, default to false)
     * @param recurringStartedSince Filter results by the recurring billing start date (optional)
     * @param recurringStartedBefore Filter results by the recurring billing start date (optional)
     * @param recurringExpirationSince Filter results by the recurring billing expiration date (optional)
     * @param recurringExpirationBefore Filter results by the recurring billing expiration date (optional)
     * @return ApiResponse<kotlin.collections.List<OfferTransactionResponse>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun searchOfferTransactionsWithHttpInfo(deviceId: kotlin.String?, accountId: kotlin.Long?, keyword: kotlin.String?, retailerId: kotlin.Long?, retailerIds: kotlin.String?, retailerLocationId: kotlin.Long?, retailerLocationIds: kotlin.String?, excludeRetailerLocationIds: kotlin.String?, offerId: kotlin.Long?, offerIds: kotlin.String?, offerLocationId: kotlin.Long?, offerLocationIds: kotlin.String?, offerType: OfferTypeSearchOfferTransactions?, offerTypes: kotlin.String?, specialOfferType: kotlin.String?, specialOfferTypes: kotlin.String?, categoryIds: kotlin.String?, filterIds: kotlin.String?, offerAudienceIds: kotlin.String?, sortField: SortFieldSearchOfferTransactions?, descending: kotlin.Boolean?, start: kotlin.Int?, limit: kotlin.Int?, latitude: kotlin.Double?, longitude: kotlin.Double?, redeemableStartDate: kotlin.Long?, redeemableEndDate: kotlin.Long?, filterByParentOffer: kotlin.Boolean?, startedSince: kotlin.Long?, startedBefore: kotlin.Long?, endedSince: kotlin.Long?, endedBefore: kotlin.Long?, redeemed: kotlin.Boolean?, statuses: kotlin.String?, reservationsOnly: kotlin.Boolean?, activeOnly: kotlin.Boolean?, returnFullResponse: kotlin.Boolean?, recurringStartedSince: kotlin.Long?, recurringStartedBefore: kotlin.Long?, recurringExpirationSince: kotlin.Long?, recurringExpirationBefore: kotlin.Long?) : ApiResponse<kotlin.collections.List<OfferTransactionResponse>?> {
        val localVariableConfig = searchOfferTransactionsRequestConfig(deviceId = deviceId, accountId = accountId, keyword = keyword, retailerId = retailerId, retailerIds = retailerIds, retailerLocationId = retailerLocationId, retailerLocationIds = retailerLocationIds, excludeRetailerLocationIds = excludeRetailerLocationIds, offerId = offerId, offerIds = offerIds, offerLocationId = offerLocationId, offerLocationIds = offerLocationIds, offerType = offerType, offerTypes = offerTypes, specialOfferType = specialOfferType, specialOfferTypes = specialOfferTypes, categoryIds = categoryIds, filterIds = filterIds, offerAudienceIds = offerAudienceIds, sortField = sortField, descending = descending, start = start, limit = limit, latitude = latitude, longitude = longitude, redeemableStartDate = redeemableStartDate, redeemableEndDate = redeemableEndDate, filterByParentOffer = filterByParentOffer, startedSince = startedSince, startedBefore = startedBefore, endedSince = endedSince, endedBefore = endedBefore, redeemed = redeemed, statuses = statuses, reservationsOnly = reservationsOnly, activeOnly = activeOnly, returnFullResponse = returnFullResponse, recurringStartedSince = recurringStartedSince, recurringStartedBefore = recurringStartedBefore, recurringExpirationSince = recurringExpirationSince, recurringExpirationBefore = recurringExpirationBefore)

        return request<Unit, kotlin.collections.List<OfferTransactionResponse>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation searchOfferTransactions
     *
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param keyword The keyword to search for (optional)
     * @param retailerId Filter results for this retailer (optional)
     * @param retailerIds Filter results for a list of retailers (optional)
     * @param retailerLocationId Filter results for this retailer location (optional)
     * @param retailerLocationIds Filter results for a list of retailer locations (optional)
     * @param excludeRetailerLocationIds Filter results to exclude retailer locations (optional)
     * @param offerId Filter results for this offer (optional)
     * @param offerIds Filter results for a list of offer (optional)
     * @param offerLocationId Filter results for this offer location (optional)
     * @param offerLocationIds Filter results for a list of offer locations (optional)
     * @param offerType Filter results to return a specific offer type (optional)
     * @param offerTypes Filter results to return specific offer types (optional)
     * @param specialOfferType Filter results to return a specific special offer type (optional)
     * @param specialOfferTypes Filter results to return specific special offer types (optional)
     * @param categoryIds Category Ids (optional)
     * @param filterIds Filter Ids (optional)
     * @param offerAudienceIds Offer Audience Ids (optional)
     * @param sortField Determines what to sort the results by (optional, default to SortField.CREATED)
     * @param descending Determines whether the results are in descending order (optional, default to true)
     * @param start The start index for pagination (optional, default to 0)
     * @param limit The limit for pagination (optional, default to 20)
     * @param latitude The latitude location of the user (optional)
     * @param longitude The latitude location of the user (optional)
     * @param redeemableStartDate Filter results by the offer redeemable date (optional)
     * @param redeemableEndDate Filter results by the offer redeemable date (optional)
     * @param filterByParentOffer Apply params to offer&#39;s parent (optional, default to false)
     * @param startedSince Filter results by the offer start date (optional)
     * @param startedBefore Filter results by the offer start date (optional)
     * @param endedSince Filter results by the offer end date (optional)
     * @param endedBefore Filter results by the offer end date (optional)
     * @param redeemed If true return redeemed transactions (status 2), otherwise return active transactions (status 0 or 1) (optional, default to false)
     * @param statuses Custom status value to change to (0 or 1 for redeem, 5 or 6 for membership) (optional)
     * @param reservationsOnly Returns only reservation transactions if true (optional, default to false)
     * @param activeOnly Active Only (optional, default to false)
     * @param returnFullResponse Determines whether to return a detailed version of the response (optional, default to false)
     * @param recurringStartedSince Filter results by the recurring billing start date (optional)
     * @param recurringStartedBefore Filter results by the recurring billing start date (optional)
     * @param recurringExpirationSince Filter results by the recurring billing expiration date (optional)
     * @param recurringExpirationBefore Filter results by the recurring billing expiration date (optional)
     * @return RequestConfig
     */
    fun searchOfferTransactionsRequestConfig(deviceId: kotlin.String?, accountId: kotlin.Long?, keyword: kotlin.String?, retailerId: kotlin.Long?, retailerIds: kotlin.String?, retailerLocationId: kotlin.Long?, retailerLocationIds: kotlin.String?, excludeRetailerLocationIds: kotlin.String?, offerId: kotlin.Long?, offerIds: kotlin.String?, offerLocationId: kotlin.Long?, offerLocationIds: kotlin.String?, offerType: OfferTypeSearchOfferTransactions?, offerTypes: kotlin.String?, specialOfferType: kotlin.String?, specialOfferTypes: kotlin.String?, categoryIds: kotlin.String?, filterIds: kotlin.String?, offerAudienceIds: kotlin.String?, sortField: SortFieldSearchOfferTransactions?, descending: kotlin.Boolean?, start: kotlin.Int?, limit: kotlin.Int?, latitude: kotlin.Double?, longitude: kotlin.Double?, redeemableStartDate: kotlin.Long?, redeemableEndDate: kotlin.Long?, filterByParentOffer: kotlin.Boolean?, startedSince: kotlin.Long?, startedBefore: kotlin.Long?, endedSince: kotlin.Long?, endedBefore: kotlin.Long?, redeemed: kotlin.Boolean?, statuses: kotlin.String?, reservationsOnly: kotlin.Boolean?, activeOnly: kotlin.Boolean?, returnFullResponse: kotlin.Boolean?, recurringStartedSince: kotlin.Long?, recurringStartedBefore: kotlin.Long?, recurringExpirationSince: kotlin.Long?, recurringExpirationBefore: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (keyword != null) {
                    put("keyword", listOf(keyword.toString()))
                }
                if (retailerId != null) {
                    put("retailerId", listOf(retailerId.toString()))
                }
                if (retailerIds != null) {
                    put("retailerIds", listOf(retailerIds.toString()))
                }
                if (retailerLocationId != null) {
                    put("retailerLocationId", listOf(retailerLocationId.toString()))
                }
                if (retailerLocationIds != null) {
                    put("retailerLocationIds", listOf(retailerLocationIds.toString()))
                }
                if (excludeRetailerLocationIds != null) {
                    put("excludeRetailerLocationIds", listOf(excludeRetailerLocationIds.toString()))
                }
                if (offerId != null) {
                    put("offerId", listOf(offerId.toString()))
                }
                if (offerIds != null) {
                    put("offerIds", listOf(offerIds.toString()))
                }
                if (offerLocationId != null) {
                    put("offerLocationId", listOf(offerLocationId.toString()))
                }
                if (offerLocationIds != null) {
                    put("offerLocationIds", listOf(offerLocationIds.toString()))
                }
                if (offerType != null) {
                    put("offerType", listOf(offerType.value))
                }
                if (offerTypes != null) {
                    put("offerTypes", listOf(offerTypes.toString()))
                }
                if (specialOfferType != null) {
                    put("specialOfferType", listOf(specialOfferType.toString()))
                }
                if (specialOfferTypes != null) {
                    put("specialOfferTypes", listOf(specialOfferTypes.toString()))
                }
                if (categoryIds != null) {
                    put("categoryIds", listOf(categoryIds.toString()))
                }
                if (filterIds != null) {
                    put("filterIds", listOf(filterIds.toString()))
                }
                if (offerAudienceIds != null) {
                    put("offerAudienceIds", listOf(offerAudienceIds.toString()))
                }
                if (sortField != null) {
                    put("sortField", listOf(sortField.value))
                }
                if (descending != null) {
                    put("descending", listOf(descending.toString()))
                }
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (latitude != null) {
                    put("latitude", listOf(latitude.toString()))
                }
                if (longitude != null) {
                    put("longitude", listOf(longitude.toString()))
                }
                if (redeemableStartDate != null) {
                    put("redeemableStartDate", listOf(redeemableStartDate.toString()))
                }
                if (redeemableEndDate != null) {
                    put("redeemableEndDate", listOf(redeemableEndDate.toString()))
                }
                if (filterByParentOffer != null) {
                    put("filterByParentOffer", listOf(filterByParentOffer.toString()))
                }
                if (startedSince != null) {
                    put("startedSince", listOf(startedSince.toString()))
                }
                if (startedBefore != null) {
                    put("startedBefore", listOf(startedBefore.toString()))
                }
                if (endedSince != null) {
                    put("endedSince", listOf(endedSince.toString()))
                }
                if (endedBefore != null) {
                    put("endedBefore", listOf(endedBefore.toString()))
                }
                if (redeemed != null) {
                    put("redeemed", listOf(redeemed.toString()))
                }
                if (statuses != null) {
                    put("statuses", listOf(statuses.toString()))
                }
                if (reservationsOnly != null) {
                    put("reservationsOnly", listOf(reservationsOnly.toString()))
                }
                if (activeOnly != null) {
                    put("activeOnly", listOf(activeOnly.toString()))
                }
                if (returnFullResponse != null) {
                    put("returnFullResponse", listOf(returnFullResponse.toString()))
                }
                if (recurringStartedSince != null) {
                    put("recurringStartedSince", listOf(recurringStartedSince.toString()))
                }
                if (recurringStartedBefore != null) {
                    put("recurringStartedBefore", listOf(recurringStartedBefore.toString()))
                }
                if (recurringExpirationSince != null) {
                    put("recurringExpirationSince", listOf(recurringExpirationSince.toString()))
                }
                if (recurringExpirationBefore != null) {
                    put("recurringExpirationBefore", listOf(recurringExpirationBefore.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/wallet/search",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /wallet/update
     * Update Wallet Offer
     * Update offer status. The status values are: 0 - not redeemable, 1 - redeemable.  Not redeemable means the customer has received the offer but has not decided to use (or print) it yet.  Until they choose to do this the merchant cannot redeem the offer (has not been given permission yet).   Redeemable means the customer has chosen to use the offer and wishes to redeem it.  Redeemed means the merchant has accepted the offer and the given the customer its value, then marked it a used in the system.  This status change is handled by a merchant end point.
     * @param transactionId The offer transaction id to remove
     * @param status The status value to change to (0 or 1)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param offerLocationId Offer Location Id (optional)
     * @param currencyType Currency Type (optional, default to "CASH")
     * @param usePoints Use Points (optional)
     * @param appKey App Key (optional)
     * @param latitude The latitude location of the user (optional)
     * @param longitude The latitude location of the user (optional)
     * @param metaData External custom client defined data (optional)
     * @param returnFullResponse Determines whether to return a detailed version of the response (optional, default to false)
     * @param exceptionMembershipOfferIds Exception Offers, transaction audiences of these offers won&#39;t be removed out of the account when up (optional)
     * @return OfferTransactionResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updateOfferTransaction(transactionId: kotlin.Long, status: kotlin.Int, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, offerLocationId: kotlin.Long? = null, currencyType: kotlin.String? = "CASH", usePoints: kotlin.Boolean? = null, appKey: kotlin.String? = null, latitude: kotlin.Double? = null, longitude: kotlin.Double? = null, metaData: kotlin.String? = null, returnFullResponse: kotlin.Boolean? = false, exceptionMembershipOfferIds: kotlin.String? = null) : OfferTransactionResponse {
        val localVarResponse = updateOfferTransactionWithHttpInfo(transactionId = transactionId, status = status, deviceId = deviceId, accountId = accountId, offerLocationId = offerLocationId, currencyType = currencyType, usePoints = usePoints, appKey = appKey, latitude = latitude, longitude = longitude, metaData = metaData, returnFullResponse = returnFullResponse, exceptionMembershipOfferIds = exceptionMembershipOfferIds)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OfferTransactionResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /wallet/update
     * Update Wallet Offer
     * Update offer status. The status values are: 0 - not redeemable, 1 - redeemable.  Not redeemable means the customer has received the offer but has not decided to use (or print) it yet.  Until they choose to do this the merchant cannot redeem the offer (has not been given permission yet).   Redeemable means the customer has chosen to use the offer and wishes to redeem it.  Redeemed means the merchant has accepted the offer and the given the customer its value, then marked it a used in the system.  This status change is handled by a merchant end point.
     * @param transactionId The offer transaction id to remove
     * @param status The status value to change to (0 or 1)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param offerLocationId Offer Location Id (optional)
     * @param currencyType Currency Type (optional, default to "CASH")
     * @param usePoints Use Points (optional)
     * @param appKey App Key (optional)
     * @param latitude The latitude location of the user (optional)
     * @param longitude The latitude location of the user (optional)
     * @param metaData External custom client defined data (optional)
     * @param returnFullResponse Determines whether to return a detailed version of the response (optional, default to false)
     * @param exceptionMembershipOfferIds Exception Offers, transaction audiences of these offers won&#39;t be removed out of the account when up (optional)
     * @return ApiResponse<OfferTransactionResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun updateOfferTransactionWithHttpInfo(transactionId: kotlin.Long, status: kotlin.Int, deviceId: kotlin.String?, accountId: kotlin.Long?, offerLocationId: kotlin.Long?, currencyType: kotlin.String?, usePoints: kotlin.Boolean?, appKey: kotlin.String?, latitude: kotlin.Double?, longitude: kotlin.Double?, metaData: kotlin.String?, returnFullResponse: kotlin.Boolean?, exceptionMembershipOfferIds: kotlin.String?) : ApiResponse<OfferTransactionResponse?> {
        val localVariableConfig = updateOfferTransactionRequestConfig(transactionId = transactionId, status = status, deviceId = deviceId, accountId = accountId, offerLocationId = offerLocationId, currencyType = currencyType, usePoints = usePoints, appKey = appKey, latitude = latitude, longitude = longitude, metaData = metaData, returnFullResponse = returnFullResponse, exceptionMembershipOfferIds = exceptionMembershipOfferIds)

        return request<Unit, OfferTransactionResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateOfferTransaction
     *
     * @param transactionId The offer transaction id to remove
     * @param status The status value to change to (0 or 1)
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param offerLocationId Offer Location Id (optional)
     * @param currencyType Currency Type (optional, default to "CASH")
     * @param usePoints Use Points (optional)
     * @param appKey App Key (optional)
     * @param latitude The latitude location of the user (optional)
     * @param longitude The latitude location of the user (optional)
     * @param metaData External custom client defined data (optional)
     * @param returnFullResponse Determines whether to return a detailed version of the response (optional, default to false)
     * @param exceptionMembershipOfferIds Exception Offers, transaction audiences of these offers won&#39;t be removed out of the account when up (optional)
     * @return RequestConfig
     */
    fun updateOfferTransactionRequestConfig(transactionId: kotlin.Long, status: kotlin.Int, deviceId: kotlin.String?, accountId: kotlin.Long?, offerLocationId: kotlin.Long?, currencyType: kotlin.String?, usePoints: kotlin.Boolean?, appKey: kotlin.String?, latitude: kotlin.Double?, longitude: kotlin.Double?, metaData: kotlin.String?, returnFullResponse: kotlin.Boolean?, exceptionMembershipOfferIds: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                put("transactionId", listOf(transactionId.toString()))
                if (offerLocationId != null) {
                    put("offerLocationId", listOf(offerLocationId.toString()))
                }
                if (currencyType != null) {
                    put("currencyType", listOf(currencyType.toString()))
                }
                if (usePoints != null) {
                    put("usePoints", listOf(usePoints.toString()))
                }
                if (appKey != null) {
                    put("appKey", listOf(appKey.toString()))
                }
                put("status", listOf(status.toString()))
                if (latitude != null) {
                    put("latitude", listOf(latitude.toString()))
                }
                if (longitude != null) {
                    put("longitude", listOf(longitude.toString()))
                }
                if (metaData != null) {
                    put("metaData", listOf(metaData.toString()))
                }
                if (returnFullResponse != null) {
                    put("returnFullResponse", listOf(returnFullResponse.toString()))
                }
                if (exceptionMembershipOfferIds != null) {
                    put("exceptionMembershipOfferIds", listOf(exceptionMembershipOfferIds.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/wallet/update",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
