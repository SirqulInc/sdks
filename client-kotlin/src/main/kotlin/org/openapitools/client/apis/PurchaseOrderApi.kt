/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import org.openapitools.client.models.OrderResponse
import org.openapitools.client.models.SirqulResponse

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

open class PurchaseOrderApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://dev.sirqul.com/api/3.18")
        }
    }

    /**
     * enum for parameter currencyType
     */
     enum class CurrencyTypeCreateOrder(val value: kotlin.String) {
         @Json(name = "VOID") VOID("VOID"),
         @Json(name = "CASH") CASH("CASH"),
         @Json(name = "POINTS") POINTS("POINTS"),
         @Json(name = "TICKETS") TICKETS("TICKETS"),
         @Json(name = "REFUND") REFUND("REFUND"),
         @Json(name = "CREDIT") CREDIT("CREDIT"),
         @Json(name = "RELOAD") RELOAD("RELOAD");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * POST /order/create
     * Create Order
     * Creates a new purchase with some number of items associated with it. The purchase is added to the order that was created
     * @param appKey The application requesting the purchase
     * @param cart &#x60;&#x60;&#x60;json [   { \&quot;orderItemType\&quot;: \&quot;OFFER\&quot;, \&quot;orderItemId\&quot;: 234, \&quot;orderCustomType\&quot;: \&quot;OfferLocation\&quot;, \&quot;orderCustomId\&quot;: 123, \&quot;retailerLocationId\&quot;: 1234, \&quot;quantity\&quot;: 2 },   { \&quot;orderItemType\&quot;: \&quot;OFFER\&quot;, \&quot;orderItemId\&quot;: 235, \&quot;quantity\&quot;: 2 },   { \&quot;orderItemType\&quot;: \&quot;CUSTOM\&quot;, \&quot;amount\&quot;: 10.50, \&quot;orderCustomType\&quot;: \&quot;ServiceFee\&quot; },   { \&quot;orderItemType\&quot;: \&quot;CUSTOM\&quot;, \&quot;amount\&quot;: 25.10, \&quot;quantity\&quot;: 2, \&quot;orderCustomType\&quot;: \&quot;Hat\&quot;, \&quot;orderCustomId\&quot;: 123 } ] &#x60;&#x60;&#x60; 
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param description A description of the purchase (optional)
     * @param currencyType Determines the method of purchasing offer.  * VOID: used for when there is no payment involved (ie. for updating the status of a purchase order)  * CASH: use card on file  * POINTS: use account balance  * TICKETS: use tickets  * REFUND: not allowed for a create, requires a paymentTransactionId.  * CREDIT: add to the account balance  * RELOAD: charge a credit card then add to the account balance   (optional, default to CurrencyType.CASH)
     * @param paymentMethodId Use a specific payment method (CASH), if not provided use default (optional)
     * @param externalOrderId Store identifier from external system (optional)
     * @param externalPaymentId Store identifier from external system (optional)
     * @param remoteRefType Remote Reference type (optional)
     * @param externalDate External Date (optional)
     * @param promoCode The Promo Code (optional)
     * @return OrderResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createOrder(appKey: kotlin.String, cart: kotlin.String, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, description: kotlin.String? = null, currencyType: CurrencyTypeCreateOrder? = CurrencyTypeCreateOrder.CASH, paymentMethodId: kotlin.Long? = null, externalOrderId: kotlin.String? = null, externalPaymentId: kotlin.String? = null, remoteRefType: kotlin.String? = null, externalDate: kotlin.Long? = null, promoCode: kotlin.String? = null) : OrderResponse {
        val localVarResponse = createOrderWithHttpInfo(appKey = appKey, cart = cart, deviceId = deviceId, accountId = accountId, description = description, currencyType = currencyType, paymentMethodId = paymentMethodId, externalOrderId = externalOrderId, externalPaymentId = externalPaymentId, remoteRefType = remoteRefType, externalDate = externalDate, promoCode = promoCode)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OrderResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /order/create
     * Create Order
     * Creates a new purchase with some number of items associated with it. The purchase is added to the order that was created
     * @param appKey The application requesting the purchase
     * @param cart &#x60;&#x60;&#x60;json [   { \&quot;orderItemType\&quot;: \&quot;OFFER\&quot;, \&quot;orderItemId\&quot;: 234, \&quot;orderCustomType\&quot;: \&quot;OfferLocation\&quot;, \&quot;orderCustomId\&quot;: 123, \&quot;retailerLocationId\&quot;: 1234, \&quot;quantity\&quot;: 2 },   { \&quot;orderItemType\&quot;: \&quot;OFFER\&quot;, \&quot;orderItemId\&quot;: 235, \&quot;quantity\&quot;: 2 },   { \&quot;orderItemType\&quot;: \&quot;CUSTOM\&quot;, \&quot;amount\&quot;: 10.50, \&quot;orderCustomType\&quot;: \&quot;ServiceFee\&quot; },   { \&quot;orderItemType\&quot;: \&quot;CUSTOM\&quot;, \&quot;amount\&quot;: 25.10, \&quot;quantity\&quot;: 2, \&quot;orderCustomType\&quot;: \&quot;Hat\&quot;, \&quot;orderCustomId\&quot;: 123 } ] &#x60;&#x60;&#x60; 
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param description A description of the purchase (optional)
     * @param currencyType Determines the method of purchasing offer.  * VOID: used for when there is no payment involved (ie. for updating the status of a purchase order)  * CASH: use card on file  * POINTS: use account balance  * TICKETS: use tickets  * REFUND: not allowed for a create, requires a paymentTransactionId.  * CREDIT: add to the account balance  * RELOAD: charge a credit card then add to the account balance   (optional, default to CurrencyType.CASH)
     * @param paymentMethodId Use a specific payment method (CASH), if not provided use default (optional)
     * @param externalOrderId Store identifier from external system (optional)
     * @param externalPaymentId Store identifier from external system (optional)
     * @param remoteRefType Remote Reference type (optional)
     * @param externalDate External Date (optional)
     * @param promoCode The Promo Code (optional)
     * @return ApiResponse<OrderResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createOrderWithHttpInfo(appKey: kotlin.String, cart: kotlin.String, deviceId: kotlin.String?, accountId: kotlin.Long?, description: kotlin.String?, currencyType: CurrencyTypeCreateOrder?, paymentMethodId: kotlin.Long?, externalOrderId: kotlin.String?, externalPaymentId: kotlin.String?, remoteRefType: kotlin.String?, externalDate: kotlin.Long?, promoCode: kotlin.String?) : ApiResponse<OrderResponse?> {
        val localVariableConfig = createOrderRequestConfig(appKey = appKey, cart = cart, deviceId = deviceId, accountId = accountId, description = description, currencyType = currencyType, paymentMethodId = paymentMethodId, externalOrderId = externalOrderId, externalPaymentId = externalPaymentId, remoteRefType = remoteRefType, externalDate = externalDate, promoCode = promoCode)

        return request<Unit, OrderResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createOrder
     *
     * @param appKey The application requesting the purchase
     * @param cart &#x60;&#x60;&#x60;json [   { \&quot;orderItemType\&quot;: \&quot;OFFER\&quot;, \&quot;orderItemId\&quot;: 234, \&quot;orderCustomType\&quot;: \&quot;OfferLocation\&quot;, \&quot;orderCustomId\&quot;: 123, \&quot;retailerLocationId\&quot;: 1234, \&quot;quantity\&quot;: 2 },   { \&quot;orderItemType\&quot;: \&quot;OFFER\&quot;, \&quot;orderItemId\&quot;: 235, \&quot;quantity\&quot;: 2 },   { \&quot;orderItemType\&quot;: \&quot;CUSTOM\&quot;, \&quot;amount\&quot;: 10.50, \&quot;orderCustomType\&quot;: \&quot;ServiceFee\&quot; },   { \&quot;orderItemType\&quot;: \&quot;CUSTOM\&quot;, \&quot;amount\&quot;: 25.10, \&quot;quantity\&quot;: 2, \&quot;orderCustomType\&quot;: \&quot;Hat\&quot;, \&quot;orderCustomId\&quot;: 123 } ] &#x60;&#x60;&#x60; 
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param description A description of the purchase (optional)
     * @param currencyType Determines the method of purchasing offer.  * VOID: used for when there is no payment involved (ie. for updating the status of a purchase order)  * CASH: use card on file  * POINTS: use account balance  * TICKETS: use tickets  * REFUND: not allowed for a create, requires a paymentTransactionId.  * CREDIT: add to the account balance  * RELOAD: charge a credit card then add to the account balance   (optional, default to CurrencyType.CASH)
     * @param paymentMethodId Use a specific payment method (CASH), if not provided use default (optional)
     * @param externalOrderId Store identifier from external system (optional)
     * @param externalPaymentId Store identifier from external system (optional)
     * @param remoteRefType Remote Reference type (optional)
     * @param externalDate External Date (optional)
     * @param promoCode The Promo Code (optional)
     * @return RequestConfig
     */
    fun createOrderRequestConfig(appKey: kotlin.String, cart: kotlin.String, deviceId: kotlin.String?, accountId: kotlin.Long?, description: kotlin.String?, currencyType: CurrencyTypeCreateOrder?, paymentMethodId: kotlin.Long?, externalOrderId: kotlin.String?, externalPaymentId: kotlin.String?, remoteRefType: kotlin.String?, externalDate: kotlin.Long?, promoCode: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                put("appKey", listOf(appKey.toString()))
                if (description != null) {
                    put("description", listOf(description.toString()))
                }
                if (currencyType != null) {
                    put("currencyType", listOf(currencyType.value))
                }
                put("cart", listOf(cart.toString()))
                if (paymentMethodId != null) {
                    put("paymentMethodId", listOf(paymentMethodId.toString()))
                }
                if (externalOrderId != null) {
                    put("externalOrderId", listOf(externalOrderId.toString()))
                }
                if (externalPaymentId != null) {
                    put("externalPaymentId", listOf(externalPaymentId.toString()))
                }
                if (remoteRefType != null) {
                    put("remoteRefType", listOf(remoteRefType.toString()))
                }
                if (externalDate != null) {
                    put("externalDate", listOf(externalDate.toString()))
                }
                if (promoCode != null) {
                    put("promoCode", listOf(promoCode.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/order/create",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /order/delete
     * Delete Order
     * Removes the transaction from the wallet by setting the deleted date to the current date/time.  Requires a valid account and transactionId.
     * @param orderId Order Id
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteOrder(orderId: kotlin.Long, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null) : SirqulResponse {
        val localVarResponse = deleteOrderWithHttpInfo(orderId = orderId, deviceId = deviceId, accountId = accountId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /order/delete
     * Delete Order
     * Removes the transaction from the wallet by setting the deleted date to the current date/time.  Requires a valid account and transactionId.
     * @param orderId Order Id
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteOrderWithHttpInfo(orderId: kotlin.Long, deviceId: kotlin.String?, accountId: kotlin.Long?) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = deleteOrderRequestConfig(orderId = orderId, deviceId = deviceId, accountId = accountId)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteOrder
     *
     * @param orderId Order Id
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @return RequestConfig
     */
    fun deleteOrderRequestConfig(orderId: kotlin.Long, deviceId: kotlin.String?, accountId: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                put("orderId", listOf(orderId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/order/delete",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /order/get
     * Get Order
     * Get an order record
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param orderId The order id to get details of, either orderId or externalOrderId must be provided (optional)
     * @param externalOrderId The external order id to get details of, either orderId or externalOrderId must be provided (optional)
     * @return OrderResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getOrder(deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, orderId: kotlin.Long? = null, externalOrderId: kotlin.String? = null) : OrderResponse {
        val localVarResponse = getOrderWithHttpInfo(deviceId = deviceId, accountId = accountId, orderId = orderId, externalOrderId = externalOrderId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OrderResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /order/get
     * Get Order
     * Get an order record
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param orderId The order id to get details of, either orderId or externalOrderId must be provided (optional)
     * @param externalOrderId The external order id to get details of, either orderId or externalOrderId must be provided (optional)
     * @return ApiResponse<OrderResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getOrderWithHttpInfo(deviceId: kotlin.String?, accountId: kotlin.Long?, orderId: kotlin.Long?, externalOrderId: kotlin.String?) : ApiResponse<OrderResponse?> {
        val localVariableConfig = getOrderRequestConfig(deviceId = deviceId, accountId = accountId, orderId = orderId, externalOrderId = externalOrderId)

        return request<Unit, OrderResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getOrder
     *
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param orderId The order id to get details of, either orderId or externalOrderId must be provided (optional)
     * @param externalOrderId The external order id to get details of, either orderId or externalOrderId must be provided (optional)
     * @return RequestConfig
     */
    fun getOrderRequestConfig(deviceId: kotlin.String?, accountId: kotlin.Long?, orderId: kotlin.Long?, externalOrderId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (orderId != null) {
                    put("orderId", listOf(orderId.toString()))
                }
                if (externalOrderId != null) {
                    put("externalOrderId", listOf(externalOrderId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/order/get",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter currencyType
     */
     enum class CurrencyTypePreviewOrder(val value: kotlin.String) {
         @Json(name = "VOID") VOID("VOID"),
         @Json(name = "CASH") CASH("CASH"),
         @Json(name = "POINTS") POINTS("POINTS"),
         @Json(name = "TICKETS") TICKETS("TICKETS"),
         @Json(name = "REFUND") REFUND("REFUND"),
         @Json(name = "CREDIT") CREDIT("CREDIT"),
         @Json(name = "RELOAD") RELOAD("RELOAD");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * POST /order/preview
     * Preview Order
     * Previews a purchase to see the total cost before making it.
     * @param appKey The application requesting the purchase
     * @param cart A JSON list of items to purchase
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param description A description of the purchase (optional)
     * @param currencyType Determines the method of purchasing offer. &#x60;&#x60;&#x60;json {   \&quot;VOID\&quot;: \&quot;used for when there is no payment involved (ie. for updating the status of a purchase order)\&quot;,   \&quot;CASH\&quot;: \&quot;use card on file\&quot;,   \&quot;POINTS\&quot;: \&quot;use account balance\&quot;,   \&quot;TICKETS\&quot;: \&quot;use tickets\&quot;,   \&quot;REFUND\&quot;: \&quot;not allowed for a create, requires a paymentTransactionId\&quot;,   \&quot;CREDIT\&quot;: \&quot;add to the account balance\&quot;,   \&quot;RELOAD\&quot;: \&quot;charge a credit card then add to the account balance\&quot; } &#x60;&#x60;&#x60;  (optional, default to CurrencyType.CASH)
     * @param paymentMethodId Use a specific payment method (CASH), if not provided use default (optional)
     * @param externalOrderId Store identifier from external system (optional)
     * @param externalPaymentId Store identifier from external system (optional)
     * @param remoteRefType Remote Reference type (optional)
     * @param externalDate External Date (optional)
     * @param promoCode The Promo Code (optional)
     * @return OrderResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun previewOrder(appKey: kotlin.String, cart: kotlin.String, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, description: kotlin.String? = null, currencyType: CurrencyTypePreviewOrder? = CurrencyTypePreviewOrder.CASH, paymentMethodId: kotlin.Long? = null, externalOrderId: kotlin.String? = null, externalPaymentId: kotlin.String? = null, remoteRefType: kotlin.String? = null, externalDate: kotlin.Long? = null, promoCode: kotlin.String? = null) : OrderResponse {
        val localVarResponse = previewOrderWithHttpInfo(appKey = appKey, cart = cart, deviceId = deviceId, accountId = accountId, description = description, currencyType = currencyType, paymentMethodId = paymentMethodId, externalOrderId = externalOrderId, externalPaymentId = externalPaymentId, remoteRefType = remoteRefType, externalDate = externalDate, promoCode = promoCode)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OrderResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /order/preview
     * Preview Order
     * Previews a purchase to see the total cost before making it.
     * @param appKey The application requesting the purchase
     * @param cart A JSON list of items to purchase
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param description A description of the purchase (optional)
     * @param currencyType Determines the method of purchasing offer. &#x60;&#x60;&#x60;json {   \&quot;VOID\&quot;: \&quot;used for when there is no payment involved (ie. for updating the status of a purchase order)\&quot;,   \&quot;CASH\&quot;: \&quot;use card on file\&quot;,   \&quot;POINTS\&quot;: \&quot;use account balance\&quot;,   \&quot;TICKETS\&quot;: \&quot;use tickets\&quot;,   \&quot;REFUND\&quot;: \&quot;not allowed for a create, requires a paymentTransactionId\&quot;,   \&quot;CREDIT\&quot;: \&quot;add to the account balance\&quot;,   \&quot;RELOAD\&quot;: \&quot;charge a credit card then add to the account balance\&quot; } &#x60;&#x60;&#x60;  (optional, default to CurrencyType.CASH)
     * @param paymentMethodId Use a specific payment method (CASH), if not provided use default (optional)
     * @param externalOrderId Store identifier from external system (optional)
     * @param externalPaymentId Store identifier from external system (optional)
     * @param remoteRefType Remote Reference type (optional)
     * @param externalDate External Date (optional)
     * @param promoCode The Promo Code (optional)
     * @return ApiResponse<OrderResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun previewOrderWithHttpInfo(appKey: kotlin.String, cart: kotlin.String, deviceId: kotlin.String?, accountId: kotlin.Long?, description: kotlin.String?, currencyType: CurrencyTypePreviewOrder?, paymentMethodId: kotlin.Long?, externalOrderId: kotlin.String?, externalPaymentId: kotlin.String?, remoteRefType: kotlin.String?, externalDate: kotlin.Long?, promoCode: kotlin.String?) : ApiResponse<OrderResponse?> {
        val localVariableConfig = previewOrderRequestConfig(appKey = appKey, cart = cart, deviceId = deviceId, accountId = accountId, description = description, currencyType = currencyType, paymentMethodId = paymentMethodId, externalOrderId = externalOrderId, externalPaymentId = externalPaymentId, remoteRefType = remoteRefType, externalDate = externalDate, promoCode = promoCode)

        return request<Unit, OrderResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation previewOrder
     *
     * @param appKey The application requesting the purchase
     * @param cart A JSON list of items to purchase
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param description A description of the purchase (optional)
     * @param currencyType Determines the method of purchasing offer. &#x60;&#x60;&#x60;json {   \&quot;VOID\&quot;: \&quot;used for when there is no payment involved (ie. for updating the status of a purchase order)\&quot;,   \&quot;CASH\&quot;: \&quot;use card on file\&quot;,   \&quot;POINTS\&quot;: \&quot;use account balance\&quot;,   \&quot;TICKETS\&quot;: \&quot;use tickets\&quot;,   \&quot;REFUND\&quot;: \&quot;not allowed for a create, requires a paymentTransactionId\&quot;,   \&quot;CREDIT\&quot;: \&quot;add to the account balance\&quot;,   \&quot;RELOAD\&quot;: \&quot;charge a credit card then add to the account balance\&quot; } &#x60;&#x60;&#x60;  (optional, default to CurrencyType.CASH)
     * @param paymentMethodId Use a specific payment method (CASH), if not provided use default (optional)
     * @param externalOrderId Store identifier from external system (optional)
     * @param externalPaymentId Store identifier from external system (optional)
     * @param remoteRefType Remote Reference type (optional)
     * @param externalDate External Date (optional)
     * @param promoCode The Promo Code (optional)
     * @return RequestConfig
     */
    fun previewOrderRequestConfig(appKey: kotlin.String, cart: kotlin.String, deviceId: kotlin.String?, accountId: kotlin.Long?, description: kotlin.String?, currencyType: CurrencyTypePreviewOrder?, paymentMethodId: kotlin.Long?, externalOrderId: kotlin.String?, externalPaymentId: kotlin.String?, remoteRefType: kotlin.String?, externalDate: kotlin.Long?, promoCode: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                put("appKey", listOf(appKey.toString()))
                if (description != null) {
                    put("description", listOf(description.toString()))
                }
                if (currencyType != null) {
                    put("currencyType", listOf(currencyType.value))
                }
                put("cart", listOf(cart.toString()))
                if (paymentMethodId != null) {
                    put("paymentMethodId", listOf(paymentMethodId.toString()))
                }
                if (externalOrderId != null) {
                    put("externalOrderId", listOf(externalOrderId.toString()))
                }
                if (externalPaymentId != null) {
                    put("externalPaymentId", listOf(externalPaymentId.toString()))
                }
                if (remoteRefType != null) {
                    put("remoteRefType", listOf(remoteRefType.toString()))
                }
                if (externalDate != null) {
                    put("externalDate", listOf(externalDate.toString()))
                }
                if (promoCode != null) {
                    put("promoCode", listOf(promoCode.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/order/preview",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /order/search
     * Search Orders
     * Search on active orders by customer
     * @param appKey The application requesting the purchase
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param start The start index for pagination (optional, default to 0)
     * @param limit The limit for pagination (optional, default to 20)
     * @param descending Determines whether to return the resulting list in descending or ascending order (optional, default to true)
     * @param activeOnly Only return active orders (optional, default to false)
     * @param ignoreCustomerFilter Determines whether to ignore the customer filter (requires an Admin/Exec account) (optional, default to false)
     * @param orderItemTypes Filter results by orderItemTypes (optional)
     * @param orderItemIds Filter results by orderItemIds (optional)
     * @param orderCustomTypes Filter results by orderCustomTypes (optional)
     * @param orderCustomIds Filter results by orderCustomIds (optional)
     * @param sortField Determines what to sort the results by (optional, default to "ID")
     * @param offerTypes Filter results by offer type (optional)
     * @param specialOfferTypes Filter results by special offer type (optional)
     * @param categoryIds Filter results by category Ids (optional)
     * @param filterIds Filter results by filter Ids (optional)
     * @param offerAudienceIds Filter results by offer audience Ids (optional)
     * @param transactionAudienceIds Filter results by transaction audience Ids (optional)
     * @param offerIds Filter results by offer Ids (optional)
     * @param offerLocationIds Filter results by offer location Ids (optional)
     * @param retailerIds Filter results by retailer Ids (optional)
     * @param retailerLocationIds Filter results by retailer location Ids (optional)
     * @param statuses Filter results by offer transaction status (0: non-redeemable, 1: redeemable, 2: redeemed, 3: user deleted, 4: unclaimed/rewarded, 5: membership active, 6: membership cancelled) (optional)
     * @param keyword The keyword to search for (optional)
     * @param redeemableStartDate Filter results by the offer redeemable date (optional)
     * @param redeemableEndDate Filter results by the offer redeemable date (optional)
     * @param startedSince Filter results by the offer start date (optional)
     * @param startedBefore Filter results by the offer start date (optional)
     * @param endedSince Filter results by the offer end date (optional)
     * @param endedBefore Filter results by the offer end date (optional)
     * @return kotlin.collections.List<OrderResponse>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun searchOrders(appKey: kotlin.String, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, start: kotlin.Int? = 0, limit: kotlin.Int? = 20, descending: kotlin.Boolean? = true, activeOnly: kotlin.Boolean? = false, ignoreCustomerFilter: kotlin.Boolean? = false, orderItemTypes: kotlin.String? = null, orderItemIds: kotlin.String? = null, orderCustomTypes: kotlin.String? = null, orderCustomIds: kotlin.String? = null, sortField: kotlin.String? = "ID", offerTypes: kotlin.String? = null, specialOfferTypes: kotlin.String? = null, categoryIds: kotlin.String? = null, filterIds: kotlin.String? = null, offerAudienceIds: kotlin.String? = null, transactionAudienceIds: kotlin.String? = null, offerIds: kotlin.String? = null, offerLocationIds: kotlin.String? = null, retailerIds: kotlin.String? = null, retailerLocationIds: kotlin.String? = null, statuses: kotlin.String? = null, keyword: kotlin.String? = null, redeemableStartDate: kotlin.Long? = null, redeemableEndDate: kotlin.Long? = null, startedSince: kotlin.Long? = null, startedBefore: kotlin.Long? = null, endedSince: kotlin.Long? = null, endedBefore: kotlin.Long? = null) : kotlin.collections.List<OrderResponse> {
        val localVarResponse = searchOrdersWithHttpInfo(appKey = appKey, deviceId = deviceId, accountId = accountId, start = start, limit = limit, descending = descending, activeOnly = activeOnly, ignoreCustomerFilter = ignoreCustomerFilter, orderItemTypes = orderItemTypes, orderItemIds = orderItemIds, orderCustomTypes = orderCustomTypes, orderCustomIds = orderCustomIds, sortField = sortField, offerTypes = offerTypes, specialOfferTypes = specialOfferTypes, categoryIds = categoryIds, filterIds = filterIds, offerAudienceIds = offerAudienceIds, transactionAudienceIds = transactionAudienceIds, offerIds = offerIds, offerLocationIds = offerLocationIds, retailerIds = retailerIds, retailerLocationIds = retailerLocationIds, statuses = statuses, keyword = keyword, redeemableStartDate = redeemableStartDate, redeemableEndDate = redeemableEndDate, startedSince = startedSince, startedBefore = startedBefore, endedSince = endedSince, endedBefore = endedBefore)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<OrderResponse>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /order/search
     * Search Orders
     * Search on active orders by customer
     * @param appKey The application requesting the purchase
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param start The start index for pagination (optional, default to 0)
     * @param limit The limit for pagination (optional, default to 20)
     * @param descending Determines whether to return the resulting list in descending or ascending order (optional, default to true)
     * @param activeOnly Only return active orders (optional, default to false)
     * @param ignoreCustomerFilter Determines whether to ignore the customer filter (requires an Admin/Exec account) (optional, default to false)
     * @param orderItemTypes Filter results by orderItemTypes (optional)
     * @param orderItemIds Filter results by orderItemIds (optional)
     * @param orderCustomTypes Filter results by orderCustomTypes (optional)
     * @param orderCustomIds Filter results by orderCustomIds (optional)
     * @param sortField Determines what to sort the results by (optional, default to "ID")
     * @param offerTypes Filter results by offer type (optional)
     * @param specialOfferTypes Filter results by special offer type (optional)
     * @param categoryIds Filter results by category Ids (optional)
     * @param filterIds Filter results by filter Ids (optional)
     * @param offerAudienceIds Filter results by offer audience Ids (optional)
     * @param transactionAudienceIds Filter results by transaction audience Ids (optional)
     * @param offerIds Filter results by offer Ids (optional)
     * @param offerLocationIds Filter results by offer location Ids (optional)
     * @param retailerIds Filter results by retailer Ids (optional)
     * @param retailerLocationIds Filter results by retailer location Ids (optional)
     * @param statuses Filter results by offer transaction status (0: non-redeemable, 1: redeemable, 2: redeemed, 3: user deleted, 4: unclaimed/rewarded, 5: membership active, 6: membership cancelled) (optional)
     * @param keyword The keyword to search for (optional)
     * @param redeemableStartDate Filter results by the offer redeemable date (optional)
     * @param redeemableEndDate Filter results by the offer redeemable date (optional)
     * @param startedSince Filter results by the offer start date (optional)
     * @param startedBefore Filter results by the offer start date (optional)
     * @param endedSince Filter results by the offer end date (optional)
     * @param endedBefore Filter results by the offer end date (optional)
     * @return ApiResponse<kotlin.collections.List<OrderResponse>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun searchOrdersWithHttpInfo(appKey: kotlin.String, deviceId: kotlin.String?, accountId: kotlin.Long?, start: kotlin.Int?, limit: kotlin.Int?, descending: kotlin.Boolean?, activeOnly: kotlin.Boolean?, ignoreCustomerFilter: kotlin.Boolean?, orderItemTypes: kotlin.String?, orderItemIds: kotlin.String?, orderCustomTypes: kotlin.String?, orderCustomIds: kotlin.String?, sortField: kotlin.String?, offerTypes: kotlin.String?, specialOfferTypes: kotlin.String?, categoryIds: kotlin.String?, filterIds: kotlin.String?, offerAudienceIds: kotlin.String?, transactionAudienceIds: kotlin.String?, offerIds: kotlin.String?, offerLocationIds: kotlin.String?, retailerIds: kotlin.String?, retailerLocationIds: kotlin.String?, statuses: kotlin.String?, keyword: kotlin.String?, redeemableStartDate: kotlin.Long?, redeemableEndDate: kotlin.Long?, startedSince: kotlin.Long?, startedBefore: kotlin.Long?, endedSince: kotlin.Long?, endedBefore: kotlin.Long?) : ApiResponse<kotlin.collections.List<OrderResponse>?> {
        val localVariableConfig = searchOrdersRequestConfig(appKey = appKey, deviceId = deviceId, accountId = accountId, start = start, limit = limit, descending = descending, activeOnly = activeOnly, ignoreCustomerFilter = ignoreCustomerFilter, orderItemTypes = orderItemTypes, orderItemIds = orderItemIds, orderCustomTypes = orderCustomTypes, orderCustomIds = orderCustomIds, sortField = sortField, offerTypes = offerTypes, specialOfferTypes = specialOfferTypes, categoryIds = categoryIds, filterIds = filterIds, offerAudienceIds = offerAudienceIds, transactionAudienceIds = transactionAudienceIds, offerIds = offerIds, offerLocationIds = offerLocationIds, retailerIds = retailerIds, retailerLocationIds = retailerLocationIds, statuses = statuses, keyword = keyword, redeemableStartDate = redeemableStartDate, redeemableEndDate = redeemableEndDate, startedSince = startedSince, startedBefore = startedBefore, endedSince = endedSince, endedBefore = endedBefore)

        return request<Unit, kotlin.collections.List<OrderResponse>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation searchOrders
     *
     * @param appKey The application requesting the purchase
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param start The start index for pagination (optional, default to 0)
     * @param limit The limit for pagination (optional, default to 20)
     * @param descending Determines whether to return the resulting list in descending or ascending order (optional, default to true)
     * @param activeOnly Only return active orders (optional, default to false)
     * @param ignoreCustomerFilter Determines whether to ignore the customer filter (requires an Admin/Exec account) (optional, default to false)
     * @param orderItemTypes Filter results by orderItemTypes (optional)
     * @param orderItemIds Filter results by orderItemIds (optional)
     * @param orderCustomTypes Filter results by orderCustomTypes (optional)
     * @param orderCustomIds Filter results by orderCustomIds (optional)
     * @param sortField Determines what to sort the results by (optional, default to "ID")
     * @param offerTypes Filter results by offer type (optional)
     * @param specialOfferTypes Filter results by special offer type (optional)
     * @param categoryIds Filter results by category Ids (optional)
     * @param filterIds Filter results by filter Ids (optional)
     * @param offerAudienceIds Filter results by offer audience Ids (optional)
     * @param transactionAudienceIds Filter results by transaction audience Ids (optional)
     * @param offerIds Filter results by offer Ids (optional)
     * @param offerLocationIds Filter results by offer location Ids (optional)
     * @param retailerIds Filter results by retailer Ids (optional)
     * @param retailerLocationIds Filter results by retailer location Ids (optional)
     * @param statuses Filter results by offer transaction status (0: non-redeemable, 1: redeemable, 2: redeemed, 3: user deleted, 4: unclaimed/rewarded, 5: membership active, 6: membership cancelled) (optional)
     * @param keyword The keyword to search for (optional)
     * @param redeemableStartDate Filter results by the offer redeemable date (optional)
     * @param redeemableEndDate Filter results by the offer redeemable date (optional)
     * @param startedSince Filter results by the offer start date (optional)
     * @param startedBefore Filter results by the offer start date (optional)
     * @param endedSince Filter results by the offer end date (optional)
     * @param endedBefore Filter results by the offer end date (optional)
     * @return RequestConfig
     */
    fun searchOrdersRequestConfig(appKey: kotlin.String, deviceId: kotlin.String?, accountId: kotlin.Long?, start: kotlin.Int?, limit: kotlin.Int?, descending: kotlin.Boolean?, activeOnly: kotlin.Boolean?, ignoreCustomerFilter: kotlin.Boolean?, orderItemTypes: kotlin.String?, orderItemIds: kotlin.String?, orderCustomTypes: kotlin.String?, orderCustomIds: kotlin.String?, sortField: kotlin.String?, offerTypes: kotlin.String?, specialOfferTypes: kotlin.String?, categoryIds: kotlin.String?, filterIds: kotlin.String?, offerAudienceIds: kotlin.String?, transactionAudienceIds: kotlin.String?, offerIds: kotlin.String?, offerLocationIds: kotlin.String?, retailerIds: kotlin.String?, retailerLocationIds: kotlin.String?, statuses: kotlin.String?, keyword: kotlin.String?, redeemableStartDate: kotlin.Long?, redeemableEndDate: kotlin.Long?, startedSince: kotlin.Long?, startedBefore: kotlin.Long?, endedSince: kotlin.Long?, endedBefore: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                put("appKey", listOf(appKey.toString()))
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (descending != null) {
                    put("descending", listOf(descending.toString()))
                }
                if (activeOnly != null) {
                    put("activeOnly", listOf(activeOnly.toString()))
                }
                if (ignoreCustomerFilter != null) {
                    put("ignoreCustomerFilter", listOf(ignoreCustomerFilter.toString()))
                }
                if (orderItemTypes != null) {
                    put("orderItemTypes", listOf(orderItemTypes.toString()))
                }
                if (orderItemIds != null) {
                    put("orderItemIds", listOf(orderItemIds.toString()))
                }
                if (orderCustomTypes != null) {
                    put("orderCustomTypes", listOf(orderCustomTypes.toString()))
                }
                if (orderCustomIds != null) {
                    put("orderCustomIds", listOf(orderCustomIds.toString()))
                }
                if (sortField != null) {
                    put("sortField", listOf(sortField.toString()))
                }
                if (offerTypes != null) {
                    put("offerTypes", listOf(offerTypes.toString()))
                }
                if (specialOfferTypes != null) {
                    put("specialOfferTypes", listOf(specialOfferTypes.toString()))
                }
                if (categoryIds != null) {
                    put("categoryIds", listOf(categoryIds.toString()))
                }
                if (filterIds != null) {
                    put("filterIds", listOf(filterIds.toString()))
                }
                if (offerAudienceIds != null) {
                    put("offerAudienceIds", listOf(offerAudienceIds.toString()))
                }
                if (transactionAudienceIds != null) {
                    put("transactionAudienceIds", listOf(transactionAudienceIds.toString()))
                }
                if (offerIds != null) {
                    put("offerIds", listOf(offerIds.toString()))
                }
                if (offerLocationIds != null) {
                    put("offerLocationIds", listOf(offerLocationIds.toString()))
                }
                if (retailerIds != null) {
                    put("retailerIds", listOf(retailerIds.toString()))
                }
                if (retailerLocationIds != null) {
                    put("retailerLocationIds", listOf(retailerLocationIds.toString()))
                }
                if (statuses != null) {
                    put("statuses", listOf(statuses.toString()))
                }
                if (keyword != null) {
                    put("keyword", listOf(keyword.toString()))
                }
                if (redeemableStartDate != null) {
                    put("redeemableStartDate", listOf(redeemableStartDate.toString()))
                }
                if (redeemableEndDate != null) {
                    put("redeemableEndDate", listOf(redeemableEndDate.toString()))
                }
                if (startedSince != null) {
                    put("startedSince", listOf(startedSince.toString()))
                }
                if (startedBefore != null) {
                    put("startedBefore", listOf(startedBefore.toString()))
                }
                if (endedSince != null) {
                    put("endedSince", listOf(endedSince.toString()))
                }
                if (endedBefore != null) {
                    put("endedBefore", listOf(endedBefore.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/order/search",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter currencyType
     */
     enum class CurrencyTypeUpdateOrder(val value: kotlin.String) {
         @Json(name = "VOID") VOID("VOID"),
         @Json(name = "CASH") CASH("CASH"),
         @Json(name = "POINTS") POINTS("POINTS"),
         @Json(name = "TICKETS") TICKETS("TICKETS"),
         @Json(name = "REFUND") REFUND("REFUND"),
         @Json(name = "CREDIT") CREDIT("CREDIT"),
         @Json(name = "RELOAD") RELOAD("RELOAD");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * POST /order/update
     * Update Order
     * Updates new purchase with some number of items associated with it. The orderId provided is used to retrieve the record and the payment is added to it.
     * @param orderId The order to add the purchase to, leave null for new order.
     * @param appKey The application requesting the purchase
     * @param cart &#x60;&#x60;&#x60;json [   { \&quot;orderItemType\&quot;: \&quot;OFFER\&quot;, \&quot;orderItemId\&quot;: 234, \&quot;orderCustomType\&quot;: \&quot;OfferLocation\&quot;, \&quot;orderCustomId\&quot;: 123, \&quot;retailerLocationId\&quot;: 1234, \&quot;quantity\&quot;: 2 },   { \&quot;orderItemType\&quot;: \&quot;OFFER\&quot;, \&quot;orderItemId\&quot;: 235, \&quot;quantity\&quot;: 2 },   { \&quot;orderItemType\&quot;: \&quot;CUSTOM\&quot;, \&quot;amount\&quot;: 10.50, \&quot;orderCustomType\&quot;: \&quot;ServiceFee\&quot; },   { \&quot;orderItemType\&quot;: \&quot;CUSTOM\&quot;, \&quot;amount\&quot;: 25.10, \&quot;quantity\&quot;: 2, \&quot;orderCustomType\&quot;: \&quot;Hat\&quot;, \&quot;orderCustomId\&quot;: 123 } ] &#x60;&#x60;&#x60; 
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param paymentTransactionId The payment transaction to apply the refund to (optional)
     * @param description A description of the purchase (optional)
     * @param currencyType Determines the method of purchasing offer.  * VOID: used for when there is no payment involved (ie. for updating the status of a purchase order)  * CASH: use card on file  * POINTS: use account balance  * TICKETS: use tickets  * REFUND: not allowed for a create, requires a paymentTransactionId.  * CREDIT: add to the account balance  * RELOAD: charge a credit card then add to the account balance   (optional, default to CurrencyType.CASH)
     * @param paymentMethodId Use a specific payment method (CASH), if not provided use default (optional)
     * @param externalPaymentId Store identifier from external system (optional)
     * @param externalDate External Date (optional)
     * @return OrderResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updateOrder(orderId: kotlin.Long, appKey: kotlin.String, cart: kotlin.String, deviceId: kotlin.String? = null, accountId: kotlin.Long? = null, paymentTransactionId: kotlin.Long? = null, description: kotlin.String? = null, currencyType: CurrencyTypeUpdateOrder? = CurrencyTypeUpdateOrder.CASH, paymentMethodId: kotlin.Long? = null, externalPaymentId: kotlin.String? = null, externalDate: kotlin.Long? = null) : OrderResponse {
        val localVarResponse = updateOrderWithHttpInfo(orderId = orderId, appKey = appKey, cart = cart, deviceId = deviceId, accountId = accountId, paymentTransactionId = paymentTransactionId, description = description, currencyType = currencyType, paymentMethodId = paymentMethodId, externalPaymentId = externalPaymentId, externalDate = externalDate)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OrderResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /order/update
     * Update Order
     * Updates new purchase with some number of items associated with it. The orderId provided is used to retrieve the record and the payment is added to it.
     * @param orderId The order to add the purchase to, leave null for new order.
     * @param appKey The application requesting the purchase
     * @param cart &#x60;&#x60;&#x60;json [   { \&quot;orderItemType\&quot;: \&quot;OFFER\&quot;, \&quot;orderItemId\&quot;: 234, \&quot;orderCustomType\&quot;: \&quot;OfferLocation\&quot;, \&quot;orderCustomId\&quot;: 123, \&quot;retailerLocationId\&quot;: 1234, \&quot;quantity\&quot;: 2 },   { \&quot;orderItemType\&quot;: \&quot;OFFER\&quot;, \&quot;orderItemId\&quot;: 235, \&quot;quantity\&quot;: 2 },   { \&quot;orderItemType\&quot;: \&quot;CUSTOM\&quot;, \&quot;amount\&quot;: 10.50, \&quot;orderCustomType\&quot;: \&quot;ServiceFee\&quot; },   { \&quot;orderItemType\&quot;: \&quot;CUSTOM\&quot;, \&quot;amount\&quot;: 25.10, \&quot;quantity\&quot;: 2, \&quot;orderCustomType\&quot;: \&quot;Hat\&quot;, \&quot;orderCustomId\&quot;: 123 } ] &#x60;&#x60;&#x60; 
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param paymentTransactionId The payment transaction to apply the refund to (optional)
     * @param description A description of the purchase (optional)
     * @param currencyType Determines the method of purchasing offer.  * VOID: used for when there is no payment involved (ie. for updating the status of a purchase order)  * CASH: use card on file  * POINTS: use account balance  * TICKETS: use tickets  * REFUND: not allowed for a create, requires a paymentTransactionId.  * CREDIT: add to the account balance  * RELOAD: charge a credit card then add to the account balance   (optional, default to CurrencyType.CASH)
     * @param paymentMethodId Use a specific payment method (CASH), if not provided use default (optional)
     * @param externalPaymentId Store identifier from external system (optional)
     * @param externalDate External Date (optional)
     * @return ApiResponse<OrderResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun updateOrderWithHttpInfo(orderId: kotlin.Long, appKey: kotlin.String, cart: kotlin.String, deviceId: kotlin.String?, accountId: kotlin.Long?, paymentTransactionId: kotlin.Long?, description: kotlin.String?, currencyType: CurrencyTypeUpdateOrder?, paymentMethodId: kotlin.Long?, externalPaymentId: kotlin.String?, externalDate: kotlin.Long?) : ApiResponse<OrderResponse?> {
        val localVariableConfig = updateOrderRequestConfig(orderId = orderId, appKey = appKey, cart = cart, deviceId = deviceId, accountId = accountId, paymentTransactionId = paymentTransactionId, description = description, currencyType = currencyType, paymentMethodId = paymentMethodId, externalPaymentId = externalPaymentId, externalDate = externalDate)

        return request<Unit, OrderResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateOrder
     *
     * @param orderId The order to add the purchase to, leave null for new order.
     * @param appKey The application requesting the purchase
     * @param cart &#x60;&#x60;&#x60;json [   { \&quot;orderItemType\&quot;: \&quot;OFFER\&quot;, \&quot;orderItemId\&quot;: 234, \&quot;orderCustomType\&quot;: \&quot;OfferLocation\&quot;, \&quot;orderCustomId\&quot;: 123, \&quot;retailerLocationId\&quot;: 1234, \&quot;quantity\&quot;: 2 },   { \&quot;orderItemType\&quot;: \&quot;OFFER\&quot;, \&quot;orderItemId\&quot;: 235, \&quot;quantity\&quot;: 2 },   { \&quot;orderItemType\&quot;: \&quot;CUSTOM\&quot;, \&quot;amount\&quot;: 10.50, \&quot;orderCustomType\&quot;: \&quot;ServiceFee\&quot; },   { \&quot;orderItemType\&quot;: \&quot;CUSTOM\&quot;, \&quot;amount\&quot;: 25.10, \&quot;quantity\&quot;: 2, \&quot;orderCustomType\&quot;: \&quot;Hat\&quot;, \&quot;orderCustomId\&quot;: 123 } ] &#x60;&#x60;&#x60; 
     * @param deviceId The device id (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param paymentTransactionId The payment transaction to apply the refund to (optional)
     * @param description A description of the purchase (optional)
     * @param currencyType Determines the method of purchasing offer.  * VOID: used for when there is no payment involved (ie. for updating the status of a purchase order)  * CASH: use card on file  * POINTS: use account balance  * TICKETS: use tickets  * REFUND: not allowed for a create, requires a paymentTransactionId.  * CREDIT: add to the account balance  * RELOAD: charge a credit card then add to the account balance   (optional, default to CurrencyType.CASH)
     * @param paymentMethodId Use a specific payment method (CASH), if not provided use default (optional)
     * @param externalPaymentId Store identifier from external system (optional)
     * @param externalDate External Date (optional)
     * @return RequestConfig
     */
    fun updateOrderRequestConfig(orderId: kotlin.Long, appKey: kotlin.String, cart: kotlin.String, deviceId: kotlin.String?, accountId: kotlin.Long?, paymentTransactionId: kotlin.Long?, description: kotlin.String?, currencyType: CurrencyTypeUpdateOrder?, paymentMethodId: kotlin.Long?, externalPaymentId: kotlin.String?, externalDate: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deviceId != null) {
                    put("deviceId", listOf(deviceId.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                put("orderId", listOf(orderId.toString()))
                if (paymentTransactionId != null) {
                    put("paymentTransactionId", listOf(paymentTransactionId.toString()))
                }
                put("appKey", listOf(appKey.toString()))
                if (description != null) {
                    put("description", listOf(description.toString()))
                }
                if (currencyType != null) {
                    put("currencyType", listOf(currencyType.value))
                }
                put("cart", listOf(cart.toString()))
                if (paymentMethodId != null) {
                    put("paymentMethodId", listOf(paymentMethodId.toString()))
                }
                if (externalPaymentId != null) {
                    put("externalPaymentId", listOf(externalPaymentId.toString()))
                }
                if (externalDate != null) {
                    put("externalDate", listOf(externalDate.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/order/update",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
