/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import org.openapitools.client.models.MissionFormatResponse
import org.openapitools.client.models.MissionResponse
import org.openapitools.client.models.SirqulResponse

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

open class MissionApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://dev.sirqul.com/api/3.18")
        }
    }

    /**
     * POST /mission/create
     * Create Mission
     * Create a user defined mission.
     * @param accountId The logged in user.
     * @param title The title of the mission
     * @param description The description of the mission (optional)
     * @param subType Custom string client apps can use for searching/filtering missions (optional)
     * @param startDate The date/time to start the mission, send 0 to unset (optional)
     * @param endDate The date/time to end the mission, send 0 to unset (optional)
     * @param active Activate/deactivate the mission (optional)
     * @param gameLevelIds the game level ids to include in the mission, comma separated (optional)
     * @param creativeIds creatives to associate with the mission (optional)
     * @param audienceIds audiences to associate with the mission (optional)
     * @param missionTask This parameter is deprecated. (optional)
     * @param formatType The string identifier for a mission format (this is not the missionFormatId) (optional)
     * @param offerId The offerId to give as a reward (optional)
     * @param balance Set the amount of money available to spend, once 0 deactivate mission. Set to a negative value for unlimited. (optional)
     * @param advancedReporting Flag to mark the mission as eligible for advanced reporting (optional)
     * @param allocateTickets Flag to indicate owner should receive tickets for completed missions (optional)
     * @param ticketCount The number of tickets to reward (optional)
     * @param ticketType The type of ticket to reward, null means default type (optional)
     * @param points The number of points to award for completing a mission (optional)
     * @param metaData external custom client defined data (optional)
     * @param applicationIds Comma separated list of application ids (optional)
     * @param devices Deprecated parameter for device names (optional)
     * @param deviceIds Comma separated list of device ids (optional)
     * @param deviceVersions Comma separated list of device version ranges (optional)
     * @param locations List of lat/long pairs for mission locations (optional)
     * @param radius Comma separated list of radii for locations (optional)
     * @return MissionResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createMission(accountId: kotlin.Long, title: kotlin.String, description: kotlin.String? = null, subType: kotlin.String? = null, startDate: kotlin.Long? = null, endDate: kotlin.Long? = null, active: kotlin.Boolean? = null, gameLevelIds: kotlin.String? = null, creativeIds: kotlin.String? = null, audienceIds: kotlin.String? = null, missionTask: kotlin.String? = null, formatType: kotlin.String? = null, offerId: kotlin.Long? = null, balance: kotlin.Double? = null, advancedReporting: kotlin.Boolean? = null, allocateTickets: kotlin.Boolean? = null, ticketCount: kotlin.Long? = null, ticketType: kotlin.String? = null, points: kotlin.Long? = null, metaData: kotlin.String? = null, applicationIds: kotlin.String? = null, devices: kotlin.String? = null, deviceIds: kotlin.String? = null, deviceVersions: kotlin.String? = null, locations: kotlin.String? = null, radius: kotlin.String? = null) : MissionResponse {
        val localVarResponse = createMissionWithHttpInfo(accountId = accountId, title = title, description = description, subType = subType, startDate = startDate, endDate = endDate, active = active, gameLevelIds = gameLevelIds, creativeIds = creativeIds, audienceIds = audienceIds, missionTask = missionTask, formatType = formatType, offerId = offerId, balance = balance, advancedReporting = advancedReporting, allocateTickets = allocateTickets, ticketCount = ticketCount, ticketType = ticketType, points = points, metaData = metaData, applicationIds = applicationIds, devices = devices, deviceIds = deviceIds, deviceVersions = deviceVersions, locations = locations, radius = radius)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MissionResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /mission/create
     * Create Mission
     * Create a user defined mission.
     * @param accountId The logged in user.
     * @param title The title of the mission
     * @param description The description of the mission (optional)
     * @param subType Custom string client apps can use for searching/filtering missions (optional)
     * @param startDate The date/time to start the mission, send 0 to unset (optional)
     * @param endDate The date/time to end the mission, send 0 to unset (optional)
     * @param active Activate/deactivate the mission (optional)
     * @param gameLevelIds the game level ids to include in the mission, comma separated (optional)
     * @param creativeIds creatives to associate with the mission (optional)
     * @param audienceIds audiences to associate with the mission (optional)
     * @param missionTask This parameter is deprecated. (optional)
     * @param formatType The string identifier for a mission format (this is not the missionFormatId) (optional)
     * @param offerId The offerId to give as a reward (optional)
     * @param balance Set the amount of money available to spend, once 0 deactivate mission. Set to a negative value for unlimited. (optional)
     * @param advancedReporting Flag to mark the mission as eligible for advanced reporting (optional)
     * @param allocateTickets Flag to indicate owner should receive tickets for completed missions (optional)
     * @param ticketCount The number of tickets to reward (optional)
     * @param ticketType The type of ticket to reward, null means default type (optional)
     * @param points The number of points to award for completing a mission (optional)
     * @param metaData external custom client defined data (optional)
     * @param applicationIds Comma separated list of application ids (optional)
     * @param devices Deprecated parameter for device names (optional)
     * @param deviceIds Comma separated list of device ids (optional)
     * @param deviceVersions Comma separated list of device version ranges (optional)
     * @param locations List of lat/long pairs for mission locations (optional)
     * @param radius Comma separated list of radii for locations (optional)
     * @return ApiResponse<MissionResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createMissionWithHttpInfo(accountId: kotlin.Long, title: kotlin.String, description: kotlin.String?, subType: kotlin.String?, startDate: kotlin.Long?, endDate: kotlin.Long?, active: kotlin.Boolean?, gameLevelIds: kotlin.String?, creativeIds: kotlin.String?, audienceIds: kotlin.String?, missionTask: kotlin.String?, formatType: kotlin.String?, offerId: kotlin.Long?, balance: kotlin.Double?, advancedReporting: kotlin.Boolean?, allocateTickets: kotlin.Boolean?, ticketCount: kotlin.Long?, ticketType: kotlin.String?, points: kotlin.Long?, metaData: kotlin.String?, applicationIds: kotlin.String?, devices: kotlin.String?, deviceIds: kotlin.String?, deviceVersions: kotlin.String?, locations: kotlin.String?, radius: kotlin.String?) : ApiResponse<MissionResponse?> {
        val localVariableConfig = createMissionRequestConfig(accountId = accountId, title = title, description = description, subType = subType, startDate = startDate, endDate = endDate, active = active, gameLevelIds = gameLevelIds, creativeIds = creativeIds, audienceIds = audienceIds, missionTask = missionTask, formatType = formatType, offerId = offerId, balance = balance, advancedReporting = advancedReporting, allocateTickets = allocateTickets, ticketCount = ticketCount, ticketType = ticketType, points = points, metaData = metaData, applicationIds = applicationIds, devices = devices, deviceIds = deviceIds, deviceVersions = deviceVersions, locations = locations, radius = radius)

        return request<Unit, MissionResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createMission
     *
     * @param accountId The logged in user.
     * @param title The title of the mission
     * @param description The description of the mission (optional)
     * @param subType Custom string client apps can use for searching/filtering missions (optional)
     * @param startDate The date/time to start the mission, send 0 to unset (optional)
     * @param endDate The date/time to end the mission, send 0 to unset (optional)
     * @param active Activate/deactivate the mission (optional)
     * @param gameLevelIds the game level ids to include in the mission, comma separated (optional)
     * @param creativeIds creatives to associate with the mission (optional)
     * @param audienceIds audiences to associate with the mission (optional)
     * @param missionTask This parameter is deprecated. (optional)
     * @param formatType The string identifier for a mission format (this is not the missionFormatId) (optional)
     * @param offerId The offerId to give as a reward (optional)
     * @param balance Set the amount of money available to spend, once 0 deactivate mission. Set to a negative value for unlimited. (optional)
     * @param advancedReporting Flag to mark the mission as eligible for advanced reporting (optional)
     * @param allocateTickets Flag to indicate owner should receive tickets for completed missions (optional)
     * @param ticketCount The number of tickets to reward (optional)
     * @param ticketType The type of ticket to reward, null means default type (optional)
     * @param points The number of points to award for completing a mission (optional)
     * @param metaData external custom client defined data (optional)
     * @param applicationIds Comma separated list of application ids (optional)
     * @param devices Deprecated parameter for device names (optional)
     * @param deviceIds Comma separated list of device ids (optional)
     * @param deviceVersions Comma separated list of device version ranges (optional)
     * @param locations List of lat/long pairs for mission locations (optional)
     * @param radius Comma separated list of radii for locations (optional)
     * @return RequestConfig
     */
    fun createMissionRequestConfig(accountId: kotlin.Long, title: kotlin.String, description: kotlin.String?, subType: kotlin.String?, startDate: kotlin.Long?, endDate: kotlin.Long?, active: kotlin.Boolean?, gameLevelIds: kotlin.String?, creativeIds: kotlin.String?, audienceIds: kotlin.String?, missionTask: kotlin.String?, formatType: kotlin.String?, offerId: kotlin.Long?, balance: kotlin.Double?, advancedReporting: kotlin.Boolean?, allocateTickets: kotlin.Boolean?, ticketCount: kotlin.Long?, ticketType: kotlin.String?, points: kotlin.Long?, metaData: kotlin.String?, applicationIds: kotlin.String?, devices: kotlin.String?, deviceIds: kotlin.String?, deviceVersions: kotlin.String?, locations: kotlin.String?, radius: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("title", listOf(title.toString()))
                if (description != null) {
                    put("description", listOf(description.toString()))
                }
                if (subType != null) {
                    put("subType", listOf(subType.toString()))
                }
                if (startDate != null) {
                    put("startDate", listOf(startDate.toString()))
                }
                if (endDate != null) {
                    put("endDate", listOf(endDate.toString()))
                }
                if (active != null) {
                    put("active", listOf(active.toString()))
                }
                if (gameLevelIds != null) {
                    put("gameLevelIds", listOf(gameLevelIds.toString()))
                }
                if (creativeIds != null) {
                    put("creativeIds", listOf(creativeIds.toString()))
                }
                if (audienceIds != null) {
                    put("audienceIds", listOf(audienceIds.toString()))
                }
                if (missionTask != null) {
                    put("missionTask", listOf(missionTask.toString()))
                }
                if (formatType != null) {
                    put("formatType", listOf(formatType.toString()))
                }
                if (offerId != null) {
                    put("offerId", listOf(offerId.toString()))
                }
                if (balance != null) {
                    put("balance", listOf(balance.toString()))
                }
                if (advancedReporting != null) {
                    put("advancedReporting", listOf(advancedReporting.toString()))
                }
                if (allocateTickets != null) {
                    put("allocateTickets", listOf(allocateTickets.toString()))
                }
                if (ticketCount != null) {
                    put("ticketCount", listOf(ticketCount.toString()))
                }
                if (ticketType != null) {
                    put("ticketType", listOf(ticketType.toString()))
                }
                if (points != null) {
                    put("points", listOf(points.toString()))
                }
                if (metaData != null) {
                    put("metaData", listOf(metaData.toString()))
                }
                if (applicationIds != null) {
                    put("applicationIds", listOf(applicationIds.toString()))
                }
                if (devices != null) {
                    put("devices", listOf(devices.toString()))
                }
                if (deviceIds != null) {
                    put("deviceIds", listOf(deviceIds.toString()))
                }
                if (deviceVersions != null) {
                    put("deviceVersions", listOf(deviceVersions.toString()))
                }
                if (locations != null) {
                    put("locations", listOf(locations.toString()))
                }
                if (radius != null) {
                    put("radius", listOf(radius.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/mission/create",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /mission/delete
     * Delete Mission
     * Delete a mission.
     * @param accountId the id of the logged in user
     * @param missionId the id of the mission to delete
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteMission(accountId: kotlin.Long, missionId: kotlin.Long) : SirqulResponse {
        val localVarResponse = deleteMissionWithHttpInfo(accountId = accountId, missionId = missionId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /mission/delete
     * Delete Mission
     * Delete a mission.
     * @param accountId the id of the logged in user
     * @param missionId the id of the mission to delete
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteMissionWithHttpInfo(accountId: kotlin.Long, missionId: kotlin.Long) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = deleteMissionRequestConfig(accountId = accountId, missionId = missionId)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteMission
     *
     * @param accountId the id of the logged in user
     * @param missionId the id of the mission to delete
     * @return RequestConfig
     */
    fun deleteMissionRequestConfig(accountId: kotlin.Long, missionId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("missionId", listOf(missionId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/mission/delete",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /mission/find
     * Find Missions
     * Get a set of ad filtered by the parameters provided.
     * @param appKey The application key, if provided return missions specific for the app. Will always return mission levels that are app agnostic.
     * @param suffix The type of mission to get, possible values are: click_banner, click_leaderboard, click_skyscraper, click_full, click_video, or click_zip (optional)
     * @param type The type of ads to get, possible values are: BANNER, LEADERBOARD, SKYSCRAPER, FULL, VIDEO, ZIP, CONFIG. Use this instead of suffix. (optional)
     * @param accountId The logged in user. (optional)
     * @param appVersion The version of the application, will not return levels newer than the appVersion. (optional)
     * @param latitude The current location of the requesting device (optional)
     * @param longitude The current location of the requesting device (optional)
     * @param device Should use deviceId if possible. The name of the requesting device; possible values are: Android, iPhone, iPad, iPod, etc. use /audience/devices for list. (optional)
     * @param deviceIdentifier The device ID of the requesting device, use /audience/devices for list (optional)
     * @param deviceVersion The requesting device version; examples are: 2.3, 5.1.4, 6.1.4. Supports X, X.X, or X.X.X formated string. (optional)
     * @param start The index into the record set to start with. (optional)
     * @param limit The total number of record to return. (optional)
     * @param includeGameData Include the game level data with the mission. (optional)
     * @param includeAudiences If true then return the audience data in the response. Default is false. (optional)
     * @param allocatesTickets If true/false only return missions whose game levels allocate (or don&#39;t allocate) tickets. Do not provide a value to return both. (optional)
     * @param randomize return a random set of results, default is true. If false returns in natural order. (optional)
     * @param targetedAdsOnly return only ads targeted to the specific app, no global ads. (optional)
     * @param missionIds return only ads from the specified campaigns. (optional)
     * @param audienceOperator will return the items that have at least 1 or all of their audiences exist in the logged in user’s audiences, depending if the value is OR or AND (optional)
     * @return MissionResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun findMissions(appKey: kotlin.String, suffix: kotlin.String? = null, type: kotlin.String? = null, accountId: kotlin.Long? = null, appVersion: kotlin.String? = null, latitude: kotlin.Double? = null, longitude: kotlin.Double? = null, device: kotlin.String? = null, deviceIdentifier: kotlin.Long? = null, deviceVersion: kotlin.String? = null, start: kotlin.Int? = null, limit: kotlin.Int? = null, includeGameData: kotlin.Boolean? = null, includeAudiences: kotlin.Boolean? = null, allocatesTickets: kotlin.Boolean? = null, randomize: kotlin.Boolean? = null, targetedAdsOnly: kotlin.Boolean? = null, missionIds: kotlin.String? = null, audienceOperator: kotlin.String? = null) : MissionResponse {
        val localVarResponse = findMissionsWithHttpInfo(appKey = appKey, suffix = suffix, type = type, accountId = accountId, appVersion = appVersion, latitude = latitude, longitude = longitude, device = device, deviceIdentifier = deviceIdentifier, deviceVersion = deviceVersion, start = start, limit = limit, includeGameData = includeGameData, includeAudiences = includeAudiences, allocatesTickets = allocatesTickets, randomize = randomize, targetedAdsOnly = targetedAdsOnly, missionIds = missionIds, audienceOperator = audienceOperator)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MissionResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /mission/find
     * Find Missions
     * Get a set of ad filtered by the parameters provided.
     * @param appKey The application key, if provided return missions specific for the app. Will always return mission levels that are app agnostic.
     * @param suffix The type of mission to get, possible values are: click_banner, click_leaderboard, click_skyscraper, click_full, click_video, or click_zip (optional)
     * @param type The type of ads to get, possible values are: BANNER, LEADERBOARD, SKYSCRAPER, FULL, VIDEO, ZIP, CONFIG. Use this instead of suffix. (optional)
     * @param accountId The logged in user. (optional)
     * @param appVersion The version of the application, will not return levels newer than the appVersion. (optional)
     * @param latitude The current location of the requesting device (optional)
     * @param longitude The current location of the requesting device (optional)
     * @param device Should use deviceId if possible. The name of the requesting device; possible values are: Android, iPhone, iPad, iPod, etc. use /audience/devices for list. (optional)
     * @param deviceIdentifier The device ID of the requesting device, use /audience/devices for list (optional)
     * @param deviceVersion The requesting device version; examples are: 2.3, 5.1.4, 6.1.4. Supports X, X.X, or X.X.X formated string. (optional)
     * @param start The index into the record set to start with. (optional)
     * @param limit The total number of record to return. (optional)
     * @param includeGameData Include the game level data with the mission. (optional)
     * @param includeAudiences If true then return the audience data in the response. Default is false. (optional)
     * @param allocatesTickets If true/false only return missions whose game levels allocate (or don&#39;t allocate) tickets. Do not provide a value to return both. (optional)
     * @param randomize return a random set of results, default is true. If false returns in natural order. (optional)
     * @param targetedAdsOnly return only ads targeted to the specific app, no global ads. (optional)
     * @param missionIds return only ads from the specified campaigns. (optional)
     * @param audienceOperator will return the items that have at least 1 or all of their audiences exist in the logged in user’s audiences, depending if the value is OR or AND (optional)
     * @return ApiResponse<MissionResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun findMissionsWithHttpInfo(appKey: kotlin.String, suffix: kotlin.String?, type: kotlin.String?, accountId: kotlin.Long?, appVersion: kotlin.String?, latitude: kotlin.Double?, longitude: kotlin.Double?, device: kotlin.String?, deviceIdentifier: kotlin.Long?, deviceVersion: kotlin.String?, start: kotlin.Int?, limit: kotlin.Int?, includeGameData: kotlin.Boolean?, includeAudiences: kotlin.Boolean?, allocatesTickets: kotlin.Boolean?, randomize: kotlin.Boolean?, targetedAdsOnly: kotlin.Boolean?, missionIds: kotlin.String?, audienceOperator: kotlin.String?) : ApiResponse<MissionResponse?> {
        val localVariableConfig = findMissionsRequestConfig(appKey = appKey, suffix = suffix, type = type, accountId = accountId, appVersion = appVersion, latitude = latitude, longitude = longitude, device = device, deviceIdentifier = deviceIdentifier, deviceVersion = deviceVersion, start = start, limit = limit, includeGameData = includeGameData, includeAudiences = includeAudiences, allocatesTickets = allocatesTickets, randomize = randomize, targetedAdsOnly = targetedAdsOnly, missionIds = missionIds, audienceOperator = audienceOperator)

        return request<Unit, MissionResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation findMissions
     *
     * @param appKey The application key, if provided return missions specific for the app. Will always return mission levels that are app agnostic.
     * @param suffix The type of mission to get, possible values are: click_banner, click_leaderboard, click_skyscraper, click_full, click_video, or click_zip (optional)
     * @param type The type of ads to get, possible values are: BANNER, LEADERBOARD, SKYSCRAPER, FULL, VIDEO, ZIP, CONFIG. Use this instead of suffix. (optional)
     * @param accountId The logged in user. (optional)
     * @param appVersion The version of the application, will not return levels newer than the appVersion. (optional)
     * @param latitude The current location of the requesting device (optional)
     * @param longitude The current location of the requesting device (optional)
     * @param device Should use deviceId if possible. The name of the requesting device; possible values are: Android, iPhone, iPad, iPod, etc. use /audience/devices for list. (optional)
     * @param deviceIdentifier The device ID of the requesting device, use /audience/devices for list (optional)
     * @param deviceVersion The requesting device version; examples are: 2.3, 5.1.4, 6.1.4. Supports X, X.X, or X.X.X formated string. (optional)
     * @param start The index into the record set to start with. (optional)
     * @param limit The total number of record to return. (optional)
     * @param includeGameData Include the game level data with the mission. (optional)
     * @param includeAudiences If true then return the audience data in the response. Default is false. (optional)
     * @param allocatesTickets If true/false only return missions whose game levels allocate (or don&#39;t allocate) tickets. Do not provide a value to return both. (optional)
     * @param randomize return a random set of results, default is true. If false returns in natural order. (optional)
     * @param targetedAdsOnly return only ads targeted to the specific app, no global ads. (optional)
     * @param missionIds return only ads from the specified campaigns. (optional)
     * @param audienceOperator will return the items that have at least 1 or all of their audiences exist in the logged in user’s audiences, depending if the value is OR or AND (optional)
     * @return RequestConfig
     */
    fun findMissionsRequestConfig(appKey: kotlin.String, suffix: kotlin.String?, type: kotlin.String?, accountId: kotlin.Long?, appVersion: kotlin.String?, latitude: kotlin.Double?, longitude: kotlin.Double?, device: kotlin.String?, deviceIdentifier: kotlin.Long?, deviceVersion: kotlin.String?, start: kotlin.Int?, limit: kotlin.Int?, includeGameData: kotlin.Boolean?, includeAudiences: kotlin.Boolean?, allocatesTickets: kotlin.Boolean?, randomize: kotlin.Boolean?, targetedAdsOnly: kotlin.Boolean?, missionIds: kotlin.String?, audienceOperator: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("appKey", listOf(appKey.toString()))
                if (suffix != null) {
                    put("suffix", listOf(suffix.toString()))
                }
                if (type != null) {
                    put("type", listOf(type.toString()))
                }
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (appVersion != null) {
                    put("appVersion", listOf(appVersion.toString()))
                }
                if (latitude != null) {
                    put("latitude", listOf(latitude.toString()))
                }
                if (longitude != null) {
                    put("longitude", listOf(longitude.toString()))
                }
                if (device != null) {
                    put("device", listOf(device.toString()))
                }
                if (deviceIdentifier != null) {
                    put("deviceIdentifier", listOf(deviceIdentifier.toString()))
                }
                if (deviceVersion != null) {
                    put("deviceVersion", listOf(deviceVersion.toString()))
                }
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (includeGameData != null) {
                    put("includeGameData", listOf(includeGameData.toString()))
                }
                if (includeAudiences != null) {
                    put("includeAudiences", listOf(includeAudiences.toString()))
                }
                if (allocatesTickets != null) {
                    put("allocatesTickets", listOf(allocatesTickets.toString()))
                }
                if (randomize != null) {
                    put("randomize", listOf(randomize.toString()))
                }
                if (targetedAdsOnly != null) {
                    put("targetedAdsOnly", listOf(targetedAdsOnly.toString()))
                }
                if (missionIds != null) {
                    put("missionIds", listOf(missionIds.toString()))
                }
                if (audienceOperator != null) {
                    put("audienceOperator", listOf(audienceOperator.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/mission/find",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /mission/get
     * Get Mission
     * Get a mission.
     * @param accountId The logged in user.
     * @param missionId The id of the mission to return.
     * @param returnCreative Return creatives associated with the mission when true (optional)
     * @return MissionResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getMission(accountId: kotlin.Long, missionId: kotlin.Long, returnCreative: kotlin.Boolean? = null) : MissionResponse {
        val localVarResponse = getMissionWithHttpInfo(accountId = accountId, missionId = missionId, returnCreative = returnCreative)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MissionResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /mission/get
     * Get Mission
     * Get a mission.
     * @param accountId The logged in user.
     * @param missionId The id of the mission to return.
     * @param returnCreative Return creatives associated with the mission when true (optional)
     * @return ApiResponse<MissionResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getMissionWithHttpInfo(accountId: kotlin.Long, missionId: kotlin.Long, returnCreative: kotlin.Boolean?) : ApiResponse<MissionResponse?> {
        val localVariableConfig = getMissionRequestConfig(accountId = accountId, missionId = missionId, returnCreative = returnCreative)

        return request<Unit, MissionResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getMission
     *
     * @param accountId The logged in user.
     * @param missionId The id of the mission to return.
     * @param returnCreative Return creatives associated with the mission when true (optional)
     * @return RequestConfig
     */
    fun getMissionRequestConfig(accountId: kotlin.Long, missionId: kotlin.Long, returnCreative: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("missionId", listOf(missionId.toString()))
                if (returnCreative != null) {
                    put("returnCreative", listOf(returnCreative.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/mission/get",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter adSize
     */
     enum class AdSizeImportMission(val value: kotlin.String) {
         @Json(name = "CONFIG") CONFIG("CONFIG"),
         @Json(name = "BANNER") BANNER("BANNER"),
         @Json(name = "LEADERBOARD") LEADERBOARD("LEADERBOARD"),
         @Json(name = "SKYSCRAPER") SKYSCRAPER("SKYSCRAPER"),
         @Json(name = "VIDEO") VIDEO("VIDEO"),
         @Json(name = "ZIP") ZIP("ZIP"),
         @Json(name = "INTERSTITIAL") INTERSTITIAL("INTERSTITIAL"),
         @Json(name = "CUSTOM1") CUSTOM1("CUSTOM1"),
         @Json(name = "CUSTOM2") CUSTOM2("CUSTOM2"),
         @Json(name = "CUSTOM3") CUSTOM3("CUSTOM3"),
         @Json(name = "CUSTOM4") CUSTOM4("CUSTOM4"),
         @Json(name = "CUSTOM5") CUSTOM5("CUSTOM5"),
         @Json(name = "CUSTOM6") CUSTOM6("CUSTOM6"),
         @Json(name = "CUSTOM7") CUSTOM7("CUSTOM7"),
         @Json(name = "CUSTOM8") CUSTOM8("CUSTOM8"),
         @Json(name = "CUSTOM9") CUSTOM9("CUSTOM9"),
         @Json(name = "CUSTOM10") CUSTOM10("CUSTOM10");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * POST /mission/import
     * Import Mission
     * Create a mission using a source item such as an offer location.
     * @param accountId The logged in user.
     * @param latitude The current location of the requesting device
     * @param longitude The current location of the requesting device
     * @param appKey the application key
     * @param keyword the keyword of the mission (optional)
     * @param start The starting index in the result set to return. Default is 0. (optional)
     * @param limit The total number of records to return. Default is 20. (optional)
     * @param adSize the size of the ad (optional)
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun importMission(accountId: kotlin.Long, latitude: kotlin.Double, longitude: kotlin.Double, appKey: kotlin.String, keyword: kotlin.String? = null, start: kotlin.Int? = null, limit: kotlin.Int? = null, adSize: AdSizeImportMission? = null) : SirqulResponse {
        val localVarResponse = importMissionWithHttpInfo(accountId = accountId, latitude = latitude, longitude = longitude, appKey = appKey, keyword = keyword, start = start, limit = limit, adSize = adSize)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /mission/import
     * Import Mission
     * Create a mission using a source item such as an offer location.
     * @param accountId The logged in user.
     * @param latitude The current location of the requesting device
     * @param longitude The current location of the requesting device
     * @param appKey the application key
     * @param keyword the keyword of the mission (optional)
     * @param start The starting index in the result set to return. Default is 0. (optional)
     * @param limit The total number of records to return. Default is 20. (optional)
     * @param adSize the size of the ad (optional)
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun importMissionWithHttpInfo(accountId: kotlin.Long, latitude: kotlin.Double, longitude: kotlin.Double, appKey: kotlin.String, keyword: kotlin.String?, start: kotlin.Int?, limit: kotlin.Int?, adSize: AdSizeImportMission?) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = importMissionRequestConfig(accountId = accountId, latitude = latitude, longitude = longitude, appKey = appKey, keyword = keyword, start = start, limit = limit, adSize = adSize)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation importMission
     *
     * @param accountId The logged in user.
     * @param latitude The current location of the requesting device
     * @param longitude The current location of the requesting device
     * @param appKey the application key
     * @param keyword the keyword of the mission (optional)
     * @param start The starting index in the result set to return. Default is 0. (optional)
     * @param limit The total number of records to return. Default is 20. (optional)
     * @param adSize the size of the ad (optional)
     * @return RequestConfig
     */
    fun importMissionRequestConfig(accountId: kotlin.Long, latitude: kotlin.Double, longitude: kotlin.Double, appKey: kotlin.String, keyword: kotlin.String?, start: kotlin.Int?, limit: kotlin.Int?, adSize: AdSizeImportMission?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("latitude", listOf(latitude.toString()))
                put("longitude", listOf(longitude.toString()))
                if (keyword != null) {
                    put("keyword", listOf(keyword.toString()))
                }
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                put("appKey", listOf(appKey.toString()))
                if (adSize != null) {
                    put("adSize", listOf(adSize.value))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/mission/import",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /mission/format/search
     * Search Mission Formats
     * Searches on pre-defined mission formats
     * @param start The starting index in the result set to return. Default is 0.
     * @param limit The total number of records to return. Default is 20.
     * @param activeOnly Determines whether to return only active results. Default is false.
     * @return kotlin.collections.List<MissionFormatResponse>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun searchMissionFormats(start: kotlin.Int, limit: kotlin.Int, activeOnly: kotlin.Boolean) : kotlin.collections.List<MissionFormatResponse> {
        val localVarResponse = searchMissionFormatsWithHttpInfo(start = start, limit = limit, activeOnly = activeOnly)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<MissionFormatResponse>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /mission/format/search
     * Search Mission Formats
     * Searches on pre-defined mission formats
     * @param start The starting index in the result set to return. Default is 0.
     * @param limit The total number of records to return. Default is 20.
     * @param activeOnly Determines whether to return only active results. Default is false.
     * @return ApiResponse<kotlin.collections.List<MissionFormatResponse>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun searchMissionFormatsWithHttpInfo(start: kotlin.Int, limit: kotlin.Int, activeOnly: kotlin.Boolean) : ApiResponse<kotlin.collections.List<MissionFormatResponse>?> {
        val localVariableConfig = searchMissionFormatsRequestConfig(start = start, limit = limit, activeOnly = activeOnly)

        return request<Unit, kotlin.collections.List<MissionFormatResponse>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation searchMissionFormats
     *
     * @param start The starting index in the result set to return. Default is 0.
     * @param limit The total number of records to return. Default is 20.
     * @param activeOnly Determines whether to return only active results. Default is false.
     * @return RequestConfig
     */
    fun searchMissionFormatsRequestConfig(start: kotlin.Int, limit: kotlin.Int, activeOnly: kotlin.Boolean) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("start", listOf(start.toString()))
                put("limit", listOf(limit.toString()))
                put("activeOnly", listOf(activeOnly.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/mission/format/search",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /mission/search
     * Search Missions
     * Get the list missions available to the account.  
     * @param accountId The logged in user.
     * @param keyword Filter by keyword (optional)
     * @param subType Custom string client apps can use for searching/filtering missions (optional)
     * @param start The index into the record set to start with. Default is 0. (optional)
     * @param limit The total number of record to return. Default is 20, maximum is 100. (optional)
     * @param includeGameData If true then return the game level data in the response. Default is false. (optional)
     * @param includeAudiences If true then return the audience data in the response. Default is false. (optional)
     * @param includeInactive If true then include inactive missions. Default is false. (optional)
     * @param suffix A list of game types to include; click_leaderboard, click_banner, click_skyscraper, click_full, click_video, click_zip, create, vote, question, invite, share, json, xml (optional)
     * @param sortField The field to sort the search on (for example TITLE) (optional)
     * @param descending Whether to sort in descending order (default true) (optional)
     * @return kotlin.collections.List<MissionResponse>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun searchMissions(accountId: kotlin.Long, keyword: kotlin.String? = null, subType: kotlin.String? = null, start: kotlin.Int? = null, limit: kotlin.Int? = null, includeGameData: kotlin.Boolean? = null, includeAudiences: kotlin.Boolean? = null, includeInactive: kotlin.Boolean? = null, suffix: kotlin.String? = null, sortField: kotlin.String? = null, descending: kotlin.Boolean? = null) : kotlin.collections.List<MissionResponse> {
        val localVarResponse = searchMissionsWithHttpInfo(accountId = accountId, keyword = keyword, subType = subType, start = start, limit = limit, includeGameData = includeGameData, includeAudiences = includeAudiences, includeInactive = includeInactive, suffix = suffix, sortField = sortField, descending = descending)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<MissionResponse>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /mission/search
     * Search Missions
     * Get the list missions available to the account.  
     * @param accountId The logged in user.
     * @param keyword Filter by keyword (optional)
     * @param subType Custom string client apps can use for searching/filtering missions (optional)
     * @param start The index into the record set to start with. Default is 0. (optional)
     * @param limit The total number of record to return. Default is 20, maximum is 100. (optional)
     * @param includeGameData If true then return the game level data in the response. Default is false. (optional)
     * @param includeAudiences If true then return the audience data in the response. Default is false. (optional)
     * @param includeInactive If true then include inactive missions. Default is false. (optional)
     * @param suffix A list of game types to include; click_leaderboard, click_banner, click_skyscraper, click_full, click_video, click_zip, create, vote, question, invite, share, json, xml (optional)
     * @param sortField The field to sort the search on (for example TITLE) (optional)
     * @param descending Whether to sort in descending order (default true) (optional)
     * @return ApiResponse<kotlin.collections.List<MissionResponse>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun searchMissionsWithHttpInfo(accountId: kotlin.Long, keyword: kotlin.String?, subType: kotlin.String?, start: kotlin.Int?, limit: kotlin.Int?, includeGameData: kotlin.Boolean?, includeAudiences: kotlin.Boolean?, includeInactive: kotlin.Boolean?, suffix: kotlin.String?, sortField: kotlin.String?, descending: kotlin.Boolean?) : ApiResponse<kotlin.collections.List<MissionResponse>?> {
        val localVariableConfig = searchMissionsRequestConfig(accountId = accountId, keyword = keyword, subType = subType, start = start, limit = limit, includeGameData = includeGameData, includeAudiences = includeAudiences, includeInactive = includeInactive, suffix = suffix, sortField = sortField, descending = descending)

        return request<Unit, kotlin.collections.List<MissionResponse>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation searchMissions
     *
     * @param accountId The logged in user.
     * @param keyword Filter by keyword (optional)
     * @param subType Custom string client apps can use for searching/filtering missions (optional)
     * @param start The index into the record set to start with. Default is 0. (optional)
     * @param limit The total number of record to return. Default is 20, maximum is 100. (optional)
     * @param includeGameData If true then return the game level data in the response. Default is false. (optional)
     * @param includeAudiences If true then return the audience data in the response. Default is false. (optional)
     * @param includeInactive If true then include inactive missions. Default is false. (optional)
     * @param suffix A list of game types to include; click_leaderboard, click_banner, click_skyscraper, click_full, click_video, click_zip, create, vote, question, invite, share, json, xml (optional)
     * @param sortField The field to sort the search on (for example TITLE) (optional)
     * @param descending Whether to sort in descending order (default true) (optional)
     * @return RequestConfig
     */
    fun searchMissionsRequestConfig(accountId: kotlin.Long, keyword: kotlin.String?, subType: kotlin.String?, start: kotlin.Int?, limit: kotlin.Int?, includeGameData: kotlin.Boolean?, includeAudiences: kotlin.Boolean?, includeInactive: kotlin.Boolean?, suffix: kotlin.String?, sortField: kotlin.String?, descending: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                if (keyword != null) {
                    put("keyword", listOf(keyword.toString()))
                }
                if (subType != null) {
                    put("subType", listOf(subType.toString()))
                }
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (includeGameData != null) {
                    put("includeGameData", listOf(includeGameData.toString()))
                }
                if (includeAudiences != null) {
                    put("includeAudiences", listOf(includeAudiences.toString()))
                }
                if (includeInactive != null) {
                    put("includeInactive", listOf(includeInactive.toString()))
                }
                if (suffix != null) {
                    put("suffix", listOf(suffix.toString()))
                }
                if (sortField != null) {
                    put("sortField", listOf(sortField.toString()))
                }
                if (descending != null) {
                    put("descending", listOf(descending.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/mission/search",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /mission/searchByBillableEntity
     * Search Missions by Billable Entity
     * Use the accountId to determine the associated BillableEntity.  From there get a list of all accounts associated as managers.  Get the list missions owned by all associated managers.
     * @param accountId The logged in user.
     * @param keyword Filter by keyword (optional)
     * @param start The index into the record set to start with. Default is 0. (optional)
     * @param limit The total number of record to return. Default id 20. (optional)
     * @param includeGameData If true then return the game level data in the response. Default is false. (optional)
     * @param includeAudiences If true then return the audience data in the response. Default is false. (optional)
     * @param includeInactive If true then include inactive missions. Default is false. (optional)
     * @param suffix A list of game types to include; click_leaderboard, click_banner, click_skyscraper, click_full, click_video, click_zip, create, vote, question, invite, share, json, xml (optional)
     * @param sortField The field to sort the search on (for example TITLE) (optional)
     * @param descending Whether to sort in descending order (default true) (optional)
     * @return kotlin.collections.List<MissionResponse>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun searchMissionsByBillableEntity(accountId: kotlin.Long, keyword: kotlin.String? = null, start: kotlin.Int? = null, limit: kotlin.Int? = null, includeGameData: kotlin.Boolean? = null, includeAudiences: kotlin.Boolean? = null, includeInactive: kotlin.Boolean? = null, suffix: kotlin.String? = null, sortField: kotlin.String? = null, descending: kotlin.Boolean? = null) : kotlin.collections.List<MissionResponse> {
        val localVarResponse = searchMissionsByBillableEntityWithHttpInfo(accountId = accountId, keyword = keyword, start = start, limit = limit, includeGameData = includeGameData, includeAudiences = includeAudiences, includeInactive = includeInactive, suffix = suffix, sortField = sortField, descending = descending)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<MissionResponse>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /mission/searchByBillableEntity
     * Search Missions by Billable Entity
     * Use the accountId to determine the associated BillableEntity.  From there get a list of all accounts associated as managers.  Get the list missions owned by all associated managers.
     * @param accountId The logged in user.
     * @param keyword Filter by keyword (optional)
     * @param start The index into the record set to start with. Default is 0. (optional)
     * @param limit The total number of record to return. Default id 20. (optional)
     * @param includeGameData If true then return the game level data in the response. Default is false. (optional)
     * @param includeAudiences If true then return the audience data in the response. Default is false. (optional)
     * @param includeInactive If true then include inactive missions. Default is false. (optional)
     * @param suffix A list of game types to include; click_leaderboard, click_banner, click_skyscraper, click_full, click_video, click_zip, create, vote, question, invite, share, json, xml (optional)
     * @param sortField The field to sort the search on (for example TITLE) (optional)
     * @param descending Whether to sort in descending order (default true) (optional)
     * @return ApiResponse<kotlin.collections.List<MissionResponse>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun searchMissionsByBillableEntityWithHttpInfo(accountId: kotlin.Long, keyword: kotlin.String?, start: kotlin.Int?, limit: kotlin.Int?, includeGameData: kotlin.Boolean?, includeAudiences: kotlin.Boolean?, includeInactive: kotlin.Boolean?, suffix: kotlin.String?, sortField: kotlin.String?, descending: kotlin.Boolean?) : ApiResponse<kotlin.collections.List<MissionResponse>?> {
        val localVariableConfig = searchMissionsByBillableEntityRequestConfig(accountId = accountId, keyword = keyword, start = start, limit = limit, includeGameData = includeGameData, includeAudiences = includeAudiences, includeInactive = includeInactive, suffix = suffix, sortField = sortField, descending = descending)

        return request<Unit, kotlin.collections.List<MissionResponse>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation searchMissionsByBillableEntity
     *
     * @param accountId The logged in user.
     * @param keyword Filter by keyword (optional)
     * @param start The index into the record set to start with. Default is 0. (optional)
     * @param limit The total number of record to return. Default id 20. (optional)
     * @param includeGameData If true then return the game level data in the response. Default is false. (optional)
     * @param includeAudiences If true then return the audience data in the response. Default is false. (optional)
     * @param includeInactive If true then include inactive missions. Default is false. (optional)
     * @param suffix A list of game types to include; click_leaderboard, click_banner, click_skyscraper, click_full, click_video, click_zip, create, vote, question, invite, share, json, xml (optional)
     * @param sortField The field to sort the search on (for example TITLE) (optional)
     * @param descending Whether to sort in descending order (default true) (optional)
     * @return RequestConfig
     */
    fun searchMissionsByBillableEntityRequestConfig(accountId: kotlin.Long, keyword: kotlin.String?, start: kotlin.Int?, limit: kotlin.Int?, includeGameData: kotlin.Boolean?, includeAudiences: kotlin.Boolean?, includeInactive: kotlin.Boolean?, suffix: kotlin.String?, sortField: kotlin.String?, descending: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                if (keyword != null) {
                    put("keyword", listOf(keyword.toString()))
                }
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (includeGameData != null) {
                    put("includeGameData", listOf(includeGameData.toString()))
                }
                if (includeAudiences != null) {
                    put("includeAudiences", listOf(includeAudiences.toString()))
                }
                if (includeInactive != null) {
                    put("includeInactive", listOf(includeInactive.toString()))
                }
                if (suffix != null) {
                    put("suffix", listOf(suffix.toString()))
                }
                if (sortField != null) {
                    put("sortField", listOf(sortField.toString()))
                }
                if (descending != null) {
                    put("descending", listOf(descending.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/mission/searchByBillableEntity",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /mission/update
     * Update Mission
     * Update a mission.
     * @param accountId The logged in user.
     * @param missionId The id of the mission to update.
     * @param title The title of the mission (optional)
     * @param description The description of the mission (optional)
     * @param subType Custom string client apps can use for searching/filtering missions (optional)
     * @param metaData external custom client defined data (optional)
     * @param startDate The date/time to start the mission, send 0 to unset (optional)
     * @param endDate The date/time to end the mission, send 0 to unset (optional)
     * @param active Activate/deactivate the mission (optional)
     * @param gameLevelIds the game level ids to include in the mission, comma separated (optional)
     * @param creativeIds  (optional)
     * @param audienceIds  (optional)
     * @param offerId The offerId to give as a reward (optional)
     * @param balance Replace the amount of money available to spend, once 0 deactivate mission. Set to a negative value for unlimited. (optional)
     * @param advancedReporting Flag to mark the mission as eligible for advanced reporting (optional)
     * @param allocateTickets Flag to indicate owner should receive tickets for completed missions (optional)
     * @param ticketCount The number of tickets to reward (optional)
     * @param ticketType The type of ticket to reward, null means default type (optional)
     * @param points The number of points to award for completing a mission (optional)
     * @param applicationIds Comma separated list of application ids (optional)
     * @param devices Deprecated parameter for device names (optional)
     * @param deviceIds Comma separated list of device ids (optional)
     * @param deviceVersions Comma separated list of device version ranges (optional)
     * @param locations List of lat/long pairs for mission locations (optional)
     * @param radius Comma separated list of radii for locations (optional)
     * @return MissionResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updateMission(accountId: kotlin.Long, missionId: kotlin.Long, title: kotlin.String? = null, description: kotlin.String? = null, subType: kotlin.String? = null, metaData: kotlin.String? = null, startDate: kotlin.Long? = null, endDate: kotlin.Long? = null, active: kotlin.Boolean? = null, gameLevelIds: kotlin.String? = null, creativeIds: kotlin.String? = null, audienceIds: kotlin.String? = null, offerId: kotlin.Long? = null, balance: kotlin.Double? = null, advancedReporting: kotlin.Boolean? = null, allocateTickets: kotlin.Boolean? = null, ticketCount: kotlin.Long? = null, ticketType: kotlin.String? = null, points: kotlin.Long? = null, applicationIds: kotlin.String? = null, devices: kotlin.String? = null, deviceIds: kotlin.String? = null, deviceVersions: kotlin.String? = null, locations: kotlin.String? = null, radius: kotlin.String? = null) : MissionResponse {
        val localVarResponse = updateMissionWithHttpInfo(accountId = accountId, missionId = missionId, title = title, description = description, subType = subType, metaData = metaData, startDate = startDate, endDate = endDate, active = active, gameLevelIds = gameLevelIds, creativeIds = creativeIds, audienceIds = audienceIds, offerId = offerId, balance = balance, advancedReporting = advancedReporting, allocateTickets = allocateTickets, ticketCount = ticketCount, ticketType = ticketType, points = points, applicationIds = applicationIds, devices = devices, deviceIds = deviceIds, deviceVersions = deviceVersions, locations = locations, radius = radius)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MissionResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /mission/update
     * Update Mission
     * Update a mission.
     * @param accountId The logged in user.
     * @param missionId The id of the mission to update.
     * @param title The title of the mission (optional)
     * @param description The description of the mission (optional)
     * @param subType Custom string client apps can use for searching/filtering missions (optional)
     * @param metaData external custom client defined data (optional)
     * @param startDate The date/time to start the mission, send 0 to unset (optional)
     * @param endDate The date/time to end the mission, send 0 to unset (optional)
     * @param active Activate/deactivate the mission (optional)
     * @param gameLevelIds the game level ids to include in the mission, comma separated (optional)
     * @param creativeIds  (optional)
     * @param audienceIds  (optional)
     * @param offerId The offerId to give as a reward (optional)
     * @param balance Replace the amount of money available to spend, once 0 deactivate mission. Set to a negative value for unlimited. (optional)
     * @param advancedReporting Flag to mark the mission as eligible for advanced reporting (optional)
     * @param allocateTickets Flag to indicate owner should receive tickets for completed missions (optional)
     * @param ticketCount The number of tickets to reward (optional)
     * @param ticketType The type of ticket to reward, null means default type (optional)
     * @param points The number of points to award for completing a mission (optional)
     * @param applicationIds Comma separated list of application ids (optional)
     * @param devices Deprecated parameter for device names (optional)
     * @param deviceIds Comma separated list of device ids (optional)
     * @param deviceVersions Comma separated list of device version ranges (optional)
     * @param locations List of lat/long pairs for mission locations (optional)
     * @param radius Comma separated list of radii for locations (optional)
     * @return ApiResponse<MissionResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun updateMissionWithHttpInfo(accountId: kotlin.Long, missionId: kotlin.Long, title: kotlin.String?, description: kotlin.String?, subType: kotlin.String?, metaData: kotlin.String?, startDate: kotlin.Long?, endDate: kotlin.Long?, active: kotlin.Boolean?, gameLevelIds: kotlin.String?, creativeIds: kotlin.String?, audienceIds: kotlin.String?, offerId: kotlin.Long?, balance: kotlin.Double?, advancedReporting: kotlin.Boolean?, allocateTickets: kotlin.Boolean?, ticketCount: kotlin.Long?, ticketType: kotlin.String?, points: kotlin.Long?, applicationIds: kotlin.String?, devices: kotlin.String?, deviceIds: kotlin.String?, deviceVersions: kotlin.String?, locations: kotlin.String?, radius: kotlin.String?) : ApiResponse<MissionResponse?> {
        val localVariableConfig = updateMissionRequestConfig(accountId = accountId, missionId = missionId, title = title, description = description, subType = subType, metaData = metaData, startDate = startDate, endDate = endDate, active = active, gameLevelIds = gameLevelIds, creativeIds = creativeIds, audienceIds = audienceIds, offerId = offerId, balance = balance, advancedReporting = advancedReporting, allocateTickets = allocateTickets, ticketCount = ticketCount, ticketType = ticketType, points = points, applicationIds = applicationIds, devices = devices, deviceIds = deviceIds, deviceVersions = deviceVersions, locations = locations, radius = radius)

        return request<Unit, MissionResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateMission
     *
     * @param accountId The logged in user.
     * @param missionId The id of the mission to update.
     * @param title The title of the mission (optional)
     * @param description The description of the mission (optional)
     * @param subType Custom string client apps can use for searching/filtering missions (optional)
     * @param metaData external custom client defined data (optional)
     * @param startDate The date/time to start the mission, send 0 to unset (optional)
     * @param endDate The date/time to end the mission, send 0 to unset (optional)
     * @param active Activate/deactivate the mission (optional)
     * @param gameLevelIds the game level ids to include in the mission, comma separated (optional)
     * @param creativeIds  (optional)
     * @param audienceIds  (optional)
     * @param offerId The offerId to give as a reward (optional)
     * @param balance Replace the amount of money available to spend, once 0 deactivate mission. Set to a negative value for unlimited. (optional)
     * @param advancedReporting Flag to mark the mission as eligible for advanced reporting (optional)
     * @param allocateTickets Flag to indicate owner should receive tickets for completed missions (optional)
     * @param ticketCount The number of tickets to reward (optional)
     * @param ticketType The type of ticket to reward, null means default type (optional)
     * @param points The number of points to award for completing a mission (optional)
     * @param applicationIds Comma separated list of application ids (optional)
     * @param devices Deprecated parameter for device names (optional)
     * @param deviceIds Comma separated list of device ids (optional)
     * @param deviceVersions Comma separated list of device version ranges (optional)
     * @param locations List of lat/long pairs for mission locations (optional)
     * @param radius Comma separated list of radii for locations (optional)
     * @return RequestConfig
     */
    fun updateMissionRequestConfig(accountId: kotlin.Long, missionId: kotlin.Long, title: kotlin.String?, description: kotlin.String?, subType: kotlin.String?, metaData: kotlin.String?, startDate: kotlin.Long?, endDate: kotlin.Long?, active: kotlin.Boolean?, gameLevelIds: kotlin.String?, creativeIds: kotlin.String?, audienceIds: kotlin.String?, offerId: kotlin.Long?, balance: kotlin.Double?, advancedReporting: kotlin.Boolean?, allocateTickets: kotlin.Boolean?, ticketCount: kotlin.Long?, ticketType: kotlin.String?, points: kotlin.Long?, applicationIds: kotlin.String?, devices: kotlin.String?, deviceIds: kotlin.String?, deviceVersions: kotlin.String?, locations: kotlin.String?, radius: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("missionId", listOf(missionId.toString()))
                if (title != null) {
                    put("title", listOf(title.toString()))
                }
                if (description != null) {
                    put("description", listOf(description.toString()))
                }
                if (subType != null) {
                    put("subType", listOf(subType.toString()))
                }
                if (metaData != null) {
                    put("metaData", listOf(metaData.toString()))
                }
                if (startDate != null) {
                    put("startDate", listOf(startDate.toString()))
                }
                if (endDate != null) {
                    put("endDate", listOf(endDate.toString()))
                }
                if (active != null) {
                    put("active", listOf(active.toString()))
                }
                if (gameLevelIds != null) {
                    put("gameLevelIds", listOf(gameLevelIds.toString()))
                }
                if (creativeIds != null) {
                    put("creativeIds", listOf(creativeIds.toString()))
                }
                if (audienceIds != null) {
                    put("audienceIds", listOf(audienceIds.toString()))
                }
                if (offerId != null) {
                    put("offerId", listOf(offerId.toString()))
                }
                if (balance != null) {
                    put("balance", listOf(balance.toString()))
                }
                if (advancedReporting != null) {
                    put("advancedReporting", listOf(advancedReporting.toString()))
                }
                if (allocateTickets != null) {
                    put("allocateTickets", listOf(allocateTickets.toString()))
                }
                if (ticketCount != null) {
                    put("ticketCount", listOf(ticketCount.toString()))
                }
                if (ticketType != null) {
                    put("ticketType", listOf(ticketType.toString()))
                }
                if (points != null) {
                    put("points", listOf(points.toString()))
                }
                if (applicationIds != null) {
                    put("applicationIds", listOf(applicationIds.toString()))
                }
                if (devices != null) {
                    put("devices", listOf(devices.toString()))
                }
                if (deviceIds != null) {
                    put("deviceIds", listOf(deviceIds.toString()))
                }
                if (deviceVersions != null) {
                    put("deviceVersions", listOf(deviceVersions.toString()))
                }
                if (locations != null) {
                    put("locations", listOf(locations.toString()))
                }
                if (radius != null) {
                    put("radius", listOf(radius.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/mission/update",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
