/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import org.openapitools.client.models.ApplicationUsageResponse
import org.openapitools.client.models.SirqulResponse
import org.openapitools.client.models.SubscriptionPlanResponse
import org.openapitools.client.models.SubscriptionResponse

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

open class SubscriptionApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://dev.sirqul.com/api/3.18")
        }
    }

    /**
     * POST /subscription/create
     * Create Subscription
     * Create a subscription for a billable entity.  Provide a planId, if not provided then the base plan will be assigned.
     * @param accountId The account used to perform the create, must be the responsible manager
     * @param planId The plan to subscribe to, if null use default plan (optional)
     * @param promoCode Set a promo code for a discount. (optional)
     * @return SubscriptionResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createSubscription(accountId: kotlin.Long, planId: kotlin.Long? = null, promoCode: kotlin.String? = null) : SubscriptionResponse {
        val localVarResponse = createSubscriptionWithHttpInfo(accountId = accountId, planId = planId, promoCode = promoCode)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SubscriptionResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /subscription/create
     * Create Subscription
     * Create a subscription for a billable entity.  Provide a planId, if not provided then the base plan will be assigned.
     * @param accountId The account used to perform the create, must be the responsible manager
     * @param planId The plan to subscribe to, if null use default plan (optional)
     * @param promoCode Set a promo code for a discount. (optional)
     * @return ApiResponse<SubscriptionResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createSubscriptionWithHttpInfo(accountId: kotlin.Long, planId: kotlin.Long?, promoCode: kotlin.String?) : ApiResponse<SubscriptionResponse?> {
        val localVariableConfig = createSubscriptionRequestConfig(accountId = accountId, planId = planId, promoCode = promoCode)

        return request<Unit, SubscriptionResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createSubscription
     *
     * @param accountId The account used to perform the create, must be the responsible manager
     * @param planId The plan to subscribe to, if null use default plan (optional)
     * @param promoCode Set a promo code for a discount. (optional)
     * @return RequestConfig
     */
    fun createSubscriptionRequestConfig(accountId: kotlin.Long, planId: kotlin.Long?, promoCode: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                if (planId != null) {
                    put("planId", listOf(planId.toString()))
                }
                if (promoCode != null) {
                    put("promoCode", listOf(promoCode.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/subscription/create",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /subscription/delete
     * Delete Subscription
     * Suspend the current subscription for the billable entity managed by the account.  The account must be the responsible manager to perform this action
     * @param accountId The account used to perform the delete, must be the responsible manager
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteSubscription(accountId: kotlin.Long) : SirqulResponse {
        val localVarResponse = deleteSubscriptionWithHttpInfo(accountId = accountId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /subscription/delete
     * Delete Subscription
     * Suspend the current subscription for the billable entity managed by the account.  The account must be the responsible manager to perform this action
     * @param accountId The account used to perform the delete, must be the responsible manager
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteSubscriptionWithHttpInfo(accountId: kotlin.Long) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = deleteSubscriptionRequestConfig(accountId = accountId)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteSubscription
     *
     * @param accountId The account used to perform the delete, must be the responsible manager
     * @return RequestConfig
     */
    fun deleteSubscriptionRequestConfig(accountId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/subscription/delete",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /subscription/get
     * Get Subscription
     * Use the accountId to determine the associated BillableEntity.  Then get the subscription.
     * @param accountId The account used to perform the lookup
     * @return SubscriptionResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getSubscription(accountId: kotlin.Long) : SubscriptionResponse {
        val localVarResponse = getSubscriptionWithHttpInfo(accountId = accountId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SubscriptionResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /subscription/get
     * Get Subscription
     * Use the accountId to determine the associated BillableEntity.  Then get the subscription.
     * @param accountId The account used to perform the lookup
     * @return ApiResponse<SubscriptionResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getSubscriptionWithHttpInfo(accountId: kotlin.Long) : ApiResponse<SubscriptionResponse?> {
        val localVariableConfig = getSubscriptionRequestConfig(accountId = accountId)

        return request<Unit, SubscriptionResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getSubscription
     *
     * @param accountId The account used to perform the lookup
     * @return RequestConfig
     */
    fun getSubscriptionRequestConfig(accountId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/subscription/get",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /subscription/plan/get
     * Get Subscription Plan
     * Get the matched subscription plan
     * @param planId The ID of the plan to get
     * @return SubscriptionPlanResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getSubscriptionPlan(planId: kotlin.Long) : SubscriptionPlanResponse {
        val localVarResponse = getSubscriptionPlanWithHttpInfo(planId = planId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SubscriptionPlanResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /subscription/plan/get
     * Get Subscription Plan
     * Get the matched subscription plan
     * @param planId The ID of the plan to get
     * @return ApiResponse<SubscriptionPlanResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getSubscriptionPlanWithHttpInfo(planId: kotlin.Long) : ApiResponse<SubscriptionPlanResponse?> {
        val localVariableConfig = getSubscriptionPlanRequestConfig(planId = planId)

        return request<Unit, SubscriptionPlanResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getSubscriptionPlan
     *
     * @param planId The ID of the plan to get
     * @return RequestConfig
     */
    fun getSubscriptionPlanRequestConfig(planId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("planId", listOf(planId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/subscription/plan/get",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /subscription/plan/list
     * List Subscription Plans
     * Get the matched subscription plan
     * @param visible Include visible only (true), hidden only (false), or all (null) (optional)
     * @param role The role the plan is targeted for, values are: DEVELOPER, RETAILER, ADVERTISER (optional)
     * @return kotlin.collections.List<SubscriptionPlanResponse>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getSubscriptionPlans(visible: kotlin.Boolean? = null, role: kotlin.String? = null) : kotlin.collections.List<SubscriptionPlanResponse> {
        val localVarResponse = getSubscriptionPlansWithHttpInfo(visible = visible, role = role)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<SubscriptionPlanResponse>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /subscription/plan/list
     * List Subscription Plans
     * Get the matched subscription plan
     * @param visible Include visible only (true), hidden only (false), or all (null) (optional)
     * @param role The role the plan is targeted for, values are: DEVELOPER, RETAILER, ADVERTISER (optional)
     * @return ApiResponse<kotlin.collections.List<SubscriptionPlanResponse>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getSubscriptionPlansWithHttpInfo(visible: kotlin.Boolean?, role: kotlin.String?) : ApiResponse<kotlin.collections.List<SubscriptionPlanResponse>?> {
        val localVariableConfig = getSubscriptionPlansRequestConfig(visible = visible, role = role)

        return request<Unit, kotlin.collections.List<SubscriptionPlanResponse>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getSubscriptionPlans
     *
     * @param visible Include visible only (true), hidden only (false), or all (null) (optional)
     * @param role The role the plan is targeted for, values are: DEVELOPER, RETAILER, ADVERTISER (optional)
     * @return RequestConfig
     */
    fun getSubscriptionPlansRequestConfig(visible: kotlin.Boolean?, role: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (visible != null) {
                    put("visible", listOf(visible.toString()))
                }
                if (role != null) {
                    put("role", listOf(role.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/subscription/plan/list",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /subscription/usage/get
     * Get Subscription Usage
     * Use the accountId to determine the associated BillableEntity.  Then get the application usage.
     * @param accountId The account used to perform the lookup
     * @param applicationId Get for just 1 application instead of the BillableEntity (optional)
     * @param start The start time frame (optional)
     * @param end The end time frame (optional)
     * @return ApplicationUsageResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getSubscriptionUsage(accountId: kotlin.Long, applicationId: kotlin.Long? = null, start: kotlin.Long? = null, end: kotlin.Long? = null) : ApplicationUsageResponse {
        val localVarResponse = getSubscriptionUsageWithHttpInfo(accountId = accountId, applicationId = applicationId, start = start, end = end)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ApplicationUsageResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /subscription/usage/get
     * Get Subscription Usage
     * Use the accountId to determine the associated BillableEntity.  Then get the application usage.
     * @param accountId The account used to perform the lookup
     * @param applicationId Get for just 1 application instead of the BillableEntity (optional)
     * @param start The start time frame (optional)
     * @param end The end time frame (optional)
     * @return ApiResponse<ApplicationUsageResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getSubscriptionUsageWithHttpInfo(accountId: kotlin.Long, applicationId: kotlin.Long?, start: kotlin.Long?, end: kotlin.Long?) : ApiResponse<ApplicationUsageResponse?> {
        val localVariableConfig = getSubscriptionUsageRequestConfig(accountId = accountId, applicationId = applicationId, start = start, end = end)

        return request<Unit, ApplicationUsageResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getSubscriptionUsage
     *
     * @param accountId The account used to perform the lookup
     * @param applicationId Get for just 1 application instead of the BillableEntity (optional)
     * @param start The start time frame (optional)
     * @param end The end time frame (optional)
     * @return RequestConfig
     */
    fun getSubscriptionUsageRequestConfig(accountId: kotlin.Long, applicationId: kotlin.Long?, start: kotlin.Long?, end: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                if (applicationId != null) {
                    put("applicationId", listOf(applicationId.toString()))
                }
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (end != null) {
                    put("end", listOf(end.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/subscription/usage/get",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /subscription/update
     * Update Subscription
     * Updates the subscription for the billable entity for an account
     * @param accountId The account used to perform the update, must be the responsible manager
     * @param planId The plan to subscribe to (optional)
     * @param promoCode Set a promo code for a discount. (optional)
     * @param active Set active status (optional)
     * @return SubscriptionResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updateSubscription(accountId: kotlin.Long, planId: kotlin.Long? = null, promoCode: kotlin.String? = null, active: kotlin.Boolean? = null) : SubscriptionResponse {
        val localVarResponse = updateSubscriptionWithHttpInfo(accountId = accountId, planId = planId, promoCode = promoCode, active = active)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SubscriptionResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /subscription/update
     * Update Subscription
     * Updates the subscription for the billable entity for an account
     * @param accountId The account used to perform the update, must be the responsible manager
     * @param planId The plan to subscribe to (optional)
     * @param promoCode Set a promo code for a discount. (optional)
     * @param active Set active status (optional)
     * @return ApiResponse<SubscriptionResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun updateSubscriptionWithHttpInfo(accountId: kotlin.Long, planId: kotlin.Long?, promoCode: kotlin.String?, active: kotlin.Boolean?) : ApiResponse<SubscriptionResponse?> {
        val localVariableConfig = updateSubscriptionRequestConfig(accountId = accountId, planId = planId, promoCode = promoCode, active = active)

        return request<Unit, SubscriptionResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateSubscription
     *
     * @param accountId The account used to perform the update, must be the responsible manager
     * @param planId The plan to subscribe to (optional)
     * @param promoCode Set a promo code for a discount. (optional)
     * @param active Set active status (optional)
     * @return RequestConfig
     */
    fun updateSubscriptionRequestConfig(accountId: kotlin.Long, planId: kotlin.Long?, promoCode: kotlin.String?, active: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                if (planId != null) {
                    put("planId", listOf(planId.toString()))
                }
                if (promoCode != null) {
                    put("promoCode", listOf(promoCode.toString()))
                }
                if (active != null) {
                    put("active", listOf(active.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/subscription/update",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
