/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import org.openapitools.client.models.ObjectStoreResponse

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

open class ObjectStoreApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost")
        }
    }

    /**
     * POST /api/{version}/object/field/add
     * Create Field
     * Add a field to a specific object.  The field name should be camel   case with the first letter lower case, for example: myFieldName.  Duplicate   field names are not allowed.   The field name cannot be any of the following   reserved words: ACCESSIBLE, ADD, ALL, ALTER, ANALYZE, AND, AS, ASC, ASENSITIVE,   BEFORE, BETWEEN, BIGINT, BINARY, BLOB, BOTH, BY, CALL, CASCADE, CASE, CHANGE,   CHAR, CHARACTER, CHECK, COLLATE, COLUMN, CONDITION, CONSTRAINT, CONTINUE,   CONVERT, CREATE, CROSS, CURRENT_, ATE, CURRENT_TIME, CURRENT_TIMESTAMP,   CURRENT_USER, CURSOR, DATABASE, DATABASES, DAY_HOUR, DAY_MICROSECOND, DAY_MINUTE,   DAY_SECOND, DEC, DECIMAL, DECLARE, DEFAULT, DELAYED, DELETE, DESC, DESCRIBE,   DETERMINISTIC, DISTINCT, DISTINCTROW, DIV, DOUBLE, DROP, DUAL, EACH, ELSE,   ELSEIF, ENCLOSED, ESCAPED, EXISTS, EXIT, EXPLAIN, FALSE, FETCH, FLOAT, FLOAT4,   FLOAT8, FOR, FORCE, FOREIGN, FROM, FULLTEXT, GRANT, GROUP, HAVING, HIGH_PRIORITY,   HOUR_MICROSECOND, HOUR_MINUTE, HOUR_SECOND, IF, IGNORE, IN, INDEX, INFILE,   INNER, INOUT, INSENSITIVE, INSERT, INT, INT1, INT2, INT3, INT4, INT8, INTEGER,   INTERVAL, INTO, IS, ITERATE, JOIN, KEY, KEYS, KILL, LEADING, LEAVE, LEFT,   LIKE, LIMIT, LINEAR, LINES, LOAD, LOCALTIME, LOCALTIMESTAMP, LOCK, LONG,   LONGBLOB, LONGT, XT, LOOP, LOW_PRIORITY, MASTER_SSL_VERIFY_SERVER_CERT,   MATCH, MAXVALUE, MEDIUMBLOB, MEDIUMINT, MEDIUMTEXT, MIDDLEINT, MINUTE_MICROSECOND,   MINUTE_SECOND, MOD, MODIFIES, NATURAL, NOT, NO_WRITE_TO_BINLOG, NULL, NUMERIC,   ON, OPTIMIZE, OPTION, OPTIONALLY, OR, ORDER, OUT, OUTER, OUTFILE, PRECISION,   PRIMARY, PROCEDURE, PURGE, RANGE, READ, READS, READ_WRITE, REAL, REFERENCES,   REGEXP, RELEASE, RENAME, REPEAT, REPLACE, REQUIRE, RESIGNAL, RESTRICT, RETURN,   REVOKE, RIGHT, RLIKE, SCHEMA, SCHEMAS, SECOND_MICROSECOND, SELECT, SENSITIVE,   SEPARATOR, SET, SHOW, SIGNAL, SMALLINT, SPATIAL, SPECIFIC, SQL, SQLEXCEPTION,   SQLSTATE, SQLWARNING, SQL_BIG_RESULT, SQL_CALC_FOUND_ROWS, SQL_SMALL_RESULT,   SSL, STARTING, STRAIGHT_JOIN, TABLE, TERMINATED, THEN, TINYBLOB, TINYINT,   TINYTEXT, TO, TRAILING, TRIGGER, TRUE, NDO, UNION, UNIQUE, UNLOCK, UNSIGNED,   UPDATE, USAGE, USE, USING, UTC_DATE, UTC_TIME, UTC_TIMESTAMP, VALUES, VARBINARY,   VARCHAR, VARCHARACTER, VARYING, WHEN, WHERE, WHILE, WITH, WRITE, XOR, YEAR_MONTH,   ZEROFILL, GENERAL, IGNORE_SERVER_IDS, MASTER_HEARTBEAT_PERIOD, SLOW.     The following field names are reserved (cannot be used directly) and are automatically   included during object creation: ID, OBJECTID, CREATED, UPDATED, DELETED.   Additionally the field names must start with a letter or number.
     * @param version 
     * @param accountId The account id of the logged in user
     * @param appKey The application key for updating an existing application
     * @param objectName The name of the object to add the field to
     * @param fieldName field name The name of the field to add.
     * @param fieldType field type The field type to create, supported types are: STRING, DATE, NUMBER, BOOLEAN, IDENTITY
     * @return ObjectStoreResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun addField(version: java.math.BigDecimal, accountId: kotlin.Long, appKey: kotlin.String, objectName: kotlin.String, fieldName: kotlin.String, fieldType: kotlin.String) : ObjectStoreResponse {
        val localVarResponse = addFieldWithHttpInfo(version = version, accountId = accountId, appKey = appKey, objectName = objectName, fieldName = fieldName, fieldType = fieldType)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ObjectStoreResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/{version}/object/field/add
     * Create Field
     * Add a field to a specific object.  The field name should be camel   case with the first letter lower case, for example: myFieldName.  Duplicate   field names are not allowed.   The field name cannot be any of the following   reserved words: ACCESSIBLE, ADD, ALL, ALTER, ANALYZE, AND, AS, ASC, ASENSITIVE,   BEFORE, BETWEEN, BIGINT, BINARY, BLOB, BOTH, BY, CALL, CASCADE, CASE, CHANGE,   CHAR, CHARACTER, CHECK, COLLATE, COLUMN, CONDITION, CONSTRAINT, CONTINUE,   CONVERT, CREATE, CROSS, CURRENT_, ATE, CURRENT_TIME, CURRENT_TIMESTAMP,   CURRENT_USER, CURSOR, DATABASE, DATABASES, DAY_HOUR, DAY_MICROSECOND, DAY_MINUTE,   DAY_SECOND, DEC, DECIMAL, DECLARE, DEFAULT, DELAYED, DELETE, DESC, DESCRIBE,   DETERMINISTIC, DISTINCT, DISTINCTROW, DIV, DOUBLE, DROP, DUAL, EACH, ELSE,   ELSEIF, ENCLOSED, ESCAPED, EXISTS, EXIT, EXPLAIN, FALSE, FETCH, FLOAT, FLOAT4,   FLOAT8, FOR, FORCE, FOREIGN, FROM, FULLTEXT, GRANT, GROUP, HAVING, HIGH_PRIORITY,   HOUR_MICROSECOND, HOUR_MINUTE, HOUR_SECOND, IF, IGNORE, IN, INDEX, INFILE,   INNER, INOUT, INSENSITIVE, INSERT, INT, INT1, INT2, INT3, INT4, INT8, INTEGER,   INTERVAL, INTO, IS, ITERATE, JOIN, KEY, KEYS, KILL, LEADING, LEAVE, LEFT,   LIKE, LIMIT, LINEAR, LINES, LOAD, LOCALTIME, LOCALTIMESTAMP, LOCK, LONG,   LONGBLOB, LONGT, XT, LOOP, LOW_PRIORITY, MASTER_SSL_VERIFY_SERVER_CERT,   MATCH, MAXVALUE, MEDIUMBLOB, MEDIUMINT, MEDIUMTEXT, MIDDLEINT, MINUTE_MICROSECOND,   MINUTE_SECOND, MOD, MODIFIES, NATURAL, NOT, NO_WRITE_TO_BINLOG, NULL, NUMERIC,   ON, OPTIMIZE, OPTION, OPTIONALLY, OR, ORDER, OUT, OUTER, OUTFILE, PRECISION,   PRIMARY, PROCEDURE, PURGE, RANGE, READ, READS, READ_WRITE, REAL, REFERENCES,   REGEXP, RELEASE, RENAME, REPEAT, REPLACE, REQUIRE, RESIGNAL, RESTRICT, RETURN,   REVOKE, RIGHT, RLIKE, SCHEMA, SCHEMAS, SECOND_MICROSECOND, SELECT, SENSITIVE,   SEPARATOR, SET, SHOW, SIGNAL, SMALLINT, SPATIAL, SPECIFIC, SQL, SQLEXCEPTION,   SQLSTATE, SQLWARNING, SQL_BIG_RESULT, SQL_CALC_FOUND_ROWS, SQL_SMALL_RESULT,   SSL, STARTING, STRAIGHT_JOIN, TABLE, TERMINATED, THEN, TINYBLOB, TINYINT,   TINYTEXT, TO, TRAILING, TRIGGER, TRUE, NDO, UNION, UNIQUE, UNLOCK, UNSIGNED,   UPDATE, USAGE, USE, USING, UTC_DATE, UTC_TIME, UTC_TIMESTAMP, VALUES, VARBINARY,   VARCHAR, VARCHARACTER, VARYING, WHEN, WHERE, WHILE, WITH, WRITE, XOR, YEAR_MONTH,   ZEROFILL, GENERAL, IGNORE_SERVER_IDS, MASTER_HEARTBEAT_PERIOD, SLOW.     The following field names are reserved (cannot be used directly) and are automatically   included during object creation: ID, OBJECTID, CREATED, UPDATED, DELETED.   Additionally the field names must start with a letter or number.
     * @param version 
     * @param accountId The account id of the logged in user
     * @param appKey The application key for updating an existing application
     * @param objectName The name of the object to add the field to
     * @param fieldName field name The name of the field to add.
     * @param fieldType field type The field type to create, supported types are: STRING, DATE, NUMBER, BOOLEAN, IDENTITY
     * @return ApiResponse<ObjectStoreResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun addFieldWithHttpInfo(version: java.math.BigDecimal, accountId: kotlin.Long, appKey: kotlin.String, objectName: kotlin.String, fieldName: kotlin.String, fieldType: kotlin.String) : ApiResponse<ObjectStoreResponse?> {
        val localVariableConfig = addFieldRequestConfig(version = version, accountId = accountId, appKey = appKey, objectName = objectName, fieldName = fieldName, fieldType = fieldType)

        return request<Unit, ObjectStoreResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation addField
     *
     * @param version 
     * @param accountId The account id of the logged in user
     * @param appKey The application key for updating an existing application
     * @param objectName The name of the object to add the field to
     * @param fieldName field name The name of the field to add.
     * @param fieldType field type The field type to create, supported types are: STRING, DATE, NUMBER, BOOLEAN, IDENTITY
     * @return RequestConfig
     */
    fun addFieldRequestConfig(version: java.math.BigDecimal, accountId: kotlin.Long, appKey: kotlin.String, objectName: kotlin.String, fieldName: kotlin.String, fieldType: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("appKey", listOf(appKey.toString()))
                put("objectName", listOf(objectName.toString()))
                put("fieldName", listOf(fieldName.toString()))
                put("fieldType", listOf(fieldType.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/{version}/object/field/add".replace("{"+"version"+"}", encodeURIComponent(version.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/{version}/object/data/{objectName}
     * Create Data
     * Create a record for the specified object.  If the object does not exist then a new one will be created prior to inserting the record.  If any of the fields included does not exist for the object then they are added to the object. 
     * @param version 
     * @param objectName the name of the object to create data for
     * @param accountId the account id (optional)
     * @param body  (optional)
     * @return ObjectStoreResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createData(version: java.math.BigDecimal, objectName: kotlin.String, accountId: kotlin.Long? = null, body: kotlin.String? = null) : ObjectStoreResponse {
        val localVarResponse = createDataWithHttpInfo(version = version, objectName = objectName, accountId = accountId, body = body)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ObjectStoreResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/{version}/object/data/{objectName}
     * Create Data
     * Create a record for the specified object.  If the object does not exist then a new one will be created prior to inserting the record.  If any of the fields included does not exist for the object then they are added to the object. 
     * @param version 
     * @param objectName the name of the object to create data for
     * @param accountId the account id (optional)
     * @param body  (optional)
     * @return ApiResponse<ObjectStoreResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createDataWithHttpInfo(version: java.math.BigDecimal, objectName: kotlin.String, accountId: kotlin.Long?, body: kotlin.String?) : ApiResponse<ObjectStoreResponse?> {
        val localVariableConfig = createDataRequestConfig(version = version, objectName = objectName, accountId = accountId, body = body)

        return request<kotlin.String, ObjectStoreResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createData
     *
     * @param version 
     * @param objectName the name of the object to create data for
     * @param accountId the account id (optional)
     * @param body  (optional)
     * @return RequestConfig
     */
    fun createDataRequestConfig(version: java.math.BigDecimal, objectName: kotlin.String, accountId: kotlin.Long?, body: kotlin.String?) : RequestConfig<kotlin.String> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/{version}/object/data/{objectName}".replace("{"+"version"+"}", encodeURIComponent(version.toString())).replace("{"+"objectName"+"}", encodeURIComponent(objectName.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/{version}/object/create
     * Create Object
     * Create an Object Store table.  By default tables will have the columns: id, created, updated, deleted.  Names og objects should be camel case with the first letter capitalized, for example: MyTableName.   Duplicate object names are not allowed.   The object name cannot be any of the following reserved words: ACCESSIBLE, ADD, ALL, ALTER, ANALYZE, AND, AS, ASC, ASENSITIVE, BEFORE, BETWEEN, BIGINT, BINARY, BLOB, BOTH, BY, CALL, CASCADE, CASE, CHANGE, CHAR, CHARACTER, CHECK, COLLATE, COLUMN, CONDITION, CONSTRAINT, CONTINUE, CONVERT, CREATE, CROSS, CURRENT_, ATE, CURRENT_TIME, CURRENT_TIMESTAMP, CURRENT_USER, CURSOR, DATABASE, DATABASES, DAY_HOUR, DAY_MICROSECOND, DAY_MINUTE, DAY_SECOND, DEC, DECIMAL, DECLARE, DEFAULT, DELAYED, DELETE, DESC, DESCRIBE, DETERMINISTIC, DISTINCT, DISTINCTROW, DIV, DOUBLE, DROP, DUAL, EACH, ELSE, ELSEIF, ENCLOSED, ESCAPED, EXISTS, EXIT, EXPLAIN, FALSE, FETCH, FLOAT, FLOAT4, FLOAT8, FOR, FORCE, FOREIGN, FROM, FULLTEXT, GRANT, GROUP, HAVING, HIGH_PRIORITY, HOUR_MICROSECOND, HOUR_MINUTE, HOUR_SECOND, IF, IGNORE, IN, INDEX, INFILE, INNER, INOUT, INSENSITIVE, INSERT, INT, INT1, INT2, INT3, INT4, INT8, INTEGER, INTERVAL, INTO, IS, ITERATE, JOIN, KEY, KEYS, KILL, LEADING, LEAVE, LEFT, LIKE, LIMIT, LINEAR, LINES, LOAD, LOCALTIME, LOCALTIMESTAMP, LOCK, LONG, LONGBLOB, LONGT, XT, LOOP, LOW_PRIORITY, MASTER_SSL_VERIFY_SERVER_CERT, MATCH, MAXVALUE, MEDIUMBLOB, MEDIUMINT, MEDIUMTEXT, MIDDLEINT, MINUTE_MICROSECOND, MINUTE_SECOND, MOD, MODIFIES, NATURAL, NOT, NO_WRITE_TO_BINLOG, NULL, NUMERIC, ON, OPTIMIZE, OPTION, OPTIONALLY, OR, ORDER, OUT, OUTER, OUTFILE, PRECISION, PRIMARY, PROCEDURE, PURGE, RANGE, READ, READS, READ_WRITE, REAL, REFERENCES, REGEXP, RELEASE, RENAME, REPEAT, REPLACE, REQUIRE, RESIGNAL, RESTRICT, RETURN, REVOKE, RIGHT, RLIKE, SCHEMA, SCHEMAS, SECOND_MICROSECOND, SELECT, SENSITIVE, SEPARATOR, SET, SHOW, SIGNAL, SMALLINT, SPATIAL, SPECIFIC, SQL, SQLEXCEPTION, SQLSTATE, SQLWARNING, SQL_BIG_RESULT, SQL_CALC_FOUND_ROWS, SQL_SMALL_RESULT, SSL, STARTING, STRAIGHT_JOIN, TABLE, TERMINATED, THEN, TINYBLOB, TINYINT, TINYTEXT, TO, TRAILING, TRIGGER, TRUE, NDO, UNION, UNIQUE, UNLOCK, UNSIGNED, UPDATE, USAGE, USE, USING, UTC_DATE, UTC_TIME, UTC_TIMESTAMP, VALUES, VARBINARY, VARCHAR, VARCHARACTER, VARYING, WHEN, WHERE, WHILE, WITH, WRITE, XOR, YEAR_MONTH, ZEROFILL, GENERAL, IGNORE_SERVER_IDS, MASTER_HEARTBEAT_PERIOD, SLOW. 
     * @param version 
     * @param accountId The account id of the logged in user
     * @param appKey The application key for updating an existing application
     * @param objectName The name of the object to create
     * @return ObjectStoreResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createObject(version: java.math.BigDecimal, accountId: kotlin.Long, appKey: kotlin.String, objectName: kotlin.String) : ObjectStoreResponse {
        val localVarResponse = createObjectWithHttpInfo(version = version, accountId = accountId, appKey = appKey, objectName = objectName)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ObjectStoreResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/{version}/object/create
     * Create Object
     * Create an Object Store table.  By default tables will have the columns: id, created, updated, deleted.  Names og objects should be camel case with the first letter capitalized, for example: MyTableName.   Duplicate object names are not allowed.   The object name cannot be any of the following reserved words: ACCESSIBLE, ADD, ALL, ALTER, ANALYZE, AND, AS, ASC, ASENSITIVE, BEFORE, BETWEEN, BIGINT, BINARY, BLOB, BOTH, BY, CALL, CASCADE, CASE, CHANGE, CHAR, CHARACTER, CHECK, COLLATE, COLUMN, CONDITION, CONSTRAINT, CONTINUE, CONVERT, CREATE, CROSS, CURRENT_, ATE, CURRENT_TIME, CURRENT_TIMESTAMP, CURRENT_USER, CURSOR, DATABASE, DATABASES, DAY_HOUR, DAY_MICROSECOND, DAY_MINUTE, DAY_SECOND, DEC, DECIMAL, DECLARE, DEFAULT, DELAYED, DELETE, DESC, DESCRIBE, DETERMINISTIC, DISTINCT, DISTINCTROW, DIV, DOUBLE, DROP, DUAL, EACH, ELSE, ELSEIF, ENCLOSED, ESCAPED, EXISTS, EXIT, EXPLAIN, FALSE, FETCH, FLOAT, FLOAT4, FLOAT8, FOR, FORCE, FOREIGN, FROM, FULLTEXT, GRANT, GROUP, HAVING, HIGH_PRIORITY, HOUR_MICROSECOND, HOUR_MINUTE, HOUR_SECOND, IF, IGNORE, IN, INDEX, INFILE, INNER, INOUT, INSENSITIVE, INSERT, INT, INT1, INT2, INT3, INT4, INT8, INTEGER, INTERVAL, INTO, IS, ITERATE, JOIN, KEY, KEYS, KILL, LEADING, LEAVE, LEFT, LIKE, LIMIT, LINEAR, LINES, LOAD, LOCALTIME, LOCALTIMESTAMP, LOCK, LONG, LONGBLOB, LONGT, XT, LOOP, LOW_PRIORITY, MASTER_SSL_VERIFY_SERVER_CERT, MATCH, MAXVALUE, MEDIUMBLOB, MEDIUMINT, MEDIUMTEXT, MIDDLEINT, MINUTE_MICROSECOND, MINUTE_SECOND, MOD, MODIFIES, NATURAL, NOT, NO_WRITE_TO_BINLOG, NULL, NUMERIC, ON, OPTIMIZE, OPTION, OPTIONALLY, OR, ORDER, OUT, OUTER, OUTFILE, PRECISION, PRIMARY, PROCEDURE, PURGE, RANGE, READ, READS, READ_WRITE, REAL, REFERENCES, REGEXP, RELEASE, RENAME, REPEAT, REPLACE, REQUIRE, RESIGNAL, RESTRICT, RETURN, REVOKE, RIGHT, RLIKE, SCHEMA, SCHEMAS, SECOND_MICROSECOND, SELECT, SENSITIVE, SEPARATOR, SET, SHOW, SIGNAL, SMALLINT, SPATIAL, SPECIFIC, SQL, SQLEXCEPTION, SQLSTATE, SQLWARNING, SQL_BIG_RESULT, SQL_CALC_FOUND_ROWS, SQL_SMALL_RESULT, SSL, STARTING, STRAIGHT_JOIN, TABLE, TERMINATED, THEN, TINYBLOB, TINYINT, TINYTEXT, TO, TRAILING, TRIGGER, TRUE, NDO, UNION, UNIQUE, UNLOCK, UNSIGNED, UPDATE, USAGE, USE, USING, UTC_DATE, UTC_TIME, UTC_TIMESTAMP, VALUES, VARBINARY, VARCHAR, VARCHARACTER, VARYING, WHEN, WHERE, WHILE, WITH, WRITE, XOR, YEAR_MONTH, ZEROFILL, GENERAL, IGNORE_SERVER_IDS, MASTER_HEARTBEAT_PERIOD, SLOW. 
     * @param version 
     * @param accountId The account id of the logged in user
     * @param appKey The application key for updating an existing application
     * @param objectName The name of the object to create
     * @return ApiResponse<ObjectStoreResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createObjectWithHttpInfo(version: java.math.BigDecimal, accountId: kotlin.Long, appKey: kotlin.String, objectName: kotlin.String) : ApiResponse<ObjectStoreResponse?> {
        val localVariableConfig = createObjectRequestConfig(version = version, accountId = accountId, appKey = appKey, objectName = objectName)

        return request<Unit, ObjectStoreResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createObject
     *
     * @param version 
     * @param accountId The account id of the logged in user
     * @param appKey The application key for updating an existing application
     * @param objectName The name of the object to create
     * @return RequestConfig
     */
    fun createObjectRequestConfig(version: java.math.BigDecimal, accountId: kotlin.Long, appKey: kotlin.String, objectName: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("appKey", listOf(appKey.toString()))
                put("objectName", listOf(objectName.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/{version}/object/create".replace("{"+"version"+"}", encodeURIComponent(version.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * DELETE /api/{version}/object/data/{objectName}/{objectId}
     * Delete Data
     * Delete a record for the specified object. Cannot be undone so use only when abolutely sure.
     * @param version 
     * @param objectName The name of the object to search upon
     * @param objectId objectId The id of the record to return
     * @param accountId The account id of the logged in user (optional)
     * @return ObjectStoreResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteData(version: java.math.BigDecimal, objectName: kotlin.String, objectId: kotlin.String, accountId: kotlin.Long? = null) : ObjectStoreResponse {
        val localVarResponse = deleteDataWithHttpInfo(version = version, objectName = objectName, objectId = objectId, accountId = accountId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ObjectStoreResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * DELETE /api/{version}/object/data/{objectName}/{objectId}
     * Delete Data
     * Delete a record for the specified object. Cannot be undone so use only when abolutely sure.
     * @param version 
     * @param objectName The name of the object to search upon
     * @param objectId objectId The id of the record to return
     * @param accountId The account id of the logged in user (optional)
     * @return ApiResponse<ObjectStoreResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteDataWithHttpInfo(version: java.math.BigDecimal, objectName: kotlin.String, objectId: kotlin.String, accountId: kotlin.Long?) : ApiResponse<ObjectStoreResponse?> {
        val localVariableConfig = deleteDataRequestConfig(version = version, objectName = objectName, objectId = objectId, accountId = accountId)

        return request<Unit, ObjectStoreResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteData
     *
     * @param version 
     * @param objectName The name of the object to search upon
     * @param objectId objectId The id of the record to return
     * @param accountId The account id of the logged in user (optional)
     * @return RequestConfig
     */
    fun deleteDataRequestConfig(version: java.math.BigDecimal, objectName: kotlin.String, objectId: kotlin.String, accountId: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/{version}/object/data/{objectName}/{objectId}".replace("{"+"version"+"}", encodeURIComponent(version.toString())).replace("{"+"objectName"+"}", encodeURIComponent(objectName.toString())).replace("{"+"objectId"+"}", encodeURIComponent(objectId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/{version}/object/field/delete
     * Delete Field
     * Delete a field from an object.  This will remove the field, indexes,   and foreign keys associated with the field.   The following field names   are reserved and cannot be removed from the object: ID, OBJECTID, CREATED,   UPDATED, DELETED
     * @param version 
     * @param accountId The account id of the logged in user
     * @param appKey The application key for updating an existing application
     * @param objectName The name of the object to remove the field from
     * @param fieldName field name The name of the field to remove.
     * @return ObjectStoreResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteField(version: java.math.BigDecimal, accountId: kotlin.Long, appKey: kotlin.String, objectName: kotlin.String, fieldName: kotlin.String) : ObjectStoreResponse {
        val localVarResponse = deleteFieldWithHttpInfo(version = version, accountId = accountId, appKey = appKey, objectName = objectName, fieldName = fieldName)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ObjectStoreResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/{version}/object/field/delete
     * Delete Field
     * Delete a field from an object.  This will remove the field, indexes,   and foreign keys associated with the field.   The following field names   are reserved and cannot be removed from the object: ID, OBJECTID, CREATED,   UPDATED, DELETED
     * @param version 
     * @param accountId The account id of the logged in user
     * @param appKey The application key for updating an existing application
     * @param objectName The name of the object to remove the field from
     * @param fieldName field name The name of the field to remove.
     * @return ApiResponse<ObjectStoreResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteFieldWithHttpInfo(version: java.math.BigDecimal, accountId: kotlin.Long, appKey: kotlin.String, objectName: kotlin.String, fieldName: kotlin.String) : ApiResponse<ObjectStoreResponse?> {
        val localVariableConfig = deleteFieldRequestConfig(version = version, accountId = accountId, appKey = appKey, objectName = objectName, fieldName = fieldName)

        return request<Unit, ObjectStoreResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteField
     *
     * @param version 
     * @param accountId The account id of the logged in user
     * @param appKey The application key for updating an existing application
     * @param objectName The name of the object to remove the field from
     * @param fieldName field name The name of the field to remove.
     * @return RequestConfig
     */
    fun deleteFieldRequestConfig(version: java.math.BigDecimal, accountId: kotlin.Long, appKey: kotlin.String, objectName: kotlin.String, fieldName: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("appKey", listOf(appKey.toString()))
                put("objectName", listOf(objectName.toString()))
                put("fieldName", listOf(fieldName.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/{version}/object/field/delete".replace("{"+"version"+"}", encodeURIComponent(version.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/{version}/object/delete
     * Delete Object
     * Delete and Object in the store.  This will delete the table and clean up and foreign keys referencing it. Cannot be undone so use only when abolutely sure.
     * @param version 
     * @param accountId the id of the logged in user
     * @param appKey the application key
     * @param objectName the name of the object to delete
     * @return ObjectStoreResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteObject(version: java.math.BigDecimal, accountId: kotlin.Long, appKey: kotlin.String, objectName: kotlin.String) : ObjectStoreResponse {
        val localVarResponse = deleteObjectWithHttpInfo(version = version, accountId = accountId, appKey = appKey, objectName = objectName)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ObjectStoreResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/{version}/object/delete
     * Delete Object
     * Delete and Object in the store.  This will delete the table and clean up and foreign keys referencing it. Cannot be undone so use only when abolutely sure.
     * @param version 
     * @param accountId the id of the logged in user
     * @param appKey the application key
     * @param objectName the name of the object to delete
     * @return ApiResponse<ObjectStoreResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteObjectWithHttpInfo(version: java.math.BigDecimal, accountId: kotlin.Long, appKey: kotlin.String, objectName: kotlin.String) : ApiResponse<ObjectStoreResponse?> {
        val localVariableConfig = deleteObjectRequestConfig(version = version, accountId = accountId, appKey = appKey, objectName = objectName)

        return request<Unit, ObjectStoreResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteObject
     *
     * @param version 
     * @param accountId the id of the logged in user
     * @param appKey the application key
     * @param objectName the name of the object to delete
     * @return RequestConfig
     */
    fun deleteObjectRequestConfig(version: java.math.BigDecimal, accountId: kotlin.Long, appKey: kotlin.String, objectName: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("appKey", listOf(appKey.toString()))
                put("objectName", listOf(objectName.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/{version}/object/delete".replace("{"+"version"+"}", encodeURIComponent(version.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /api/{version}/object/data/{objectName}/{objectId}
     * Get Data
     * Get a specific record from a specified object.
     * @param version 
     * @param objectName The name of the object to search upon
     * @param objectId objectId The id of the record to return
     * @param accountId The account id of the logged in user (optional)
     * @param include  (optional)
     * @return ObjectStoreResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getData(version: java.math.BigDecimal, objectName: kotlin.String, objectId: kotlin.String, accountId: kotlin.Long? = null, include: kotlin.String? = null) : ObjectStoreResponse {
        val localVarResponse = getDataWithHttpInfo(version = version, objectName = objectName, objectId = objectId, accountId = accountId, include = include)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ObjectStoreResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/{version}/object/data/{objectName}/{objectId}
     * Get Data
     * Get a specific record from a specified object.
     * @param version 
     * @param objectName The name of the object to search upon
     * @param objectId objectId The id of the record to return
     * @param accountId The account id of the logged in user (optional)
     * @param include  (optional)
     * @return ApiResponse<ObjectStoreResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getDataWithHttpInfo(version: java.math.BigDecimal, objectName: kotlin.String, objectId: kotlin.String, accountId: kotlin.Long?, include: kotlin.String?) : ApiResponse<ObjectStoreResponse?> {
        val localVariableConfig = getDataRequestConfig(version = version, objectName = objectName, objectId = objectId, accountId = accountId, include = include)

        return request<Unit, ObjectStoreResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getData
     *
     * @param version 
     * @param objectName The name of the object to search upon
     * @param objectId objectId The id of the record to return
     * @param accountId The account id of the logged in user (optional)
     * @param include  (optional)
     * @return RequestConfig
     */
    fun getDataRequestConfig(version: java.math.BigDecimal, objectName: kotlin.String, objectId: kotlin.String, accountId: kotlin.Long?, include: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (include != null) {
                    put("include", listOf(include.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/{version}/object/data/{objectName}/{objectId}".replace("{"+"version"+"}", encodeURIComponent(version.toString())).replace("{"+"objectName"+"}", encodeURIComponent(objectName.toString())).replace("{"+"objectId"+"}", encodeURIComponent(objectId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /api/{version}/object/get
     * Get Object
     * Get the definition of an Object. Returns all field names, types, and current size. The types supported are: STRING, DATE, NUMBER, BOOLEAN, IDENTITY.
     * @param version 
     * @param accountId The account id of the logged in user
     * @param appKey The application key for updating an existing application
     * @param objectName The name of the object to get the definition for
     * @return ObjectStoreResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getObject(version: java.math.BigDecimal, accountId: kotlin.Long, appKey: kotlin.String, objectName: kotlin.String) : ObjectStoreResponse {
        val localVarResponse = getObjectWithHttpInfo(version = version, accountId = accountId, appKey = appKey, objectName = objectName)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ObjectStoreResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/{version}/object/get
     * Get Object
     * Get the definition of an Object. Returns all field names, types, and current size. The types supported are: STRING, DATE, NUMBER, BOOLEAN, IDENTITY.
     * @param version 
     * @param accountId The account id of the logged in user
     * @param appKey The application key for updating an existing application
     * @param objectName The name of the object to get the definition for
     * @return ApiResponse<ObjectStoreResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getObjectWithHttpInfo(version: java.math.BigDecimal, accountId: kotlin.Long, appKey: kotlin.String, objectName: kotlin.String) : ApiResponse<ObjectStoreResponse?> {
        val localVariableConfig = getObjectRequestConfig(version = version, accountId = accountId, appKey = appKey, objectName = objectName)

        return request<Unit, ObjectStoreResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getObject
     *
     * @param version 
     * @param accountId The account id of the logged in user
     * @param appKey The application key for updating an existing application
     * @param objectName The name of the object to get the definition for
     * @return RequestConfig
     */
    fun getObjectRequestConfig(version: java.math.BigDecimal, accountId: kotlin.Long, appKey: kotlin.String, objectName: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("appKey", listOf(appKey.toString()))
                put("objectName", listOf(objectName.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/{version}/object/get".replace("{"+"version"+"}", encodeURIComponent(version.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /api/{version}/object/data/{objectName}
     * Search Data
     * Search for records given the specified criteria.  The criteria is a defined set of json values used to build a query
     * @param version 
     * @param objectName The name of the object to search upon
     * @param count If true just return the record count of the search. False (default) will return the actual records
     * @param start The start of the pagination
     * @param limit The limit of the pagination
     * @param accountId The account id of the logged in user (optional)
     * @param criteria The search criteria (optional)
     * @param order The order of results; comma seperated list of field names. Illegal field names will be ignored. Direction by defualt is ascending. Prepend a minus to the field name to make that field descending. (optional)
     * @param include  (optional)
     * @return ObjectStoreResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun searchData(version: java.math.BigDecimal, objectName: kotlin.String, count: kotlin.Boolean, start: kotlin.Long, limit: kotlin.Long, accountId: kotlin.Long? = null, criteria: kotlin.String? = null, order: kotlin.String? = null, include: kotlin.String? = null) : ObjectStoreResponse {
        val localVarResponse = searchDataWithHttpInfo(version = version, objectName = objectName, count = count, start = start, limit = limit, accountId = accountId, criteria = criteria, order = order, include = include)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ObjectStoreResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/{version}/object/data/{objectName}
     * Search Data
     * Search for records given the specified criteria.  The criteria is a defined set of json values used to build a query
     * @param version 
     * @param objectName The name of the object to search upon
     * @param count If true just return the record count of the search. False (default) will return the actual records
     * @param start The start of the pagination
     * @param limit The limit of the pagination
     * @param accountId The account id of the logged in user (optional)
     * @param criteria The search criteria (optional)
     * @param order The order of results; comma seperated list of field names. Illegal field names will be ignored. Direction by defualt is ascending. Prepend a minus to the field name to make that field descending. (optional)
     * @param include  (optional)
     * @return ApiResponse<ObjectStoreResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun searchDataWithHttpInfo(version: java.math.BigDecimal, objectName: kotlin.String, count: kotlin.Boolean, start: kotlin.Long, limit: kotlin.Long, accountId: kotlin.Long?, criteria: kotlin.String?, order: kotlin.String?, include: kotlin.String?) : ApiResponse<ObjectStoreResponse?> {
        val localVariableConfig = searchDataRequestConfig(version = version, objectName = objectName, count = count, start = start, limit = limit, accountId = accountId, criteria = criteria, order = order, include = include)

        return request<Unit, ObjectStoreResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation searchData
     *
     * @param version 
     * @param objectName The name of the object to search upon
     * @param count If true just return the record count of the search. False (default) will return the actual records
     * @param start The start of the pagination
     * @param limit The limit of the pagination
     * @param accountId The account id of the logged in user (optional)
     * @param criteria The search criteria (optional)
     * @param order The order of results; comma seperated list of field names. Illegal field names will be ignored. Direction by defualt is ascending. Prepend a minus to the field name to make that field descending. (optional)
     * @param include  (optional)
     * @return RequestConfig
     */
    fun searchDataRequestConfig(version: java.math.BigDecimal, objectName: kotlin.String, count: kotlin.Boolean, start: kotlin.Long, limit: kotlin.Long, accountId: kotlin.Long?, criteria: kotlin.String?, order: kotlin.String?, include: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
                if (criteria != null) {
                    put("criteria", listOf(criteria.toString()))
                }
                put("count", listOf(count.toString()))
                put("start", listOf(start.toString()))
                put("limit", listOf(limit.toString()))
                if (order != null) {
                    put("order", listOf(order.toString()))
                }
                if (include != null) {
                    put("include", listOf(include.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/{version}/object/data/{objectName}".replace("{"+"version"+"}", encodeURIComponent(version.toString())).replace("{"+"objectName"+"}", encodeURIComponent(objectName.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /api/{version}/object/search
     * Search Objects
     * Search for Objects and return the list of names found.  Use this in conjunction with the object get service to present the current data model defined.
     * @param version 
     * @param accountId The account id of the logged in user
     * @param appKey The application key for updating an existing application
     * @param start The start of the pagination
     * @param limit The limit of the pagination
     * @param keyword The name of the object(s) to search for, can be a partial match (optional)
     * @return ObjectStoreResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun searchObject(version: java.math.BigDecimal, accountId: kotlin.Long, appKey: kotlin.String, start: kotlin.Long, limit: kotlin.Long, keyword: kotlin.String? = null) : ObjectStoreResponse {
        val localVarResponse = searchObjectWithHttpInfo(version = version, accountId = accountId, appKey = appKey, start = start, limit = limit, keyword = keyword)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ObjectStoreResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/{version}/object/search
     * Search Objects
     * Search for Objects and return the list of names found.  Use this in conjunction with the object get service to present the current data model defined.
     * @param version 
     * @param accountId The account id of the logged in user
     * @param appKey The application key for updating an existing application
     * @param start The start of the pagination
     * @param limit The limit of the pagination
     * @param keyword The name of the object(s) to search for, can be a partial match (optional)
     * @return ApiResponse<ObjectStoreResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun searchObjectWithHttpInfo(version: java.math.BigDecimal, accountId: kotlin.Long, appKey: kotlin.String, start: kotlin.Long, limit: kotlin.Long, keyword: kotlin.String?) : ApiResponse<ObjectStoreResponse?> {
        val localVariableConfig = searchObjectRequestConfig(version = version, accountId = accountId, appKey = appKey, start = start, limit = limit, keyword = keyword)

        return request<Unit, ObjectStoreResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation searchObject
     *
     * @param version 
     * @param accountId The account id of the logged in user
     * @param appKey The application key for updating an existing application
     * @param start The start of the pagination
     * @param limit The limit of the pagination
     * @param keyword The name of the object(s) to search for, can be a partial match (optional)
     * @return RequestConfig
     */
    fun searchObjectRequestConfig(version: java.math.BigDecimal, accountId: kotlin.Long, appKey: kotlin.String, start: kotlin.Long, limit: kotlin.Long, keyword: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("appKey", listOf(appKey.toString()))
                if (keyword != null) {
                    put("keyword", listOf(keyword.toString()))
                }
                put("start", listOf(start.toString()))
                put("limit", listOf(limit.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/{version}/object/search".replace("{"+"version"+"}", encodeURIComponent(version.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * PUT /api/{version}/object/data/{objectName}/{objectId}
     * Update Data
     * Update a record for the specified object.  If the object does not exist the request will be rejected, use the data create service for the first entry. If any of the fields included does not exist for the object then they are added to the object.
     * @param version 
     * @param objectName The name of the object to search upon
     * @param objectId objectId The id of the record to return
     * @param accountId The account id of the logged in user (optional)
     * @param body  (optional)
     * @return ObjectStoreResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updateData(version: java.math.BigDecimal, objectName: kotlin.String, objectId: kotlin.String, accountId: kotlin.Long? = null, body: kotlin.String? = null) : ObjectStoreResponse {
        val localVarResponse = updateDataWithHttpInfo(version = version, objectName = objectName, objectId = objectId, accountId = accountId, body = body)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ObjectStoreResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * PUT /api/{version}/object/data/{objectName}/{objectId}
     * Update Data
     * Update a record for the specified object.  If the object does not exist the request will be rejected, use the data create service for the first entry. If any of the fields included does not exist for the object then they are added to the object.
     * @param version 
     * @param objectName The name of the object to search upon
     * @param objectId objectId The id of the record to return
     * @param accountId The account id of the logged in user (optional)
     * @param body  (optional)
     * @return ApiResponse<ObjectStoreResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun updateDataWithHttpInfo(version: java.math.BigDecimal, objectName: kotlin.String, objectId: kotlin.String, accountId: kotlin.Long?, body: kotlin.String?) : ApiResponse<ObjectStoreResponse?> {
        val localVariableConfig = updateDataRequestConfig(version = version, objectName = objectName, objectId = objectId, accountId = accountId, body = body)

        return request<kotlin.String, ObjectStoreResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateData
     *
     * @param version 
     * @param objectName The name of the object to search upon
     * @param objectId objectId The id of the record to return
     * @param accountId The account id of the logged in user (optional)
     * @param body  (optional)
     * @return RequestConfig
     */
    fun updateDataRequestConfig(version: java.math.BigDecimal, objectName: kotlin.String, objectId: kotlin.String, accountId: kotlin.Long?, body: kotlin.String?) : RequestConfig<kotlin.String> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (accountId != null) {
                    put("accountId", listOf(accountId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/{version}/object/data/{objectName}/{objectId}".replace("{"+"version"+"}", encodeURIComponent(version.toString())).replace("{"+"objectName"+"}", encodeURIComponent(objectName.toString())).replace("{"+"objectId"+"}", encodeURIComponent(objectId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
