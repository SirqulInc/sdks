/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import org.openapitools.client.models.SirqulResponse
import org.openapitools.client.models.WordzWordResponse

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

open class WordApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost")
        }
    }

    /**
     * POST /api/{version}/game/word/create
     * Create Word
     * Create a word by the given params.
     * @param version 
     * @param accountId The logged in user.
     * @param word The text of the word.
     * @param definition The definition of the word.
     * @param active If true set the word to active. Default to false. (default to false)
     * @param allocateTickets If true then scoring will give tickets. Default to false. (default to false)
     * @param ticketCount The number of tickets to reward (default to 0L)
     * @param assetId The asset id of the word. (optional)
     * @param ticketType The type of ticket to reward, null means default type (optional)
     * @param points The number of points to award for completing a mission (optional)
     * @return WordzWordResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createWord(version: java.math.BigDecimal, accountId: kotlin.Long, word: kotlin.String, definition: kotlin.String, active: kotlin.Boolean = false, allocateTickets: kotlin.Boolean = false, ticketCount: kotlin.Long = 0L, assetId: kotlin.Long? = null, ticketType: kotlin.String? = null, points: kotlin.Long? = null) : WordzWordResponse {
        val localVarResponse = createWordWithHttpInfo(version = version, accountId = accountId, word = word, definition = definition, active = active, allocateTickets = allocateTickets, ticketCount = ticketCount, assetId = assetId, ticketType = ticketType, points = points)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as WordzWordResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/{version}/game/word/create
     * Create Word
     * Create a word by the given params.
     * @param version 
     * @param accountId The logged in user.
     * @param word The text of the word.
     * @param definition The definition of the word.
     * @param active If true set the word to active. Default to false. (default to false)
     * @param allocateTickets If true then scoring will give tickets. Default to false. (default to false)
     * @param ticketCount The number of tickets to reward (default to 0L)
     * @param assetId The asset id of the word. (optional)
     * @param ticketType The type of ticket to reward, null means default type (optional)
     * @param points The number of points to award for completing a mission (optional)
     * @return ApiResponse<WordzWordResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createWordWithHttpInfo(version: java.math.BigDecimal, accountId: kotlin.Long, word: kotlin.String, definition: kotlin.String, active: kotlin.Boolean, allocateTickets: kotlin.Boolean, ticketCount: kotlin.Long, assetId: kotlin.Long?, ticketType: kotlin.String?, points: kotlin.Long?) : ApiResponse<WordzWordResponse?> {
        val localVariableConfig = createWordRequestConfig(version = version, accountId = accountId, word = word, definition = definition, active = active, allocateTickets = allocateTickets, ticketCount = ticketCount, assetId = assetId, ticketType = ticketType, points = points)

        return request<Unit, WordzWordResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createWord
     *
     * @param version 
     * @param accountId The logged in user.
     * @param word The text of the word.
     * @param definition The definition of the word.
     * @param active If true set the word to active. Default to false. (default to false)
     * @param allocateTickets If true then scoring will give tickets. Default to false. (default to false)
     * @param ticketCount The number of tickets to reward (default to 0L)
     * @param assetId The asset id of the word. (optional)
     * @param ticketType The type of ticket to reward, null means default type (optional)
     * @param points The number of points to award for completing a mission (optional)
     * @return RequestConfig
     */
    fun createWordRequestConfig(version: java.math.BigDecimal, accountId: kotlin.Long, word: kotlin.String, definition: kotlin.String, active: kotlin.Boolean, allocateTickets: kotlin.Boolean, ticketCount: kotlin.Long, assetId: kotlin.Long?, ticketType: kotlin.String?, points: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("word", listOf(word.toString()))
                put("definition", listOf(definition.toString()))
                if (assetId != null) {
                    put("assetId", listOf(assetId.toString()))
                }
                put("active", listOf(active.toString()))
                put("allocateTickets", listOf(allocateTickets.toString()))
                put("ticketCount", listOf(ticketCount.toString()))
                if (ticketType != null) {
                    put("ticketType", listOf(ticketType.toString()))
                }
                if (points != null) {
                    put("points", listOf(points.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/{version}/game/word/create".replace("{"+"version"+"}", encodeURIComponent(version.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * DELETE /api/{version}/game/word/delete
     * Delete Word
     * Delete a word by the given id. The accountId given needs to be the owner or executive to delete.
     * @param version 
     * @param wordId The id of the word to delete.
     * @param accountId The account vor validating permission
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteWord(version: java.math.BigDecimal, wordId: kotlin.Long, accountId: kotlin.Long) : SirqulResponse {
        val localVarResponse = deleteWordWithHttpInfo(version = version, wordId = wordId, accountId = accountId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * DELETE /api/{version}/game/word/delete
     * Delete Word
     * Delete a word by the given id. The accountId given needs to be the owner or executive to delete.
     * @param version 
     * @param wordId The id of the word to delete.
     * @param accountId The account vor validating permission
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteWordWithHttpInfo(version: java.math.BigDecimal, wordId: kotlin.Long, accountId: kotlin.Long) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = deleteWordRequestConfig(version = version, wordId = wordId, accountId = accountId)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteWord
     *
     * @param version 
     * @param wordId The id of the word to delete.
     * @param accountId The account vor validating permission
     * @return RequestConfig
     */
    fun deleteWordRequestConfig(version: java.math.BigDecimal, wordId: kotlin.Long, accountId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("wordId", listOf(wordId.toString()))
                put("accountId", listOf(accountId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/{version}/game/word/delete".replace("{"+"version"+"}", encodeURIComponent(version.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /api/{version}/game/word/get
     * Get Word
     * Get a word by the given id.
     * @param version 
     * @param wordId The id of the word to get.
     * @param accountId The logged in user.
     * @return WordzWordResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getWord(version: java.math.BigDecimal, wordId: kotlin.Long, accountId: kotlin.Long) : WordzWordResponse {
        val localVarResponse = getWordWithHttpInfo(version = version, wordId = wordId, accountId = accountId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as WordzWordResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/{version}/game/word/get
     * Get Word
     * Get a word by the given id.
     * @param version 
     * @param wordId The id of the word to get.
     * @param accountId The logged in user.
     * @return ApiResponse<WordzWordResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getWordWithHttpInfo(version: java.math.BigDecimal, wordId: kotlin.Long, accountId: kotlin.Long) : ApiResponse<WordzWordResponse?> {
        val localVariableConfig = getWordRequestConfig(version = version, wordId = wordId, accountId = accountId)

        return request<Unit, WordzWordResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getWord
     *
     * @param version 
     * @param wordId The id of the word to get.
     * @param accountId The logged in user.
     * @return RequestConfig
     */
    fun getWordRequestConfig(version: java.math.BigDecimal, wordId: kotlin.Long, accountId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("wordId", listOf(wordId.toString()))
                put("accountId", listOf(accountId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/{version}/game/word/get".replace("{"+"version"+"}", encodeURIComponent(version.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /api/{version}/game/word/search
     * Search Words
     * Search for words by the given params.
     * @param version 
     * @param accountId The logged in user.
     * @param sortField The column to sort the search on (default to "id")
     * @param descending The order to return the search results (default to false)
     * @param activeOnly Return only active results if set to true. (default to false)
     * @param start The record to begin the return set on. (default to 0)
     * @param limit The number of records to return. (default to 20)
     * @param keyword The keyword for searching words with matching definition or word text. (optional)
     * @return kotlin.collections.List<WordzWordResponse>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getWords(version: java.math.BigDecimal, accountId: kotlin.Long, sortField: kotlin.String = "id", descending: kotlin.Boolean = false, activeOnly: kotlin.Boolean = false, start: kotlin.Int = 0, limit: kotlin.Int = 20, keyword: kotlin.String? = null) : kotlin.collections.List<WordzWordResponse> {
        val localVarResponse = getWordsWithHttpInfo(version = version, accountId = accountId, sortField = sortField, descending = descending, activeOnly = activeOnly, start = start, limit = limit, keyword = keyword)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<WordzWordResponse>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/{version}/game/word/search
     * Search Words
     * Search for words by the given params.
     * @param version 
     * @param accountId The logged in user.
     * @param sortField The column to sort the search on (default to "id")
     * @param descending The order to return the search results (default to false)
     * @param activeOnly Return only active results if set to true. (default to false)
     * @param start The record to begin the return set on. (default to 0)
     * @param limit The number of records to return. (default to 20)
     * @param keyword The keyword for searching words with matching definition or word text. (optional)
     * @return ApiResponse<kotlin.collections.List<WordzWordResponse>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getWordsWithHttpInfo(version: java.math.BigDecimal, accountId: kotlin.Long, sortField: kotlin.String, descending: kotlin.Boolean, activeOnly: kotlin.Boolean, start: kotlin.Int, limit: kotlin.Int, keyword: kotlin.String?) : ApiResponse<kotlin.collections.List<WordzWordResponse>?> {
        val localVariableConfig = getWordsRequestConfig(version = version, accountId = accountId, sortField = sortField, descending = descending, activeOnly = activeOnly, start = start, limit = limit, keyword = keyword)

        return request<Unit, kotlin.collections.List<WordzWordResponse>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getWords
     *
     * @param version 
     * @param accountId The logged in user.
     * @param sortField The column to sort the search on (default to "id")
     * @param descending The order to return the search results (default to false)
     * @param activeOnly Return only active results if set to true. (default to false)
     * @param start The record to begin the return set on. (default to 0)
     * @param limit The number of records to return. (default to 20)
     * @param keyword The keyword for searching words with matching definition or word text. (optional)
     * @return RequestConfig
     */
    fun getWordsRequestConfig(version: java.math.BigDecimal, accountId: kotlin.Long, sortField: kotlin.String, descending: kotlin.Boolean, activeOnly: kotlin.Boolean, start: kotlin.Int, limit: kotlin.Int, keyword: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                if (keyword != null) {
                    put("keyword", listOf(keyword.toString()))
                }
                put("sortField", listOf(sortField.toString()))
                put("descending", listOf(descending.toString()))
                put("activeOnly", listOf(activeOnly.toString()))
                put("start", listOf(start.toString()))
                put("limit", listOf(limit.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/{version}/game/word/search".replace("{"+"version"+"}", encodeURIComponent(version.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/{version}/game/word/update
     * Update Word
     * Update a word by the given params.
     * @param version 
     * @param wordId The id of the word to update.
     * @param accountId The logged in user.
     * @param ticketCount The number of tickets to reward (default to 0L)
     * @param wordText The text for the word (optional)
     * @param definition The definition of the word. (optional)
     * @param assetId The asset id of the word. (optional)
     * @param active If true set the word to active. (optional)
     * @param allocateTickets If true then scoring will give tickets. (optional)
     * @param ticketType The type of ticket to reward, null means default type (optional)
     * @param points The number of points to award for completing a mission (optional)
     * @return WordzWordResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updateWord(version: java.math.BigDecimal, wordId: kotlin.Long, accountId: kotlin.Long, ticketCount: kotlin.Long = 0L, wordText: kotlin.String? = null, definition: kotlin.String? = null, assetId: kotlin.Long? = null, active: kotlin.Boolean? = null, allocateTickets: kotlin.Boolean? = null, ticketType: kotlin.String? = null, points: kotlin.Long? = null) : WordzWordResponse {
        val localVarResponse = updateWordWithHttpInfo(version = version, wordId = wordId, accountId = accountId, ticketCount = ticketCount, wordText = wordText, definition = definition, assetId = assetId, active = active, allocateTickets = allocateTickets, ticketType = ticketType, points = points)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as WordzWordResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/{version}/game/word/update
     * Update Word
     * Update a word by the given params.
     * @param version 
     * @param wordId The id of the word to update.
     * @param accountId The logged in user.
     * @param ticketCount The number of tickets to reward (default to 0L)
     * @param wordText The text for the word (optional)
     * @param definition The definition of the word. (optional)
     * @param assetId The asset id of the word. (optional)
     * @param active If true set the word to active. (optional)
     * @param allocateTickets If true then scoring will give tickets. (optional)
     * @param ticketType The type of ticket to reward, null means default type (optional)
     * @param points The number of points to award for completing a mission (optional)
     * @return ApiResponse<WordzWordResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun updateWordWithHttpInfo(version: java.math.BigDecimal, wordId: kotlin.Long, accountId: kotlin.Long, ticketCount: kotlin.Long, wordText: kotlin.String?, definition: kotlin.String?, assetId: kotlin.Long?, active: kotlin.Boolean?, allocateTickets: kotlin.Boolean?, ticketType: kotlin.String?, points: kotlin.Long?) : ApiResponse<WordzWordResponse?> {
        val localVariableConfig = updateWordRequestConfig(version = version, wordId = wordId, accountId = accountId, ticketCount = ticketCount, wordText = wordText, definition = definition, assetId = assetId, active = active, allocateTickets = allocateTickets, ticketType = ticketType, points = points)

        return request<Unit, WordzWordResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateWord
     *
     * @param version 
     * @param wordId The id of the word to update.
     * @param accountId The logged in user.
     * @param ticketCount The number of tickets to reward (default to 0L)
     * @param wordText The text for the word (optional)
     * @param definition The definition of the word. (optional)
     * @param assetId The asset id of the word. (optional)
     * @param active If true set the word to active. (optional)
     * @param allocateTickets If true then scoring will give tickets. (optional)
     * @param ticketType The type of ticket to reward, null means default type (optional)
     * @param points The number of points to award for completing a mission (optional)
     * @return RequestConfig
     */
    fun updateWordRequestConfig(version: java.math.BigDecimal, wordId: kotlin.Long, accountId: kotlin.Long, ticketCount: kotlin.Long, wordText: kotlin.String?, definition: kotlin.String?, assetId: kotlin.Long?, active: kotlin.Boolean?, allocateTickets: kotlin.Boolean?, ticketType: kotlin.String?, points: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("wordId", listOf(wordId.toString()))
                put("accountId", listOf(accountId.toString()))
                if (wordText != null) {
                    put("wordText", listOf(wordText.toString()))
                }
                if (definition != null) {
                    put("definition", listOf(definition.toString()))
                }
                if (assetId != null) {
                    put("assetId", listOf(assetId.toString()))
                }
                if (active != null) {
                    put("active", listOf(active.toString()))
                }
                if (allocateTickets != null) {
                    put("allocateTickets", listOf(allocateTickets.toString()))
                }
                put("ticketCount", listOf(ticketCount.toString()))
                if (ticketType != null) {
                    put("ticketType", listOf(ticketType.toString()))
                }
                if (points != null) {
                    put("points", listOf(points.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/{version}/game/word/update".replace("{"+"version"+"}", encodeURIComponent(version.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
