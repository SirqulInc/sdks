/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import org.openapitools.client.models.QuestionResponse
import org.openapitools.client.models.SirqulResponse

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

open class QuestionApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost")
        }
    }

    /**
     * POST /api/{version}/game/question/create
     * Create Question
     * Create a question and related answers by the given params.
     * @param version 
     * @param accountId the id of the logged in user
     * @param question the text of the question
     * @param answers &#x60;&#x60;&#x60;json [   {     \&quot;text\&quot;: \&quot;1942\&quot;,     \&quot;image\&quot;: 123,     \&quot;videoURL\&quot;: \&quot;http://www.here.com\&quot;,     \&quot;correct\&quot;: true   },   {     \&quot;text\&quot;: \&quot;1943\&quot;,     \&quot;image\&quot;: 124,     \&quot;videoURL\&quot;: \&quot;http://www.there.com\&quot;,     \&quot;correct\&quot;: false   } ] &#x60;&#x60;&#x60; 
     * @param active If true set the question to active. Default to false.
     * @param allocateTickets If true then scoring will give tickets. Default to false.
     * @param ticketCount The number of tickets to reward
     * @param tags The tags of the question for search. (optional)
     * @param videoURL The video link for the question. (optional)
     * @param assetId The asset id of the question. (optional)
     * @param ticketType The type of ticket to reward, null means default type (optional)
     * @param points The number of points to award for completing a mission (optional)
     * @return QuestionResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createQuestion(version: java.math.BigDecimal, accountId: kotlin.Long, question: kotlin.String, answers: kotlin.String, active: kotlin.Boolean, allocateTickets: kotlin.Boolean, ticketCount: kotlin.Long, tags: kotlin.String? = null, videoURL: kotlin.String? = null, assetId: kotlin.Long? = null, ticketType: kotlin.String? = null, points: kotlin.Long? = null) : QuestionResponse {
        val localVarResponse = createQuestionWithHttpInfo(version = version, accountId = accountId, question = question, answers = answers, active = active, allocateTickets = allocateTickets, ticketCount = ticketCount, tags = tags, videoURL = videoURL, assetId = assetId, ticketType = ticketType, points = points)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as QuestionResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/{version}/game/question/create
     * Create Question
     * Create a question and related answers by the given params.
     * @param version 
     * @param accountId the id of the logged in user
     * @param question the text of the question
     * @param answers &#x60;&#x60;&#x60;json [   {     \&quot;text\&quot;: \&quot;1942\&quot;,     \&quot;image\&quot;: 123,     \&quot;videoURL\&quot;: \&quot;http://www.here.com\&quot;,     \&quot;correct\&quot;: true   },   {     \&quot;text\&quot;: \&quot;1943\&quot;,     \&quot;image\&quot;: 124,     \&quot;videoURL\&quot;: \&quot;http://www.there.com\&quot;,     \&quot;correct\&quot;: false   } ] &#x60;&#x60;&#x60; 
     * @param active If true set the question to active. Default to false.
     * @param allocateTickets If true then scoring will give tickets. Default to false.
     * @param ticketCount The number of tickets to reward
     * @param tags The tags of the question for search. (optional)
     * @param videoURL The video link for the question. (optional)
     * @param assetId The asset id of the question. (optional)
     * @param ticketType The type of ticket to reward, null means default type (optional)
     * @param points The number of points to award for completing a mission (optional)
     * @return ApiResponse<QuestionResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createQuestionWithHttpInfo(version: java.math.BigDecimal, accountId: kotlin.Long, question: kotlin.String, answers: kotlin.String, active: kotlin.Boolean, allocateTickets: kotlin.Boolean, ticketCount: kotlin.Long, tags: kotlin.String?, videoURL: kotlin.String?, assetId: kotlin.Long?, ticketType: kotlin.String?, points: kotlin.Long?) : ApiResponse<QuestionResponse?> {
        val localVariableConfig = createQuestionRequestConfig(version = version, accountId = accountId, question = question, answers = answers, active = active, allocateTickets = allocateTickets, ticketCount = ticketCount, tags = tags, videoURL = videoURL, assetId = assetId, ticketType = ticketType, points = points)

        return request<Unit, QuestionResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createQuestion
     *
     * @param version 
     * @param accountId the id of the logged in user
     * @param question the text of the question
     * @param answers &#x60;&#x60;&#x60;json [   {     \&quot;text\&quot;: \&quot;1942\&quot;,     \&quot;image\&quot;: 123,     \&quot;videoURL\&quot;: \&quot;http://www.here.com\&quot;,     \&quot;correct\&quot;: true   },   {     \&quot;text\&quot;: \&quot;1943\&quot;,     \&quot;image\&quot;: 124,     \&quot;videoURL\&quot;: \&quot;http://www.there.com\&quot;,     \&quot;correct\&quot;: false   } ] &#x60;&#x60;&#x60; 
     * @param active If true set the question to active. Default to false.
     * @param allocateTickets If true then scoring will give tickets. Default to false.
     * @param ticketCount The number of tickets to reward
     * @param tags The tags of the question for search. (optional)
     * @param videoURL The video link for the question. (optional)
     * @param assetId The asset id of the question. (optional)
     * @param ticketType The type of ticket to reward, null means default type (optional)
     * @param points The number of points to award for completing a mission (optional)
     * @return RequestConfig
     */
    fun createQuestionRequestConfig(version: java.math.BigDecimal, accountId: kotlin.Long, question: kotlin.String, answers: kotlin.String, active: kotlin.Boolean, allocateTickets: kotlin.Boolean, ticketCount: kotlin.Long, tags: kotlin.String?, videoURL: kotlin.String?, assetId: kotlin.Long?, ticketType: kotlin.String?, points: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                put("question", listOf(question.toString()))
                put("answers", listOf(answers.toString()))
                if (tags != null) {
                    put("tags", listOf(tags.toString()))
                }
                if (videoURL != null) {
                    put("videoURL", listOf(videoURL.toString()))
                }
                if (assetId != null) {
                    put("assetId", listOf(assetId.toString()))
                }
                put("active", listOf(active.toString()))
                put("allocateTickets", listOf(allocateTickets.toString()))
                put("ticketCount", listOf(ticketCount.toString()))
                if (ticketType != null) {
                    put("ticketType", listOf(ticketType.toString()))
                }
                if (points != null) {
                    put("points", listOf(points.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/{version}/game/question/create".replace("{"+"version"+"}", encodeURIComponent(version.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/{version}/game/question/delete
     * Delete Question
     * Delete a question by the given questionId. The accountId given needs to be the owner or executive to delete.
     * @param version 
     * @param questionId the id of the question to delete
     * @param accountId the id of the account that can execute this request
     * @return SirqulResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteQuestion(version: java.math.BigDecimal, questionId: kotlin.Long, accountId: kotlin.Long) : SirqulResponse {
        val localVarResponse = deleteQuestionWithHttpInfo(version = version, questionId = questionId, accountId = accountId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SirqulResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/{version}/game/question/delete
     * Delete Question
     * Delete a question by the given questionId. The accountId given needs to be the owner or executive to delete.
     * @param version 
     * @param questionId the id of the question to delete
     * @param accountId the id of the account that can execute this request
     * @return ApiResponse<SirqulResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteQuestionWithHttpInfo(version: java.math.BigDecimal, questionId: kotlin.Long, accountId: kotlin.Long) : ApiResponse<SirqulResponse?> {
        val localVariableConfig = deleteQuestionRequestConfig(version = version, questionId = questionId, accountId = accountId)

        return request<Unit, SirqulResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteQuestion
     *
     * @param version 
     * @param questionId the id of the question to delete
     * @param accountId the id of the account that can execute this request
     * @return RequestConfig
     */
    fun deleteQuestionRequestConfig(version: java.math.BigDecimal, questionId: kotlin.Long, accountId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("questionId", listOf(questionId.toString()))
                put("accountId", listOf(accountId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/{version}/game/question/delete".replace("{"+"version"+"}", encodeURIComponent(version.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /api/{version}/game/question/get
     * Get Question
     * Get a question by the given id.
     * @param version 
     * @param questionId the id of the question to get
     * @param accountId the id of the account that can make this request
     * @return QuestionResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getQuestion(version: java.math.BigDecimal, questionId: kotlin.Long, accountId: kotlin.Long) : QuestionResponse {
        val localVarResponse = getQuestionWithHttpInfo(version = version, questionId = questionId, accountId = accountId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as QuestionResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/{version}/game/question/get
     * Get Question
     * Get a question by the given id.
     * @param version 
     * @param questionId the id of the question to get
     * @param accountId the id of the account that can make this request
     * @return ApiResponse<QuestionResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getQuestionWithHttpInfo(version: java.math.BigDecimal, questionId: kotlin.Long, accountId: kotlin.Long) : ApiResponse<QuestionResponse?> {
        val localVariableConfig = getQuestionRequestConfig(version = version, questionId = questionId, accountId = accountId)

        return request<Unit, QuestionResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getQuestion
     *
     * @param version 
     * @param questionId the id of the question to get
     * @param accountId the id of the account that can make this request
     * @return RequestConfig
     */
    fun getQuestionRequestConfig(version: java.math.BigDecimal, questionId: kotlin.Long, accountId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("questionId", listOf(questionId.toString()))
                put("accountId", listOf(accountId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/{version}/game/question/get".replace("{"+"version"+"}", encodeURIComponent(version.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /api/{version}/game/question/search
     * Search Questions
     * Search for questions by the given params.
     * @param version 
     * @param accountId The logged in user.
     * @param sortField The column to sort the search on
     * @param descending The order to return the search results
     * @param activeOnly Return only active results if set to true.
     * @param start The record to begin the return set on.
     * @param limit The number of records to return.
     * @param keyword The keyword for searching questions with matching tags or question text. (optional)
     * @return kotlin.collections.List<QuestionResponse>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun searchQuestions(version: java.math.BigDecimal, accountId: kotlin.Long, sortField: kotlin.String, descending: kotlin.Boolean, activeOnly: kotlin.Boolean, start: kotlin.Int, limit: kotlin.Int, keyword: kotlin.String? = null) : kotlin.collections.List<QuestionResponse> {
        val localVarResponse = searchQuestionsWithHttpInfo(version = version, accountId = accountId, sortField = sortField, descending = descending, activeOnly = activeOnly, start = start, limit = limit, keyword = keyword)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<QuestionResponse>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/{version}/game/question/search
     * Search Questions
     * Search for questions by the given params.
     * @param version 
     * @param accountId The logged in user.
     * @param sortField The column to sort the search on
     * @param descending The order to return the search results
     * @param activeOnly Return only active results if set to true.
     * @param start The record to begin the return set on.
     * @param limit The number of records to return.
     * @param keyword The keyword for searching questions with matching tags or question text. (optional)
     * @return ApiResponse<kotlin.collections.List<QuestionResponse>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun searchQuestionsWithHttpInfo(version: java.math.BigDecimal, accountId: kotlin.Long, sortField: kotlin.String, descending: kotlin.Boolean, activeOnly: kotlin.Boolean, start: kotlin.Int, limit: kotlin.Int, keyword: kotlin.String?) : ApiResponse<kotlin.collections.List<QuestionResponse>?> {
        val localVariableConfig = searchQuestionsRequestConfig(version = version, accountId = accountId, sortField = sortField, descending = descending, activeOnly = activeOnly, start = start, limit = limit, keyword = keyword)

        return request<Unit, kotlin.collections.List<QuestionResponse>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation searchQuestions
     *
     * @param version 
     * @param accountId The logged in user.
     * @param sortField The column to sort the search on
     * @param descending The order to return the search results
     * @param activeOnly Return only active results if set to true.
     * @param start The record to begin the return set on.
     * @param limit The number of records to return.
     * @param keyword The keyword for searching questions with matching tags or question text. (optional)
     * @return RequestConfig
     */
    fun searchQuestionsRequestConfig(version: java.math.BigDecimal, accountId: kotlin.Long, sortField: kotlin.String, descending: kotlin.Boolean, activeOnly: kotlin.Boolean, start: kotlin.Int, limit: kotlin.Int, keyword: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("accountId", listOf(accountId.toString()))
                if (keyword != null) {
                    put("keyword", listOf(keyword.toString()))
                }
                put("sortField", listOf(sortField.toString()))
                put("descending", listOf(descending.toString()))
                put("activeOnly", listOf(activeOnly.toString()))
                put("start", listOf(start.toString()))
                put("limit", listOf(limit.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/{version}/game/question/search".replace("{"+"version"+"}", encodeURIComponent(version.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/{version}/game/question/update
     * Update Question
     * Update a question and related answers.
     * @param version 
     * @param questionId The id of the question to update.
     * @param accountId The logged in user.
     * @param ticketCount The number of tickets to reward
     * @param question The text of the question. (optional)
     * @param answers The json representations of answers for the question. (optional)
     * @param tags The tags of the question for search. (optional)
     * @param videoURL The video link for the question. (optional)
     * @param assetId The asset id of the question. (optional)
     * @param active If true set the question to active. (optional)
     * @param allocateTickets If true then scoring will give tickets. (optional)
     * @param ticketType The type of ticket to reward, null means default type (optional)
     * @param points The number of points to award for completing a mission (optional)
     * @return QuestionResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updateQuestion(version: java.math.BigDecimal, questionId: kotlin.Long, accountId: kotlin.Long, ticketCount: kotlin.Long, question: kotlin.String? = null, answers: kotlin.String? = null, tags: kotlin.String? = null, videoURL: kotlin.String? = null, assetId: kotlin.Long? = null, active: kotlin.Boolean? = null, allocateTickets: kotlin.Boolean? = null, ticketType: kotlin.String? = null, points: kotlin.Long? = null) : QuestionResponse {
        val localVarResponse = updateQuestionWithHttpInfo(version = version, questionId = questionId, accountId = accountId, ticketCount = ticketCount, question = question, answers = answers, tags = tags, videoURL = videoURL, assetId = assetId, active = active, allocateTickets = allocateTickets, ticketType = ticketType, points = points)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as QuestionResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/{version}/game/question/update
     * Update Question
     * Update a question and related answers.
     * @param version 
     * @param questionId The id of the question to update.
     * @param accountId The logged in user.
     * @param ticketCount The number of tickets to reward
     * @param question The text of the question. (optional)
     * @param answers The json representations of answers for the question. (optional)
     * @param tags The tags of the question for search. (optional)
     * @param videoURL The video link for the question. (optional)
     * @param assetId The asset id of the question. (optional)
     * @param active If true set the question to active. (optional)
     * @param allocateTickets If true then scoring will give tickets. (optional)
     * @param ticketType The type of ticket to reward, null means default type (optional)
     * @param points The number of points to award for completing a mission (optional)
     * @return ApiResponse<QuestionResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun updateQuestionWithHttpInfo(version: java.math.BigDecimal, questionId: kotlin.Long, accountId: kotlin.Long, ticketCount: kotlin.Long, question: kotlin.String?, answers: kotlin.String?, tags: kotlin.String?, videoURL: kotlin.String?, assetId: kotlin.Long?, active: kotlin.Boolean?, allocateTickets: kotlin.Boolean?, ticketType: kotlin.String?, points: kotlin.Long?) : ApiResponse<QuestionResponse?> {
        val localVariableConfig = updateQuestionRequestConfig(version = version, questionId = questionId, accountId = accountId, ticketCount = ticketCount, question = question, answers = answers, tags = tags, videoURL = videoURL, assetId = assetId, active = active, allocateTickets = allocateTickets, ticketType = ticketType, points = points)

        return request<Unit, QuestionResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateQuestion
     *
     * @param version 
     * @param questionId The id of the question to update.
     * @param accountId The logged in user.
     * @param ticketCount The number of tickets to reward
     * @param question The text of the question. (optional)
     * @param answers The json representations of answers for the question. (optional)
     * @param tags The tags of the question for search. (optional)
     * @param videoURL The video link for the question. (optional)
     * @param assetId The asset id of the question. (optional)
     * @param active If true set the question to active. (optional)
     * @param allocateTickets If true then scoring will give tickets. (optional)
     * @param ticketType The type of ticket to reward, null means default type (optional)
     * @param points The number of points to award for completing a mission (optional)
     * @return RequestConfig
     */
    fun updateQuestionRequestConfig(version: java.math.BigDecimal, questionId: kotlin.Long, accountId: kotlin.Long, ticketCount: kotlin.Long, question: kotlin.String?, answers: kotlin.String?, tags: kotlin.String?, videoURL: kotlin.String?, assetId: kotlin.Long?, active: kotlin.Boolean?, allocateTickets: kotlin.Boolean?, ticketType: kotlin.String?, points: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("questionId", listOf(questionId.toString()))
                put("accountId", listOf(accountId.toString()))
                if (question != null) {
                    put("question", listOf(question.toString()))
                }
                if (answers != null) {
                    put("answers", listOf(answers.toString()))
                }
                if (tags != null) {
                    put("tags", listOf(tags.toString()))
                }
                if (videoURL != null) {
                    put("videoURL", listOf(videoURL.toString()))
                }
                if (assetId != null) {
                    put("assetId", listOf(assetId.toString()))
                }
                if (active != null) {
                    put("active", listOf(active.toString()))
                }
                if (allocateTickets != null) {
                    put("allocateTickets", listOf(allocateTickets.toString()))
                }
                put("ticketCount", listOf(ticketCount.toString()))
                if (ticketType != null) {
                    put("ticketType", listOf(ticketType.toString()))
                }
                if (points != null) {
                    put("points", listOf(points.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/{version}/game/question/update".replace("{"+"version"+"}", encodeURIComponent(version.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
