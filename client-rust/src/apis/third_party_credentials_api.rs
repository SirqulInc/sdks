/*
 * Sirqul IoT Platform
 *
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`create_credential`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateCredentialError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_network`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateNetworkError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_credential`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteCredentialError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_network`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteNetworkError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_credential`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetCredentialError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_network`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetNetworkError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_credentials`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchCredentialsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_networks`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchNetworksError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`send_mfa_challenge`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SendMfaChallengeError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_credential`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateCredentialError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_network`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateNetworkError {
    UnknownValue(serde_json::Value),
}


/// This endpoint creates a third-party login for a Sirqul account. A third party login is a way for external systems (Third Party Networks) to link their own user accounts with a Sirqul account.   The thirdPartyId parameter is used to determine if the user already exists in Sirqul or not. This parameter needs to be unique for each user in the Third Party Network (identified by the networkUID parameter). Note that subsequent calls will update the user's third-party login credentials for the user with the same thirdPartyId and networkUID combination.    The thirdPartyToken parameter acts as a shared secret and used by client applications to log users into Sirqul without providing a Sirqul username and password. 
pub async fn create_credential(configuration: &configuration::Configuration, version: f64, third_party_id: &str, third_party_token: &str, network_uid: &str, app_key: &str, account_id: Option<i64>, device_id: Option<&str>, session_id: Option<&str>, third_party_name: Option<&str>, email_address: Option<&str>, signin_only_mode: Option<bool>, response_filters: Option<&str>, latitude: Option<f64>, longitude: Option<f64>, meta_data: Option<&str>, third_party_refresh_token: Option<&str>, audience_ids_to_add: Option<&str>, audience_ids_to_remove: Option<&str>) -> Result<models::ProfileResponse, Error<CreateCredentialError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_third_party_id = third_party_id;
    let p_query_third_party_token = third_party_token;
    let p_query_network_uid = network_uid;
    let p_query_app_key = app_key;
    let p_query_account_id = account_id;
    let p_query_device_id = device_id;
    let p_query_session_id = session_id;
    let p_query_third_party_name = third_party_name;
    let p_query_email_address = email_address;
    let p_query_signin_only_mode = signin_only_mode;
    let p_query_response_filters = response_filters;
    let p_query_latitude = latitude;
    let p_query_longitude = longitude;
    let p_query_meta_data = meta_data;
    let p_query_third_party_refresh_token = third_party_refresh_token;
    let p_query_audience_ids_to_add = audience_ids_to_add;
    let p_query_audience_ids_to_remove = audience_ids_to_remove;

    let uri_str = format!("{}/api/{version}/thirdparty/credential/create", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_session_id {
        req_builder = req_builder.query(&[("sessionId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("thirdPartyId", &p_query_third_party_id.to_string())]);
    if let Some(ref param_value) = p_query_third_party_name {
        req_builder = req_builder.query(&[("thirdPartyName", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("thirdPartyToken", &p_query_third_party_token.to_string())]);
    req_builder = req_builder.query(&[("networkUID", &p_query_network_uid.to_string())]);
    req_builder = req_builder.query(&[("appKey", &p_query_app_key.to_string())]);
    if let Some(ref param_value) = p_query_email_address {
        req_builder = req_builder.query(&[("emailAddress", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_signin_only_mode {
        req_builder = req_builder.query(&[("signinOnlyMode", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_response_filters {
        req_builder = req_builder.query(&[("responseFilters", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_latitude {
        req_builder = req_builder.query(&[("latitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_longitude {
        req_builder = req_builder.query(&[("longitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_meta_data {
        req_builder = req_builder.query(&[("metaData", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_third_party_refresh_token {
        req_builder = req_builder.query(&[("thirdPartyRefreshToken", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_audience_ids_to_add {
        req_builder = req_builder.query(&[("audienceIdsToAdd", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_audience_ids_to_remove {
        req_builder = req_builder.query(&[("audienceIdsToRemove", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProfileResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProfileResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateCredentialError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a custom third party network.
pub async fn create_network(configuration: &configuration::Configuration, version: f64, account_id: i64, name: &str, enable_introspection: bool, description: Option<&str>, introspection_method: Option<&str>, introspection_url: Option<&str>, introspection_params: Option<&str>, required_root_field: Option<&str>, enable_mfa: Option<bool>, size_mfa: Option<i32>, shelf_life_mfa: Option<i32>, oauth_token_url: Option<&str>, oauth_private_key: Option<std::path::PathBuf>, oauth_public_key: Option<std::path::PathBuf>, oauth_client_id: Option<&str>, oauth_secret_key: Option<&str>, body: Option<&str>) -> Result<models::ThirdPartyNetworkResponse, Error<CreateNetworkError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_account_id = account_id;
    let p_query_name = name;
    let p_query_enable_introspection = enable_introspection;
    let p_query_description = description;
    let p_query_introspection_method = introspection_method;
    let p_query_introspection_url = introspection_url;
    let p_query_introspection_params = introspection_params;
    let p_query_required_root_field = required_root_field;
    let p_query_enable_mfa = enable_mfa;
    let p_query_size_mfa = size_mfa;
    let p_query_shelf_life_mfa = shelf_life_mfa;
    let p_query_oauth_token_url = oauth_token_url;
    let p_query_oauth_private_key = oauth_private_key;
    let p_query_oauth_public_key = oauth_public_key;
    let p_query_oauth_client_id = oauth_client_id;
    let p_query_oauth_secret_key = oauth_secret_key;
    let p_body_body = body;

    let uri_str = format!("{}/api/{version}/thirdparty/network/create", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("name", &p_query_name.to_string())]);
    if let Some(ref param_value) = p_query_description {
        req_builder = req_builder.query(&[("description", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("enableIntrospection", &p_query_enable_introspection.to_string())]);
    if let Some(ref param_value) = p_query_introspection_method {
        req_builder = req_builder.query(&[("introspectionMethod", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_introspection_url {
        req_builder = req_builder.query(&[("introspectionURL", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_introspection_params {
        req_builder = req_builder.query(&[("introspectionParams", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_required_root_field {
        req_builder = req_builder.query(&[("requiredRootField", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_enable_mfa {
        req_builder = req_builder.query(&[("enableMFA", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_size_mfa {
        req_builder = req_builder.query(&[("sizeMFA", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_shelf_life_mfa {
        req_builder = req_builder.query(&[("shelfLifeMFA", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_oauth_token_url {
        req_builder = req_builder.query(&[("oauthTokenURL", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_oauth_private_key {
        req_builder = req_builder.query(&[("oauthPrivateKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_oauth_public_key {
        req_builder = req_builder.query(&[("oauthPublicKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_oauth_client_id {
        req_builder = req_builder.query(&[("oauthClientId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_oauth_secret_key {
        req_builder = req_builder.query(&[("oauthSecretKey", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ThirdPartyNetworkResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ThirdPartyNetworkResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateNetworkError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete a third party network on a Sirqul account.
pub async fn delete_credential(configuration: &configuration::Configuration, version: f64, account_id: i64, network_uid: &str, third_party_id: &str, app_key: &str) -> Result<models::SirqulResponse, Error<DeleteCredentialError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_account_id = account_id;
    let p_query_network_uid = network_uid;
    let p_query_third_party_id = third_party_id;
    let p_query_app_key = app_key;

    let uri_str = format!("{}/api/{version}/thirdparty/credential/delete", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("networkUID", &p_query_network_uid.to_string())]);
    req_builder = req_builder.query(&[("thirdPartyId", &p_query_third_party_id.to_string())]);
    req_builder = req_builder.query(&[("appKey", &p_query_app_key.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SirqulResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SirqulResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteCredentialError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Marks a custom third party network as deleted. Only the network owners and managers have access to this.
pub async fn delete_network(configuration: &configuration::Configuration, version: f64, account_id: i64, network_uid: &str) -> Result<models::SirqulResponse, Error<DeleteNetworkError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_account_id = account_id;
    let p_query_network_uid = network_uid;

    let uri_str = format!("{}/api/{version}/thirdparty/network/delete", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("networkUID", &p_query_network_uid.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SirqulResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SirqulResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteNetworkError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets the account information given a third party token.
pub async fn get_credential(configuration: &configuration::Configuration, version: f64, network_uid: &str, app_key: &str, account_id: Option<i64>, device_id: Option<&str>, session_id: Option<&str>, third_party_credential_id: Option<i64>, third_party_token: Option<&str>, third_party_secret: Option<&str>, create_new_account: Option<bool>, response_filters: Option<&str>, latitude: Option<f64>, longitude: Option<f64>, audience_ids_to_add: Option<&str>, audience_ids_to_remove: Option<&str>, referral_account_id: Option<i64>) -> Result<models::ProfileResponse, Error<GetCredentialError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_network_uid = network_uid;
    let p_query_app_key = app_key;
    let p_query_account_id = account_id;
    let p_query_device_id = device_id;
    let p_query_session_id = session_id;
    let p_query_third_party_credential_id = third_party_credential_id;
    let p_query_third_party_token = third_party_token;
    let p_query_third_party_secret = third_party_secret;
    let p_query_create_new_account = create_new_account;
    let p_query_response_filters = response_filters;
    let p_query_latitude = latitude;
    let p_query_longitude = longitude;
    let p_query_audience_ids_to_add = audience_ids_to_add;
    let p_query_audience_ids_to_remove = audience_ids_to_remove;
    let p_query_referral_account_id = referral_account_id;

    let uri_str = format!("{}/api/{version}/thirdparty/credential/get", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_session_id {
        req_builder = req_builder.query(&[("sessionId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_third_party_credential_id {
        req_builder = req_builder.query(&[("thirdPartyCredentialId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_third_party_token {
        req_builder = req_builder.query(&[("thirdPartyToken", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_third_party_secret {
        req_builder = req_builder.query(&[("thirdPartySecret", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_create_new_account {
        req_builder = req_builder.query(&[("createNewAccount", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("networkUID", &p_query_network_uid.to_string())]);
    req_builder = req_builder.query(&[("appKey", &p_query_app_key.to_string())]);
    if let Some(ref param_value) = p_query_response_filters {
        req_builder = req_builder.query(&[("responseFilters", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_latitude {
        req_builder = req_builder.query(&[("latitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_longitude {
        req_builder = req_builder.query(&[("longitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_audience_ids_to_add {
        req_builder = req_builder.query(&[("audienceIdsToAdd", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_audience_ids_to_remove {
        req_builder = req_builder.query(&[("audienceIdsToRemove", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_referral_account_id {
        req_builder = req_builder.query(&[("referralAccountId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProfileResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProfileResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetCredentialError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the details of a third party network. Only the network owners and managers have access to this.
pub async fn get_network(configuration: &configuration::Configuration, version: f64, account_id: i64, network_uid: &str) -> Result<models::ThirdPartyNetworkResponse, Error<GetNetworkError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_account_id = account_id;
    let p_query_network_uid = network_uid;

    let uri_str = format!("{}/api/{version}/thirdparty/network/get", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("networkUID", &p_query_network_uid.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ThirdPartyNetworkResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ThirdPartyNetworkResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetNetworkError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Search on a user's linked third party networks.
pub async fn search_credentials(configuration: &configuration::Configuration, version: f64, account_id: i64, keyword: Option<&str>, network_uid: Option<&str>, descending: Option<bool>, start: Option<i32>, limit: Option<i32>) -> Result<Vec<models::ThirdPartyCredentialResponse>, Error<SearchCredentialsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_account_id = account_id;
    let p_query_keyword = keyword;
    let p_query_network_uid = network_uid;
    let p_query_descending = descending;
    let p_query_start = start;
    let p_query_limit = limit;

    let uri_str = format!("{}/api/{version}/thirdparty/credential/search", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    if let Some(ref param_value) = p_query_keyword {
        req_builder = req_builder.query(&[("keyword", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_network_uid {
        req_builder = req_builder.query(&[("networkUID", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_descending {
        req_builder = req_builder.query(&[("descending", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start {
        req_builder = req_builder.query(&[("start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::ThirdPartyCredentialResponse&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::ThirdPartyCredentialResponse&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchCredentialsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Search on supported third party networks and custom networks from external users.
pub async fn search_networks(configuration: &configuration::Configuration, version: f64, account_id: i64, sort_field: &str, descending: bool, start: i32, limit: i32, active_only: bool, keyword: Option<&str>, filter_billable: Option<bool>) -> Result<Vec<models::ThirdPartyNetworkShortResponse>, Error<SearchNetworksError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_account_id = account_id;
    let p_query_sort_field = sort_field;
    let p_query_descending = descending;
    let p_query_start = start;
    let p_query_limit = limit;
    let p_query_active_only = active_only;
    let p_query_keyword = keyword;
    let p_query_filter_billable = filter_billable;

    let uri_str = format!("{}/api/{version}/thirdparty/network/search", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    if let Some(ref param_value) = p_query_keyword {
        req_builder = req_builder.query(&[("keyword", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("sortField", &p_query_sort_field.to_string())]);
    req_builder = req_builder.query(&[("descending", &p_query_descending.to_string())]);
    req_builder = req_builder.query(&[("start", &p_query_start.to_string())]);
    req_builder = req_builder.query(&[("limit", &p_query_limit.to_string())]);
    req_builder = req_builder.query(&[("activeOnly", &p_query_active_only.to_string())]);
    if let Some(ref param_value) = p_query_filter_billable {
        req_builder = req_builder.query(&[("filterBillable", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::ThirdPartyNetworkShortResponse&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::ThirdPartyNetworkShortResponse&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchNetworksError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Sends an MFA challenge (SMS or Email) for networks with MFA enabled.
pub async fn send_mfa_challenge(configuration: &configuration::Configuration, version: f64, network_uid: &str, app_key: &str, third_party_token: Option<&str>, third_party_credential_id: Option<i64>, device_id: Option<&str>) -> Result<models::SirqulResponse, Error<SendMfaChallengeError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_network_uid = network_uid;
    let p_query_app_key = app_key;
    let p_query_third_party_token = third_party_token;
    let p_query_third_party_credential_id = third_party_credential_id;
    let p_query_device_id = device_id;

    let uri_str = format!("{}/api/{version}/thirdparty/credential/mfa/send", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_third_party_token {
        req_builder = req_builder.query(&[("thirdPartyToken", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_third_party_credential_id {
        req_builder = req_builder.query(&[("thirdPartyCredentialId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("networkUID", &p_query_network_uid.to_string())]);
    req_builder = req_builder.query(&[("appKey", &p_query_app_key.to_string())]);
    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SirqulResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SirqulResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SendMfaChallengeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates a third-party login for an account.
pub async fn update_credential(configuration: &configuration::Configuration, version: f64, network_uid: &str, third_party_id: &str, app_key: &str, device_id: Option<&str>, third_party_name: Option<&str>, third_party_token: Option<&str>, response_filters: Option<&str>, meta_data: Option<&str>, third_party_refresh_token: Option<&str>) -> Result<models::ProfileResponse, Error<UpdateCredentialError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_network_uid = network_uid;
    let p_query_third_party_id = third_party_id;
    let p_query_app_key = app_key;
    let p_query_device_id = device_id;
    let p_query_third_party_name = third_party_name;
    let p_query_third_party_token = third_party_token;
    let p_query_response_filters = response_filters;
    let p_query_meta_data = meta_data;
    let p_query_third_party_refresh_token = third_party_refresh_token;

    let uri_str = format!("{}/api/{version}/thirdparty/credential/update", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("networkUID", &p_query_network_uid.to_string())]);
    req_builder = req_builder.query(&[("thirdPartyId", &p_query_third_party_id.to_string())]);
    if let Some(ref param_value) = p_query_third_party_name {
        req_builder = req_builder.query(&[("thirdPartyName", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_third_party_token {
        req_builder = req_builder.query(&[("thirdPartyToken", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("appKey", &p_query_app_key.to_string())]);
    if let Some(ref param_value) = p_query_response_filters {
        req_builder = req_builder.query(&[("responseFilters", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_meta_data {
        req_builder = req_builder.query(&[("metaData", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_third_party_refresh_token {
        req_builder = req_builder.query(&[("thirdPartyRefreshToken", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProfileResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProfileResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateCredentialError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates a custom third party network. Only the network owners and managers have access to this.
pub async fn update_network(configuration: &configuration::Configuration, version: f64, account_id: i64, network_uid: &str, name: Option<&str>, description: Option<&str>, enable_introspection: Option<bool>, introspection_method: Option<&str>, introspection_url: Option<&str>, introspection_params: Option<&str>, required_root_field: Option<&str>, enable_mfa: Option<bool>, size_mfa: Option<i32>, shelf_life_mfa: Option<i32>, oauth_token_url: Option<&str>, oauth_private_key: Option<std::path::PathBuf>, oauth_public_key: Option<std::path::PathBuf>, oauth_client_id: Option<&str>, oauth_secret_key: Option<&str>, body: Option<&str>) -> Result<models::ThirdPartyNetworkResponse, Error<UpdateNetworkError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_account_id = account_id;
    let p_query_network_uid = network_uid;
    let p_query_name = name;
    let p_query_description = description;
    let p_query_enable_introspection = enable_introspection;
    let p_query_introspection_method = introspection_method;
    let p_query_introspection_url = introspection_url;
    let p_query_introspection_params = introspection_params;
    let p_query_required_root_field = required_root_field;
    let p_query_enable_mfa = enable_mfa;
    let p_query_size_mfa = size_mfa;
    let p_query_shelf_life_mfa = shelf_life_mfa;
    let p_query_oauth_token_url = oauth_token_url;
    let p_query_oauth_private_key = oauth_private_key;
    let p_query_oauth_public_key = oauth_public_key;
    let p_query_oauth_client_id = oauth_client_id;
    let p_query_oauth_secret_key = oauth_secret_key;
    let p_body_body = body;

    let uri_str = format!("{}/api/{version}/thirdparty/network/update", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("networkUID", &p_query_network_uid.to_string())]);
    if let Some(ref param_value) = p_query_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_description {
        req_builder = req_builder.query(&[("description", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_enable_introspection {
        req_builder = req_builder.query(&[("enableIntrospection", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_introspection_method {
        req_builder = req_builder.query(&[("introspectionMethod", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_introspection_url {
        req_builder = req_builder.query(&[("introspectionURL", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_introspection_params {
        req_builder = req_builder.query(&[("introspectionParams", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_required_root_field {
        req_builder = req_builder.query(&[("requiredRootField", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_enable_mfa {
        req_builder = req_builder.query(&[("enableMFA", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_size_mfa {
        req_builder = req_builder.query(&[("sizeMFA", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_shelf_life_mfa {
        req_builder = req_builder.query(&[("shelfLifeMFA", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_oauth_token_url {
        req_builder = req_builder.query(&[("oauthTokenURL", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_oauth_private_key {
        req_builder = req_builder.query(&[("oauthPrivateKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_oauth_public_key {
        req_builder = req_builder.query(&[("oauthPublicKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_oauth_client_id {
        req_builder = req_builder.query(&[("oauthClientId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_oauth_secret_key {
        req_builder = req_builder.query(&[("oauthSecretKey", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ThirdPartyNetworkResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ThirdPartyNetworkResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateNetworkError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

