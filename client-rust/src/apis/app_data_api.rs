/*
 * Sirqul IoT Platform
 *
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`get_app_data`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAppDataError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_app_data`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostAppDataError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`regen_app_data`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RegenAppDataError {
    UnknownValue(serde_json::Value),
}


/// Get the application data structure.  The basic structure is a   node tree, with the root node being a AppResponse.  The response contains   the user's profile, messages from the system, and a list of MissionResponse.    A mission can have any number of GameResponses but typically is a single   game type.  A game then has any number of PackResponses which help group   the game levels. Packs are then composed of any number of GameLevelResponses.     Using the various parameters can return the applications default mission   (built-in packs to play), the list of community levels published, the user's   saved levels, or explicity levels desired.  You can choose to include the   profile or not, or just return parts of the profile.  You can also filter   out game levels that have been published with a higher version of the application.
pub async fn get_app_data(configuration: &configuration::Configuration, start: i32, limit: i32, device_id: Option<&str>, account_id: Option<i64>, game_type: Option<&str>, include_game_data: Option<bool>, q: Option<&str>, keyword: Option<&str>, sort_field: Option<&str>, descending: Option<bool>, _i: Option<i32>, _l: Option<i32>, game_object_count: Option<bool>, filter: Option<&str>, date_created: Option<i64>, owner_id: Option<i64>, mission_ids: Option<&str>, game_ids: Option<&str>, pack_ids: Option<&str>, game_level_ids: Option<&str>, app_version: Option<&str>, include_higher_version_packs: Option<bool>, include_higher_version_levels: Option<bool>, response_groups: Option<&str>, purchase_type: Option<&str>) -> Result<models::AppResponse, Error<GetAppDataError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_start = start;
    let p_query_limit = limit;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_game_type = game_type;
    let p_query_include_game_data = include_game_data;
    let p_query_q = q;
    let p_query_keyword = keyword;
    let p_query_sort_field = sort_field;
    let p_query_descending = descending;
    let p_query__i = _i;
    let p_query__l = _l;
    let p_query_game_object_count = game_object_count;
    let p_query_filter = filter;
    let p_query_date_created = date_created;
    let p_query_owner_id = owner_id;
    let p_query_mission_ids = mission_ids;
    let p_query_game_ids = game_ids;
    let p_query_pack_ids = pack_ids;
    let p_query_game_level_ids = game_level_ids;
    let p_query_app_version = app_version;
    let p_query_include_higher_version_packs = include_higher_version_packs;
    let p_query_include_higher_version_levels = include_higher_version_levels;
    let p_query_response_groups = response_groups;
    let p_query_purchase_type = purchase_type;

    let uri_str = format!("{}/app/get", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_game_type {
        req_builder = req_builder.query(&[("gameType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_game_data {
        req_builder = req_builder.query(&[("includeGameData", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_q {
        req_builder = req_builder.query(&[("q", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_keyword {
        req_builder = req_builder.query(&[("keyword", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_field {
        req_builder = req_builder.query(&[("sortField", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_descending {
        req_builder = req_builder.query(&[("descending", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query__i {
        req_builder = req_builder.query(&[("_i", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("start", &p_query_start.to_string())]);
    if let Some(ref param_value) = p_query__l {
        req_builder = req_builder.query(&[("_l", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("limit", &p_query_limit.to_string())]);
    if let Some(ref param_value) = p_query_game_object_count {
        req_builder = req_builder.query(&[("gameObjectCount", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter {
        req_builder = req_builder.query(&[("filter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date_created {
        req_builder = req_builder.query(&[("dateCreated", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_owner_id {
        req_builder = req_builder.query(&[("ownerId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mission_ids {
        req_builder = req_builder.query(&[("missionIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_game_ids {
        req_builder = req_builder.query(&[("gameIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_pack_ids {
        req_builder = req_builder.query(&[("packIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_game_level_ids {
        req_builder = req_builder.query(&[("gameLevelIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_version {
        req_builder = req_builder.query(&[("appVersion", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_higher_version_packs {
        req_builder = req_builder.query(&[("includeHigherVersionPacks", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_higher_version_levels {
        req_builder = req_builder.query(&[("includeHigherVersionLevels", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_response_groups {
        req_builder = req_builder.query(&[("responseGroups", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_purchase_type {
        req_builder = req_builder.query(&[("purchaseType", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AppResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AppResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAppDataError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Publish the application data structure.  Can be used to save levels   and scores.  It then returns the application data structure.  The basic   structure is a node tree, with the root node being a AppResponse.  The response   contains the user's profile, messages from the system, and a list of MissionResponse.    A mission can have any number of GameResponses but typically is a single   game type.  A game then has any number of PackResponses which help group   the game levels. Packs are then composed of any number of GameLevelResponses.      Using the various parameters can return the applications default mission   (built-in packs to play), the list of community levels published, the user's   saved levels, or explicity levels desired.  You can choose to include the   profile or not, or just return parts of the profile.  You can also filter   out game levels that have been published with a higher version of the application
pub async fn post_app_data(configuration: &configuration::Configuration, game_type: &str, start: i32, limit: i32, data: &str, device_id: Option<&str>, account_id: Option<i64>, include_game_data: Option<bool>, q: Option<&str>, keyword: Option<&str>, sort_field: Option<&str>, descending: Option<bool>, _i: Option<i32>, _l: Option<i32>, game_object_count: Option<bool>, filter: Option<&str>, date_created: Option<i64>, owner_id: Option<i64>, mission_ids: Option<&str>, game_ids: Option<&str>, pack_ids: Option<&str>, game_level_ids: Option<&str>, app_version: Option<&str>, include_higher_version_packs: Option<bool>, include_higher_version_levels: Option<bool>, response_groups: Option<&str>, purchase_type: Option<&str>) -> Result<models::AppResponse, Error<PostAppDataError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_game_type = game_type;
    let p_query_start = start;
    let p_query_limit = limit;
    let p_query_data = data;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_include_game_data = include_game_data;
    let p_query_q = q;
    let p_query_keyword = keyword;
    let p_query_sort_field = sort_field;
    let p_query_descending = descending;
    let p_query__i = _i;
    let p_query__l = _l;
    let p_query_game_object_count = game_object_count;
    let p_query_filter = filter;
    let p_query_date_created = date_created;
    let p_query_owner_id = owner_id;
    let p_query_mission_ids = mission_ids;
    let p_query_game_ids = game_ids;
    let p_query_pack_ids = pack_ids;
    let p_query_game_level_ids = game_level_ids;
    let p_query_app_version = app_version;
    let p_query_include_higher_version_packs = include_higher_version_packs;
    let p_query_include_higher_version_levels = include_higher_version_levels;
    let p_query_response_groups = response_groups;
    let p_query_purchase_type = purchase_type;

    let uri_str = format!("{}/app/post", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("gameType", &p_query_game_type.to_string())]);
    if let Some(ref param_value) = p_query_include_game_data {
        req_builder = req_builder.query(&[("includeGameData", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_q {
        req_builder = req_builder.query(&[("q", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_keyword {
        req_builder = req_builder.query(&[("keyword", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_field {
        req_builder = req_builder.query(&[("sortField", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_descending {
        req_builder = req_builder.query(&[("descending", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query__i {
        req_builder = req_builder.query(&[("_i", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("start", &p_query_start.to_string())]);
    if let Some(ref param_value) = p_query__l {
        req_builder = req_builder.query(&[("_l", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("limit", &p_query_limit.to_string())]);
    if let Some(ref param_value) = p_query_game_object_count {
        req_builder = req_builder.query(&[("gameObjectCount", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter {
        req_builder = req_builder.query(&[("filter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date_created {
        req_builder = req_builder.query(&[("dateCreated", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_owner_id {
        req_builder = req_builder.query(&[("ownerId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mission_ids {
        req_builder = req_builder.query(&[("missionIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_game_ids {
        req_builder = req_builder.query(&[("gameIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_pack_ids {
        req_builder = req_builder.query(&[("packIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_game_level_ids {
        req_builder = req_builder.query(&[("gameLevelIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_version {
        req_builder = req_builder.query(&[("appVersion", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_higher_version_packs {
        req_builder = req_builder.query(&[("includeHigherVersionPacks", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_higher_version_levels {
        req_builder = req_builder.query(&[("includeHigherVersionLevels", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_response_groups {
        req_builder = req_builder.query(&[("responseGroups", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_purchase_type {
        req_builder = req_builder.query(&[("purchaseType", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("data", &p_query_data.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AppResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AppResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PostAppDataError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Regenerate the app data cache for apps
pub async fn regen_app_data(configuration: &configuration::Configuration, account_id: Option<i64>, app_key: Option<&str>, build_version: Option<&str>, api_version: Option<&str>) -> Result<models::SirqulResponse, Error<RegenAppDataError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_id = account_id;
    let p_query_app_key = app_key;
    let p_query_build_version = build_version;
    let p_query_api_version = api_version;

    let uri_str = format!("{}/app/regen", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_key {
        req_builder = req_builder.query(&[("appKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_build_version {
        req_builder = req_builder.query(&[("buildVersion", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_api_version {
        req_builder = req_builder.query(&[("apiVersion", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SirqulResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SirqulResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RegenAppDataError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

