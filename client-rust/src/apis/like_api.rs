/*
 * Sirqul IoT Platform
 *
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`register_like`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RegisterLikeError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`remove_like`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RemoveLikeError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_likes`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchLikesError {
    UnknownValue(serde_json::Value),
}


/// Allows a user to like or dislike accounts, albums, album contests, assets, game levels, notes, and theme descriptors. Multiple likes\\dislikes on the same object will replace the previous one.
pub async fn register_like(configuration: &configuration::Configuration, version: f64, likable_type: &str, likable_id: i64, device_id: Option<&str>, account_id: Option<i64>, permissionable_type: Option<&str>, permissionable_id: Option<i64>, like: Option<bool>, app: Option<&str>, game_type: Option<&str>, app_key: Option<&str>, latitude: Option<f64>, longitude: Option<f64>) -> Result<models::LikableResponse, Error<RegisterLikeError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_likable_type = likable_type;
    let p_query_likable_id = likable_id;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_permissionable_type = permissionable_type;
    let p_query_permissionable_id = permissionable_id;
    let p_query_like = like;
    let p_query_app = app;
    let p_query_game_type = game_type;
    let p_query_app_key = app_key;
    let p_query_latitude = latitude;
    let p_query_longitude = longitude;

    let uri_str = format!("{}/api/{version}/like", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("likableType", &p_query_likable_type.to_string())]);
    req_builder = req_builder.query(&[("likableId", &p_query_likable_id.to_string())]);
    if let Some(ref param_value) = p_query_permissionable_type {
        req_builder = req_builder.query(&[("permissionableType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_permissionable_id {
        req_builder = req_builder.query(&[("permissionableId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_like {
        req_builder = req_builder.query(&[("like", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app {
        req_builder = req_builder.query(&[("app", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_game_type {
        req_builder = req_builder.query(&[("gameType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_key {
        req_builder = req_builder.query(&[("appKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_latitude {
        req_builder = req_builder.query(&[("latitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_longitude {
        req_builder = req_builder.query(&[("longitude", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::LikableResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::LikableResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RegisterLikeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Removes a like. This will make the user \"neutral\".
pub async fn remove_like(configuration: &configuration::Configuration, version: f64, likable_type: &str, likable_id: i64, device_id: Option<&str>, account_id: Option<i64>, latitude: Option<f64>, longitude: Option<f64>) -> Result<models::LikableResponse, Error<RemoveLikeError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_likable_type = likable_type;
    let p_query_likable_id = likable_id;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_latitude = latitude;
    let p_query_longitude = longitude;

    let uri_str = format!("{}/api/{version}/like/delete", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("likableType", &p_query_likable_type.to_string())]);
    req_builder = req_builder.query(&[("likableId", &p_query_likable_id.to_string())]);
    if let Some(ref param_value) = p_query_latitude {
        req_builder = req_builder.query(&[("latitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_longitude {
        req_builder = req_builder.query(&[("longitude", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::LikableResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::LikableResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RemoveLikeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Search for likes on a likable object.
pub async fn search_likes(configuration: &configuration::Configuration, version: f64, likable_type: &str, likable_id: i64, device_id: Option<&str>, account_id: Option<i64>, connection_account_ids: Option<&str>, sort_field: Option<&str>, descending: Option<bool>, updated_since: Option<i64>, updated_before: Option<i64>, start: Option<i32>, limit: Option<i32>) -> Result<models::SearchResponse, Error<SearchLikesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_likable_type = likable_type;
    let p_query_likable_id = likable_id;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_connection_account_ids = connection_account_ids;
    let p_query_sort_field = sort_field;
    let p_query_descending = descending;
    let p_query_updated_since = updated_since;
    let p_query_updated_before = updated_before;
    let p_query_start = start;
    let p_query_limit = limit;

    let uri_str = format!("{}/api/{version}/like/search", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_connection_account_ids {
        req_builder = req_builder.query(&[("connectionAccountIds", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("likableType", &p_query_likable_type.to_string())]);
    req_builder = req_builder.query(&[("likableId", &p_query_likable_id.to_string())]);
    if let Some(ref param_value) = p_query_sort_field {
        req_builder = req_builder.query(&[("sortField", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_descending {
        req_builder = req_builder.query(&[("descending", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_updated_since {
        req_builder = req_builder.query(&[("updatedSince", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_updated_before {
        req_builder = req_builder.query(&[("updatedBefore", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start {
        req_builder = req_builder.query(&[("start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SearchResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SearchResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchLikesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

