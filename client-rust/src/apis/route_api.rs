/*
 * Sirqul IoT Platform
 *
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`approve_route`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApproveRouteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`copy_route`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CopyRouteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_route`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateRouteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_route_directions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateRouteDirectionsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_route_polyline`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateRoutePolylineError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_route`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteRouteError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`disapprove_route`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DisapproveRouteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_route`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRouteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_route_directions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRouteDirectionsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_route_shipments`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRouteShipmentsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_route_stop`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRouteStopError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_route_stops`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRouteStopsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_shipments_at_stop`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetShipmentsAtStopError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`optimize_route`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OptimizeRouteError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`remove_stop`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RemoveStopError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reorder_route_stops_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReorderRouteStopsPatchError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reorder_route_stops_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReorderRouteStopsPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_routes`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchRoutesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`set_driver`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SetDriverError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_route`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateRouteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_route_stop`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateRouteStopError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}


/// Approve a route
pub async fn approve_route(configuration: &configuration::Configuration, version: f64, route_id: i64) -> Result<models::Route, Error<ApproveRouteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_path_route_id = route_id;

    let uri_str = format!("{}/api/{version}/route/{routeId}/approve", configuration.base_path, version=p_path_version, routeId=p_path_route_id);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Route`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Route`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApproveRouteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Make an copy of the given route with optional overriding properties
pub async fn copy_route(configuration: &configuration::Configuration, version: f64, route_id: i64, body: Option<models::Route>) -> Result<models::Route, Error<CopyRouteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_path_route_id = route_id;
    let p_body_body = body;

    let uri_str = format!("{}/api/{version}/route/{routeId}/copy", configuration.base_path, version=p_path_version, routeId=p_path_route_id);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Route`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Route`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CopyRouteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create new route
pub async fn create_route(configuration: &configuration::Configuration, version: f64, body: Option<models::Route>) -> Result<models::Route, Error<CreateRouteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_body_body = body;

    let uri_str = format!("{}/api/{version}/route", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Route`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Route`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateRouteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Regenerate the directions of a route
pub async fn create_route_directions(configuration: &configuration::Configuration, version: f64, route_id: i64) -> Result<Vec<models::Direction>, Error<CreateRouteDirectionsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_path_route_id = route_id;

    let uri_str = format!("{}/api/{version}/route/{routeId}/directions", configuration.base_path, version=p_path_version, routeId=p_path_route_id);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Direction&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Direction&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateRouteDirectionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update the polyline of the requested route
pub async fn create_route_polyline(configuration: &configuration::Configuration, version: f64, route_id: i64) -> Result<models::Route, Error<CreateRoutePolylineError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_path_route_id = route_id;

    let uri_str = format!("{}/api/{version}/route/{routeId}/polyline", configuration.base_path, version=p_path_version, routeId=p_path_route_id);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Route`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Route`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateRoutePolylineError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete an existing route
pub async fn delete_route(configuration: &configuration::Configuration, version: f64, route_id: i64) -> Result<(), Error<DeleteRouteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_path_route_id = route_id;

    let uri_str = format!("{}/api/{version}/route/{routeId}", configuration.base_path, version=p_path_version, routeId=p_path_route_id);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteRouteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Disapprove a route
pub async fn disapprove_route(configuration: &configuration::Configuration, version: f64, route_id: i64) -> Result<models::Route, Error<DisapproveRouteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_path_route_id = route_id;

    let uri_str = format!("{}/api/{version}/route/{routeId}/disapprove", configuration.base_path, version=p_path_version, routeId=p_path_route_id);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Route`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Route`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DisapproveRouteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get an existing route
pub async fn get_route(configuration: &configuration::Configuration, version: f64, route_id: i64, show_inherited_properties: bool) -> Result<models::Route, Error<GetRouteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_path_route_id = route_id;
    let p_query_show_inherited_properties = show_inherited_properties;

    let uri_str = format!("{}/api/{version}/route/{routeId}", configuration.base_path, version=p_path_version, routeId=p_path_route_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("showInheritedProperties", &p_query_show_inherited_properties.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Route`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Route`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetRouteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the directions of a route
pub async fn get_route_directions(configuration: &configuration::Configuration, version: f64, route_id: i64) -> Result<Vec<models::Direction>, Error<GetRouteDirectionsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_path_route_id = route_id;

    let uri_str = format!("{}/api/{version}/route/{routeId}/directions", configuration.base_path, version=p_path_version, routeId=p_path_route_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Direction&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Direction&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetRouteDirectionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the shipments on the requested route
pub async fn get_route_shipments(configuration: &configuration::Configuration, version: f64, route_id: i64) -> Result<Vec<models::Shipment>, Error<GetRouteShipmentsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_path_route_id = route_id;

    let uri_str = format!("{}/api/{version}/route/{routeId}/shipments", configuration.base_path, version=p_path_version, routeId=p_path_route_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Shipment&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Shipment&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetRouteShipmentsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the specific stop on a route
pub async fn get_route_stop(configuration: &configuration::Configuration, version: f64, route_id: i64, stop_id: i64) -> Result<models::Stop, Error<GetRouteStopError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_path_route_id = route_id;
    let p_path_stop_id = stop_id;

    let uri_str = format!("{}/api/{version}/route/{routeId}/stop/{stopId}", configuration.base_path, version=p_path_version, routeId=p_path_route_id, stopId=p_path_stop_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Stop`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Stop`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetRouteStopError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The stops of the route requested
pub async fn get_route_stops(configuration: &configuration::Configuration, version: f64, route_id: i64, confirmed_only: bool) -> Result<Vec<models::Stop>, Error<GetRouteStopsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_path_route_id = route_id;
    let p_query_confirmed_only = confirmed_only;

    let uri_str = format!("{}/api/{version}/route/{routeId}/stops", configuration.base_path, version=p_path_version, routeId=p_path_route_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("confirmedOnly", &p_query_confirmed_only.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Stop&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Stop&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetRouteStopsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the list of shipments on the requested route at a stop
pub async fn get_shipments_at_stop(configuration: &configuration::Configuration, version: f64, route_id: i64, stop_id: i64) -> Result<Vec<models::Shipment>, Error<GetShipmentsAtStopError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_path_route_id = route_id;
    let p_path_stop_id = stop_id;

    let uri_str = format!("{}/api/{version}/route/{routeId}/stop/{stopId}/shipments", configuration.base_path, version=p_path_version, routeId=p_path_route_id, stopId=p_path_stop_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Shipment&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Shipment&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetShipmentsAtStopError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Optimize a route. The optimization method based on how the server is configured.
pub async fn optimize_route(configuration: &configuration::Configuration, version: f64, route_id: i64) -> Result<(), Error<OptimizeRouteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_path_route_id = route_id;

    let uri_str = format!("{}/api/{version}/route/{routeId}/optimize", configuration.base_path, version=p_path_version, routeId=p_path_route_id);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<OptimizeRouteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete a stop on a route
pub async fn remove_stop(configuration: &configuration::Configuration, version: f64, route_id: i64, stop_id: i64) -> Result<(), Error<RemoveStopError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_path_route_id = route_id;
    let p_path_stop_id = stop_id;

    let uri_str = format!("{}/api/{version}/route/{routeId}/stop/{stopId}", configuration.base_path, version=p_path_version, routeId=p_path_route_id, stopId=p_path_stop_id);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<RemoveStopError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Reordering the stops on the route with and update route distance, time, direction, and polyline
pub async fn reorder_route_stops_patch(configuration: &configuration::Configuration, version: f64, route_id: i64, body: Option<Vec<models::Stop>>) -> Result<Vec<models::Stop>, Error<ReorderRouteStopsPatchError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_path_route_id = route_id;
    let p_body_body = body;

    let uri_str = format!("{}/api/{version}/route/{routeId}/stops/reorder", configuration.base_path, version=p_path_version, routeId=p_path_route_id);
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Stop&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Stop&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ReorderRouteStopsPatchError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Reordering the stops on the route with and update route distance, time, direction, and polyline
pub async fn reorder_route_stops_post(configuration: &configuration::Configuration, version: f64, route_id: i64, body: Option<Vec<models::Stop>>) -> Result<Vec<models::Stop>, Error<ReorderRouteStopsPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_path_route_id = route_id;
    let p_body_body = body;

    let uri_str = format!("{}/api/{version}/route/{routeId}/stops/reorder", configuration.base_path, version=p_path_version, routeId=p_path_route_id);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Stop&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Stop&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ReorderRouteStopsPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Search for routes.
pub async fn search_routes(configuration: &configuration::Configuration, version: f64, sort_field: &str, descending: bool, start: i32, limit: i32, active_only: bool, includes_empty: bool, root_only: bool, show_inherited_properties: bool, hub_id: Option<i64>, program_id: Option<i64>, scheduled_start: Option<i64>, scheduled_end: Option<i64>, updated_start: Option<i64>, updated_end: Option<i64>, featured: Option<bool>, seat_count: Option<i32>, approved: Option<bool>, started: Option<bool>, completed: Option<bool>, valid: Option<bool>, parent_id: Option<i64>) -> Result<Vec<models::Route>, Error<SearchRoutesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_sort_field = sort_field;
    let p_query_descending = descending;
    let p_query_start = start;
    let p_query_limit = limit;
    let p_query_active_only = active_only;
    let p_query_includes_empty = includes_empty;
    let p_query_root_only = root_only;
    let p_query_show_inherited_properties = show_inherited_properties;
    let p_query_hub_id = hub_id;
    let p_query_program_id = program_id;
    let p_query_scheduled_start = scheduled_start;
    let p_query_scheduled_end = scheduled_end;
    let p_query_updated_start = updated_start;
    let p_query_updated_end = updated_end;
    let p_query_featured = featured;
    let p_query_seat_count = seat_count;
    let p_query_approved = approved;
    let p_query_started = started;
    let p_query_completed = completed;
    let p_query_valid = valid;
    let p_query_parent_id = parent_id;

    let uri_str = format!("{}/api/{version}/route", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_hub_id {
        req_builder = req_builder.query(&[("hubId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_program_id {
        req_builder = req_builder.query(&[("programId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_scheduled_start {
        req_builder = req_builder.query(&[("scheduledStart", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_scheduled_end {
        req_builder = req_builder.query(&[("scheduledEnd", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_updated_start {
        req_builder = req_builder.query(&[("updatedStart", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_updated_end {
        req_builder = req_builder.query(&[("updatedEnd", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_featured {
        req_builder = req_builder.query(&[("featured", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_seat_count {
        req_builder = req_builder.query(&[("seatCount", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_approved {
        req_builder = req_builder.query(&[("approved", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_started {
        req_builder = req_builder.query(&[("started", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_completed {
        req_builder = req_builder.query(&[("completed", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_valid {
        req_builder = req_builder.query(&[("valid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_parent_id {
        req_builder = req_builder.query(&[("parentId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("sortField", &p_query_sort_field.to_string())]);
    req_builder = req_builder.query(&[("descending", &p_query_descending.to_string())]);
    req_builder = req_builder.query(&[("start", &p_query_start.to_string())]);
    req_builder = req_builder.query(&[("limit", &p_query_limit.to_string())]);
    req_builder = req_builder.query(&[("activeOnly", &p_query_active_only.to_string())]);
    req_builder = req_builder.query(&[("includesEmpty", &p_query_includes_empty.to_string())]);
    req_builder = req_builder.query(&[("rootOnly", &p_query_root_only.to_string())]);
    req_builder = req_builder.query(&[("showInheritedProperties", &p_query_show_inherited_properties.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Route&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Route&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchRoutesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update the driver of the route.
pub async fn set_driver(configuration: &configuration::Configuration, version: f64, id: i64, driver_id: i64) -> Result<(), Error<SetDriverError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_path_id = id;
    let p_path_driver_id = driver_id;

    let uri_str = format!("{}/api/{version}/route/{id}/driver/{driverId}", configuration.base_path, version=p_path_version, id=p_path_id, driverId=p_path_driver_id);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<SetDriverError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update an existing route
pub async fn update_route(configuration: &configuration::Configuration, version: f64, route_id: i64, body: Option<models::Route>) -> Result<models::Route, Error<UpdateRouteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_path_route_id = route_id;
    let p_body_body = body;

    let uri_str = format!("{}/api/{version}/route/{routeId}", configuration.base_path, version=p_path_version, routeId=p_path_route_id);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Route`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Route`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateRouteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update a stop on a specified route
pub async fn update_route_stop(configuration: &configuration::Configuration, version: f64, route_id: i64, stop_id: i64, body: Option<models::Stop>) -> Result<(), Error<UpdateRouteStopError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_path_route_id = route_id;
    let p_path_stop_id = stop_id;
    let p_body_body = body;

    let uri_str = format!("{}/api/{version}/route/{routeId}/stop/{stopId}", configuration.base_path, version=p_path_version, routeId=p_path_route_id, stopId=p_path_stop_id);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateRouteStopError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

