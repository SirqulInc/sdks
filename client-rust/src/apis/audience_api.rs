/*
 * Sirqul IoT Platform
 *
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`create_audience`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateAudienceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_audience`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteAudienceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_age_groups`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAgeGroupsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_audience`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAudienceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_audience_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAudienceListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_devices`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDevicesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_experiences`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetExperiencesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_grouped_audiences`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetGroupedAudiencesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_by_account`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListByAccountError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_by_audience`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListByAudienceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_lastest_by_account`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListLastestByAccountError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`send_by_account`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SendByAccountError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_audience`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateAudienceError {
    UnknownValue(serde_json::Value),
}


/// Create a user defined audience.
pub async fn create_audience(configuration: &configuration::Configuration, version: f64, account_id: i64, name: &str, description: Option<&str>, search_tags: Option<&str>, gender: Option<&str>, age_groups: Option<&str>, category_ids: Option<&str>, application_ids: Option<&str>, game_experience_level: Option<&str>, devices: Option<&str>, device_ids: Option<&str>, device_versions: Option<&str>, locations: Option<&str>, radius: Option<&str>, start_time_offset: Option<i32>, end_time_offset: Option<i32>, send_suggestion: Option<bool>, associate_description: Option<&str>, associate_type: Option<&str>, associate_id: Option<i64>, grouping_id: Option<&str>, meta_data: Option<&str>, visibility: Option<&str>, audience_type: Option<&str>, use_order: Option<bool>, cohort_regions_data: Option<&str>, app_key: Option<&str>, trilateration_types: Option<&str>, unique_name: Option<bool>) -> Result<models::AudienceResponse, Error<CreateAudienceError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_account_id = account_id;
    let p_query_name = name;
    let p_query_description = description;
    let p_query_search_tags = search_tags;
    let p_query_gender = gender;
    let p_query_age_groups = age_groups;
    let p_query_category_ids = category_ids;
    let p_query_application_ids = application_ids;
    let p_query_game_experience_level = game_experience_level;
    let p_query_devices = devices;
    let p_query_device_ids = device_ids;
    let p_query_device_versions = device_versions;
    let p_query_locations = locations;
    let p_query_radius = radius;
    let p_query_start_time_offset = start_time_offset;
    let p_query_end_time_offset = end_time_offset;
    let p_query_send_suggestion = send_suggestion;
    let p_query_associate_description = associate_description;
    let p_query_associate_type = associate_type;
    let p_query_associate_id = associate_id;
    let p_query_grouping_id = grouping_id;
    let p_query_meta_data = meta_data;
    let p_query_visibility = visibility;
    let p_query_audience_type = audience_type;
    let p_query_use_order = use_order;
    let p_query_cohort_regions_data = cohort_regions_data;
    let p_query_app_key = app_key;
    let p_query_trilateration_types = trilateration_types;
    let p_query_unique_name = unique_name;

    let uri_str = format!("{}/api/{version}/audience/create", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("name", &p_query_name.to_string())]);
    if let Some(ref param_value) = p_query_description {
        req_builder = req_builder.query(&[("description", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search_tags {
        req_builder = req_builder.query(&[("searchTags", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_gender {
        req_builder = req_builder.query(&[("gender", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_age_groups {
        req_builder = req_builder.query(&[("ageGroups", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_category_ids {
        req_builder = req_builder.query(&[("categoryIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_application_ids {
        req_builder = req_builder.query(&[("applicationIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_game_experience_level {
        req_builder = req_builder.query(&[("gameExperienceLevel", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_devices {
        req_builder = req_builder.query(&[("devices", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_device_ids {
        req_builder = req_builder.query(&[("deviceIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_device_versions {
        req_builder = req_builder.query(&[("deviceVersions", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_locations {
        req_builder = req_builder.query(&[("locations", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_radius {
        req_builder = req_builder.query(&[("radius", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_time_offset {
        req_builder = req_builder.query(&[("startTimeOffset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_time_offset {
        req_builder = req_builder.query(&[("endTimeOffset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_send_suggestion {
        req_builder = req_builder.query(&[("sendSuggestion", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_associate_description {
        req_builder = req_builder.query(&[("associateDescription", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_associate_type {
        req_builder = req_builder.query(&[("associateType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_associate_id {
        req_builder = req_builder.query(&[("associateId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_grouping_id {
        req_builder = req_builder.query(&[("groupingId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_meta_data {
        req_builder = req_builder.query(&[("metaData", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_visibility {
        req_builder = req_builder.query(&[("visibility", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_audience_type {
        req_builder = req_builder.query(&[("audienceType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_use_order {
        req_builder = req_builder.query(&[("useOrder", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cohort_regions_data {
        req_builder = req_builder.query(&[("cohortRegionsData", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_key {
        req_builder = req_builder.query(&[("appKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_trilateration_types {
        req_builder = req_builder.query(&[("trilaterationTypes", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_unique_name {
        req_builder = req_builder.query(&[("uniqueName", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AudienceResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AudienceResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateAudienceError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete an audience. The audience and account must be valid and have the appropirate permissions to view the content.
pub async fn delete_audience(configuration: &configuration::Configuration, version: f64, account_id: i64, audience_id: i64) -> Result<models::SirqulResponse, Error<DeleteAudienceError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_account_id = account_id;
    let p_query_audience_id = audience_id;

    let uri_str = format!("{}/api/{version}/audience/delete", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("audienceId", &p_query_audience_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SirqulResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SirqulResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteAudienceError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets the list of available age groups that can be selected by consumers and retailers targeting offers.
pub async fn get_age_groups(configuration: &configuration::Configuration, version: f64) -> Result<Vec<models::AgeGroupResponse>, Error<GetAgeGroupsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;

    let uri_str = format!("{}/api/{version}/audience/ageGroups", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::AgeGroupResponse&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::AgeGroupResponse&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAgeGroupsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get an audience. The audience and account must be valid and have the appropriate permissions to view the content.
pub async fn get_audience(configuration: &configuration::Configuration, version: f64, account_id: i64, audience_id: i64, app_key: Option<&str>, return_account_count: Option<bool>, return_album_count: Option<bool>, album_types_for_count: Option<&str>) -> Result<models::AudienceResponse, Error<GetAudienceError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_account_id = account_id;
    let p_query_audience_id = audience_id;
    let p_query_app_key = app_key;
    let p_query_return_account_count = return_account_count;
    let p_query_return_album_count = return_album_count;
    let p_query_album_types_for_count = album_types_for_count;

    let uri_str = format!("{}/api/{version}/audience/get", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("audienceId", &p_query_audience_id.to_string())]);
    if let Some(ref param_value) = p_query_app_key {
        req_builder = req_builder.query(&[("appKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_return_account_count {
        req_builder = req_builder.query(&[("returnAccountCount", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_return_album_count {
        req_builder = req_builder.query(&[("returnAlbumCount", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_album_types_for_count {
        req_builder = req_builder.query(&[("albumTypesForCount", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AudienceResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AudienceResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAudienceError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the list audiences owned by the account
pub async fn get_audience_list(configuration: &configuration::Configuration, version: f64, account_id: Option<i64>, album_ids: Option<&str>, keyword: Option<&str>, keyword_fields: Option<&str>, sort_field: Option<&str>, descending: Option<bool>, start: Option<i32>, limit: Option<i32>, send_suggestion: Option<bool>, active_only: Option<bool>, group_by_grouping_id: Option<bool>, app_key: Option<&str>, return_global: Option<bool>, exact_keyword: Option<bool>, audience_type: Option<&str>, audience_types: Option<&str>, return_account_count: Option<bool>, return_album_count: Option<bool>, album_types_for_count: Option<&str>) -> Result<Vec<models::SearchResponse>, Error<GetAudienceListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_account_id = account_id;
    let p_query_album_ids = album_ids;
    let p_query_keyword = keyword;
    let p_query_keyword_fields = keyword_fields;
    let p_query_sort_field = sort_field;
    let p_query_descending = descending;
    let p_query_start = start;
    let p_query_limit = limit;
    let p_query_send_suggestion = send_suggestion;
    let p_query_active_only = active_only;
    let p_query_group_by_grouping_id = group_by_grouping_id;
    let p_query_app_key = app_key;
    let p_query_return_global = return_global;
    let p_query_exact_keyword = exact_keyword;
    let p_query_audience_type = audience_type;
    let p_query_audience_types = audience_types;
    let p_query_return_account_count = return_account_count;
    let p_query_return_album_count = return_album_count;
    let p_query_album_types_for_count = album_types_for_count;

    let uri_str = format!("{}/api/{version}/audience/search", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_album_ids {
        req_builder = req_builder.query(&[("albumIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_keyword {
        req_builder = req_builder.query(&[("keyword", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_keyword_fields {
        req_builder = req_builder.query(&[("keywordFields", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_field {
        req_builder = req_builder.query(&[("sortField", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_descending {
        req_builder = req_builder.query(&[("descending", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start {
        req_builder = req_builder.query(&[("start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_send_suggestion {
        req_builder = req_builder.query(&[("sendSuggestion", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_active_only {
        req_builder = req_builder.query(&[("activeOnly", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_group_by_grouping_id {
        req_builder = req_builder.query(&[("groupByGroupingId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_key {
        req_builder = req_builder.query(&[("appKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_return_global {
        req_builder = req_builder.query(&[("returnGlobal", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exact_keyword {
        req_builder = req_builder.query(&[("exactKeyword", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_audience_type {
        req_builder = req_builder.query(&[("audienceType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_audience_types {
        req_builder = req_builder.query(&[("audienceTypes", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_return_account_count {
        req_builder = req_builder.query(&[("returnAccountCount", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_return_album_count {
        req_builder = req_builder.query(&[("returnAlbumCount", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_album_types_for_count {
        req_builder = req_builder.query(&[("albumTypesForCount", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::SearchResponse&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::SearchResponse&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAudienceListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets the list of available devices that can be selected by consumers and retailers.
pub async fn get_devices(configuration: &configuration::Configuration, version: f64, include_inactive: bool) -> Result<Vec<models::AudienceDeviceResponse>, Error<GetDevicesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_include_inactive = include_inactive;

    let uri_str = format!("{}/api/{version}/audience/devices", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("includeInactive", &p_query_include_inactive.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::AudienceDeviceResponse&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::AudienceDeviceResponse&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetDevicesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets the list of available experiences that can be selected by consumers and retailers.
pub async fn get_experiences(configuration: &configuration::Configuration, version: f64) -> Result<models::SirqulResponse, Error<GetExperiencesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;

    let uri_str = format!("{}/api/{version}/audience/experiences", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SirqulResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SirqulResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetExperiencesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a group of audiences. The audience and account must be valid and have the appropriate permissions to view the content.
pub async fn get_grouped_audiences(configuration: &configuration::Configuration, version: f64, account_id: i64, audience_grouping_id: &str) -> Result<models::AudienceResponse, Error<GetGroupedAudiencesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_account_id = account_id;
    let p_query_audience_grouping_id = audience_grouping_id;

    let uri_str = format!("{}/api/{version}/audience/grouped/get", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("audienceGroupingId", &p_query_audience_grouping_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AudienceResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AudienceResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetGroupedAudiencesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// List either Missions or Offers that the user matches the assigned audience.
pub async fn list_by_account(configuration: &configuration::Configuration, version: f64, account_id: i64, limit: i32, suggestion_type: &str) -> Result<models::OfferListResponse, Error<ListByAccountError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_account_id = account_id;
    let p_query_limit = limit;
    let p_query_suggestion_type = suggestion_type;

    let uri_str = format!("{}/api/{version}/audience/suggestion/list", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("limit", &p_query_limit.to_string())]);
    req_builder = req_builder.query(&[("suggestionType", &p_query_suggestion_type.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OfferListResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OfferListResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListByAccountError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a list of offer locations based on audience information provided.
pub async fn list_by_audience(configuration: &configuration::Configuration, version: f64, limit: i32, gender: Option<&str>, age: Option<i32>, category_ids: Option<&str>, latitude: Option<f64>, longitude: Option<f64>) -> Result<models::OfferListResponse, Error<ListByAudienceError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_limit = limit;
    let p_query_gender = gender;
    let p_query_age = age;
    let p_query_category_ids = category_ids;
    let p_query_latitude = latitude;
    let p_query_longitude = longitude;

    let uri_str = format!("{}/api/{version}/audience/suggestion/offersByAudience", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_gender {
        req_builder = req_builder.query(&[("gender", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_age {
        req_builder = req_builder.query(&[("age", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_category_ids {
        req_builder = req_builder.query(&[("categoryIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_latitude {
        req_builder = req_builder.query(&[("latitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_longitude {
        req_builder = req_builder.query(&[("longitude", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("limit", &p_query_limit.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OfferListResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OfferListResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListByAudienceError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Return list of recent trigger suggestions that have been sent to the user.
pub async fn list_lastest_by_account(configuration: &configuration::Configuration, version: f64, account_id: i64, timeframe: i32, suggestion_type: &str) -> Result<models::OfferListResponse, Error<ListLastestByAccountError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_account_id = account_id;
    let p_query_timeframe = timeframe;
    let p_query_suggestion_type = suggestion_type;

    let uri_str = format!("{}/api/{version}/audience/suggestion/latest", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("timeframe", &p_query_timeframe.to_string())]);
    req_builder = req_builder.query(&[("suggestionType", &p_query_suggestion_type.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OfferListResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OfferListResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListLastestByAccountError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Use the accountId to determine the associated BillableEntity. From there get a list of all triggers associated with the BillableEntity.
pub async fn send_by_account(configuration: &configuration::Configuration, version: f64, account_id: i64, latitude: f64, longitude: f64) -> Result<models::SirqulResponse, Error<SendByAccountError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_account_id = account_id;
    let p_query_latitude = latitude;
    let p_query_longitude = longitude;

    let uri_str = format!("{}/api/{version}/audience/suggestion/send", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("latitude", &p_query_latitude.to_string())]);
    req_builder = req_builder.query(&[("longitude", &p_query_longitude.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SirqulResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SirqulResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SendByAccountError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update a user defined audience.
pub async fn update_audience(configuration: &configuration::Configuration, version: f64, account_id: i64, audience_id: i64, name: Option<&str>, description: Option<&str>, search_tags: Option<&str>, gender: Option<&str>, age_groups: Option<&str>, category_ids: Option<&str>, application_ids: Option<&str>, game_experience_level: Option<&str>, devices: Option<&str>, device_ids: Option<&str>, device_versions: Option<&str>, locations: Option<&str>, radius: Option<&str>, active: Option<bool>, send_suggestion: Option<bool>, start_time_offset: Option<i32>, end_time_offset: Option<i32>, associate_description: Option<&str>, associate_type: Option<&str>, associate_id: Option<i64>, grouping_id: Option<&str>, meta_data: Option<&str>, visibility: Option<&str>, audience_type: Option<&str>, use_order: Option<bool>, cohort_regions_data: Option<&str>, app_key: Option<&str>, trilateration_types: Option<&str>, unique_name: Option<bool>) -> Result<models::AudienceResponse, Error<UpdateAudienceError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_account_id = account_id;
    let p_query_audience_id = audience_id;
    let p_query_name = name;
    let p_query_description = description;
    let p_query_search_tags = search_tags;
    let p_query_gender = gender;
    let p_query_age_groups = age_groups;
    let p_query_category_ids = category_ids;
    let p_query_application_ids = application_ids;
    let p_query_game_experience_level = game_experience_level;
    let p_query_devices = devices;
    let p_query_device_ids = device_ids;
    let p_query_device_versions = device_versions;
    let p_query_locations = locations;
    let p_query_radius = radius;
    let p_query_active = active;
    let p_query_send_suggestion = send_suggestion;
    let p_query_start_time_offset = start_time_offset;
    let p_query_end_time_offset = end_time_offset;
    let p_query_associate_description = associate_description;
    let p_query_associate_type = associate_type;
    let p_query_associate_id = associate_id;
    let p_query_grouping_id = grouping_id;
    let p_query_meta_data = meta_data;
    let p_query_visibility = visibility;
    let p_query_audience_type = audience_type;
    let p_query_use_order = use_order;
    let p_query_cohort_regions_data = cohort_regions_data;
    let p_query_app_key = app_key;
    let p_query_trilateration_types = trilateration_types;
    let p_query_unique_name = unique_name;

    let uri_str = format!("{}/api/{version}/audience/update", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("audienceId", &p_query_audience_id.to_string())]);
    if let Some(ref param_value) = p_query_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_description {
        req_builder = req_builder.query(&[("description", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search_tags {
        req_builder = req_builder.query(&[("searchTags", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_gender {
        req_builder = req_builder.query(&[("gender", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_age_groups {
        req_builder = req_builder.query(&[("ageGroups", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_category_ids {
        req_builder = req_builder.query(&[("categoryIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_application_ids {
        req_builder = req_builder.query(&[("applicationIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_game_experience_level {
        req_builder = req_builder.query(&[("gameExperienceLevel", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_devices {
        req_builder = req_builder.query(&[("devices", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_device_ids {
        req_builder = req_builder.query(&[("deviceIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_device_versions {
        req_builder = req_builder.query(&[("deviceVersions", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_locations {
        req_builder = req_builder.query(&[("locations", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_radius {
        req_builder = req_builder.query(&[("radius", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_active {
        req_builder = req_builder.query(&[("active", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_send_suggestion {
        req_builder = req_builder.query(&[("sendSuggestion", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_time_offset {
        req_builder = req_builder.query(&[("startTimeOffset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_time_offset {
        req_builder = req_builder.query(&[("endTimeOffset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_associate_description {
        req_builder = req_builder.query(&[("associateDescription", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_associate_type {
        req_builder = req_builder.query(&[("associateType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_associate_id {
        req_builder = req_builder.query(&[("associateId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_grouping_id {
        req_builder = req_builder.query(&[("groupingId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_meta_data {
        req_builder = req_builder.query(&[("metaData", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_visibility {
        req_builder = req_builder.query(&[("visibility", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_audience_type {
        req_builder = req_builder.query(&[("audienceType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_use_order {
        req_builder = req_builder.query(&[("useOrder", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cohort_regions_data {
        req_builder = req_builder.query(&[("cohortRegionsData", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_key {
        req_builder = req_builder.query(&[("appKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_trilateration_types {
        req_builder = req_builder.query(&[("trilaterationTypes", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_unique_name {
        req_builder = req_builder.query(&[("uniqueName", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AudienceResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AudienceResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateAudienceError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

