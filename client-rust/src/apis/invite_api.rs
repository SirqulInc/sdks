/*
 * Sirqul IoT Platform
 *
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`accept_invite`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AcceptInviteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`album_contest_invite`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AlbumContestInviteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`album_invite`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AlbumInviteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`event_invite`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EventInviteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`game_invite`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GameInviteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_invite`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetInviteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`mission_invite`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MissionInviteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`offer_invite`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OfferInviteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`offer_location_invite`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OfferLocationInviteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retailer_location_invite`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetailerLocationInviteError {
    UnknownValue(serde_json::Value),
}


/// Allows a user to accept an invite. The user could also become the inviter's friend.
pub async fn accept_invite(configuration: &configuration::Configuration, version: f64, token: &str, account_id: i64, album_id: Option<i64>, mission_id: Option<i64>, album_contest_id: Option<i64>, offer_id: Option<i64>, offer_location_id: Option<i64>, retailer_location_id: Option<i64>, app_key: Option<&str>, auto_friend: Option<bool>, auto_attend_event: Option<bool>, auto_favorite_offer: Option<bool>, auto_favorite_offer_location: Option<bool>, auto_favorite_retailer_location: Option<bool>) -> Result<models::ConsumerInviteResponse, Error<AcceptInviteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_token = token;
    let p_query_account_id = account_id;
    let p_query_album_id = album_id;
    let p_query_mission_id = mission_id;
    let p_query_album_contest_id = album_contest_id;
    let p_query_offer_id = offer_id;
    let p_query_offer_location_id = offer_location_id;
    let p_query_retailer_location_id = retailer_location_id;
    let p_query_app_key = app_key;
    let p_query_auto_friend = auto_friend;
    let p_query_auto_attend_event = auto_attend_event;
    let p_query_auto_favorite_offer = auto_favorite_offer;
    let p_query_auto_favorite_offer_location = auto_favorite_offer_location;
    let p_query_auto_favorite_retailer_location = auto_favorite_retailer_location;

    let uri_str = format!("{}/api/{version}/invite/accept", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("token", &p_query_token.to_string())]);
    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    if let Some(ref param_value) = p_query_album_id {
        req_builder = req_builder.query(&[("albumId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mission_id {
        req_builder = req_builder.query(&[("missionId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_album_contest_id {
        req_builder = req_builder.query(&[("albumContestId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offer_id {
        req_builder = req_builder.query(&[("offerId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offer_location_id {
        req_builder = req_builder.query(&[("offerLocationId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_retailer_location_id {
        req_builder = req_builder.query(&[("retailerLocationId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_key {
        req_builder = req_builder.query(&[("appKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_friend {
        req_builder = req_builder.query(&[("autoFriend", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_attend_event {
        req_builder = req_builder.query(&[("autoAttendEvent", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_favorite_offer {
        req_builder = req_builder.query(&[("autoFavoriteOffer", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_favorite_offer_location {
        req_builder = req_builder.query(&[("autoFavoriteOfferLocation", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auto_favorite_retailer_location {
        req_builder = req_builder.query(&[("autoFavoriteRetailerLocation", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ConsumerInviteResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ConsumerInviteResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AcceptInviteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Allows a user to invite people to gain access to a contest. This will generate an invite token, which when used, will give the invitee access to a contest (whether it is private or not). The invitee will also become the user's friend when the invitation is accepted.
pub async fn album_contest_invite(configuration: &configuration::Configuration, version: f64, device_id: Option<&str>, account_id: Option<i64>, app_id: Option<i64>, app_key: Option<&str>, album_contest_id: Option<i64>, latitude: Option<f64>, longitude: Option<f64>) -> Result<models::InviteResponse, Error<AlbumContestInviteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_app_id = app_id;
    let p_query_app_key = app_key;
    let p_query_album_contest_id = album_contest_id;
    let p_query_latitude = latitude;
    let p_query_longitude = longitude;

    let uri_str = format!("{}/api/{version}/invite/albumContest", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_id {
        req_builder = req_builder.query(&[("appId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_key {
        req_builder = req_builder.query(&[("appKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_album_contest_id {
        req_builder = req_builder.query(&[("albumContestId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_latitude {
        req_builder = req_builder.query(&[("latitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_longitude {
        req_builder = req_builder.query(&[("longitude", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::InviteResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::InviteResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AlbumContestInviteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Allows a user to invite people to gain access to a collection. This will generate an invite token, which when used, will give the invitee access to a collection (whether it is private or not). The invitee will also become the user's friend when the invitation is accepted.
pub async fn album_invite(configuration: &configuration::Configuration, version: f64, device_id: Option<&str>, account_id: Option<i64>, app_id: Option<i64>, app_key: Option<&str>, album_id: Option<i64>, latitude: Option<f64>, longitude: Option<f64>) -> Result<models::InviteResponse, Error<AlbumInviteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_app_id = app_id;
    let p_query_app_key = app_key;
    let p_query_album_id = album_id;
    let p_query_latitude = latitude;
    let p_query_longitude = longitude;

    let uri_str = format!("{}/api/{version}/invite/album", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_id {
        req_builder = req_builder.query(&[("appId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_key {
        req_builder = req_builder.query(&[("appKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_album_id {
        req_builder = req_builder.query(&[("albumId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_latitude {
        req_builder = req_builder.query(&[("latitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_longitude {
        req_builder = req_builder.query(&[("longitude", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::InviteResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::InviteResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AlbumInviteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Allows a user to invite people to attend an event. This will generate an invite token, which when used, will allow the invitee to add the offer to their wallet.
pub async fn event_invite(configuration: &configuration::Configuration, version: f64, account_id: i64, app_key: &str, listing_id: i64, receiver_account_ids: Option<&str>, retailer_location_id: Option<i64>) -> Result<models::InviteResponse, Error<EventInviteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_account_id = account_id;
    let p_query_app_key = app_key;
    let p_query_listing_id = listing_id;
    let p_query_receiver_account_ids = receiver_account_ids;
    let p_query_retailer_location_id = retailer_location_id;

    let uri_str = format!("{}/api/{version}/invite/event", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    if let Some(ref param_value) = p_query_receiver_account_ids {
        req_builder = req_builder.query(&[("receiverAccountIds", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("appKey", &p_query_app_key.to_string())]);
    req_builder = req_builder.query(&[("listingId", &p_query_listing_id.to_string())]);
    if let Some(ref param_value) = p_query_retailer_location_id {
        req_builder = req_builder.query(&[("retailerLocationId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::InviteResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::InviteResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EventInviteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Allows a user to invite people to gain access to an album. This will generate an invite token, which when used, will give the invitee access to an album (whether it is private or not). The invitee will also become the user's friend when the invitation is accepted.
pub async fn game_invite(configuration: &configuration::Configuration, version: f64, device_id: Option<&str>, account_id: Option<i64>, app_id: Option<i64>, app_key: Option<&str>, game_level_id: Option<i64>, latitude: Option<f64>, longitude: Option<f64>) -> Result<models::InviteResponse, Error<GameInviteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_app_id = app_id;
    let p_query_app_key = app_key;
    let p_query_game_level_id = game_level_id;
    let p_query_latitude = latitude;
    let p_query_longitude = longitude;

    let uri_str = format!("{}/api/{version}/invite/gameLevel", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_id {
        req_builder = req_builder.query(&[("appId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_key {
        req_builder = req_builder.query(&[("appKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_game_level_id {
        req_builder = req_builder.query(&[("gameLevelId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_latitude {
        req_builder = req_builder.query(&[("latitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_longitude {
        req_builder = req_builder.query(&[("longitude", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::InviteResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::InviteResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GameInviteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// This is used to determine whether an invite token is valid. If the token is valid, this will also return information about who invited the user, and what they are invited to.
pub async fn get_invite(configuration: &configuration::Configuration, version: f64, account_id: Option<i64>, token: Option<&str>, album_id: Option<i64>, mission_id: Option<i64>, album_contest_id: Option<i64>, offer_id: Option<i64>, offer_location_id: Option<i64>, retailer_location_id: Option<i64>, app_key: Option<&str>) -> Result<models::SirqulResponse, Error<GetInviteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_account_id = account_id;
    let p_query_token = token;
    let p_query_album_id = album_id;
    let p_query_mission_id = mission_id;
    let p_query_album_contest_id = album_contest_id;
    let p_query_offer_id = offer_id;
    let p_query_offer_location_id = offer_location_id;
    let p_query_retailer_location_id = retailer_location_id;
    let p_query_app_key = app_key;

    let uri_str = format!("{}/api/{version}/invite/get", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_token {
        req_builder = req_builder.query(&[("token", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_album_id {
        req_builder = req_builder.query(&[("albumId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mission_id {
        req_builder = req_builder.query(&[("missionId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_album_contest_id {
        req_builder = req_builder.query(&[("albumContestId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offer_id {
        req_builder = req_builder.query(&[("offerId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offer_location_id {
        req_builder = req_builder.query(&[("offerLocationId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_retailer_location_id {
        req_builder = req_builder.query(&[("retailerLocationId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_key {
        req_builder = req_builder.query(&[("appKey", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SirqulResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SirqulResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetInviteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Allows a user to invite people to gain access to a mission. This will generate an invite token, which when used, will give the invitee access to a mission (whether it is private or not). The invitee will also become the user's friend when the invitation is accepted.
pub async fn mission_invite(configuration: &configuration::Configuration, version: f64, device_id: Option<&str>, account_id: Option<i64>, app_id: Option<i64>, app_key: Option<&str>, mission_id: Option<i64>, latitude: Option<f64>, longitude: Option<f64>) -> Result<models::InviteResponse, Error<MissionInviteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_app_id = app_id;
    let p_query_app_key = app_key;
    let p_query_mission_id = mission_id;
    let p_query_latitude = latitude;
    let p_query_longitude = longitude;

    let uri_str = format!("{}/api/{version}/invite/mission", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_id {
        req_builder = req_builder.query(&[("appId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_key {
        req_builder = req_builder.query(&[("appKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mission_id {
        req_builder = req_builder.query(&[("missionId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_latitude {
        req_builder = req_builder.query(&[("latitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_longitude {
        req_builder = req_builder.query(&[("longitude", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::InviteResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::InviteResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MissionInviteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Allows a user to invite people to favorite an offer. This will generate an invite token, which when used, will give the invitee the offer in their favorite's list.
pub async fn offer_invite(configuration: &configuration::Configuration, version: f64, account_id: i64, app_key: &str, offer_id: i64) -> Result<models::InviteResponse, Error<OfferInviteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_account_id = account_id;
    let p_query_app_key = app_key;
    let p_query_offer_id = offer_id;

    let uri_str = format!("{}/api/{version}/invite/offer", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("appKey", &p_query_app_key.to_string())]);
    req_builder = req_builder.query(&[("offerId", &p_query_offer_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::InviteResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::InviteResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OfferInviteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Allows a user to invite people to favorite an offer location. This will generate an invite token, which when used, will give the invitee the offer location in their favorite's list.
pub async fn offer_location_invite(configuration: &configuration::Configuration, version: f64, account_id: i64, app_key: &str, offer_location_id: i64) -> Result<models::InviteResponse, Error<OfferLocationInviteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_account_id = account_id;
    let p_query_app_key = app_key;
    let p_query_offer_location_id = offer_location_id;

    let uri_str = format!("{}/api/{version}/invite/offerLocation", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("appKey", &p_query_app_key.to_string())]);
    req_builder = req_builder.query(&[("offerLocationId", &p_query_offer_location_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::InviteResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::InviteResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OfferLocationInviteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Allows a user to invite people to favorite a retailer location. This will generate an invite token, which when used, will give the invitee the retailer location in their favorite's list.
pub async fn retailer_location_invite(configuration: &configuration::Configuration, version: f64, account_id: i64, app_key: &str, retailer_location_id: i64, album_id: Option<i64>) -> Result<models::InviteResponse, Error<RetailerLocationInviteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_account_id = account_id;
    let p_query_app_key = app_key;
    let p_query_retailer_location_id = retailer_location_id;
    let p_query_album_id = album_id;

    let uri_str = format!("{}/api/{version}/invite/retailerLocation", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("appKey", &p_query_app_key.to_string())]);
    req_builder = req_builder.query(&[("retailerLocationId", &p_query_retailer_location_id.to_string())]);
    if let Some(ref param_value) = p_query_album_id {
        req_builder = req_builder.query(&[("albumId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::InviteResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::InviteResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetailerLocationInviteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

