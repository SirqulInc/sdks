/*
 * Sirqul IoT Platform
 *
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`consumer_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConsumerCreateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`consumer_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConsumerUpdateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`queue_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum QueueCreateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`queue_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum QueueDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`queue_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum QueueGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`queue_publish`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum QueuePublishError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`queue_search`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum QueueSearchError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`queue_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum QueueUpdateError {
    UnknownValue(serde_json::Value),
}


/// Create a connection to an existing amqp queue and register as a consumer.
pub async fn consumer_create(configuration: &configuration::Configuration, version: f64, app_key: &str, name: &str, hostname: &str, username: &str, password: &str, data_mapping: &str, device_id: Option<&str>, account_id: Option<i64>, port: Option<i32>, virtual_host: Option<&str>, exchanger: Option<&str>, exchanger_type: Option<&str>, workers: Option<i32>, use_ssl: Option<bool>) -> Result<models::QueueResponse, Error<ConsumerCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_app_key = app_key;
    let p_query_name = name;
    let p_query_hostname = hostname;
    let p_query_username = username;
    let p_query_password = password;
    let p_query_data_mapping = data_mapping;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_port = port;
    let p_query_virtual_host = virtual_host;
    let p_query_exchanger = exchanger;
    let p_query_exchanger_type = exchanger_type;
    let p_query_workers = workers;
    let p_query_use_ssl = use_ssl;

    let uri_str = format!("{}/api/{version}/queue/consumer/create", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("appKey", &p_query_app_key.to_string())]);
    req_builder = req_builder.query(&[("name", &p_query_name.to_string())]);
    req_builder = req_builder.query(&[("hostname", &p_query_hostname.to_string())]);
    if let Some(ref param_value) = p_query_port {
        req_builder = req_builder.query(&[("port", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("username", &p_query_username.to_string())]);
    req_builder = req_builder.query(&[("password", &p_query_password.to_string())]);
    if let Some(ref param_value) = p_query_virtual_host {
        req_builder = req_builder.query(&[("virtualHost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchanger {
        req_builder = req_builder.query(&[("exchanger", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exchanger_type {
        req_builder = req_builder.query(&[("exchangerType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_workers {
        req_builder = req_builder.query(&[("workers", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("dataMapping", &p_query_data_mapping.to_string())]);
    if let Some(ref param_value) = p_query_use_ssl {
        req_builder = req_builder.query(&[("useSSL", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::QueueResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::QueueResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ConsumerCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update an existing amqp queue's data mapping.
pub async fn consumer_update(configuration: &configuration::Configuration, version: f64, app_key: &str, queue_id: i64, data_mapping: &str, device_id: Option<&str>, account_id: Option<i64>, use_ssl: Option<bool>) -> Result<models::QueueResponse, Error<ConsumerUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_app_key = app_key;
    let p_query_queue_id = queue_id;
    let p_query_data_mapping = data_mapping;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_use_ssl = use_ssl;

    let uri_str = format!("{}/api/{version}/queue/consumer/update", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("appKey", &p_query_app_key.to_string())]);
    req_builder = req_builder.query(&[("queueId", &p_query_queue_id.to_string())]);
    req_builder = req_builder.query(&[("dataMapping", &p_query_data_mapping.to_string())]);
    if let Some(ref param_value) = p_query_use_ssl {
        req_builder = req_builder.query(&[("useSSL", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::QueueResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::QueueResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ConsumerUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create a basic AMQP queue. If the username and password and virtual host is not sepcified, the queue will be created on the virtual host assigned to the application.
pub async fn queue_create(configuration: &configuration::Configuration, version: f64, app_key: &str, name: &str, device_id: Option<&str>, account_id: Option<i64>, workers: Option<i32>, analytic_tags: Option<&str>, hostname: Option<&str>, port: Option<i32>, username: Option<&str>, password: Option<&str>, virtual_host: Option<&str>, use_ssl: Option<bool>) -> Result<models::QueueResponse, Error<QueueCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_app_key = app_key;
    let p_query_name = name;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_workers = workers;
    let p_query_analytic_tags = analytic_tags;
    let p_query_hostname = hostname;
    let p_query_port = port;
    let p_query_username = username;
    let p_query_password = password;
    let p_query_virtual_host = virtual_host;
    let p_query_use_ssl = use_ssl;

    let uri_str = format!("{}/api/{version}/queue/create", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("appKey", &p_query_app_key.to_string())]);
    req_builder = req_builder.query(&[("name", &p_query_name.to_string())]);
    if let Some(ref param_value) = p_query_workers {
        req_builder = req_builder.query(&[("workers", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_analytic_tags {
        req_builder = req_builder.query(&[("analyticTags", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_hostname {
        req_builder = req_builder.query(&[("hostname", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_port {
        req_builder = req_builder.query(&[("port", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_username {
        req_builder = req_builder.query(&[("username", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_password {
        req_builder = req_builder.query(&[("password", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_virtual_host {
        req_builder = req_builder.query(&[("virtualHost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_use_ssl {
        req_builder = req_builder.query(&[("useSSL", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::QueueResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::QueueResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<QueueCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete the stored queue record and close any active connections to the AMQP servers.
pub async fn queue_delete(configuration: &configuration::Configuration, version: f64, queue_id: i64, device_id: Option<&str>, account_id: Option<i64>) -> Result<models::SirqulResponse, Error<QueueDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_queue_id = queue_id;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;

    let uri_str = format!("{}/api/{version}/queue/delete", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("queueId", &p_query_queue_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SirqulResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SirqulResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<QueueDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the stored queue record. Must supply the queueId, or the name and hostname and virtualHost, or the name and appKey to find the record.
pub async fn queue_get(configuration: &configuration::Configuration, version: f64, device_id: Option<&str>, account_id: Option<i64>, queue_id: Option<i64>, app_key: Option<&str>, name: Option<&str>, hostname: Option<&str>, virtual_host: Option<&str>) -> Result<models::QueueResponse, Error<QueueGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_queue_id = queue_id;
    let p_query_app_key = app_key;
    let p_query_name = name;
    let p_query_hostname = hostname;
    let p_query_virtual_host = virtual_host;

    let uri_str = format!("{}/api/{version}/queue/get", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_queue_id {
        req_builder = req_builder.query(&[("queueId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_key {
        req_builder = req_builder.query(&[("appKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_hostname {
        req_builder = req_builder.query(&[("hostname", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_virtual_host {
        req_builder = req_builder.query(&[("virtualHost", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::QueueResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::QueueResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<QueueGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Publish a message to a stored queue. Must supply the queueId, or the name and hostname and virtualHost, or the name and appKey to find the record.
pub async fn queue_publish(configuration: &configuration::Configuration, version: f64, message: &str, queue_id: Option<i64>, app_key: Option<&str>, name: Option<&str>, hostname: Option<&str>, virtual_host: Option<&str>) -> Result<models::SirqulResponse, Error<QueuePublishError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_message = message;
    let p_query_queue_id = queue_id;
    let p_query_app_key = app_key;
    let p_query_name = name;
    let p_query_hostname = hostname;
    let p_query_virtual_host = virtual_host;

    let uri_str = format!("{}/api/{version}/queue/publish", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_queue_id {
        req_builder = req_builder.query(&[("queueId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_key {
        req_builder = req_builder.query(&[("appKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_hostname {
        req_builder = req_builder.query(&[("hostname", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_virtual_host {
        req_builder = req_builder.query(&[("virtualHost", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("message", &p_query_message.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SirqulResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SirqulResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<QueuePublishError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the queues setup for the BillableEntity's applications.
pub async fn queue_search(configuration: &configuration::Configuration, version: f64, queue_id: Option<i64>, device_id: Option<&str>, account_id: Option<i64>, name: Option<&str>, start: Option<i32>, limit: Option<i32>) -> Result<models::QueueResponse, Error<QueueSearchError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_queue_id = queue_id;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_name = name;
    let p_query_start = start;
    let p_query_limit = limit;

    let uri_str = format!("{}/api/{version}/queue/search", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_queue_id {
        req_builder = req_builder.query(&[("queueId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start {
        req_builder = req_builder.query(&[("start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::QueueResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::QueueResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<QueueSearchError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update the basic AMQP queue.
pub async fn queue_update(configuration: &configuration::Configuration, version: f64, queue_id: i64, device_id: Option<&str>, account_id: Option<i64>, app_key: Option<&str>, workers: Option<i32>, analytic_tags: Option<&str>, hostname: Option<&str>, port: Option<i32>, username: Option<&str>, password: Option<&str>, virtual_host: Option<&str>, use_ssl: Option<bool>) -> Result<models::QueueResponse, Error<QueueUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_queue_id = queue_id;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_app_key = app_key;
    let p_query_workers = workers;
    let p_query_analytic_tags = analytic_tags;
    let p_query_hostname = hostname;
    let p_query_port = port;
    let p_query_username = username;
    let p_query_password = password;
    let p_query_virtual_host = virtual_host;
    let p_query_use_ssl = use_ssl;

    let uri_str = format!("{}/api/{version}/queue/update", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_key {
        req_builder = req_builder.query(&[("appKey", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("queueId", &p_query_queue_id.to_string())]);
    if let Some(ref param_value) = p_query_workers {
        req_builder = req_builder.query(&[("workers", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_analytic_tags {
        req_builder = req_builder.query(&[("analyticTags", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_hostname {
        req_builder = req_builder.query(&[("hostname", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_port {
        req_builder = req_builder.query(&[("port", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_username {
        req_builder = req_builder.query(&[("username", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_password {
        req_builder = req_builder.query(&[("password", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_virtual_host {
        req_builder = req_builder.query(&[("virtualHost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_use_ssl {
        req_builder = req_builder.query(&[("useSSL", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::QueueResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::QueueResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<QueueUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

