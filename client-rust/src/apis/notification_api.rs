/*
 * Sirqul IoT Platform
 *
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`create_notification_template`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateNotificationTemplateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_or_update_blocked_notifications`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateOrUpdateBlockedNotificationsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_notification_template`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteNotificationTemplateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_notification_template`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetNotificationTemplateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_notifications`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetNotificationsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`register_notification_token`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RegisterNotificationTokenError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_blocked_notifications`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchBlockedNotificationsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_notification_template`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchNotificationTemplateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_recipients`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchRecipientsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_recipients_count`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchRecipientsCountError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`send_batch_notifications`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SendBatchNotificationsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`send_custom_notifications`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SendCustomNotificationsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_notification_template`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateNotificationTemplateError {
    UnknownValue(serde_json::Value),
}


/// Create a notification template. Developers will only be able to create notification templates for their own applications.
pub async fn create_notification_template(configuration: &configuration::Configuration, version: f64, account_id: i64, conduit: &str, title: &str, body: &str, app_key: Option<&str>, event: Option<&str>, tags: Option<&str>) -> Result<models::NotificationTemplateResponse, Error<CreateNotificationTemplateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_account_id = account_id;
    let p_query_conduit = conduit;
    let p_query_title = title;
    let p_query_body = body;
    let p_query_app_key = app_key;
    let p_query_event = event;
    let p_query_tags = tags;

    let uri_str = format!("{}/api/{version}/notification/template/create", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    if let Some(ref param_value) = p_query_app_key {
        req_builder = req_builder.query(&[("appKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_event {
        req_builder = req_builder.query(&[("event", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("conduit", &p_query_conduit.to_string())]);
    req_builder = req_builder.query(&[("title", &p_query_title.to_string())]);
    req_builder = req_builder.query(&[("body", &p_query_body.to_string())]);
    if let Some(ref param_value) = p_query_tags {
        req_builder = req_builder.query(&[("tags", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::NotificationTemplateResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::NotificationTemplateResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateNotificationTemplateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create or update blocked notification settings
pub async fn create_or_update_blocked_notifications(configuration: &configuration::Configuration, version: f64, app_key: &str, data: &str, account_id: Option<i64>) -> Result<models::BlockedNotificationResponse, Error<CreateOrUpdateBlockedNotificationsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_app_key = app_key;
    let p_query_data = data;
    let p_query_account_id = account_id;

    let uri_str = format!("{}/api/{version}/notification/blocked/batch", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("appKey", &p_query_app_key.to_string())]);
    req_builder = req_builder.query(&[("data", &p_query_data.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BlockedNotificationResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BlockedNotificationResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateOrUpdateBlockedNotificationsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deletes a notification template. Developers will only be able to delete notification templates for their own applications.
pub async fn delete_notification_template(configuration: &configuration::Configuration, version: f64, account_id: i64, notification_template_id: i64) -> Result<models::NotificationTemplateResponse, Error<DeleteNotificationTemplateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_account_id = account_id;
    let p_query_notification_template_id = notification_template_id;

    let uri_str = format!("{}/api/{version}/notification/template/delete", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("notificationTemplateId", &p_query_notification_template_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::NotificationTemplateResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::NotificationTemplateResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteNotificationTemplateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the details of a notification template. Developers will only be able to see notification templates for their own applications.
pub async fn get_notification_template(configuration: &configuration::Configuration, version: f64, account_id: i64, notification_template_id: i64) -> Result<models::NotificationTemplateResponse, Error<GetNotificationTemplateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_account_id = account_id;
    let p_query_notification_template_id = notification_template_id;

    let uri_str = format!("{}/api/{version}/notification/template/get", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("notificationTemplateId", &p_query_notification_template_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::NotificationTemplateResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::NotificationTemplateResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetNotificationTemplateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a list of notifications for a user. If the \"markAsRead\" parameter is set to true, the returned notifications will be marked as \"read\" after the response has been sent. By default, read messages will not be returned, so to see read messages, set \"returnReadMessages\" to true.
pub async fn get_notifications(configuration: &configuration::Configuration, version: f64, device_id: Option<&str>, account_id: Option<i64>, connection_account_id: Option<i64>, app_key: Option<&str>, event_type: Option<&str>, content_ids: Option<&str>, content_types: Option<&str>, parent_ids: Option<&str>, parent_types: Option<&str>, action_category: Option<&str>, conduits: Option<&str>, keyword: Option<&str>, return_read_messages: Option<bool>, mark_as_read: Option<bool>, from_date: Option<i64>, latitude: Option<f64>, longitude: Option<f64>, return_sent: Option<bool>, ignore_flagged: Option<bool>, start: Option<i32>, limit: Option<i32>) -> Result<models::NotificationMessageListResponse, Error<GetNotificationsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_connection_account_id = connection_account_id;
    let p_query_app_key = app_key;
    let p_query_event_type = event_type;
    let p_query_content_ids = content_ids;
    let p_query_content_types = content_types;
    let p_query_parent_ids = parent_ids;
    let p_query_parent_types = parent_types;
    let p_query_action_category = action_category;
    let p_query_conduits = conduits;
    let p_query_keyword = keyword;
    let p_query_return_read_messages = return_read_messages;
    let p_query_mark_as_read = mark_as_read;
    let p_query_from_date = from_date;
    let p_query_latitude = latitude;
    let p_query_longitude = longitude;
    let p_query_return_sent = return_sent;
    let p_query_ignore_flagged = ignore_flagged;
    let p_query_start = start;
    let p_query_limit = limit;

    let uri_str = format!("{}/api/{version}/notification/search", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_connection_account_id {
        req_builder = req_builder.query(&[("connectionAccountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_key {
        req_builder = req_builder.query(&[("appKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_event_type {
        req_builder = req_builder.query(&[("eventType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_content_ids {
        req_builder = req_builder.query(&[("contentIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_content_types {
        req_builder = req_builder.query(&[("contentTypes", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_parent_ids {
        req_builder = req_builder.query(&[("parentIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_parent_types {
        req_builder = req_builder.query(&[("parentTypes", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_action_category {
        req_builder = req_builder.query(&[("actionCategory", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_conduits {
        req_builder = req_builder.query(&[("conduits", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_keyword {
        req_builder = req_builder.query(&[("keyword", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_return_read_messages {
        req_builder = req_builder.query(&[("returnReadMessages", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mark_as_read {
        req_builder = req_builder.query(&[("markAsRead", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_from_date {
        req_builder = req_builder.query(&[("fromDate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_latitude {
        req_builder = req_builder.query(&[("latitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_longitude {
        req_builder = req_builder.query(&[("longitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_return_sent {
        req_builder = req_builder.query(&[("returnSent", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ignore_flagged {
        req_builder = req_builder.query(&[("ignoreFlagged", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start {
        req_builder = req_builder.query(&[("start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::NotificationMessageListResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::NotificationMessageListResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetNotificationsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Register a token to send application dependent notifications like Google Cloud Messaging, or Apple Push Notifications.
pub async fn register_notification_token(configuration: &configuration::Configuration, version: f64, token: &str, push_type: &str, device_id: Option<&str>, account_id: Option<i64>, environment: Option<&str>, app_key: Option<&str>, game_type: Option<&str>, active: Option<bool>, latitude: Option<f64>, longitude: Option<f64>) -> Result<models::SirqulResponse, Error<RegisterNotificationTokenError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_token = token;
    let p_query_push_type = push_type;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_environment = environment;
    let p_query_app_key = app_key;
    let p_query_game_type = game_type;
    let p_query_active = active;
    let p_query_latitude = latitude;
    let p_query_longitude = longitude;

    let uri_str = format!("{}/api/{version}/notification/token", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("token", &p_query_token.to_string())]);
    req_builder = req_builder.query(&[("pushType", &p_query_push_type.to_string())]);
    if let Some(ref param_value) = p_query_environment {
        req_builder = req_builder.query(&[("environment", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_key {
        req_builder = req_builder.query(&[("appKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_game_type {
        req_builder = req_builder.query(&[("gameType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_active {
        req_builder = req_builder.query(&[("active", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_latitude {
        req_builder = req_builder.query(&[("latitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_longitude {
        req_builder = req_builder.query(&[("longitude", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SirqulResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SirqulResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RegisterNotificationTokenError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Search on the user's blocked notification settings
pub async fn search_blocked_notifications(configuration: &configuration::Configuration, version: f64, app_key: &str, account_id: Option<i64>, search_tags: Option<&str>, events: Option<&str>, conduits: Option<&str>, custom_types: Option<&str>, content_types: Option<&str>, content_ids: Option<&str>, sort_field: Option<&str>, descending: Option<bool>, start: Option<i32>, limit: Option<i32>) -> Result<models::BlockedNotificationResponse, Error<SearchBlockedNotificationsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_app_key = app_key;
    let p_query_account_id = account_id;
    let p_query_search_tags = search_tags;
    let p_query_events = events;
    let p_query_conduits = conduits;
    let p_query_custom_types = custom_types;
    let p_query_content_types = content_types;
    let p_query_content_ids = content_ids;
    let p_query_sort_field = sort_field;
    let p_query_descending = descending;
    let p_query_start = start;
    let p_query_limit = limit;

    let uri_str = format!("{}/api/{version}/notification/blocked/search", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("appKey", &p_query_app_key.to_string())]);
    if let Some(ref param_value) = p_query_search_tags {
        req_builder = req_builder.query(&[("searchTags", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_events {
        req_builder = req_builder.query(&[("events", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_conduits {
        req_builder = req_builder.query(&[("conduits", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_custom_types {
        req_builder = req_builder.query(&[("customTypes", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_content_types {
        req_builder = req_builder.query(&[("contentTypes", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_content_ids {
        req_builder = req_builder.query(&[("contentIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_field {
        req_builder = req_builder.query(&[("sortField", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_descending {
        req_builder = req_builder.query(&[("descending", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start {
        req_builder = req_builder.query(&[("start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BlockedNotificationResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BlockedNotificationResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchBlockedNotificationsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Search for notification templates on owned applications.
pub async fn search_notification_template(configuration: &configuration::Configuration, version: f64, account_id: i64, sort_field: &str, descending: bool, start: i32, limit: i32, app_key: Option<&str>, event: Option<&str>, conduit: Option<&str>, global_only: Option<bool>, reserved_only: Option<bool>, keyword: Option<&str>) -> Result<models::NotificationTemplateResponse, Error<SearchNotificationTemplateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_account_id = account_id;
    let p_query_sort_field = sort_field;
    let p_query_descending = descending;
    let p_query_start = start;
    let p_query_limit = limit;
    let p_query_app_key = app_key;
    let p_query_event = event;
    let p_query_conduit = conduit;
    let p_query_global_only = global_only;
    let p_query_reserved_only = reserved_only;
    let p_query_keyword = keyword;

    let uri_str = format!("{}/api/{version}/notification/template/search", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    if let Some(ref param_value) = p_query_app_key {
        req_builder = req_builder.query(&[("appKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_event {
        req_builder = req_builder.query(&[("event", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_conduit {
        req_builder = req_builder.query(&[("conduit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_global_only {
        req_builder = req_builder.query(&[("globalOnly", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_reserved_only {
        req_builder = req_builder.query(&[("reservedOnly", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_keyword {
        req_builder = req_builder.query(&[("keyword", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("sortField", &p_query_sort_field.to_string())]);
    req_builder = req_builder.query(&[("descending", &p_query_descending.to_string())]);
    req_builder = req_builder.query(&[("start", &p_query_start.to_string())]);
    req_builder = req_builder.query(&[("limit", &p_query_limit.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::NotificationTemplateResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::NotificationTemplateResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchNotificationTemplateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Search for application users to send notifications.
pub async fn search_recipients(configuration: &configuration::Configuration, version: f64, sort_field: &str, device_id: Option<&str>, account_id: Option<i64>, app_key: Option<&str>, conduit: Option<&str>, keyword: Option<&str>, audience_id: Option<i64>, audience_ids: Option<&str>, connection_group_ids: Option<&str>, recipient_account_ids: Option<&str>, descending: Option<bool>, start: Option<i32>, limit: Option<i32>) -> Result<Vec<models::NotificationRecipientResponse>, Error<SearchRecipientsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_sort_field = sort_field;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_app_key = app_key;
    let p_query_conduit = conduit;
    let p_query_keyword = keyword;
    let p_query_audience_id = audience_id;
    let p_query_audience_ids = audience_ids;
    let p_query_connection_group_ids = connection_group_ids;
    let p_query_recipient_account_ids = recipient_account_ids;
    let p_query_descending = descending;
    let p_query_start = start;
    let p_query_limit = limit;

    let uri_str = format!("{}/api/{version}/notification/recipient/search", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_key {
        req_builder = req_builder.query(&[("appKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_conduit {
        req_builder = req_builder.query(&[("conduit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_keyword {
        req_builder = req_builder.query(&[("keyword", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_audience_id {
        req_builder = req_builder.query(&[("audienceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_audience_ids {
        req_builder = req_builder.query(&[("audienceIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_connection_group_ids {
        req_builder = req_builder.query(&[("connectionGroupIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_recipient_account_ids {
        req_builder = req_builder.query(&[("recipientAccountIds", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("sortField", &p_query_sort_field.to_string())]);
    if let Some(ref param_value) = p_query_descending {
        req_builder = req_builder.query(&[("descending", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start {
        req_builder = req_builder.query(&[("start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::NotificationRecipientResponse&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::NotificationRecipientResponse&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchRecipientsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Search for application users to send notifications (count/grouped variant).
pub async fn search_recipients_count(configuration: &configuration::Configuration, version: f64, device_id: Option<&str>, account_id: Option<i64>, app_key: Option<&str>, conduit: Option<&str>, keyword: Option<&str>, audience_id: Option<i64>, audience_ids: Option<&str>, connection_group_ids: Option<&str>, sort_field: Option<&str>, descending: Option<bool>, start: Option<i32>, limit: Option<i32>) -> Result<models::NotificationRecipientResponseListResponse, Error<SearchRecipientsCountError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_app_key = app_key;
    let p_query_conduit = conduit;
    let p_query_keyword = keyword;
    let p_query_audience_id = audience_id;
    let p_query_audience_ids = audience_ids;
    let p_query_connection_group_ids = connection_group_ids;
    let p_query_sort_field = sort_field;
    let p_query_descending = descending;
    let p_query_start = start;
    let p_query_limit = limit;

    let uri_str = format!("{}/api/{version}/notification/recipient/search/count", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_key {
        req_builder = req_builder.query(&[("appKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_conduit {
        req_builder = req_builder.query(&[("conduit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_keyword {
        req_builder = req_builder.query(&[("keyword", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_audience_id {
        req_builder = req_builder.query(&[("audienceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_audience_ids {
        req_builder = req_builder.query(&[("audienceIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_connection_group_ids {
        req_builder = req_builder.query(&[("connectionGroupIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_field {
        req_builder = req_builder.query(&[("sortField", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_descending {
        req_builder = req_builder.query(&[("descending", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start {
        req_builder = req_builder.query(&[("start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::NotificationRecipientResponseListResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::NotificationRecipientResponseListResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchRecipientsCountError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Send notifications to all users of an application. Only someone with permissions to the application can do this.
pub async fn send_batch_notifications(configuration: &configuration::Configuration, version: f64, account_id: i64, app_key: &str, custom_message: &str, conduit: Option<&str>, content_id: Option<i64>, content_name: Option<&str>, content_type: Option<&str>, parent_id: Option<i64>, parent_type: Option<&str>) -> Result<models::SirqulResponse, Error<SendBatchNotificationsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_account_id = account_id;
    let p_query_app_key = app_key;
    let p_query_custom_message = custom_message;
    let p_query_conduit = conduit;
    let p_query_content_id = content_id;
    let p_query_content_name = content_name;
    let p_query_content_type = content_type;
    let p_query_parent_id = parent_id;
    let p_query_parent_type = parent_type;

    let uri_str = format!("{}/api/{version}/notification/batch", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("appKey", &p_query_app_key.to_string())]);
    if let Some(ref param_value) = p_query_conduit {
        req_builder = req_builder.query(&[("conduit", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("customMessage", &p_query_custom_message.to_string())]);
    if let Some(ref param_value) = p_query_content_id {
        req_builder = req_builder.query(&[("contentId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_content_name {
        req_builder = req_builder.query(&[("contentName", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_content_type {
        req_builder = req_builder.query(&[("contentType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_parent_id {
        req_builder = req_builder.query(&[("parentId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_parent_type {
        req_builder = req_builder.query(&[("parentType", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SirqulResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SirqulResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SendBatchNotificationsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Send your own custom notification to a user. NOTE: the EventType of these notifications will be CUSTOM. Notifications sent to yourself will currently be ignored.
pub async fn send_custom_notifications(configuration: &configuration::Configuration, version: f64, device_id: Option<&str>, account_id: Option<i64>, receiver_account_ids: Option<&str>, include_friend_group: Option<bool>, app_key: Option<&str>, game_type: Option<&str>, conduit: Option<&str>, content_id: Option<i64>, content_name: Option<&str>, content_type: Option<&str>, parent_id: Option<i64>, parent_type: Option<&str>, action_category: Option<&str>, subject: Option<&str>, custom_message: Option<&str>, friend_only_apns: Option<bool>, latitude: Option<f64>, longitude: Option<f64>) -> Result<models::SirqulResponse, Error<SendCustomNotificationsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_receiver_account_ids = receiver_account_ids;
    let p_query_include_friend_group = include_friend_group;
    let p_query_app_key = app_key;
    let p_query_game_type = game_type;
    let p_query_conduit = conduit;
    let p_query_content_id = content_id;
    let p_query_content_name = content_name;
    let p_query_content_type = content_type;
    let p_query_parent_id = parent_id;
    let p_query_parent_type = parent_type;
    let p_query_action_category = action_category;
    let p_query_subject = subject;
    let p_query_custom_message = custom_message;
    let p_query_friend_only_apns = friend_only_apns;
    let p_query_latitude = latitude;
    let p_query_longitude = longitude;

    let uri_str = format!("{}/api/{version}/notification/custom", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_receiver_account_ids {
        req_builder = req_builder.query(&[("receiverAccountIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_friend_group {
        req_builder = req_builder.query(&[("includeFriendGroup", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_key {
        req_builder = req_builder.query(&[("appKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_game_type {
        req_builder = req_builder.query(&[("gameType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_conduit {
        req_builder = req_builder.query(&[("conduit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_content_id {
        req_builder = req_builder.query(&[("contentId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_content_name {
        req_builder = req_builder.query(&[("contentName", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_content_type {
        req_builder = req_builder.query(&[("contentType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_parent_id {
        req_builder = req_builder.query(&[("parentId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_parent_type {
        req_builder = req_builder.query(&[("parentType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_action_category {
        req_builder = req_builder.query(&[("actionCategory", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_subject {
        req_builder = req_builder.query(&[("subject", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_custom_message {
        req_builder = req_builder.query(&[("customMessage", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_friend_only_apns {
        req_builder = req_builder.query(&[("friendOnlyAPNS", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_latitude {
        req_builder = req_builder.query(&[("latitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_longitude {
        req_builder = req_builder.query(&[("longitude", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SirqulResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SirqulResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SendCustomNotificationsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update a notification template. Developers will only be able to update notification templates for their own applications.
pub async fn update_notification_template(configuration: &configuration::Configuration, version: f64, account_id: i64, notification_template_id: i64, title: Option<&str>, body: Option<&str>, tags: Option<&str>) -> Result<models::NotificationTemplateResponse, Error<UpdateNotificationTemplateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_account_id = account_id;
    let p_query_notification_template_id = notification_template_id;
    let p_query_title = title;
    let p_query_body = body;
    let p_query_tags = tags;

    let uri_str = format!("{}/api/{version}/notification/template/update", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("notificationTemplateId", &p_query_notification_template_id.to_string())]);
    if let Some(ref param_value) = p_query_title {
        req_builder = req_builder.query(&[("title", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_body {
        req_builder = req_builder.query(&[("body", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_tags {
        req_builder = req_builder.query(&[("tags", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::NotificationTemplateResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::NotificationTemplateResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateNotificationTemplateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

