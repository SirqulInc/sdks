/*
 * Sirqul IoT Platform
 *
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`add_album_collection`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddAlbumCollectionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`add_album_users`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddAlbumUsersError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`approve_album`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApproveAlbumError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_album_collection`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAlbumCollectionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`leave_album`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LeaveAlbumError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`remove_album`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RemoveAlbumError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`remove_album_users`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RemoveAlbumUsersError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_albums`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchAlbumsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_album_collection`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateAlbumCollectionError {
    UnknownValue(serde_json::Value),
}


/// Create an Album.
pub async fn add_album_collection(configuration: &configuration::Configuration, version: f64, title: &str, cover_asset_nullable: bool, include_cover_in_asset_list: bool, public_read: bool, public_write: bool, public_delete: bool, public_add: bool, anonymous: bool, device_id: Option<&str>, account_id: Option<i64>, assets_to_add: Option<&str>, media: Option<std::path::PathBuf>, media_url: Option<&str>, asset_id: Option<i64>, attached_media: Option<std::path::PathBuf>, attached_media_url: Option<&str>, start_date: Option<i64>, end_date: Option<i64>, tags: Option<&str>, description: Option<&str>, album_type: Option<&str>, album_type_id: Option<i64>, sub_type: Option<&str>, latitude: Option<f64>, longitude: Option<f64>, location_description: Option<&str>, visibility: Option<&str>, game_type: Option<&str>, app_key: Option<&str>, cell_phone: Option<&str>, street_address: Option<&str>, street_address2: Option<&str>, city: Option<&str>, state: Option<&str>, postal_code: Option<&str>, full_address: Option<&str>, meta_data: Option<&str>, category_ids: Option<&str>, category_filter_ids: Option<&str>, audience_ids: Option<&str>, include_all_app_users_as_members: Option<bool>, include_audiences_as_members: Option<bool>, audience_operator: Option<&str>, approval_status: Option<&str>, linked_object_type: Option<&str>, linked_object_id: Option<i64>) -> Result<models::SearchResponse, Error<AddAlbumCollectionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_title = title;
    let p_query_cover_asset_nullable = cover_asset_nullable;
    let p_query_include_cover_in_asset_list = include_cover_in_asset_list;
    let p_query_public_read = public_read;
    let p_query_public_write = public_write;
    let p_query_public_delete = public_delete;
    let p_query_public_add = public_add;
    let p_query_anonymous = anonymous;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_assets_to_add = assets_to_add;
    let p_query_media = media;
    let p_query_media_url = media_url;
    let p_query_asset_id = asset_id;
    let p_query_attached_media = attached_media;
    let p_query_attached_media_url = attached_media_url;
    let p_query_start_date = start_date;
    let p_query_end_date = end_date;
    let p_query_tags = tags;
    let p_query_description = description;
    let p_query_album_type = album_type;
    let p_query_album_type_id = album_type_id;
    let p_query_sub_type = sub_type;
    let p_query_latitude = latitude;
    let p_query_longitude = longitude;
    let p_query_location_description = location_description;
    let p_query_visibility = visibility;
    let p_query_game_type = game_type;
    let p_query_app_key = app_key;
    let p_query_cell_phone = cell_phone;
    let p_query_street_address = street_address;
    let p_query_street_address2 = street_address2;
    let p_query_city = city;
    let p_query_state = state;
    let p_query_postal_code = postal_code;
    let p_query_full_address = full_address;
    let p_query_meta_data = meta_data;
    let p_query_category_ids = category_ids;
    let p_query_category_filter_ids = category_filter_ids;
    let p_query_audience_ids = audience_ids;
    let p_query_include_all_app_users_as_members = include_all_app_users_as_members;
    let p_query_include_audiences_as_members = include_audiences_as_members;
    let p_query_audience_operator = audience_operator;
    let p_query_approval_status = approval_status;
    let p_query_linked_object_type = linked_object_type;
    let p_query_linked_object_id = linked_object_id;

    let uri_str = format!("{}/api/{version}/album/create", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("title", &p_query_title.to_string())]);
    if let Some(ref param_value) = p_query_assets_to_add {
        req_builder = req_builder.query(&[("assetsToAdd", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_media {
        req_builder = req_builder.query(&[("media", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_media_url {
        req_builder = req_builder.query(&[("mediaURL", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_asset_id {
        req_builder = req_builder.query(&[("assetId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_attached_media {
        req_builder = req_builder.query(&[("attachedMedia", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_attached_media_url {
        req_builder = req_builder.query(&[("attachedMediaURL", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("coverAssetNullable", &p_query_cover_asset_nullable.to_string())]);
    req_builder = req_builder.query(&[("includeCoverInAssetList", &p_query_include_cover_in_asset_list.to_string())]);
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("startDate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("endDate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_tags {
        req_builder = req_builder.query(&[("tags", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_description {
        req_builder = req_builder.query(&[("description", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_album_type {
        req_builder = req_builder.query(&[("albumType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_album_type_id {
        req_builder = req_builder.query(&[("albumTypeId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sub_type {
        req_builder = req_builder.query(&[("subType", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("publicRead", &p_query_public_read.to_string())]);
    req_builder = req_builder.query(&[("publicWrite", &p_query_public_write.to_string())]);
    req_builder = req_builder.query(&[("publicDelete", &p_query_public_delete.to_string())]);
    req_builder = req_builder.query(&[("publicAdd", &p_query_public_add.to_string())]);
    if let Some(ref param_value) = p_query_latitude {
        req_builder = req_builder.query(&[("latitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_longitude {
        req_builder = req_builder.query(&[("longitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_location_description {
        req_builder = req_builder.query(&[("locationDescription", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_visibility {
        req_builder = req_builder.query(&[("visibility", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_game_type {
        req_builder = req_builder.query(&[("gameType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_key {
        req_builder = req_builder.query(&[("appKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cell_phone {
        req_builder = req_builder.query(&[("cellPhone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_street_address {
        req_builder = req_builder.query(&[("streetAddress", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_street_address2 {
        req_builder = req_builder.query(&[("streetAddress2", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_city {
        req_builder = req_builder.query(&[("city", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_state {
        req_builder = req_builder.query(&[("state", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_postal_code {
        req_builder = req_builder.query(&[("postalCode", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_full_address {
        req_builder = req_builder.query(&[("fullAddress", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("anonymous", &p_query_anonymous.to_string())]);
    if let Some(ref param_value) = p_query_meta_data {
        req_builder = req_builder.query(&[("metaData", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_category_ids {
        req_builder = req_builder.query(&[("categoryIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_category_filter_ids {
        req_builder = req_builder.query(&[("categoryFilterIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_audience_ids {
        req_builder = req_builder.query(&[("audienceIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_all_app_users_as_members {
        req_builder = req_builder.query(&[("includeAllAppUsersAsMembers", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_audiences_as_members {
        req_builder = req_builder.query(&[("includeAudiencesAsMembers", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_audience_operator {
        req_builder = req_builder.query(&[("audienceOperator", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_approval_status {
        req_builder = req_builder.query(&[("approvalStatus", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_linked_object_type {
        req_builder = req_builder.query(&[("linkedObjectType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_linked_object_id {
        req_builder = req_builder.query(&[("linkedObjectId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SearchResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SearchResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AddAlbumCollectionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Add users to an album as participants.
pub async fn add_album_users(configuration: &configuration::Configuration, version: f64, album_id: i64, include_friend_group: bool, device_id: Option<&str>, account_id: Option<i64>, read: Option<bool>, write: Option<bool>, delete: Option<bool>, add: Option<bool>, connections: Option<&str>, connection_groups: Option<&str>) -> Result<models::SirqulResponse, Error<AddAlbumUsersError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_album_id = album_id;
    let p_query_include_friend_group = include_friend_group;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_read = read;
    let p_query_write = write;
    let p_query_delete = delete;
    let p_query_add = add;
    let p_query_connections = connections;
    let p_query_connection_groups = connection_groups;

    let uri_str = format!("{}/api/{version}/album/user/add", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("albumId", &p_query_album_id.to_string())]);
    if let Some(ref param_value) = p_query_read {
        req_builder = req_builder.query(&[("read", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_write {
        req_builder = req_builder.query(&[("write", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_delete {
        req_builder = req_builder.query(&[("delete", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_add {
        req_builder = req_builder.query(&[("add", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_connections {
        req_builder = req_builder.query(&[("connections", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_connection_groups {
        req_builder = req_builder.query(&[("connectionGroups", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("includeFriendGroup", &p_query_include_friend_group.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SirqulResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SirqulResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AddAlbumUsersError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Sets the approval status of an Album.
pub async fn approve_album(configuration: &configuration::Configuration, version: f64, album_id: i64, device_id: Option<&str>, account_id: Option<i64>, approval_status: Option<&str>, verified: Option<bool>) -> Result<models::SirqulResponse, Error<ApproveAlbumError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_album_id = album_id;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_approval_status = approval_status;
    let p_query_verified = verified;

    let uri_str = format!("{}/api/{version}/album/approve", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("albumId", &p_query_album_id.to_string())]);
    if let Some(ref param_value) = p_query_approval_status {
        req_builder = req_builder.query(&[("approvalStatus", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_verified {
        req_builder = req_builder.query(&[("verified", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SirqulResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SirqulResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApproveAlbumError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get an Album.
pub async fn get_album_collection(configuration: &configuration::Configuration, version: f64, return_nulls: bool, album_id: i64, device_id: Option<&str>, account_id: Option<i64>, like_preview_size: Option<i32>, asset_preview_size: Option<i32>, note_preview_size: Option<i32>, connection_preview_size: Option<i32>, audience_preview_size: Option<i32>) -> Result<models::AlbumFullResponse, Error<GetAlbumCollectionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_return_nulls = return_nulls;
    let p_query_album_id = album_id;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_like_preview_size = like_preview_size;
    let p_query_asset_preview_size = asset_preview_size;
    let p_query_note_preview_size = note_preview_size;
    let p_query_connection_preview_size = connection_preview_size;
    let p_query_audience_preview_size = audience_preview_size;

    let uri_str = format!("{}/api/{version}/album/get", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("returnNulls", &p_query_return_nulls.to_string())]);
    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("albumId", &p_query_album_id.to_string())]);
    if let Some(ref param_value) = p_query_like_preview_size {
        req_builder = req_builder.query(&[("likePreviewSize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_asset_preview_size {
        req_builder = req_builder.query(&[("assetPreviewSize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_note_preview_size {
        req_builder = req_builder.query(&[("notePreviewSize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_connection_preview_size {
        req_builder = req_builder.query(&[("connectionPreviewSize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_audience_preview_size {
        req_builder = req_builder.query(&[("audiencePreviewSize", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AlbumFullResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AlbumFullResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAlbumCollectionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

///  Allows a user to leave an album (they are no longer considered a participant). The album creator cannot leave their own albums.
pub async fn leave_album(configuration: &configuration::Configuration, version: f64, album_id: i64, device_id: Option<&str>, account_id: Option<i64>) -> Result<models::SirqulResponse, Error<LeaveAlbumError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_album_id = album_id;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;

    let uri_str = format!("{}/api/{version}/album/user/leave", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("albumId", &p_query_album_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SirqulResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SirqulResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<LeaveAlbumError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deletes an Album
pub async fn remove_album(configuration: &configuration::Configuration, version: f64, album_id: i64, device_id: Option<&str>, account_id: Option<i64>) -> Result<models::SirqulResponse, Error<RemoveAlbumError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_album_id = album_id;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;

    let uri_str = format!("{}/api/{version}/album/delete", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("albumId", &p_query_album_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SirqulResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SirqulResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RemoveAlbumError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Remove participants of an album.
pub async fn remove_album_users(configuration: &configuration::Configuration, version: f64, album_id: i64, remove_friend_group: bool, device_id: Option<&str>, account_id: Option<i64>, connections: Option<&str>, connection_groups: Option<&str>) -> Result<models::SirqulResponse, Error<RemoveAlbumUsersError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_album_id = album_id;
    let p_query_remove_friend_group = remove_friend_group;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_connections = connections;
    let p_query_connection_groups = connection_groups;

    let uri_str = format!("{}/api/{version}/album/user/delete", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("albumId", &p_query_album_id.to_string())]);
    if let Some(ref param_value) = p_query_connections {
        req_builder = req_builder.query(&[("connections", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_connection_groups {
        req_builder = req_builder.query(&[("connectionGroups", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("removeFriendGroup", &p_query_remove_friend_group.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SirqulResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SirqulResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RemoveAlbumUsersError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Searches on Albums.
pub async fn search_albums(configuration: &configuration::Configuration, version: f64, filter: &str, album_type_id: i64, sub_type: &str, include_inactive: bool, sort_field: &str, descending: bool, start: i32, limit: i32, range: f64, include_liked: bool, include_favorited: bool, include_permissions: bool, like_preview_size: i32, asset_preview_size: i32, note_preview_size: i32, connection_preview_size: i32, audience_preview_size: i32, device_id: Option<&str>, account_id: Option<i64>, connection_account_id: Option<i64>, owner_id: Option<i64>, album_ids: Option<&str>, exclude_album_ids: Option<&str>, media_id: Option<i64>, keyword: Option<&str>, album_type: Option<&str>, limit_per_album_type: Option<i32>, date_created: Option<i64>, updated_since: Option<i64>, updated_before: Option<i64>, created_since: Option<i64>, created_before: Option<i64>, started_since: Option<i64>, started_before: Option<i64>, ended_since: Option<i64>, ended_before: Option<i64>, latitude: Option<f64>, longitude: Option<f64>, app_key: Option<&str>, category_ids: Option<&str>, category_filter_ids: Option<&str>, audience_ids: Option<&str>, exclude_audience_ids: Option<&str>, include_completable: Option<bool>, include_rating: Option<bool>, search_mode: Option<&str>, stack_search: Option<bool>, stack_window_size: Option<i32>, min_stack_per_page: Option<i32>, stack_pagination_identifier: Option<&str>, stack_details: Option<bool>, flag_count_minimum: Option<i64>, remove_flagged_content: Option<bool>, verified_filter: Option<bool>, linked_object_type: Option<&str>, linked_object_id: Option<i64>, order_audience_id: Option<i64>, ignore_default_app_filter: Option<bool>, search_expression: Option<&str>, generate_albums: Option<bool>) -> Result<Vec<models::AlbumFullResponse>, Error<SearchAlbumsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_filter = filter;
    let p_query_album_type_id = album_type_id;
    let p_query_sub_type = sub_type;
    let p_query_include_inactive = include_inactive;
    let p_query_sort_field = sort_field;
    let p_query_descending = descending;
    let p_query_start = start;
    let p_query_limit = limit;
    let p_query_range = range;
    let p_query_include_liked = include_liked;
    let p_query_include_favorited = include_favorited;
    let p_query_include_permissions = include_permissions;
    let p_query_like_preview_size = like_preview_size;
    let p_query_asset_preview_size = asset_preview_size;
    let p_query_note_preview_size = note_preview_size;
    let p_query_connection_preview_size = connection_preview_size;
    let p_query_audience_preview_size = audience_preview_size;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_connection_account_id = connection_account_id;
    let p_query_owner_id = owner_id;
    let p_query_album_ids = album_ids;
    let p_query_exclude_album_ids = exclude_album_ids;
    let p_query_media_id = media_id;
    let p_query_keyword = keyword;
    let p_query_album_type = album_type;
    let p_query_limit_per_album_type = limit_per_album_type;
    let p_query_date_created = date_created;
    let p_query_updated_since = updated_since;
    let p_query_updated_before = updated_before;
    let p_query_created_since = created_since;
    let p_query_created_before = created_before;
    let p_query_started_since = started_since;
    let p_query_started_before = started_before;
    let p_query_ended_since = ended_since;
    let p_query_ended_before = ended_before;
    let p_query_latitude = latitude;
    let p_query_longitude = longitude;
    let p_query_app_key = app_key;
    let p_query_category_ids = category_ids;
    let p_query_category_filter_ids = category_filter_ids;
    let p_query_audience_ids = audience_ids;
    let p_query_exclude_audience_ids = exclude_audience_ids;
    let p_query_include_completable = include_completable;
    let p_query_include_rating = include_rating;
    let p_query_search_mode = search_mode;
    let p_query_stack_search = stack_search;
    let p_query_stack_window_size = stack_window_size;
    let p_query_min_stack_per_page = min_stack_per_page;
    let p_query_stack_pagination_identifier = stack_pagination_identifier;
    let p_query_stack_details = stack_details;
    let p_query_flag_count_minimum = flag_count_minimum;
    let p_query_remove_flagged_content = remove_flagged_content;
    let p_query_verified_filter = verified_filter;
    let p_query_linked_object_type = linked_object_type;
    let p_query_linked_object_id = linked_object_id;
    let p_query_order_audience_id = order_audience_id;
    let p_query_ignore_default_app_filter = ignore_default_app_filter;
    let p_query_search_expression = search_expression;
    let p_query_generate_albums = generate_albums;

    let uri_str = format!("{}/api/{version}/album/search", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_connection_account_id {
        req_builder = req_builder.query(&[("connectionAccountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_owner_id {
        req_builder = req_builder.query(&[("ownerId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_album_ids {
        req_builder = req_builder.query(&[("albumIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exclude_album_ids {
        req_builder = req_builder.query(&[("excludeAlbumIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_media_id {
        req_builder = req_builder.query(&[("mediaId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_keyword {
        req_builder = req_builder.query(&[("keyword", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("filter", &p_query_filter.to_string())]);
    if let Some(ref param_value) = p_query_album_type {
        req_builder = req_builder.query(&[("albumType", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("albumTypeId", &p_query_album_type_id.to_string())]);
    req_builder = req_builder.query(&[("subType", &p_query_sub_type.to_string())]);
    req_builder = req_builder.query(&[("includeInactive", &p_query_include_inactive.to_string())]);
    req_builder = req_builder.query(&[("sortField", &p_query_sort_field.to_string())]);
    req_builder = req_builder.query(&[("descending", &p_query_descending.to_string())]);
    req_builder = req_builder.query(&[("start", &p_query_start.to_string())]);
    req_builder = req_builder.query(&[("limit", &p_query_limit.to_string())]);
    if let Some(ref param_value) = p_query_limit_per_album_type {
        req_builder = req_builder.query(&[("limitPerAlbumType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date_created {
        req_builder = req_builder.query(&[("dateCreated", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_updated_since {
        req_builder = req_builder.query(&[("updatedSince", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_updated_before {
        req_builder = req_builder.query(&[("updatedBefore", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_created_since {
        req_builder = req_builder.query(&[("createdSince", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_created_before {
        req_builder = req_builder.query(&[("createdBefore", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_started_since {
        req_builder = req_builder.query(&[("startedSince", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_started_before {
        req_builder = req_builder.query(&[("startedBefore", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ended_since {
        req_builder = req_builder.query(&[("endedSince", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ended_before {
        req_builder = req_builder.query(&[("endedBefore", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_latitude {
        req_builder = req_builder.query(&[("latitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_longitude {
        req_builder = req_builder.query(&[("longitude", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("range", &p_query_range.to_string())]);
    if let Some(ref param_value) = p_query_app_key {
        req_builder = req_builder.query(&[("appKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_category_ids {
        req_builder = req_builder.query(&[("categoryIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_category_filter_ids {
        req_builder = req_builder.query(&[("categoryFilterIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_audience_ids {
        req_builder = req_builder.query(&[("audienceIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exclude_audience_ids {
        req_builder = req_builder.query(&[("excludeAudienceIds", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("includeLiked", &p_query_include_liked.to_string())]);
    req_builder = req_builder.query(&[("includeFavorited", &p_query_include_favorited.to_string())]);
    req_builder = req_builder.query(&[("includePermissions", &p_query_include_permissions.to_string())]);
    if let Some(ref param_value) = p_query_include_completable {
        req_builder = req_builder.query(&[("includeCompletable", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_rating {
        req_builder = req_builder.query(&[("includeRating", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("likePreviewSize", &p_query_like_preview_size.to_string())]);
    req_builder = req_builder.query(&[("assetPreviewSize", &p_query_asset_preview_size.to_string())]);
    req_builder = req_builder.query(&[("notePreviewSize", &p_query_note_preview_size.to_string())]);
    req_builder = req_builder.query(&[("connectionPreviewSize", &p_query_connection_preview_size.to_string())]);
    req_builder = req_builder.query(&[("audiencePreviewSize", &p_query_audience_preview_size.to_string())]);
    if let Some(ref param_value) = p_query_search_mode {
        req_builder = req_builder.query(&[("searchMode", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_stack_search {
        req_builder = req_builder.query(&[("stackSearch", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_stack_window_size {
        req_builder = req_builder.query(&[("stackWindowSize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_min_stack_per_page {
        req_builder = req_builder.query(&[("minStackPerPage", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_stack_pagination_identifier {
        req_builder = req_builder.query(&[("stackPaginationIdentifier", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_stack_details {
        req_builder = req_builder.query(&[("stackDetails", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_flag_count_minimum {
        req_builder = req_builder.query(&[("flagCountMinimum", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_remove_flagged_content {
        req_builder = req_builder.query(&[("removeFlaggedContent", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_verified_filter {
        req_builder = req_builder.query(&[("verifiedFilter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_linked_object_type {
        req_builder = req_builder.query(&[("linkedObjectType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_linked_object_id {
        req_builder = req_builder.query(&[("linkedObjectId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order_audience_id {
        req_builder = req_builder.query(&[("orderAudienceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ignore_default_app_filter {
        req_builder = req_builder.query(&[("ignoreDefaultAppFilter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search_expression {
        req_builder = req_builder.query(&[("searchExpression", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_generate_albums {
        req_builder = req_builder.query(&[("generateAlbums", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::AlbumFullResponse&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::AlbumFullResponse&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchAlbumsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update an Album.
pub async fn update_album_collection(configuration: &configuration::Configuration, version: f64, album_id: i64, device_id: Option<&str>, account_id: Option<i64>, assets_to_add: Option<&str>, assets_to_remove: Option<&str>, asset_id: Option<i64>, media: Option<std::path::PathBuf>, media_url: Option<&str>, active: Option<bool>, title: Option<&str>, start_date: Option<i64>, end_date: Option<i64>, tags: Option<&str>, description: Option<&str>, album_type: Option<&str>, album_type_id: Option<i64>, sub_type: Option<&str>, public_read: Option<bool>, public_write: Option<bool>, public_delete: Option<bool>, public_add: Option<bool>, latitude: Option<f64>, longitude: Option<f64>, location_description: Option<&str>, visibility: Option<&str>, cell_phone: Option<&str>, street_address: Option<&str>, street_address2: Option<&str>, city: Option<&str>, state: Option<&str>, postal_code: Option<&str>, full_address: Option<&str>, anonymous: Option<bool>, meta_data: Option<&str>, category_ids: Option<&str>, category_filter_ids: Option<&str>, audience_ids: Option<&str>, audience_ids_to_add: Option<&str>, audience_ids_to_remove: Option<&str>, include_all_app_users_as_members: Option<bool>, include_audiences_as_members: Option<bool>, audience_operator: Option<&str>, linked_object_type: Option<&str>, linked_object_id: Option<i64>, index_now: Option<bool>) -> Result<models::AlbumResponse, Error<UpdateAlbumCollectionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_album_id = album_id;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_assets_to_add = assets_to_add;
    let p_query_assets_to_remove = assets_to_remove;
    let p_query_asset_id = asset_id;
    let p_query_media = media;
    let p_query_media_url = media_url;
    let p_query_active = active;
    let p_query_title = title;
    let p_query_start_date = start_date;
    let p_query_end_date = end_date;
    let p_query_tags = tags;
    let p_query_description = description;
    let p_query_album_type = album_type;
    let p_query_album_type_id = album_type_id;
    let p_query_sub_type = sub_type;
    let p_query_public_read = public_read;
    let p_query_public_write = public_write;
    let p_query_public_delete = public_delete;
    let p_query_public_add = public_add;
    let p_query_latitude = latitude;
    let p_query_longitude = longitude;
    let p_query_location_description = location_description;
    let p_query_visibility = visibility;
    let p_query_cell_phone = cell_phone;
    let p_query_street_address = street_address;
    let p_query_street_address2 = street_address2;
    let p_query_city = city;
    let p_query_state = state;
    let p_query_postal_code = postal_code;
    let p_query_full_address = full_address;
    let p_query_anonymous = anonymous;
    let p_query_meta_data = meta_data;
    let p_query_category_ids = category_ids;
    let p_query_category_filter_ids = category_filter_ids;
    let p_query_audience_ids = audience_ids;
    let p_query_audience_ids_to_add = audience_ids_to_add;
    let p_query_audience_ids_to_remove = audience_ids_to_remove;
    let p_query_include_all_app_users_as_members = include_all_app_users_as_members;
    let p_query_include_audiences_as_members = include_audiences_as_members;
    let p_query_audience_operator = audience_operator;
    let p_query_linked_object_type = linked_object_type;
    let p_query_linked_object_id = linked_object_id;
    let p_query_index_now = index_now;

    let uri_str = format!("{}/api/{version}/album/update", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("albumId", &p_query_album_id.to_string())]);
    if let Some(ref param_value) = p_query_assets_to_add {
        req_builder = req_builder.query(&[("assetsToAdd", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_assets_to_remove {
        req_builder = req_builder.query(&[("assetsToRemove", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_asset_id {
        req_builder = req_builder.query(&[("assetId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_media {
        req_builder = req_builder.query(&[("media", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_media_url {
        req_builder = req_builder.query(&[("mediaURL", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_active {
        req_builder = req_builder.query(&[("active", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_title {
        req_builder = req_builder.query(&[("title", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("startDate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("endDate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_tags {
        req_builder = req_builder.query(&[("tags", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_description {
        req_builder = req_builder.query(&[("description", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_album_type {
        req_builder = req_builder.query(&[("albumType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_album_type_id {
        req_builder = req_builder.query(&[("albumTypeId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sub_type {
        req_builder = req_builder.query(&[("subType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_public_read {
        req_builder = req_builder.query(&[("publicRead", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_public_write {
        req_builder = req_builder.query(&[("publicWrite", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_public_delete {
        req_builder = req_builder.query(&[("publicDelete", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_public_add {
        req_builder = req_builder.query(&[("publicAdd", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_latitude {
        req_builder = req_builder.query(&[("latitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_longitude {
        req_builder = req_builder.query(&[("longitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_location_description {
        req_builder = req_builder.query(&[("locationDescription", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_visibility {
        req_builder = req_builder.query(&[("visibility", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cell_phone {
        req_builder = req_builder.query(&[("cellPhone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_street_address {
        req_builder = req_builder.query(&[("streetAddress", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_street_address2 {
        req_builder = req_builder.query(&[("streetAddress2", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_city {
        req_builder = req_builder.query(&[("city", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_state {
        req_builder = req_builder.query(&[("state", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_postal_code {
        req_builder = req_builder.query(&[("postalCode", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_full_address {
        req_builder = req_builder.query(&[("fullAddress", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_anonymous {
        req_builder = req_builder.query(&[("anonymous", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_meta_data {
        req_builder = req_builder.query(&[("metaData", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_category_ids {
        req_builder = req_builder.query(&[("categoryIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_category_filter_ids {
        req_builder = req_builder.query(&[("categoryFilterIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_audience_ids {
        req_builder = req_builder.query(&[("audienceIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_audience_ids_to_add {
        req_builder = req_builder.query(&[("audienceIdsToAdd", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_audience_ids_to_remove {
        req_builder = req_builder.query(&[("audienceIdsToRemove", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_all_app_users_as_members {
        req_builder = req_builder.query(&[("includeAllAppUsersAsMembers", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_audiences_as_members {
        req_builder = req_builder.query(&[("includeAudiencesAsMembers", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_audience_operator {
        req_builder = req_builder.query(&[("audienceOperator", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_linked_object_type {
        req_builder = req_builder.query(&[("linkedObjectType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_linked_object_id {
        req_builder = req_builder.query(&[("linkedObjectId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_index_now {
        req_builder = req_builder.query(&[("indexNow", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AlbumResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AlbumResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateAlbumCollectionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

