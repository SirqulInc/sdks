/*
 * Sirqul IoT Platform
 *
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`create_application`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateApplicationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_application_placement`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateApplicationPlacementError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_application`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteApplicationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_application_placement`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteApplicationPlacementError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_application`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetApplicationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_application_placement`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetApplicationPlacementError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_application_versions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetApplicationVersionsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_unique_users_by_app`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUniqueUsersByAppError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_applications`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListApplicationsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_application_placement`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchApplicationPlacementError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_application_settings`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchApplicationSettingsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_applications`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchApplicationsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_application`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateApplicationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_application_active`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateApplicationActiveError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_application_placement`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateApplicationPlacementError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`upload_application_certificate`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UploadApplicationCertificateError {
    UnknownValue(serde_json::Value),
}


/// Create an application record and one placement record for that application. You can create more placements for this application by using {@link createApplicationPlacement}.
pub async fn create_application(configuration: &configuration::Configuration, version: f64, app_name: &str, device_id: Option<&str>, account_id: Option<i64>, about: Option<&str>, bundle_id: Option<&str>, app_icon_asset_id: Option<i64>, app_logo_asset_id: Option<i64>, facebook_app_id: Option<&str>, facebook_app_secret: Option<&str>, google_api_key: Option<&str>, update_eula_date: Option<bool>, eula_version: Option<&str>, landing_page_url: Option<&str>, show_in_activities: Option<bool>, activity_description: Option<&str>, invite_welcome_text: Option<&str>, invite_page_url: Option<&str>, url_scheme: Option<&str>, platforms: Option<&str>, download_urls: Option<&str>, category_ids: Option<&str>, scoring_type: Option<&str>, hint_cost: Option<i32>, max_score: Option<i32>, tickets_per_point: Option<f32>, has_game_data: Option<bool>, public_notifications: Option<bool>, use_matching_algorithm: Option<bool>, global_tickets: Option<bool>, build_version: Option<f32>, api_version: Option<f32>, placement_name: Option<&str>, placement_description: Option<&str>, placement_size: Option<&str>, placement_height: Option<i32>, placement_width: Option<i32>, placement_refresh_interval: Option<i32>, create_object_store: Option<bool>, public_content_approval: Option<bool>, production_mode: Option<bool>, minimum_session_length: Option<i32>, session_gap_length: Option<i32>, local_ads_enabled: Option<bool>, sqoot_api_key: Option<&str>, trilat_processing_type: Option<&str>, max_sample_size: Option<i32>, min_rssi: Option<f64>, modules: Option<&str>, authorized_count: Option<i32>, authorized_servers: Option<&str>, default_timezone: Option<&str>, smtp_pass: Option<&str>, meta_data: Option<&str>, placement_meta_data: Option<&str>, ips_floor: Option<bool>, enable_apns_badge: Option<bool>, include_in_report: Option<bool>, default_app_filter_id: Option<i64>, enable_welcome_email: Option<bool>, apple_app_id: Option<&str>, apple_team_id: Option<&str>, apple_auth_key_id: Option<&str>, apple_auth_key: Option<std::path::PathBuf>, apple_issuer_id: Option<&str>, app_store_key_id: Option<&str>, app_store_key: Option<std::path::PathBuf>, google_private_key_file: Option<std::path::PathBuf>, authorize_net_api_key: Option<&str>, authorize_net_transaction_key: Option<&str>, email_sender: Option<&str>, smtp_user: Option<&str>, smtp_host: Option<&str>, vatom_business_id: Option<&str>, vatom_rest_client_id: Option<&str>, vatom_rest_secret_key: Option<&str>, twilio_account_sid: Option<&str>, twilio_auth_token: Option<&str>, twilio_sender_phone_number: Option<&str>, open_ai_secret_key: Option<&str>) -> Result<models::ApplicationResponse, Error<CreateApplicationError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_app_name = app_name;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_about = about;
    let p_query_bundle_id = bundle_id;
    let p_query_app_icon_asset_id = app_icon_asset_id;
    let p_query_app_logo_asset_id = app_logo_asset_id;
    let p_query_facebook_app_id = facebook_app_id;
    let p_query_facebook_app_secret = facebook_app_secret;
    let p_query_google_api_key = google_api_key;
    let p_query_update_eula_date = update_eula_date;
    let p_query_eula_version = eula_version;
    let p_query_landing_page_url = landing_page_url;
    let p_query_show_in_activities = show_in_activities;
    let p_query_activity_description = activity_description;
    let p_query_invite_welcome_text = invite_welcome_text;
    let p_query_invite_page_url = invite_page_url;
    let p_query_url_scheme = url_scheme;
    let p_query_platforms = platforms;
    let p_query_download_urls = download_urls;
    let p_query_category_ids = category_ids;
    let p_query_scoring_type = scoring_type;
    let p_query_hint_cost = hint_cost;
    let p_query_max_score = max_score;
    let p_query_tickets_per_point = tickets_per_point;
    let p_query_has_game_data = has_game_data;
    let p_query_public_notifications = public_notifications;
    let p_query_use_matching_algorithm = use_matching_algorithm;
    let p_query_global_tickets = global_tickets;
    let p_query_build_version = build_version;
    let p_query_api_version = api_version;
    let p_query_placement_name = placement_name;
    let p_query_placement_description = placement_description;
    let p_query_placement_size = placement_size;
    let p_query_placement_height = placement_height;
    let p_query_placement_width = placement_width;
    let p_query_placement_refresh_interval = placement_refresh_interval;
    let p_query_create_object_store = create_object_store;
    let p_query_public_content_approval = public_content_approval;
    let p_query_production_mode = production_mode;
    let p_query_minimum_session_length = minimum_session_length;
    let p_query_session_gap_length = session_gap_length;
    let p_query_local_ads_enabled = local_ads_enabled;
    let p_query_sqoot_api_key = sqoot_api_key;
    let p_query_trilat_processing_type = trilat_processing_type;
    let p_query_max_sample_size = max_sample_size;
    let p_query_min_rssi = min_rssi;
    let p_query_modules = modules;
    let p_query_authorized_count = authorized_count;
    let p_query_authorized_servers = authorized_servers;
    let p_query_default_timezone = default_timezone;
    let p_query_smtp_pass = smtp_pass;
    let p_query_meta_data = meta_data;
    let p_query_placement_meta_data = placement_meta_data;
    let p_query_ips_floor = ips_floor;
    let p_query_enable_apns_badge = enable_apns_badge;
    let p_query_include_in_report = include_in_report;
    let p_query_default_app_filter_id = default_app_filter_id;
    let p_query_enable_welcome_email = enable_welcome_email;
    let p_query_apple_app_id = apple_app_id;
    let p_query_apple_team_id = apple_team_id;
    let p_query_apple_auth_key_id = apple_auth_key_id;
    let p_query_apple_auth_key = apple_auth_key;
    let p_query_apple_issuer_id = apple_issuer_id;
    let p_query_app_store_key_id = app_store_key_id;
    let p_query_app_store_key = app_store_key;
    let p_query_google_private_key_file = google_private_key_file;
    let p_query_authorize_net_api_key = authorize_net_api_key;
    let p_query_authorize_net_transaction_key = authorize_net_transaction_key;
    let p_query_email_sender = email_sender;
    let p_query_smtp_user = smtp_user;
    let p_query_smtp_host = smtp_host;
    let p_query_vatom_business_id = vatom_business_id;
    let p_query_vatom_rest_client_id = vatom_rest_client_id;
    let p_query_vatom_rest_secret_key = vatom_rest_secret_key;
    let p_query_twilio_account_sid = twilio_account_sid;
    let p_query_twilio_auth_token = twilio_auth_token;
    let p_query_twilio_sender_phone_number = twilio_sender_phone_number;
    let p_query_open_ai_secret_key = open_ai_secret_key;

    let uri_str = format!("{}/api/{version}/application/create", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("appName", &p_query_app_name.to_string())]);
    if let Some(ref param_value) = p_query_about {
        req_builder = req_builder.query(&[("about", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_bundle_id {
        req_builder = req_builder.query(&[("bundleId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_icon_asset_id {
        req_builder = req_builder.query(&[("appIconAssetId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_logo_asset_id {
        req_builder = req_builder.query(&[("appLogoAssetId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_facebook_app_id {
        req_builder = req_builder.query(&[("facebookAppId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_facebook_app_secret {
        req_builder = req_builder.query(&[("facebookAppSecret", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_google_api_key {
        req_builder = req_builder.query(&[("googleApiKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_update_eula_date {
        req_builder = req_builder.query(&[("updateEULADate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_eula_version {
        req_builder = req_builder.query(&[("eulaVersion", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_landing_page_url {
        req_builder = req_builder.query(&[("landingPageUrl", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_show_in_activities {
        req_builder = req_builder.query(&[("showInActivities", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_activity_description {
        req_builder = req_builder.query(&[("activityDescription", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_invite_welcome_text {
        req_builder = req_builder.query(&[("inviteWelcomeText", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_invite_page_url {
        req_builder = req_builder.query(&[("invitePageUrl", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_url_scheme {
        req_builder = req_builder.query(&[("urlScheme", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_platforms {
        req_builder = req_builder.query(&[("platforms", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_download_urls {
        req_builder = req_builder.query(&[("downloadUrls", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_category_ids {
        req_builder = req_builder.query(&[("categoryIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_scoring_type {
        req_builder = req_builder.query(&[("scoringType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_hint_cost {
        req_builder = req_builder.query(&[("hintCost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_max_score {
        req_builder = req_builder.query(&[("maxScore", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_tickets_per_point {
        req_builder = req_builder.query(&[("ticketsPerPoint", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_has_game_data {
        req_builder = req_builder.query(&[("hasGameData", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_public_notifications {
        req_builder = req_builder.query(&[("publicNotifications", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_use_matching_algorithm {
        req_builder = req_builder.query(&[("useMatchingAlgorithm", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_global_tickets {
        req_builder = req_builder.query(&[("globalTickets", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_build_version {
        req_builder = req_builder.query(&[("buildVersion", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_api_version {
        req_builder = req_builder.query(&[("apiVersion", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_placement_name {
        req_builder = req_builder.query(&[("placementName", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_placement_description {
        req_builder = req_builder.query(&[("placementDescription", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_placement_size {
        req_builder = req_builder.query(&[("placementSize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_placement_height {
        req_builder = req_builder.query(&[("placementHeight", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_placement_width {
        req_builder = req_builder.query(&[("placementWidth", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_placement_refresh_interval {
        req_builder = req_builder.query(&[("placementRefreshInterval", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_create_object_store {
        req_builder = req_builder.query(&[("createObjectStore", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_public_content_approval {
        req_builder = req_builder.query(&[("publicContentApproval", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_production_mode {
        req_builder = req_builder.query(&[("productionMode", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_minimum_session_length {
        req_builder = req_builder.query(&[("minimumSessionLength", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_session_gap_length {
        req_builder = req_builder.query(&[("sessionGapLength", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_local_ads_enabled {
        req_builder = req_builder.query(&[("localAdsEnabled", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sqoot_api_key {
        req_builder = req_builder.query(&[("sqootApiKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_trilat_processing_type {
        req_builder = req_builder.query(&[("trilatProcessingType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_max_sample_size {
        req_builder = req_builder.query(&[("maxSampleSize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_min_rssi {
        req_builder = req_builder.query(&[("minRSSI", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_modules {
        req_builder = req_builder.query(&[("modules", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_authorized_count {
        req_builder = req_builder.query(&[("authorizedCount", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_authorized_servers {
        req_builder = req_builder.query(&[("authorizedServers", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_default_timezone {
        req_builder = req_builder.query(&[("defaultTimezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_smtp_pass {
        req_builder = req_builder.query(&[("smtpPass", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_meta_data {
        req_builder = req_builder.query(&[("metaData", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_placement_meta_data {
        req_builder = req_builder.query(&[("placementMetaData", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ips_floor {
        req_builder = req_builder.query(&[("ipsFloor", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_enable_apns_badge {
        req_builder = req_builder.query(&[("enableAPNSBadge", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_in_report {
        req_builder = req_builder.query(&[("includeInReport", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_default_app_filter_id {
        req_builder = req_builder.query(&[("defaultAppFilterId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_enable_welcome_email {
        req_builder = req_builder.query(&[("enableWelcomeEmail", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_apple_app_id {
        req_builder = req_builder.query(&[("appleAppId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_apple_team_id {
        req_builder = req_builder.query(&[("appleTeamId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_apple_auth_key_id {
        req_builder = req_builder.query(&[("appleAuthKeyId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_apple_auth_key {
        req_builder = req_builder.query(&[("appleAuthKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_apple_issuer_id {
        req_builder = req_builder.query(&[("appleIssuerId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_store_key_id {
        req_builder = req_builder.query(&[("appStoreKeyId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_store_key {
        req_builder = req_builder.query(&[("appStoreKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_google_private_key_file {
        req_builder = req_builder.query(&[("googlePrivateKeyFile", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_authorize_net_api_key {
        req_builder = req_builder.query(&[("authorizeNetApiKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_authorize_net_transaction_key {
        req_builder = req_builder.query(&[("authorizeNetTransactionKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_email_sender {
        req_builder = req_builder.query(&[("emailSender", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_smtp_user {
        req_builder = req_builder.query(&[("smtpUser", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_smtp_host {
        req_builder = req_builder.query(&[("smtpHost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_vatom_business_id {
        req_builder = req_builder.query(&[("vatomBusinessId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_vatom_rest_client_id {
        req_builder = req_builder.query(&[("vatomRestClientId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_vatom_rest_secret_key {
        req_builder = req_builder.query(&[("vatomRestSecretKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_twilio_account_sid {
        req_builder = req_builder.query(&[("twilioAccountSID", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_twilio_auth_token {
        req_builder = req_builder.query(&[("twilioAuthToken", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_twilio_sender_phone_number {
        req_builder = req_builder.query(&[("twilioSenderPhoneNumber", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_open_ai_secret_key {
        req_builder = req_builder.query(&[("openAISecretKey", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApplicationResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApplicationResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateApplicationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a new ad placement for an application.
pub async fn create_application_placement(configuration: &configuration::Configuration, version: f64, app_key: &str, size: &str, device_id: Option<&str>, account_id: Option<i64>, name: Option<&str>, description: Option<&str>, height: Option<i32>, width: Option<i32>, refresh_interval: Option<i32>, default_image_id: Option<i64>, active: Option<bool>) -> Result<models::PlacementResponse, Error<CreateApplicationPlacementError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_app_key = app_key;
    let p_query_size = size;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_name = name;
    let p_query_description = description;
    let p_query_height = height;
    let p_query_width = width;
    let p_query_refresh_interval = refresh_interval;
    let p_query_default_image_id = default_image_id;
    let p_query_active = active;

    let uri_str = format!("{}/api/{version}/application/placement/create", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("appKey", &p_query_app_key.to_string())]);
    if let Some(ref param_value) = p_query_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_description {
        req_builder = req_builder.query(&[("description", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("size", &p_query_size.to_string())]);
    if let Some(ref param_value) = p_query_height {
        req_builder = req_builder.query(&[("height", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_width {
        req_builder = req_builder.query(&[("width", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_refresh_interval {
        req_builder = req_builder.query(&[("refreshInterval", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_default_image_id {
        req_builder = req_builder.query(&[("defaultImageId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_active {
        req_builder = req_builder.query(&[("active", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PlacementResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PlacementResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateApplicationPlacementError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Set the deleted timestamp to current time. This effectively deletes the application since all queries should ignore any records with a deleted timestamp
pub async fn delete_application(configuration: &configuration::Configuration, version: f64, account_id: Option<i64>, app_key: Option<&str>) -> Result<models::SirqulResponse, Error<DeleteApplicationError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_account_id = account_id;
    let p_query_app_key = app_key;

    let uri_str = format!("{}/api/{version}/application/delete", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_key {
        req_builder = req_builder.query(&[("appKey", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SirqulResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SirqulResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteApplicationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deletes an ad placement for an application.
pub async fn delete_application_placement(configuration: &configuration::Configuration, version: f64, placement_id: i64, device_id: Option<&str>, account_id: Option<i64>) -> Result<models::PlacementResponse, Error<DeleteApplicationPlacementError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_placement_id = placement_id;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;

    let uri_str = format!("{}/api/{version}/application/placement/delete", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("placementId", &p_query_placement_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PlacementResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PlacementResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteApplicationPlacementError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a specific application by appKey
pub async fn get_application(configuration: &configuration::Configuration, version: f64, app_key: Option<&str>, application_id: Option<i64>) -> Result<models::ApplicationResponse, Error<GetApplicationError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_app_key = app_key;
    let p_query_application_id = application_id;

    let uri_str = format!("{}/api/{version}/application/get", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_app_key {
        req_builder = req_builder.query(&[("appKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_application_id {
        req_builder = req_builder.query(&[("applicationId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApplicationResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApplicationResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetApplicationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get details of an ad placement
pub async fn get_application_placement(configuration: &configuration::Configuration, version: f64, placement_id: i64, device_id: Option<&str>, account_id: Option<i64>) -> Result<models::PlacementResponse, Error<GetApplicationPlacementError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_placement_id = placement_id;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;

    let uri_str = format!("{}/api/{version}/application/placement/get", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("placementId", &p_query_placement_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PlacementResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PlacementResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetApplicationPlacementError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Will return a comma separated list of numbers, newest first. For example: 3.0, 2.2, 2.1, 1.8
pub async fn get_application_versions(configuration: &configuration::Configuration, version: f64) -> Result<models::SirqulResponse, Error<GetApplicationVersionsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;

    let uri_str = format!("{}/api/{version}/application/versions", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SirqulResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SirqulResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetApplicationVersionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a list of users per application
pub async fn get_unique_users_by_app(configuration: &configuration::Configuration, version: f64, app_key: &str, q: Option<&str>, keyword: Option<&str>, since: Option<i64>, _i: Option<i32>, start: Option<i32>, _l: Option<i32>, limit: Option<i32>) -> Result<models::AccountListResponse, Error<GetUniqueUsersByAppError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_app_key = app_key;
    let p_query_q = q;
    let p_query_keyword = keyword;
    let p_query_since = since;
    let p_query__i = _i;
    let p_query_start = start;
    let p_query__l = _l;
    let p_query_limit = limit;

    let uri_str = format!("{}/api/{version}/application/users", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("appKey", &p_query_app_key.to_string())]);
    if let Some(ref param_value) = p_query_q {
        req_builder = req_builder.query(&[("q", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_keyword {
        req_builder = req_builder.query(&[("keyword", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_since {
        req_builder = req_builder.query(&[("since", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query__i {
        req_builder = req_builder.query(&[("_i", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start {
        req_builder = req_builder.query(&[("start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query__l {
        req_builder = req_builder.query(&[("_l", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AccountListResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AccountListResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetUniqueUsersByAppError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// List active applications matching the criteria (as a consumer)
pub async fn list_applications(configuration: &configuration::Configuration, version: f64, account_id: Option<i64>, q: Option<&str>, keyword: Option<&str>, platforms: Option<&str>, device_ids: Option<&str>, device_versions: Option<&str>, category_ids: Option<&str>, sort_field: Option<&str>, has_ads: Option<bool>, public_notifications: Option<bool>, filter_billable: Option<bool>, filter_content_admin: Option<bool>, descending: Option<bool>, _i: Option<i32>, start: Option<i32>, _l: Option<i32>, limit: Option<i32>, application_ids: Option<&str>, has_object_store: Option<bool>, active_only: Option<bool>) -> Result<Vec<models::ApplicationShortResponse>, Error<ListApplicationsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_account_id = account_id;
    let p_query_q = q;
    let p_query_keyword = keyword;
    let p_query_platforms = platforms;
    let p_query_device_ids = device_ids;
    let p_query_device_versions = device_versions;
    let p_query_category_ids = category_ids;
    let p_query_sort_field = sort_field;
    let p_query_has_ads = has_ads;
    let p_query_public_notifications = public_notifications;
    let p_query_filter_billable = filter_billable;
    let p_query_filter_content_admin = filter_content_admin;
    let p_query_descending = descending;
    let p_query__i = _i;
    let p_query_start = start;
    let p_query__l = _l;
    let p_query_limit = limit;
    let p_query_application_ids = application_ids;
    let p_query_has_object_store = has_object_store;
    let p_query_active_only = active_only;

    let uri_str = format!("{}/api/{version}/application/list", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_q {
        req_builder = req_builder.query(&[("q", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_keyword {
        req_builder = req_builder.query(&[("keyword", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_platforms {
        req_builder = req_builder.query(&[("platforms", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_device_ids {
        req_builder = req_builder.query(&[("deviceIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_device_versions {
        req_builder = req_builder.query(&[("deviceVersions", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_category_ids {
        req_builder = req_builder.query(&[("categoryIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_field {
        req_builder = req_builder.query(&[("sortField", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_has_ads {
        req_builder = req_builder.query(&[("hasAds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_public_notifications {
        req_builder = req_builder.query(&[("publicNotifications", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_billable {
        req_builder = req_builder.query(&[("filterBillable", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_content_admin {
        req_builder = req_builder.query(&[("filterContentAdmin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_descending {
        req_builder = req_builder.query(&[("descending", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query__i {
        req_builder = req_builder.query(&[("_i", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start {
        req_builder = req_builder.query(&[("start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query__l {
        req_builder = req_builder.query(&[("_l", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_application_ids {
        req_builder = req_builder.query(&[("applicationIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_has_object_store {
        req_builder = req_builder.query(&[("hasObjectStore", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_active_only {
        req_builder = req_builder.query(&[("activeOnly", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::ApplicationShortResponse&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::ApplicationShortResponse&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListApplicationsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Searches placements for an application.
pub async fn search_application_placement(configuration: &configuration::Configuration, version: f64, app_key: &str, device_id: Option<&str>, account_id: Option<i64>, start: Option<i32>, limit: Option<i32>) -> Result<Vec<models::PlacementResponse>, Error<SearchApplicationPlacementError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_app_key = app_key;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_start = start;
    let p_query_limit = limit;

    let uri_str = format!("{}/api/{version}/application/placement/search", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("appKey", &p_query_app_key.to_string())]);
    if let Some(ref param_value) = p_query_start {
        req_builder = req_builder.query(&[("start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::PlacementResponse&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::PlacementResponse&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchApplicationPlacementError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns a list of applications that the user has logged into before, and returns specific settings for that application and user
pub async fn search_application_settings(configuration: &configuration::Configuration, version: f64, device_id: Option<&str>, account_id: Option<i64>, connection_account_id: Option<i64>, keyword: Option<&str>, sort_field: Option<&str>, descending: Option<bool>, start: Option<i32>, limit: Option<i32>) -> Result<models::ApplicationSettingsResponse, Error<SearchApplicationSettingsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_connection_account_id = connection_account_id;
    let p_query_keyword = keyword;
    let p_query_sort_field = sort_field;
    let p_query_descending = descending;
    let p_query_start = start;
    let p_query_limit = limit;

    let uri_str = format!("{}/api/{version}/application/settings/search", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_connection_account_id {
        req_builder = req_builder.query(&[("connectionAccountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_keyword {
        req_builder = req_builder.query(&[("keyword", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_field {
        req_builder = req_builder.query(&[("sortField", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_descending {
        req_builder = req_builder.query(&[("descending", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start {
        req_builder = req_builder.query(&[("start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApplicationSettingsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApplicationSettingsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchApplicationSettingsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Search for applications matching the criteria that the logged in user has access to
pub async fn search_applications(configuration: &configuration::Configuration, version: f64, device_id: Option<&str>, account_id: Option<i64>, latitude: Option<f64>, longitude: Option<f64>, q: Option<&str>, keyword: Option<&str>, q_search_fields: Option<&str>, sort_field: Option<&str>, descending: Option<bool>, _i: Option<i32>, start: Option<i32>, _l: Option<i32>, limit: Option<i32>, has_ads: Option<bool>, public_notifications: Option<bool>, active_only: Option<bool>) -> Result<Vec<models::ApplicationResponse>, Error<SearchApplicationsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_latitude = latitude;
    let p_query_longitude = longitude;
    let p_query_q = q;
    let p_query_keyword = keyword;
    let p_query_q_search_fields = q_search_fields;
    let p_query_sort_field = sort_field;
    let p_query_descending = descending;
    let p_query__i = _i;
    let p_query_start = start;
    let p_query__l = _l;
    let p_query_limit = limit;
    let p_query_has_ads = has_ads;
    let p_query_public_notifications = public_notifications;
    let p_query_active_only = active_only;

    let uri_str = format!("{}/api/{version}/application/search", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_latitude {
        req_builder = req_builder.query(&[("latitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_longitude {
        req_builder = req_builder.query(&[("longitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_q {
        req_builder = req_builder.query(&[("q", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_keyword {
        req_builder = req_builder.query(&[("keyword", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_q_search_fields {
        req_builder = req_builder.query(&[("qSearchFields", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_field {
        req_builder = req_builder.query(&[("sortField", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_descending {
        req_builder = req_builder.query(&[("descending", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query__i {
        req_builder = req_builder.query(&[("_i", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start {
        req_builder = req_builder.query(&[("start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query__l {
        req_builder = req_builder.query(&[("_l", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_has_ads {
        req_builder = req_builder.query(&[("hasAds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_public_notifications {
        req_builder = req_builder.query(&[("publicNotifications", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_active_only {
        req_builder = req_builder.query(&[("activeOnly", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::ApplicationResponse&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::ApplicationResponse&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchApplicationsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update an application record
pub async fn update_application(configuration: &configuration::Configuration, version: f64, app_key: &str, app_name: &str, device_id: Option<&str>, account_id: Option<i64>, about: Option<&str>, bundle_id: Option<&str>, app_icon_asset_id: Option<i64>, app_logo_asset_id: Option<i64>, facebook_app_id: Option<&str>, facebook_app_secret: Option<&str>, google_api_key: Option<&str>, update_eula_date: Option<bool>, eula_version: Option<&str>, landing_page_url: Option<&str>, show_in_activities: Option<bool>, activity_description: Option<&str>, invite_welcome_text: Option<&str>, invite_page_url: Option<&str>, url_scheme: Option<&str>, platforms: Option<&str>, download_urls: Option<&str>, category_ids: Option<&str>, scoring_type: Option<&str>, hint_cost: Option<i32>, max_score: Option<i32>, tickets_per_point: Option<f32>, has_game_data: Option<bool>, public_notifications: Option<bool>, use_matching_algorithm: Option<bool>, global_tickets: Option<bool>, build_version: Option<f32>, api_version: Option<f32>, placement_name: Option<&str>, placement_description: Option<&str>, placement_size: Option<&str>, placement_height: Option<i32>, placement_width: Option<i32>, placement_refresh_interval: Option<i32>, create_object_store: Option<bool>, public_content_approval: Option<bool>, production_mode: Option<bool>, minimum_session_length: Option<i32>, session_gap_length: Option<i32>, local_ads_enabled: Option<bool>, sqoot_api_key: Option<&str>, trilat_processing_type: Option<&str>, max_sample_size: Option<i32>, min_rssi: Option<f64>, modules: Option<&str>, authorized_count: Option<i32>, authorized_servers: Option<&str>, default_timezone: Option<&str>, smtp_pass: Option<&str>, meta_data: Option<&str>, placement_meta_data: Option<&str>, ips_floor: Option<bool>, enable_apns_badge: Option<bool>, include_in_report: Option<bool>, default_app_filter_id: Option<i64>, enable_welcome_email: Option<bool>, apple_app_id: Option<&str>, apple_team_id: Option<&str>, apple_auth_key_id: Option<&str>, apple_auth_key: Option<std::path::PathBuf>, apple_issuer_id: Option<&str>, app_store_key_id: Option<&str>, app_store_key: Option<std::path::PathBuf>, google_private_key_file: Option<std::path::PathBuf>, authorize_net_api_key: Option<&str>, authorize_net_transaction_key: Option<&str>, email_sender: Option<&str>, smtp_user: Option<&str>, smtp_host: Option<&str>, vatom_business_id: Option<&str>, vatom_rest_client_id: Option<&str>, vatom_rest_secret_key: Option<&str>, twilio_account_sid: Option<&str>, twilio_auth_token: Option<&str>, twilio_sender_phone_number: Option<&str>, open_ai_secret_key: Option<&str>) -> Result<models::ApplicationResponse, Error<UpdateApplicationError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_app_key = app_key;
    let p_query_app_name = app_name;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_about = about;
    let p_query_bundle_id = bundle_id;
    let p_query_app_icon_asset_id = app_icon_asset_id;
    let p_query_app_logo_asset_id = app_logo_asset_id;
    let p_query_facebook_app_id = facebook_app_id;
    let p_query_facebook_app_secret = facebook_app_secret;
    let p_query_google_api_key = google_api_key;
    let p_query_update_eula_date = update_eula_date;
    let p_query_eula_version = eula_version;
    let p_query_landing_page_url = landing_page_url;
    let p_query_show_in_activities = show_in_activities;
    let p_query_activity_description = activity_description;
    let p_query_invite_welcome_text = invite_welcome_text;
    let p_query_invite_page_url = invite_page_url;
    let p_query_url_scheme = url_scheme;
    let p_query_platforms = platforms;
    let p_query_download_urls = download_urls;
    let p_query_category_ids = category_ids;
    let p_query_scoring_type = scoring_type;
    let p_query_hint_cost = hint_cost;
    let p_query_max_score = max_score;
    let p_query_tickets_per_point = tickets_per_point;
    let p_query_has_game_data = has_game_data;
    let p_query_public_notifications = public_notifications;
    let p_query_use_matching_algorithm = use_matching_algorithm;
    let p_query_global_tickets = global_tickets;
    let p_query_build_version = build_version;
    let p_query_api_version = api_version;
    let p_query_placement_name = placement_name;
    let p_query_placement_description = placement_description;
    let p_query_placement_size = placement_size;
    let p_query_placement_height = placement_height;
    let p_query_placement_width = placement_width;
    let p_query_placement_refresh_interval = placement_refresh_interval;
    let p_query_create_object_store = create_object_store;
    let p_query_public_content_approval = public_content_approval;
    let p_query_production_mode = production_mode;
    let p_query_minimum_session_length = minimum_session_length;
    let p_query_session_gap_length = session_gap_length;
    let p_query_local_ads_enabled = local_ads_enabled;
    let p_query_sqoot_api_key = sqoot_api_key;
    let p_query_trilat_processing_type = trilat_processing_type;
    let p_query_max_sample_size = max_sample_size;
    let p_query_min_rssi = min_rssi;
    let p_query_modules = modules;
    let p_query_authorized_count = authorized_count;
    let p_query_authorized_servers = authorized_servers;
    let p_query_default_timezone = default_timezone;
    let p_query_smtp_pass = smtp_pass;
    let p_query_meta_data = meta_data;
    let p_query_placement_meta_data = placement_meta_data;
    let p_query_ips_floor = ips_floor;
    let p_query_enable_apns_badge = enable_apns_badge;
    let p_query_include_in_report = include_in_report;
    let p_query_default_app_filter_id = default_app_filter_id;
    let p_query_enable_welcome_email = enable_welcome_email;
    let p_query_apple_app_id = apple_app_id;
    let p_query_apple_team_id = apple_team_id;
    let p_query_apple_auth_key_id = apple_auth_key_id;
    let p_query_apple_auth_key = apple_auth_key;
    let p_query_apple_issuer_id = apple_issuer_id;
    let p_query_app_store_key_id = app_store_key_id;
    let p_query_app_store_key = app_store_key;
    let p_query_google_private_key_file = google_private_key_file;
    let p_query_authorize_net_api_key = authorize_net_api_key;
    let p_query_authorize_net_transaction_key = authorize_net_transaction_key;
    let p_query_email_sender = email_sender;
    let p_query_smtp_user = smtp_user;
    let p_query_smtp_host = smtp_host;
    let p_query_vatom_business_id = vatom_business_id;
    let p_query_vatom_rest_client_id = vatom_rest_client_id;
    let p_query_vatom_rest_secret_key = vatom_rest_secret_key;
    let p_query_twilio_account_sid = twilio_account_sid;
    let p_query_twilio_auth_token = twilio_auth_token;
    let p_query_twilio_sender_phone_number = twilio_sender_phone_number;
    let p_query_open_ai_secret_key = open_ai_secret_key;

    let uri_str = format!("{}/api/{version}/application/update", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("appKey", &p_query_app_key.to_string())]);
    req_builder = req_builder.query(&[("appName", &p_query_app_name.to_string())]);
    if let Some(ref param_value) = p_query_about {
        req_builder = req_builder.query(&[("about", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_bundle_id {
        req_builder = req_builder.query(&[("bundleId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_icon_asset_id {
        req_builder = req_builder.query(&[("appIconAssetId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_logo_asset_id {
        req_builder = req_builder.query(&[("appLogoAssetId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_facebook_app_id {
        req_builder = req_builder.query(&[("facebookAppId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_facebook_app_secret {
        req_builder = req_builder.query(&[("facebookAppSecret", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_google_api_key {
        req_builder = req_builder.query(&[("googleApiKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_update_eula_date {
        req_builder = req_builder.query(&[("updateEULADate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_eula_version {
        req_builder = req_builder.query(&[("eulaVersion", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_landing_page_url {
        req_builder = req_builder.query(&[("landingPageUrl", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_show_in_activities {
        req_builder = req_builder.query(&[("showInActivities", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_activity_description {
        req_builder = req_builder.query(&[("activityDescription", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_invite_welcome_text {
        req_builder = req_builder.query(&[("inviteWelcomeText", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_invite_page_url {
        req_builder = req_builder.query(&[("invitePageUrl", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_url_scheme {
        req_builder = req_builder.query(&[("urlScheme", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_platforms {
        req_builder = req_builder.query(&[("platforms", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_download_urls {
        req_builder = req_builder.query(&[("downloadUrls", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_category_ids {
        req_builder = req_builder.query(&[("categoryIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_scoring_type {
        req_builder = req_builder.query(&[("scoringType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_hint_cost {
        req_builder = req_builder.query(&[("hintCost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_max_score {
        req_builder = req_builder.query(&[("maxScore", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_tickets_per_point {
        req_builder = req_builder.query(&[("ticketsPerPoint", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_has_game_data {
        req_builder = req_builder.query(&[("hasGameData", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_public_notifications {
        req_builder = req_builder.query(&[("publicNotifications", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_use_matching_algorithm {
        req_builder = req_builder.query(&[("useMatchingAlgorithm", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_global_tickets {
        req_builder = req_builder.query(&[("globalTickets", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_build_version {
        req_builder = req_builder.query(&[("buildVersion", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_api_version {
        req_builder = req_builder.query(&[("apiVersion", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_placement_name {
        req_builder = req_builder.query(&[("placementName", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_placement_description {
        req_builder = req_builder.query(&[("placementDescription", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_placement_size {
        req_builder = req_builder.query(&[("placementSize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_placement_height {
        req_builder = req_builder.query(&[("placementHeight", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_placement_width {
        req_builder = req_builder.query(&[("placementWidth", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_placement_refresh_interval {
        req_builder = req_builder.query(&[("placementRefreshInterval", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_create_object_store {
        req_builder = req_builder.query(&[("createObjectStore", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_public_content_approval {
        req_builder = req_builder.query(&[("publicContentApproval", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_production_mode {
        req_builder = req_builder.query(&[("productionMode", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_minimum_session_length {
        req_builder = req_builder.query(&[("minimumSessionLength", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_session_gap_length {
        req_builder = req_builder.query(&[("sessionGapLength", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_local_ads_enabled {
        req_builder = req_builder.query(&[("localAdsEnabled", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sqoot_api_key {
        req_builder = req_builder.query(&[("sqootApiKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_trilat_processing_type {
        req_builder = req_builder.query(&[("trilatProcessingType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_max_sample_size {
        req_builder = req_builder.query(&[("maxSampleSize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_min_rssi {
        req_builder = req_builder.query(&[("minRSSI", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_modules {
        req_builder = req_builder.query(&[("modules", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_authorized_count {
        req_builder = req_builder.query(&[("authorizedCount", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_authorized_servers {
        req_builder = req_builder.query(&[("authorizedServers", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_default_timezone {
        req_builder = req_builder.query(&[("defaultTimezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_smtp_pass {
        req_builder = req_builder.query(&[("smtpPass", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_meta_data {
        req_builder = req_builder.query(&[("metaData", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_placement_meta_data {
        req_builder = req_builder.query(&[("placementMetaData", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ips_floor {
        req_builder = req_builder.query(&[("ipsFloor", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_enable_apns_badge {
        req_builder = req_builder.query(&[("enableAPNSBadge", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_in_report {
        req_builder = req_builder.query(&[("includeInReport", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_default_app_filter_id {
        req_builder = req_builder.query(&[("defaultAppFilterId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_enable_welcome_email {
        req_builder = req_builder.query(&[("enableWelcomeEmail", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_apple_app_id {
        req_builder = req_builder.query(&[("appleAppId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_apple_team_id {
        req_builder = req_builder.query(&[("appleTeamId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_apple_auth_key_id {
        req_builder = req_builder.query(&[("appleAuthKeyId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_apple_auth_key {
        req_builder = req_builder.query(&[("appleAuthKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_apple_issuer_id {
        req_builder = req_builder.query(&[("appleIssuerId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_store_key_id {
        req_builder = req_builder.query(&[("appStoreKeyId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_store_key {
        req_builder = req_builder.query(&[("appStoreKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_google_private_key_file {
        req_builder = req_builder.query(&[("googlePrivateKeyFile", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_authorize_net_api_key {
        req_builder = req_builder.query(&[("authorizeNetApiKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_authorize_net_transaction_key {
        req_builder = req_builder.query(&[("authorizeNetTransactionKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_email_sender {
        req_builder = req_builder.query(&[("emailSender", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_smtp_user {
        req_builder = req_builder.query(&[("smtpUser", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_smtp_host {
        req_builder = req_builder.query(&[("smtpHost", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_vatom_business_id {
        req_builder = req_builder.query(&[("vatomBusinessId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_vatom_rest_client_id {
        req_builder = req_builder.query(&[("vatomRestClientId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_vatom_rest_secret_key {
        req_builder = req_builder.query(&[("vatomRestSecretKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_twilio_account_sid {
        req_builder = req_builder.query(&[("twilioAccountSID", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_twilio_auth_token {
        req_builder = req_builder.query(&[("twilioAuthToken", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_twilio_sender_phone_number {
        req_builder = req_builder.query(&[("twilioSenderPhoneNumber", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_open_ai_secret_key {
        req_builder = req_builder.query(&[("openAISecretKey", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApplicationResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApplicationResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateApplicationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Set the application's active flag to true/false. This effectively activates or deactivates the application.
pub async fn update_application_active(configuration: &configuration::Configuration, version: f64, account_id: i64, app_key: &str, active: bool) -> Result<models::SirqulResponse, Error<UpdateApplicationActiveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_account_id = account_id;
    let p_query_app_key = app_key;
    let p_query_active = active;

    let uri_str = format!("{}/api/{version}/application/active", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("appKey", &p_query_app_key.to_string())]);
    req_builder = req_builder.query(&[("active", &p_query_active.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SirqulResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SirqulResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateApplicationActiveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates an ad placement for an application.
pub async fn update_application_placement(configuration: &configuration::Configuration, version: f64, placement_id: i64, device_id: Option<&str>, account_id: Option<i64>, name: Option<&str>, description: Option<&str>, size: Option<&str>, height: Option<i32>, width: Option<i32>, refresh_interval: Option<i32>, default_image_id: Option<i64>, active: Option<bool>) -> Result<models::PlacementResponse, Error<UpdateApplicationPlacementError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_placement_id = placement_id;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_name = name;
    let p_query_description = description;
    let p_query_size = size;
    let p_query_height = height;
    let p_query_width = width;
    let p_query_refresh_interval = refresh_interval;
    let p_query_default_image_id = default_image_id;
    let p_query_active = active;

    let uri_str = format!("{}/api/{version}/application/placement/update", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("placementId", &p_query_placement_id.to_string())]);
    if let Some(ref param_value) = p_query_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_description {
        req_builder = req_builder.query(&[("description", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_size {
        req_builder = req_builder.query(&[("size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_height {
        req_builder = req_builder.query(&[("height", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_width {
        req_builder = req_builder.query(&[("width", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_refresh_interval {
        req_builder = req_builder.query(&[("refreshInterval", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_default_image_id {
        req_builder = req_builder.query(&[("defaultImageId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_active {
        req_builder = req_builder.query(&[("active", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PlacementResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PlacementResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateApplicationPlacementError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Uploads a certificate for an application that the user has access to.
pub async fn upload_application_certificate(configuration: &configuration::Configuration, version: f64, app_key: &str, device_id: Option<&str>, account_id: Option<i64>, certificate: Option<std::path::PathBuf>) -> Result<models::SirqulResponse, Error<UploadApplicationCertificateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_app_key = app_key;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_certificate = certificate;

    let uri_str = format!("{}/api/{version}/application/certificate/create", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("appKey", &p_query_app_key.to_string())]);
    if let Some(ref param_value) = p_query_certificate {
        req_builder = req_builder.query(&[("certificate", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SirqulResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SirqulResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UploadApplicationCertificateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

