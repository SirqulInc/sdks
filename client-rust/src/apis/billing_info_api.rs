/*
 * Sirqul IoT Platform
 *
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`add_payment_method`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddPaymentMethodError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_payment_method`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreatePaymentMethodError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_smart_contract`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSmartContractError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_crypto_balance`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetCryptoBalanceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_payment_method`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetPaymentMethodError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_payment_method`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchPaymentMethodError {
    UnknownValue(serde_json::Value),
}


/// Update a method of payment. If the paymentMethodId is not passed in then will update their default payment method.
pub async fn add_payment_method(configuration: &configuration::Configuration, version: f64, account_id: i64, payment_method_id: Option<i64>, account_name: Option<&str>, first_name: Option<&str>, last_name: Option<&str>, address: Option<&str>, city: Option<&str>, state: Option<&str>, postal_code: Option<&str>, country: Option<&str>, phone: Option<&str>, credit_card_number: Option<&str>, expiration_date: Option<&str>, ccv: Option<&str>, account_number: Option<&str>, bank_name: Option<&str>, routing_number: Option<&str>, default_payment_method: Option<bool>, payment_method_nickname: Option<&str>, tax_id: Option<&str>, provider_customer_profile_id: Option<&str>, provider_payment_profile_id: Option<&str>, meta_data: Option<&str>) -> Result<models::PaymentTypesResponse, Error<AddPaymentMethodError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_account_id = account_id;
    let p_query_payment_method_id = payment_method_id;
    let p_query_account_name = account_name;
    let p_query_first_name = first_name;
    let p_query_last_name = last_name;
    let p_query_address = address;
    let p_query_city = city;
    let p_query_state = state;
    let p_query_postal_code = postal_code;
    let p_query_country = country;
    let p_query_phone = phone;
    let p_query_credit_card_number = credit_card_number;
    let p_query_expiration_date = expiration_date;
    let p_query_ccv = ccv;
    let p_query_account_number = account_number;
    let p_query_bank_name = bank_name;
    let p_query_routing_number = routing_number;
    let p_query_default_payment_method = default_payment_method;
    let p_query_payment_method_nickname = payment_method_nickname;
    let p_query_tax_id = tax_id;
    let p_query_provider_customer_profile_id = provider_customer_profile_id;
    let p_query_provider_payment_profile_id = provider_payment_profile_id;
    let p_query_meta_data = meta_data;

    let uri_str = format!("{}/api/{version}/billing/update", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    if let Some(ref param_value) = p_query_payment_method_id {
        req_builder = req_builder.query(&[("paymentMethodId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_name {
        req_builder = req_builder.query(&[("accountName", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_first_name {
        req_builder = req_builder.query(&[("firstName", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_last_name {
        req_builder = req_builder.query(&[("lastName", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_address {
        req_builder = req_builder.query(&[("address", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_city {
        req_builder = req_builder.query(&[("city", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_state {
        req_builder = req_builder.query(&[("state", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_postal_code {
        req_builder = req_builder.query(&[("postalCode", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_phone {
        req_builder = req_builder.query(&[("phone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_credit_card_number {
        req_builder = req_builder.query(&[("creditCardNumber", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_expiration_date {
        req_builder = req_builder.query(&[("expirationDate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ccv {
        req_builder = req_builder.query(&[("ccv", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_number {
        req_builder = req_builder.query(&[("accountNumber", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_bank_name {
        req_builder = req_builder.query(&[("bankName", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_routing_number {
        req_builder = req_builder.query(&[("routingNumber", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_default_payment_method {
        req_builder = req_builder.query(&[("defaultPaymentMethod", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_payment_method_nickname {
        req_builder = req_builder.query(&[("paymentMethodNickname", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_tax_id {
        req_builder = req_builder.query(&[("taxId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_provider_customer_profile_id {
        req_builder = req_builder.query(&[("providerCustomerProfileId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_provider_payment_profile_id {
        req_builder = req_builder.query(&[("providerPaymentProfileId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_meta_data {
        req_builder = req_builder.query(&[("metaData", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaymentTypesResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaymentTypesResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AddPaymentMethodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Add a new method of payment.
pub async fn create_payment_method(configuration: &configuration::Configuration, version: f64, account_id: i64, account_name: Option<&str>, first_name: Option<&str>, last_name: Option<&str>, address: Option<&str>, city: Option<&str>, state: Option<&str>, postal_code: Option<&str>, country: Option<&str>, phone: Option<&str>, credit_card_number: Option<&str>, expiration_date: Option<&str>, ccv: Option<&str>, account_number: Option<&str>, bank_name: Option<&str>, routing_number: Option<&str>, payment_method_nickname: Option<&str>, tax_id: Option<&str>, default_payment_method: Option<bool>, auth_token: Option<&str>, provider: Option<&str>, provider_customer_profile_id: Option<&str>, provider_payment_profile_id: Option<&str>, meta_data: Option<&str>, app_key: Option<&str>) -> Result<models::PaymentTypesResponse, Error<CreatePaymentMethodError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_account_id = account_id;
    let p_query_account_name = account_name;
    let p_query_first_name = first_name;
    let p_query_last_name = last_name;
    let p_query_address = address;
    let p_query_city = city;
    let p_query_state = state;
    let p_query_postal_code = postal_code;
    let p_query_country = country;
    let p_query_phone = phone;
    let p_query_credit_card_number = credit_card_number;
    let p_query_expiration_date = expiration_date;
    let p_query_ccv = ccv;
    let p_query_account_number = account_number;
    let p_query_bank_name = bank_name;
    let p_query_routing_number = routing_number;
    let p_query_payment_method_nickname = payment_method_nickname;
    let p_query_tax_id = tax_id;
    let p_query_default_payment_method = default_payment_method;
    let p_query_auth_token = auth_token;
    let p_query_provider = provider;
    let p_query_provider_customer_profile_id = provider_customer_profile_id;
    let p_query_provider_payment_profile_id = provider_payment_profile_id;
    let p_query_meta_data = meta_data;
    let p_query_app_key = app_key;

    let uri_str = format!("{}/api/{version}/billing/create", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    if let Some(ref param_value) = p_query_account_name {
        req_builder = req_builder.query(&[("accountName", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_first_name {
        req_builder = req_builder.query(&[("firstName", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_last_name {
        req_builder = req_builder.query(&[("lastName", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_address {
        req_builder = req_builder.query(&[("address", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_city {
        req_builder = req_builder.query(&[("city", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_state {
        req_builder = req_builder.query(&[("state", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_postal_code {
        req_builder = req_builder.query(&[("postalCode", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_phone {
        req_builder = req_builder.query(&[("phone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_credit_card_number {
        req_builder = req_builder.query(&[("creditCardNumber", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_expiration_date {
        req_builder = req_builder.query(&[("expirationDate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ccv {
        req_builder = req_builder.query(&[("ccv", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_number {
        req_builder = req_builder.query(&[("accountNumber", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_bank_name {
        req_builder = req_builder.query(&[("bankName", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_routing_number {
        req_builder = req_builder.query(&[("routingNumber", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_payment_method_nickname {
        req_builder = req_builder.query(&[("paymentMethodNickname", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_tax_id {
        req_builder = req_builder.query(&[("taxId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_default_payment_method {
        req_builder = req_builder.query(&[("defaultPaymentMethod", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auth_token {
        req_builder = req_builder.query(&[("authToken", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_provider {
        req_builder = req_builder.query(&[("provider", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_provider_customer_profile_id {
        req_builder = req_builder.query(&[("providerCustomerProfileId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_provider_payment_profile_id {
        req_builder = req_builder.query(&[("providerPaymentProfileId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_meta_data {
        req_builder = req_builder.query(&[("metaData", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_key {
        req_builder = req_builder.query(&[("appKey", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaymentTypesResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaymentTypesResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreatePaymentMethodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Adds a smart contract.
pub async fn create_smart_contract(configuration: &configuration::Configuration, version: f64, account_id: i64, token_name: &str, token_symbol: &str, payment_method_id: Option<i64>) -> Result<models::PaymentTypesResponse, Error<CreateSmartContractError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_account_id = account_id;
    let p_query_token_name = token_name;
    let p_query_token_symbol = token_symbol;
    let p_query_payment_method_id = payment_method_id;

    let uri_str = format!("{}/api/{version}/billing/crypto/transfer", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    if let Some(ref param_value) = p_query_payment_method_id {
        req_builder = req_builder.query(&[("paymentMethodId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("tokenName", &p_query_token_name.to_string())]);
    req_builder = req_builder.query(&[("tokenSymbol", &p_query_token_symbol.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaymentTypesResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaymentTypesResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateSmartContractError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the cypto balance details for a user
pub async fn get_crypto_balance(configuration: &configuration::Configuration, version: f64, account_id: i64, owner_account_id: Option<i64>, payment_method_id: Option<i64>) -> Result<models::PaymentTypesResponse, Error<GetCryptoBalanceError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_account_id = account_id;
    let p_query_owner_account_id = owner_account_id;
    let p_query_payment_method_id = payment_method_id;

    let uri_str = format!("{}/api/{version}/billing/crypto/get", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    if let Some(ref param_value) = p_query_owner_account_id {
        req_builder = req_builder.query(&[("ownerAccountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_payment_method_id {
        req_builder = req_builder.query(&[("paymentMethodId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaymentTypesResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaymentTypesResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetCryptoBalanceError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the details of the user's payment method or their current default method of payment
pub async fn get_payment_method(configuration: &configuration::Configuration, version: f64, account_id: i64, payment_method_id: Option<i64>, get_current_balance: Option<bool>) -> Result<models::PaymentTypesResponse, Error<GetPaymentMethodError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_account_id = account_id;
    let p_query_payment_method_id = payment_method_id;
    let p_query_get_current_balance = get_current_balance;

    let uri_str = format!("{}/api/{version}/billing/get", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    if let Some(ref param_value) = p_query_payment_method_id {
        req_builder = req_builder.query(&[("paymentMethodId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_get_current_balance {
        req_builder = req_builder.query(&[("getCurrentBalance", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaymentTypesResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaymentTypesResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetPaymentMethodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Search the payment methods of an account
pub async fn search_payment_method(configuration: &configuration::Configuration, version: f64, account_id: i64, provider: Option<&str>, r#type: Option<&str>, keyword: Option<&str>, sort_field: Option<&str>, descending: Option<bool>, start: Option<i32>, limit: Option<i32>) -> Result<models::PaymentTypesResponse, Error<SearchPaymentMethodError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_account_id = account_id;
    let p_query_provider = provider;
    let p_query_type = r#type;
    let p_query_keyword = keyword;
    let p_query_sort_field = sort_field;
    let p_query_descending = descending;
    let p_query_start = start;
    let p_query_limit = limit;

    let uri_str = format!("{}/api/{version}/billing/search", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    if let Some(ref param_value) = p_query_provider {
        req_builder = req_builder.query(&[("provider", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_keyword {
        req_builder = req_builder.query(&[("keyword", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_field {
        req_builder = req_builder.query(&[("sortField", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_descending {
        req_builder = req_builder.query(&[("descending", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start {
        req_builder = req_builder.query(&[("start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaymentTypesResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaymentTypesResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchPaymentMethodError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

