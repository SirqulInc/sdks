/*
 * Sirqul IoT Platform
 *
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`assign_employee`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AssignEmployeeError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`assign_to_location_employee`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AssignToLocationEmployeeError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_employee`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateEmployeeError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_employee`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteEmployeeError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_employee`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetEmployeeError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_employees`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchEmployeesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`unassign_employee`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UnassignEmployeeError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_employee`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateEmployeeError {
    UnknownValue(serde_json::Value),
}


/// Assign An existing account to be an employee
pub async fn assign_employee(configuration: &configuration::Configuration, version: f64, account_id: i64, manager_account_id: i64, employee_account_id: i64, role: Option<&str>) -> Result<models::EmployeeResponse, Error<AssignEmployeeError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_account_id = account_id;
    let p_query_manager_account_id = manager_account_id;
    let p_query_employee_account_id = employee_account_id;
    let p_query_role = role;

    let uri_str = format!("{}/api/{version}/employee/assign", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("managerAccountId", &p_query_manager_account_id.to_string())]);
    req_builder = req_builder.query(&[("employeeAccountId", &p_query_employee_account_id.to_string())]);
    if let Some(ref param_value) = p_query_role {
        req_builder = req_builder.query(&[("role", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EmployeeResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EmployeeResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AssignEmployeeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Assign or unassign the account to a retailer location.
pub async fn assign_to_location_employee(configuration: &configuration::Configuration, version: f64, account_id: i64, retailer_location_id: i64, employee_account_id: Option<i64>, assign: Option<bool>) -> Result<models::SirqulResponse, Error<AssignToLocationEmployeeError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_account_id = account_id;
    let p_query_retailer_location_id = retailer_location_id;
    let p_query_employee_account_id = employee_account_id;
    let p_query_assign = assign;

    let uri_str = format!("{}/api/{version}/employee/assignToLocation", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    if let Some(ref param_value) = p_query_employee_account_id {
        req_builder = req_builder.query(&[("employeeAccountId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("retailerLocationId", &p_query_retailer_location_id.to_string())]);
    if let Some(ref param_value) = p_query_assign {
        req_builder = req_builder.query(&[("assign", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SirqulResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SirqulResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AssignToLocationEmployeeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create a new account record with the provided information.
pub async fn create_employee(configuration: &configuration::Configuration, version: f64, account_id: i64, manager_account_id: i64, username: &str, password: &str, name: Option<&str>, prefix_name: Option<&str>, first_name: Option<&str>, middle_name: Option<&str>, last_name: Option<&str>, suffix_name: Option<&str>, title: Option<&str>, about_us: Option<&str>, asset_id: Option<i64>, gender: Option<&str>, home_phone: Option<&str>, cell_phone: Option<&str>, cell_phone_carrier: Option<&str>, business_phone: Option<&str>, email_address: Option<&str>, street_address: Option<&str>, street_address2: Option<&str>, city: Option<&str>, state: Option<&str>, zipcode: Option<&str>, country: Option<&str>, role: Option<&str>, retailer_location_ids: Option<&str>, settings_app_key: Option<&str>, app_blob: Option<&str>, assigned_device_id: Option<&str>) -> Result<models::EmployeeResponse, Error<CreateEmployeeError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_account_id = account_id;
    let p_query_manager_account_id = manager_account_id;
    let p_query_username = username;
    let p_query_password = password;
    let p_query_name = name;
    let p_query_prefix_name = prefix_name;
    let p_query_first_name = first_name;
    let p_query_middle_name = middle_name;
    let p_query_last_name = last_name;
    let p_query_suffix_name = suffix_name;
    let p_query_title = title;
    let p_query_about_us = about_us;
    let p_query_asset_id = asset_id;
    let p_query_gender = gender;
    let p_query_home_phone = home_phone;
    let p_query_cell_phone = cell_phone;
    let p_query_cell_phone_carrier = cell_phone_carrier;
    let p_query_business_phone = business_phone;
    let p_query_email_address = email_address;
    let p_query_street_address = street_address;
    let p_query_street_address2 = street_address2;
    let p_query_city = city;
    let p_query_state = state;
    let p_query_zipcode = zipcode;
    let p_query_country = country;
    let p_query_role = role;
    let p_query_retailer_location_ids = retailer_location_ids;
    let p_query_settings_app_key = settings_app_key;
    let p_query_app_blob = app_blob;
    let p_query_assigned_device_id = assigned_device_id;

    let uri_str = format!("{}/api/{version}/employee/create", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("managerAccountId", &p_query_manager_account_id.to_string())]);
    req_builder = req_builder.query(&[("username", &p_query_username.to_string())]);
    req_builder = req_builder.query(&[("password", &p_query_password.to_string())]);
    if let Some(ref param_value) = p_query_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_prefix_name {
        req_builder = req_builder.query(&[("prefixName", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_first_name {
        req_builder = req_builder.query(&[("firstName", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_middle_name {
        req_builder = req_builder.query(&[("middleName", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_last_name {
        req_builder = req_builder.query(&[("lastName", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_suffix_name {
        req_builder = req_builder.query(&[("suffixName", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_title {
        req_builder = req_builder.query(&[("title", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_about_us {
        req_builder = req_builder.query(&[("aboutUs", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_asset_id {
        req_builder = req_builder.query(&[("assetId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_gender {
        req_builder = req_builder.query(&[("gender", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_home_phone {
        req_builder = req_builder.query(&[("homePhone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cell_phone {
        req_builder = req_builder.query(&[("cellPhone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cell_phone_carrier {
        req_builder = req_builder.query(&[("cellPhoneCarrier", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_business_phone {
        req_builder = req_builder.query(&[("businessPhone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_email_address {
        req_builder = req_builder.query(&[("emailAddress", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_street_address {
        req_builder = req_builder.query(&[("streetAddress", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_street_address2 {
        req_builder = req_builder.query(&[("streetAddress2", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_city {
        req_builder = req_builder.query(&[("city", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_state {
        req_builder = req_builder.query(&[("state", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_zipcode {
        req_builder = req_builder.query(&[("zipcode", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_role {
        req_builder = req_builder.query(&[("role", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_retailer_location_ids {
        req_builder = req_builder.query(&[("retailerLocationIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_settings_app_key {
        req_builder = req_builder.query(&[("settingsAppKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_blob {
        req_builder = req_builder.query(&[("appBlob", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_assigned_device_id {
        req_builder = req_builder.query(&[("assignedDeviceId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EmployeeResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EmployeeResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateEmployeeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Set the deleted date field which marks the record as deleted.
pub async fn delete_employee(configuration: &configuration::Configuration, version: f64, account_id: i64, employee_account_id: i64) -> Result<models::SirqulResponse, Error<DeleteEmployeeError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_account_id = account_id;
    let p_query_employee_account_id = employee_account_id;

    let uri_str = format!("{}/api/{version}/employee/delete", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("employeeAccountId", &p_query_employee_account_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SirqulResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SirqulResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteEmployeeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the account record for the account id provided.
pub async fn get_employee(configuration: &configuration::Configuration, version: f64, account_id: i64, employee_account_id: i64, settings_app_key: Option<&str>) -> Result<models::EmployeeResponse, Error<GetEmployeeError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_account_id = account_id;
    let p_query_employee_account_id = employee_account_id;
    let p_query_settings_app_key = settings_app_key;

    let uri_str = format!("{}/api/{version}/employee/get", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("employeeAccountId", &p_query_employee_account_id.to_string())]);
    if let Some(ref param_value) = p_query_settings_app_key {
        req_builder = req_builder.query(&[("settingsAppKey", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EmployeeResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EmployeeResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetEmployeeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Use the accountId to determine the associated BillableEntity. From there get a list of all accounts associated as managers/employees.
pub async fn search_employees(configuration: &configuration::Configuration, version: f64, account_id: i64, role: Option<&str>, retailer_id: Option<i64>, retailer_location_id: Option<i64>, q: Option<&str>, keyword: Option<&str>, sort_field: Option<&str>, descending: Option<bool>, _i: Option<i32>, start: Option<i32>, _l: Option<i32>, limit: Option<i32>, active_only: Option<bool>, managed_only: Option<bool>, settings_app_key: Option<&str>, category_ids: Option<&str>, query: Option<&str>) -> Result<Vec<models::EmployeeResponse>, Error<SearchEmployeesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_account_id = account_id;
    let p_query_role = role;
    let p_query_retailer_id = retailer_id;
    let p_query_retailer_location_id = retailer_location_id;
    let p_query_q = q;
    let p_query_keyword = keyword;
    let p_query_sort_field = sort_field;
    let p_query_descending = descending;
    let p_query__i = _i;
    let p_query_start = start;
    let p_query__l = _l;
    let p_query_limit = limit;
    let p_query_active_only = active_only;
    let p_query_managed_only = managed_only;
    let p_query_settings_app_key = settings_app_key;
    let p_query_category_ids = category_ids;
    let p_query_query = query;

    let uri_str = format!("{}/api/{version}/employee/search", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    if let Some(ref param_value) = p_query_role {
        req_builder = req_builder.query(&[("role", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_retailer_id {
        req_builder = req_builder.query(&[("retailerId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_retailer_location_id {
        req_builder = req_builder.query(&[("retailerLocationId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_q {
        req_builder = req_builder.query(&[("q", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_keyword {
        req_builder = req_builder.query(&[("keyword", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_field {
        req_builder = req_builder.query(&[("sortField", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_descending {
        req_builder = req_builder.query(&[("descending", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query__i {
        req_builder = req_builder.query(&[("_i", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start {
        req_builder = req_builder.query(&[("start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query__l {
        req_builder = req_builder.query(&[("_l", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_active_only {
        req_builder = req_builder.query(&[("activeOnly", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_managed_only {
        req_builder = req_builder.query(&[("managedOnly", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_settings_app_key {
        req_builder = req_builder.query(&[("settingsAppKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_category_ids {
        req_builder = req_builder.query(&[("categoryIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_query {
        req_builder = req_builder.query(&[("query", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::EmployeeResponse&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::EmployeeResponse&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchEmployeesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Unassign An existing account to be an employee
pub async fn unassign_employee(configuration: &configuration::Configuration, version: f64, account_id: i64, employee_account_id: i64) -> Result<models::EmployeeResponse, Error<UnassignEmployeeError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_account_id = account_id;
    let p_query_employee_account_id = employee_account_id;

    let uri_str = format!("{}/api/{version}/employee/unassign", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("employeeAccountId", &p_query_employee_account_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EmployeeResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EmployeeResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UnassignEmployeeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update the account record with the provided information.
pub async fn update_employee(configuration: &configuration::Configuration, version: f64, account_id: i64, employee_account_id: i64, manager_account_id: Option<i64>, name: Option<&str>, prefix_name: Option<&str>, first_name: Option<&str>, middle_name: Option<&str>, last_name: Option<&str>, suffix_name: Option<&str>, title: Option<&str>, asset_id: Option<i64>, gender: Option<&str>, home_phone: Option<&str>, cell_phone: Option<&str>, cell_phone_carrier: Option<&str>, business_phone: Option<&str>, email_address: Option<&str>, street_address: Option<&str>, street_address2: Option<&str>, city: Option<&str>, state: Option<&str>, zipcode: Option<&str>, country: Option<&str>, role: Option<&str>, active: Option<bool>, password: Option<&str>, retailer_location_ids: Option<&str>, settings_app_key: Option<&str>, app_blob: Option<&str>, assigned_device_id: Option<&str>) -> Result<models::EmployeeResponse, Error<UpdateEmployeeError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_account_id = account_id;
    let p_query_employee_account_id = employee_account_id;
    let p_query_manager_account_id = manager_account_id;
    let p_query_name = name;
    let p_query_prefix_name = prefix_name;
    let p_query_first_name = first_name;
    let p_query_middle_name = middle_name;
    let p_query_last_name = last_name;
    let p_query_suffix_name = suffix_name;
    let p_query_title = title;
    let p_query_asset_id = asset_id;
    let p_query_gender = gender;
    let p_query_home_phone = home_phone;
    let p_query_cell_phone = cell_phone;
    let p_query_cell_phone_carrier = cell_phone_carrier;
    let p_query_business_phone = business_phone;
    let p_query_email_address = email_address;
    let p_query_street_address = street_address;
    let p_query_street_address2 = street_address2;
    let p_query_city = city;
    let p_query_state = state;
    let p_query_zipcode = zipcode;
    let p_query_country = country;
    let p_query_role = role;
    let p_query_active = active;
    let p_query_password = password;
    let p_query_retailer_location_ids = retailer_location_ids;
    let p_query_settings_app_key = settings_app_key;
    let p_query_app_blob = app_blob;
    let p_query_assigned_device_id = assigned_device_id;

    let uri_str = format!("{}/api/{version}/employee/update", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("employeeAccountId", &p_query_employee_account_id.to_string())]);
    if let Some(ref param_value) = p_query_manager_account_id {
        req_builder = req_builder.query(&[("managerAccountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_prefix_name {
        req_builder = req_builder.query(&[("prefixName", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_first_name {
        req_builder = req_builder.query(&[("firstName", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_middle_name {
        req_builder = req_builder.query(&[("middleName", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_last_name {
        req_builder = req_builder.query(&[("lastName", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_suffix_name {
        req_builder = req_builder.query(&[("suffixName", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_title {
        req_builder = req_builder.query(&[("title", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_asset_id {
        req_builder = req_builder.query(&[("assetId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_gender {
        req_builder = req_builder.query(&[("gender", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_home_phone {
        req_builder = req_builder.query(&[("homePhone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cell_phone {
        req_builder = req_builder.query(&[("cellPhone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cell_phone_carrier {
        req_builder = req_builder.query(&[("cellPhoneCarrier", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_business_phone {
        req_builder = req_builder.query(&[("businessPhone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_email_address {
        req_builder = req_builder.query(&[("emailAddress", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_street_address {
        req_builder = req_builder.query(&[("streetAddress", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_street_address2 {
        req_builder = req_builder.query(&[("streetAddress2", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_city {
        req_builder = req_builder.query(&[("city", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_state {
        req_builder = req_builder.query(&[("state", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_zipcode {
        req_builder = req_builder.query(&[("zipcode", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_role {
        req_builder = req_builder.query(&[("role", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_active {
        req_builder = req_builder.query(&[("active", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_password {
        req_builder = req_builder.query(&[("password", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_retailer_location_ids {
        req_builder = req_builder.query(&[("retailerLocationIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_settings_app_key {
        req_builder = req_builder.query(&[("settingsAppKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_blob {
        req_builder = req_builder.query(&[("appBlob", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_assigned_device_id {
        req_builder = req_builder.query(&[("assignedDeviceId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EmployeeResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EmployeeResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateEmployeeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

