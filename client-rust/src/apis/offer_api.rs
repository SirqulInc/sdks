/*
 * Sirqul IoT Platform
 *
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`batch_update_offer_locations`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BatchUpdateOfferLocationsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_offer`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateOfferError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_offer`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteOfferError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_offer_location`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteOfferLocationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_offer`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetOfferError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_offer_details`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetOfferDetailsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_offer_list_counts`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetOfferListCountsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_offer_location`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetOfferLocationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_offer_locations_for_retailers`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetOfferLocationsForRetailersError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_offers_for_retailers`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetOffersForRetailersError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`redeem_offer_transaction`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RedeemOfferTransactionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_offer_transactions_for_retailers`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchOfferTransactionsForRetailersError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_offers_for_consumer`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchOffersForConsumerError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`top_offer_transactions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TopOfferTransactionsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_offer`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateOfferError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_offer_status`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateOfferStatusError {
    UnknownValue(serde_json::Value),
}


/// Batch update offer locations.
pub async fn batch_update_offer_locations(configuration: &configuration::Configuration, version: f64, data: &str, device_id: Option<&str>, account_id: Option<i64>) -> Result<models::SirqulResponse, Error<BatchUpdateOfferLocationsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_data = data;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;

    let uri_str = format!("{}/api/{version}/retailer/offer/location/batchUpdate", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("data", &p_query_data.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SirqulResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SirqulResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BatchUpdateOfferLocationsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create an offer and assign it to the provided retailer locations.
pub async fn create_offer(configuration: &configuration::Configuration, version: f64, include_offer_locations: bool, title: &str, barcode_type: &str, no_expiration: bool, available_limit: i32, available_limit_per_user: i32, added_limit: i32, view_limit: i32, max_prints: i32, ticket_price: i64, full_price: f64, discount_price: f64, offer_type: &str, special_offer_type: &str, offer_visibility: &str, active: bool, device_id: Option<&str>, account_id: Option<i64>, tags: Option<&str>, parent_offer_id: Option<i64>, retailer_location_ids: Option<&str>, offer_locations: Option<&str>, sub_title: Option<&str>, details: Option<&str>, sub_details: Option<&str>, fine_print: Option<&str>, barcode_entry: Option<&str>, external_redeem_options: Option<&str>, external_url: Option<&str>, external_id: Option<&str>, tickets_reward_type: Option<&str>, tickets_reward: Option<i64>, activated: Option<i64>, expires: Option<i64>, ticket_price_type: Option<&str>, show_remaining: Option<bool>, show_redeemed: Option<bool>, replaced: Option<bool>, featured: Option<bool>, category_ids: Option<&str>, filter_ids: Option<&str>, barcode_asset_id: Option<i64>, image_asset_id: Option<i64>, image_asset_id1: Option<i64>, image_asset_id2: Option<i64>, image_asset_id3: Option<i64>, image_asset_id4: Option<i64>, image_asset_id5: Option<i64>, publisher: Option<&str>, redeemable_start: Option<i64>, redeemable_end: Option<i64>, brand: Option<&str>, product_type: Option<&str>, condition_type: Option<&str>, isbn: Option<&str>, asin: Option<&str>, catalog_numbers: Option<&str>, department: Option<&str>, features: Option<&str>, minimum_price: Option<f64>, width: Option<f64>, height: Option<f64>, depth: Option<f64>, weight: Option<f64>, unit: Option<&str>, studio: Option<&str>, parental_rating: Option<&str>, publish_date: Option<i64>, availability_date: Option<i64>, size_id: Option<i64>, listing_id: Option<i64>, media_type: Option<&str>, duration: Option<i32>, author: Option<&str>, release_date: Option<i64>, collection_ids: Option<&str>, reboot_time_hour: Option<i32>, reboot_time_minute: Option<i32>, idle_timeout_in_second: Option<i32>, serial_number: Option<&str>, udid: Option<&str>, device_type: Option<&str>, device_power: Option<f64>, device_interference: Option<f64>, availability: Option<&str>, availability_summary: Option<&str>) -> Result<models::RetailerOfferResponse, Error<CreateOfferError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_include_offer_locations = include_offer_locations;
    let p_query_title = title;
    let p_query_barcode_type = barcode_type;
    let p_query_no_expiration = no_expiration;
    let p_query_available_limit = available_limit;
    let p_query_available_limit_per_user = available_limit_per_user;
    let p_query_added_limit = added_limit;
    let p_query_view_limit = view_limit;
    let p_query_max_prints = max_prints;
    let p_query_ticket_price = ticket_price;
    let p_query_full_price = full_price;
    let p_query_discount_price = discount_price;
    let p_query_offer_type = offer_type;
    let p_query_special_offer_type = special_offer_type;
    let p_query_offer_visibility = offer_visibility;
    let p_query_active = active;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_tags = tags;
    let p_query_parent_offer_id = parent_offer_id;
    let p_query_retailer_location_ids = retailer_location_ids;
    let p_query_offer_locations = offer_locations;
    let p_query_sub_title = sub_title;
    let p_query_details = details;
    let p_query_sub_details = sub_details;
    let p_query_fine_print = fine_print;
    let p_query_barcode_entry = barcode_entry;
    let p_query_external_redeem_options = external_redeem_options;
    let p_query_external_url = external_url;
    let p_query_external_id = external_id;
    let p_query_tickets_reward_type = tickets_reward_type;
    let p_query_tickets_reward = tickets_reward;
    let p_query_activated = activated;
    let p_query_expires = expires;
    let p_query_ticket_price_type = ticket_price_type;
    let p_query_show_remaining = show_remaining;
    let p_query_show_redeemed = show_redeemed;
    let p_query_replaced = replaced;
    let p_query_featured = featured;
    let p_query_category_ids = category_ids;
    let p_query_filter_ids = filter_ids;
    let p_query_barcode_asset_id = barcode_asset_id;
    let p_query_image_asset_id = image_asset_id;
    let p_query_image_asset_id1 = image_asset_id1;
    let p_query_image_asset_id2 = image_asset_id2;
    let p_query_image_asset_id3 = image_asset_id3;
    let p_query_image_asset_id4 = image_asset_id4;
    let p_query_image_asset_id5 = image_asset_id5;
    let p_query_publisher = publisher;
    let p_query_redeemable_start = redeemable_start;
    let p_query_redeemable_end = redeemable_end;
    let p_query_brand = brand;
    let p_query_product_type = product_type;
    let p_query_condition_type = condition_type;
    let p_query_isbn = isbn;
    let p_query_asin = asin;
    let p_query_catalog_numbers = catalog_numbers;
    let p_query_department = department;
    let p_query_features = features;
    let p_query_minimum_price = minimum_price;
    let p_query_width = width;
    let p_query_height = height;
    let p_query_depth = depth;
    let p_query_weight = weight;
    let p_query_unit = unit;
    let p_query_studio = studio;
    let p_query_parental_rating = parental_rating;
    let p_query_publish_date = publish_date;
    let p_query_availability_date = availability_date;
    let p_query_size_id = size_id;
    let p_query_listing_id = listing_id;
    let p_query_media_type = media_type;
    let p_query_duration = duration;
    let p_query_author = author;
    let p_query_release_date = release_date;
    let p_query_collection_ids = collection_ids;
    let p_query_reboot_time_hour = reboot_time_hour;
    let p_query_reboot_time_minute = reboot_time_minute;
    let p_query_idle_timeout_in_second = idle_timeout_in_second;
    let p_query_serial_number = serial_number;
    let p_query_udid = udid;
    let p_query_device_type = device_type;
    let p_query_device_power = device_power;
    let p_query_device_interference = device_interference;
    let p_query_availability = availability;
    let p_query_availability_summary = availability_summary;

    let uri_str = format!("{}/api/{version}/retailer/offer/create", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_tags {
        req_builder = req_builder.query(&[("tags", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_parent_offer_id {
        req_builder = req_builder.query(&[("parentOfferId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("includeOfferLocations", &p_query_include_offer_locations.to_string())]);
    if let Some(ref param_value) = p_query_retailer_location_ids {
        req_builder = req_builder.query(&[("retailerLocationIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offer_locations {
        req_builder = req_builder.query(&[("offerLocations", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("title", &p_query_title.to_string())]);
    if let Some(ref param_value) = p_query_sub_title {
        req_builder = req_builder.query(&[("subTitle", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_details {
        req_builder = req_builder.query(&[("details", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sub_details {
        req_builder = req_builder.query(&[("subDetails", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_fine_print {
        req_builder = req_builder.query(&[("finePrint", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("barcodeType", &p_query_barcode_type.to_string())]);
    if let Some(ref param_value) = p_query_barcode_entry {
        req_builder = req_builder.query(&[("barcodeEntry", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_external_redeem_options {
        req_builder = req_builder.query(&[("externalRedeemOptions", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_external_url {
        req_builder = req_builder.query(&[("externalUrl", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_external_id {
        req_builder = req_builder.query(&[("externalId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_tickets_reward_type {
        req_builder = req_builder.query(&[("ticketsRewardType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_tickets_reward {
        req_builder = req_builder.query(&[("ticketsReward", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_activated {
        req_builder = req_builder.query(&[("activated", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_expires {
        req_builder = req_builder.query(&[("expires", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("noExpiration", &p_query_no_expiration.to_string())]);
    req_builder = req_builder.query(&[("availableLimit", &p_query_available_limit.to_string())]);
    req_builder = req_builder.query(&[("availableLimitPerUser", &p_query_available_limit_per_user.to_string())]);
    req_builder = req_builder.query(&[("addedLimit", &p_query_added_limit.to_string())]);
    req_builder = req_builder.query(&[("viewLimit", &p_query_view_limit.to_string())]);
    req_builder = req_builder.query(&[("maxPrints", &p_query_max_prints.to_string())]);
    if let Some(ref param_value) = p_query_ticket_price_type {
        req_builder = req_builder.query(&[("ticketPriceType", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("ticketPrice", &p_query_ticket_price.to_string())]);
    req_builder = req_builder.query(&[("fullPrice", &p_query_full_price.to_string())]);
    req_builder = req_builder.query(&[("discountPrice", &p_query_discount_price.to_string())]);
    if let Some(ref param_value) = p_query_show_remaining {
        req_builder = req_builder.query(&[("showRemaining", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_show_redeemed {
        req_builder = req_builder.query(&[("showRedeemed", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_replaced {
        req_builder = req_builder.query(&[("replaced", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_featured {
        req_builder = req_builder.query(&[("featured", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("offerType", &p_query_offer_type.to_string())]);
    req_builder = req_builder.query(&[("specialOfferType", &p_query_special_offer_type.to_string())]);
    req_builder = req_builder.query(&[("offerVisibility", &p_query_offer_visibility.to_string())]);
    if let Some(ref param_value) = p_query_category_ids {
        req_builder = req_builder.query(&[("categoryIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_ids {
        req_builder = req_builder.query(&[("filterIds", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("active", &p_query_active.to_string())]);
    if let Some(ref param_value) = p_query_barcode_asset_id {
        req_builder = req_builder.query(&[("barcodeAssetId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_image_asset_id {
        req_builder = req_builder.query(&[("imageAssetId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_image_asset_id1 {
        req_builder = req_builder.query(&[("imageAssetId1", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_image_asset_id2 {
        req_builder = req_builder.query(&[("imageAssetId2", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_image_asset_id3 {
        req_builder = req_builder.query(&[("imageAssetId3", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_image_asset_id4 {
        req_builder = req_builder.query(&[("imageAssetId4", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_image_asset_id5 {
        req_builder = req_builder.query(&[("imageAssetId5", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_publisher {
        req_builder = req_builder.query(&[("publisher", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_redeemable_start {
        req_builder = req_builder.query(&[("redeemableStart", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_redeemable_end {
        req_builder = req_builder.query(&[("redeemableEnd", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_brand {
        req_builder = req_builder.query(&[("brand", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_product_type {
        req_builder = req_builder.query(&[("productType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_condition_type {
        req_builder = req_builder.query(&[("conditionType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isbn {
        req_builder = req_builder.query(&[("isbn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_asin {
        req_builder = req_builder.query(&[("asin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_catalog_numbers {
        req_builder = req_builder.query(&[("catalogNumbers", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_department {
        req_builder = req_builder.query(&[("department", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_features {
        req_builder = req_builder.query(&[("features", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_minimum_price {
        req_builder = req_builder.query(&[("minimumPrice", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_width {
        req_builder = req_builder.query(&[("width", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_height {
        req_builder = req_builder.query(&[("height", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_depth {
        req_builder = req_builder.query(&[("depth", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_weight {
        req_builder = req_builder.query(&[("weight", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_unit {
        req_builder = req_builder.query(&[("unit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_studio {
        req_builder = req_builder.query(&[("studio", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_parental_rating {
        req_builder = req_builder.query(&[("parentalRating", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_publish_date {
        req_builder = req_builder.query(&[("publishDate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_availability_date {
        req_builder = req_builder.query(&[("availabilityDate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_size_id {
        req_builder = req_builder.query(&[("sizeId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_listing_id {
        req_builder = req_builder.query(&[("listingId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_media_type {
        req_builder = req_builder.query(&[("mediaType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_duration {
        req_builder = req_builder.query(&[("duration", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_author {
        req_builder = req_builder.query(&[("author", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_release_date {
        req_builder = req_builder.query(&[("releaseDate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_collection_ids {
        req_builder = req_builder.query(&[("collectionIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_reboot_time_hour {
        req_builder = req_builder.query(&[("rebootTimeHour", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_reboot_time_minute {
        req_builder = req_builder.query(&[("rebootTimeMinute", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_idle_timeout_in_second {
        req_builder = req_builder.query(&[("idleTimeoutInSecond", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_serial_number {
        req_builder = req_builder.query(&[("serialNumber", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_udid {
        req_builder = req_builder.query(&[("udid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_device_type {
        req_builder = req_builder.query(&[("deviceType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_device_power {
        req_builder = req_builder.query(&[("devicePower", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_device_interference {
        req_builder = req_builder.query(&[("deviceInterference", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_availability {
        req_builder = req_builder.query(&[("availability", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_availability_summary {
        req_builder = req_builder.query(&[("availabilitySummary", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RetailerOfferResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RetailerOfferResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateOfferError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Set the deleted timestamp to current time. This effectively deletes the offer since all queries should ignore any records with a deleted time stamp.
pub async fn delete_offer(configuration: &configuration::Configuration, version: f64, offer_id: i64, device_id: Option<&str>, account_id: Option<i64>) -> Result<models::SirqulResponse, Error<DeleteOfferError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_offer_id = offer_id;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;

    let uri_str = format!("{}/api/{version}/retailer/offer/delete", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("offerId", &p_query_offer_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SirqulResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SirqulResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteOfferError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Set the deleted timestamp to current time. This effectively deletes the offer location since all queries should ignore any records with a deleted time stamp.
pub async fn delete_offer_location(configuration: &configuration::Configuration, version: f64, offer_location_id: i64, device_id: Option<&str>, account_id: Option<i64>) -> Result<models::SirqulResponse, Error<DeleteOfferLocationError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_offer_location_id = offer_location_id;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;

    let uri_str = format!("{}/api/{version}/retailer/offer/location/delete", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("offerLocationId", &p_query_offer_location_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SirqulResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SirqulResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteOfferLocationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets the details of an offer that the user has access to.
pub async fn get_offer(configuration: &configuration::Configuration, version: f64, offer_id: i64, include_offer_locations: bool, device_id: Option<&str>, account_id: Option<i64>) -> Result<models::RetailerOfferResponse, Error<GetOfferError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_offer_id = offer_id;
    let p_query_include_offer_locations = include_offer_locations;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;

    let uri_str = format!("{}/api/{version}/retailer/offer/get", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("offerId", &p_query_offer_id.to_string())]);
    req_builder = req_builder.query(&[("includeOfferLocations", &p_query_include_offer_locations.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RetailerOfferResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RetailerOfferResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetOfferError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets offer or offer location details as a consumer.  Will check if it is a favorite if the deviceId/accountId is provided.  If the offerId is provided it will look up the main offer and ignore the the offerLocationId. If no offerId is provided then an offerLocationId must be specified.
pub async fn get_offer_details(configuration: &configuration::Configuration, version: f64, device_id: Option<&str>, account_id: Option<i64>, offer_id: Option<i64>, offer_location_id: Option<i64>, distance: Option<f64>, latitude: Option<f64>, longitude: Option<f64>, include_offer_locations: Option<bool>, include_retailer_locations: Option<bool>, include_child_offers: Option<bool>) -> Result<models::OfferResponse, Error<GetOfferDetailsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_offer_id = offer_id;
    let p_query_offer_location_id = offer_location_id;
    let p_query_distance = distance;
    let p_query_latitude = latitude;
    let p_query_longitude = longitude;
    let p_query_include_offer_locations = include_offer_locations;
    let p_query_include_retailer_locations = include_retailer_locations;
    let p_query_include_child_offers = include_child_offers;

    let uri_str = format!("{}/api/{version}/offer/get", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offer_id {
        req_builder = req_builder.query(&[("offerId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offer_location_id {
        req_builder = req_builder.query(&[("offerLocationId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_distance {
        req_builder = req_builder.query(&[("distance", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_latitude {
        req_builder = req_builder.query(&[("latitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_longitude {
        req_builder = req_builder.query(&[("longitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_offer_locations {
        req_builder = req_builder.query(&[("includeOfferLocations", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_retailer_locations {
        req_builder = req_builder.query(&[("includeRetailerLocations", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_child_offers {
        req_builder = req_builder.query(&[("includeChildOffers", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OfferResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OfferResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetOfferDetailsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets the offer list counts.
pub async fn get_offer_list_counts(configuration: &configuration::Configuration, version: f64, latitude: f64, longitude: f64, search_range: Option<f64>, distance_unit: Option<&str>) -> Result<models::ListCountResponse, Error<GetOfferListCountsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_latitude = latitude;
    let p_query_longitude = longitude;
    let p_query_search_range = search_range;
    let p_query_distance_unit = distance_unit;

    let uri_str = format!("{}/api/{version}/offer/lists/count", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("latitude", &p_query_latitude.to_string())]);
    req_builder = req_builder.query(&[("longitude", &p_query_longitude.to_string())]);
    if let Some(ref param_value) = p_query_search_range {
        req_builder = req_builder.query(&[("searchRange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_distance_unit {
        req_builder = req_builder.query(&[("distanceUnit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ListCountResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ListCountResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetOfferListCountsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets the offer location by offer location id or udid (of a device)
pub async fn get_offer_location(configuration: &configuration::Configuration, version: f64, offer_location_id: Option<i64>, udid: Option<&str>) -> Result<models::OfferShortResponse, Error<GetOfferLocationError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_offer_location_id = offer_location_id;
    let p_query_udid = udid;

    let uri_str = format!("{}/api/{version}/offer/location/get", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_offer_location_id {
        req_builder = req_builder.query(&[("offerLocationId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_udid {
        req_builder = req_builder.query(&[("udid", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OfferShortResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OfferShortResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetOfferLocationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Searches on offer locations, which are records that represent an offer that has been assigned to a retailer location. If an offer does not have any locations assigned, then it will NOT be returned.
pub async fn get_offer_locations_for_retailers(configuration: &configuration::Configuration, version: f64, sort_field: &str, descending: bool, start: i32, limit: i32, active_only: bool, include_retailer_location: bool, device_id: Option<&str>, account_id: Option<i64>, keyword: Option<&str>, retailer_id: Option<i64>, retailer_location_id: Option<i64>, offer_type: Option<&str>, special_offer_type: Option<&str>, barcode_type: Option<&str>, barcode_entry: Option<&str>, isbn: Option<&str>, asin: Option<&str>, device_status: Option<&str>, needs_notification_sent: Option<bool>, last_notification_sent: Option<i64>) -> Result<Vec<models::OfferShortResponse>, Error<GetOfferLocationsForRetailersError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_sort_field = sort_field;
    let p_query_descending = descending;
    let p_query_start = start;
    let p_query_limit = limit;
    let p_query_active_only = active_only;
    let p_query_include_retailer_location = include_retailer_location;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_keyword = keyword;
    let p_query_retailer_id = retailer_id;
    let p_query_retailer_location_id = retailer_location_id;
    let p_query_offer_type = offer_type;
    let p_query_special_offer_type = special_offer_type;
    let p_query_barcode_type = barcode_type;
    let p_query_barcode_entry = barcode_entry;
    let p_query_isbn = isbn;
    let p_query_asin = asin;
    let p_query_device_status = device_status;
    let p_query_needs_notification_sent = needs_notification_sent;
    let p_query_last_notification_sent = last_notification_sent;

    let uri_str = format!("{}/api/{version}/retailer/offer/location/search", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_keyword {
        req_builder = req_builder.query(&[("keyword", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_retailer_id {
        req_builder = req_builder.query(&[("retailerId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_retailer_location_id {
        req_builder = req_builder.query(&[("retailerLocationId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offer_type {
        req_builder = req_builder.query(&[("offerType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_special_offer_type {
        req_builder = req_builder.query(&[("specialOfferType", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("sortField", &p_query_sort_field.to_string())]);
    req_builder = req_builder.query(&[("descending", &p_query_descending.to_string())]);
    req_builder = req_builder.query(&[("start", &p_query_start.to_string())]);
    req_builder = req_builder.query(&[("limit", &p_query_limit.to_string())]);
    req_builder = req_builder.query(&[("activeOnly", &p_query_active_only.to_string())]);
    req_builder = req_builder.query(&[("includeRetailerLocation", &p_query_include_retailer_location.to_string())]);
    if let Some(ref param_value) = p_query_barcode_type {
        req_builder = req_builder.query(&[("barcodeType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_barcode_entry {
        req_builder = req_builder.query(&[("barcodeEntry", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isbn {
        req_builder = req_builder.query(&[("isbn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_asin {
        req_builder = req_builder.query(&[("asin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_device_status {
        req_builder = req_builder.query(&[("deviceStatus", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_needs_notification_sent {
        req_builder = req_builder.query(&[("needsNotificationSent", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_last_notification_sent {
        req_builder = req_builder.query(&[("lastNotificationSent", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::OfferShortResponse&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::OfferShortResponse&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetOfferLocationsForRetailersError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Searches on offers that the account has access to.
pub async fn get_offers_for_retailers(configuration: &configuration::Configuration, version: f64, offer_visibility: &str, sort_field: &str, descending: bool, start: i32, limit: i32, available_only: bool, active_only: bool, include_categories: bool, include_filters: bool, include_offer_locations: bool, device_id: Option<&str>, account_id: Option<i64>, category_ids: Option<&str>, filter_ids: Option<&str>, q: Option<&str>, keyword: Option<&str>, retailer_id: Option<i64>, retailer_location_id: Option<i64>, coupon_type: Option<&str>, offer_type: Option<&str>, offer_types: Option<&str>, special_offer_type: Option<&str>, _i: Option<i32>, _l: Option<i32>, barcode_type: Option<&str>, barcode_entry: Option<&str>, isbn: Option<&str>, asin: Option<&str>, device_status: Option<&str>, needs_notification_sent: Option<bool>, last_notification_sent: Option<i64>) -> Result<Vec<models::OfferResponse>, Error<GetOffersForRetailersError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_offer_visibility = offer_visibility;
    let p_query_sort_field = sort_field;
    let p_query_descending = descending;
    let p_query_start = start;
    let p_query_limit = limit;
    let p_query_available_only = available_only;
    let p_query_active_only = active_only;
    let p_query_include_categories = include_categories;
    let p_query_include_filters = include_filters;
    let p_query_include_offer_locations = include_offer_locations;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_category_ids = category_ids;
    let p_query_filter_ids = filter_ids;
    let p_query_q = q;
    let p_query_keyword = keyword;
    let p_query_retailer_id = retailer_id;
    let p_query_retailer_location_id = retailer_location_id;
    let p_query_coupon_type = coupon_type;
    let p_query_offer_type = offer_type;
    let p_query_offer_types = offer_types;
    let p_query_special_offer_type = special_offer_type;
    let p_query__i = _i;
    let p_query__l = _l;
    let p_query_barcode_type = barcode_type;
    let p_query_barcode_entry = barcode_entry;
    let p_query_isbn = isbn;
    let p_query_asin = asin;
    let p_query_device_status = device_status;
    let p_query_needs_notification_sent = needs_notification_sent;
    let p_query_last_notification_sent = last_notification_sent;

    let uri_str = format!("{}/api/{version}/retailer/offer/search", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_category_ids {
        req_builder = req_builder.query(&[("categoryIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_ids {
        req_builder = req_builder.query(&[("filterIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_q {
        req_builder = req_builder.query(&[("q", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_keyword {
        req_builder = req_builder.query(&[("keyword", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_retailer_id {
        req_builder = req_builder.query(&[("retailerId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_retailer_location_id {
        req_builder = req_builder.query(&[("retailerLocationId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_coupon_type {
        req_builder = req_builder.query(&[("couponType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offer_type {
        req_builder = req_builder.query(&[("offerType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offer_types {
        req_builder = req_builder.query(&[("offerTypes", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_special_offer_type {
        req_builder = req_builder.query(&[("specialOfferType", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("offerVisibility", &p_query_offer_visibility.to_string())]);
    req_builder = req_builder.query(&[("sortField", &p_query_sort_field.to_string())]);
    req_builder = req_builder.query(&[("descending", &p_query_descending.to_string())]);
    if let Some(ref param_value) = p_query__i {
        req_builder = req_builder.query(&[("_i", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("start", &p_query_start.to_string())]);
    if let Some(ref param_value) = p_query__l {
        req_builder = req_builder.query(&[("_l", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("limit", &p_query_limit.to_string())]);
    req_builder = req_builder.query(&[("availableOnly", &p_query_available_only.to_string())]);
    req_builder = req_builder.query(&[("activeOnly", &p_query_active_only.to_string())]);
    req_builder = req_builder.query(&[("includeCategories", &p_query_include_categories.to_string())]);
    req_builder = req_builder.query(&[("includeFilters", &p_query_include_filters.to_string())]);
    req_builder = req_builder.query(&[("includeOfferLocations", &p_query_include_offer_locations.to_string())]);
    if let Some(ref param_value) = p_query_barcode_type {
        req_builder = req_builder.query(&[("barcodeType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_barcode_entry {
        req_builder = req_builder.query(&[("barcodeEntry", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isbn {
        req_builder = req_builder.query(&[("isbn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_asin {
        req_builder = req_builder.query(&[("asin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_device_status {
        req_builder = req_builder.query(&[("deviceStatus", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_needs_notification_sent {
        req_builder = req_builder.query(&[("needsNotificationSent", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_last_notification_sent {
        req_builder = req_builder.query(&[("lastNotificationSent", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::OfferResponse&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::OfferResponse&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetOffersForRetailersError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Redeems an offer.
pub async fn redeem_offer_transaction(configuration: &configuration::Configuration, version: f64, offer_transaction_id: i64, status: i32, device_id: Option<&str>, account_id: Option<i64>, offer_location_id: Option<i64>) -> Result<models::SirqulResponse, Error<RedeemOfferTransactionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_offer_transaction_id = offer_transaction_id;
    let p_query_status = status;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_offer_location_id = offer_location_id;

    let uri_str = format!("{}/api/{version}/retailer/offer/transaction/update", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("offerTransactionId", &p_query_offer_transaction_id.to_string())]);
    if let Some(ref param_value) = p_query_offer_location_id {
        req_builder = req_builder.query(&[("offerLocationId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("status", &p_query_status.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SirqulResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SirqulResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RedeemOfferTransactionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Searches on offer transactions for offers that the account has access to.
pub async fn search_offer_transactions_for_retailers(configuration: &configuration::Configuration, version: f64, sort_field: &str, descending: bool, start: i32, limit: i32, active_only: bool, device_id: Option<&str>, account_id: Option<i64>, q: Option<&str>, keyword: Option<&str>, retailer_id: Option<i64>, retailer_location_id: Option<i64>, offer_id: Option<i64>, offer_location_id: Option<i64>, redeemed: Option<bool>, reservations_only: Option<bool>, coupon_type: Option<&str>, offer_type: Option<&str>, special_offer_type: Option<&str>, customer_account_ids: Option<&str>, category_ids: Option<&str>, redeemable_start_date: Option<i64>, redeemable_end_date: Option<i64>, _i: Option<i32>, _l: Option<i32>) -> Result<Vec<models::OfferTransactionResponse>, Error<SearchOfferTransactionsForRetailersError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_sort_field = sort_field;
    let p_query_descending = descending;
    let p_query_start = start;
    let p_query_limit = limit;
    let p_query_active_only = active_only;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_q = q;
    let p_query_keyword = keyword;
    let p_query_retailer_id = retailer_id;
    let p_query_retailer_location_id = retailer_location_id;
    let p_query_offer_id = offer_id;
    let p_query_offer_location_id = offer_location_id;
    let p_query_redeemed = redeemed;
    let p_query_reservations_only = reservations_only;
    let p_query_coupon_type = coupon_type;
    let p_query_offer_type = offer_type;
    let p_query_special_offer_type = special_offer_type;
    let p_query_customer_account_ids = customer_account_ids;
    let p_query_category_ids = category_ids;
    let p_query_redeemable_start_date = redeemable_start_date;
    let p_query_redeemable_end_date = redeemable_end_date;
    let p_query__i = _i;
    let p_query__l = _l;

    let uri_str = format!("{}/api/{version}/retailer/offer/transaction/search", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_q {
        req_builder = req_builder.query(&[("q", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_keyword {
        req_builder = req_builder.query(&[("keyword", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_retailer_id {
        req_builder = req_builder.query(&[("retailerId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_retailer_location_id {
        req_builder = req_builder.query(&[("retailerLocationId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offer_id {
        req_builder = req_builder.query(&[("offerId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offer_location_id {
        req_builder = req_builder.query(&[("offerLocationId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_redeemed {
        req_builder = req_builder.query(&[("redeemed", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_reservations_only {
        req_builder = req_builder.query(&[("reservationsOnly", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_coupon_type {
        req_builder = req_builder.query(&[("couponType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offer_type {
        req_builder = req_builder.query(&[("offerType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_special_offer_type {
        req_builder = req_builder.query(&[("specialOfferType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_customer_account_ids {
        req_builder = req_builder.query(&[("customerAccountIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_category_ids {
        req_builder = req_builder.query(&[("categoryIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_redeemable_start_date {
        req_builder = req_builder.query(&[("redeemableStartDate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_redeemable_end_date {
        req_builder = req_builder.query(&[("redeemableEndDate", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("sortField", &p_query_sort_field.to_string())]);
    req_builder = req_builder.query(&[("descending", &p_query_descending.to_string())]);
    if let Some(ref param_value) = p_query__i {
        req_builder = req_builder.query(&[("_i", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("start", &p_query_start.to_string())]);
    if let Some(ref param_value) = p_query__l {
        req_builder = req_builder.query(&[("_l", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("limit", &p_query_limit.to_string())]);
    req_builder = req_builder.query(&[("activeOnly", &p_query_active_only.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::OfferTransactionResponse&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::OfferTransactionResponse&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchOfferTransactionsForRetailersError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Searches for offers as a consumer.
pub async fn search_offers_for_consumer(configuration: &configuration::Configuration, version: f64, latitude: f64, longitude: f64, recommendation_type: &str, location_id: i64, start: i32, limit: i32, max_recommendations: i32, distance_unit: &str, app_key: Option<&str>, device_id: Option<&str>, account_id: Option<i64>, search_range: Option<f64>, tags: Option<&str>, supported_postal_codes: Option<&str>, keyword: Option<&str>, categories: Option<&str>, filters: Option<&str>, offer_types: Option<&str>, r#type: Option<&str>, sort_field: Option<&str>, recommend_offer_ids: Option<&str>, retailer_location_ids: Option<&str>, offer_id: Option<i64>, include_mission: Option<bool>, include_categories: Option<bool>, include_filters: Option<bool>, include_expired: Option<bool>, include_favorite: Option<bool>, closest_offer_only: Option<bool>, search_expression: Option<&str>, group_by: Option<&str>) -> Result<models::OfferListResponse, Error<SearchOffersForConsumerError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_latitude = latitude;
    let p_query_longitude = longitude;
    let p_query_recommendation_type = recommendation_type;
    let p_query_location_id = location_id;
    let p_query_start = start;
    let p_query_limit = limit;
    let p_query_max_recommendations = max_recommendations;
    let p_query_distance_unit = distance_unit;
    let p_query_app_key = app_key;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_search_range = search_range;
    let p_query_tags = tags;
    let p_query_supported_postal_codes = supported_postal_codes;
    let p_query_keyword = keyword;
    let p_query_categories = categories;
    let p_query_filters = filters;
    let p_query_offer_types = offer_types;
    let p_query_type = r#type;
    let p_query_sort_field = sort_field;
    let p_query_recommend_offer_ids = recommend_offer_ids;
    let p_query_retailer_location_ids = retailer_location_ids;
    let p_query_offer_id = offer_id;
    let p_query_include_mission = include_mission;
    let p_query_include_categories = include_categories;
    let p_query_include_filters = include_filters;
    let p_query_include_expired = include_expired;
    let p_query_include_favorite = include_favorite;
    let p_query_closest_offer_only = closest_offer_only;
    let p_query_search_expression = search_expression;
    let p_query_group_by = group_by;

    let uri_str = format!("{}/api/{version}/offer/lists", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_app_key {
        req_builder = req_builder.query(&[("appKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("latitude", &p_query_latitude.to_string())]);
    req_builder = req_builder.query(&[("longitude", &p_query_longitude.to_string())]);
    if let Some(ref param_value) = p_query_search_range {
        req_builder = req_builder.query(&[("searchRange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_tags {
        req_builder = req_builder.query(&[("tags", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_supported_postal_codes {
        req_builder = req_builder.query(&[("supportedPostalCodes", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_keyword {
        req_builder = req_builder.query(&[("keyword", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_categories {
        req_builder = req_builder.query(&[("categories", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filters {
        req_builder = req_builder.query(&[("filters", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offer_types {
        req_builder = req_builder.query(&[("offerTypes", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_field {
        req_builder = req_builder.query(&[("sortField", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_recommend_offer_ids {
        req_builder = req_builder.query(&[("recommendOfferIds", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("recommendationType", &p_query_recommendation_type.to_string())]);
    req_builder = req_builder.query(&[("locationId", &p_query_location_id.to_string())]);
    if let Some(ref param_value) = p_query_retailer_location_ids {
        req_builder = req_builder.query(&[("retailerLocationIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offer_id {
        req_builder = req_builder.query(&[("offerId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_mission {
        req_builder = req_builder.query(&[("includeMission", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_categories {
        req_builder = req_builder.query(&[("includeCategories", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_filters {
        req_builder = req_builder.query(&[("includeFilters", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_expired {
        req_builder = req_builder.query(&[("includeExpired", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_favorite {
        req_builder = req_builder.query(&[("includeFavorite", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("start", &p_query_start.to_string())]);
    req_builder = req_builder.query(&[("limit", &p_query_limit.to_string())]);
    req_builder = req_builder.query(&[("maxRecommendations", &p_query_max_recommendations.to_string())]);
    req_builder = req_builder.query(&[("distanceUnit", &p_query_distance_unit.to_string())]);
    if let Some(ref param_value) = p_query_closest_offer_only {
        req_builder = req_builder.query(&[("closestOfferOnly", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search_expression {
        req_builder = req_builder.query(&[("searchExpression", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_group_by {
        req_builder = req_builder.query(&[("groupBy", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OfferListResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OfferListResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchOffersForConsumerError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets the top active offers.
pub async fn top_offer_transactions(configuration: &configuration::Configuration, version: f64, start: Option<i32>, limit: Option<i32>) -> Result<models::OfferListResponse, Error<TopOfferTransactionsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_start = start;
    let p_query_limit = limit;

    let uri_str = format!("{}/api/{version}/offer/top", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_start {
        req_builder = req_builder.query(&[("start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OfferListResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OfferListResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TopOfferTransactionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update an offer, must provide a current list of retailer locations or the current offer locations will be marked as deleted.
pub async fn update_offer(configuration: &configuration::Configuration, version: f64, offer_id: i64, include_offer_locations: bool, device_id: Option<&str>, account_id: Option<i64>, parent_offer_id: Option<i64>, retailer_location_ids: Option<&str>, offer_locations: Option<&str>, tags: Option<&str>, title: Option<&str>, sub_title: Option<&str>, details: Option<&str>, sub_details: Option<&str>, fine_print: Option<&str>, barcode_type: Option<&str>, barcode_entry: Option<&str>, external_redeem_options: Option<&str>, external_url: Option<&str>, external_id: Option<&str>, tickets_reward_type: Option<&str>, tickets_reward: Option<i64>, activated: Option<i64>, expires: Option<i64>, no_expiration: Option<bool>, available_limit: Option<i32>, available_limit_per_user: Option<i32>, added_limit: Option<i32>, view_limit: Option<i32>, max_prints: Option<i32>, ticket_price_type: Option<&str>, ticket_price: Option<i64>, full_price: Option<f64>, discount_price: Option<f64>, show_remaining: Option<bool>, show_redeemed: Option<bool>, replaced: Option<bool>, featured: Option<bool>, offer_type: Option<&str>, special_offer_type: Option<&str>, offer_visibility: Option<&str>, category_ids: Option<&str>, filter_ids: Option<&str>, active: Option<bool>, barcode_asset_id: Option<i64>, image_asset_id: Option<i64>, image_asset_id1: Option<i64>, image_asset_id2: Option<i64>, image_asset_id3: Option<i64>, image_asset_id4: Option<i64>, image_asset_id5: Option<i64>, publisher: Option<&str>, redeemable_start: Option<i64>, redeemable_end: Option<i64>, brand: Option<&str>, product_type: Option<&str>, condition_type: Option<&str>, isbn: Option<&str>, asin: Option<&str>, catalog_numbers: Option<&str>, department: Option<&str>, features: Option<&str>, minimum_price: Option<f64>, width: Option<f64>, height: Option<f64>, depth: Option<f64>, weight: Option<f64>, unit: Option<&str>, studio: Option<&str>, parental_rating: Option<&str>, publish_date: Option<i64>, availability_date: Option<i64>, size_id: Option<i64>, listing_id: Option<i64>, media_type: Option<&str>, duration: Option<i32>, author: Option<&str>, release_date: Option<i64>, collection_ids: Option<&str>, reboot_time_hour: Option<i32>, reboot_time_minute: Option<i32>, idle_timeout_in_second: Option<i32>, serial_number: Option<&str>, udid: Option<&str>, device_type: Option<&str>, device_power: Option<f64>, device_interference: Option<f64>, availability: Option<&str>, availability_summary: Option<&str>) -> Result<models::RetailerOfferResponse, Error<UpdateOfferError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_offer_id = offer_id;
    let p_query_include_offer_locations = include_offer_locations;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_parent_offer_id = parent_offer_id;
    let p_query_retailer_location_ids = retailer_location_ids;
    let p_query_offer_locations = offer_locations;
    let p_query_tags = tags;
    let p_query_title = title;
    let p_query_sub_title = sub_title;
    let p_query_details = details;
    let p_query_sub_details = sub_details;
    let p_query_fine_print = fine_print;
    let p_query_barcode_type = barcode_type;
    let p_query_barcode_entry = barcode_entry;
    let p_query_external_redeem_options = external_redeem_options;
    let p_query_external_url = external_url;
    let p_query_external_id = external_id;
    let p_query_tickets_reward_type = tickets_reward_type;
    let p_query_tickets_reward = tickets_reward;
    let p_query_activated = activated;
    let p_query_expires = expires;
    let p_query_no_expiration = no_expiration;
    let p_query_available_limit = available_limit;
    let p_query_available_limit_per_user = available_limit_per_user;
    let p_query_added_limit = added_limit;
    let p_query_view_limit = view_limit;
    let p_query_max_prints = max_prints;
    let p_query_ticket_price_type = ticket_price_type;
    let p_query_ticket_price = ticket_price;
    let p_query_full_price = full_price;
    let p_query_discount_price = discount_price;
    let p_query_show_remaining = show_remaining;
    let p_query_show_redeemed = show_redeemed;
    let p_query_replaced = replaced;
    let p_query_featured = featured;
    let p_query_offer_type = offer_type;
    let p_query_special_offer_type = special_offer_type;
    let p_query_offer_visibility = offer_visibility;
    let p_query_category_ids = category_ids;
    let p_query_filter_ids = filter_ids;
    let p_query_active = active;
    let p_query_barcode_asset_id = barcode_asset_id;
    let p_query_image_asset_id = image_asset_id;
    let p_query_image_asset_id1 = image_asset_id1;
    let p_query_image_asset_id2 = image_asset_id2;
    let p_query_image_asset_id3 = image_asset_id3;
    let p_query_image_asset_id4 = image_asset_id4;
    let p_query_image_asset_id5 = image_asset_id5;
    let p_query_publisher = publisher;
    let p_query_redeemable_start = redeemable_start;
    let p_query_redeemable_end = redeemable_end;
    let p_query_brand = brand;
    let p_query_product_type = product_type;
    let p_query_condition_type = condition_type;
    let p_query_isbn = isbn;
    let p_query_asin = asin;
    let p_query_catalog_numbers = catalog_numbers;
    let p_query_department = department;
    let p_query_features = features;
    let p_query_minimum_price = minimum_price;
    let p_query_width = width;
    let p_query_height = height;
    let p_query_depth = depth;
    let p_query_weight = weight;
    let p_query_unit = unit;
    let p_query_studio = studio;
    let p_query_parental_rating = parental_rating;
    let p_query_publish_date = publish_date;
    let p_query_availability_date = availability_date;
    let p_query_size_id = size_id;
    let p_query_listing_id = listing_id;
    let p_query_media_type = media_type;
    let p_query_duration = duration;
    let p_query_author = author;
    let p_query_release_date = release_date;
    let p_query_collection_ids = collection_ids;
    let p_query_reboot_time_hour = reboot_time_hour;
    let p_query_reboot_time_minute = reboot_time_minute;
    let p_query_idle_timeout_in_second = idle_timeout_in_second;
    let p_query_serial_number = serial_number;
    let p_query_udid = udid;
    let p_query_device_type = device_type;
    let p_query_device_power = device_power;
    let p_query_device_interference = device_interference;
    let p_query_availability = availability;
    let p_query_availability_summary = availability_summary;

    let uri_str = format!("{}/api/{version}/retailer/offer/update", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("offerId", &p_query_offer_id.to_string())]);
    if let Some(ref param_value) = p_query_parent_offer_id {
        req_builder = req_builder.query(&[("parentOfferId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("includeOfferLocations", &p_query_include_offer_locations.to_string())]);
    if let Some(ref param_value) = p_query_retailer_location_ids {
        req_builder = req_builder.query(&[("retailerLocationIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offer_locations {
        req_builder = req_builder.query(&[("offerLocations", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_tags {
        req_builder = req_builder.query(&[("tags", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_title {
        req_builder = req_builder.query(&[("title", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sub_title {
        req_builder = req_builder.query(&[("subTitle", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_details {
        req_builder = req_builder.query(&[("details", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sub_details {
        req_builder = req_builder.query(&[("subDetails", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_fine_print {
        req_builder = req_builder.query(&[("finePrint", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_barcode_type {
        req_builder = req_builder.query(&[("barcodeType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_barcode_entry {
        req_builder = req_builder.query(&[("barcodeEntry", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_external_redeem_options {
        req_builder = req_builder.query(&[("externalRedeemOptions", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_external_url {
        req_builder = req_builder.query(&[("externalUrl", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_external_id {
        req_builder = req_builder.query(&[("externalId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_tickets_reward_type {
        req_builder = req_builder.query(&[("ticketsRewardType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_tickets_reward {
        req_builder = req_builder.query(&[("ticketsReward", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_activated {
        req_builder = req_builder.query(&[("activated", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_expires {
        req_builder = req_builder.query(&[("expires", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_no_expiration {
        req_builder = req_builder.query(&[("noExpiration", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_available_limit {
        req_builder = req_builder.query(&[("availableLimit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_available_limit_per_user {
        req_builder = req_builder.query(&[("availableLimitPerUser", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_added_limit {
        req_builder = req_builder.query(&[("addedLimit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_view_limit {
        req_builder = req_builder.query(&[("viewLimit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_max_prints {
        req_builder = req_builder.query(&[("maxPrints", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ticket_price_type {
        req_builder = req_builder.query(&[("ticketPriceType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ticket_price {
        req_builder = req_builder.query(&[("ticketPrice", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_full_price {
        req_builder = req_builder.query(&[("fullPrice", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_discount_price {
        req_builder = req_builder.query(&[("discountPrice", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_show_remaining {
        req_builder = req_builder.query(&[("showRemaining", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_show_redeemed {
        req_builder = req_builder.query(&[("showRedeemed", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_replaced {
        req_builder = req_builder.query(&[("replaced", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_featured {
        req_builder = req_builder.query(&[("featured", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offer_type {
        req_builder = req_builder.query(&[("offerType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_special_offer_type {
        req_builder = req_builder.query(&[("specialOfferType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offer_visibility {
        req_builder = req_builder.query(&[("offerVisibility", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_category_ids {
        req_builder = req_builder.query(&[("categoryIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_ids {
        req_builder = req_builder.query(&[("filterIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_active {
        req_builder = req_builder.query(&[("active", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_barcode_asset_id {
        req_builder = req_builder.query(&[("barcodeAssetId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_image_asset_id {
        req_builder = req_builder.query(&[("imageAssetId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_image_asset_id1 {
        req_builder = req_builder.query(&[("imageAssetId1", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_image_asset_id2 {
        req_builder = req_builder.query(&[("imageAssetId2", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_image_asset_id3 {
        req_builder = req_builder.query(&[("imageAssetId3", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_image_asset_id4 {
        req_builder = req_builder.query(&[("imageAssetId4", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_image_asset_id5 {
        req_builder = req_builder.query(&[("imageAssetId5", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_publisher {
        req_builder = req_builder.query(&[("publisher", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_redeemable_start {
        req_builder = req_builder.query(&[("redeemableStart", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_redeemable_end {
        req_builder = req_builder.query(&[("redeemableEnd", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_brand {
        req_builder = req_builder.query(&[("brand", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_product_type {
        req_builder = req_builder.query(&[("productType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_condition_type {
        req_builder = req_builder.query(&[("conditionType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isbn {
        req_builder = req_builder.query(&[("isbn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_asin {
        req_builder = req_builder.query(&[("asin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_catalog_numbers {
        req_builder = req_builder.query(&[("catalogNumbers", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_department {
        req_builder = req_builder.query(&[("department", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_features {
        req_builder = req_builder.query(&[("features", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_minimum_price {
        req_builder = req_builder.query(&[("minimumPrice", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_width {
        req_builder = req_builder.query(&[("width", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_height {
        req_builder = req_builder.query(&[("height", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_depth {
        req_builder = req_builder.query(&[("depth", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_weight {
        req_builder = req_builder.query(&[("weight", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_unit {
        req_builder = req_builder.query(&[("unit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_studio {
        req_builder = req_builder.query(&[("studio", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_parental_rating {
        req_builder = req_builder.query(&[("parentalRating", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_publish_date {
        req_builder = req_builder.query(&[("publishDate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_availability_date {
        req_builder = req_builder.query(&[("availabilityDate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_size_id {
        req_builder = req_builder.query(&[("sizeId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_listing_id {
        req_builder = req_builder.query(&[("listingId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_media_type {
        req_builder = req_builder.query(&[("mediaType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_duration {
        req_builder = req_builder.query(&[("duration", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_author {
        req_builder = req_builder.query(&[("author", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_release_date {
        req_builder = req_builder.query(&[("releaseDate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_collection_ids {
        req_builder = req_builder.query(&[("collectionIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_reboot_time_hour {
        req_builder = req_builder.query(&[("rebootTimeHour", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_reboot_time_minute {
        req_builder = req_builder.query(&[("rebootTimeMinute", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_idle_timeout_in_second {
        req_builder = req_builder.query(&[("idleTimeoutInSecond", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_serial_number {
        req_builder = req_builder.query(&[("serialNumber", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_udid {
        req_builder = req_builder.query(&[("udid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_device_type {
        req_builder = req_builder.query(&[("deviceType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_device_power {
        req_builder = req_builder.query(&[("devicePower", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_device_interference {
        req_builder = req_builder.query(&[("deviceInterference", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_availability {
        req_builder = req_builder.query(&[("availability", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_availability_summary {
        req_builder = req_builder.query(&[("availabilitySummary", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RetailerOfferResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RetailerOfferResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateOfferError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Sets the activated date on offers. This will make offers visible for consumers.
pub async fn update_offer_status(configuration: &configuration::Configuration, version: f64, offer_ids: &str, active: bool, device_id: Option<&str>, account_id: Option<i64>) -> Result<models::SirqulResponse, Error<UpdateOfferStatusError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_offer_ids = offer_ids;
    let p_query_active = active;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;

    let uri_str = format!("{}/api/{version}/retailer/offer/status", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("offerIds", &p_query_offer_ids.to_string())]);
    req_builder = req_builder.query(&[("active", &p_query_active.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SirqulResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SirqulResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateOfferStatusError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

