/*
 * Sirqul IoT Platform
 *
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`add_movie`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddMovieError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ai_docs`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AiDocsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ai_find_images`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AiFindImagesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ai_tags`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AiTagsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ai_text`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AiTextError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`batch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BatchError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_instant_episode`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateInstantEpisodeError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_voice_canvas`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateVoiceCanvasError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`emotion`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EmotionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_add_movie_result`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAddMovieResultError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_batch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetBatchError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_emotion`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetEmotionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_episode_status`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetEpisodeStatusError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_render_status`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRenderStatusError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_stt`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSttError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_tech_tune`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTechTuneError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_topics`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTopicsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_tts`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTtsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_voice_canvas`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetVoiceCanvasError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`start_video_render`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StartVideoRenderError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stt`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SttError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`summarize_topics`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SummarizeTopicsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tech_tune`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TechTuneError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tts`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TtsError {
    UnknownValue(serde_json::Value),
}


/// Add a movie to be indexed for Topics. Indexing a movie analyses the content and incorporates it into the topics model for future /topics calls. This does not store the movie file long-term.
pub async fn add_movie(configuration: &configuration::Configuration, version: f64, account_id: i64, movie_name: &str, third_party_account_id: Option<&str>, tags: Option<&str>, file: Option<std::path::PathBuf>, url: Option<&str>, callback: Option<&str>) -> Result<models::OrsonAiAddMovieResponse, Error<AddMovieError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_account_id = account_id;
    let p_query_movie_name = movie_name;
    let p_query_third_party_account_id = third_party_account_id;
    let p_query_tags = tags;
    let p_query_file = file;
    let p_query_url = url;
    let p_query_callback = callback;

    let uri_str = format!("{}/api/{version}/orson/ai/addMovie", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    if let Some(ref param_value) = p_query_third_party_account_id {
        req_builder = req_builder.query(&[("thirdPartyAccountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_tags {
        req_builder = req_builder.query(&[("tags", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("movieName", &p_query_movie_name.to_string())]);
    if let Some(ref param_value) = p_query_file {
        req_builder = req_builder.query(&[("file", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_url {
        req_builder = req_builder.query(&[("url", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_callback {
        req_builder = req_builder.query(&[("callback", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrsonAiAddMovieResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrsonAiAddMovieResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AddMovieError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Takes in a text string representing one or more sentences and it returns a list of documents which are related to the provided document.
pub async fn ai_docs(configuration: &configuration::Configuration, version: f64, account_id: i64, doc: &str, return_topics: Option<bool>, limit: Option<i32>, offset: Option<i32>) -> Result<models::OrsonAiProtoResponse, Error<AiDocsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_account_id = account_id;
    let p_query_doc = doc;
    let p_query_return_topics = return_topics;
    let p_query_limit = limit;
    let p_query_offset = offset;

    let uri_str = format!("{}/api/{version}/orson/ai/docs", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("doc", &p_query_doc.to_string())]);
    if let Some(ref param_value) = p_query_return_topics {
        req_builder = req_builder.query(&[("return_topics", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrsonAiProtoResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrsonAiProtoResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AiDocsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns a list of URIs of images that match the text.
pub async fn ai_find_images(configuration: &configuration::Configuration, version: f64, account_id: i64, text: &str, parse_flag: Option<&str>, fetch_flag: Option<&str>, size: Option<&str>) -> Result<models::OrsonAiProtoResponse, Error<AiFindImagesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_account_id = account_id;
    let p_query_text = text;
    let p_query_parse_flag = parse_flag;
    let p_query_fetch_flag = fetch_flag;
    let p_query_size = size;

    let uri_str = format!("{}/api/{version}/orson/ai/img", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("text", &p_query_text.to_string())]);
    if let Some(ref param_value) = p_query_parse_flag {
        req_builder = req_builder.query(&[("parse_flag", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_fetch_flag {
        req_builder = req_builder.query(&[("fetch_flag", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_size {
        req_builder = req_builder.query(&[("size", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrsonAiProtoResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrsonAiProtoResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AiFindImagesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Search the tags column of user provided tags using this endpoint.
pub async fn ai_tags(configuration: &configuration::Configuration, version: f64, account_id: i64, tags: &str, conditional: Option<&str>, limit: Option<i32>, offset: Option<i32>) -> Result<models::OrsonAiProtoResponse, Error<AiTagsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_account_id = account_id;
    let p_query_tags = tags;
    let p_query_conditional = conditional;
    let p_query_limit = limit;
    let p_query_offset = offset;

    let uri_str = format!("{}/api/{version}/orson/ai/tags", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("tags", &p_query_tags.to_string())]);
    if let Some(ref param_value) = p_query_conditional {
        req_builder = req_builder.query(&[("conditional", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrsonAiProtoResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrsonAiProtoResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AiTagsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Search the movie text column of movie text using this endpoint.
pub async fn ai_text(configuration: &configuration::Configuration, version: f64, account_id: i64, terms: &str, conditional: Option<&str>, limit: Option<i32>, offset: Option<i32>) -> Result<models::OrsonAiProtoResponse, Error<AiTextError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_account_id = account_id;
    let p_query_terms = terms;
    let p_query_conditional = conditional;
    let p_query_limit = limit;
    let p_query_offset = offset;

    let uri_str = format!("{}/api/{version}/orson/ai/text", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("terms", &p_query_terms.to_string())]);
    if let Some(ref param_value) = p_query_conditional {
        req_builder = req_builder.query(&[("conditional", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrsonAiProtoResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrsonAiProtoResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AiTextError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Run several types of analysis on an audio or video file in a single API call, instead of calling several operations for the same file..
pub async fn batch(configuration: &configuration::Configuration, version: f64, account_id: i64, third_party_account_id: Option<&str>, limit: Option<i32>, operations: Option<&str>, file: Option<std::path::PathBuf>, url: Option<&str>, callback: Option<&str>) -> Result<models::OrsonAiBatchResponse, Error<BatchError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_account_id = account_id;
    let p_query_third_party_account_id = third_party_account_id;
    let p_query_limit = limit;
    let p_query_operations = operations;
    let p_query_file = file;
    let p_query_url = url;
    let p_query_callback = callback;

    let uri_str = format!("{}/api/{version}/orson/ai/batch", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    if let Some(ref param_value) = p_query_third_party_account_id {
        req_builder = req_builder.query(&[("thirdPartyAccountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_operations {
        req_builder = req_builder.query(&[("operations", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_file {
        req_builder = req_builder.query(&[("file", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_url {
        req_builder = req_builder.query(&[("url", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_callback {
        req_builder = req_builder.query(&[("callback", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrsonAiBatchResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrsonAiBatchResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BatchError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates an instant episode for a given StoryStrip by providing all necessary inputs, interview recordings, and pictures, kicking off a render immediately.
pub async fn create_instant_episode(configuration: &configuration::Configuration, version: f64, account_id: i64, data: &str) -> Result<models::OrsonEpisodeResponse, Error<CreateInstantEpisodeError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_account_id = account_id;
    let p_query_data = data;

    let uri_str = format!("{}/api/{version}/orson/stories/episodes/instant", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("data", &p_query_data.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrsonEpisodeResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrsonEpisodeResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateInstantEpisodeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create VoiceCanvas images for provided text, file upload, or file URL
pub async fn create_voice_canvas(configuration: &configuration::Configuration, version: f64, account_id: i64, dimensions: &str, third_party_account_id: Option<&str>, text: Option<&str>, file: Option<std::path::PathBuf>, url: Option<&str>, parse_flag: Option<bool>, fetch_flag: Option<bool>, callback: Option<&str>) -> Result<models::OrsonAiVoiceCanvasResponse, Error<CreateVoiceCanvasError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_account_id = account_id;
    let p_query_dimensions = dimensions;
    let p_query_third_party_account_id = third_party_account_id;
    let p_query_text = text;
    let p_query_file = file;
    let p_query_url = url;
    let p_query_parse_flag = parse_flag;
    let p_query_fetch_flag = fetch_flag;
    let p_query_callback = callback;

    let uri_str = format!("{}/api/{version}/orson/ai/voiceCanvas", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    if let Some(ref param_value) = p_query_third_party_account_id {
        req_builder = req_builder.query(&[("thirdPartyAccountId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("dimensions", &p_query_dimensions.to_string())]);
    if let Some(ref param_value) = p_query_text {
        req_builder = req_builder.query(&[("text", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_file {
        req_builder = req_builder.query(&[("file", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_url {
        req_builder = req_builder.query(&[("url", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_parse_flag {
        req_builder = req_builder.query(&[("parseFlag", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_fetch_flag {
        req_builder = req_builder.query(&[("fetchFlag", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_callback {
        req_builder = req_builder.query(&[("callback", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrsonAiVoiceCanvasResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrsonAiVoiceCanvasResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateVoiceCanvasError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Detects emotions in an audio or video recording.
pub async fn emotion(configuration: &configuration::Configuration, version: f64, account_id: i64, third_party_account_id: Option<&str>, file: Option<std::path::PathBuf>, url: Option<&str>, callback: Option<&str>) -> Result<models::OrsonAiEmotionsResponse, Error<EmotionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_account_id = account_id;
    let p_query_third_party_account_id = third_party_account_id;
    let p_query_file = file;
    let p_query_url = url;
    let p_query_callback = callback;

    let uri_str = format!("{}/api/{version}/orson/ai/emotion", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    if let Some(ref param_value) = p_query_third_party_account_id {
        req_builder = req_builder.query(&[("thirdPartyAccountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_file {
        req_builder = req_builder.query(&[("file", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_url {
        req_builder = req_builder.query(&[("url", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_callback {
        req_builder = req_builder.query(&[("callback", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrsonAiEmotionsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrsonAiEmotionsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EmotionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the result of an in progress Add Movie request from an earlier POST.
pub async fn get_add_movie_result(configuration: &configuration::Configuration, version: f64, request_id: &str, account_id: i64) -> Result<models::OrsonAiAddMovieResponse, Error<GetAddMovieResultError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_path_request_id = request_id;
    let p_query_account_id = account_id;

    let uri_str = format!("{}/api/{version}/orson/ai/addMovie/{requestId}", configuration.base_path, version=p_path_version, requestId=crate::apis::urlencode(p_path_request_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrsonAiAddMovieResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrsonAiAddMovieResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAddMovieResultError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets the completed Video Batch results, if done, or an error or status update if not.
pub async fn get_batch(configuration: &configuration::Configuration, version: f64, request_id: &str, account_id: i64) -> Result<models::OrsonAiBatchResponse, Error<GetBatchError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_path_request_id = request_id;
    let p_query_account_id = account_id;

    let uri_str = format!("{}/api/{version}/orson/ai/batch/{requestId}", configuration.base_path, version=p_path_version, requestId=crate::apis::urlencode(p_path_request_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrsonAiBatchResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrsonAiBatchResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetBatchError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Checks the Emotion analysis and returns in progress, results, or error.
pub async fn get_emotion(configuration: &configuration::Configuration, version: f64, request_id: &str, account_id: i64) -> Result<models::OrsonAiEmotionsResponse, Error<GetEmotionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_path_request_id = request_id;
    let p_query_account_id = account_id;

    let uri_str = format!("{}/api/{version}/orson/ai/emotion/{requestId}", configuration.base_path, version=p_path_version, requestId=crate::apis::urlencode(p_path_request_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrsonAiEmotionsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrsonAiEmotionsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetEmotionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets a summary of the episode's status, including any renders.
pub async fn get_episode_status(configuration: &configuration::Configuration, version: f64, episode_id: i64, account_id: i64) -> Result<models::OrsonEpisodeResponse, Error<GetEpisodeStatusError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_path_episode_id = episode_id;
    let p_query_account_id = account_id;

    let uri_str = format!("{}/api/{version}/orson/stories/episodes/{episodeId}/status", configuration.base_path, version=p_path_version, episodeId=p_path_episode_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrsonEpisodeResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrsonEpisodeResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetEpisodeStatusError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets a summary of the episode's status, including any renders.
pub async fn get_render_status(configuration: &configuration::Configuration, version: f64, render_id: &str, account_id: i64) -> Result<models::OrsonRenderResponse, Error<GetRenderStatusError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_path_render_id = render_id;
    let p_query_account_id = account_id;

    let uri_str = format!("{}/api/{version}/orson/stories/renders/{renderId}/status", configuration.base_path, version=p_path_version, renderId=crate::apis::urlencode(p_path_render_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrsonRenderResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrsonRenderResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetRenderStatusError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The results of the video transcription and optional translation.
pub async fn get_stt(configuration: &configuration::Configuration, version: f64, request_id: &str, account_id: i64) -> Result<models::OrsonAiSttResponse, Error<GetSttError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_path_request_id = request_id;
    let p_query_account_id = account_id;

    let uri_str = format!("{}/api/{version}/orson/ai/stt/{requestId}", configuration.base_path, version=p_path_version, requestId=crate::apis::urlencode(p_path_request_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrsonAiSttResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrsonAiSttResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSttError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a result or continue waiting for a pending request for TechTune analysis.
pub async fn get_tech_tune(configuration: &configuration::Configuration, version: f64, request_id: &str, account_id: i64) -> Result<models::OrsonAiTechTuneResponse, Error<GetTechTuneError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_path_request_id = request_id;
    let p_query_account_id = account_id;

    let uri_str = format!("{}/api/{version}/orson/ai/techTune/{requestId}", configuration.base_path, version=p_path_version, requestId=crate::apis::urlencode(p_path_request_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrsonAiTechTuneResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrsonAiTechTuneResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTechTuneError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the result of an in progress Topics Analysis from an earlier POST.
pub async fn get_topics(configuration: &configuration::Configuration, version: f64, request_id: &str, account_id: i64) -> Result<models::OrsonAiTopicsResponse, Error<GetTopicsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_path_request_id = request_id;
    let p_query_account_id = account_id;

    let uri_str = format!("{}/api/{version}/orson/ai/topics/{requestId}", configuration.base_path, version=p_path_version, requestId=crate::apis::urlencode(p_path_request_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrsonAiTopicsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrsonAiTopicsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTopicsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Check the status of an in progress Text-to-Speech call or download the result.
pub async fn get_tts(configuration: &configuration::Configuration, version: f64, request_id: &str, account_id: i64) -> Result<models::OrsonAiTtsResponse, Error<GetTtsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_path_request_id = request_id;
    let p_query_account_id = account_id;

    let uri_str = format!("{}/api/{version}/orson/ai/tts/{requestId}", configuration.base_path, version=p_path_version, requestId=crate::apis::urlencode(p_path_request_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrsonAiTtsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrsonAiTtsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTtsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a result or continue waiting for a pending request for VoiceCanvas Images.
pub async fn get_voice_canvas(configuration: &configuration::Configuration, version: f64, request_id: &str, account_id: i64) -> Result<models::OrsonAiVoiceCanvasResponse, Error<GetVoiceCanvasError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_path_request_id = request_id;
    let p_query_account_id = account_id;

    let uri_str = format!("{}/api/{version}/orson/ai/voiceCanvas/{requestId}", configuration.base_path, version=p_path_version, requestId=crate::apis::urlencode(p_path_request_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrsonAiVoiceCanvasResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrsonAiVoiceCanvasResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetVoiceCanvasError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Starts a StoryStitch video render to produce your final video, returning the status details.
pub async fn start_video_render(configuration: &configuration::Configuration, version: f64, account_id: i64, data: &str) -> Result<models::OrsonRenderResponse, Error<StartVideoRenderError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_account_id = account_id;
    let p_query_data = data;

    let uri_str = format!("{}/api/{version}/orson/stories/renders", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("data", &p_query_data.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrsonRenderResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrsonRenderResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StartVideoRenderError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Accepts a movie URL or uploaded file and transcribes it. You also have the option to translate it into one of our additional supported languages.
pub async fn stt(configuration: &configuration::Configuration, version: f64, account_id: i64, third_party_account_id: Option<&str>, source_language: Option<&str>, target_language: Option<&str>, file: Option<std::path::PathBuf>, url: Option<&str>, callback: Option<&str>) -> Result<models::OrsonAiSttResponse, Error<SttError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_account_id = account_id;
    let p_query_third_party_account_id = third_party_account_id;
    let p_query_source_language = source_language;
    let p_query_target_language = target_language;
    let p_query_file = file;
    let p_query_url = url;
    let p_query_callback = callback;

    let uri_str = format!("{}/api/{version}/orson/ai/stt", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    if let Some(ref param_value) = p_query_third_party_account_id {
        req_builder = req_builder.query(&[("thirdPartyAccountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_source_language {
        req_builder = req_builder.query(&[("sourceLanguage", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_target_language {
        req_builder = req_builder.query(&[("targetLanguage", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_file {
        req_builder = req_builder.query(&[("file", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_url {
        req_builder = req_builder.query(&[("url", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_callback {
        req_builder = req_builder.query(&[("callback", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrsonAiSttResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrsonAiSttResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SttError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Takes in a string of text sentences (also known as a document) and returns a list of associated topics and their proximity score.
pub async fn summarize_topics(configuration: &configuration::Configuration, version: f64, account_id: i64, third_party_account_id: Option<&str>, doc: Option<&str>, file: Option<std::path::PathBuf>, url: Option<&str>, limit: Option<i32>, offset: Option<i32>, callback: Option<&str>) -> Result<models::OrsonAiTopicsResponse, Error<SummarizeTopicsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_account_id = account_id;
    let p_query_third_party_account_id = third_party_account_id;
    let p_query_doc = doc;
    let p_query_file = file;
    let p_query_url = url;
    let p_query_limit = limit;
    let p_query_offset = offset;
    let p_query_callback = callback;

    let uri_str = format!("{}/api/{version}/orson/ai/topics", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    if let Some(ref param_value) = p_query_third_party_account_id {
        req_builder = req_builder.query(&[("thirdPartyAccountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_doc {
        req_builder = req_builder.query(&[("doc", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_file {
        req_builder = req_builder.query(&[("file", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_url {
        req_builder = req_builder.query(&[("url", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_callback {
        req_builder = req_builder.query(&[("callback", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrsonAiTopicsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrsonAiTopicsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SummarizeTopicsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Analyses a movie file to detect technical issues, such as too few people in frame.
pub async fn tech_tune(configuration: &configuration::Configuration, version: f64, account_id: i64, num_faces_expected: i32, third_party_account_id: Option<&str>, file: Option<std::path::PathBuf>, url: Option<&str>, callback: Option<&str>) -> Result<models::OrsonAiTechTuneResponse, Error<TechTuneError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_account_id = account_id;
    let p_query_num_faces_expected = num_faces_expected;
    let p_query_third_party_account_id = third_party_account_id;
    let p_query_file = file;
    let p_query_url = url;
    let p_query_callback = callback;

    let uri_str = format!("{}/api/{version}/orson/ai/techTune", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    if let Some(ref param_value) = p_query_third_party_account_id {
        req_builder = req_builder.query(&[("thirdPartyAccountId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("numFacesExpected", &p_query_num_faces_expected.to_string())]);
    if let Some(ref param_value) = p_query_file {
        req_builder = req_builder.query(&[("file", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_url {
        req_builder = req_builder.query(&[("url", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_callback {
        req_builder = req_builder.query(&[("callback", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrsonAiTechTuneResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrsonAiTechTuneResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TechTuneError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates an audio file for the given text, with the option of language and voice selection.
pub async fn tts(configuration: &configuration::Configuration, version: f64, account_id: i64, text: &str, third_party_account_id: Option<&str>, language: Option<&str>, voice: Option<&str>, callback: Option<&str>) -> Result<models::OrsonAiTtsResponse, Error<TtsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_account_id = account_id;
    let p_query_text = text;
    let p_query_third_party_account_id = third_party_account_id;
    let p_query_language = language;
    let p_query_voice = voice;
    let p_query_callback = callback;

    let uri_str = format!("{}/api/{version}/orson/ai/tts", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    if let Some(ref param_value) = p_query_third_party_account_id {
        req_builder = req_builder.query(&[("thirdPartyAccountId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("text", &p_query_text.to_string())]);
    if let Some(ref param_value) = p_query_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_voice {
        req_builder = req_builder.query(&[("voice", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_callback {
        req_builder = req_builder.query(&[("callback", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrsonAiTtsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrsonAiTtsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TtsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

