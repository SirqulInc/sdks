/*
 * Sirqul IoT Platform
 *
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`create_application_config`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateApplicationConfigError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_application_config`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteApplicationConfigError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_application_config`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetApplicationConfigError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_application_config_by_config_version`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetApplicationConfigByConfigVersionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_application_config`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchApplicationConfigError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_application_config`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateApplicationConfigError {
    UnknownValue(serde_json::Value),
}


/// Creates a new application configuration. If the configVersion provided already exists for the given app, an invalid response is returned and the application configuration won't be created.
pub async fn create_application_config(configuration: &configuration::Configuration, version: f64, account_id: i64, app_key: &str, config_version: &str, asset_id: i64, retailer_id: Option<i64>, retailer_location_id: Option<i64>, udid: Option<&str>) -> Result<models::ApplicationConfigResponse, Error<CreateApplicationConfigError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_account_id = account_id;
    let p_query_app_key = app_key;
    let p_query_config_version = config_version;
    let p_query_asset_id = asset_id;
    let p_query_retailer_id = retailer_id;
    let p_query_retailer_location_id = retailer_location_id;
    let p_query_udid = udid;

    let uri_str = format!("{}/api/{version}/appconfig/create", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("appKey", &p_query_app_key.to_string())]);
    req_builder = req_builder.query(&[("configVersion", &p_query_config_version.to_string())]);
    req_builder = req_builder.query(&[("assetId", &p_query_asset_id.to_string())]);
    if let Some(ref param_value) = p_query_retailer_id {
        req_builder = req_builder.query(&[("retailerId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_retailer_location_id {
        req_builder = req_builder.query(&[("retailerLocationId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_udid {
        req_builder = req_builder.query(&[("udid", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApplicationConfigResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApplicationConfigResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateApplicationConfigError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Mark the application configuration for deletion.
pub async fn delete_application_config(configuration: &configuration::Configuration, version: f64, account_id: i64, config_id: i64) -> Result<models::SirqulResponse, Error<DeleteApplicationConfigError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_account_id = account_id;
    let p_query_config_id = config_id;

    let uri_str = format!("{}/api/{version}/appconfig/delete", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("configId", &p_query_config_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SirqulResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SirqulResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteApplicationConfigError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets the appConfig data by the given configId. If appConfig cannot be found, it returns an invalid response.
pub async fn get_application_config(configuration: &configuration::Configuration, version: f64, account_id: i64, config_id: i64) -> Result<models::ApplicationConfigResponse, Error<GetApplicationConfigError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_account_id = account_id;
    let p_query_config_id = config_id;

    let uri_str = format!("{}/api/{version}/appconfig/get", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("configId", &p_query_config_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApplicationConfigResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApplicationConfigResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetApplicationConfigError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets the appConfig data by the given appKey and app configVersion number.If the appKey is is invalid or appConfig is not found, it returns an invalid response. 
pub async fn get_application_config_by_config_version(configuration: &configuration::Configuration, version: f64, app_key: &str, config_version: &str, retailer_id: Option<i64>, retailer_location_id: Option<i64>, udid: Option<&str>, allow_older_versions: Option<bool>) -> Result<models::ApplicationConfigResponse, Error<GetApplicationConfigByConfigVersionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_app_key = app_key;
    let p_query_config_version = config_version;
    let p_query_retailer_id = retailer_id;
    let p_query_retailer_location_id = retailer_location_id;
    let p_query_udid = udid;
    let p_query_allow_older_versions = allow_older_versions;

    let uri_str = format!("{}/api/{version}/appconfig/getbyversion", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("appKey", &p_query_app_key.to_string())]);
    req_builder = req_builder.query(&[("configVersion", &p_query_config_version.to_string())]);
    if let Some(ref param_value) = p_query_retailer_id {
        req_builder = req_builder.query(&[("retailerId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_retailer_location_id {
        req_builder = req_builder.query(&[("retailerLocationId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_udid {
        req_builder = req_builder.query(&[("udid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_allow_older_versions {
        req_builder = req_builder.query(&[("allowOlderVersions", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApplicationConfigResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApplicationConfigResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetApplicationConfigByConfigVersionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets all versions of application configurations in a particular app by the given appKey.
pub async fn search_application_config(configuration: &configuration::Configuration, version: f64, account_id: i64, app_key: Option<&str>, retailer_id: Option<i64>, retailer_location_id: Option<i64>, udid: Option<&str>, config_version: Option<&str>, sort_field: Option<&str>, descending: Option<bool>, start: Option<i32>, limit: Option<i32>) -> Result<Vec<models::ApplicationConfigResponse>, Error<SearchApplicationConfigError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_account_id = account_id;
    let p_query_app_key = app_key;
    let p_query_retailer_id = retailer_id;
    let p_query_retailer_location_id = retailer_location_id;
    let p_query_udid = udid;
    let p_query_config_version = config_version;
    let p_query_sort_field = sort_field;
    let p_query_descending = descending;
    let p_query_start = start;
    let p_query_limit = limit;

    let uri_str = format!("{}/api/{version}/appconfig/search", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    if let Some(ref param_value) = p_query_app_key {
        req_builder = req_builder.query(&[("appKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_retailer_id {
        req_builder = req_builder.query(&[("retailerId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_retailer_location_id {
        req_builder = req_builder.query(&[("retailerLocationId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_udid {
        req_builder = req_builder.query(&[("udid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_config_version {
        req_builder = req_builder.query(&[("configVersion", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_field {
        req_builder = req_builder.query(&[("sortField", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_descending {
        req_builder = req_builder.query(&[("descending", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start {
        req_builder = req_builder.query(&[("start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::ApplicationConfigResponse&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::ApplicationConfigResponse&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchApplicationConfigError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// pdates an existing application configuration. If the configVersion provided already exists for the given app the application configuration won't be updated.
pub async fn update_application_config(configuration: &configuration::Configuration, version: f64, account_id: i64, config_id: i64, app_key: Option<&str>, config_version: Option<&str>, asset_id: Option<i64>, retailer_id: Option<i64>, retailer_location_id: Option<i64>, udid: Option<&str>) -> Result<models::ApplicationConfigResponse, Error<UpdateApplicationConfigError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_account_id = account_id;
    let p_query_config_id = config_id;
    let p_query_app_key = app_key;
    let p_query_config_version = config_version;
    let p_query_asset_id = asset_id;
    let p_query_retailer_id = retailer_id;
    let p_query_retailer_location_id = retailer_location_id;
    let p_query_udid = udid;

    let uri_str = format!("{}/api/{version}/appconfig/update", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("configId", &p_query_config_id.to_string())]);
    if let Some(ref param_value) = p_query_app_key {
        req_builder = req_builder.query(&[("appKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_config_version {
        req_builder = req_builder.query(&[("configVersion", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_asset_id {
        req_builder = req_builder.query(&[("assetId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_retailer_id {
        req_builder = req_builder.query(&[("retailerId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_retailer_location_id {
        req_builder = req_builder.query(&[("retailerLocationId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_udid {
        req_builder = req_builder.query(&[("udid", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApplicationConfigResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApplicationConfigResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateApplicationConfigError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

