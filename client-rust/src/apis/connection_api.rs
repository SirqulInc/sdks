/*
 * Sirqul IoT Platform
 *
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`add_connection_to_group`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddConnectionToGroupError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`add_connections_to_group`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddConnectionsToGroupError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`add_sub_groups`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddSubGroupsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_or_update_connection`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateOrUpdateConnectionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_or_update_group`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateOrUpdateGroupError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`follow_accept`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FollowAcceptError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`follow_reject`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FollowRejectError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`follow_remove`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FollowRemoveError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`follow_request`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FollowRequestError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`friend_accept`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FriendAcceptError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`friend_reject`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FriendRejectError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`friend_remove`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FriendRemoveError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`friend_request`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FriendRequestError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_connection_sent_friend_requests`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetConnectionSentFriendRequestsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_connections`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetConnectionsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_group_details`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetGroupDetailsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`group_search`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GroupSearchError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`remove_connection_from_group`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RemoveConnectionFromGroupError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`remove_connections_from_group`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RemoveConnectionsFromGroupError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`remove_group`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RemoveGroupError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`remove_sub_groups`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RemoveSubGroupsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_connections`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchConnectionsError {
    UnknownValue(serde_json::Value),
}


/// Adds a connection to a group.
pub async fn add_connection_to_group(configuration: &configuration::Configuration, return_nulls: bool, group_id: i64, device_id: Option<&str>, account_id: Option<i64>, connection_id: Option<i64>, connection_account_id: Option<i64>, pending_id: Option<i64>, latitude: Option<f64>, longitude: Option<f64>) -> Result<models::SirqulResponse, Error<AddConnectionToGroupError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_return_nulls = return_nulls;
    let p_query_group_id = group_id;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_connection_id = connection_id;
    let p_query_connection_account_id = connection_account_id;
    let p_query_pending_id = pending_id;
    let p_query_latitude = latitude;
    let p_query_longitude = longitude;

    let uri_str = format!("{}/consumer/connection/group/addConnection", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("returnNulls", &p_query_return_nulls.to_string())]);
    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_connection_id {
        req_builder = req_builder.query(&[("connectionId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_connection_account_id {
        req_builder = req_builder.query(&[("connectionAccountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_pending_id {
        req_builder = req_builder.query(&[("pendingId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("groupId", &p_query_group_id.to_string())]);
    if let Some(ref param_value) = p_query_latitude {
        req_builder = req_builder.query(&[("latitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_longitude {
        req_builder = req_builder.query(&[("longitude", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SirqulResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SirqulResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AddConnectionToGroupError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Adds a list of connections to a group.
pub async fn add_connections_to_group(configuration: &configuration::Configuration, connection_group_id: i64, device_id: Option<&str>, account_id: Option<i64>, connection_ids: Option<&str>, connection_account_ids: Option<&str>, latitude: Option<f64>, longitude: Option<f64>) -> Result<models::SirqulResponse, Error<AddConnectionsToGroupError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_connection_group_id = connection_group_id;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_connection_ids = connection_ids;
    let p_query_connection_account_ids = connection_account_ids;
    let p_query_latitude = latitude;
    let p_query_longitude = longitude;

    let uri_str = format!("{}/connection/group/addConnections", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_connection_ids {
        req_builder = req_builder.query(&[("connectionIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_connection_account_ids {
        req_builder = req_builder.query(&[("connectionAccountIds", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("connectionGroupId", &p_query_connection_group_id.to_string())]);
    if let Some(ref param_value) = p_query_latitude {
        req_builder = req_builder.query(&[("latitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_longitude {
        req_builder = req_builder.query(&[("longitude", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SirqulResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SirqulResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AddConnectionsToGroupError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Add sub groups to a group.
pub async fn add_sub_groups(configuration: &configuration::Configuration, return_nulls: bool, group_id: i64, sub_group_ids: &str, device_id: Option<&str>, account_id: Option<i64>, latitude: Option<f64>, longitude: Option<f64>) -> Result<models::ConnectionGroupResponse, Error<AddSubGroupsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_return_nulls = return_nulls;
    let p_query_group_id = group_id;
    let p_query_sub_group_ids = sub_group_ids;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_latitude = latitude;
    let p_query_longitude = longitude;

    let uri_str = format!("{}/consumer/connection/group/addSubGroup", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("returnNulls", &p_query_return_nulls.to_string())]);
    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("groupId", &p_query_group_id.to_string())]);
    req_builder = req_builder.query(&[("subGroupIds", &p_query_sub_group_ids.to_string())]);
    if let Some(ref param_value) = p_query_latitude {
        req_builder = req_builder.query(&[("latitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_longitude {
        req_builder = req_builder.query(&[("longitude", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ConnectionGroupResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ConnectionGroupResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AddSubGroupsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates or updates the connection of the user and another account. Allows a user to follow, block, mark as trusted, and/or add someone to a group.
pub async fn create_or_update_connection(configuration: &configuration::Configuration, device_id: Option<&str>, account_id: Option<i64>, connection_id: Option<i64>, connection_account_id: Option<i64>, pending_id: Option<i64>, group_id: Option<i64>, game_type: Option<&str>, app_key: Option<&str>, is_trusted: Option<bool>, ignore_friend_request: Option<bool>, is_contact: Option<bool>, is_blocked: Option<bool>, is_following: Option<bool>, connection_response: Option<bool>) -> Result<models::ConnectionResponse, Error<CreateOrUpdateConnectionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_connection_id = connection_id;
    let p_query_connection_account_id = connection_account_id;
    let p_query_pending_id = pending_id;
    let p_query_group_id = group_id;
    let p_query_game_type = game_type;
    let p_query_app_key = app_key;
    let p_query_is_trusted = is_trusted;
    let p_query_ignore_friend_request = ignore_friend_request;
    let p_query_is_contact = is_contact;
    let p_query_is_blocked = is_blocked;
    let p_query_is_following = is_following;
    let p_query_connection_response = connection_response;

    let uri_str = format!("{}/consumer/connection/add", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_connection_id {
        req_builder = req_builder.query(&[("connectionId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_connection_account_id {
        req_builder = req_builder.query(&[("connectionAccountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_pending_id {
        req_builder = req_builder.query(&[("pendingId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_group_id {
        req_builder = req_builder.query(&[("groupId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_game_type {
        req_builder = req_builder.query(&[("gameType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_key {
        req_builder = req_builder.query(&[("appKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_is_trusted {
        req_builder = req_builder.query(&[("isTrusted", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ignore_friend_request {
        req_builder = req_builder.query(&[("ignoreFriendRequest", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_is_contact {
        req_builder = req_builder.query(&[("isContact", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_is_blocked {
        req_builder = req_builder.query(&[("isBlocked", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_is_following {
        req_builder = req_builder.query(&[("isFollowing", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_connection_response {
        req_builder = req_builder.query(&[("connectionResponse", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ConnectionResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ConnectionResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateOrUpdateConnectionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a new private group.
pub async fn create_or_update_group(configuration: &configuration::Configuration, return_nulls: bool, device_id: Option<&str>, account_id: Option<i64>, name: Option<&str>, group_id: Option<i64>, asset_id: Option<i64>, connections: Option<&str>, description: Option<&str>, can_view_profile_info: Option<bool>, can_view_game_info: Option<bool>, can_view_friend_info: Option<bool>, active: Option<bool>, latitude: Option<f64>, longitude: Option<f64>) -> Result<models::SirqulResponse, Error<CreateOrUpdateGroupError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_return_nulls = return_nulls;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_name = name;
    let p_query_group_id = group_id;
    let p_query_asset_id = asset_id;
    let p_query_connections = connections;
    let p_query_description = description;
    let p_query_can_view_profile_info = can_view_profile_info;
    let p_query_can_view_game_info = can_view_game_info;
    let p_query_can_view_friend_info = can_view_friend_info;
    let p_query_active = active;
    let p_query_latitude = latitude;
    let p_query_longitude = longitude;

    let uri_str = format!("{}/consumer/connection/group", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("returnNulls", &p_query_return_nulls.to_string())]);
    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_group_id {
        req_builder = req_builder.query(&[("groupId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_asset_id {
        req_builder = req_builder.query(&[("assetId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_connections {
        req_builder = req_builder.query(&[("connections", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_description {
        req_builder = req_builder.query(&[("description", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_can_view_profile_info {
        req_builder = req_builder.query(&[("canViewProfileInfo", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_can_view_game_info {
        req_builder = req_builder.query(&[("canViewGameInfo", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_can_view_friend_info {
        req_builder = req_builder.query(&[("canViewFriendInfo", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_active {
        req_builder = req_builder.query(&[("active", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_latitude {
        req_builder = req_builder.query(&[("latitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_longitude {
        req_builder = req_builder.query(&[("longitude", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SirqulResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SirqulResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateOrUpdateGroupError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Accept someone's follow request.
pub async fn follow_accept(configuration: &configuration::Configuration, account_id: i64, connection_account_id: i64, app_key: &str) -> Result<models::SirqulResponse, Error<FollowAcceptError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_id = account_id;
    let p_query_connection_account_id = connection_account_id;
    let p_query_app_key = app_key;

    let uri_str = format!("{}/consumer/follow/accept", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("connectionAccountId", &p_query_connection_account_id.to_string())]);
    req_builder = req_builder.query(&[("appKey", &p_query_app_key.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SirqulResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SirqulResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<FollowAcceptError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Reject someone's follow request or remove them as a follower.
pub async fn follow_reject(configuration: &configuration::Configuration, account_id: i64, connection_account_id: i64, app_key: &str) -> Result<models::SirqulResponse, Error<FollowRejectError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_id = account_id;
    let p_query_connection_account_id = connection_account_id;
    let p_query_app_key = app_key;

    let uri_str = format!("{}/consumer/follow/reject", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("connectionAccountId", &p_query_connection_account_id.to_string())]);
    req_builder = req_builder.query(&[("appKey", &p_query_app_key.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SirqulResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SirqulResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<FollowRejectError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Unfollow someone you are following or remove them as a follower.
pub async fn follow_remove(configuration: &configuration::Configuration, account_id: i64, connection_account_id: i64, app_key: &str) -> Result<models::SirqulResponse, Error<FollowRemoveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_id = account_id;
    let p_query_connection_account_id = connection_account_id;
    let p_query_app_key = app_key;

    let uri_str = format!("{}/consumer/follow/remove", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("connectionAccountId", &p_query_connection_account_id.to_string())]);
    req_builder = req_builder.query(&[("appKey", &p_query_app_key.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SirqulResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SirqulResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<FollowRemoveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Send a request to follow someone.
pub async fn follow_request(configuration: &configuration::Configuration, account_id: i64, connection_account_id: i64, app_key: &str, approval_needed: Option<bool>) -> Result<models::SirqulResponse, Error<FollowRequestError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_id = account_id;
    let p_query_connection_account_id = connection_account_id;
    let p_query_app_key = app_key;
    let p_query_approval_needed = approval_needed;

    let uri_str = format!("{}/consumer/follow/request", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("connectionAccountId", &p_query_connection_account_id.to_string())]);
    req_builder = req_builder.query(&[("appKey", &p_query_app_key.to_string())]);
    if let Some(ref param_value) = p_query_approval_needed {
        req_builder = req_builder.query(&[("approvalNeeded", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SirqulResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SirqulResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<FollowRequestError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Accept a friend request and optionally sends a notification.
pub async fn friend_accept(configuration: &configuration::Configuration, friend_account_id: i64, notify_friend: bool, device_id: Option<&str>, account_id: Option<i64>, game_type: Option<&str>, app_key: Option<&str>, notification_message: Option<&str>) -> Result<models::SirqulResponse, Error<FriendAcceptError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_friend_account_id = friend_account_id;
    let p_query_notify_friend = notify_friend;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_game_type = game_type;
    let p_query_app_key = app_key;
    let p_query_notification_message = notification_message;

    let uri_str = format!("{}/consumer/friend/accept", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("friendAccountId", &p_query_friend_account_id.to_string())]);
    if let Some(ref param_value) = p_query_game_type {
        req_builder = req_builder.query(&[("gameType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_key {
        req_builder = req_builder.query(&[("appKey", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("notifyFriend", &p_query_notify_friend.to_string())]);
    if let Some(ref param_value) = p_query_notification_message {
        req_builder = req_builder.query(&[("notificationMessage", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SirqulResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SirqulResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<FriendAcceptError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Request a friend request and optionally sends a notification.
pub async fn friend_reject(configuration: &configuration::Configuration, friend_account_id: i64, device_id: Option<&str>, account_id: Option<i64>, game_type: Option<&str>, app_key: Option<&str>, notify_friend: Option<bool>, notification_message: Option<&str>) -> Result<models::SirqulResponse, Error<FriendRejectError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_friend_account_id = friend_account_id;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_game_type = game_type;
    let p_query_app_key = app_key;
    let p_query_notify_friend = notify_friend;
    let p_query_notification_message = notification_message;

    let uri_str = format!("{}/consumer/friend/reject", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("friendAccountId", &p_query_friend_account_id.to_string())]);
    if let Some(ref param_value) = p_query_game_type {
        req_builder = req_builder.query(&[("gameType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_key {
        req_builder = req_builder.query(&[("appKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_notify_friend {
        req_builder = req_builder.query(&[("notifyFriend", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_notification_message {
        req_builder = req_builder.query(&[("notificationMessage", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SirqulResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SirqulResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<FriendRejectError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Removes a friend from the user's friends list.
pub async fn friend_remove(configuration: &configuration::Configuration, friend_account_id: i64, device_id: Option<&str>, account_id: Option<i64>, notify_friend: Option<bool>, remove_from_groups: Option<bool>) -> Result<models::SirqulResponse, Error<FriendRemoveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_friend_account_id = friend_account_id;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_notify_friend = notify_friend;
    let p_query_remove_from_groups = remove_from_groups;

    let uri_str = format!("{}/consumer/friend/remove", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("friendAccountId", &p_query_friend_account_id.to_string())]);
    if let Some(ref param_value) = p_query_notify_friend {
        req_builder = req_builder.query(&[("notifyFriend", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_remove_from_groups {
        req_builder = req_builder.query(&[("removeFromGroups", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SirqulResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SirqulResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<FriendRemoveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Sends a friend request notification to another user.
pub async fn friend_request(configuration: &configuration::Configuration, friend_account_id: i64, device_id: Option<&str>, account_id: Option<i64>, game_type: Option<&str>, app_key: Option<&str>, notification_message: Option<&str>) -> Result<models::SirqulResponse, Error<FriendRequestError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_friend_account_id = friend_account_id;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_game_type = game_type;
    let p_query_app_key = app_key;
    let p_query_notification_message = notification_message;

    let uri_str = format!("{}/consumer/friend/request", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("friendAccountId", &p_query_friend_account_id.to_string())]);
    if let Some(ref param_value) = p_query_game_type {
        req_builder = req_builder.query(&[("gameType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_key {
        req_builder = req_builder.query(&[("appKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_notification_message {
        req_builder = req_builder.query(&[("notificationMessage", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SirqulResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SirqulResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<FriendRequestError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets the connection sent friend requests.
pub async fn get_connection_sent_friend_requests(configuration: &configuration::Configuration, device_id: Option<&str>, account_id: Option<i64>) -> Result<models::ConnectionListResponse, Error<GetConnectionSentFriendRequestsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;

    let uri_str = format!("{}/consumer/connection/getRequested", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ConnectionListResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ConnectionListResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetConnectionSentFriendRequestsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets the connections.
pub async fn get_connections(configuration: &configuration::Configuration, return_nulls: bool, filter: &str, sort_field: &str, descending: bool, start: i32, limit: i32, device_id: Option<&str>, account_id: Option<i64>, connection_account_id: Option<i64>, q: Option<&str>, keyword: Option<&str>, _i: Option<i32>, _l: Option<i32>, latitude: Option<f64>, longitude: Option<f64>) -> Result<models::ConnectionListResponse, Error<GetConnectionsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_return_nulls = return_nulls;
    let p_query_filter = filter;
    let p_query_sort_field = sort_field;
    let p_query_descending = descending;
    let p_query_start = start;
    let p_query_limit = limit;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_connection_account_id = connection_account_id;
    let p_query_q = q;
    let p_query_keyword = keyword;
    let p_query__i = _i;
    let p_query__l = _l;
    let p_query_latitude = latitude;
    let p_query_longitude = longitude;

    let uri_str = format!("{}/consumer/connection/get", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("returnNulls", &p_query_return_nulls.to_string())]);
    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_connection_account_id {
        req_builder = req_builder.query(&[("connectionAccountId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("filter", &p_query_filter.to_string())]);
    if let Some(ref param_value) = p_query_q {
        req_builder = req_builder.query(&[("q", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_keyword {
        req_builder = req_builder.query(&[("keyword", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("sortField", &p_query_sort_field.to_string())]);
    req_builder = req_builder.query(&[("descending", &p_query_descending.to_string())]);
    if let Some(ref param_value) = p_query__i {
        req_builder = req_builder.query(&[("_i", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("start", &p_query_start.to_string())]);
    if let Some(ref param_value) = p_query__l {
        req_builder = req_builder.query(&[("_l", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("limit", &p_query_limit.to_string())]);
    if let Some(ref param_value) = p_query_latitude {
        req_builder = req_builder.query(&[("latitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_longitude {
        req_builder = req_builder.query(&[("longitude", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ConnectionListResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ConnectionListResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetConnectionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_group_details(configuration: &configuration::Configuration, combine_connections: bool, device_id: Option<&str>, account_id: Option<i64>, group_id: Option<i64>, latitude: Option<f64>, longitude: Option<f64>) -> Result<models::ConnectionGroupResponse, Error<GetGroupDetailsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_combine_connections = combine_connections;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_group_id = group_id;
    let p_query_latitude = latitude;
    let p_query_longitude = longitude;

    let uri_str = format!("{}/consumer/connection/group/details/get", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_group_id {
        req_builder = req_builder.query(&[("groupId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("combineConnections", &p_query_combine_connections.to_string())]);
    if let Some(ref param_value) = p_query_latitude {
        req_builder = req_builder.query(&[("latitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_longitude {
        req_builder = req_builder.query(&[("longitude", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ConnectionGroupResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ConnectionGroupResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetGroupDetailsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets a user's private groups and default groups.
pub async fn group_search(configuration: &configuration::Configuration, sort_field: &str, descending: bool, active_only: bool, start: i32, limit: i32, device_id: Option<&str>, account_id: Option<i64>, latitude: Option<f64>, longitude: Option<f64>, keyword: Option<&str>) -> Result<Vec<models::ConnectionInfoResponse>, Error<GroupSearchError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_sort_field = sort_field;
    let p_query_descending = descending;
    let p_query_active_only = active_only;
    let p_query_start = start;
    let p_query_limit = limit;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_latitude = latitude;
    let p_query_longitude = longitude;
    let p_query_keyword = keyword;

    let uri_str = format!("{}/connection/group/search", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_latitude {
        req_builder = req_builder.query(&[("latitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_longitude {
        req_builder = req_builder.query(&[("longitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_keyword {
        req_builder = req_builder.query(&[("keyword", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("sortField", &p_query_sort_field.to_string())]);
    req_builder = req_builder.query(&[("descending", &p_query_descending.to_string())]);
    req_builder = req_builder.query(&[("activeOnly", &p_query_active_only.to_string())]);
    req_builder = req_builder.query(&[("start", &p_query_start.to_string())]);
    req_builder = req_builder.query(&[("limit", &p_query_limit.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::ConnectionInfoResponse&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::ConnectionInfoResponse&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GroupSearchError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Removes the connection from group.
pub async fn remove_connection_from_group(configuration: &configuration::Configuration, return_nulls: bool, group_id: i64, device_id: Option<&str>, account_id: Option<i64>, connection_id: Option<i64>, connection_account_id: Option<i64>, pending_id: Option<i64>, latitude: Option<f64>, longitude: Option<f64>) -> Result<models::SirqulResponse, Error<RemoveConnectionFromGroupError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_return_nulls = return_nulls;
    let p_query_group_id = group_id;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_connection_id = connection_id;
    let p_query_connection_account_id = connection_account_id;
    let p_query_pending_id = pending_id;
    let p_query_latitude = latitude;
    let p_query_longitude = longitude;

    let uri_str = format!("{}/consumer/connection/group/removeConnection", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("returnNulls", &p_query_return_nulls.to_string())]);
    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_connection_id {
        req_builder = req_builder.query(&[("connectionId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_connection_account_id {
        req_builder = req_builder.query(&[("connectionAccountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_pending_id {
        req_builder = req_builder.query(&[("pendingId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("groupId", &p_query_group_id.to_string())]);
    if let Some(ref param_value) = p_query_latitude {
        req_builder = req_builder.query(&[("latitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_longitude {
        req_builder = req_builder.query(&[("longitude", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SirqulResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SirqulResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RemoveConnectionFromGroupError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Remove a list of connections from a group.
pub async fn remove_connections_from_group(configuration: &configuration::Configuration, connection_group_id: i64, device_id: Option<&str>, account_id: Option<i64>, connection_ids: Option<&str>, connection_account_ids: Option<&str>, latitude: Option<f64>, longitude: Option<f64>) -> Result<models::SirqulResponse, Error<RemoveConnectionsFromGroupError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_connection_group_id = connection_group_id;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_connection_ids = connection_ids;
    let p_query_connection_account_ids = connection_account_ids;
    let p_query_latitude = latitude;
    let p_query_longitude = longitude;

    let uri_str = format!("{}/connection/group/removeConnections", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_connection_ids {
        req_builder = req_builder.query(&[("connectionIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_connection_account_ids {
        req_builder = req_builder.query(&[("connectionAccountIds", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("connectionGroupId", &p_query_connection_group_id.to_string())]);
    if let Some(ref param_value) = p_query_latitude {
        req_builder = req_builder.query(&[("latitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_longitude {
        req_builder = req_builder.query(&[("longitude", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SirqulResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SirqulResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RemoveConnectionsFromGroupError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Remove a user's group.
pub async fn remove_group(configuration: &configuration::Configuration, return_nulls: bool, group_id: i64, device_id: Option<&str>, account_id: Option<i64>, latitude: Option<f64>, longitude: Option<f64>) -> Result<models::SirqulResponse, Error<RemoveGroupError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_return_nulls = return_nulls;
    let p_query_group_id = group_id;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_latitude = latitude;
    let p_query_longitude = longitude;

    let uri_str = format!("{}/consumer/connection/group/remove", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("returnNulls", &p_query_return_nulls.to_string())]);
    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("groupId", &p_query_group_id.to_string())]);
    if let Some(ref param_value) = p_query_latitude {
        req_builder = req_builder.query(&[("latitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_longitude {
        req_builder = req_builder.query(&[("longitude", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SirqulResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SirqulResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RemoveGroupError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Remove sub groups from a group
pub async fn remove_sub_groups(configuration: &configuration::Configuration, return_nulls: bool, group_id: i64, sub_group_ids: &str, device_id: Option<&str>, account_id: Option<i64>, latitude: Option<f64>, longitude: Option<f64>) -> Result<models::SirqulResponse, Error<RemoveSubGroupsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_return_nulls = return_nulls;
    let p_query_group_id = group_id;
    let p_query_sub_group_ids = sub_group_ids;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_latitude = latitude;
    let p_query_longitude = longitude;

    let uri_str = format!("{}/consumer/connection/group/removeSubGroup", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("returnNulls", &p_query_return_nulls.to_string())]);
    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("groupId", &p_query_group_id.to_string())]);
    req_builder = req_builder.query(&[("subGroupIds", &p_query_sub_group_ids.to_string())]);
    if let Some(ref param_value) = p_query_latitude {
        req_builder = req_builder.query(&[("latitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_longitude {
        req_builder = req_builder.query(&[("longitude", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SirqulResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SirqulResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RemoveSubGroupsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Search for accounts that the user may not have a connection with.
pub async fn search_connections(configuration: &configuration::Configuration, return_nulls: bool, start: i32, limit: i32, device_id: Option<&str>, account_id: Option<i64>, q: Option<&str>, keyword: Option<&str>, latitude: Option<f64>, longitude: Option<f64>, game_type: Option<&str>, app_key: Option<&str>, _i: Option<i32>, _l: Option<i32>, sort_field: Option<&str>, has_location: Option<bool>) -> Result<models::ConnectionListResponse, Error<SearchConnectionsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_return_nulls = return_nulls;
    let p_query_start = start;
    let p_query_limit = limit;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_q = q;
    let p_query_keyword = keyword;
    let p_query_latitude = latitude;
    let p_query_longitude = longitude;
    let p_query_game_type = game_type;
    let p_query_app_key = app_key;
    let p_query__i = _i;
    let p_query__l = _l;
    let p_query_sort_field = sort_field;
    let p_query_has_location = has_location;

    let uri_str = format!("{}/connection/search", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("returnNulls", &p_query_return_nulls.to_string())]);
    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_q {
        req_builder = req_builder.query(&[("q", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_keyword {
        req_builder = req_builder.query(&[("keyword", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_latitude {
        req_builder = req_builder.query(&[("latitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_longitude {
        req_builder = req_builder.query(&[("longitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_game_type {
        req_builder = req_builder.query(&[("gameType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_key {
        req_builder = req_builder.query(&[("appKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query__i {
        req_builder = req_builder.query(&[("_i", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("start", &p_query_start.to_string())]);
    if let Some(ref param_value) = p_query__l {
        req_builder = req_builder.query(&[("_l", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("limit", &p_query_limit.to_string())]);
    if let Some(ref param_value) = p_query_sort_field {
        req_builder = req_builder.query(&[("sortField", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_has_location {
        req_builder = req_builder.query(&[("hasLocation", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ConnectionListResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ConnectionListResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchConnectionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

