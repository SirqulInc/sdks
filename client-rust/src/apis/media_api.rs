/*
 * Sirqul IoT Platform
 *
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`create_media`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateMediaError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_media`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteMediaError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_media`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMediaError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_media`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchMediaError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_media`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateMediaError {
    UnknownValue(serde_json::Value),
}


/// Create a media offering.
pub async fn create_media(configuration: &configuration::Configuration, account_id: i64, title: &str, barcode_type: &str, no_expiration: bool, available_limit: i32, available_limit_per_user: i32, added_limit: i32, view_limit: i32, max_prints: i32, ticket_price: i64, full_price: f64, discount_price: f64, special_offer_type: &str, offer_visibility: &str, active: bool, retailer_location_ids: Option<&str>, sub_title: Option<&str>, details: Option<&str>, sub_details: Option<&str>, fine_print: Option<&str>, barcode_entry: Option<&str>, external_redeem_options: Option<&str>, external_url: Option<&str>, tickets_reward_type: Option<&str>, tickets_reward: Option<i64>, activated: Option<i64>, expires: Option<i64>, ticket_price_type: Option<&str>, show_remaining: Option<bool>, show_redeemed: Option<bool>, replaced: Option<bool>, featured: Option<bool>, category_ids: Option<&str>, filter_ids: Option<&str>, barcode_asset_id: Option<i64>, image_asset_id: Option<i64>, image_asset_id1: Option<i64>, image_asset_id2: Option<i64>, image_asset_id3: Option<i64>, image_asset_id4: Option<i64>, image_asset_id5: Option<i64>, publisher: Option<&str>, redeemable_start: Option<i64>, redeemable_end: Option<i64>, condition_type: Option<&str>, isbn: Option<&str>, asin: Option<&str>, catalog_numbers: Option<&str>, parental_rating: Option<&str>, availability_date: Option<i64>, media_type: Option<&str>, duration: Option<i32>, author: Option<&str>, release_date: Option<i64>, collection_ids: Option<&str>, availability: Option<&str>, availability_summary: Option<&str>) -> Result<models::MediaOfferResponse, Error<CreateMediaError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_id = account_id;
    let p_query_title = title;
    let p_query_barcode_type = barcode_type;
    let p_query_no_expiration = no_expiration;
    let p_query_available_limit = available_limit;
    let p_query_available_limit_per_user = available_limit_per_user;
    let p_query_added_limit = added_limit;
    let p_query_view_limit = view_limit;
    let p_query_max_prints = max_prints;
    let p_query_ticket_price = ticket_price;
    let p_query_full_price = full_price;
    let p_query_discount_price = discount_price;
    let p_query_special_offer_type = special_offer_type;
    let p_query_offer_visibility = offer_visibility;
    let p_query_active = active;
    let p_query_retailer_location_ids = retailer_location_ids;
    let p_query_sub_title = sub_title;
    let p_query_details = details;
    let p_query_sub_details = sub_details;
    let p_query_fine_print = fine_print;
    let p_query_barcode_entry = barcode_entry;
    let p_query_external_redeem_options = external_redeem_options;
    let p_query_external_url = external_url;
    let p_query_tickets_reward_type = tickets_reward_type;
    let p_query_tickets_reward = tickets_reward;
    let p_query_activated = activated;
    let p_query_expires = expires;
    let p_query_ticket_price_type = ticket_price_type;
    let p_query_show_remaining = show_remaining;
    let p_query_show_redeemed = show_redeemed;
    let p_query_replaced = replaced;
    let p_query_featured = featured;
    let p_query_category_ids = category_ids;
    let p_query_filter_ids = filter_ids;
    let p_query_barcode_asset_id = barcode_asset_id;
    let p_query_image_asset_id = image_asset_id;
    let p_query_image_asset_id1 = image_asset_id1;
    let p_query_image_asset_id2 = image_asset_id2;
    let p_query_image_asset_id3 = image_asset_id3;
    let p_query_image_asset_id4 = image_asset_id4;
    let p_query_image_asset_id5 = image_asset_id5;
    let p_query_publisher = publisher;
    let p_query_redeemable_start = redeemable_start;
    let p_query_redeemable_end = redeemable_end;
    let p_query_condition_type = condition_type;
    let p_query_isbn = isbn;
    let p_query_asin = asin;
    let p_query_catalog_numbers = catalog_numbers;
    let p_query_parental_rating = parental_rating;
    let p_query_availability_date = availability_date;
    let p_query_media_type = media_type;
    let p_query_duration = duration;
    let p_query_author = author;
    let p_query_release_date = release_date;
    let p_query_collection_ids = collection_ids;
    let p_query_availability = availability;
    let p_query_availability_summary = availability_summary;

    let uri_str = format!("{}/media/create", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    if let Some(ref param_value) = p_query_retailer_location_ids {
        req_builder = req_builder.query(&[("retailerLocationIds", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("title", &p_query_title.to_string())]);
    if let Some(ref param_value) = p_query_sub_title {
        req_builder = req_builder.query(&[("subTitle", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_details {
        req_builder = req_builder.query(&[("details", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sub_details {
        req_builder = req_builder.query(&[("subDetails", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_fine_print {
        req_builder = req_builder.query(&[("finePrint", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("barcodeType", &p_query_barcode_type.to_string())]);
    if let Some(ref param_value) = p_query_barcode_entry {
        req_builder = req_builder.query(&[("barcodeEntry", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_external_redeem_options {
        req_builder = req_builder.query(&[("externalRedeemOptions", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_external_url {
        req_builder = req_builder.query(&[("externalUrl", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_tickets_reward_type {
        req_builder = req_builder.query(&[("ticketsRewardType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_tickets_reward {
        req_builder = req_builder.query(&[("ticketsReward", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_activated {
        req_builder = req_builder.query(&[("activated", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_expires {
        req_builder = req_builder.query(&[("expires", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("noExpiration", &p_query_no_expiration.to_string())]);
    req_builder = req_builder.query(&[("availableLimit", &p_query_available_limit.to_string())]);
    req_builder = req_builder.query(&[("availableLimitPerUser", &p_query_available_limit_per_user.to_string())]);
    req_builder = req_builder.query(&[("addedLimit", &p_query_added_limit.to_string())]);
    req_builder = req_builder.query(&[("viewLimit", &p_query_view_limit.to_string())]);
    req_builder = req_builder.query(&[("maxPrints", &p_query_max_prints.to_string())]);
    if let Some(ref param_value) = p_query_ticket_price_type {
        req_builder = req_builder.query(&[("ticketPriceType", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("ticketPrice", &p_query_ticket_price.to_string())]);
    req_builder = req_builder.query(&[("fullPrice", &p_query_full_price.to_string())]);
    req_builder = req_builder.query(&[("discountPrice", &p_query_discount_price.to_string())]);
    if let Some(ref param_value) = p_query_show_remaining {
        req_builder = req_builder.query(&[("showRemaining", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_show_redeemed {
        req_builder = req_builder.query(&[("showRedeemed", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_replaced {
        req_builder = req_builder.query(&[("replaced", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_featured {
        req_builder = req_builder.query(&[("featured", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("specialOfferType", &p_query_special_offer_type.to_string())]);
    req_builder = req_builder.query(&[("offerVisibility", &p_query_offer_visibility.to_string())]);
    if let Some(ref param_value) = p_query_category_ids {
        req_builder = req_builder.query(&[("categoryIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_ids {
        req_builder = req_builder.query(&[("filterIds", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("active", &p_query_active.to_string())]);
    if let Some(ref param_value) = p_query_barcode_asset_id {
        req_builder = req_builder.query(&[("barcodeAssetId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_image_asset_id {
        req_builder = req_builder.query(&[("imageAssetId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_image_asset_id1 {
        req_builder = req_builder.query(&[("imageAssetId1", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_image_asset_id2 {
        req_builder = req_builder.query(&[("imageAssetId2", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_image_asset_id3 {
        req_builder = req_builder.query(&[("imageAssetId3", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_image_asset_id4 {
        req_builder = req_builder.query(&[("imageAssetId4", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_image_asset_id5 {
        req_builder = req_builder.query(&[("imageAssetId5", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_publisher {
        req_builder = req_builder.query(&[("publisher", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_redeemable_start {
        req_builder = req_builder.query(&[("redeemableStart", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_redeemable_end {
        req_builder = req_builder.query(&[("redeemableEnd", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_condition_type {
        req_builder = req_builder.query(&[("conditionType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isbn {
        req_builder = req_builder.query(&[("isbn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_asin {
        req_builder = req_builder.query(&[("asin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_catalog_numbers {
        req_builder = req_builder.query(&[("catalogNumbers", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_parental_rating {
        req_builder = req_builder.query(&[("parentalRating", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_availability_date {
        req_builder = req_builder.query(&[("availabilityDate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_media_type {
        req_builder = req_builder.query(&[("mediaType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_duration {
        req_builder = req_builder.query(&[("duration", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_author {
        req_builder = req_builder.query(&[("author", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_release_date {
        req_builder = req_builder.query(&[("releaseDate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_collection_ids {
        req_builder = req_builder.query(&[("collectionIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_availability {
        req_builder = req_builder.query(&[("availability", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_availability_summary {
        req_builder = req_builder.query(&[("availabilitySummary", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MediaOfferResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MediaOfferResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateMediaError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete a media offering that the user has permissions to.
pub async fn delete_media(configuration: &configuration::Configuration, account_id: i64, media_id: i64) -> Result<models::SirqulResponse, Error<DeleteMediaError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_id = account_id;
    let p_query_media_id = media_id;

    let uri_str = format!("{}/media/delete", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("mediaId", &p_query_media_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SirqulResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SirqulResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteMediaError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a media offering.
pub async fn get_media(configuration: &configuration::Configuration, account_id: i64, media_id: i64) -> Result<models::MediaOfferResponse, Error<GetMediaError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_id = account_id;
    let p_query_media_id = media_id;

    let uri_str = format!("{}/media/get", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("mediaId", &p_query_media_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MediaOfferResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MediaOfferResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetMediaError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Searches on events that the account has access to.
pub async fn search_media(configuration: &configuration::Configuration, account_id: i64, active_only: bool, sort_field: &str, descending: bool, keyword: Option<&str>, category_ids: Option<&str>, filter_ids: Option<&str>, start: Option<i32>, limit: Option<i32>) -> Result<Vec<models::MediaOfferResponse>, Error<SearchMediaError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_id = account_id;
    let p_query_active_only = active_only;
    let p_query_sort_field = sort_field;
    let p_query_descending = descending;
    let p_query_keyword = keyword;
    let p_query_category_ids = category_ids;
    let p_query_filter_ids = filter_ids;
    let p_query_start = start;
    let p_query_limit = limit;

    let uri_str = format!("{}/media/search", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    if let Some(ref param_value) = p_query_keyword {
        req_builder = req_builder.query(&[("keyword", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("activeOnly", &p_query_active_only.to_string())]);
    if let Some(ref param_value) = p_query_category_ids {
        req_builder = req_builder.query(&[("categoryIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_ids {
        req_builder = req_builder.query(&[("filterIds", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("sortField", &p_query_sort_field.to_string())]);
    req_builder = req_builder.query(&[("descending", &p_query_descending.to_string())]);
    if let Some(ref param_value) = p_query_start {
        req_builder = req_builder.query(&[("start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::MediaOfferResponse&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::MediaOfferResponse&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchMediaError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update a media offering.
pub async fn update_media(configuration: &configuration::Configuration, account_id: i64, media_id: i64, retailer_location_ids: Option<&str>, offer_locations: Option<&str>, title: Option<&str>, sub_title: Option<&str>, details: Option<&str>, sub_details: Option<&str>, fine_print: Option<&str>, barcode_type: Option<&str>, barcode_entry: Option<&str>, external_redeem_options: Option<&str>, external_url: Option<&str>, tickets_reward_type: Option<&str>, tickets_reward: Option<i64>, activated: Option<i64>, expires: Option<i64>, no_expiration: Option<bool>, available_limit: Option<i32>, available_limit_per_user: Option<i32>, added_limit: Option<i32>, view_limit: Option<i32>, max_prints: Option<i32>, ticket_price_type: Option<&str>, ticket_price: Option<i64>, full_price: Option<f64>, discount_price: Option<f64>, show_remaining: Option<bool>, show_redeemed: Option<bool>, replaced: Option<bool>, featured: Option<bool>, special_offer_type: Option<&str>, offer_visibility: Option<&str>, category_ids: Option<&str>, filter_ids: Option<&str>, active: Option<bool>, barcode_asset_id: Option<i64>, image_asset_id: Option<i64>, image_asset_id1: Option<i64>, image_asset_id2: Option<i64>, image_asset_id3: Option<i64>, image_asset_id4: Option<i64>, image_asset_id5: Option<i64>, publisher: Option<&str>, redeemable_start: Option<i64>, redeemable_end: Option<i64>, condition_type: Option<&str>, isbn: Option<&str>, asin: Option<&str>, catalog_numbers: Option<&str>, availability_date: Option<i64>, parental_rating: Option<&str>, media_type: Option<&str>, duration: Option<i32>, author: Option<&str>, release_date: Option<i64>, collection_ids: Option<&str>, availability: Option<&str>, availability_summary: Option<&str>) -> Result<models::MediaOfferResponse, Error<UpdateMediaError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_id = account_id;
    let p_query_media_id = media_id;
    let p_query_retailer_location_ids = retailer_location_ids;
    let p_query_offer_locations = offer_locations;
    let p_query_title = title;
    let p_query_sub_title = sub_title;
    let p_query_details = details;
    let p_query_sub_details = sub_details;
    let p_query_fine_print = fine_print;
    let p_query_barcode_type = barcode_type;
    let p_query_barcode_entry = barcode_entry;
    let p_query_external_redeem_options = external_redeem_options;
    let p_query_external_url = external_url;
    let p_query_tickets_reward_type = tickets_reward_type;
    let p_query_tickets_reward = tickets_reward;
    let p_query_activated = activated;
    let p_query_expires = expires;
    let p_query_no_expiration = no_expiration;
    let p_query_available_limit = available_limit;
    let p_query_available_limit_per_user = available_limit_per_user;
    let p_query_added_limit = added_limit;
    let p_query_view_limit = view_limit;
    let p_query_max_prints = max_prints;
    let p_query_ticket_price_type = ticket_price_type;
    let p_query_ticket_price = ticket_price;
    let p_query_full_price = full_price;
    let p_query_discount_price = discount_price;
    let p_query_show_remaining = show_remaining;
    let p_query_show_redeemed = show_redeemed;
    let p_query_replaced = replaced;
    let p_query_featured = featured;
    let p_query_special_offer_type = special_offer_type;
    let p_query_offer_visibility = offer_visibility;
    let p_query_category_ids = category_ids;
    let p_query_filter_ids = filter_ids;
    let p_query_active = active;
    let p_query_barcode_asset_id = barcode_asset_id;
    let p_query_image_asset_id = image_asset_id;
    let p_query_image_asset_id1 = image_asset_id1;
    let p_query_image_asset_id2 = image_asset_id2;
    let p_query_image_asset_id3 = image_asset_id3;
    let p_query_image_asset_id4 = image_asset_id4;
    let p_query_image_asset_id5 = image_asset_id5;
    let p_query_publisher = publisher;
    let p_query_redeemable_start = redeemable_start;
    let p_query_redeemable_end = redeemable_end;
    let p_query_condition_type = condition_type;
    let p_query_isbn = isbn;
    let p_query_asin = asin;
    let p_query_catalog_numbers = catalog_numbers;
    let p_query_availability_date = availability_date;
    let p_query_parental_rating = parental_rating;
    let p_query_media_type = media_type;
    let p_query_duration = duration;
    let p_query_author = author;
    let p_query_release_date = release_date;
    let p_query_collection_ids = collection_ids;
    let p_query_availability = availability;
    let p_query_availability_summary = availability_summary;

    let uri_str = format!("{}/media/update", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("mediaId", &p_query_media_id.to_string())]);
    if let Some(ref param_value) = p_query_retailer_location_ids {
        req_builder = req_builder.query(&[("retailerLocationIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offer_locations {
        req_builder = req_builder.query(&[("offerLocations", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_title {
        req_builder = req_builder.query(&[("title", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sub_title {
        req_builder = req_builder.query(&[("subTitle", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_details {
        req_builder = req_builder.query(&[("details", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sub_details {
        req_builder = req_builder.query(&[("subDetails", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_fine_print {
        req_builder = req_builder.query(&[("finePrint", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_barcode_type {
        req_builder = req_builder.query(&[("barcodeType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_barcode_entry {
        req_builder = req_builder.query(&[("barcodeEntry", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_external_redeem_options {
        req_builder = req_builder.query(&[("externalRedeemOptions", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_external_url {
        req_builder = req_builder.query(&[("externalUrl", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_tickets_reward_type {
        req_builder = req_builder.query(&[("ticketsRewardType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_tickets_reward {
        req_builder = req_builder.query(&[("ticketsReward", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_activated {
        req_builder = req_builder.query(&[("activated", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_expires {
        req_builder = req_builder.query(&[("expires", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_no_expiration {
        req_builder = req_builder.query(&[("noExpiration", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_available_limit {
        req_builder = req_builder.query(&[("availableLimit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_available_limit_per_user {
        req_builder = req_builder.query(&[("availableLimitPerUser", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_added_limit {
        req_builder = req_builder.query(&[("addedLimit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_view_limit {
        req_builder = req_builder.query(&[("viewLimit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_max_prints {
        req_builder = req_builder.query(&[("maxPrints", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ticket_price_type {
        req_builder = req_builder.query(&[("ticketPriceType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ticket_price {
        req_builder = req_builder.query(&[("ticketPrice", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_full_price {
        req_builder = req_builder.query(&[("fullPrice", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_discount_price {
        req_builder = req_builder.query(&[("discountPrice", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_show_remaining {
        req_builder = req_builder.query(&[("showRemaining", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_show_redeemed {
        req_builder = req_builder.query(&[("showRedeemed", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_replaced {
        req_builder = req_builder.query(&[("replaced", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_featured {
        req_builder = req_builder.query(&[("featured", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_special_offer_type {
        req_builder = req_builder.query(&[("specialOfferType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offer_visibility {
        req_builder = req_builder.query(&[("offerVisibility", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_category_ids {
        req_builder = req_builder.query(&[("categoryIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_ids {
        req_builder = req_builder.query(&[("filterIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_active {
        req_builder = req_builder.query(&[("active", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_barcode_asset_id {
        req_builder = req_builder.query(&[("barcodeAssetId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_image_asset_id {
        req_builder = req_builder.query(&[("imageAssetId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_image_asset_id1 {
        req_builder = req_builder.query(&[("imageAssetId1", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_image_asset_id2 {
        req_builder = req_builder.query(&[("imageAssetId2", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_image_asset_id3 {
        req_builder = req_builder.query(&[("imageAssetId3", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_image_asset_id4 {
        req_builder = req_builder.query(&[("imageAssetId4", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_image_asset_id5 {
        req_builder = req_builder.query(&[("imageAssetId5", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_publisher {
        req_builder = req_builder.query(&[("publisher", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_redeemable_start {
        req_builder = req_builder.query(&[("redeemableStart", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_redeemable_end {
        req_builder = req_builder.query(&[("redeemableEnd", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_condition_type {
        req_builder = req_builder.query(&[("conditionType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_isbn {
        req_builder = req_builder.query(&[("isbn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_asin {
        req_builder = req_builder.query(&[("asin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_catalog_numbers {
        req_builder = req_builder.query(&[("catalogNumbers", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_availability_date {
        req_builder = req_builder.query(&[("availabilityDate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_parental_rating {
        req_builder = req_builder.query(&[("parentalRating", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_media_type {
        req_builder = req_builder.query(&[("mediaType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_duration {
        req_builder = req_builder.query(&[("duration", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_author {
        req_builder = req_builder.query(&[("author", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_release_date {
        req_builder = req_builder.query(&[("releaseDate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_collection_ids {
        req_builder = req_builder.query(&[("collectionIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_availability {
        req_builder = req_builder.query(&[("availability", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_availability_summary {
        req_builder = req_builder.query(&[("availabilitySummary", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MediaOfferResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MediaOfferResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateMediaError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

