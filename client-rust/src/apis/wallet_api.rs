/*
 * Sirqul IoT Platform
 *
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`create_offer_transaction`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateOfferTransactionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_offer_transaction`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteOfferTransactionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_offer_transaction`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetOfferTransactionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`preview_offer_transaction`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PreviewOfferTransactionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_offer_transactions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchOfferTransactionsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_offer_transaction`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateOfferTransactionError {
    UnknownValue(serde_json::Value),
}


/// Adds offers to the wallet
pub async fn create_offer_transaction(configuration: &configuration::Configuration, version: f64, device_id: Option<&str>, account_id: Option<i64>, offer_id: Option<i64>, offer_location_id: Option<i64>, offer_cart: Option<&str>, promo_code: Option<&str>, currency_type: Option<&str>, use_points: Option<bool>, meta_data: Option<&str>, app_key: Option<&str>, status: Option<i32>) -> Result<Vec<models::OfferTransactionResponse>, Error<CreateOfferTransactionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_offer_id = offer_id;
    let p_query_offer_location_id = offer_location_id;
    let p_query_offer_cart = offer_cart;
    let p_query_promo_code = promo_code;
    let p_query_currency_type = currency_type;
    let p_query_use_points = use_points;
    let p_query_meta_data = meta_data;
    let p_query_app_key = app_key;
    let p_query_status = status;

    let uri_str = format!("{}/api/{version}/wallet/create", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offer_id {
        req_builder = req_builder.query(&[("offerId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offer_location_id {
        req_builder = req_builder.query(&[("offerLocationId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offer_cart {
        req_builder = req_builder.query(&[("offerCart", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_promo_code {
        req_builder = req_builder.query(&[("promoCode", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_currency_type {
        req_builder = req_builder.query(&[("currencyType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_use_points {
        req_builder = req_builder.query(&[("usePoints", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_meta_data {
        req_builder = req_builder.query(&[("metaData", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_key {
        req_builder = req_builder.query(&[("appKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_status {
        req_builder = req_builder.query(&[("status", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::OfferTransactionResponse&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::OfferTransactionResponse&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateOfferTransactionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Removes the transaction from the wallet by setting the deleted date to the current date/time.  Requires a valid account and transactionId.
pub async fn delete_offer_transaction(configuration: &configuration::Configuration, version: f64, transaction_id: i64, device_id: Option<&str>, account_id: Option<i64>) -> Result<models::SirqulResponse, Error<DeleteOfferTransactionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_transaction_id = transaction_id;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;

    let uri_str = format!("{}/api/{version}/wallet/delete", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("transactionId", &p_query_transaction_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SirqulResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SirqulResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteOfferTransactionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_offer_transaction(configuration: &configuration::Configuration, version: f64, transaction_id: i64, device_id: Option<&str>, account_id: Option<i64>, include_mission: Option<bool>, latitude: Option<f64>, longitude: Option<f64>, return_full_response: Option<bool>) -> Result<models::OfferTransactionResponse, Error<GetOfferTransactionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_transaction_id = transaction_id;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_include_mission = include_mission;
    let p_query_latitude = latitude;
    let p_query_longitude = longitude;
    let p_query_return_full_response = return_full_response;

    let uri_str = format!("{}/api/{version}/wallet/get", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("transactionId", &p_query_transaction_id.to_string())]);
    if let Some(ref param_value) = p_query_include_mission {
        req_builder = req_builder.query(&[("includeMission", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_latitude {
        req_builder = req_builder.query(&[("latitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_longitude {
        req_builder = req_builder.query(&[("longitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_return_full_response {
        req_builder = req_builder.query(&[("returnFullResponse", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OfferTransactionResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OfferTransactionResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetOfferTransactionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Preview the final cost of a transaction without charging the user
pub async fn preview_offer_transaction(configuration: &configuration::Configuration, version: f64, device_id: Option<&str>, account_id: Option<i64>, offer_id: Option<i64>, offer_location_id: Option<i64>, offer_cart: Option<&str>, promo_code: Option<&str>, currency_type: Option<&str>, use_points: Option<bool>, meta_data: Option<&str>, app_key: Option<&str>) -> Result<Vec<models::OfferTransactionResponse>, Error<PreviewOfferTransactionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_offer_id = offer_id;
    let p_query_offer_location_id = offer_location_id;
    let p_query_offer_cart = offer_cart;
    let p_query_promo_code = promo_code;
    let p_query_currency_type = currency_type;
    let p_query_use_points = use_points;
    let p_query_meta_data = meta_data;
    let p_query_app_key = app_key;

    let uri_str = format!("{}/api/{version}/wallet/preview", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offer_id {
        req_builder = req_builder.query(&[("offerId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offer_location_id {
        req_builder = req_builder.query(&[("offerLocationId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offer_cart {
        req_builder = req_builder.query(&[("offerCart", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_promo_code {
        req_builder = req_builder.query(&[("promoCode", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_currency_type {
        req_builder = req_builder.query(&[("currencyType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_use_points {
        req_builder = req_builder.query(&[("usePoints", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_meta_data {
        req_builder = req_builder.query(&[("metaData", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_key {
        req_builder = req_builder.query(&[("appKey", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::OfferTransactionResponse&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::OfferTransactionResponse&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PreviewOfferTransactionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Search on active offers currently in the user's wallet, or past offers the user has already redeemed.
pub async fn search_offer_transactions(configuration: &configuration::Configuration, version: f64, device_id: Option<&str>, account_id: Option<i64>, keyword: Option<&str>, retailer_id: Option<i64>, retailer_ids: Option<&str>, retailer_location_id: Option<i64>, retailer_location_ids: Option<&str>, exclude_retailer_location_ids: Option<&str>, offer_id: Option<i64>, offer_ids: Option<&str>, offer_location_id: Option<i64>, offer_location_ids: Option<&str>, offer_type: Option<&str>, offer_types: Option<&str>, special_offer_type: Option<&str>, special_offer_types: Option<&str>, category_ids: Option<&str>, filter_ids: Option<&str>, offer_audience_ids: Option<&str>, sort_field: Option<&str>, descending: Option<bool>, start: Option<i32>, limit: Option<i32>, latitude: Option<f64>, longitude: Option<f64>, redeemable_start_date: Option<i64>, redeemable_end_date: Option<i64>, filter_by_parent_offer: Option<bool>, started_since: Option<i64>, started_before: Option<i64>, ended_since: Option<i64>, ended_before: Option<i64>, redeemed: Option<bool>, statuses: Option<&str>, reservations_only: Option<bool>, active_only: Option<bool>, return_full_response: Option<bool>, recurring_started_since: Option<i64>, recurring_started_before: Option<i64>, recurring_expiration_since: Option<i64>, recurring_expiration_before: Option<i64>) -> Result<Vec<models::OfferTransactionResponse>, Error<SearchOfferTransactionsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_keyword = keyword;
    let p_query_retailer_id = retailer_id;
    let p_query_retailer_ids = retailer_ids;
    let p_query_retailer_location_id = retailer_location_id;
    let p_query_retailer_location_ids = retailer_location_ids;
    let p_query_exclude_retailer_location_ids = exclude_retailer_location_ids;
    let p_query_offer_id = offer_id;
    let p_query_offer_ids = offer_ids;
    let p_query_offer_location_id = offer_location_id;
    let p_query_offer_location_ids = offer_location_ids;
    let p_query_offer_type = offer_type;
    let p_query_offer_types = offer_types;
    let p_query_special_offer_type = special_offer_type;
    let p_query_special_offer_types = special_offer_types;
    let p_query_category_ids = category_ids;
    let p_query_filter_ids = filter_ids;
    let p_query_offer_audience_ids = offer_audience_ids;
    let p_query_sort_field = sort_field;
    let p_query_descending = descending;
    let p_query_start = start;
    let p_query_limit = limit;
    let p_query_latitude = latitude;
    let p_query_longitude = longitude;
    let p_query_redeemable_start_date = redeemable_start_date;
    let p_query_redeemable_end_date = redeemable_end_date;
    let p_query_filter_by_parent_offer = filter_by_parent_offer;
    let p_query_started_since = started_since;
    let p_query_started_before = started_before;
    let p_query_ended_since = ended_since;
    let p_query_ended_before = ended_before;
    let p_query_redeemed = redeemed;
    let p_query_statuses = statuses;
    let p_query_reservations_only = reservations_only;
    let p_query_active_only = active_only;
    let p_query_return_full_response = return_full_response;
    let p_query_recurring_started_since = recurring_started_since;
    let p_query_recurring_started_before = recurring_started_before;
    let p_query_recurring_expiration_since = recurring_expiration_since;
    let p_query_recurring_expiration_before = recurring_expiration_before;

    let uri_str = format!("{}/api/{version}/wallet/search", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_keyword {
        req_builder = req_builder.query(&[("keyword", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_retailer_id {
        req_builder = req_builder.query(&[("retailerId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_retailer_ids {
        req_builder = req_builder.query(&[("retailerIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_retailer_location_id {
        req_builder = req_builder.query(&[("retailerLocationId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_retailer_location_ids {
        req_builder = req_builder.query(&[("retailerLocationIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exclude_retailer_location_ids {
        req_builder = req_builder.query(&[("excludeRetailerLocationIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offer_id {
        req_builder = req_builder.query(&[("offerId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offer_ids {
        req_builder = req_builder.query(&[("offerIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offer_location_id {
        req_builder = req_builder.query(&[("offerLocationId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offer_location_ids {
        req_builder = req_builder.query(&[("offerLocationIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offer_type {
        req_builder = req_builder.query(&[("offerType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offer_types {
        req_builder = req_builder.query(&[("offerTypes", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_special_offer_type {
        req_builder = req_builder.query(&[("specialOfferType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_special_offer_types {
        req_builder = req_builder.query(&[("specialOfferTypes", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_category_ids {
        req_builder = req_builder.query(&[("categoryIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_ids {
        req_builder = req_builder.query(&[("filterIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offer_audience_ids {
        req_builder = req_builder.query(&[("offerAudienceIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_field {
        req_builder = req_builder.query(&[("sortField", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_descending {
        req_builder = req_builder.query(&[("descending", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start {
        req_builder = req_builder.query(&[("start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_latitude {
        req_builder = req_builder.query(&[("latitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_longitude {
        req_builder = req_builder.query(&[("longitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_redeemable_start_date {
        req_builder = req_builder.query(&[("redeemableStartDate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_redeemable_end_date {
        req_builder = req_builder.query(&[("redeemableEndDate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_by_parent_offer {
        req_builder = req_builder.query(&[("filterByParentOffer", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_started_since {
        req_builder = req_builder.query(&[("startedSince", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_started_before {
        req_builder = req_builder.query(&[("startedBefore", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ended_since {
        req_builder = req_builder.query(&[("endedSince", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ended_before {
        req_builder = req_builder.query(&[("endedBefore", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_redeemed {
        req_builder = req_builder.query(&[("redeemed", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_statuses {
        req_builder = req_builder.query(&[("statuses", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_reservations_only {
        req_builder = req_builder.query(&[("reservationsOnly", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_active_only {
        req_builder = req_builder.query(&[("activeOnly", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_return_full_response {
        req_builder = req_builder.query(&[("returnFullResponse", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_recurring_started_since {
        req_builder = req_builder.query(&[("recurringStartedSince", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_recurring_started_before {
        req_builder = req_builder.query(&[("recurringStartedBefore", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_recurring_expiration_since {
        req_builder = req_builder.query(&[("recurringExpirationSince", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_recurring_expiration_before {
        req_builder = req_builder.query(&[("recurringExpirationBefore", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::OfferTransactionResponse&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::OfferTransactionResponse&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchOfferTransactionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update offer status. The status values are: 0 - not redeemable, 1 - redeemable.  Not redeemable means the customer has received the offer but has not decided to use (or print) it yet.  Until they choose to do this the merchant cannot redeem the offer (has not been given permission yet).   Redeemable means the customer has chosen to use the offer and wishes to redeem it.  Redeemed means the merchant has accepted the offer and the given the customer its value, then marked it a used in the system.  This status change is handled by a merchant end point.
pub async fn update_offer_transaction(configuration: &configuration::Configuration, version: f64, transaction_id: i64, status: i32, device_id: Option<&str>, account_id: Option<i64>, offer_location_id: Option<i64>, currency_type: Option<&str>, use_points: Option<bool>, app_key: Option<&str>, latitude: Option<f64>, longitude: Option<f64>, meta_data: Option<&str>, return_full_response: Option<bool>, exception_membership_offer_ids: Option<&str>) -> Result<models::OfferTransactionResponse, Error<UpdateOfferTransactionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_transaction_id = transaction_id;
    let p_query_status = status;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_offer_location_id = offer_location_id;
    let p_query_currency_type = currency_type;
    let p_query_use_points = use_points;
    let p_query_app_key = app_key;
    let p_query_latitude = latitude;
    let p_query_longitude = longitude;
    let p_query_meta_data = meta_data;
    let p_query_return_full_response = return_full_response;
    let p_query_exception_membership_offer_ids = exception_membership_offer_ids;

    let uri_str = format!("{}/api/{version}/wallet/update", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("transactionId", &p_query_transaction_id.to_string())]);
    if let Some(ref param_value) = p_query_offer_location_id {
        req_builder = req_builder.query(&[("offerLocationId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_currency_type {
        req_builder = req_builder.query(&[("currencyType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_use_points {
        req_builder = req_builder.query(&[("usePoints", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_key {
        req_builder = req_builder.query(&[("appKey", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("status", &p_query_status.to_string())]);
    if let Some(ref param_value) = p_query_latitude {
        req_builder = req_builder.query(&[("latitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_longitude {
        req_builder = req_builder.query(&[("longitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_meta_data {
        req_builder = req_builder.query(&[("metaData", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_return_full_response {
        req_builder = req_builder.query(&[("returnFullResponse", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_exception_membership_offer_ids {
        req_builder = req_builder.query(&[("exceptionMembershipOfferIds", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OfferTransactionResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OfferTransactionResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateOfferTransactionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

