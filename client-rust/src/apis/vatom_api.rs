/*
 * Sirqul IoT Platform
 *
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`create_following`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateFollowingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_space`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSpaceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_vatom_event`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateVatomEventError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_following`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteFollowingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_points_balance`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeletePointsBalanceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_space`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSpaceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_vatom_event`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteVatomEventError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_vatom_nft`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteVatomNftError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`execute_action_on_nft`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ExecuteActionOnNftError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`geomap_search`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GeomapSearchError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_business_behaviors`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetBusinessBehaviorsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_business_coins_balance`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetBusinessCoinsBalanceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_business_ids`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetBusinessIdsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_business_info`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetBusinessInfoError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_business_users`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetBusinessUsersError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_campaign_group_entities`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetCampaignGroupEntitiesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_campaign_group_rules`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetCampaignGroupRulesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_campaign_group_stats`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetCampaignGroupStatsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_campaign_info`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetCampaignInfoError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_event_guest_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetEventGuestListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_inventory`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetInventoryError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_my_following`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMyFollowingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_points_balance`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetPointsBalanceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_points_balance_as_business`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetPointsBalanceAsBusinessError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_space`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSpaceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_user_coins_as_business`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUserCoinsAsBusinessError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_user_coins_balance`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUserCoinsBalanceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_user_followers`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUserFollowersError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_user_following`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUserFollowingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_user_info`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUserInfoError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_user_profile`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUserProfileError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_vatom_event`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetVatomEventError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_vatom_nft`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetVatomNftError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_communities`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListCommunitiesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_events`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListEventsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_spaces`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListSpacesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_user_coin_transactions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListUserCoinTransactionsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_user_coin_transactions_as_business`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListUserCoinTransactionsAsBusinessError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`perform_action_on_nft`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PerformActionOnNftError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`redeem_nft`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RedeemNftError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`redeem_user_coins_as_business`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RedeemUserCoinsAsBusinessError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_businesses`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchBusinessesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_campaign_groups`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchCampaignGroupsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_identities`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchIdentitiesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_inventory`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchInventoryError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`send_nft`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SendNftError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`set_points_balance_as_business`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SetPointsBalanceAsBusinessError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`transfer_user_coins`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TransferUserCoinsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_business_coins`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateBusinessCoinsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_event_guest_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateEventGuestListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_space`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateSpaceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_user_coins_as_business`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateUserCoinsAsBusinessError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_user_profile`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateUserProfileError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_vatom_event`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateVatomEventError {
    UnknownValue(serde_json::Value),
}


/// Create following.
pub async fn create_following(configuration: &configuration::Configuration, account_id: i64, vatom_parameters: &str, return_raw_response: Option<bool>) -> Result<(), Error<CreateFollowingError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_id = account_id;
    let p_query_vatom_parameters = vatom_parameters;
    let p_query_return_raw_response = return_raw_response;

    let uri_str = format!("{}/vatom/me/rels/following/create", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("vatomParameters", &p_query_vatom_parameters.to_string())]);
    if let Some(ref param_value) = p_query_return_raw_response {
        req_builder = req_builder.query(&[("returnRawResponse", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateFollowingError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create a Vatom space.
pub async fn create_space(configuration: &configuration::Configuration, account_id: i64, app_key: &str, vatom_parameters: &str, return_raw_response: Option<bool>) -> Result<(), Error<CreateSpaceError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_id = account_id;
    let p_query_app_key = app_key;
    let p_query_vatom_parameters = vatom_parameters;
    let p_query_return_raw_response = return_raw_response;

    let uri_str = format!("{}/vatom/b/spaces/create", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("appKey", &p_query_app_key.to_string())]);
    req_builder = req_builder.query(&[("vatomParameters", &p_query_vatom_parameters.to_string())]);
    if let Some(ref param_value) = p_query_return_raw_response {
        req_builder = req_builder.query(&[("returnRawResponse", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateSpaceError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create a Vatom event.
pub async fn create_vatom_event(configuration: &configuration::Configuration, account_id: i64, app_key: &str, vatom_parameters: &str, return_raw_response: Option<bool>) -> Result<(), Error<CreateVatomEventError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_id = account_id;
    let p_query_app_key = app_key;
    let p_query_vatom_parameters = vatom_parameters;
    let p_query_return_raw_response = return_raw_response;

    let uri_str = format!("{}/vatom/b/events/create", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("appKey", &p_query_app_key.to_string())]);
    req_builder = req_builder.query(&[("vatomParameters", &p_query_vatom_parameters.to_string())]);
    if let Some(ref param_value) = p_query_return_raw_response {
        req_builder = req_builder.query(&[("returnRawResponse", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateVatomEventError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete following.
pub async fn delete_following(configuration: &configuration::Configuration, account_id: i64, vatom_rels_key: &str, return_raw_response: Option<bool>) -> Result<(), Error<DeleteFollowingError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_id = account_id;
    let p_query_vatom_rels_key = vatom_rels_key;
    let p_query_return_raw_response = return_raw_response;

    let uri_str = format!("{}/vatom/me/rels/following/delete", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("vatomRelsKey", &p_query_vatom_rels_key.to_string())]);
    if let Some(ref param_value) = p_query_return_raw_response {
        req_builder = req_builder.query(&[("returnRawResponse", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteFollowingError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Reset All Points Balance.
pub async fn delete_points_balance(configuration: &configuration::Configuration, account_id: i64, app_key: &str, vatom_campaign_id: &str, return_raw_response: Option<bool>) -> Result<(), Error<DeletePointsBalanceError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_id = account_id;
    let p_query_app_key = app_key;
    let p_query_vatom_campaign_id = vatom_campaign_id;
    let p_query_return_raw_response = return_raw_response;

    let uri_str = format!("{}/vatom/b/campaign/points/delete", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("appKey", &p_query_app_key.to_string())]);
    req_builder = req_builder.query(&[("vatomCampaignId", &p_query_vatom_campaign_id.to_string())]);
    if let Some(ref param_value) = p_query_return_raw_response {
        req_builder = req_builder.query(&[("returnRawResponse", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeletePointsBalanceError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete a Vatom space.
pub async fn delete_space(configuration: &configuration::Configuration, account_id: i64, app_key: &str, vatom_space_id: &str, return_raw_response: Option<bool>) -> Result<(), Error<DeleteSpaceError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_id = account_id;
    let p_query_app_key = app_key;
    let p_query_vatom_space_id = vatom_space_id;
    let p_query_return_raw_response = return_raw_response;

    let uri_str = format!("{}/vatom/b/spaces/delete", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("appKey", &p_query_app_key.to_string())]);
    req_builder = req_builder.query(&[("vatomSpaceId", &p_query_vatom_space_id.to_string())]);
    if let Some(ref param_value) = p_query_return_raw_response {
        req_builder = req_builder.query(&[("returnRawResponse", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteSpaceError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete a Vatom event.
pub async fn delete_vatom_event(configuration: &configuration::Configuration, account_id: i64, app_key: &str, vatom_event_id: &str, return_raw_response: Option<bool>) -> Result<(), Error<DeleteVatomEventError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_id = account_id;
    let p_query_app_key = app_key;
    let p_query_vatom_event_id = vatom_event_id;
    let p_query_return_raw_response = return_raw_response;

    let uri_str = format!("{}/vatom/b/events/delete", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("appKey", &p_query_app_key.to_string())]);
    req_builder = req_builder.query(&[("vatomEventId", &p_query_vatom_event_id.to_string())]);
    if let Some(ref param_value) = p_query_return_raw_response {
        req_builder = req_builder.query(&[("returnRawResponse", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteVatomEventError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete Vatom NFT
pub async fn delete_vatom_nft(configuration: &configuration::Configuration, account_id: i64, vatom_id: &str, return_raw_response: Option<bool>) -> Result<(), Error<DeleteVatomNftError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_id = account_id;
    let p_query_vatom_id = vatom_id;
    let p_query_return_raw_response = return_raw_response;

    let uri_str = format!("{}/vatom/vatoms/delete", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("vatomId", &p_query_vatom_id.to_string())]);
    if let Some(ref param_value) = p_query_return_raw_response {
        req_builder = req_builder.query(&[("returnRawResponse", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteVatomNftError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Execute Action on NFT.
pub async fn execute_action_on_nft(configuration: &configuration::Configuration, account_id: i64, vatom_id: &str, vatom_parameters: &str, return_raw_response: Option<bool>) -> Result<(), Error<ExecuteActionOnNftError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_id = account_id;
    let p_query_vatom_id = vatom_id;
    let p_query_vatom_parameters = vatom_parameters;
    let p_query_return_raw_response = return_raw_response;

    let uri_str = format!("{}/vatom/vatoms/execute-action", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("vatomId", &p_query_vatom_id.to_string())]);
    req_builder = req_builder.query(&[("vatomParameters", &p_query_vatom_parameters.to_string())]);
    if let Some(ref param_value) = p_query_return_raw_response {
        req_builder = req_builder.query(&[("returnRawResponse", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ExecuteActionOnNftError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Search Vatom Geo Map
pub async fn geomap_search(configuration: &configuration::Configuration, account_id: i64, vatom_parameters: &str, return_raw_response: Option<bool>) -> Result<(), Error<GeomapSearchError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_id = account_id;
    let p_query_vatom_parameters = vatom_parameters;
    let p_query_return_raw_response = return_raw_response;

    let uri_str = format!("{}/vatom/vatoms/geo-map/search", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("vatomParameters", &p_query_vatom_parameters.to_string())]);
    if let Some(ref param_value) = p_query_return_raw_response {
        req_builder = req_builder.query(&[("returnRawResponse", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<GeomapSearchError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets the behaviors of a business.
pub async fn get_business_behaviors(configuration: &configuration::Configuration, account_id: i64, app_key: &str, return_raw_response: Option<bool>) -> Result<(), Error<GetBusinessBehaviorsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_id = account_id;
    let p_query_app_key = app_key;
    let p_query_return_raw_response = return_raw_response;

    let uri_str = format!("{}/vatom/b/behaviors", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("appKey", &p_query_app_key.to_string())]);
    if let Some(ref param_value) = p_query_return_raw_response {
        req_builder = req_builder.query(&[("returnRawResponse", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<GetBusinessBehaviorsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the coins for a Businesss.
pub async fn get_business_coins_balance(configuration: &configuration::Configuration, account_id: i64, app_key: &str, return_raw_response: Option<bool>) -> Result<(), Error<GetBusinessCoinsBalanceError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_id = account_id;
    let p_query_app_key = app_key;
    let p_query_return_raw_response = return_raw_response;

    let uri_str = format!("{}/vatom/b/coins/get", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("appKey", &p_query_app_key.to_string())]);
    if let Some(ref param_value) = p_query_return_raw_response {
        req_builder = req_builder.query(&[("returnRawResponse", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<GetBusinessCoinsBalanceError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the business ids the logged in user has access to.
pub async fn get_business_ids(configuration: &configuration::Configuration, account_id: i64, return_raw_response: Option<bool>) -> Result<(), Error<GetBusinessIdsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_id = account_id;
    let p_query_return_raw_response = return_raw_response;

    let uri_str = format!("{}/vatom/me/businesses", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    if let Some(ref param_value) = p_query_return_raw_response {
        req_builder = req_builder.query(&[("returnRawResponse", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<GetBusinessIdsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets the business info tied to this account.
pub async fn get_business_info(configuration: &configuration::Configuration, account_id: i64, app_key: &str, vatom_parameters: Option<&str>, return_raw_response: Option<bool>) -> Result<(), Error<GetBusinessInfoError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_id = account_id;
    let p_query_app_key = app_key;
    let p_query_vatom_parameters = vatom_parameters;
    let p_query_return_raw_response = return_raw_response;

    let uri_str = format!("{}/vatom/b/get", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("appKey", &p_query_app_key.to_string())]);
    if let Some(ref param_value) = p_query_vatom_parameters {
        req_builder = req_builder.query(&[("vatomParameters", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_return_raw_response {
        req_builder = req_builder.query(&[("returnRawResponse", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<GetBusinessInfoError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets the users of a business.
pub async fn get_business_users(configuration: &configuration::Configuration, account_id: i64, app_key: &str, return_raw_response: Option<bool>) -> Result<(), Error<GetBusinessUsersError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_id = account_id;
    let p_query_app_key = app_key;
    let p_query_return_raw_response = return_raw_response;

    let uri_str = format!("{}/vatom/b/users", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("appKey", &p_query_app_key.to_string())]);
    if let Some(ref param_value) = p_query_return_raw_response {
        req_builder = req_builder.query(&[("returnRawResponse", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<GetBusinessUsersError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get campaign group entities.
pub async fn get_campaign_group_entities(configuration: &configuration::Configuration, account_id: i64, app_key: &str, vatom_campaign_id: &str, return_raw_response: Option<bool>) -> Result<(), Error<GetCampaignGroupEntitiesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_id = account_id;
    let p_query_app_key = app_key;
    let p_query_vatom_campaign_id = vatom_campaign_id;
    let p_query_return_raw_response = return_raw_response;

    let uri_str = format!("{}/vatom/b/campaign-groups/entities", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("appKey", &p_query_app_key.to_string())]);
    req_builder = req_builder.query(&[("vatomCampaignId", &p_query_vatom_campaign_id.to_string())]);
    if let Some(ref param_value) = p_query_return_raw_response {
        req_builder = req_builder.query(&[("returnRawResponse", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<GetCampaignGroupEntitiesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get campaign group rules.
pub async fn get_campaign_group_rules(configuration: &configuration::Configuration, account_id: i64, app_key: &str, vatom_campaign_id: &str, return_raw_response: Option<bool>) -> Result<(), Error<GetCampaignGroupRulesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_id = account_id;
    let p_query_app_key = app_key;
    let p_query_vatom_campaign_id = vatom_campaign_id;
    let p_query_return_raw_response = return_raw_response;

    let uri_str = format!("{}/vatom/b/campaign-groups/rules", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("appKey", &p_query_app_key.to_string())]);
    req_builder = req_builder.query(&[("vatomCampaignId", &p_query_vatom_campaign_id.to_string())]);
    if let Some(ref param_value) = p_query_return_raw_response {
        req_builder = req_builder.query(&[("returnRawResponse", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<GetCampaignGroupRulesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get campaign group stats.
pub async fn get_campaign_group_stats(configuration: &configuration::Configuration, account_id: i64, app_key: &str, vatom_campaign_id: &str, return_raw_response: Option<bool>) -> Result<(), Error<GetCampaignGroupStatsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_id = account_id;
    let p_query_app_key = app_key;
    let p_query_vatom_campaign_id = vatom_campaign_id;
    let p_query_return_raw_response = return_raw_response;

    let uri_str = format!("{}/vatom/b/campaign-groups/stats", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("appKey", &p_query_app_key.to_string())]);
    req_builder = req_builder.query(&[("vatomCampaignId", &p_query_vatom_campaign_id.to_string())]);
    if let Some(ref param_value) = p_query_return_raw_response {
        req_builder = req_builder.query(&[("returnRawResponse", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<GetCampaignGroupStatsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets the info on a campaign.
pub async fn get_campaign_info(configuration: &configuration::Configuration, account_id: i64, app_key: &str, vatom_campaign_id: &str, return_raw_response: Option<bool>) -> Result<(), Error<GetCampaignInfoError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_id = account_id;
    let p_query_app_key = app_key;
    let p_query_vatom_campaign_id = vatom_campaign_id;
    let p_query_return_raw_response = return_raw_response;

    let uri_str = format!("{}/vatom/b/campaign-groups/get", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("appKey", &p_query_app_key.to_string())]);
    req_builder = req_builder.query(&[("vatomCampaignId", &p_query_vatom_campaign_id.to_string())]);
    if let Some(ref param_value) = p_query_return_raw_response {
        req_builder = req_builder.query(&[("returnRawResponse", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<GetCampaignInfoError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets the guest list of an event.
pub async fn get_event_guest_list(configuration: &configuration::Configuration, account_id: i64, app_key: &str, vatom_event_id: &str, return_raw_response: Option<bool>) -> Result<(), Error<GetEventGuestListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_id = account_id;
    let p_query_app_key = app_key;
    let p_query_vatom_event_id = vatom_event_id;
    let p_query_return_raw_response = return_raw_response;

    let uri_str = format!("{}/vatom/b/events/guests/get", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("appKey", &p_query_app_key.to_string())]);
    req_builder = req_builder.query(&[("vatomEventId", &p_query_vatom_event_id.to_string())]);
    if let Some(ref param_value) = p_query_return_raw_response {
        req_builder = req_builder.query(&[("returnRawResponse", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<GetEventGuestListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets the logged in user's Vatom Inventory.
pub async fn get_inventory(configuration: &configuration::Configuration, account_id: i64, vatom_parameters: &str, return_raw_response: Option<bool>) -> Result<(), Error<GetInventoryError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_id = account_id;
    let p_query_vatom_parameters = vatom_parameters;
    let p_query_return_raw_response = return_raw_response;

    let uri_str = format!("{}/vatom/me/inventory", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("vatomParameters", &p_query_vatom_parameters.to_string())]);
    if let Some(ref param_value) = p_query_return_raw_response {
        req_builder = req_builder.query(&[("returnRawResponse", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<GetInventoryError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get following.
pub async fn get_my_following(configuration: &configuration::Configuration, account_id: i64, return_raw_response: Option<bool>) -> Result<(), Error<GetMyFollowingError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_id = account_id;
    let p_query_return_raw_response = return_raw_response;

    let uri_str = format!("{}/vatom/me/rels/following", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    if let Some(ref param_value) = p_query_return_raw_response {
        req_builder = req_builder.query(&[("returnRawResponse", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<GetMyFollowingError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets the points balance of a Vatom user.
pub async fn get_points_balance(configuration: &configuration::Configuration, account_id: i64, vatom_user_id: &str, vatom_campaign_id: &str, return_raw_response: Option<bool>) -> Result<(), Error<GetPointsBalanceError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_id = account_id;
    let p_query_vatom_user_id = vatom_user_id;
    let p_query_vatom_campaign_id = vatom_campaign_id;
    let p_query_return_raw_response = return_raw_response;

    let uri_str = format!("{}/vatom/u/campaign/points/get", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("vatomUserId", &p_query_vatom_user_id.to_string())]);
    req_builder = req_builder.query(&[("vatomCampaignId", &p_query_vatom_campaign_id.to_string())]);
    if let Some(ref param_value) = p_query_return_raw_response {
        req_builder = req_builder.query(&[("returnRawResponse", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<GetPointsBalanceError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets the points balance of a Vatom user.
pub async fn get_points_balance_as_business(configuration: &configuration::Configuration, account_id: i64, app_key: &str, vatom_user_id: &str, vatom_campaign_id: &str, return_raw_response: Option<bool>) -> Result<(), Error<GetPointsBalanceAsBusinessError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_id = account_id;
    let p_query_app_key = app_key;
    let p_query_vatom_user_id = vatom_user_id;
    let p_query_vatom_campaign_id = vatom_campaign_id;
    let p_query_return_raw_response = return_raw_response;

    let uri_str = format!("{}/vatom/b/campaign/u/points/get", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("appKey", &p_query_app_key.to_string())]);
    req_builder = req_builder.query(&[("vatomUserId", &p_query_vatom_user_id.to_string())]);
    req_builder = req_builder.query(&[("vatomCampaignId", &p_query_vatom_campaign_id.to_string())]);
    if let Some(ref param_value) = p_query_return_raw_response {
        req_builder = req_builder.query(&[("returnRawResponse", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<GetPointsBalanceAsBusinessError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets the details of a space.
pub async fn get_space(configuration: &configuration::Configuration, account_id: i64, app_key: &str, vatom_space_id: &str, return_raw_response: Option<bool>) -> Result<(), Error<GetSpaceError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_id = account_id;
    let p_query_app_key = app_key;
    let p_query_vatom_space_id = vatom_space_id;
    let p_query_return_raw_response = return_raw_response;

    let uri_str = format!("{}/vatom/b/spaces/get", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("appKey", &p_query_app_key.to_string())]);
    req_builder = req_builder.query(&[("vatomSpaceId", &p_query_vatom_space_id.to_string())]);
    if let Some(ref param_value) = p_query_return_raw_response {
        req_builder = req_builder.query(&[("returnRawResponse", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSpaceError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the coins for a user (as a Business).
pub async fn get_user_coins_as_business(configuration: &configuration::Configuration, account_id: i64, vatom_user_id: &str, app_key: &str, return_raw_response: Option<bool>) -> Result<(), Error<GetUserCoinsAsBusinessError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_id = account_id;
    let p_query_vatom_user_id = vatom_user_id;
    let p_query_app_key = app_key;
    let p_query_return_raw_response = return_raw_response;

    let uri_str = format!("{}/vatom/b/users/coins/get", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("vatomUserId", &p_query_vatom_user_id.to_string())]);
    req_builder = req_builder.query(&[("appKey", &p_query_app_key.to_string())]);
    if let Some(ref param_value) = p_query_return_raw_response {
        req_builder = req_builder.query(&[("returnRawResponse", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<GetUserCoinsAsBusinessError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets the coins balance for a Vatom User.
pub async fn get_user_coins_balance(configuration: &configuration::Configuration, account_id: i64, vatom_user_id: &str, vatom_parameters: Option<&str>, return_raw_response: Option<bool>) -> Result<(), Error<GetUserCoinsBalanceError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_id = account_id;
    let p_query_vatom_user_id = vatom_user_id;
    let p_query_vatom_parameters = vatom_parameters;
    let p_query_return_raw_response = return_raw_response;

    let uri_str = format!("{}/vatom/u/coins/get", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("vatomUserId", &p_query_vatom_user_id.to_string())]);
    if let Some(ref param_value) = p_query_vatom_parameters {
        req_builder = req_builder.query(&[("vatomParameters", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_return_raw_response {
        req_builder = req_builder.query(&[("returnRawResponse", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<GetUserCoinsBalanceError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get user followers.
pub async fn get_user_followers(configuration: &configuration::Configuration, account_id: i64, vatom_user_id: &str, return_raw_response: Option<bool>) -> Result<(), Error<GetUserFollowersError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_id = account_id;
    let p_query_vatom_user_id = vatom_user_id;
    let p_query_return_raw_response = return_raw_response;

    let uri_str = format!("{}/vatom/users/rels/followers", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("vatomUserId", &p_query_vatom_user_id.to_string())]);
    if let Some(ref param_value) = p_query_return_raw_response {
        req_builder = req_builder.query(&[("returnRawResponse", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<GetUserFollowersError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get user following.
pub async fn get_user_following(configuration: &configuration::Configuration, account_id: i64, vatom_user_id: &str, return_raw_response: Option<bool>) -> Result<(), Error<GetUserFollowingError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_id = account_id;
    let p_query_vatom_user_id = vatom_user_id;
    let p_query_return_raw_response = return_raw_response;

    let uri_str = format!("{}/vatom/users/rels/following", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("vatomUserId", &p_query_vatom_user_id.to_string())]);
    if let Some(ref param_value) = p_query_return_raw_response {
        req_builder = req_builder.query(&[("returnRawResponse", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<GetUserFollowingError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a User's Info.
pub async fn get_user_info(configuration: &configuration::Configuration, account_id: i64, vatom_user_id: &str, return_raw_response: Option<bool>) -> Result<(), Error<GetUserInfoError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_id = account_id;
    let p_query_vatom_user_id = vatom_user_id;
    let p_query_return_raw_response = return_raw_response;

    let uri_str = format!("{}/vatom/user/get", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("vatomUserId", &p_query_vatom_user_id.to_string())]);
    if let Some(ref param_value) = p_query_return_raw_response {
        req_builder = req_builder.query(&[("returnRawResponse", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<GetUserInfoError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets the logged in user's profile in Vatom.
pub async fn get_user_profile(configuration: &configuration::Configuration, account_id: i64, return_raw_response: Option<bool>) -> Result<(), Error<GetUserProfileError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_id = account_id;
    let p_query_return_raw_response = return_raw_response;

    let uri_str = format!("{}/vatom/me/get", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    if let Some(ref param_value) = p_query_return_raw_response {
        req_builder = req_builder.query(&[("returnRawResponse", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<GetUserProfileError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets the details of a event.
pub async fn get_vatom_event(configuration: &configuration::Configuration, account_id: i64, app_key: &str, vatom_event_id: &str, return_raw_response: Option<bool>) -> Result<(), Error<GetVatomEventError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_id = account_id;
    let p_query_app_key = app_key;
    let p_query_vatom_event_id = vatom_event_id;
    let p_query_return_raw_response = return_raw_response;

    let uri_str = format!("{}/vatom/b/events/get", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("appKey", &p_query_app_key.to_string())]);
    req_builder = req_builder.query(&[("vatomEventId", &p_query_vatom_event_id.to_string())]);
    if let Some(ref param_value) = p_query_return_raw_response {
        req_builder = req_builder.query(&[("returnRawResponse", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<GetVatomEventError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get Vatom NFT Details
pub async fn get_vatom_nft(configuration: &configuration::Configuration, account_id: i64, vatom_id: &str, return_raw_response: Option<bool>) -> Result<(), Error<GetVatomNftError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_id = account_id;
    let p_query_vatom_id = vatom_id;
    let p_query_return_raw_response = return_raw_response;

    let uri_str = format!("{}/vatom/vatoms/get", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("vatomId", &p_query_vatom_id.to_string())]);
    if let Some(ref param_value) = p_query_return_raw_response {
        req_builder = req_builder.query(&[("returnRawResponse", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<GetVatomNftError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets the communities tied to a business.
pub async fn list_communities(configuration: &configuration::Configuration, account_id: i64, app_key: &str, vatom_parameters: Option<&str>, return_raw_response: Option<bool>) -> Result<(), Error<ListCommunitiesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_id = account_id;
    let p_query_app_key = app_key;
    let p_query_vatom_parameters = vatom_parameters;
    let p_query_return_raw_response = return_raw_response;

    let uri_str = format!("{}/vatom/b/communities/search", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("appKey", &p_query_app_key.to_string())]);
    if let Some(ref param_value) = p_query_vatom_parameters {
        req_builder = req_builder.query(&[("vatomParameters", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_return_raw_response {
        req_builder = req_builder.query(&[("returnRawResponse", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ListCommunitiesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets the events tied to a business.
pub async fn list_events(configuration: &configuration::Configuration, account_id: i64, app_key: &str, vatom_parameters: Option<&str>, return_raw_response: Option<bool>) -> Result<(), Error<ListEventsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_id = account_id;
    let p_query_app_key = app_key;
    let p_query_vatom_parameters = vatom_parameters;
    let p_query_return_raw_response = return_raw_response;

    let uri_str = format!("{}/vatom/b/events/search", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("appKey", &p_query_app_key.to_string())]);
    if let Some(ref param_value) = p_query_vatom_parameters {
        req_builder = req_builder.query(&[("vatomParameters", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_return_raw_response {
        req_builder = req_builder.query(&[("returnRawResponse", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ListEventsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets the spaces tied to a business.
pub async fn list_spaces(configuration: &configuration::Configuration, account_id: i64, app_key: &str, vatom_parameters: Option<&str>, return_raw_response: Option<bool>) -> Result<(), Error<ListSpacesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_id = account_id;
    let p_query_app_key = app_key;
    let p_query_vatom_parameters = vatom_parameters;
    let p_query_return_raw_response = return_raw_response;

    let uri_str = format!("{}/vatom/b/spaces/search", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("appKey", &p_query_app_key.to_string())]);
    if let Some(ref param_value) = p_query_vatom_parameters {
        req_builder = req_builder.query(&[("vatomParameters", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_return_raw_response {
        req_builder = req_builder.query(&[("returnRawResponse", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ListSpacesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets the logged in user's Vatom coin transactions.
pub async fn list_user_coin_transactions(configuration: &configuration::Configuration, account_id: i64, vatom_user_id: &str, vatom_parameters: Option<&str>, return_raw_response: Option<bool>) -> Result<(), Error<ListUserCoinTransactionsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_id = account_id;
    let p_query_vatom_user_id = vatom_user_id;
    let p_query_vatom_parameters = vatom_parameters;
    let p_query_return_raw_response = return_raw_response;

    let uri_str = format!("{}/vatom/u/coins/txns/search", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("vatomUserId", &p_query_vatom_user_id.to_string())]);
    if let Some(ref param_value) = p_query_vatom_parameters {
        req_builder = req_builder.query(&[("vatomParameters", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_return_raw_response {
        req_builder = req_builder.query(&[("returnRawResponse", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ListUserCoinTransactionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// List coin transactions for a user (as a Business).
pub async fn list_user_coin_transactions_as_business(configuration: &configuration::Configuration, account_id: i64, vatom_user_id: &str, app_key: &str, vatom_parameters: Option<&str>, return_raw_response: Option<bool>) -> Result<(), Error<ListUserCoinTransactionsAsBusinessError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_id = account_id;
    let p_query_vatom_user_id = vatom_user_id;
    let p_query_app_key = app_key;
    let p_query_vatom_parameters = vatom_parameters;
    let p_query_return_raw_response = return_raw_response;

    let uri_str = format!("{}/vatom/b/users/coins/txns/search", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("vatomUserId", &p_query_vatom_user_id.to_string())]);
    req_builder = req_builder.query(&[("appKey", &p_query_app_key.to_string())]);
    if let Some(ref param_value) = p_query_vatom_parameters {
        req_builder = req_builder.query(&[("vatomParameters", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_return_raw_response {
        req_builder = req_builder.query(&[("returnRawResponse", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ListUserCoinTransactionsAsBusinessError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Perform Action on NFT.
pub async fn perform_action_on_nft(configuration: &configuration::Configuration, account_id: i64, vatom_id: &str, vatom_action: &str, vatom_parameters: &str, return_raw_response: Option<bool>) -> Result<(), Error<PerformActionOnNftError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_id = account_id;
    let p_query_vatom_id = vatom_id;
    let p_query_vatom_action = vatom_action;
    let p_query_vatom_parameters = vatom_parameters;
    let p_query_return_raw_response = return_raw_response;

    let uri_str = format!("{}/vatom/me/vatoms/actions", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("vatomId", &p_query_vatom_id.to_string())]);
    req_builder = req_builder.query(&[("vatomAction", &p_query_vatom_action.to_string())]);
    req_builder = req_builder.query(&[("vatomParameters", &p_query_vatom_parameters.to_string())]);
    if let Some(ref param_value) = p_query_return_raw_response {
        req_builder = req_builder.query(&[("returnRawResponse", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<PerformActionOnNftError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Redeem an NFT.
pub async fn redeem_nft(configuration: &configuration::Configuration, account_id: i64, app_key: &str, vatom_parameters: &str, return_raw_response: Option<bool>) -> Result<(), Error<RedeemNftError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_id = account_id;
    let p_query_app_key = app_key;
    let p_query_vatom_parameters = vatom_parameters;
    let p_query_return_raw_response = return_raw_response;

    let uri_str = format!("{}/vatom/b/redemptions", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("appKey", &p_query_app_key.to_string())]);
    req_builder = req_builder.query(&[("vatomParameters", &p_query_vatom_parameters.to_string())]);
    if let Some(ref param_value) = p_query_return_raw_response {
        req_builder = req_builder.query(&[("returnRawResponse", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<RedeemNftError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Redeem the coins for a user (as a Business).
pub async fn redeem_user_coins_as_business(configuration: &configuration::Configuration, account_id: i64, vatom_user_id: &str, app_key: &str, vatom_parameters: &str, return_raw_response: Option<bool>) -> Result<(), Error<RedeemUserCoinsAsBusinessError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_id = account_id;
    let p_query_vatom_user_id = vatom_user_id;
    let p_query_app_key = app_key;
    let p_query_vatom_parameters = vatom_parameters;
    let p_query_return_raw_response = return_raw_response;

    let uri_str = format!("{}/vatom/b/users/coins/redeem", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("vatomUserId", &p_query_vatom_user_id.to_string())]);
    req_builder = req_builder.query(&[("appKey", &p_query_app_key.to_string())]);
    req_builder = req_builder.query(&[("vatomParameters", &p_query_vatom_parameters.to_string())]);
    if let Some(ref param_value) = p_query_return_raw_response {
        req_builder = req_builder.query(&[("returnRawResponse", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<RedeemUserCoinsAsBusinessError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Searches for Vatom businesses.
pub async fn search_businesses(configuration: &configuration::Configuration, account_id: i64, vatom_parameters: Option<&str>, return_raw_response: Option<bool>) -> Result<(), Error<SearchBusinessesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_id = account_id;
    let p_query_vatom_parameters = vatom_parameters;
    let p_query_return_raw_response = return_raw_response;

    let uri_str = format!("{}/vatom/b/search", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    if let Some(ref param_value) = p_query_vatom_parameters {
        req_builder = req_builder.query(&[("vatomParameters", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_return_raw_response {
        req_builder = req_builder.query(&[("returnRawResponse", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchBusinessesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Search campaign groups.
pub async fn search_campaign_groups(configuration: &configuration::Configuration, account_id: i64, app_key: &str, return_raw_response: Option<bool>) -> Result<(), Error<SearchCampaignGroupsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_id = account_id;
    let p_query_app_key = app_key;
    let p_query_return_raw_response = return_raw_response;

    let uri_str = format!("{}/vatom/b/campaign-groups/search", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("appKey", &p_query_app_key.to_string())]);
    if let Some(ref param_value) = p_query_return_raw_response {
        req_builder = req_builder.query(&[("returnRawResponse", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchCampaignGroupsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Search User Identities.
pub async fn search_identities(configuration: &configuration::Configuration, account_id: i64, return_raw_response: Option<bool>) -> Result<(), Error<SearchIdentitiesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_id = account_id;
    let p_query_return_raw_response = return_raw_response;

    let uri_str = format!("{}/vatom/me/identities/search", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    if let Some(ref param_value) = p_query_return_raw_response {
        req_builder = req_builder.query(&[("returnRawResponse", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchIdentitiesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Searches the logged in user's Vatom Inventory.
pub async fn search_inventory(configuration: &configuration::Configuration, account_id: i64, vatom_parameters: Option<&str>, return_raw_response: Option<bool>) -> Result<(), Error<SearchInventoryError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_id = account_id;
    let p_query_vatom_parameters = vatom_parameters;
    let p_query_return_raw_response = return_raw_response;

    let uri_str = format!("{}/vatom/user-inventory/search", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    if let Some(ref param_value) = p_query_vatom_parameters {
        req_builder = req_builder.query(&[("vatomParameters", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_return_raw_response {
        req_builder = req_builder.query(&[("returnRawResponse", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchInventoryError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Send an NFT.
pub async fn send_nft(configuration: &configuration::Configuration, account_id: i64, app_key: &str, vatom_campaign_id: &str, vatom_parameters: &str, return_raw_response: Option<bool>) -> Result<(), Error<SendNftError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_id = account_id;
    let p_query_app_key = app_key;
    let p_query_vatom_campaign_id = vatom_campaign_id;
    let p_query_vatom_parameters = vatom_parameters;
    let p_query_return_raw_response = return_raw_response;

    let uri_str = format!("{}/vatom/b/campaigns/send", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("appKey", &p_query_app_key.to_string())]);
    req_builder = req_builder.query(&[("vatomCampaignId", &p_query_vatom_campaign_id.to_string())]);
    req_builder = req_builder.query(&[("vatomParameters", &p_query_vatom_parameters.to_string())]);
    if let Some(ref param_value) = p_query_return_raw_response {
        req_builder = req_builder.query(&[("returnRawResponse", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<SendNftError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Sets the points balance of a Vatom user.
pub async fn set_points_balance_as_business(configuration: &configuration::Configuration, account_id: i64, app_key: &str, vatom_user_id: &str, vatom_campaign_id: &str, vatom_parameters: &str, return_raw_response: Option<bool>) -> Result<(), Error<SetPointsBalanceAsBusinessError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_id = account_id;
    let p_query_app_key = app_key;
    let p_query_vatom_user_id = vatom_user_id;
    let p_query_vatom_campaign_id = vatom_campaign_id;
    let p_query_vatom_parameters = vatom_parameters;
    let p_query_return_raw_response = return_raw_response;

    let uri_str = format!("{}/vatom/b/campaign/u/points/update", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("appKey", &p_query_app_key.to_string())]);
    req_builder = req_builder.query(&[("vatomUserId", &p_query_vatom_user_id.to_string())]);
    req_builder = req_builder.query(&[("vatomCampaignId", &p_query_vatom_campaign_id.to_string())]);
    req_builder = req_builder.query(&[("vatomParameters", &p_query_vatom_parameters.to_string())]);
    if let Some(ref param_value) = p_query_return_raw_response {
        req_builder = req_builder.query(&[("returnRawResponse", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<SetPointsBalanceAsBusinessError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Transfer coins from Vatom Users.
pub async fn transfer_user_coins(configuration: &configuration::Configuration, account_id: i64, vatom_user_id: &str, vatom_parameters: &str, return_raw_response: Option<bool>) -> Result<(), Error<TransferUserCoinsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_id = account_id;
    let p_query_vatom_user_id = vatom_user_id;
    let p_query_vatom_parameters = vatom_parameters;
    let p_query_return_raw_response = return_raw_response;

    let uri_str = format!("{}/vatom/u/coins/transfer", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("vatomUserId", &p_query_vatom_user_id.to_string())]);
    req_builder = req_builder.query(&[("vatomParameters", &p_query_vatom_parameters.to_string())]);
    if let Some(ref param_value) = p_query_return_raw_response {
        req_builder = req_builder.query(&[("returnRawResponse", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<TransferUserCoinsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Fund/update coins for a Businesss.
pub async fn update_business_coins(configuration: &configuration::Configuration, account_id: i64, app_key: &str, vatom_parameters: &str, return_raw_response: Option<bool>) -> Result<(), Error<UpdateBusinessCoinsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_id = account_id;
    let p_query_app_key = app_key;
    let p_query_vatom_parameters = vatom_parameters;
    let p_query_return_raw_response = return_raw_response;

    let uri_str = format!("{}/vatom/b/coins/update", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("appKey", &p_query_app_key.to_string())]);
    req_builder = req_builder.query(&[("vatomParameters", &p_query_vatom_parameters.to_string())]);
    if let Some(ref param_value) = p_query_return_raw_response {
        req_builder = req_builder.query(&[("returnRawResponse", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateBusinessCoinsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update the guest list of an event.
pub async fn update_event_guest_list(configuration: &configuration::Configuration, account_id: i64, app_key: &str, vatom_event_id: &str, vatom_parameters: &str, return_raw_response: Option<bool>) -> Result<(), Error<UpdateEventGuestListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_id = account_id;
    let p_query_app_key = app_key;
    let p_query_vatom_event_id = vatom_event_id;
    let p_query_vatom_parameters = vatom_parameters;
    let p_query_return_raw_response = return_raw_response;

    let uri_str = format!("{}/vatom/b/events/guests/update", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("appKey", &p_query_app_key.to_string())]);
    req_builder = req_builder.query(&[("vatomEventId", &p_query_vatom_event_id.to_string())]);
    req_builder = req_builder.query(&[("vatomParameters", &p_query_vatom_parameters.to_string())]);
    if let Some(ref param_value) = p_query_return_raw_response {
        req_builder = req_builder.query(&[("returnRawResponse", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateEventGuestListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update a Vatom space.
pub async fn update_space(configuration: &configuration::Configuration, account_id: i64, app_key: &str, vatom_space_id: &str, vatom_parameters: &str, return_raw_response: Option<bool>) -> Result<(), Error<UpdateSpaceError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_id = account_id;
    let p_query_app_key = app_key;
    let p_query_vatom_space_id = vatom_space_id;
    let p_query_vatom_parameters = vatom_parameters;
    let p_query_return_raw_response = return_raw_response;

    let uri_str = format!("{}/vatom/b/spaces/update", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("appKey", &p_query_app_key.to_string())]);
    req_builder = req_builder.query(&[("vatomSpaceId", &p_query_vatom_space_id.to_string())]);
    req_builder = req_builder.query(&[("vatomParameters", &p_query_vatom_parameters.to_string())]);
    if let Some(ref param_value) = p_query_return_raw_response {
        req_builder = req_builder.query(&[("returnRawResponse", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateSpaceError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update the coins for a user (as a Business).
pub async fn update_user_coins_as_business(configuration: &configuration::Configuration, account_id: i64, vatom_user_id: &str, app_key: &str, vatom_parameters: &str, return_raw_response: Option<bool>) -> Result<(), Error<UpdateUserCoinsAsBusinessError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_id = account_id;
    let p_query_vatom_user_id = vatom_user_id;
    let p_query_app_key = app_key;
    let p_query_vatom_parameters = vatom_parameters;
    let p_query_return_raw_response = return_raw_response;

    let uri_str = format!("{}/vatom/b/users/coins/update", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("vatomUserId", &p_query_vatom_user_id.to_string())]);
    req_builder = req_builder.query(&[("appKey", &p_query_app_key.to_string())]);
    req_builder = req_builder.query(&[("vatomParameters", &p_query_vatom_parameters.to_string())]);
    if let Some(ref param_value) = p_query_return_raw_response {
        req_builder = req_builder.query(&[("returnRawResponse", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateUserCoinsAsBusinessError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets the logged in user's profile in Vatom.
pub async fn update_user_profile(configuration: &configuration::Configuration, account_id: i64, vatom_parameters: &str, return_raw_response: Option<bool>) -> Result<(), Error<UpdateUserProfileError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_id = account_id;
    let p_query_vatom_parameters = vatom_parameters;
    let p_query_return_raw_response = return_raw_response;

    let uri_str = format!("{}/vatom/me/update", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("vatomParameters", &p_query_vatom_parameters.to_string())]);
    if let Some(ref param_value) = p_query_return_raw_response {
        req_builder = req_builder.query(&[("returnRawResponse", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateUserProfileError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update a Vatom event.
pub async fn update_vatom_event(configuration: &configuration::Configuration, account_id: i64, app_key: &str, vatom_event_id: &str, vatom_parameters: &str, return_raw_response: Option<bool>) -> Result<(), Error<UpdateVatomEventError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_id = account_id;
    let p_query_app_key = app_key;
    let p_query_vatom_event_id = vatom_event_id;
    let p_query_vatom_parameters = vatom_parameters;
    let p_query_return_raw_response = return_raw_response;

    let uri_str = format!("{}/vatom/b/events/update", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("appKey", &p_query_app_key.to_string())]);
    req_builder = req_builder.query(&[("vatomEventId", &p_query_vatom_event_id.to_string())]);
    req_builder = req_builder.query(&[("vatomParameters", &p_query_vatom_parameters.to_string())]);
    if let Some(ref param_value) = p_query_return_raw_response {
        req_builder = req_builder.query(&[("returnRawResponse", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateVatomEventError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

