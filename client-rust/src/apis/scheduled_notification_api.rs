/*
 * Sirqul IoT Platform
 *
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`create_scheduled_notification`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateScheduledNotificationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_scheduled_notification`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteScheduledNotificationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_scheduled_notification`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetScheduledNotificationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`schedule_notification_listings`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ScheduleNotificationListingsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_scheduled_notifications`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchScheduledNotificationsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_scheduled_notification`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateScheduledNotificationError {
    UnknownValue(serde_json::Value),
}


/// This endpoint creates a Scheduled Notification message that can be configured to process and send periodically at set time periods
pub async fn create_scheduled_notification(configuration: &configuration::Configuration, account_id: i64, name: &str, r#type: &str, message: &str, content_id: Option<i64>, content_name: Option<&str>, content_type: Option<&str>, parent_id: Option<i64>, parent_type: Option<&str>, app_key: Option<&str>, grouping_id: Option<&str>, connection_group_ids: Option<&str>, connection_account_ids: Option<&str>, audience_id: Option<i64>, audience_ids: Option<&str>, album_ids: Option<&str>, report_id: Option<i64>, report_params: Option<&str>, endpoint_url: Option<&str>, payload: Option<&str>, scheduled_date: Option<i64>, start_date: Option<i64>, end_date: Option<i64>, cron_expression: Option<&str>, cron_type: Option<&str>, meta_data: Option<&str>, conditional_input: Option<&str>, template_type: Option<&str>, visibility: Option<&str>, active: Option<bool>, send_now: Option<bool>, event_type: Option<&str>, deep_link_uri: Option<&str>, send_to_all: Option<bool>) -> Result<models::ScheduledNotificationFullResponse, Error<CreateScheduledNotificationError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_id = account_id;
    let p_query_name = name;
    let p_query_type = r#type;
    let p_query_message = message;
    let p_query_content_id = content_id;
    let p_query_content_name = content_name;
    let p_query_content_type = content_type;
    let p_query_parent_id = parent_id;
    let p_query_parent_type = parent_type;
    let p_query_app_key = app_key;
    let p_query_grouping_id = grouping_id;
    let p_query_connection_group_ids = connection_group_ids;
    let p_query_connection_account_ids = connection_account_ids;
    let p_query_audience_id = audience_id;
    let p_query_audience_ids = audience_ids;
    let p_query_album_ids = album_ids;
    let p_query_report_id = report_id;
    let p_query_report_params = report_params;
    let p_query_endpoint_url = endpoint_url;
    let p_query_payload = payload;
    let p_query_scheduled_date = scheduled_date;
    let p_query_start_date = start_date;
    let p_query_end_date = end_date;
    let p_query_cron_expression = cron_expression;
    let p_query_cron_type = cron_type;
    let p_query_meta_data = meta_data;
    let p_query_conditional_input = conditional_input;
    let p_query_template_type = template_type;
    let p_query_visibility = visibility;
    let p_query_active = active;
    let p_query_send_now = send_now;
    let p_query_event_type = event_type;
    let p_query_deep_link_uri = deep_link_uri;
    let p_query_send_to_all = send_to_all;

    let uri_str = format!("{}/notification/schedule/create", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("name", &p_query_name.to_string())]);
    req_builder = req_builder.query(&[("type", &p_query_type.to_string())]);
    req_builder = req_builder.query(&[("message", &p_query_message.to_string())]);
    if let Some(ref param_value) = p_query_content_id {
        req_builder = req_builder.query(&[("contentId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_content_name {
        req_builder = req_builder.query(&[("contentName", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_content_type {
        req_builder = req_builder.query(&[("contentType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_parent_id {
        req_builder = req_builder.query(&[("parentId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_parent_type {
        req_builder = req_builder.query(&[("parentType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_key {
        req_builder = req_builder.query(&[("appKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_grouping_id {
        req_builder = req_builder.query(&[("groupingId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_connection_group_ids {
        req_builder = req_builder.query(&[("connectionGroupIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_connection_account_ids {
        req_builder = req_builder.query(&[("connectionAccountIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_audience_id {
        req_builder = req_builder.query(&[("audienceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_audience_ids {
        req_builder = req_builder.query(&[("audienceIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_album_ids {
        req_builder = req_builder.query(&[("albumIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_report_id {
        req_builder = req_builder.query(&[("reportId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_report_params {
        req_builder = req_builder.query(&[("reportParams", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_endpoint_url {
        req_builder = req_builder.query(&[("endpointURL", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_payload {
        req_builder = req_builder.query(&[("payload", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_scheduled_date {
        req_builder = req_builder.query(&[("scheduledDate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("startDate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("endDate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cron_expression {
        req_builder = req_builder.query(&[("cronExpression", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cron_type {
        req_builder = req_builder.query(&[("cronType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_meta_data {
        req_builder = req_builder.query(&[("metaData", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_conditional_input {
        req_builder = req_builder.query(&[("conditionalInput", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_template_type {
        req_builder = req_builder.query(&[("templateType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_visibility {
        req_builder = req_builder.query(&[("visibility", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_active {
        req_builder = req_builder.query(&[("active", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_send_now {
        req_builder = req_builder.query(&[("sendNow", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_event_type {
        req_builder = req_builder.query(&[("eventType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_deep_link_uri {
        req_builder = req_builder.query(&[("deepLinkURI", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_send_to_all {
        req_builder = req_builder.query(&[("sendToAll", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ScheduledNotificationFullResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ScheduledNotificationFullResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateScheduledNotificationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// This endpoint deletes a Scheduled Notification. Only the original owner of the Scheduled Notification or someone with write permissions can use this endpoint. Permissions can be granted to other users by using the UserPermissionsApi.
pub async fn delete_scheduled_notification(configuration: &configuration::Configuration, account_id: i64, scheduled_notification_id: i64, delete_by_grouping_id: Option<bool>) -> Result<models::ScheduledNotificationFullResponse, Error<DeleteScheduledNotificationError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_id = account_id;
    let p_query_scheduled_notification_id = scheduled_notification_id;
    let p_query_delete_by_grouping_id = delete_by_grouping_id;

    let uri_str = format!("{}/notification/schedule/delete", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("scheduledNotificationId", &p_query_scheduled_notification_id.to_string())]);
    if let Some(ref param_value) = p_query_delete_by_grouping_id {
        req_builder = req_builder.query(&[("deleteByGroupingId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ScheduledNotificationFullResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ScheduledNotificationFullResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteScheduledNotificationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a ScheduledNotification
pub async fn get_scheduled_notification(configuration: &configuration::Configuration, account_id: i64, scheduled_notification_id: i64) -> Result<models::ScheduledNotificationFullResponse, Error<GetScheduledNotificationError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_id = account_id;
    let p_query_scheduled_notification_id = scheduled_notification_id;

    let uri_str = format!("{}/notification/schedule/get", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("scheduledNotificationId", &p_query_scheduled_notification_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ScheduledNotificationFullResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ScheduledNotificationFullResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetScheduledNotificationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Use a report to identify events that are starting soon and then create a scheduled notification to push a message to matching users.
pub async fn schedule_notification_listings(configuration: &configuration::Configuration, account_id: i64, app_key: &str, report_name: &str, message: &str, offset: i32, recipient_report_id: i64, report_params: Option<&str>, r#type: Option<&str>) -> Result<models::SirqulResponse, Error<ScheduleNotificationListingsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_id = account_id;
    let p_query_app_key = app_key;
    let p_query_report_name = report_name;
    let p_query_message = message;
    let p_query_offset = offset;
    let p_query_recipient_report_id = recipient_report_id;
    let p_query_report_params = report_params;
    let p_query_type = r#type;

    let uri_str = format!("{}/notification/schedule/generate", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("appKey", &p_query_app_key.to_string())]);
    req_builder = req_builder.query(&[("reportName", &p_query_report_name.to_string())]);
    if let Some(ref param_value) = p_query_report_params {
        req_builder = req_builder.query(&[("reportParams", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("message", &p_query_message.to_string())]);
    req_builder = req_builder.query(&[("offset", &p_query_offset.to_string())]);
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("recipientReportId", &p_query_recipient_report_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SirqulResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SirqulResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ScheduleNotificationListingsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// This endpoint searches on Scheduled Notifications. If a scheduled notification was created with the visibility parameter set to PUBLIC, then anyone can search on it if the filter parameter includes the PUBLIC value. PRIVATE visibility means that it can only be searched on by the owner or if it has been shared to the user using the UserPermissionsApi.  In addition, if a PUBLIC Scheduled Notification was created for an application that requires content approval (using the publicContentApproval parameter), then an administrator of the application needs to approve it before it can be search on by other users. Before this happens, it is in a PENDING state, and only the original creator or the owner of the application can search and see it. Also, only the owner of the application can use the UserPermissionsApi to approve or reject it. Scheduled notifications that have been rejected are only visible to the original creators.
pub async fn search_scheduled_notifications(configuration: &configuration::Configuration, account_id: i64, grouping_id: Option<&str>, audience_id: Option<i64>, filter: Option<&str>, types: Option<&str>, content_ids: Option<&str>, content_types: Option<&str>, parent_ids: Option<&str>, parent_types: Option<&str>, statuses: Option<&str>, template_types: Option<&str>, app_key: Option<&str>, keyword: Option<&str>, sort_field: Option<&str>, descending: Option<bool>, start: Option<i32>, limit: Option<i32>, active_only: Option<bool>, group_by_grouping_id: Option<bool>, return_audience_account_count: Option<bool>) -> Result<models::ScheduledNotificationFullResponse, Error<SearchScheduledNotificationsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_id = account_id;
    let p_query_grouping_id = grouping_id;
    let p_query_audience_id = audience_id;
    let p_query_filter = filter;
    let p_query_types = types;
    let p_query_content_ids = content_ids;
    let p_query_content_types = content_types;
    let p_query_parent_ids = parent_ids;
    let p_query_parent_types = parent_types;
    let p_query_statuses = statuses;
    let p_query_template_types = template_types;
    let p_query_app_key = app_key;
    let p_query_keyword = keyword;
    let p_query_sort_field = sort_field;
    let p_query_descending = descending;
    let p_query_start = start;
    let p_query_limit = limit;
    let p_query_active_only = active_only;
    let p_query_group_by_grouping_id = group_by_grouping_id;
    let p_query_return_audience_account_count = return_audience_account_count;

    let uri_str = format!("{}/notification/schedule/search", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    if let Some(ref param_value) = p_query_grouping_id {
        req_builder = req_builder.query(&[("groupingId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_audience_id {
        req_builder = req_builder.query(&[("audienceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter {
        req_builder = req_builder.query(&[("filter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_types {
        req_builder = req_builder.query(&[("types", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_content_ids {
        req_builder = req_builder.query(&[("contentIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_content_types {
        req_builder = req_builder.query(&[("contentTypes", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_parent_ids {
        req_builder = req_builder.query(&[("parentIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_parent_types {
        req_builder = req_builder.query(&[("parentTypes", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_statuses {
        req_builder = req_builder.query(&[("statuses", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_template_types {
        req_builder = req_builder.query(&[("templateTypes", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_key {
        req_builder = req_builder.query(&[("appKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_keyword {
        req_builder = req_builder.query(&[("keyword", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_field {
        req_builder = req_builder.query(&[("sortField", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_descending {
        req_builder = req_builder.query(&[("descending", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start {
        req_builder = req_builder.query(&[("start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_active_only {
        req_builder = req_builder.query(&[("activeOnly", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_group_by_grouping_id {
        req_builder = req_builder.query(&[("groupByGroupingId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_return_audience_account_count {
        req_builder = req_builder.query(&[("returnAudienceAccountCount", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ScheduledNotificationFullResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ScheduledNotificationFullResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchScheduledNotificationsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// This endpoint updates a Scheduled Notification message that can be configured to process and send periodically at set time periods. Please see createScheduledNotification for more details.  Only the original owner of the Scheduled Notification or someone with write permissions can use this endpoint. Permissions can be granted to other users by using theUserPermissionsApi.
pub async fn update_scheduled_notification(configuration: &configuration::Configuration, scheduled_notification_id: i64, account_id: i64, name: Option<&str>, r#type: Option<&str>, message: Option<&str>, payload: Option<&str>, content_id: Option<i64>, content_name: Option<&str>, content_type: Option<&str>, parent_id: Option<i64>, parent_type: Option<&str>, app_key: Option<&str>, grouping_id: Option<&str>, connection_group_ids: Option<&str>, connection_account_ids: Option<&str>, audience_id: Option<i64>, audience_ids: Option<&str>, album_ids: Option<&str>, report_id: Option<i64>, report_params: Option<&str>, endpoint_url: Option<&str>, scheduled_date: Option<i64>, start_date: Option<i64>, end_date: Option<i64>, cron_expression: Option<&str>, cron_type: Option<&str>, meta_data: Option<&str>, conditional_input: Option<&str>, template_type: Option<&str>, visibility: Option<&str>, active: Option<bool>, error_message: Option<&str>, status: Option<&str>, update_by_grouping_id: Option<bool>, send_now: Option<bool>, event_type: Option<&str>, deep_link_uri: Option<&str>, send_to_all: Option<bool>) -> Result<models::ScheduledNotificationFullResponse, Error<UpdateScheduledNotificationError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_scheduled_notification_id = scheduled_notification_id;
    let p_query_account_id = account_id;
    let p_query_name = name;
    let p_query_type = r#type;
    let p_query_message = message;
    let p_query_payload = payload;
    let p_query_content_id = content_id;
    let p_query_content_name = content_name;
    let p_query_content_type = content_type;
    let p_query_parent_id = parent_id;
    let p_query_parent_type = parent_type;
    let p_query_app_key = app_key;
    let p_query_grouping_id = grouping_id;
    let p_query_connection_group_ids = connection_group_ids;
    let p_query_connection_account_ids = connection_account_ids;
    let p_query_audience_id = audience_id;
    let p_query_audience_ids = audience_ids;
    let p_query_album_ids = album_ids;
    let p_query_report_id = report_id;
    let p_query_report_params = report_params;
    let p_query_endpoint_url = endpoint_url;
    let p_query_scheduled_date = scheduled_date;
    let p_query_start_date = start_date;
    let p_query_end_date = end_date;
    let p_query_cron_expression = cron_expression;
    let p_query_cron_type = cron_type;
    let p_query_meta_data = meta_data;
    let p_query_conditional_input = conditional_input;
    let p_query_template_type = template_type;
    let p_query_visibility = visibility;
    let p_query_active = active;
    let p_query_error_message = error_message;
    let p_query_status = status;
    let p_query_update_by_grouping_id = update_by_grouping_id;
    let p_query_send_now = send_now;
    let p_query_event_type = event_type;
    let p_query_deep_link_uri = deep_link_uri;
    let p_query_send_to_all = send_to_all;

    let uri_str = format!("{}/notification/schedule/update", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("scheduledNotificationId", &p_query_scheduled_notification_id.to_string())]);
    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    if let Some(ref param_value) = p_query_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_message {
        req_builder = req_builder.query(&[("message", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_payload {
        req_builder = req_builder.query(&[("payload", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_content_id {
        req_builder = req_builder.query(&[("contentId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_content_name {
        req_builder = req_builder.query(&[("contentName", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_content_type {
        req_builder = req_builder.query(&[("contentType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_parent_id {
        req_builder = req_builder.query(&[("parentId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_parent_type {
        req_builder = req_builder.query(&[("parentType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_key {
        req_builder = req_builder.query(&[("appKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_grouping_id {
        req_builder = req_builder.query(&[("groupingId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_connection_group_ids {
        req_builder = req_builder.query(&[("connectionGroupIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_connection_account_ids {
        req_builder = req_builder.query(&[("connectionAccountIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_audience_id {
        req_builder = req_builder.query(&[("audienceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_audience_ids {
        req_builder = req_builder.query(&[("audienceIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_album_ids {
        req_builder = req_builder.query(&[("albumIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_report_id {
        req_builder = req_builder.query(&[("reportId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_report_params {
        req_builder = req_builder.query(&[("reportParams", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_endpoint_url {
        req_builder = req_builder.query(&[("endpointURL", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_scheduled_date {
        req_builder = req_builder.query(&[("scheduledDate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("startDate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("endDate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cron_expression {
        req_builder = req_builder.query(&[("cronExpression", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cron_type {
        req_builder = req_builder.query(&[("cronType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_meta_data {
        req_builder = req_builder.query(&[("metaData", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_conditional_input {
        req_builder = req_builder.query(&[("conditionalInput", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_template_type {
        req_builder = req_builder.query(&[("templateType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_visibility {
        req_builder = req_builder.query(&[("visibility", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_active {
        req_builder = req_builder.query(&[("active", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_error_message {
        req_builder = req_builder.query(&[("errorMessage", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_status {
        req_builder = req_builder.query(&[("status", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_update_by_grouping_id {
        req_builder = req_builder.query(&[("updateByGroupingId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_send_now {
        req_builder = req_builder.query(&[("sendNow", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_event_type {
        req_builder = req_builder.query(&[("eventType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_deep_link_uri {
        req_builder = req_builder.query(&[("deepLinkURI", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_send_to_all {
        req_builder = req_builder.query(&[("sendToAll", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ScheduledNotificationFullResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ScheduledNotificationFullResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateScheduledNotificationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

