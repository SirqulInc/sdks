/*
 * Sirqul IoT Platform
 *
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`create_persona`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreatePersonaError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_persona`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeletePersonaError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_persona_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetPersonaListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_persona`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchPersonaError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_persona`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdatePersonaError {
    UnknownValue(serde_json::Value),
}


/// Creates a new persona. If the given params are null those attributes will be override by null.
pub async fn create_persona(configuration: &configuration::Configuration, account_id: i64, title: &str, preview_accounts: Option<&str>, date: Option<i64>, age: Option<i32>, gender: Option<&str>, game_experience_level: Option<&str>, latitude: Option<f64>, longitude: Option<f64>) -> Result<models::PreviewPersonaResponse, Error<CreatePersonaError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_id = account_id;
    let p_query_title = title;
    let p_query_preview_accounts = preview_accounts;
    let p_query_date = date;
    let p_query_age = age;
    let p_query_gender = gender;
    let p_query_game_experience_level = game_experience_level;
    let p_query_latitude = latitude;
    let p_query_longitude = longitude;

    let uri_str = format!("{}/persona/create", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("title", &p_query_title.to_string())]);
    if let Some(ref param_value) = p_query_preview_accounts {
        req_builder = req_builder.query(&[("previewAccounts", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_age {
        req_builder = req_builder.query(&[("age", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_gender {
        req_builder = req_builder.query(&[("gender", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_game_experience_level {
        req_builder = req_builder.query(&[("gameExperienceLevel", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_latitude {
        req_builder = req_builder.query(&[("latitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_longitude {
        req_builder = req_builder.query(&[("longitude", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PreviewPersonaResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PreviewPersonaResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreatePersonaError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Mark the persona for deletion.
pub async fn delete_persona(configuration: &configuration::Configuration, account_id: i64, persona_id: i64) -> Result<models::SirqulResponse, Error<DeletePersonaError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_id = account_id;
    let p_query_persona_id = persona_id;

    let uri_str = format!("{}/persona/delete", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("personaId", &p_query_persona_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SirqulResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SirqulResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeletePersonaError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the persona by the given persona ID. If the persona cannot be found, a invalid response is returned.
pub async fn get_persona_list(configuration: &configuration::Configuration, account_id: i64, persona_id: i64) -> Result<models::PreviewPersonaResponse, Error<GetPersonaListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_id = account_id;
    let p_query_persona_id = persona_id;

    let uri_str = format!("{}/persona/get", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("personaId", &p_query_persona_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PreviewPersonaResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PreviewPersonaResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetPersonaListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Search for persona that the account owns by the given account ID.
pub async fn search_persona(configuration: &configuration::Configuration, account_id: i64, start: i32, limit: i32) -> Result<models::PreviewPersonaResponse, Error<SearchPersonaError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_id = account_id;
    let p_query_start = start;
    let p_query_limit = limit;

    let uri_str = format!("{}/persona/search", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("start", &p_query_start.to_string())]);
    req_builder = req_builder.query(&[("limit", &p_query_limit.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PreviewPersonaResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PreviewPersonaResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchPersonaError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update the persona by the given personaId. If the given params are null those attributes will be override by null. If active is assigned, all other params will be ignored.
pub async fn update_persona(configuration: &configuration::Configuration, account_id: i64, persona_id: i64, title: Option<&str>, preview_accounts: Option<&str>, active: Option<bool>, date: Option<i64>, age: Option<i32>, gender: Option<&str>, game_experience_level: Option<&str>, latitude: Option<f64>, longitude: Option<f64>) -> Result<models::PreviewPersonaResponse, Error<UpdatePersonaError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_id = account_id;
    let p_query_persona_id = persona_id;
    let p_query_title = title;
    let p_query_preview_accounts = preview_accounts;
    let p_query_active = active;
    let p_query_date = date;
    let p_query_age = age;
    let p_query_gender = gender;
    let p_query_game_experience_level = game_experience_level;
    let p_query_latitude = latitude;
    let p_query_longitude = longitude;

    let uri_str = format!("{}/persona/update", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("personaId", &p_query_persona_id.to_string())]);
    if let Some(ref param_value) = p_query_title {
        req_builder = req_builder.query(&[("title", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_preview_accounts {
        req_builder = req_builder.query(&[("previewAccounts", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_active {
        req_builder = req_builder.query(&[("active", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_age {
        req_builder = req_builder.query(&[("age", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_gender {
        req_builder = req_builder.query(&[("gender", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_game_experience_level {
        req_builder = req_builder.query(&[("gameExperienceLevel", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_latitude {
        req_builder = req_builder.query(&[("latitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_longitude {
        req_builder = req_builder.query(&[("longitude", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PreviewPersonaResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PreviewPersonaResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdatePersonaError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

