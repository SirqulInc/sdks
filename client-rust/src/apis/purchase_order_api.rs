/*
 * Sirqul IoT Platform
 *
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`create_order`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateOrderError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_order`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteOrderError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_order`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetOrderError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`preview_order`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PreviewOrderError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_orders`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchOrdersError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_order`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateOrderError {
    UnknownValue(serde_json::Value),
}


/// Creates a new purchase with some number of items associated with it. The purchase is added to the order that was created
pub async fn create_order(configuration: &configuration::Configuration, version: f64, app_key: &str, cart: &str, device_id: Option<&str>, account_id: Option<i64>, description: Option<&str>, currency_type: Option<&str>, payment_method_id: Option<i64>, external_order_id: Option<&str>, external_payment_id: Option<&str>, remote_ref_type: Option<&str>, external_date: Option<i64>, promo_code: Option<&str>) -> Result<models::OrderResponse, Error<CreateOrderError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_app_key = app_key;
    let p_query_cart = cart;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_description = description;
    let p_query_currency_type = currency_type;
    let p_query_payment_method_id = payment_method_id;
    let p_query_external_order_id = external_order_id;
    let p_query_external_payment_id = external_payment_id;
    let p_query_remote_ref_type = remote_ref_type;
    let p_query_external_date = external_date;
    let p_query_promo_code = promo_code;

    let uri_str = format!("{}/api/{version}/order/create", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("appKey", &p_query_app_key.to_string())]);
    if let Some(ref param_value) = p_query_description {
        req_builder = req_builder.query(&[("description", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_currency_type {
        req_builder = req_builder.query(&[("currencyType", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("cart", &p_query_cart.to_string())]);
    if let Some(ref param_value) = p_query_payment_method_id {
        req_builder = req_builder.query(&[("paymentMethodId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_external_order_id {
        req_builder = req_builder.query(&[("externalOrderId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_external_payment_id {
        req_builder = req_builder.query(&[("externalPaymentId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_remote_ref_type {
        req_builder = req_builder.query(&[("remoteRefType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_external_date {
        req_builder = req_builder.query(&[("externalDate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_promo_code {
        req_builder = req_builder.query(&[("promoCode", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrderResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrderResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateOrderError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Removes the transaction from the wallet by setting the deleted date to the current date/time.  Requires a valid account and transactionId.
pub async fn delete_order(configuration: &configuration::Configuration, version: f64, order_id: i64, device_id: Option<&str>, account_id: Option<i64>) -> Result<models::SirqulResponse, Error<DeleteOrderError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_order_id = order_id;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;

    let uri_str = format!("{}/api/{version}/order/delete", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("orderId", &p_query_order_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SirqulResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SirqulResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteOrderError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get an order record
pub async fn get_order(configuration: &configuration::Configuration, version: f64, device_id: Option<&str>, account_id: Option<i64>, order_id: Option<i64>, external_order_id: Option<&str>) -> Result<models::OrderResponse, Error<GetOrderError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_order_id = order_id;
    let p_query_external_order_id = external_order_id;

    let uri_str = format!("{}/api/{version}/order/get", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order_id {
        req_builder = req_builder.query(&[("orderId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_external_order_id {
        req_builder = req_builder.query(&[("externalOrderId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrderResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrderResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetOrderError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Previews a purchase to see the total cost before making it.
pub async fn preview_order(configuration: &configuration::Configuration, version: f64, app_key: &str, cart: &str, device_id: Option<&str>, account_id: Option<i64>, description: Option<&str>, currency_type: Option<&str>, payment_method_id: Option<i64>, external_order_id: Option<&str>, external_payment_id: Option<&str>, remote_ref_type: Option<&str>, external_date: Option<i64>, promo_code: Option<&str>) -> Result<models::OrderResponse, Error<PreviewOrderError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_app_key = app_key;
    let p_query_cart = cart;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_description = description;
    let p_query_currency_type = currency_type;
    let p_query_payment_method_id = payment_method_id;
    let p_query_external_order_id = external_order_id;
    let p_query_external_payment_id = external_payment_id;
    let p_query_remote_ref_type = remote_ref_type;
    let p_query_external_date = external_date;
    let p_query_promo_code = promo_code;

    let uri_str = format!("{}/api/{version}/order/preview", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("appKey", &p_query_app_key.to_string())]);
    if let Some(ref param_value) = p_query_description {
        req_builder = req_builder.query(&[("description", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_currency_type {
        req_builder = req_builder.query(&[("currencyType", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("cart", &p_query_cart.to_string())]);
    if let Some(ref param_value) = p_query_payment_method_id {
        req_builder = req_builder.query(&[("paymentMethodId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_external_order_id {
        req_builder = req_builder.query(&[("externalOrderId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_external_payment_id {
        req_builder = req_builder.query(&[("externalPaymentId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_remote_ref_type {
        req_builder = req_builder.query(&[("remoteRefType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_external_date {
        req_builder = req_builder.query(&[("externalDate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_promo_code {
        req_builder = req_builder.query(&[("promoCode", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrderResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrderResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PreviewOrderError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Search on active orders by customer
pub async fn search_orders(configuration: &configuration::Configuration, version: f64, app_key: &str, device_id: Option<&str>, account_id: Option<i64>, start: Option<i32>, limit: Option<i32>, descending: Option<bool>, active_only: Option<bool>, ignore_customer_filter: Option<bool>, order_item_types: Option<&str>, order_item_ids: Option<&str>, order_custom_types: Option<&str>, order_custom_ids: Option<&str>, sort_field: Option<&str>, offer_types: Option<&str>, special_offer_types: Option<&str>, category_ids: Option<&str>, filter_ids: Option<&str>, offer_audience_ids: Option<&str>, transaction_audience_ids: Option<&str>, offer_ids: Option<&str>, offer_location_ids: Option<&str>, retailer_ids: Option<&str>, retailer_location_ids: Option<&str>, statuses: Option<&str>, keyword: Option<&str>, redeemable_start_date: Option<i64>, redeemable_end_date: Option<i64>, started_since: Option<i64>, started_before: Option<i64>, ended_since: Option<i64>, ended_before: Option<i64>) -> Result<Vec<models::OrderResponse>, Error<SearchOrdersError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_app_key = app_key;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_start = start;
    let p_query_limit = limit;
    let p_query_descending = descending;
    let p_query_active_only = active_only;
    let p_query_ignore_customer_filter = ignore_customer_filter;
    let p_query_order_item_types = order_item_types;
    let p_query_order_item_ids = order_item_ids;
    let p_query_order_custom_types = order_custom_types;
    let p_query_order_custom_ids = order_custom_ids;
    let p_query_sort_field = sort_field;
    let p_query_offer_types = offer_types;
    let p_query_special_offer_types = special_offer_types;
    let p_query_category_ids = category_ids;
    let p_query_filter_ids = filter_ids;
    let p_query_offer_audience_ids = offer_audience_ids;
    let p_query_transaction_audience_ids = transaction_audience_ids;
    let p_query_offer_ids = offer_ids;
    let p_query_offer_location_ids = offer_location_ids;
    let p_query_retailer_ids = retailer_ids;
    let p_query_retailer_location_ids = retailer_location_ids;
    let p_query_statuses = statuses;
    let p_query_keyword = keyword;
    let p_query_redeemable_start_date = redeemable_start_date;
    let p_query_redeemable_end_date = redeemable_end_date;
    let p_query_started_since = started_since;
    let p_query_started_before = started_before;
    let p_query_ended_since = ended_since;
    let p_query_ended_before = ended_before;

    let uri_str = format!("{}/api/{version}/order/search", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("appKey", &p_query_app_key.to_string())]);
    if let Some(ref param_value) = p_query_start {
        req_builder = req_builder.query(&[("start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_descending {
        req_builder = req_builder.query(&[("descending", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_active_only {
        req_builder = req_builder.query(&[("activeOnly", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ignore_customer_filter {
        req_builder = req_builder.query(&[("ignoreCustomerFilter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order_item_types {
        req_builder = req_builder.query(&[("orderItemTypes", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order_item_ids {
        req_builder = req_builder.query(&[("orderItemIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order_custom_types {
        req_builder = req_builder.query(&[("orderCustomTypes", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order_custom_ids {
        req_builder = req_builder.query(&[("orderCustomIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_field {
        req_builder = req_builder.query(&[("sortField", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offer_types {
        req_builder = req_builder.query(&[("offerTypes", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_special_offer_types {
        req_builder = req_builder.query(&[("specialOfferTypes", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_category_ids {
        req_builder = req_builder.query(&[("categoryIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter_ids {
        req_builder = req_builder.query(&[("filterIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offer_audience_ids {
        req_builder = req_builder.query(&[("offerAudienceIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_transaction_audience_ids {
        req_builder = req_builder.query(&[("transactionAudienceIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offer_ids {
        req_builder = req_builder.query(&[("offerIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offer_location_ids {
        req_builder = req_builder.query(&[("offerLocationIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_retailer_ids {
        req_builder = req_builder.query(&[("retailerIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_retailer_location_ids {
        req_builder = req_builder.query(&[("retailerLocationIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_statuses {
        req_builder = req_builder.query(&[("statuses", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_keyword {
        req_builder = req_builder.query(&[("keyword", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_redeemable_start_date {
        req_builder = req_builder.query(&[("redeemableStartDate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_redeemable_end_date {
        req_builder = req_builder.query(&[("redeemableEndDate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_started_since {
        req_builder = req_builder.query(&[("startedSince", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_started_before {
        req_builder = req_builder.query(&[("startedBefore", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ended_since {
        req_builder = req_builder.query(&[("endedSince", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ended_before {
        req_builder = req_builder.query(&[("endedBefore", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::OrderResponse&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::OrderResponse&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchOrdersError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates new purchase with some number of items associated with it. The orderId provided is used to retrieve the record and the payment is added to it.
pub async fn update_order(configuration: &configuration::Configuration, version: f64, order_id: i64, app_key: &str, cart: &str, device_id: Option<&str>, account_id: Option<i64>, payment_transaction_id: Option<i64>, description: Option<&str>, currency_type: Option<&str>, payment_method_id: Option<i64>, external_payment_id: Option<&str>, external_date: Option<i64>) -> Result<models::OrderResponse, Error<UpdateOrderError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_order_id = order_id;
    let p_query_app_key = app_key;
    let p_query_cart = cart;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_payment_transaction_id = payment_transaction_id;
    let p_query_description = description;
    let p_query_currency_type = currency_type;
    let p_query_payment_method_id = payment_method_id;
    let p_query_external_payment_id = external_payment_id;
    let p_query_external_date = external_date;

    let uri_str = format!("{}/api/{version}/order/update", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("orderId", &p_query_order_id.to_string())]);
    if let Some(ref param_value) = p_query_payment_transaction_id {
        req_builder = req_builder.query(&[("paymentTransactionId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("appKey", &p_query_app_key.to_string())]);
    if let Some(ref param_value) = p_query_description {
        req_builder = req_builder.query(&[("description", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_currency_type {
        req_builder = req_builder.query(&[("currencyType", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("cart", &p_query_cart.to_string())]);
    if let Some(ref param_value) = p_query_payment_method_id {
        req_builder = req_builder.query(&[("paymentMethodId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_external_payment_id {
        req_builder = req_builder.query(&[("externalPaymentId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_external_date {
        req_builder = req_builder.query(&[("externalDate", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrderResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrderResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateOrderError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

