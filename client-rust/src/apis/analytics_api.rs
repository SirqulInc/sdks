/*
 * Sirqul IoT Platform
 *
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`activities`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActivitiesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`aggregated_filtered_usage`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AggregatedFilteredUsageError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`filtered_usage`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FilteredUsageError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`usage`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsageError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`usage_batch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsageBatchError {
    UnknownValue(serde_json::Value),
}


/// Get an activity feed by user.
pub async fn activities(configuration: &configuration::Configuration, version: f64, start: i32, limit: i32, account_id: i64) -> Result<Vec<models::UserActivityResponse>, Error<ActivitiesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_start = start;
    let p_query_limit = limit;
    let p_query_account_id = account_id;

    let uri_str = format!("{}/api/{version}/analytics/useractivity", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("start", &p_query_start.to_string())]);
    req_builder = req_builder.query(&[("limit", &p_query_limit.to_string())]);
    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UserActivityResponse&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UserActivityResponse&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ActivitiesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Query analytics to get data used for nested graphs and charts
pub async fn aggregated_filtered_usage(configuration: &configuration::Configuration, version: f64, device_id: Option<&str>, account_id: Option<i64>, application_id: Option<i64>, app_key: Option<&str>, start_date: Option<i64>, end_date: Option<i64>, device_type: Option<&str>, device: Option<&str>, device_os: Option<&str>, gender: Option<&str>, age_group: Option<&str>, country: Option<&str>, state: Option<&str>, city: Option<&str>, zip: Option<&str>, model: Option<&str>, tag: Option<&str>, user_account_id: Option<i64>, user_account_display: Option<&str>, user_account_username: Option<&str>, group_by_root: Option<&str>, group_by: Option<&str>, distinct_count: Option<&str>, sort_field: Option<&str>, descending: Option<bool>, hide_unknown: Option<bool>, response_format: Option<&str>, _l: Option<i32>, limit: Option<i32>, latitude: Option<f64>, longitude: Option<f64>) -> Result<models::ChartData, Error<AggregatedFilteredUsageError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_application_id = application_id;
    let p_query_app_key = app_key;
    let p_query_start_date = start_date;
    let p_query_end_date = end_date;
    let p_query_device_type = device_type;
    let p_query_device = device;
    let p_query_device_os = device_os;
    let p_query_gender = gender;
    let p_query_age_group = age_group;
    let p_query_country = country;
    let p_query_state = state;
    let p_query_city = city;
    let p_query_zip = zip;
    let p_query_model = model;
    let p_query_tag = tag;
    let p_query_user_account_id = user_account_id;
    let p_query_user_account_display = user_account_display;
    let p_query_user_account_username = user_account_username;
    let p_query_group_by_root = group_by_root;
    let p_query_group_by = group_by;
    let p_query_distinct_count = distinct_count;
    let p_query_sort_field = sort_field;
    let p_query_descending = descending;
    let p_query_hide_unknown = hide_unknown;
    let p_query_response_format = response_format;
    let p_query__l = _l;
    let p_query_limit = limit;
    let p_query_latitude = latitude;
    let p_query_longitude = longitude;

    let uri_str = format!("{}/api/{version}/analytics/aggregatedFilteredUsage", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_application_id {
        req_builder = req_builder.query(&[("applicationId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_key {
        req_builder = req_builder.query(&[("appKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("startDate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("endDate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_device_type {
        req_builder = req_builder.query(&[("deviceType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_device {
        req_builder = req_builder.query(&[("device", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_device_os {
        req_builder = req_builder.query(&[("deviceOS", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_gender {
        req_builder = req_builder.query(&[("gender", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_age_group {
        req_builder = req_builder.query(&[("ageGroup", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_state {
        req_builder = req_builder.query(&[("state", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_city {
        req_builder = req_builder.query(&[("city", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_zip {
        req_builder = req_builder.query(&[("zip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_model {
        req_builder = req_builder.query(&[("model", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_tag {
        req_builder = req_builder.query(&[("tag", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_user_account_id {
        req_builder = req_builder.query(&[("userAccountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_user_account_display {
        req_builder = req_builder.query(&[("userAccountDisplay", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_user_account_username {
        req_builder = req_builder.query(&[("userAccountUsername", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_group_by_root {
        req_builder = req_builder.query(&[("groupByRoot", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_group_by {
        req_builder = req_builder.query(&[("groupBy", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_distinct_count {
        req_builder = req_builder.query(&[("distinctCount", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_field {
        req_builder = req_builder.query(&[("sortField", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_descending {
        req_builder = req_builder.query(&[("descending", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_hide_unknown {
        req_builder = req_builder.query(&[("hideUnknown", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_response_format {
        req_builder = req_builder.query(&[("responseFormat", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query__l {
        req_builder = req_builder.query(&[("_l", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_latitude {
        req_builder = req_builder.query(&[("latitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_longitude {
        req_builder = req_builder.query(&[("longitude", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ChartData`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ChartData`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AggregatedFilteredUsageError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Query analytics to get data used for graphs and charts
pub async fn filtered_usage(configuration: &configuration::Configuration, version: f64, device_id: Option<&str>, account_id: Option<i64>, application_id: Option<i64>, app_key: Option<&str>, start_date: Option<i64>, end_date: Option<i64>, device_type: Option<&str>, device: Option<&str>, device_os: Option<&str>, gender: Option<&str>, age_group: Option<&str>, country: Option<&str>, state: Option<&str>, city: Option<&str>, zip: Option<&str>, model: Option<&str>, tag: Option<&str>, user_account_id: Option<i64>, user_account_display: Option<&str>, user_account_username: Option<&str>, custom_id: Option<i64>, custom_type: Option<&str>, custom_value: Option<f64>, custom_value2: Option<f64>, custom_long: Option<i64>, custom_long2: Option<i64>, custom_message: Option<&str>, custom_message2: Option<&str>, group_by: Option<&str>, distinct_count: Option<&str>, sum_column: Option<&str>, sort_field: Option<&str>, descending: Option<bool>, hide_unknown: Option<bool>, response_format: Option<&str>, _l: Option<i32>, limit: Option<i32>, latitude: Option<f64>, longitude: Option<f64>) -> Result<models::ChartData, Error<FilteredUsageError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_application_id = application_id;
    let p_query_app_key = app_key;
    let p_query_start_date = start_date;
    let p_query_end_date = end_date;
    let p_query_device_type = device_type;
    let p_query_device = device;
    let p_query_device_os = device_os;
    let p_query_gender = gender;
    let p_query_age_group = age_group;
    let p_query_country = country;
    let p_query_state = state;
    let p_query_city = city;
    let p_query_zip = zip;
    let p_query_model = model;
    let p_query_tag = tag;
    let p_query_user_account_id = user_account_id;
    let p_query_user_account_display = user_account_display;
    let p_query_user_account_username = user_account_username;
    let p_query_custom_id = custom_id;
    let p_query_custom_type = custom_type;
    let p_query_custom_value = custom_value;
    let p_query_custom_value2 = custom_value2;
    let p_query_custom_long = custom_long;
    let p_query_custom_long2 = custom_long2;
    let p_query_custom_message = custom_message;
    let p_query_custom_message2 = custom_message2;
    let p_query_group_by = group_by;
    let p_query_distinct_count = distinct_count;
    let p_query_sum_column = sum_column;
    let p_query_sort_field = sort_field;
    let p_query_descending = descending;
    let p_query_hide_unknown = hide_unknown;
    let p_query_response_format = response_format;
    let p_query__l = _l;
    let p_query_limit = limit;
    let p_query_latitude = latitude;
    let p_query_longitude = longitude;

    let uri_str = format!("{}/api/{version}/analytics/filteredUsage", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_application_id {
        req_builder = req_builder.query(&[("applicationId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_key {
        req_builder = req_builder.query(&[("appKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("startDate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("endDate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_device_type {
        req_builder = req_builder.query(&[("deviceType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_device {
        req_builder = req_builder.query(&[("device", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_device_os {
        req_builder = req_builder.query(&[("deviceOS", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_gender {
        req_builder = req_builder.query(&[("gender", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_age_group {
        req_builder = req_builder.query(&[("ageGroup", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_state {
        req_builder = req_builder.query(&[("state", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_city {
        req_builder = req_builder.query(&[("city", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_zip {
        req_builder = req_builder.query(&[("zip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_model {
        req_builder = req_builder.query(&[("model", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_tag {
        req_builder = req_builder.query(&[("tag", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_user_account_id {
        req_builder = req_builder.query(&[("userAccountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_user_account_display {
        req_builder = req_builder.query(&[("userAccountDisplay", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_user_account_username {
        req_builder = req_builder.query(&[("userAccountUsername", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_custom_id {
        req_builder = req_builder.query(&[("customId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_custom_type {
        req_builder = req_builder.query(&[("customType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_custom_value {
        req_builder = req_builder.query(&[("customValue", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_custom_value2 {
        req_builder = req_builder.query(&[("customValue2", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_custom_long {
        req_builder = req_builder.query(&[("customLong", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_custom_long2 {
        req_builder = req_builder.query(&[("customLong2", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_custom_message {
        req_builder = req_builder.query(&[("customMessage", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_custom_message2 {
        req_builder = req_builder.query(&[("customMessage2", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_group_by {
        req_builder = req_builder.query(&[("groupBy", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_distinct_count {
        req_builder = req_builder.query(&[("distinctCount", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sum_column {
        req_builder = req_builder.query(&[("sumColumn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_field {
        req_builder = req_builder.query(&[("sortField", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_descending {
        req_builder = req_builder.query(&[("descending", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_hide_unknown {
        req_builder = req_builder.query(&[("hideUnknown", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_response_format {
        req_builder = req_builder.query(&[("responseFormat", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query__l {
        req_builder = req_builder.query(&[("_l", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_latitude {
        req_builder = req_builder.query(&[("latitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_longitude {
        req_builder = req_builder.query(&[("longitude", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ChartData`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ChartData`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<FilteredUsageError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Record an analytic record for a known state within the application.
pub async fn usage(configuration: &configuration::Configuration, version: f64, tag: &str, device_id: Option<&str>, account_id: Option<i64>, application_id: Option<i64>, app_key: Option<&str>, app_version: Option<&str>, device: Option<&str>, device_type: Option<&str>, device_os: Option<&str>, model: Option<&str>, latitude: Option<f64>, longitude: Option<f64>, custom_id: Option<i64>, custom_type: Option<&str>, achievement_increment: Option<i64>, city: Option<&str>, state: Option<&str>, country: Option<&str>, zip: Option<&str>, location_description: Option<&str>, client_time: Option<i64>, error_message: Option<&str>, ip: Option<&str>, user_agent: Option<&str>, background_event: Option<bool>, custom_message: Option<&str>, custom_message2: Option<&str>, custom_value: Option<f64>, custom_value2: Option<f64>, custom_long: Option<i64>, custom_long2: Option<i64>) -> Result<models::SirqulResponse, Error<UsageError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_tag = tag;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_application_id = application_id;
    let p_query_app_key = app_key;
    let p_query_app_version = app_version;
    let p_query_device = device;
    let p_query_device_type = device_type;
    let p_query_device_os = device_os;
    let p_query_model = model;
    let p_query_latitude = latitude;
    let p_query_longitude = longitude;
    let p_query_custom_id = custom_id;
    let p_query_custom_type = custom_type;
    let p_query_achievement_increment = achievement_increment;
    let p_query_city = city;
    let p_query_state = state;
    let p_query_country = country;
    let p_query_zip = zip;
    let p_query_location_description = location_description;
    let p_query_client_time = client_time;
    let p_query_error_message = error_message;
    let p_query_ip = ip;
    let p_query_user_agent = user_agent;
    let p_query_background_event = background_event;
    let p_query_custom_message = custom_message;
    let p_query_custom_message2 = custom_message2;
    let p_query_custom_value = custom_value;
    let p_query_custom_value2 = custom_value2;
    let p_query_custom_long = custom_long;
    let p_query_custom_long2 = custom_long2;

    let uri_str = format!("{}/api/{version}/analytics/usage", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("tag", &p_query_tag.to_string())]);
    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_application_id {
        req_builder = req_builder.query(&[("applicationId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_key {
        req_builder = req_builder.query(&[("appKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_version {
        req_builder = req_builder.query(&[("appVersion", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_device {
        req_builder = req_builder.query(&[("device", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_device_type {
        req_builder = req_builder.query(&[("deviceType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_device_os {
        req_builder = req_builder.query(&[("deviceOS", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_model {
        req_builder = req_builder.query(&[("model", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_latitude {
        req_builder = req_builder.query(&[("latitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_longitude {
        req_builder = req_builder.query(&[("longitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_custom_id {
        req_builder = req_builder.query(&[("customId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_custom_type {
        req_builder = req_builder.query(&[("customType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_achievement_increment {
        req_builder = req_builder.query(&[("achievementIncrement", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_city {
        req_builder = req_builder.query(&[("city", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_state {
        req_builder = req_builder.query(&[("state", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_zip {
        req_builder = req_builder.query(&[("zip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_location_description {
        req_builder = req_builder.query(&[("locationDescription", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_client_time {
        req_builder = req_builder.query(&[("clientTime", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_error_message {
        req_builder = req_builder.query(&[("errorMessage", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ip {
        req_builder = req_builder.query(&[("ip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_user_agent {
        req_builder = req_builder.query(&[("userAgent", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_background_event {
        req_builder = req_builder.query(&[("backgroundEvent", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_custom_message {
        req_builder = req_builder.query(&[("customMessage", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_custom_message2 {
        req_builder = req_builder.query(&[("customMessage2", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_custom_value {
        req_builder = req_builder.query(&[("customValue", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_custom_value2 {
        req_builder = req_builder.query(&[("customValue2", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_custom_long {
        req_builder = req_builder.query(&[("customLong", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_custom_long2 {
        req_builder = req_builder.query(&[("customLong2", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SirqulResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SirqulResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UsageError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Sends multiple analytics. Can be used to send in the user's stored usage when they did not have internet access. Should not include more than 100 items per batch.
pub async fn usage_batch(configuration: &configuration::Configuration, version: f64, app_key: &str, device: &str, data: &str, device_id: Option<&str>, account_id: Option<i64>, app_version: Option<&str>, device_type: Option<&str>, device_os: Option<&str>, model: Option<&str>, update_ranking: Option<bool>, return_summary_response: Option<bool>) -> Result<models::SirqulResponse, Error<UsageBatchError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_app_key = app_key;
    let p_query_device = device;
    let p_query_data = data;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_app_version = app_version;
    let p_query_device_type = device_type;
    let p_query_device_os = device_os;
    let p_query_model = model;
    let p_query_update_ranking = update_ranking;
    let p_query_return_summary_response = return_summary_response;

    let uri_str = format!("{}/api/{version}/analytics/usage/batch", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("appKey", &p_query_app_key.to_string())]);
    if let Some(ref param_value) = p_query_app_version {
        req_builder = req_builder.query(&[("appVersion", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("device", &p_query_device.to_string())]);
    if let Some(ref param_value) = p_query_device_type {
        req_builder = req_builder.query(&[("deviceType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_device_os {
        req_builder = req_builder.query(&[("deviceOS", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_model {
        req_builder = req_builder.query(&[("model", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("data", &p_query_data.to_string())]);
    if let Some(ref param_value) = p_query_update_ranking {
        req_builder = req_builder.query(&[("updateRanking", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_return_summary_response {
        req_builder = req_builder.query(&[("returnSummaryResponse", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SirqulResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SirqulResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UsageBatchError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

