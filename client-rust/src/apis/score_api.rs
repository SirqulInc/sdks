/*
 * Sirqul IoT Platform
 *
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`create_score`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateScoreError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_score`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetScoreError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_scores`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchScoresError {
    UnknownValue(serde_json::Value),
}


/// Create a score.  The response object will contain a series of   coded messages detailing what items were completed, the score registered,   and any tickets allocated.  Scoring a  level could complete the pack it   is in, completing that pack could complete the game, which  in turn could   complete the mission.  This completion chain is indicated to the client   via  a list of {@link MessageResponse}.
pub async fn create_score(configuration: &configuration::Configuration, version: f64, account_id: i64, app_key: &str, points: i32, mission_id: Option<i64>, game_id: Option<i64>, pack_id: Option<i64>, game_level_id: Option<i64>, game_object_id: Option<i64>, time_taken: Option<i32>, highest: Option<bool>) -> Result<models::ScoreResponse, Error<CreateScoreError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_account_id = account_id;
    let p_query_app_key = app_key;
    let p_query_points = points;
    let p_query_mission_id = mission_id;
    let p_query_game_id = game_id;
    let p_query_pack_id = pack_id;
    let p_query_game_level_id = game_level_id;
    let p_query_game_object_id = game_object_id;
    let p_query_time_taken = time_taken;
    let p_query_highest = highest;

    let uri_str = format!("{}/api/{version}/score/create", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("appKey", &p_query_app_key.to_string())]);
    if let Some(ref param_value) = p_query_mission_id {
        req_builder = req_builder.query(&[("missionId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_game_id {
        req_builder = req_builder.query(&[("gameId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_pack_id {
        req_builder = req_builder.query(&[("packId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_game_level_id {
        req_builder = req_builder.query(&[("gameLevelId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_game_object_id {
        req_builder = req_builder.query(&[("gameObjectId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("points", &p_query_points.to_string())]);
    if let Some(ref param_value) = p_query_time_taken {
        req_builder = req_builder.query(&[("timeTaken", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_highest {
        req_builder = req_builder.query(&[("highest", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ScoreResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ScoreResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateScoreError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the high score for an item.  Pass in the full path IDs for the score.
pub async fn get_score(configuration: &configuration::Configuration, version: f64, account_id: i64, app_key: &str, mission_id: Option<i64>, game_id: Option<i64>, pack_id: Option<i64>, game_level_id: Option<i64>, game_object_id: Option<i64>, score_object_type: Option<&str>, score_status: Option<&str>) -> Result<models::ScoreResponse, Error<GetScoreError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_account_id = account_id;
    let p_query_app_key = app_key;
    let p_query_mission_id = mission_id;
    let p_query_game_id = game_id;
    let p_query_pack_id = pack_id;
    let p_query_game_level_id = game_level_id;
    let p_query_game_object_id = game_object_id;
    let p_query_score_object_type = score_object_type;
    let p_query_score_status = score_status;

    let uri_str = format!("{}/api/{version}/score/get", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("appKey", &p_query_app_key.to_string())]);
    if let Some(ref param_value) = p_query_mission_id {
        req_builder = req_builder.query(&[("missionId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_game_id {
        req_builder = req_builder.query(&[("gameId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_pack_id {
        req_builder = req_builder.query(&[("packId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_game_level_id {
        req_builder = req_builder.query(&[("gameLevelId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_game_object_id {
        req_builder = req_builder.query(&[("gameObjectId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_score_object_type {
        req_builder = req_builder.query(&[("scoreObjectType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_score_status {
        req_builder = req_builder.query(&[("scoreStatus", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ScoreResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ScoreResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetScoreError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Search the scores for an item.  Pass in the full path IDs for the scores.
pub async fn search_scores(configuration: &configuration::Configuration, version: f64, account_id: i64, app_key: &str, mission_id: Option<i64>, game_id: Option<i64>, pack_id: Option<i64>, game_level_id: Option<i64>, game_object_id: Option<i64>) -> Result<Vec<models::ScoreResponse>, Error<SearchScoresError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_account_id = account_id;
    let p_query_app_key = app_key;
    let p_query_mission_id = mission_id;
    let p_query_game_id = game_id;
    let p_query_pack_id = pack_id;
    let p_query_game_level_id = game_level_id;
    let p_query_game_object_id = game_object_id;

    let uri_str = format!("{}/api/{version}/score/search", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("appKey", &p_query_app_key.to_string())]);
    if let Some(ref param_value) = p_query_mission_id {
        req_builder = req_builder.query(&[("missionId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_game_id {
        req_builder = req_builder.query(&[("gameId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_pack_id {
        req_builder = req_builder.query(&[("packId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_game_level_id {
        req_builder = req_builder.query(&[("gameLevelId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_game_object_id {
        req_builder = req_builder.query(&[("gameObjectId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::ScoreResponse&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::ScoreResponse&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchScoresError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

