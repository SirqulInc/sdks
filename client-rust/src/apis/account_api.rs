/*
 * Sirqul IoT Platform
 *
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`account_location_search`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountLocationSearchError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`block_account`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BlockAccountError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_account`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateAccountError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`edit_account`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EditAccountError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`edit_username`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EditUsernameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_account`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAccountError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_profile_assets`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetProfileAssetsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_referral_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetReferralListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_settings`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSettingsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`login_delegate`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LoginDelegateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`login_general`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LoginGeneralError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`login_username`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LoginUsernameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`logout`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LogoutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`merge_account`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MergeAccountError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`password_change`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PasswordChangeError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`password_reset`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PasswordResetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`request_password_reset`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RequestPasswordResetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`request_validate_account`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RequestValidateAccountError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_accounts`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchAccountsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secure_login`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecureLoginError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secure_signup`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecureSignupError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`set_match_token`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SetMatchTokenError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_actve_status`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateActveStatusError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_location`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateLocationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_settings`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateSettingsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`validate_account_signup`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ValidateAccountSignupError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`validate_password_reset`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ValidatePasswordResetError {
    UnknownValue(serde_json::Value),
}


/// Search accounts by their location. This only searches on users that have location data. Use ConnectionApi to perform a regular search on accounts.
pub async fn account_location_search(configuration: &configuration::Configuration, version: f64, device_id: Option<&str>, account_id: Option<i64>, q: Option<&str>, keyword: Option<&str>, postal_code: Option<&str>, latitude: Option<f64>, longitude: Option<f64>, app_key: Option<&str>, range: Option<f64>, location_last_updated: Option<i64>, gender: Option<&str>, min_age: Option<i32>, max_age: Option<i32>, companionship_index: Option<i32>, _i: Option<i32>, start: Option<i32>, _l: Option<i32>, limit: Option<i32>, search_mode: Option<&str>, sort_field: Option<&str>, descending: Option<bool>, roles: Option<&str>, tags: Option<&str>, experience: Option<&str>, category_ids: Option<&str>, audience_ids: Option<&str>, audience_operator: Option<&str>, update_current_location: Option<bool>, update_preferred_settings: Option<bool>, show_exact_locations: Option<bool>, show_connection_to_searcher: Option<bool>, flag_count_minimum: Option<i64>, verified_user_only: Option<bool>, content_admin_only: Option<bool>) -> Result<models::UserLocationSearchResponse, Error<AccountLocationSearchError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_q = q;
    let p_query_keyword = keyword;
    let p_query_postal_code = postal_code;
    let p_query_latitude = latitude;
    let p_query_longitude = longitude;
    let p_query_app_key = app_key;
    let p_query_range = range;
    let p_query_location_last_updated = location_last_updated;
    let p_query_gender = gender;
    let p_query_min_age = min_age;
    let p_query_max_age = max_age;
    let p_query_companionship_index = companionship_index;
    let p_query__i = _i;
    let p_query_start = start;
    let p_query__l = _l;
    let p_query_limit = limit;
    let p_query_search_mode = search_mode;
    let p_query_sort_field = sort_field;
    let p_query_descending = descending;
    let p_query_roles = roles;
    let p_query_tags = tags;
    let p_query_experience = experience;
    let p_query_category_ids = category_ids;
    let p_query_audience_ids = audience_ids;
    let p_query_audience_operator = audience_operator;
    let p_query_update_current_location = update_current_location;
    let p_query_update_preferred_settings = update_preferred_settings;
    let p_query_show_exact_locations = show_exact_locations;
    let p_query_show_connection_to_searcher = show_connection_to_searcher;
    let p_query_flag_count_minimum = flag_count_minimum;
    let p_query_verified_user_only = verified_user_only;
    let p_query_content_admin_only = content_admin_only;

    let uri_str = format!("{}/api/{version}/account/search", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_q {
        req_builder = req_builder.query(&[("q", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_keyword {
        req_builder = req_builder.query(&[("keyword", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_postal_code {
        req_builder = req_builder.query(&[("postalCode", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_latitude {
        req_builder = req_builder.query(&[("latitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_longitude {
        req_builder = req_builder.query(&[("longitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_key {
        req_builder = req_builder.query(&[("appKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_range {
        req_builder = req_builder.query(&[("range", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_location_last_updated {
        req_builder = req_builder.query(&[("locationLastUpdated", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_gender {
        req_builder = req_builder.query(&[("gender", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_min_age {
        req_builder = req_builder.query(&[("minAge", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_max_age {
        req_builder = req_builder.query(&[("maxAge", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_companionship_index {
        req_builder = req_builder.query(&[("companionshipIndex", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query__i {
        req_builder = req_builder.query(&[("_i", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start {
        req_builder = req_builder.query(&[("start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query__l {
        req_builder = req_builder.query(&[("_l", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search_mode {
        req_builder = req_builder.query(&[("searchMode", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_field {
        req_builder = req_builder.query(&[("sortField", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_descending {
        req_builder = req_builder.query(&[("descending", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_roles {
        req_builder = req_builder.query(&[("roles", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_tags {
        req_builder = req_builder.query(&[("tags", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_experience {
        req_builder = req_builder.query(&[("experience", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_category_ids {
        req_builder = req_builder.query(&[("categoryIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_audience_ids {
        req_builder = req_builder.query(&[("audienceIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_audience_operator {
        req_builder = req_builder.query(&[("audienceOperator", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_update_current_location {
        req_builder = req_builder.query(&[("updateCurrentLocation", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_update_preferred_settings {
        req_builder = req_builder.query(&[("updatePreferredSettings", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_show_exact_locations {
        req_builder = req_builder.query(&[("showExactLocations", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_show_connection_to_searcher {
        req_builder = req_builder.query(&[("showConnectionToSearcher", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_flag_count_minimum {
        req_builder = req_builder.query(&[("flagCountMinimum", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_verified_user_only {
        req_builder = req_builder.query(&[("verifiedUserOnly", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_content_admin_only {
        req_builder = req_builder.query(&[("contentAdminOnly", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserLocationSearchResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserLocationSearchResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountLocationSearchError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Moves or removes an account into the user's blocked group.
pub async fn block_account(configuration: &configuration::Configuration, version: f64, account_id_being_blocked: i64, device_id: Option<&str>, account_id: Option<i64>, block_flag_value: Option<bool>, remove_from_groups_if_blocked: Option<bool>, latitude: Option<f64>, longitude: Option<f64>) -> Result<models::SirqulResponse, Error<BlockAccountError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_account_id_being_blocked = account_id_being_blocked;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_block_flag_value = block_flag_value;
    let p_query_remove_from_groups_if_blocked = remove_from_groups_if_blocked;
    let p_query_latitude = latitude;
    let p_query_longitude = longitude;

    let uri_str = format!("{}/api/{version}/account/block", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("accountIdBeingBlocked", &p_query_account_id_being_blocked.to_string())]);
    if let Some(ref param_value) = p_query_block_flag_value {
        req_builder = req_builder.query(&[("blockFlagValue", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_remove_from_groups_if_blocked {
        req_builder = req_builder.query(&[("removeFromGroupsIfBlocked", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_latitude {
        req_builder = req_builder.query(&[("latitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_longitude {
        req_builder = req_builder.query(&[("longitude", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SirqulResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SirqulResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BlockAccountError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create a new account by role.
pub async fn create_account(configuration: &configuration::Configuration, version: f64, username: &str, password: &str, name: Option<&str>, prefix_name: Option<&str>, first_name: Option<&str>, middle_name: Option<&str>, last_name: Option<&str>, suffix_name: Option<&str>, title: Option<&str>, device_id: Option<&str>, device_id_type: Option<&str>, email_address: Option<&str>, asset_id: Option<i64>, street_address: Option<&str>, zipcode: Option<&str>, gender: Option<&str>, birthday: Option<i64>, home_phone: Option<&str>, cell_phone: Option<&str>, cell_phone_carrier: Option<&str>, business_phone: Option<&str>, role: Option<&str>, platforms: Option<&str>, tags: Option<&str>, about_us: Option<&str>, game_experience: Option<&str>, category_ids: Option<&str>, hometown: Option<&str>, height: Option<&str>, height_index: Option<i32>, ethnicity: Option<&str>, body_type: Option<&str>, marital_status: Option<&str>, children: Option<&str>, religion: Option<&str>, education: Option<&str>, education_index: Option<i32>, smoke: Option<&str>, drink: Option<&str>, companionship: Option<&str>, companionship_index: Option<i32>, preferred_min_age: Option<i32>, preferred_max_age: Option<i32>, preferred_min_height: Option<i32>, preferred_max_height: Option<i32>, preferred_gender: Option<&str>, preferred_education: Option<&str>, preferred_education_index: Option<i32>, preferred_body_type: Option<&str>, preferred_ethnicity: Option<&str>, preferred_location: Option<&str>, preferred_location_range: Option<f64>, latitude: Option<f64>, longitude: Option<f64>, accepted_terms: Option<bool>, invite_token: Option<&str>, referral_account_id: Option<i64>, send_validation: Option<bool>, game_type: Option<&str>, app_key: Option<&str>, app_version: Option<&str>, response_type: Option<&str>, audience_ids_to_add: Option<&str>, app_blob: Option<&str>, app_enable_push: Option<bool>, app_enable_sms: Option<bool>, app_enable_email: Option<bool>, location_visibility: Option<&str>, home_latitude: Option<f64>, home_longitude: Option<f64>, app_nickname: Option<&str>, personal_audience_id: Option<i64>) -> Result<models::AccountLoginResponse, Error<CreateAccountError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_username = username;
    let p_query_password = password;
    let p_query_name = name;
    let p_query_prefix_name = prefix_name;
    let p_query_first_name = first_name;
    let p_query_middle_name = middle_name;
    let p_query_last_name = last_name;
    let p_query_suffix_name = suffix_name;
    let p_query_title = title;
    let p_query_device_id = device_id;
    let p_query_device_id_type = device_id_type;
    let p_query_email_address = email_address;
    let p_query_asset_id = asset_id;
    let p_query_street_address = street_address;
    let p_query_zipcode = zipcode;
    let p_query_gender = gender;
    let p_query_birthday = birthday;
    let p_query_home_phone = home_phone;
    let p_query_cell_phone = cell_phone;
    let p_query_cell_phone_carrier = cell_phone_carrier;
    let p_query_business_phone = business_phone;
    let p_query_role = role;
    let p_query_platforms = platforms;
    let p_query_tags = tags;
    let p_query_about_us = about_us;
    let p_query_game_experience = game_experience;
    let p_query_category_ids = category_ids;
    let p_query_hometown = hometown;
    let p_query_height = height;
    let p_query_height_index = height_index;
    let p_query_ethnicity = ethnicity;
    let p_query_body_type = body_type;
    let p_query_marital_status = marital_status;
    let p_query_children = children;
    let p_query_religion = religion;
    let p_query_education = education;
    let p_query_education_index = education_index;
    let p_query_smoke = smoke;
    let p_query_drink = drink;
    let p_query_companionship = companionship;
    let p_query_companionship_index = companionship_index;
    let p_query_preferred_min_age = preferred_min_age;
    let p_query_preferred_max_age = preferred_max_age;
    let p_query_preferred_min_height = preferred_min_height;
    let p_query_preferred_max_height = preferred_max_height;
    let p_query_preferred_gender = preferred_gender;
    let p_query_preferred_education = preferred_education;
    let p_query_preferred_education_index = preferred_education_index;
    let p_query_preferred_body_type = preferred_body_type;
    let p_query_preferred_ethnicity = preferred_ethnicity;
    let p_query_preferred_location = preferred_location;
    let p_query_preferred_location_range = preferred_location_range;
    let p_query_latitude = latitude;
    let p_query_longitude = longitude;
    let p_query_accepted_terms = accepted_terms;
    let p_query_invite_token = invite_token;
    let p_query_referral_account_id = referral_account_id;
    let p_query_send_validation = send_validation;
    let p_query_game_type = game_type;
    let p_query_app_key = app_key;
    let p_query_app_version = app_version;
    let p_query_response_type = response_type;
    let p_query_audience_ids_to_add = audience_ids_to_add;
    let p_query_app_blob = app_blob;
    let p_query_app_enable_push = app_enable_push;
    let p_query_app_enable_sms = app_enable_sms;
    let p_query_app_enable_email = app_enable_email;
    let p_query_location_visibility = location_visibility;
    let p_query_home_latitude = home_latitude;
    let p_query_home_longitude = home_longitude;
    let p_query_app_nickname = app_nickname;
    let p_query_personal_audience_id = personal_audience_id;

    let uri_str = format!("{}/api/{version}/account/create", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_prefix_name {
        req_builder = req_builder.query(&[("prefixName", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_first_name {
        req_builder = req_builder.query(&[("firstName", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_middle_name {
        req_builder = req_builder.query(&[("middleName", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_last_name {
        req_builder = req_builder.query(&[("lastName", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_suffix_name {
        req_builder = req_builder.query(&[("suffixName", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_title {
        req_builder = req_builder.query(&[("title", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_device_id_type {
        req_builder = req_builder.query(&[("deviceIdType", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("username", &p_query_username.to_string())]);
    req_builder = req_builder.query(&[("password", &p_query_password.to_string())]);
    if let Some(ref param_value) = p_query_email_address {
        req_builder = req_builder.query(&[("emailAddress", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_asset_id {
        req_builder = req_builder.query(&[("assetId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_street_address {
        req_builder = req_builder.query(&[("streetAddress", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_zipcode {
        req_builder = req_builder.query(&[("zipcode", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_gender {
        req_builder = req_builder.query(&[("gender", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_birthday {
        req_builder = req_builder.query(&[("birthday", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_home_phone {
        req_builder = req_builder.query(&[("homePhone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cell_phone {
        req_builder = req_builder.query(&[("cellPhone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cell_phone_carrier {
        req_builder = req_builder.query(&[("cellPhoneCarrier", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_business_phone {
        req_builder = req_builder.query(&[("businessPhone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_role {
        req_builder = req_builder.query(&[("role", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_platforms {
        req_builder = req_builder.query(&[("platforms", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_tags {
        req_builder = req_builder.query(&[("tags", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_about_us {
        req_builder = req_builder.query(&[("aboutUs", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_game_experience {
        req_builder = req_builder.query(&[("gameExperience", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_category_ids {
        req_builder = req_builder.query(&[("categoryIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_hometown {
        req_builder = req_builder.query(&[("hometown", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_height {
        req_builder = req_builder.query(&[("height", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_height_index {
        req_builder = req_builder.query(&[("heightIndex", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ethnicity {
        req_builder = req_builder.query(&[("ethnicity", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_body_type {
        req_builder = req_builder.query(&[("bodyType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_marital_status {
        req_builder = req_builder.query(&[("maritalStatus", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_children {
        req_builder = req_builder.query(&[("children", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_religion {
        req_builder = req_builder.query(&[("religion", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_education {
        req_builder = req_builder.query(&[("education", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_education_index {
        req_builder = req_builder.query(&[("educationIndex", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_smoke {
        req_builder = req_builder.query(&[("smoke", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_drink {
        req_builder = req_builder.query(&[("drink", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_companionship {
        req_builder = req_builder.query(&[("companionship", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_companionship_index {
        req_builder = req_builder.query(&[("companionshipIndex", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_preferred_min_age {
        req_builder = req_builder.query(&[("preferredMinAge", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_preferred_max_age {
        req_builder = req_builder.query(&[("preferredMaxAge", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_preferred_min_height {
        req_builder = req_builder.query(&[("preferredMinHeight", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_preferred_max_height {
        req_builder = req_builder.query(&[("preferredMaxHeight", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_preferred_gender {
        req_builder = req_builder.query(&[("preferredGender", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_preferred_education {
        req_builder = req_builder.query(&[("preferredEducation", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_preferred_education_index {
        req_builder = req_builder.query(&[("preferredEducationIndex", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_preferred_body_type {
        req_builder = req_builder.query(&[("preferredBodyType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_preferred_ethnicity {
        req_builder = req_builder.query(&[("preferredEthnicity", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_preferred_location {
        req_builder = req_builder.query(&[("preferredLocation", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_preferred_location_range {
        req_builder = req_builder.query(&[("preferredLocationRange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_latitude {
        req_builder = req_builder.query(&[("latitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_longitude {
        req_builder = req_builder.query(&[("longitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_accepted_terms {
        req_builder = req_builder.query(&[("acceptedTerms", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_invite_token {
        req_builder = req_builder.query(&[("inviteToken", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_referral_account_id {
        req_builder = req_builder.query(&[("referralAccountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_send_validation {
        req_builder = req_builder.query(&[("sendValidation", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_game_type {
        req_builder = req_builder.query(&[("gameType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_key {
        req_builder = req_builder.query(&[("appKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_version {
        req_builder = req_builder.query(&[("appVersion", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_response_type {
        req_builder = req_builder.query(&[("responseType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_audience_ids_to_add {
        req_builder = req_builder.query(&[("audienceIdsToAdd", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_blob {
        req_builder = req_builder.query(&[("appBlob", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_enable_push {
        req_builder = req_builder.query(&[("appEnablePush", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_enable_sms {
        req_builder = req_builder.query(&[("appEnableSMS", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_enable_email {
        req_builder = req_builder.query(&[("appEnableEmail", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_location_visibility {
        req_builder = req_builder.query(&[("locationVisibility", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_home_latitude {
        req_builder = req_builder.query(&[("homeLatitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_home_longitude {
        req_builder = req_builder.query(&[("homeLongitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_nickname {
        req_builder = req_builder.query(&[("appNickname", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_personal_audience_id {
        req_builder = req_builder.query(&[("personalAudienceId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AccountLoginResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AccountLoginResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateAccountError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Edit the user's profile information
pub async fn edit_account(configuration: &configuration::Configuration, version: f64, device_id: Option<&str>, account_id: Option<i64>, connection_account_id: Option<i64>, role: Option<&str>, asset_id: Option<i64>, name: Option<&str>, prefix_name: Option<&str>, first_name: Option<&str>, middle_name: Option<&str>, last_name: Option<&str>, suffix_name: Option<&str>, title: Option<&str>, gender: Option<&str>, age: Option<i32>, birthday: Option<i64>, home_phone: Option<&str>, cell_phone: Option<&str>, cell_phone_carrier: Option<&str>, business_phone: Option<&str>, email_address: Option<&str>, street_address: Option<&str>, street_address2: Option<&str>, city: Option<&str>, state: Option<&str>, zipcode: Option<&str>, country: Option<&str>, make_profile_info_public: Option<bool>, make_game_info_public: Option<bool>, make_friends_info_public: Option<bool>, hometown: Option<&str>, height: Option<&str>, height_index: Option<i32>, ethnicity: Option<&str>, body_type: Option<&str>, marital_status: Option<&str>, children: Option<&str>, religion: Option<&str>, education: Option<&str>, education_index: Option<i32>, smoke: Option<&str>, drink: Option<&str>, companionship: Option<&str>, companionship_index: Option<i32>, preferred_min_age: Option<i32>, preferred_max_age: Option<i32>, preferred_min_height: Option<i32>, preferred_max_height: Option<i32>, preferred_gender: Option<&str>, preferred_education: Option<&str>, preferred_education_index: Option<i32>, preferred_body_type: Option<&str>, preferred_ethnicity: Option<&str>, preferred_location: Option<&str>, preferred_location_range: Option<f64>, platforms: Option<&str>, tags: Option<&str>, about_us: Option<&str>, match_token: Option<&str>, game_experience: Option<&str>, categories: Option<&str>, category_ids: Option<&str>, response_filters: Option<&str>, show_as_zipcode: Option<bool>, show_exact_location: Option<bool>, show_others_exact_location: Option<bool>, accepted_terms: Option<bool>, location_visibility: Option<&str>, app_blob: Option<&str>, app_enable_push: Option<bool>, app_enable_sms: Option<bool>, app_enable_email: Option<bool>, game_type: Option<&str>, app_key: Option<&str>, latitude: Option<f64>, longitude: Option<f64>, return_profile: Option<bool>, audience_ids_to_add: Option<&str>, audience_ids_to_remove: Option<&str>, referral_account_id: Option<i64>, app_nickname: Option<&str>, personal_audience_id: Option<i64>, non_guest_username: Option<&str>) -> Result<models::ProfileInfoResponse, Error<EditAccountError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_connection_account_id = connection_account_id;
    let p_query_role = role;
    let p_query_asset_id = asset_id;
    let p_query_name = name;
    let p_query_prefix_name = prefix_name;
    let p_query_first_name = first_name;
    let p_query_middle_name = middle_name;
    let p_query_last_name = last_name;
    let p_query_suffix_name = suffix_name;
    let p_query_title = title;
    let p_query_gender = gender;
    let p_query_age = age;
    let p_query_birthday = birthday;
    let p_query_home_phone = home_phone;
    let p_query_cell_phone = cell_phone;
    let p_query_cell_phone_carrier = cell_phone_carrier;
    let p_query_business_phone = business_phone;
    let p_query_email_address = email_address;
    let p_query_street_address = street_address;
    let p_query_street_address2 = street_address2;
    let p_query_city = city;
    let p_query_state = state;
    let p_query_zipcode = zipcode;
    let p_query_country = country;
    let p_query_make_profile_info_public = make_profile_info_public;
    let p_query_make_game_info_public = make_game_info_public;
    let p_query_make_friends_info_public = make_friends_info_public;
    let p_query_hometown = hometown;
    let p_query_height = height;
    let p_query_height_index = height_index;
    let p_query_ethnicity = ethnicity;
    let p_query_body_type = body_type;
    let p_query_marital_status = marital_status;
    let p_query_children = children;
    let p_query_religion = religion;
    let p_query_education = education;
    let p_query_education_index = education_index;
    let p_query_smoke = smoke;
    let p_query_drink = drink;
    let p_query_companionship = companionship;
    let p_query_companionship_index = companionship_index;
    let p_query_preferred_min_age = preferred_min_age;
    let p_query_preferred_max_age = preferred_max_age;
    let p_query_preferred_min_height = preferred_min_height;
    let p_query_preferred_max_height = preferred_max_height;
    let p_query_preferred_gender = preferred_gender;
    let p_query_preferred_education = preferred_education;
    let p_query_preferred_education_index = preferred_education_index;
    let p_query_preferred_body_type = preferred_body_type;
    let p_query_preferred_ethnicity = preferred_ethnicity;
    let p_query_preferred_location = preferred_location;
    let p_query_preferred_location_range = preferred_location_range;
    let p_query_platforms = platforms;
    let p_query_tags = tags;
    let p_query_about_us = about_us;
    let p_query_match_token = match_token;
    let p_query_game_experience = game_experience;
    let p_query_categories = categories;
    let p_query_category_ids = category_ids;
    let p_query_response_filters = response_filters;
    let p_query_show_as_zipcode = show_as_zipcode;
    let p_query_show_exact_location = show_exact_location;
    let p_query_show_others_exact_location = show_others_exact_location;
    let p_query_accepted_terms = accepted_terms;
    let p_query_location_visibility = location_visibility;
    let p_query_app_blob = app_blob;
    let p_query_app_enable_push = app_enable_push;
    let p_query_app_enable_sms = app_enable_sms;
    let p_query_app_enable_email = app_enable_email;
    let p_query_game_type = game_type;
    let p_query_app_key = app_key;
    let p_query_latitude = latitude;
    let p_query_longitude = longitude;
    let p_query_return_profile = return_profile;
    let p_query_audience_ids_to_add = audience_ids_to_add;
    let p_query_audience_ids_to_remove = audience_ids_to_remove;
    let p_query_referral_account_id = referral_account_id;
    let p_query_app_nickname = app_nickname;
    let p_query_personal_audience_id = personal_audience_id;
    let p_query_non_guest_username = non_guest_username;

    let uri_str = format!("{}/api/{version}/account/profile/update", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_connection_account_id {
        req_builder = req_builder.query(&[("connectionAccountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_role {
        req_builder = req_builder.query(&[("role", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_asset_id {
        req_builder = req_builder.query(&[("assetId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_prefix_name {
        req_builder = req_builder.query(&[("prefixName", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_first_name {
        req_builder = req_builder.query(&[("firstName", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_middle_name {
        req_builder = req_builder.query(&[("middleName", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_last_name {
        req_builder = req_builder.query(&[("lastName", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_suffix_name {
        req_builder = req_builder.query(&[("suffixName", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_title {
        req_builder = req_builder.query(&[("title", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_gender {
        req_builder = req_builder.query(&[("gender", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_age {
        req_builder = req_builder.query(&[("age", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_birthday {
        req_builder = req_builder.query(&[("birthday", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_home_phone {
        req_builder = req_builder.query(&[("homePhone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cell_phone {
        req_builder = req_builder.query(&[("cellPhone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cell_phone_carrier {
        req_builder = req_builder.query(&[("cellPhoneCarrier", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_business_phone {
        req_builder = req_builder.query(&[("businessPhone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_email_address {
        req_builder = req_builder.query(&[("emailAddress", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_street_address {
        req_builder = req_builder.query(&[("streetAddress", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_street_address2 {
        req_builder = req_builder.query(&[("streetAddress2", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_city {
        req_builder = req_builder.query(&[("city", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_state {
        req_builder = req_builder.query(&[("state", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_zipcode {
        req_builder = req_builder.query(&[("zipcode", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_make_profile_info_public {
        req_builder = req_builder.query(&[("makeProfileInfoPublic", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_make_game_info_public {
        req_builder = req_builder.query(&[("makeGameInfoPublic", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_make_friends_info_public {
        req_builder = req_builder.query(&[("makeFriendsInfoPublic", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_hometown {
        req_builder = req_builder.query(&[("hometown", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_height {
        req_builder = req_builder.query(&[("height", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_height_index {
        req_builder = req_builder.query(&[("heightIndex", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ethnicity {
        req_builder = req_builder.query(&[("ethnicity", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_body_type {
        req_builder = req_builder.query(&[("bodyType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_marital_status {
        req_builder = req_builder.query(&[("maritalStatus", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_children {
        req_builder = req_builder.query(&[("children", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_religion {
        req_builder = req_builder.query(&[("religion", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_education {
        req_builder = req_builder.query(&[("education", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_education_index {
        req_builder = req_builder.query(&[("educationIndex", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_smoke {
        req_builder = req_builder.query(&[("smoke", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_drink {
        req_builder = req_builder.query(&[("drink", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_companionship {
        req_builder = req_builder.query(&[("companionship", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_companionship_index {
        req_builder = req_builder.query(&[("companionshipIndex", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_preferred_min_age {
        req_builder = req_builder.query(&[("preferredMinAge", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_preferred_max_age {
        req_builder = req_builder.query(&[("preferredMaxAge", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_preferred_min_height {
        req_builder = req_builder.query(&[("preferredMinHeight", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_preferred_max_height {
        req_builder = req_builder.query(&[("preferredMaxHeight", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_preferred_gender {
        req_builder = req_builder.query(&[("preferredGender", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_preferred_education {
        req_builder = req_builder.query(&[("preferredEducation", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_preferred_education_index {
        req_builder = req_builder.query(&[("preferredEducationIndex", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_preferred_body_type {
        req_builder = req_builder.query(&[("preferredBodyType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_preferred_ethnicity {
        req_builder = req_builder.query(&[("preferredEthnicity", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_preferred_location {
        req_builder = req_builder.query(&[("preferredLocation", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_preferred_location_range {
        req_builder = req_builder.query(&[("preferredLocationRange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_platforms {
        req_builder = req_builder.query(&[("platforms", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_tags {
        req_builder = req_builder.query(&[("tags", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_about_us {
        req_builder = req_builder.query(&[("aboutUs", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_match_token {
        req_builder = req_builder.query(&[("matchToken", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_game_experience {
        req_builder = req_builder.query(&[("gameExperience", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_categories {
        req_builder = req_builder.query(&[("categories", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_category_ids {
        req_builder = req_builder.query(&[("categoryIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_response_filters {
        req_builder = req_builder.query(&[("responseFilters", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_show_as_zipcode {
        req_builder = req_builder.query(&[("showAsZipcode", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_show_exact_location {
        req_builder = req_builder.query(&[("showExactLocation", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_show_others_exact_location {
        req_builder = req_builder.query(&[("showOthersExactLocation", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_accepted_terms {
        req_builder = req_builder.query(&[("acceptedTerms", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_location_visibility {
        req_builder = req_builder.query(&[("locationVisibility", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_blob {
        req_builder = req_builder.query(&[("appBlob", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_enable_push {
        req_builder = req_builder.query(&[("appEnablePush", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_enable_sms {
        req_builder = req_builder.query(&[("appEnableSMS", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_enable_email {
        req_builder = req_builder.query(&[("appEnableEmail", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_game_type {
        req_builder = req_builder.query(&[("gameType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_key {
        req_builder = req_builder.query(&[("appKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_latitude {
        req_builder = req_builder.query(&[("latitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_longitude {
        req_builder = req_builder.query(&[("longitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_return_profile {
        req_builder = req_builder.query(&[("returnProfile", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_audience_ids_to_add {
        req_builder = req_builder.query(&[("audienceIdsToAdd", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_audience_ids_to_remove {
        req_builder = req_builder.query(&[("audienceIdsToRemove", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_referral_account_id {
        req_builder = req_builder.query(&[("referralAccountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_nickname {
        req_builder = req_builder.query(&[("appNickname", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_personal_audience_id {
        req_builder = req_builder.query(&[("personalAudienceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_non_guest_username {
        req_builder = req_builder.query(&[("nonGuestUsername", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProfileInfoResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProfileInfoResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EditAccountError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update account's own username and/or emailAddress
pub async fn edit_username(configuration: &configuration::Configuration, version: f64, device_id: Option<&str>, account_id: Option<i64>, email_address: Option<&str>, username: Option<&str>) -> Result<models::SirqulResponse, Error<EditUsernameError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_email_address = email_address;
    let p_query_username = username;

    let uri_str = format!("{}/api/{version}/account/username/update", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_email_address {
        req_builder = req_builder.query(&[("emailAddress", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_username {
        req_builder = req_builder.query(&[("username", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SirqulResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SirqulResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EditUsernameError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets a user's account profile. Application settings and account settings will also be returned for the owner of the account.
pub async fn get_account(configuration: &configuration::Configuration, version: f64, return_nulls: Option<bool>, device_id: Option<&str>, account_id: Option<i64>, connection_account_email: Option<&str>, connection_account_id: Option<i64>, response_filters: Option<&str>, game_type: Option<&str>, app_key: Option<&str>, purchase_type: Option<&str>, update_viewed_date: Option<bool>, latitude: Option<f64>, longitude: Option<f64>) -> Result<models::ProfileResponse, Error<GetAccountError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_return_nulls = return_nulls;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_connection_account_email = connection_account_email;
    let p_query_connection_account_id = connection_account_id;
    let p_query_response_filters = response_filters;
    let p_query_game_type = game_type;
    let p_query_app_key = app_key;
    let p_query_purchase_type = purchase_type;
    let p_query_update_viewed_date = update_viewed_date;
    let p_query_latitude = latitude;
    let p_query_longitude = longitude;

    let uri_str = format!("{}/api/{version}/account/profile/get", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_return_nulls {
        req_builder = req_builder.query(&[("returnNulls", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_connection_account_email {
        req_builder = req_builder.query(&[("connectionAccountEmail", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_connection_account_id {
        req_builder = req_builder.query(&[("connectionAccountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_response_filters {
        req_builder = req_builder.query(&[("responseFilters", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_game_type {
        req_builder = req_builder.query(&[("gameType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_key {
        req_builder = req_builder.query(&[("appKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_purchase_type {
        req_builder = req_builder.query(&[("purchaseType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_update_viewed_date {
        req_builder = req_builder.query(&[("updateViewedDate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_latitude {
        req_builder = req_builder.query(&[("latitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_longitude {
        req_builder = req_builder.query(&[("longitude", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProfileResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProfileResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAccountError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a list of assets a person has ever uploaded. Filters the list based on parameters.
pub async fn get_profile_assets(configuration: &configuration::Configuration, version: f64, return_nulls: Option<bool>, device_id: Option<&str>, account_id: Option<i64>, owner_id: Option<i64>, media_types: Option<&str>, mime_types: Option<&str>, sort_field: Option<&str>, descending: Option<bool>, latitude: Option<f64>, longitude: Option<f64>, _i: Option<i32>, start: Option<i32>, _l: Option<i32>, limit: Option<i32>) -> Result<models::AssetListResponse, Error<GetProfileAssetsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_return_nulls = return_nulls;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_owner_id = owner_id;
    let p_query_media_types = media_types;
    let p_query_mime_types = mime_types;
    let p_query_sort_field = sort_field;
    let p_query_descending = descending;
    let p_query_latitude = latitude;
    let p_query_longitude = longitude;
    let p_query__i = _i;
    let p_query_start = start;
    let p_query__l = _l;
    let p_query_limit = limit;

    let uri_str = format!("{}/api/{version}/account/profile/assets", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_return_nulls {
        req_builder = req_builder.query(&[("returnNulls", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_owner_id {
        req_builder = req_builder.query(&[("ownerId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_media_types {
        req_builder = req_builder.query(&[("mediaTypes", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mime_types {
        req_builder = req_builder.query(&[("mimeTypes", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_field {
        req_builder = req_builder.query(&[("sortField", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_descending {
        req_builder = req_builder.query(&[("descending", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_latitude {
        req_builder = req_builder.query(&[("latitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_longitude {
        req_builder = req_builder.query(&[("longitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query__i {
        req_builder = req_builder.query(&[("_i", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start {
        req_builder = req_builder.query(&[("start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query__l {
        req_builder = req_builder.query(&[("_l", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AssetListResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AssetListResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetProfileAssetsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets a user's account profile and their referral List.
pub async fn get_referral_list(configuration: &configuration::Configuration, version: f64, account_id: Option<i64>, app_key: Option<&str>, retrieve_type: Option<&str>, level_limit: Option<f64>, ancestor_level_limit: Option<f64>, children_level_limit: Option<f64>, ancestor_list_start: Option<f64>, ancestor_list_limit: Option<f64>, children_list_start: Option<f64>, children_list_limit: Option<f64>, children_children: Option<bool>) -> Result<(), Error<GetReferralListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_account_id = account_id;
    let p_query_app_key = app_key;
    let p_query_retrieve_type = retrieve_type;
    let p_query_level_limit = level_limit;
    let p_query_ancestor_level_limit = ancestor_level_limit;
    let p_query_children_level_limit = children_level_limit;
    let p_query_ancestor_list_start = ancestor_list_start;
    let p_query_ancestor_list_limit = ancestor_list_limit;
    let p_query_children_list_start = children_list_start;
    let p_query_children_list_limit = children_list_limit;
    let p_query_children_children = children_children;

    let uri_str = format!("{}/api/{version}/account/referral/list", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_key {
        req_builder = req_builder.query(&[("appKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_retrieve_type {
        req_builder = req_builder.query(&[("retrieveType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_level_limit {
        req_builder = req_builder.query(&[("levelLimit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ancestor_level_limit {
        req_builder = req_builder.query(&[("ancestorLevelLimit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_children_level_limit {
        req_builder = req_builder.query(&[("childrenLevelLimit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ancestor_list_start {
        req_builder = req_builder.query(&[("ancestorListStart", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ancestor_list_limit {
        req_builder = req_builder.query(&[("ancestorListLimit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_children_list_start {
        req_builder = req_builder.query(&[("childrenListStart", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_children_list_limit {
        req_builder = req_builder.query(&[("childrenListLimit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_children_children {
        req_builder = req_builder.query(&[("childrenChildren", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<GetReferralListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the account settings for a user
pub async fn get_settings(configuration: &configuration::Configuration, version: f64, device_id: Option<&str>, account_id: Option<i64>, latitude: Option<f64>, longitude: Option<f64>) -> Result<models::UserSettingsResponse, Error<GetSettingsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_latitude = latitude;
    let p_query_longitude = longitude;

    let uri_str = format!("{}/api/{version}/account/settings/get", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_latitude {
        req_builder = req_builder.query(&[("latitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_longitude {
        req_builder = req_builder.query(&[("longitude", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserSettingsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserSettingsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSettingsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// A login service that supports logging in as someone else (accounts that the user manages). Intended for internal use for now.
pub async fn login_delegate(configuration: &configuration::Configuration, version: f64, access_token: &str, app_key: &str, device_id: Option<&str>, access_token_secret: Option<&str>, delegated_account_id: Option<i64>, delegated_username: Option<&str>, network_uid: Option<&str>, age_restriction: Option<i32>, response_filters: Option<&str>, latitude: Option<f64>, longitude: Option<f64>) -> Result<models::ProfileResponse, Error<LoginDelegateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_access_token = access_token;
    let p_query_app_key = app_key;
    let p_query_device_id = device_id;
    let p_query_access_token_secret = access_token_secret;
    let p_query_delegated_account_id = delegated_account_id;
    let p_query_delegated_username = delegated_username;
    let p_query_network_uid = network_uid;
    let p_query_age_restriction = age_restriction;
    let p_query_response_filters = response_filters;
    let p_query_latitude = latitude;
    let p_query_longitude = longitude;

    let uri_str = format!("{}/api/{version}/account/login/delegate", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("accessToken", &p_query_access_token.to_string())]);
    if let Some(ref param_value) = p_query_access_token_secret {
        req_builder = req_builder.query(&[("accessTokenSecret", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_delegated_account_id {
        req_builder = req_builder.query(&[("delegatedAccountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_delegated_username {
        req_builder = req_builder.query(&[("delegatedUsername", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_network_uid {
        req_builder = req_builder.query(&[("networkUID", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("appKey", &p_query_app_key.to_string())]);
    if let Some(ref param_value) = p_query_age_restriction {
        req_builder = req_builder.query(&[("ageRestriction", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_response_filters {
        req_builder = req_builder.query(&[("responseFilters", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_latitude {
        req_builder = req_builder.query(&[("latitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_longitude {
        req_builder = req_builder.query(&[("longitude", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProfileResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProfileResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<LoginDelegateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// General login service that supports various authentication methods. Currently supports Facebook, Twitter, Sirqul Username, and Sirqul Phone by default. Can also support custom networks created using the {@link ThirdPartyApi}
pub async fn login_general(configuration: &configuration::Configuration, version: f64, access_token: &str, network_uid: &str, app_key: &str, device_id: Option<&str>, device_id_type: Option<&str>, access_token_secret: Option<&str>, age_restriction: Option<i32>, response_filters: Option<&str>, latitude: Option<f64>, longitude: Option<f64>, email_match: Option<bool>, chosen_account_id: Option<i64>, third_party_credential_id: Option<i64>) -> Result<models::ProfileResponse, Error<LoginGeneralError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_access_token = access_token;
    let p_query_network_uid = network_uid;
    let p_query_app_key = app_key;
    let p_query_device_id = device_id;
    let p_query_device_id_type = device_id_type;
    let p_query_access_token_secret = access_token_secret;
    let p_query_age_restriction = age_restriction;
    let p_query_response_filters = response_filters;
    let p_query_latitude = latitude;
    let p_query_longitude = longitude;
    let p_query_email_match = email_match;
    let p_query_chosen_account_id = chosen_account_id;
    let p_query_third_party_credential_id = third_party_credential_id;

    let uri_str = format!("{}/api/{version}/account/login", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_device_id_type {
        req_builder = req_builder.query(&[("deviceIdType", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("accessToken", &p_query_access_token.to_string())]);
    if let Some(ref param_value) = p_query_access_token_secret {
        req_builder = req_builder.query(&[("accessTokenSecret", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("networkUID", &p_query_network_uid.to_string())]);
    req_builder = req_builder.query(&[("appKey", &p_query_app_key.to_string())]);
    if let Some(ref param_value) = p_query_age_restriction {
        req_builder = req_builder.query(&[("ageRestriction", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_response_filters {
        req_builder = req_builder.query(&[("responseFilters", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_latitude {
        req_builder = req_builder.query(&[("latitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_longitude {
        req_builder = req_builder.query(&[("longitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_email_match {
        req_builder = req_builder.query(&[("emailMatch", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_chosen_account_id {
        req_builder = req_builder.query(&[("chosenAccountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_third_party_credential_id {
        req_builder = req_builder.query(&[("thirdPartyCredentialId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProfileResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProfileResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<LoginGeneralError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Login to system with an account
pub async fn login_username(configuration: &configuration::Configuration, version: f64, username: &str, password: &str, device_id: Option<&str>, latitude: Option<f64>, longitude: Option<f64>, app: Option<&str>, game_type: Option<&str>, app_key: Option<&str>, return_profile: Option<bool>, response_filters: Option<&str>) -> Result<models::ProfileResponse, Error<LoginUsernameError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_username = username;
    let p_query_password = password;
    let p_query_device_id = device_id;
    let p_query_latitude = latitude;
    let p_query_longitude = longitude;
    let p_query_app = app;
    let p_query_game_type = game_type;
    let p_query_app_key = app_key;
    let p_query_return_profile = return_profile;
    let p_query_response_filters = response_filters;

    let uri_str = format!("{}/api/{version}/account/get", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("username", &p_query_username.to_string())]);
    req_builder = req_builder.query(&[("password", &p_query_password.to_string())]);
    if let Some(ref param_value) = p_query_latitude {
        req_builder = req_builder.query(&[("latitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_longitude {
        req_builder = req_builder.query(&[("longitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app {
        req_builder = req_builder.query(&[("app", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_game_type {
        req_builder = req_builder.query(&[("gameType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_key {
        req_builder = req_builder.query(&[("appKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_return_profile {
        req_builder = req_builder.query(&[("returnProfile", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_response_filters {
        req_builder = req_builder.query(&[("responseFilters", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProfileResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProfileResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<LoginUsernameError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Cleans up the users data for logging out.
pub async fn logout(configuration: &configuration::Configuration, version: f64, device_id: Option<&str>, device_id_type: Option<&str>, account_id: Option<i64>, latitude: Option<f64>, longitude: Option<f64>) -> Result<models::SirqulResponse, Error<LogoutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_device_id = device_id;
    let p_query_device_id_type = device_id_type;
    let p_query_account_id = account_id;
    let p_query_latitude = latitude;
    let p_query_longitude = longitude;

    let uri_str = format!("{}/api/{version}/account/logout", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_device_id_type {
        req_builder = req_builder.query(&[("deviceIdType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_latitude {
        req_builder = req_builder.query(&[("latitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_longitude {
        req_builder = req_builder.query(&[("longitude", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SirqulResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SirqulResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<LogoutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Merges the analytics, achievements, leaderboards of two accounts.
pub async fn merge_account(configuration: &configuration::Configuration, version: f64, merge_account_id: i64, app_key: &str, device_id: Option<&str>, account_id: Option<i64>) -> Result<models::SirqulResponse, Error<MergeAccountError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_merge_account_id = merge_account_id;
    let p_query_app_key = app_key;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;

    let uri_str = format!("{}/api/{version}/account/merge", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("mergeAccountId", &p_query_merge_account_id.to_string())]);
    req_builder = req_builder.query(&[("appKey", &p_query_app_key.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SirqulResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SirqulResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MergeAccountError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update the account password.
pub async fn password_change(configuration: &configuration::Configuration, version: f64, account_id: i64, old_password: &str, new_password: &str, confirm_password: &str) -> Result<models::SirqulResponse, Error<PasswordChangeError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_account_id = account_id;
    let p_query_old_password = old_password;
    let p_query_new_password = new_password;
    let p_query_confirm_password = confirm_password;

    let uri_str = format!("{}/api/{version}/account/passwordchange", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("oldPassword", &p_query_old_password.to_string())]);
    req_builder = req_builder.query(&[("newPassword", &p_query_new_password.to_string())]);
    req_builder = req_builder.query(&[("confirmPassword", &p_query_confirm_password.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SirqulResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SirqulResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PasswordChangeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Reset the account password. The token must be valid and not expired. Use the RequestPasswordReset end point to request a token.
pub async fn password_reset(configuration: &configuration::Configuration, version: f64, token: &str, password: &str, confirm: &str) -> Result<models::SirqulResponse, Error<PasswordResetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_token = token;
    let p_query_password = password;
    let p_query_confirm = confirm;

    let uri_str = format!("{}/api/{version}/account/passwordreset", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("token", &p_query_token.to_string())]);
    req_builder = req_builder.query(&[("password", &p_query_password.to_string())]);
    req_builder = req_builder.query(&[("confirm", &p_query_confirm.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SirqulResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SirqulResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PasswordResetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Request that an account password be reset. The account is looked up by email address and then a link is sent via email to that account with a reset token. The token is valid for 24 hours.
pub async fn request_password_reset(configuration: &configuration::Configuration, version: f64, email: &str, from: Option<&str>, domain: Option<&str>, sub_url: Option<&str>, referer: Option<&str>) -> Result<models::SirqulResponse, Error<RequestPasswordResetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_email = email;
    let p_query_from = from;
    let p_query_domain = domain;
    let p_query_sub_url = sub_url;
    let p_query_referer = referer;

    let uri_str = format!("{}/api/{version}/account/requestpasswordreset", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("email", &p_query_email.to_string())]);
    if let Some(ref param_value) = p_query_from {
        req_builder = req_builder.query(&[("from", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_domain {
        req_builder = req_builder.query(&[("domain", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sub_url {
        req_builder = req_builder.query(&[("subUrl", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_referer {
        req_builder = req_builder.query(&[("referer", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SirqulResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SirqulResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RequestPasswordResetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Send an email to validate a user's account.
pub async fn request_validate_account(configuration: &configuration::Configuration, version: f64, account_id: i64) -> Result<models::SirqulResponse, Error<RequestValidateAccountError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_account_id = account_id;

    let uri_str = format!("{}/api/{version}/account/requestValidateAccount", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SirqulResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SirqulResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RequestValidateAccountError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Search for account profiles.
pub async fn search_accounts(configuration: &configuration::Configuration, version: f64, account_id: i64, app_key: &str, keyword: Option<&str>, latitude: Option<f64>, longitude: Option<f64>, radius: Option<f64>, gender: Option<&str>, game_experience: Option<&str>, age: Option<i32>, category_ids: Option<&str>, return_nulls: Option<bool>, response_filters: Option<&str>, purchase_type: Option<&str>, sort_field: Option<&str>, descending: Option<bool>, start: Option<i32>, limit: Option<i32>, active_only: Option<bool>) -> Result<Vec<models::ProfileResponse>, Error<SearchAccountsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_account_id = account_id;
    let p_query_app_key = app_key;
    let p_query_keyword = keyword;
    let p_query_latitude = latitude;
    let p_query_longitude = longitude;
    let p_query_radius = radius;
    let p_query_gender = gender;
    let p_query_game_experience = game_experience;
    let p_query_age = age;
    let p_query_category_ids = category_ids;
    let p_query_return_nulls = return_nulls;
    let p_query_response_filters = response_filters;
    let p_query_purchase_type = purchase_type;
    let p_query_sort_field = sort_field;
    let p_query_descending = descending;
    let p_query_start = start;
    let p_query_limit = limit;
    let p_query_active_only = active_only;

    let uri_str = format!("{}/api/{version}/account/profile/search", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("appKey", &p_query_app_key.to_string())]);
    if let Some(ref param_value) = p_query_keyword {
        req_builder = req_builder.query(&[("keyword", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_latitude {
        req_builder = req_builder.query(&[("latitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_longitude {
        req_builder = req_builder.query(&[("longitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_radius {
        req_builder = req_builder.query(&[("radius", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_gender {
        req_builder = req_builder.query(&[("gender", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_game_experience {
        req_builder = req_builder.query(&[("gameExperience", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_age {
        req_builder = req_builder.query(&[("age", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_category_ids {
        req_builder = req_builder.query(&[("categoryIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_return_nulls {
        req_builder = req_builder.query(&[("returnNulls", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_response_filters {
        req_builder = req_builder.query(&[("responseFilters", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_purchase_type {
        req_builder = req_builder.query(&[("purchaseType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort_field {
        req_builder = req_builder.query(&[("sortField", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_descending {
        req_builder = req_builder.query(&[("descending", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start {
        req_builder = req_builder.query(&[("start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_active_only {
        req_builder = req_builder.query(&[("activeOnly", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::ProfileResponse&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::ProfileResponse&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchAccountsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// ogin with encrypted user-name and password.
pub async fn secure_login(configuration: &configuration::Configuration, version: f64, username: &str, password: &str, game_type: &str, device_id: Option<&str>, charset_name: Option<&str>, latitude: Option<f64>, longitude: Option<f64>, return_profile: Option<bool>, response_filters: Option<&str>) -> Result<models::ProfileResponse, Error<SecureLoginError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_username = username;
    let p_query_password = password;
    let p_query_game_type = game_type;
    let p_query_device_id = device_id;
    let p_query_charset_name = charset_name;
    let p_query_latitude = latitude;
    let p_query_longitude = longitude;
    let p_query_return_profile = return_profile;
    let p_query_response_filters = response_filters;

    let uri_str = format!("{}/api/{version}/account/login/validate", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("username", &p_query_username.to_string())]);
    req_builder = req_builder.query(&[("password", &p_query_password.to_string())]);
    req_builder = req_builder.query(&[("gameType", &p_query_game_type.to_string())]);
    if let Some(ref param_value) = p_query_charset_name {
        req_builder = req_builder.query(&[("charsetName", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_latitude {
        req_builder = req_builder.query(&[("latitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_longitude {
        req_builder = req_builder.query(&[("longitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_return_profile {
        req_builder = req_builder.query(&[("returnProfile", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_response_filters {
        req_builder = req_builder.query(&[("responseFilters", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProfileResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProfileResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecureLoginError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create a new account by role (with encrypted user-name and password)
pub async fn secure_signup(configuration: &configuration::Configuration, version: f64, device_id: &str, username: &str, password: &str, name: Option<&str>, invite_token: Option<&str>, prefix_name: Option<&str>, first_name: Option<&str>, middle_name: Option<&str>, last_name: Option<&str>, suffix_name: Option<&str>, title: Option<&str>, device_id_type: Option<&str>, email_address: Option<&str>, asset_id: Option<i64>, address: Option<&str>, zipcode: Option<&str>, gender: Option<&str>, birthday: Option<i64>, home_phone: Option<&str>, cell_phone: Option<&str>, cell_phone_carrier: Option<&str>, business_phone: Option<&str>, role: Option<&str>, platforms: Option<&str>, tags: Option<&str>, about_us: Option<&str>, game_experience: Option<&str>, category_ids: Option<&str>, hometown: Option<&str>, height: Option<&str>, height_index: Option<i32>, ethnicity: Option<&str>, body_type: Option<&str>, marital_status: Option<&str>, children: Option<&str>, religion: Option<&str>, education: Option<&str>, education_index: Option<i32>, smoke: Option<&str>, drink: Option<&str>, companionship: Option<&str>, companionship_index: Option<i32>, preferred_min_age: Option<i32>, preferred_max_age: Option<i32>, preferred_min_height: Option<i32>, preferred_max_height: Option<i32>, preferred_gender: Option<&str>, preferred_education: Option<&str>, preferred_education_index: Option<i32>, preferred_body_type: Option<&str>, preferred_ethnicity: Option<&str>, preferred_location: Option<&str>, preferred_location_range: Option<f64>, latitude: Option<f64>, longitude: Option<f64>, accepted_terms: Option<bool>, charset_name: Option<&str>, game_type: Option<&str>, app_key: Option<&str>, app_version: Option<&str>, response_type: Option<&str>) -> Result<models::ProfileInfoResponse, Error<SecureSignupError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_device_id = device_id;
    let p_query_username = username;
    let p_query_password = password;
    let p_query_name = name;
    let p_query_invite_token = invite_token;
    let p_query_prefix_name = prefix_name;
    let p_query_first_name = first_name;
    let p_query_middle_name = middle_name;
    let p_query_last_name = last_name;
    let p_query_suffix_name = suffix_name;
    let p_query_title = title;
    let p_query_device_id_type = device_id_type;
    let p_query_email_address = email_address;
    let p_query_asset_id = asset_id;
    let p_query_address = address;
    let p_query_zipcode = zipcode;
    let p_query_gender = gender;
    let p_query_birthday = birthday;
    let p_query_home_phone = home_phone;
    let p_query_cell_phone = cell_phone;
    let p_query_cell_phone_carrier = cell_phone_carrier;
    let p_query_business_phone = business_phone;
    let p_query_role = role;
    let p_query_platforms = platforms;
    let p_query_tags = tags;
    let p_query_about_us = about_us;
    let p_query_game_experience = game_experience;
    let p_query_category_ids = category_ids;
    let p_query_hometown = hometown;
    let p_query_height = height;
    let p_query_height_index = height_index;
    let p_query_ethnicity = ethnicity;
    let p_query_body_type = body_type;
    let p_query_marital_status = marital_status;
    let p_query_children = children;
    let p_query_religion = religion;
    let p_query_education = education;
    let p_query_education_index = education_index;
    let p_query_smoke = smoke;
    let p_query_drink = drink;
    let p_query_companionship = companionship;
    let p_query_companionship_index = companionship_index;
    let p_query_preferred_min_age = preferred_min_age;
    let p_query_preferred_max_age = preferred_max_age;
    let p_query_preferred_min_height = preferred_min_height;
    let p_query_preferred_max_height = preferred_max_height;
    let p_query_preferred_gender = preferred_gender;
    let p_query_preferred_education = preferred_education;
    let p_query_preferred_education_index = preferred_education_index;
    let p_query_preferred_body_type = preferred_body_type;
    let p_query_preferred_ethnicity = preferred_ethnicity;
    let p_query_preferred_location = preferred_location;
    let p_query_preferred_location_range = preferred_location_range;
    let p_query_latitude = latitude;
    let p_query_longitude = longitude;
    let p_query_accepted_terms = accepted_terms;
    let p_query_charset_name = charset_name;
    let p_query_game_type = game_type;
    let p_query_app_key = app_key;
    let p_query_app_version = app_version;
    let p_query_response_type = response_type;

    let uri_str = format!("{}/api/{version}/account/create/validate", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_invite_token {
        req_builder = req_builder.query(&[("inviteToken", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_prefix_name {
        req_builder = req_builder.query(&[("prefixName", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_first_name {
        req_builder = req_builder.query(&[("firstName", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_middle_name {
        req_builder = req_builder.query(&[("middleName", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_last_name {
        req_builder = req_builder.query(&[("lastName", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_suffix_name {
        req_builder = req_builder.query(&[("suffixName", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_title {
        req_builder = req_builder.query(&[("title", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("deviceId", &p_query_device_id.to_string())]);
    if let Some(ref param_value) = p_query_device_id_type {
        req_builder = req_builder.query(&[("deviceIdType", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("username", &p_query_username.to_string())]);
    req_builder = req_builder.query(&[("password", &p_query_password.to_string())]);
    if let Some(ref param_value) = p_query_email_address {
        req_builder = req_builder.query(&[("emailAddress", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_asset_id {
        req_builder = req_builder.query(&[("assetId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_address {
        req_builder = req_builder.query(&[("address", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_zipcode {
        req_builder = req_builder.query(&[("zipcode", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_gender {
        req_builder = req_builder.query(&[("gender", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_birthday {
        req_builder = req_builder.query(&[("birthday", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_home_phone {
        req_builder = req_builder.query(&[("homePhone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cell_phone {
        req_builder = req_builder.query(&[("cellPhone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cell_phone_carrier {
        req_builder = req_builder.query(&[("cellPhoneCarrier", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_business_phone {
        req_builder = req_builder.query(&[("businessPhone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_role {
        req_builder = req_builder.query(&[("role", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_platforms {
        req_builder = req_builder.query(&[("platforms", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_tags {
        req_builder = req_builder.query(&[("tags", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_about_us {
        req_builder = req_builder.query(&[("aboutUs", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_game_experience {
        req_builder = req_builder.query(&[("gameExperience", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_category_ids {
        req_builder = req_builder.query(&[("categoryIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_hometown {
        req_builder = req_builder.query(&[("hometown", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_height {
        req_builder = req_builder.query(&[("height", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_height_index {
        req_builder = req_builder.query(&[("heightIndex", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ethnicity {
        req_builder = req_builder.query(&[("ethnicity", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_body_type {
        req_builder = req_builder.query(&[("bodyType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_marital_status {
        req_builder = req_builder.query(&[("maritalStatus", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_children {
        req_builder = req_builder.query(&[("children", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_religion {
        req_builder = req_builder.query(&[("religion", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_education {
        req_builder = req_builder.query(&[("education", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_education_index {
        req_builder = req_builder.query(&[("educationIndex", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_smoke {
        req_builder = req_builder.query(&[("smoke", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_drink {
        req_builder = req_builder.query(&[("drink", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_companionship {
        req_builder = req_builder.query(&[("companionship", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_companionship_index {
        req_builder = req_builder.query(&[("companionshipIndex", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_preferred_min_age {
        req_builder = req_builder.query(&[("preferredMinAge", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_preferred_max_age {
        req_builder = req_builder.query(&[("preferredMaxAge", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_preferred_min_height {
        req_builder = req_builder.query(&[("preferredMinHeight", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_preferred_max_height {
        req_builder = req_builder.query(&[("preferredMaxHeight", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_preferred_gender {
        req_builder = req_builder.query(&[("preferredGender", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_preferred_education {
        req_builder = req_builder.query(&[("preferredEducation", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_preferred_education_index {
        req_builder = req_builder.query(&[("preferredEducationIndex", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_preferred_body_type {
        req_builder = req_builder.query(&[("preferredBodyType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_preferred_ethnicity {
        req_builder = req_builder.query(&[("preferredEthnicity", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_preferred_location {
        req_builder = req_builder.query(&[("preferredLocation", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_preferred_location_range {
        req_builder = req_builder.query(&[("preferredLocationRange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_latitude {
        req_builder = req_builder.query(&[("latitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_longitude {
        req_builder = req_builder.query(&[("longitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_accepted_terms {
        req_builder = req_builder.query(&[("acceptedTerms", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_charset_name {
        req_builder = req_builder.query(&[("charsetName", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_game_type {
        req_builder = req_builder.query(&[("gameType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_key {
        req_builder = req_builder.query(&[("appKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_version {
        req_builder = req_builder.query(&[("appVersion", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_response_type {
        req_builder = req_builder.query(&[("responseType", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProfileInfoResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProfileInfoResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecureSignupError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Save user's match token to be used for profile match making
pub async fn set_match_token(configuration: &configuration::Configuration, version: f64, device_id: Option<&str>, account_id: Option<i64>, match_token: Option<&str>, game_type: Option<&str>, app_key: Option<&str>, latitude: Option<f64>, longitude: Option<f64>) -> Result<models::SirqulResponse, Error<SetMatchTokenError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_match_token = match_token;
    let p_query_game_type = game_type;
    let p_query_app_key = app_key;
    let p_query_latitude = latitude;
    let p_query_longitude = longitude;

    let uri_str = format!("{}/api/{version}/consumer/profile/matchToken", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_match_token {
        req_builder = req_builder.query(&[("matchToken", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_game_type {
        req_builder = req_builder.query(&[("gameType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app_key {
        req_builder = req_builder.query(&[("appKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_latitude {
        req_builder = req_builder.query(&[("latitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_longitude {
        req_builder = req_builder.query(&[("longitude", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SirqulResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SirqulResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SetMatchTokenError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Activate or deactivate an account (requires appropriate permissions).
pub async fn update_actve_status(configuration: &configuration::Configuration, version: f64, account_id: i64, connection_account_id: i64, active: bool, device_id: Option<&str>, app_key: Option<&str>) -> Result<models::SirqulResponse, Error<UpdateActveStatusError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_account_id = account_id;
    let p_query_connection_account_id = connection_account_id;
    let p_query_active = active;
    let p_query_device_id = device_id;
    let p_query_app_key = app_key;

    let uri_str = format!("{}/api/{version}/account/active/update", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("accountId", &p_query_account_id.to_string())]);
    req_builder = req_builder.query(&[("connectionAccountId", &p_query_connection_account_id.to_string())]);
    if let Some(ref param_value) = p_query_app_key {
        req_builder = req_builder.query(&[("appKey", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("active", &p_query_active.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SirqulResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SirqulResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateActveStatusError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update the account location
pub async fn update_location(configuration: &configuration::Configuration, version: f64, device_id: Option<&str>, account_id: Option<i64>, latitude: Option<f64>, longitude: Option<f64>, client_time: Option<i64>) -> Result<models::SirqulResponse, Error<UpdateLocationError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_latitude = latitude;
    let p_query_longitude = longitude;
    let p_query_client_time = client_time;

    let uri_str = format!("{}/api/{version}/account/location/update", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_latitude {
        req_builder = req_builder.query(&[("latitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_longitude {
        req_builder = req_builder.query(&[("longitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_client_time {
        req_builder = req_builder.query(&[("clientTime", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SirqulResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SirqulResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateLocationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update the account settings for a user
pub async fn update_settings(configuration: &configuration::Configuration, version: f64, device_id: Option<&str>, account_id: Option<i64>, blocked_notifications: Option<&str>, suggestion_method: Option<&str>, suggestion_count: Option<i32>, suggestion_time_frame: Option<i32>, show_others_exact_location: Option<bool>, show_as_zipcode: Option<bool>, show_exact_location: Option<bool>, favorite_visibility: Option<&str>, latitude: Option<f64>, longitude: Option<f64>) -> Result<models::UserSettingsResponse, Error<UpdateSettingsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_device_id = device_id;
    let p_query_account_id = account_id;
    let p_query_blocked_notifications = blocked_notifications;
    let p_query_suggestion_method = suggestion_method;
    let p_query_suggestion_count = suggestion_count;
    let p_query_suggestion_time_frame = suggestion_time_frame;
    let p_query_show_others_exact_location = show_others_exact_location;
    let p_query_show_as_zipcode = show_as_zipcode;
    let p_query_show_exact_location = show_exact_location;
    let p_query_favorite_visibility = favorite_visibility;
    let p_query_latitude = latitude;
    let p_query_longitude = longitude;

    let uri_str = format!("{}/api/{version}/account/settings/update", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_device_id {
        req_builder = req_builder.query(&[("deviceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_account_id {
        req_builder = req_builder.query(&[("accountId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_blocked_notifications {
        req_builder = req_builder.query(&[("blockedNotifications", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_suggestion_method {
        req_builder = req_builder.query(&[("suggestionMethod", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_suggestion_count {
        req_builder = req_builder.query(&[("suggestionCount", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_suggestion_time_frame {
        req_builder = req_builder.query(&[("suggestionTimeFrame", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_show_others_exact_location {
        req_builder = req_builder.query(&[("showOthersExactLocation", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_show_as_zipcode {
        req_builder = req_builder.query(&[("showAsZipcode", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_show_exact_location {
        req_builder = req_builder.query(&[("showExactLocation", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_favorite_visibility {
        req_builder = req_builder.query(&[("favoriteVisibility", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_latitude {
        req_builder = req_builder.query(&[("latitude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_longitude {
        req_builder = req_builder.query(&[("longitude", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserSettingsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserSettingsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateSettingsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Validate the account's email address. The token must be valid and not expired. Use the RequestValidateAccount end point to request a new token.
pub async fn validate_account_signup(configuration: &configuration::Configuration, version: f64, token: &str) -> Result<models::AccountLoginResponse, Error<ValidateAccountSignupError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_token = token;

    let uri_str = format!("{}/api/{version}/account/validateAccountSignup", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("token", &p_query_token.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AccountLoginResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AccountLoginResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ValidateAccountSignupError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Validate the password reset token. The token must be valid and not expired. Use the RequestPasswordReset end point to request a token. The user receives and email with the reset page, therefore it should be validated before bwing used to reset the password.
pub async fn validate_password_reset(configuration: &configuration::Configuration, version: f64, token: &str) -> Result<models::SirqulResponse, Error<ValidatePasswordResetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_version = version;
    let p_query_token = token;

    let uri_str = format!("{}/api/{version}/account/validatepasswordreset", configuration.base_path, version=p_path_version);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("token", &p_query_token.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SirqulResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SirqulResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ValidatePasswordResetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

