/*
Sirqul IoT Platform

Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

API version: 3.16
Contact: info@sirqul.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// PreviewPersonaAPIService PreviewPersonaAPI service
type PreviewPersonaAPIService service

type ApiCreatePersonaRequest struct {
	ctx context.Context
	ApiService *PreviewPersonaAPIService
	version float32
	accountId *int64
	title *string
	previewAccounts *string
	date *int64
	age *int32
	gender *string
	gameExperienceLevel *string
	latitude *float64
	longitude *float64
}

// the account ID of the user
func (r ApiCreatePersonaRequest) AccountId(accountId int64) ApiCreatePersonaRequest {
	r.accountId = &accountId
	return r
}

// the title of the persona
func (r ApiCreatePersonaRequest) Title(title string) ApiCreatePersonaRequest {
	r.title = &title
	return r
}

// the accounts that are able to preview from this persona
func (r ApiCreatePersonaRequest) PreviewAccounts(previewAccounts string) ApiCreatePersonaRequest {
	r.previewAccounts = &previewAccounts
	return r
}

// the sepcified date that this persona is viewing the app
func (r ApiCreatePersonaRequest) Date(date int64) ApiCreatePersonaRequest {
	r.date = &date
	return r
}

// the specified age of this persona
func (r ApiCreatePersonaRequest) Age(age int32) ApiCreatePersonaRequest {
	r.age = &age
	return r
}

// the specified gender of this persona
func (r ApiCreatePersonaRequest) Gender(gender string) ApiCreatePersonaRequest {
	r.gender = &gender
	return r
}

// the specified experience level of the persona
func (r ApiCreatePersonaRequest) GameExperienceLevel(gameExperienceLevel string) ApiCreatePersonaRequest {
	r.gameExperienceLevel = &gameExperienceLevel
	return r
}

// the specified latitude of the persona
func (r ApiCreatePersonaRequest) Latitude(latitude float64) ApiCreatePersonaRequest {
	r.latitude = &latitude
	return r
}

// the specified longitude of the persona
func (r ApiCreatePersonaRequest) Longitude(longitude float64) ApiCreatePersonaRequest {
	r.longitude = &longitude
	return r
}

func (r ApiCreatePersonaRequest) Execute() (*PreviewPersonaResponse, *http.Response, error) {
	return r.ApiService.CreatePersonaExecute(r)
}

/*
CreatePersona Create Persona

Creates a new persona. If the given params are null those attributes will be override by null.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiCreatePersonaRequest
*/
func (a *PreviewPersonaAPIService) CreatePersona(ctx context.Context, version float32) ApiCreatePersonaRequest {
	return ApiCreatePersonaRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return PreviewPersonaResponse
func (a *PreviewPersonaAPIService) CreatePersonaExecute(r ApiCreatePersonaRequest) (*PreviewPersonaResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PreviewPersonaResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PreviewPersonaAPIService.CreatePersona")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/persona/create"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.title == nil {
		return localVarReturnValue, nil, reportError("title is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "title", r.title, "form", "")
	if r.previewAccounts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previewAccounts", r.previewAccounts, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.age != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "age", r.age, "form", "")
	}
	if r.gender != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gender", r.gender, "form", "")
	}
	if r.gameExperienceLevel != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gameExperienceLevel", r.gameExperienceLevel, "form", "")
	}
	if r.latitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latitude", r.latitude, "form", "")
	}
	if r.longitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "longitude", r.longitude, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeletePersonaRequest struct {
	ctx context.Context
	ApiService *PreviewPersonaAPIService
	version float32
	accountId *int64
	personaId *int64
}

// the account id of the user
func (r ApiDeletePersonaRequest) AccountId(accountId int64) ApiDeletePersonaRequest {
	r.accountId = &accountId
	return r
}

// the id of the persona to delete
func (r ApiDeletePersonaRequest) PersonaId(personaId int64) ApiDeletePersonaRequest {
	r.personaId = &personaId
	return r
}

func (r ApiDeletePersonaRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.DeletePersonaExecute(r)
}

/*
DeletePersona Delete Persona

Mark the persona for deletion.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiDeletePersonaRequest
*/
func (a *PreviewPersonaAPIService) DeletePersona(ctx context.Context, version float32) ApiDeletePersonaRequest {
	return ApiDeletePersonaRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *PreviewPersonaAPIService) DeletePersonaExecute(r ApiDeletePersonaRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PreviewPersonaAPIService.DeletePersona")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/persona/delete"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.personaId == nil {
		return localVarReturnValue, nil, reportError("personaId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "personaId", r.personaId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPersonaListRequest struct {
	ctx context.Context
	ApiService *PreviewPersonaAPIService
	version float32
	accountId *int64
	personaId *int64
}

// the account ID of the user
func (r ApiGetPersonaListRequest) AccountId(accountId int64) ApiGetPersonaListRequest {
	r.accountId = &accountId
	return r
}

// the persona ID of the persona
func (r ApiGetPersonaListRequest) PersonaId(personaId int64) ApiGetPersonaListRequest {
	r.personaId = &personaId
	return r
}

func (r ApiGetPersonaListRequest) Execute() (*PreviewPersonaResponse, *http.Response, error) {
	return r.ApiService.GetPersonaListExecute(r)
}

/*
GetPersonaList Get Persona

Get the persona by the given persona ID. If the persona cannot be found, a invalid response is returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiGetPersonaListRequest
*/
func (a *PreviewPersonaAPIService) GetPersonaList(ctx context.Context, version float32) ApiGetPersonaListRequest {
	return ApiGetPersonaListRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return PreviewPersonaResponse
func (a *PreviewPersonaAPIService) GetPersonaListExecute(r ApiGetPersonaListRequest) (*PreviewPersonaResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PreviewPersonaResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PreviewPersonaAPIService.GetPersonaList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/persona/get"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.personaId == nil {
		return localVarReturnValue, nil, reportError("personaId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "personaId", r.personaId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchPersonaRequest struct {
	ctx context.Context
	ApiService *PreviewPersonaAPIService
	version float32
	accountId *int64
	start *int32
	limit *int32
}

// the account ID of the user
func (r ApiSearchPersonaRequest) AccountId(accountId int64) ApiSearchPersonaRequest {
	r.accountId = &accountId
	return r
}

// the start index for pagination
func (r ApiSearchPersonaRequest) Start(start int32) ApiSearchPersonaRequest {
	r.start = &start
	return r
}

// the limit for pagination (There is a hard limit of 100)
func (r ApiSearchPersonaRequest) Limit(limit int32) ApiSearchPersonaRequest {
	r.limit = &limit
	return r
}

func (r ApiSearchPersonaRequest) Execute() (*PreviewPersonaResponse, *http.Response, error) {
	return r.ApiService.SearchPersonaExecute(r)
}

/*
SearchPersona Search Personas

Search for persona that the account owns by the given account ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiSearchPersonaRequest
*/
func (a *PreviewPersonaAPIService) SearchPersona(ctx context.Context, version float32) ApiSearchPersonaRequest {
	return ApiSearchPersonaRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return PreviewPersonaResponse
func (a *PreviewPersonaAPIService) SearchPersonaExecute(r ApiSearchPersonaRequest) (*PreviewPersonaResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PreviewPersonaResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PreviewPersonaAPIService.SearchPersona")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/persona/search"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.start == nil {
		return localVarReturnValue, nil, reportError("start is required and must be specified")
	}
	if r.limit == nil {
		return localVarReturnValue, nil, reportError("limit is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdatePersonaRequest struct {
	ctx context.Context
	ApiService *PreviewPersonaAPIService
	version float32
	accountId *int64
	personaId *int64
	title *string
	previewAccounts *string
	active *bool
	date *int64
	age *int32
	gender *string
	gameExperienceLevel *string
	latitude *float64
	longitude *float64
}

// the account ID of the user
func (r ApiUpdatePersonaRequest) AccountId(accountId int64) ApiUpdatePersonaRequest {
	r.accountId = &accountId
	return r
}

// the persona ID of the persona to update
func (r ApiUpdatePersonaRequest) PersonaId(personaId int64) ApiUpdatePersonaRequest {
	r.personaId = &personaId
	return r
}

// the title of the persona
func (r ApiUpdatePersonaRequest) Title(title string) ApiUpdatePersonaRequest {
	r.title = &title
	return r
}

// the accounts that are able to preview from this persona
func (r ApiUpdatePersonaRequest) PreviewAccounts(previewAccounts string) ApiUpdatePersonaRequest {
	r.previewAccounts = &previewAccounts
	return r
}

// the status of the persona, there can only be one active persona per account
func (r ApiUpdatePersonaRequest) Active(active bool) ApiUpdatePersonaRequest {
	r.active = &active
	return r
}

// the sepcified date that this persona is viewing the app
func (r ApiUpdatePersonaRequest) Date(date int64) ApiUpdatePersonaRequest {
	r.date = &date
	return r
}

// the specified age of this persona
func (r ApiUpdatePersonaRequest) Age(age int32) ApiUpdatePersonaRequest {
	r.age = &age
	return r
}

// the specified gender of this persona
func (r ApiUpdatePersonaRequest) Gender(gender string) ApiUpdatePersonaRequest {
	r.gender = &gender
	return r
}

// the specified experience level of the persona
func (r ApiUpdatePersonaRequest) GameExperienceLevel(gameExperienceLevel string) ApiUpdatePersonaRequest {
	r.gameExperienceLevel = &gameExperienceLevel
	return r
}

// the specified latitude of the persona
func (r ApiUpdatePersonaRequest) Latitude(latitude float64) ApiUpdatePersonaRequest {
	r.latitude = &latitude
	return r
}

// the specified longitude of the persona
func (r ApiUpdatePersonaRequest) Longitude(longitude float64) ApiUpdatePersonaRequest {
	r.longitude = &longitude
	return r
}

func (r ApiUpdatePersonaRequest) Execute() (*PreviewPersonaResponse, *http.Response, error) {
	return r.ApiService.UpdatePersonaExecute(r)
}

/*
UpdatePersona Update Persona

Update the persona by the given personaId. If the given params are null those attributes will be override by null. If active is assigned, all other params will be ignored.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiUpdatePersonaRequest
*/
func (a *PreviewPersonaAPIService) UpdatePersona(ctx context.Context, version float32) ApiUpdatePersonaRequest {
	return ApiUpdatePersonaRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return PreviewPersonaResponse
func (a *PreviewPersonaAPIService) UpdatePersonaExecute(r ApiUpdatePersonaRequest) (*PreviewPersonaResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PreviewPersonaResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PreviewPersonaAPIService.UpdatePersona")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/persona/update"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.personaId == nil {
		return localVarReturnValue, nil, reportError("personaId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "personaId", r.personaId, "form", "")
	if r.title != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "title", r.title, "form", "")
	}
	if r.previewAccounts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previewAccounts", r.previewAccounts, "form", "")
	}
	if r.active != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active", r.active, "form", "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.age != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "age", r.age, "form", "")
	}
	if r.gender != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gender", r.gender, "form", "")
	}
	if r.gameExperienceLevel != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gameExperienceLevel", r.gameExperienceLevel, "form", "")
	}
	if r.latitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latitude", r.latitude, "form", "")
	}
	if r.longitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "longitude", r.longitude, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
