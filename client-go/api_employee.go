/*
Sirqul IoT Platform

Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

API version: 3.16
Contact: info@sirqul.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// EmployeeAPIService EmployeeAPI service
type EmployeeAPIService service

type ApiAssignEmployeeRequest struct {
	ctx context.Context
	ApiService *EmployeeAPIService
	version float32
	accountId *int64
	managerAccountId *int64
	employeeAccountId *int64
	role *string
}

// The account id of the logged in user
func (r ApiAssignEmployeeRequest) AccountId(accountId int64) ApiAssignEmployeeRequest {
	r.accountId = &accountId
	return r
}

// The account id of the manager to assign under
func (r ApiAssignEmployeeRequest) ManagerAccountId(managerAccountId int64) ApiAssignEmployeeRequest {
	r.managerAccountId = &managerAccountId
	return r
}

// The account id of the user to be assigned as employee
func (r ApiAssignEmployeeRequest) EmployeeAccountId(employeeAccountId int64) ApiAssignEmployeeRequest {
	r.employeeAccountId = &employeeAccountId
	return r
}

// The role to assign to the employee (e.g. RETAILER or RETAILER_LIMITED)
func (r ApiAssignEmployeeRequest) Role(role string) ApiAssignEmployeeRequest {
	r.role = &role
	return r
}

func (r ApiAssignEmployeeRequest) Execute() (*EmployeeResponse, *http.Response, error) {
	return r.ApiService.AssignEmployeeExecute(r)
}

/*
AssignEmployee Assign Employee

Assign An existing account to be an employee

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiAssignEmployeeRequest
*/
func (a *EmployeeAPIService) AssignEmployee(ctx context.Context, version float32) ApiAssignEmployeeRequest {
	return ApiAssignEmployeeRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return EmployeeResponse
func (a *EmployeeAPIService) AssignEmployeeExecute(r ApiAssignEmployeeRequest) (*EmployeeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmployeeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EmployeeAPIService.AssignEmployee")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/employee/assign"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.managerAccountId == nil {
		return localVarReturnValue, nil, reportError("managerAccountId is required and must be specified")
	}
	if r.employeeAccountId == nil {
		return localVarReturnValue, nil, reportError("employeeAccountId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "managerAccountId", r.managerAccountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "employeeAccountId", r.employeeAccountId, "form", "")
	if r.role != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "role", r.role, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAssignToLocationEmployeeRequest struct {
	ctx context.Context
	ApiService *EmployeeAPIService
	version float32
	accountId *int64
	retailerLocationId *int64
	employeeAccountId *int64
	assign *bool
}

// The account id of the logged in user
func (r ApiAssignToLocationEmployeeRequest) AccountId(accountId int64) ApiAssignToLocationEmployeeRequest {
	r.accountId = &accountId
	return r
}

// The retailer location to apply the change to
func (r ApiAssignToLocationEmployeeRequest) RetailerLocationId(retailerLocationId int64) ApiAssignToLocationEmployeeRequest {
	r.retailerLocationId = &retailerLocationId
	return r
}

// The account id of the user to apply the change to
func (r ApiAssignToLocationEmployeeRequest) EmployeeAccountId(employeeAccountId int64) ApiAssignToLocationEmployeeRequest {
	r.employeeAccountId = &employeeAccountId
	return r
}

// If true (default) assign to the location, otherwise remove from the retailer
func (r ApiAssignToLocationEmployeeRequest) Assign(assign bool) ApiAssignToLocationEmployeeRequest {
	r.assign = &assign
	return r
}

func (r ApiAssignToLocationEmployeeRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.AssignToLocationEmployeeExecute(r)
}

/*
AssignToLocationEmployee Assign Employee to Location

Assign or unassign the account to a retailer location.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiAssignToLocationEmployeeRequest
*/
func (a *EmployeeAPIService) AssignToLocationEmployee(ctx context.Context, version float32) ApiAssignToLocationEmployeeRequest {
	return ApiAssignToLocationEmployeeRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *EmployeeAPIService) AssignToLocationEmployeeExecute(r ApiAssignToLocationEmployeeRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EmployeeAPIService.AssignToLocationEmployee")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/employee/assignToLocation"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.retailerLocationId == nil {
		return localVarReturnValue, nil, reportError("retailerLocationId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	if r.employeeAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "employeeAccountId", r.employeeAccountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "retailerLocationId", r.retailerLocationId, "form", "")
	if r.assign != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assign", r.assign, "form", "")
	} else {
		var defaultValue bool = true
		parameterAddToHeaderOrQuery(localVarQueryParams, "assign", defaultValue, "form", "")
		r.assign = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateEmployeeRequest struct {
	ctx context.Context
	ApiService *EmployeeAPIService
	version float32
	accountId *int64
	managerAccountId *int64
	username *string
	password *string
	name *string
	prefixName *string
	firstName *string
	middleName *string
	lastName *string
	suffixName *string
	title *string
	aboutUs *string
	assetId *int64
	gender *string
	homePhone *string
	cellPhone *string
	cellPhoneCarrier *string
	businessPhone *string
	emailAddress *string
	streetAddress *string
	streetAddress2 *string
	city *string
	state *string
	zipcode *string
	country *string
	role *string
	retailerLocationIds *string
	settingsAppKey *string
	appBlob *string
	assignedDeviceId *string
}

// The account id of the logged in user
func (r ApiCreateEmployeeRequest) AccountId(accountId int64) ApiCreateEmployeeRequest {
	r.accountId = &accountId
	return r
}

// The account id of the manager to assign under
func (r ApiCreateEmployeeRequest) ManagerAccountId(managerAccountId int64) ApiCreateEmployeeRequest {
	r.managerAccountId = &managerAccountId
	return r
}

// The username/email for the new user. This must be unique across the entire the system.
func (r ApiCreateEmployeeRequest) Username(username string) ApiCreateEmployeeRequest {
	r.username = &username
	return r
}

// The password for the new user
func (r ApiCreateEmployeeRequest) Password(password string) ApiCreateEmployeeRequest {
	r.password = &password
	return r
}

// a name field
func (r ApiCreateEmployeeRequest) Name(name string) ApiCreateEmployeeRequest {
	r.name = &name
	return r
}

// The name prefix; Mr, Mrs, etc
func (r ApiCreateEmployeeRequest) PrefixName(prefixName string) ApiCreateEmployeeRequest {
	r.prefixName = &prefixName
	return r
}

// The first name
func (r ApiCreateEmployeeRequest) FirstName(firstName string) ApiCreateEmployeeRequest {
	r.firstName = &firstName
	return r
}

// The middle name
func (r ApiCreateEmployeeRequest) MiddleName(middleName string) ApiCreateEmployeeRequest {
	r.middleName = &middleName
	return r
}

// The last name
func (r ApiCreateEmployeeRequest) LastName(lastName string) ApiCreateEmployeeRequest {
	r.lastName = &lastName
	return r
}

// The name suffix; Jr, Sr, III, etc
func (r ApiCreateEmployeeRequest) SuffixName(suffixName string) ApiCreateEmployeeRequest {
	r.suffixName = &suffixName
	return r
}

// The title of the user
func (r ApiCreateEmployeeRequest) Title(title string) ApiCreateEmployeeRequest {
	r.title = &title
	return r
}

// Additional about/biography text
func (r ApiCreateEmployeeRequest) AboutUs(aboutUs string) ApiCreateEmployeeRequest {
	r.aboutUs = &aboutUs
	return r
}

// the asset id to set the user&#39;s profile image
func (r ApiCreateEmployeeRequest) AssetId(assetId int64) ApiCreateEmployeeRequest {
	r.assetId = &assetId
	return r
}

// The gender
func (r ApiCreateEmployeeRequest) Gender(gender string) ApiCreateEmployeeRequest {
	r.gender = &gender
	return r
}

// The home phone number
func (r ApiCreateEmployeeRequest) HomePhone(homePhone string) ApiCreateEmployeeRequest {
	r.homePhone = &homePhone
	return r
}

// The cellular phone number
func (r ApiCreateEmployeeRequest) CellPhone(cellPhone string) ApiCreateEmployeeRequest {
	r.cellPhone = &cellPhone
	return r
}

// The cellular service provider. This is required for sending SMS. Leave this empty if the provider is not on the list of supported carriers.
func (r ApiCreateEmployeeRequest) CellPhoneCarrier(cellPhoneCarrier string) ApiCreateEmployeeRequest {
	r.cellPhoneCarrier = &cellPhoneCarrier
	return r
}

// The business phone number
func (r ApiCreateEmployeeRequest) BusinessPhone(businessPhone string) ApiCreateEmployeeRequest {
	r.businessPhone = &businessPhone
	return r
}

// The user&#39;s contact email address (NOT the username)
func (r ApiCreateEmployeeRequest) EmailAddress(emailAddress string) ApiCreateEmployeeRequest {
	r.emailAddress = &emailAddress
	return r
}

// The street address of the user&#39;s contact location
func (r ApiCreateEmployeeRequest) StreetAddress(streetAddress string) ApiCreateEmployeeRequest {
	r.streetAddress = &streetAddress
	return r
}

// Additional address information (such as a suite number, floor number, building name, or PO Box)
func (r ApiCreateEmployeeRequest) StreetAddress2(streetAddress2 string) ApiCreateEmployeeRequest {
	r.streetAddress2 = &streetAddress2
	return r
}

// The city of the user&#39;s contact location
func (r ApiCreateEmployeeRequest) City(city string) ApiCreateEmployeeRequest {
	r.city = &city
	return r
}

// The state of the user&#39;s contact location
func (r ApiCreateEmployeeRequest) State(state string) ApiCreateEmployeeRequest {
	r.state = &state
	return r
}

// The zipcode of the user&#39;s contact location
func (r ApiCreateEmployeeRequest) Zipcode(zipcode string) ApiCreateEmployeeRequest {
	r.zipcode = &zipcode
	return r
}

// The country of the user&#39;s contact location
func (r ApiCreateEmployeeRequest) Country(country string) ApiCreateEmployeeRequest {
	r.country = &country
	return r
}

// The role; RETAILER or RETAILER_LIMITED, defaulted to RETAILER_LIMITED
func (r ApiCreateEmployeeRequest) Role(role string) ApiCreateEmployeeRequest {
	r.role = &role
	return r
}

// the retailer location IDs the employee is associated with
func (r ApiCreateEmployeeRequest) RetailerLocationIds(retailerLocationIds string) ApiCreateEmployeeRequest {
	r.retailerLocationIds = &retailerLocationIds
	return r
}

// Determines whether to return the application settings for the employee for a particular application
func (r ApiCreateEmployeeRequest) SettingsAppKey(settingsAppKey string) ApiCreateEmployeeRequest {
	r.settingsAppKey = &settingsAppKey
	return r
}

// external custom client defined data (per Application)
func (r ApiCreateEmployeeRequest) AppBlob(appBlob string) ApiCreateEmployeeRequest {
	r.appBlob = &appBlob
	return r
}

// The device id to assign to the user (used for IPS beacon tracking)
func (r ApiCreateEmployeeRequest) AssignedDeviceId(assignedDeviceId string) ApiCreateEmployeeRequest {
	r.assignedDeviceId = &assignedDeviceId
	return r
}

func (r ApiCreateEmployeeRequest) Execute() (*EmployeeResponse, *http.Response, error) {
	return r.ApiService.CreateEmployeeExecute(r)
}

/*
CreateEmployee Create Employee

Create a new account record with the provided information.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiCreateEmployeeRequest
*/
func (a *EmployeeAPIService) CreateEmployee(ctx context.Context, version float32) ApiCreateEmployeeRequest {
	return ApiCreateEmployeeRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return EmployeeResponse
func (a *EmployeeAPIService) CreateEmployeeExecute(r ApiCreateEmployeeRequest) (*EmployeeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmployeeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EmployeeAPIService.CreateEmployee")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/employee/create"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.managerAccountId == nil {
		return localVarReturnValue, nil, reportError("managerAccountId is required and must be specified")
	}
	if r.username == nil {
		return localVarReturnValue, nil, reportError("username is required and must be specified")
	}
	if r.password == nil {
		return localVarReturnValue, nil, reportError("password is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "managerAccountId", r.managerAccountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "username", r.username, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "password", r.password, "form", "")
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.prefixName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prefixName", r.prefixName, "form", "")
	}
	if r.firstName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "firstName", r.firstName, "form", "")
	}
	if r.middleName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "middleName", r.middleName, "form", "")
	}
	if r.lastName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastName", r.lastName, "form", "")
	}
	if r.suffixName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "suffixName", r.suffixName, "form", "")
	}
	if r.title != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "title", r.title, "form", "")
	}
	if r.aboutUs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "aboutUs", r.aboutUs, "form", "")
	}
	if r.assetId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetId", r.assetId, "form", "")
	}
	if r.gender != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gender", r.gender, "form", "")
	}
	if r.homePhone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "homePhone", r.homePhone, "form", "")
	}
	if r.cellPhone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cellPhone", r.cellPhone, "form", "")
	}
	if r.cellPhoneCarrier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cellPhoneCarrier", r.cellPhoneCarrier, "form", "")
	}
	if r.businessPhone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "businessPhone", r.businessPhone, "form", "")
	}
	if r.emailAddress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailAddress", r.emailAddress, "form", "")
	}
	if r.streetAddress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "streetAddress", r.streetAddress, "form", "")
	}
	if r.streetAddress2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "streetAddress2", r.streetAddress2, "form", "")
	}
	if r.city != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "city", r.city, "form", "")
	}
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "form", "")
	}
	if r.zipcode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "zipcode", r.zipcode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.role != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "role", r.role, "form", "")
	}
	if r.retailerLocationIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "retailerLocationIds", r.retailerLocationIds, "form", "")
	}
	if r.settingsAppKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "settingsAppKey", r.settingsAppKey, "form", "")
	}
	if r.appBlob != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appBlob", r.appBlob, "form", "")
	}
	if r.assignedDeviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assignedDeviceId", r.assignedDeviceId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteEmployeeRequest struct {
	ctx context.Context
	ApiService *EmployeeAPIService
	version float32
	accountId *int64
	employeeAccountId *int64
}

// the id of the logged in user
func (r ApiDeleteEmployeeRequest) AccountId(accountId int64) ApiDeleteEmployeeRequest {
	r.accountId = &accountId
	return r
}

// the id of the employee to delete
func (r ApiDeleteEmployeeRequest) EmployeeAccountId(employeeAccountId int64) ApiDeleteEmployeeRequest {
	r.employeeAccountId = &employeeAccountId
	return r
}

func (r ApiDeleteEmployeeRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.DeleteEmployeeExecute(r)
}

/*
DeleteEmployee Delete Employee

Set the deleted date field which marks the record as deleted.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiDeleteEmployeeRequest
*/
func (a *EmployeeAPIService) DeleteEmployee(ctx context.Context, version float32) ApiDeleteEmployeeRequest {
	return ApiDeleteEmployeeRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *EmployeeAPIService) DeleteEmployeeExecute(r ApiDeleteEmployeeRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EmployeeAPIService.DeleteEmployee")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/employee/delete"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.employeeAccountId == nil {
		return localVarReturnValue, nil, reportError("employeeAccountId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "employeeAccountId", r.employeeAccountId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEmployeeRequest struct {
	ctx context.Context
	ApiService *EmployeeAPIService
	version float32
	accountId *int64
	employeeAccountId *int64
	settingsAppKey *string
}

// the id of logged in user
func (r ApiGetEmployeeRequest) AccountId(accountId int64) ApiGetEmployeeRequest {
	r.accountId = &accountId
	return r
}

// the id of the employee account to get
func (r ApiGetEmployeeRequest) EmployeeAccountId(employeeAccountId int64) ApiGetEmployeeRequest {
	r.employeeAccountId = &employeeAccountId
	return r
}

// Determines whether to return the application settings for the employee for a particular application
func (r ApiGetEmployeeRequest) SettingsAppKey(settingsAppKey string) ApiGetEmployeeRequest {
	r.settingsAppKey = &settingsAppKey
	return r
}

func (r ApiGetEmployeeRequest) Execute() (*EmployeeResponse, *http.Response, error) {
	return r.ApiService.GetEmployeeExecute(r)
}

/*
GetEmployee Get Employee

Get the account record for the account id provided.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiGetEmployeeRequest
*/
func (a *EmployeeAPIService) GetEmployee(ctx context.Context, version float32) ApiGetEmployeeRequest {
	return ApiGetEmployeeRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return EmployeeResponse
func (a *EmployeeAPIService) GetEmployeeExecute(r ApiGetEmployeeRequest) (*EmployeeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmployeeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EmployeeAPIService.GetEmployee")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/employee/get"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.employeeAccountId == nil {
		return localVarReturnValue, nil, reportError("employeeAccountId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "employeeAccountId", r.employeeAccountId, "form", "")
	if r.settingsAppKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "settingsAppKey", r.settingsAppKey, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchEmployeesRequest struct {
	ctx context.Context
	ApiService *EmployeeAPIService
	version float32
	accountId *int64
	role *string
	retailerId *int64
	retailerLocationId *int64
	q *string
	keyword *string
	sortField *string
	descending *bool
	i *int32
	start *int32
	l *int32
	limit *int32
	activeOnly *bool
	managedOnly *bool
	settingsAppKey *string
	categoryIds *string
	query *string
}

// The account id of the logged in user
func (r ApiSearchEmployeesRequest) AccountId(accountId int64) ApiSearchEmployeesRequest {
	r.accountId = &accountId
	return r
}

// The role to limit the search to: RETAILER or RETAILER_LIMITED. Leave empty to search on both roles.
func (r ApiSearchEmployeesRequest) Role(role string) ApiSearchEmployeesRequest {
	r.role = &role
	return r
}

// Filters employees by retailer
func (r ApiSearchEmployeesRequest) RetailerId(retailerId int64) ApiSearchEmployeesRequest {
	r.retailerId = &retailerId
	return r
}

// Filter employees by retailer locations
func (r ApiSearchEmployeesRequest) RetailerLocationId(retailerLocationId int64) ApiSearchEmployeesRequest {
	r.retailerLocationId = &retailerLocationId
	return r
}

// Deprecated parameter
func (r ApiSearchEmployeesRequest) Q(q string) ApiSearchEmployeesRequest {
	r.q = &q
	return r
}

// an optional keyword to search on; ignored if empty
func (r ApiSearchEmployeesRequest) Keyword(keyword string) ApiSearchEmployeesRequest {
	r.keyword = &keyword
	return r
}

// The field to sort by. Possible values include: DISPLAY, CREATED, UPDATED, ACTIVE, DELETED, LAST_LOGGED_IN, CONTACT_EMAIL, RETAILER_LOCATION_NAME, RETAILER_NAME
func (r ApiSearchEmployeesRequest) SortField(sortField string) ApiSearchEmployeesRequest {
	r.sortField = &sortField
	return r
}

// Determines whether the sorted list is in descending or ascending order
func (r ApiSearchEmployeesRequest) Descending(descending bool) ApiSearchEmployeesRequest {
	r.descending = &descending
	return r
}

// Deprecated parameter
func (r ApiSearchEmployeesRequest) I(i int32) ApiSearchEmployeesRequest {
	r.i = &i
	return r
}

// Start the result set at some index
func (r ApiSearchEmployeesRequest) Start(start int32) ApiSearchEmployeesRequest {
	r.start = &start
	return r
}

// Deprecated parameter
func (r ApiSearchEmployeesRequest) L(l int32) ApiSearchEmployeesRequest {
	r.l = &l
	return r
}

// Limit the result to some number
func (r ApiSearchEmployeesRequest) Limit(limit int32) ApiSearchEmployeesRequest {
	r.limit = &limit
	return r
}

// Filter results to only return active employees
func (r ApiSearchEmployeesRequest) ActiveOnly(activeOnly bool) ApiSearchEmployeesRequest {
	r.activeOnly = &activeOnly
	return r
}

// Filter results to only employees that you manage
func (r ApiSearchEmployeesRequest) ManagedOnly(managedOnly bool) ApiSearchEmployeesRequest {
	r.managedOnly = &managedOnly
	return r
}

// Determines whether to return the application settings for the employee for a particular application
func (r ApiSearchEmployeesRequest) SettingsAppKey(settingsAppKey string) ApiSearchEmployeesRequest {
	r.settingsAppKey = &settingsAppKey
	return r
}

// Comma separated list of category ids to filter results
func (r ApiSearchEmployeesRequest) CategoryIds(categoryIds string) ApiSearchEmployeesRequest {
	r.categoryIds = &categoryIds
	return r
}

// Legacy/reporting query parameter used for formatting employee responses
func (r ApiSearchEmployeesRequest) Query(query string) ApiSearchEmployeesRequest {
	r.query = &query
	return r
}

func (r ApiSearchEmployeesRequest) Execute() ([]EmployeeResponse, *http.Response, error) {
	return r.ApiService.SearchEmployeesExecute(r)
}

/*
SearchEmployees Search Employees

Use the accountId to determine the associated BillableEntity. From there get a list of all accounts associated as managers/employees.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiSearchEmployeesRequest
*/
func (a *EmployeeAPIService) SearchEmployees(ctx context.Context, version float32) ApiSearchEmployeesRequest {
	return ApiSearchEmployeesRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return []EmployeeResponse
func (a *EmployeeAPIService) SearchEmployeesExecute(r ApiSearchEmployeesRequest) ([]EmployeeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []EmployeeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EmployeeAPIService.SearchEmployees")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/employee/search"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	if r.role != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "role", r.role, "form", "")
	}
	if r.retailerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "retailerId", r.retailerId, "form", "")
	}
	if r.retailerLocationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "retailerLocationId", r.retailerLocationId, "form", "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.keyword != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyword", r.keyword, "form", "")
	}
	if r.sortField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", r.sortField, "form", "")
	}
	if r.descending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", defaultValue, "form", "")
		r.descending = &defaultValue
	}
	if r.i != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "_i", r.i, "form", "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	} else {
		var defaultValue int32 = 0
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", defaultValue, "form", "")
		r.start = &defaultValue
	}
	if r.l != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "_l", r.l, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 20
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	if r.activeOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activeOnly", r.activeOnly, "form", "")
	} else {
		var defaultValue bool = true
		parameterAddToHeaderOrQuery(localVarQueryParams, "activeOnly", defaultValue, "form", "")
		r.activeOnly = &defaultValue
	}
	if r.managedOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "managedOnly", r.managedOnly, "form", "")
	}
	if r.settingsAppKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "settingsAppKey", r.settingsAppKey, "form", "")
	}
	if r.categoryIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "categoryIds", r.categoryIds, "form", "")
	}
	if r.query != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnassignEmployeeRequest struct {
	ctx context.Context
	ApiService *EmployeeAPIService
	version float32
	accountId *int64
	employeeAccountId *int64
}

// The account id of the logged in user
func (r ApiUnassignEmployeeRequest) AccountId(accountId int64) ApiUnassignEmployeeRequest {
	r.accountId = &accountId
	return r
}

// The account id of the user to be unassigned
func (r ApiUnassignEmployeeRequest) EmployeeAccountId(employeeAccountId int64) ApiUnassignEmployeeRequest {
	r.employeeAccountId = &employeeAccountId
	return r
}

func (r ApiUnassignEmployeeRequest) Execute() (*EmployeeResponse, *http.Response, error) {
	return r.ApiService.UnassignEmployeeExecute(r)
}

/*
UnassignEmployee Unassign Employee

Unassign An existing account to be an employee

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiUnassignEmployeeRequest
*/
func (a *EmployeeAPIService) UnassignEmployee(ctx context.Context, version float32) ApiUnassignEmployeeRequest {
	return ApiUnassignEmployeeRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return EmployeeResponse
func (a *EmployeeAPIService) UnassignEmployeeExecute(r ApiUnassignEmployeeRequest) (*EmployeeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmployeeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EmployeeAPIService.UnassignEmployee")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/employee/unassign"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.employeeAccountId == nil {
		return localVarReturnValue, nil, reportError("employeeAccountId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "employeeAccountId", r.employeeAccountId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateEmployeeRequest struct {
	ctx context.Context
	ApiService *EmployeeAPIService
	version float32
	accountId *int64
	employeeAccountId *int64
	managerAccountId *int64
	name *string
	prefixName *string
	firstName *string
	middleName *string
	lastName *string
	suffixName *string
	title *string
	assetId *int64
	gender *string
	homePhone *string
	cellPhone *string
	cellPhoneCarrier *string
	businessPhone *string
	emailAddress *string
	streetAddress *string
	streetAddress2 *string
	city *string
	state *string
	zipcode *string
	country *string
	role *string
	active *bool
	password *string
	retailerLocationIds *string
	settingsAppKey *string
	appBlob *string
	assignedDeviceId *string
}

// The account id of the logged in user
func (r ApiUpdateEmployeeRequest) AccountId(accountId int64) ApiUpdateEmployeeRequest {
	r.accountId = &accountId
	return r
}

// the id of the employee account
func (r ApiUpdateEmployeeRequest) EmployeeAccountId(employeeAccountId int64) ApiUpdateEmployeeRequest {
	r.employeeAccountId = &employeeAccountId
	return r
}

// The account id of the manager to assign under
func (r ApiUpdateEmployeeRequest) ManagerAccountId(managerAccountId int64) ApiUpdateEmployeeRequest {
	r.managerAccountId = &managerAccountId
	return r
}

// a name field
func (r ApiUpdateEmployeeRequest) Name(name string) ApiUpdateEmployeeRequest {
	r.name = &name
	return r
}

// The name prefix; Mr, Mrs, etc
func (r ApiUpdateEmployeeRequest) PrefixName(prefixName string) ApiUpdateEmployeeRequest {
	r.prefixName = &prefixName
	return r
}

// The first name
func (r ApiUpdateEmployeeRequest) FirstName(firstName string) ApiUpdateEmployeeRequest {
	r.firstName = &firstName
	return r
}

// The middle name
func (r ApiUpdateEmployeeRequest) MiddleName(middleName string) ApiUpdateEmployeeRequest {
	r.middleName = &middleName
	return r
}

// The last name
func (r ApiUpdateEmployeeRequest) LastName(lastName string) ApiUpdateEmployeeRequest {
	r.lastName = &lastName
	return r
}

// The name suffix; Jr, Sr, III, etc
func (r ApiUpdateEmployeeRequest) SuffixName(suffixName string) ApiUpdateEmployeeRequest {
	r.suffixName = &suffixName
	return r
}

// The title of the user
func (r ApiUpdateEmployeeRequest) Title(title string) ApiUpdateEmployeeRequest {
	r.title = &title
	return r
}

// the asset id to set the user&#39;s profile image
func (r ApiUpdateEmployeeRequest) AssetId(assetId int64) ApiUpdateEmployeeRequest {
	r.assetId = &assetId
	return r
}

// The gender {MALE, FEMALE, ANY}
func (r ApiUpdateEmployeeRequest) Gender(gender string) ApiUpdateEmployeeRequest {
	r.gender = &gender
	return r
}

// The home phone number
func (r ApiUpdateEmployeeRequest) HomePhone(homePhone string) ApiUpdateEmployeeRequest {
	r.homePhone = &homePhone
	return r
}

// The cellular phone number
func (r ApiUpdateEmployeeRequest) CellPhone(cellPhone string) ApiUpdateEmployeeRequest {
	r.cellPhone = &cellPhone
	return r
}

// The cellular service provider. This is required for sending SMS. Leave this empty if the provider is not on the list of supported carriers. Supported Carriers: {ATT, QWEST, T_MOBILE, VERIZON, SPRINT, VIRIGIN_MOBILE, NEXTEL, ALLTEL, METRO_PCS, POWERTEL, BOOST_MOBILE, SUNCOM, TRACFONE, US_CELLULAR}
func (r ApiUpdateEmployeeRequest) CellPhoneCarrier(cellPhoneCarrier string) ApiUpdateEmployeeRequest {
	r.cellPhoneCarrier = &cellPhoneCarrier
	return r
}

// The business phone number
func (r ApiUpdateEmployeeRequest) BusinessPhone(businessPhone string) ApiUpdateEmployeeRequest {
	r.businessPhone = &businessPhone
	return r
}

// The user&#39;s contact email address (NOT the username)
func (r ApiUpdateEmployeeRequest) EmailAddress(emailAddress string) ApiUpdateEmployeeRequest {
	r.emailAddress = &emailAddress
	return r
}

// The street address of the user&#39;s contact location
func (r ApiUpdateEmployeeRequest) StreetAddress(streetAddress string) ApiUpdateEmployeeRequest {
	r.streetAddress = &streetAddress
	return r
}

// Additional address information (such as a suite number, floor number, building name, or PO Box)
func (r ApiUpdateEmployeeRequest) StreetAddress2(streetAddress2 string) ApiUpdateEmployeeRequest {
	r.streetAddress2 = &streetAddress2
	return r
}

// The city of the user&#39;s contact location
func (r ApiUpdateEmployeeRequest) City(city string) ApiUpdateEmployeeRequest {
	r.city = &city
	return r
}

// The state of the user&#39;s contact location
func (r ApiUpdateEmployeeRequest) State(state string) ApiUpdateEmployeeRequest {
	r.state = &state
	return r
}

// The zipcode of the user&#39;s contact location
func (r ApiUpdateEmployeeRequest) Zipcode(zipcode string) ApiUpdateEmployeeRequest {
	r.zipcode = &zipcode
	return r
}

// The country of the user&#39;s contact location
func (r ApiUpdateEmployeeRequest) Country(country string) ApiUpdateEmployeeRequest {
	r.country = &country
	return r
}

// The role; RETAILER or RETAILER_LIMITED, defaulted to RETAILER_LIMITED
func (r ApiUpdateEmployeeRequest) Role(role string) ApiUpdateEmployeeRequest {
	r.role = &role
	return r
}

// Sets whether the employee is active or inactive
func (r ApiUpdateEmployeeRequest) Active(active bool) ApiUpdateEmployeeRequest {
	r.active = &active
	return r
}

// Sets the password for the employee
func (r ApiUpdateEmployeeRequest) Password(password string) ApiUpdateEmployeeRequest {
	r.password = &password
	return r
}

// Sets which retailer locations the employee is assigned to
func (r ApiUpdateEmployeeRequest) RetailerLocationIds(retailerLocationIds string) ApiUpdateEmployeeRequest {
	r.retailerLocationIds = &retailerLocationIds
	return r
}

// Determines whether to return the application settings for the employee for a particular application
func (r ApiUpdateEmployeeRequest) SettingsAppKey(settingsAppKey string) ApiUpdateEmployeeRequest {
	r.settingsAppKey = &settingsAppKey
	return r
}

// external custom client defined data (per Application)
func (r ApiUpdateEmployeeRequest) AppBlob(appBlob string) ApiUpdateEmployeeRequest {
	r.appBlob = &appBlob
	return r
}

// The device id to assign to the user (used for IPS beacon tracking)
func (r ApiUpdateEmployeeRequest) AssignedDeviceId(assignedDeviceId string) ApiUpdateEmployeeRequest {
	r.assignedDeviceId = &assignedDeviceId
	return r
}

func (r ApiUpdateEmployeeRequest) Execute() (*EmployeeResponse, *http.Response, error) {
	return r.ApiService.UpdateEmployeeExecute(r)
}

/*
UpdateEmployee Update Employee

Update the account record with the provided information.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiUpdateEmployeeRequest
*/
func (a *EmployeeAPIService) UpdateEmployee(ctx context.Context, version float32) ApiUpdateEmployeeRequest {
	return ApiUpdateEmployeeRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return EmployeeResponse
func (a *EmployeeAPIService) UpdateEmployeeExecute(r ApiUpdateEmployeeRequest) (*EmployeeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmployeeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EmployeeAPIService.UpdateEmployee")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/employee/update"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.employeeAccountId == nil {
		return localVarReturnValue, nil, reportError("employeeAccountId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "employeeAccountId", r.employeeAccountId, "form", "")
	if r.managerAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "managerAccountId", r.managerAccountId, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.prefixName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prefixName", r.prefixName, "form", "")
	}
	if r.firstName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "firstName", r.firstName, "form", "")
	}
	if r.middleName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "middleName", r.middleName, "form", "")
	}
	if r.lastName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastName", r.lastName, "form", "")
	}
	if r.suffixName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "suffixName", r.suffixName, "form", "")
	}
	if r.title != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "title", r.title, "form", "")
	}
	if r.assetId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetId", r.assetId, "form", "")
	}
	if r.gender != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gender", r.gender, "form", "")
	}
	if r.homePhone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "homePhone", r.homePhone, "form", "")
	}
	if r.cellPhone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cellPhone", r.cellPhone, "form", "")
	}
	if r.cellPhoneCarrier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cellPhoneCarrier", r.cellPhoneCarrier, "form", "")
	}
	if r.businessPhone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "businessPhone", r.businessPhone, "form", "")
	}
	if r.emailAddress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailAddress", r.emailAddress, "form", "")
	}
	if r.streetAddress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "streetAddress", r.streetAddress, "form", "")
	}
	if r.streetAddress2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "streetAddress2", r.streetAddress2, "form", "")
	}
	if r.city != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "city", r.city, "form", "")
	}
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "form", "")
	}
	if r.zipcode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "zipcode", r.zipcode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.role != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "role", r.role, "form", "")
	}
	if r.active != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active", r.active, "form", "")
	}
	if r.password != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "password", r.password, "form", "")
	}
	if r.retailerLocationIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "retailerLocationIds", r.retailerLocationIds, "form", "")
	}
	if r.settingsAppKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "settingsAppKey", r.settingsAppKey, "form", "")
	}
	if r.appBlob != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appBlob", r.appBlob, "form", "")
	}
	if r.assignedDeviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assignedDeviceId", r.assignedDeviceId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
