/*
Sirqul IoT Platform

Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

API version: 3.16
Contact: info@sirqul.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
)


// ThirdPartyCredentialsAPIService ThirdPartyCredentialsAPI service
type ThirdPartyCredentialsAPIService service

type ApiCreateCredentialRequest struct {
	ctx context.Context
	ApiService *ThirdPartyCredentialsAPIService
	version float32
	thirdPartyId *string
	thirdPartyToken *string
	networkUID *string
	appKey *string
	accountId *int64
	deviceId *string
	sessionId *string
	thirdPartyName *string
	emailAddress *string
	signinOnlyMode *bool
	responseFilters *string
	latitude *float64
	longitude *float64
	metaData *string
	thirdPartyRefreshToken *string
	audienceIdsToAdd *string
	audienceIdsToRemove *string
}

// the third party user account id
func (r ApiCreateCredentialRequest) ThirdPartyId(thirdPartyId string) ApiCreateCredentialRequest {
	r.thirdPartyId = &thirdPartyId
	return r
}

// the access token to authenticate with (ex: username or fb token or phone number)
func (r ApiCreateCredentialRequest) ThirdPartyToken(thirdPartyToken string) ApiCreateCredentialRequest {
	r.thirdPartyToken = &thirdPartyToken
	return r
}

// the access provider to authenticate against
func (r ApiCreateCredentialRequest) NetworkUID(networkUID string) ApiCreateCredentialRequest {
	r.networkUID = &networkUID
	return r
}

// the application key
func (r ApiCreateCredentialRequest) AppKey(appKey string) ApiCreateCredentialRequest {
	r.appKey = &appKey
	return r
}

// the unique id of the account that needs authenticating (optional for PHONE_V2)
func (r ApiCreateCredentialRequest) AccountId(accountId int64) ApiCreateCredentialRequest {
	r.accountId = &accountId
	return r
}

// the unique id of the device making the request
func (r ApiCreateCredentialRequest) DeviceId(deviceId string) ApiCreateCredentialRequest {
	r.deviceId = &deviceId
	return r
}

// the session id for the request
func (r ApiCreateCredentialRequest) SessionId(sessionId string) ApiCreateCredentialRequest {
	r.sessionId = &sessionId
	return r
}

// the third party user&#39;s display name
func (r ApiCreateCredentialRequest) ThirdPartyName(thirdPartyName string) ApiCreateCredentialRequest {
	r.thirdPartyName = &thirdPartyName
	return r
}

// optional email address associated with the third party account
func (r ApiCreateCredentialRequest) EmailAddress(emailAddress string) ApiCreateCredentialRequest {
	r.emailAddress = &emailAddress
	return r
}

// when true will error out if can&#39;t find any accounts matching (signin only)
func (r ApiCreateCredentialRequest) SigninOnlyMode(signinOnlyMode bool) ApiCreateCredentialRequest {
	r.signinOnlyMode = &signinOnlyMode
	return r
}

// this determines how much of the profile should be returned, see ProfileFilters
func (r ApiCreateCredentialRequest) ResponseFilters(responseFilters string) ApiCreateCredentialRequest {
	r.responseFilters = &responseFilters
	return r
}

// the latitude of the user
func (r ApiCreateCredentialRequest) Latitude(latitude float64) ApiCreateCredentialRequest {
	r.latitude = &latitude
	return r
}

// the longitude of the user
func (r ApiCreateCredentialRequest) Longitude(longitude float64) ApiCreateCredentialRequest {
	r.longitude = &longitude
	return r
}

// External custom client defined data
func (r ApiCreateCredentialRequest) MetaData(metaData string) ApiCreateCredentialRequest {
	r.metaData = &metaData
	return r
}

// optional refresh token for the third party
func (r ApiCreateCredentialRequest) ThirdPartyRefreshToken(thirdPartyRefreshToken string) ApiCreateCredentialRequest {
	r.thirdPartyRefreshToken = &thirdPartyRefreshToken
	return r
}

// audience ids to add to the account
func (r ApiCreateCredentialRequest) AudienceIdsToAdd(audienceIdsToAdd string) ApiCreateCredentialRequest {
	r.audienceIdsToAdd = &audienceIdsToAdd
	return r
}

// audience ids to remove from the account
func (r ApiCreateCredentialRequest) AudienceIdsToRemove(audienceIdsToRemove string) ApiCreateCredentialRequest {
	r.audienceIdsToRemove = &audienceIdsToRemove
	return r
}

func (r ApiCreateCredentialRequest) Execute() (*ProfileResponse, *http.Response, error) {
	return r.ApiService.CreateCredentialExecute(r)
}

/*
CreateCredential Create Credential

This endpoint creates a third-party login for a Sirqul account. A third party login is a way for external systems (Third Party Networks) to link their own user accounts with a Sirqul account. 

The thirdPartyId parameter is used to determine if the user already exists in Sirqul or not. This parameter needs to be unique for each user in the Third Party Network (identified by the networkUID parameter). Note that subsequent calls will update the user's third-party login credentials for the user with the same thirdPartyId and networkUID combination. 

 The thirdPartyToken parameter acts as a shared secret and used by client applications to log users into Sirqul without providing a Sirqul username and password. 

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiCreateCredentialRequest
*/
func (a *ThirdPartyCredentialsAPIService) CreateCredential(ctx context.Context, version float32) ApiCreateCredentialRequest {
	return ApiCreateCredentialRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return ProfileResponse
func (a *ThirdPartyCredentialsAPIService) CreateCredentialExecute(r ApiCreateCredentialRequest) (*ProfileResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProfileResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ThirdPartyCredentialsAPIService.CreateCredential")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/thirdparty/credential/create"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.thirdPartyId == nil {
		return localVarReturnValue, nil, reportError("thirdPartyId is required and must be specified")
	}
	if r.thirdPartyToken == nil {
		return localVarReturnValue, nil, reportError("thirdPartyToken is required and must be specified")
	}
	if r.networkUID == nil {
		return localVarReturnValue, nil, reportError("networkUID is required and must be specified")
	}
	if r.appKey == nil {
		return localVarReturnValue, nil, reportError("appKey is required and must be specified")
	}

	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.sessionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sessionId", r.sessionId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "thirdPartyId", r.thirdPartyId, "form", "")
	if r.thirdPartyName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "thirdPartyName", r.thirdPartyName, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "thirdPartyToken", r.thirdPartyToken, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "networkUID", r.networkUID, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	if r.emailAddress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailAddress", r.emailAddress, "form", "")
	}
	if r.signinOnlyMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "signinOnlyMode", r.signinOnlyMode, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "signinOnlyMode", defaultValue, "form", "")
		r.signinOnlyMode = &defaultValue
	}
	if r.responseFilters != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "responseFilters", r.responseFilters, "form", "")
	}
	if r.latitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latitude", r.latitude, "form", "")
	}
	if r.longitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "longitude", r.longitude, "form", "")
	}
	if r.metaData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metaData", r.metaData, "form", "")
	}
	if r.thirdPartyRefreshToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "thirdPartyRefreshToken", r.thirdPartyRefreshToken, "form", "")
	}
	if r.audienceIdsToAdd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audienceIdsToAdd", r.audienceIdsToAdd, "form", "")
	}
	if r.audienceIdsToRemove != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audienceIdsToRemove", r.audienceIdsToRemove, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateNetworkRequest struct {
	ctx context.Context
	ApiService *ThirdPartyCredentialsAPIService
	version float32
	accountId *int64
	name *string
	enableIntrospection *bool
	description *string
	introspectionMethod *string
	introspectionURL *string
	introspectionParams *string
	requiredRootField *string
	enableMFA *bool
	sizeMFA *int32
	shelfLifeMFA *int32
	oauthTokenURL *string
	oauthPrivateKey *os.File
	oauthPublicKey *os.File
	oauthClientId *string
	oauthSecretKey *string
	body *string
}

// The account id making the request
func (r ApiCreateNetworkRequest) AccountId(accountId int64) ApiCreateNetworkRequest {
	r.accountId = &accountId
	return r
}

// The name of the network
func (r ApiCreateNetworkRequest) Name(name string) ApiCreateNetworkRequest {
	r.name = &name
	return r
}

// Whether the network uses introspection calls
func (r ApiCreateNetworkRequest) EnableIntrospection(enableIntrospection bool) ApiCreateNetworkRequest {
	r.enableIntrospection = &enableIntrospection
	return r
}

// The description of the network
func (r ApiCreateNetworkRequest) Description(description string) ApiCreateNetworkRequest {
	r.description = &description
	return r
}

// HTTP method to use for introspection calls (e.g., GET, POST)
func (r ApiCreateNetworkRequest) IntrospectionMethod(introspectionMethod string) ApiCreateNetworkRequest {
	r.introspectionMethod = &introspectionMethod
	return r
}

// The HTTP URL of the introspection call
func (r ApiCreateNetworkRequest) IntrospectionURL(introspectionURL string) ApiCreateNetworkRequest {
	r.introspectionURL = &introspectionURL
	return r
}

// The parameters of the introspection call
func (r ApiCreateNetworkRequest) IntrospectionParams(introspectionParams string) ApiCreateNetworkRequest {
	r.introspectionParams = &introspectionParams
	return r
}

// Required response params
func (r ApiCreateNetworkRequest) RequiredRootField(requiredRootField string) ApiCreateNetworkRequest {
	r.requiredRootField = &requiredRootField
	return r
}

// Whether this network uses MFA
func (r ApiCreateNetworkRequest) EnableMFA(enableMFA bool) ApiCreateNetworkRequest {
	r.enableMFA = &enableMFA
	return r
}

// Size of the MFA token
func (r ApiCreateNetworkRequest) SizeMFA(sizeMFA int32) ApiCreateNetworkRequest {
	r.sizeMFA = &sizeMFA
	return r
}

// Shelf life (seconds) of the MFA token
func (r ApiCreateNetworkRequest) ShelfLifeMFA(shelfLifeMFA int32) ApiCreateNetworkRequest {
	r.shelfLifeMFA = &shelfLifeMFA
	return r
}

// OAuth token endpoint URL
func (r ApiCreateNetworkRequest) OauthTokenURL(oauthTokenURL string) ApiCreateNetworkRequest {
	r.oauthTokenURL = &oauthTokenURL
	return r
}

// OAuth private key file (multipart)
func (r ApiCreateNetworkRequest) OauthPrivateKey(oauthPrivateKey *os.File) ApiCreateNetworkRequest {
	r.oauthPrivateKey = oauthPrivateKey
	return r
}

// OAuth public key file (multipart)
func (r ApiCreateNetworkRequest) OauthPublicKey(oauthPublicKey *os.File) ApiCreateNetworkRequest {
	r.oauthPublicKey = oauthPublicKey
	return r
}

// OAuth client id
func (r ApiCreateNetworkRequest) OauthClientId(oauthClientId string) ApiCreateNetworkRequest {
	r.oauthClientId = &oauthClientId
	return r
}

// OAuth secret key
func (r ApiCreateNetworkRequest) OauthSecretKey(oauthSecretKey string) ApiCreateNetworkRequest {
	r.oauthSecretKey = &oauthSecretKey
	return r
}

func (r ApiCreateNetworkRequest) Body(body string) ApiCreateNetworkRequest {
	r.body = &body
	return r
}

func (r ApiCreateNetworkRequest) Execute() (*ThirdPartyNetworkResponse, *http.Response, error) {
	return r.ApiService.CreateNetworkExecute(r)
}

/*
CreateNetwork Create Network

Creates a custom third party network.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiCreateNetworkRequest
*/
func (a *ThirdPartyCredentialsAPIService) CreateNetwork(ctx context.Context, version float32) ApiCreateNetworkRequest {
	return ApiCreateNetworkRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return ThirdPartyNetworkResponse
func (a *ThirdPartyCredentialsAPIService) CreateNetworkExecute(r ApiCreateNetworkRequest) (*ThirdPartyNetworkResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ThirdPartyNetworkResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ThirdPartyCredentialsAPIService.CreateNetwork")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/thirdparty/network/create"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.name == nil {
		return localVarReturnValue, nil, reportError("name is required and must be specified")
	}
	if r.enableIntrospection == nil {
		return localVarReturnValue, nil, reportError("enableIntrospection is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "enableIntrospection", r.enableIntrospection, "form", "")
	if r.introspectionMethod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "introspectionMethod", r.introspectionMethod, "form", "")
	}
	if r.introspectionURL != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "introspectionURL", r.introspectionURL, "form", "")
	}
	if r.introspectionParams != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "introspectionParams", r.introspectionParams, "form", "")
	}
	if r.requiredRootField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "requiredRootField", r.requiredRootField, "form", "")
	}
	if r.enableMFA != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableMFA", r.enableMFA, "form", "")
	}
	if r.sizeMFA != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sizeMFA", r.sizeMFA, "form", "")
	}
	if r.shelfLifeMFA != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "shelfLifeMFA", r.shelfLifeMFA, "form", "")
	}
	if r.oauthTokenURL != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "oauthTokenURL", r.oauthTokenURL, "form", "")
	}
	if r.oauthPrivateKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "oauthPrivateKey", r.oauthPrivateKey, "form", "")
	}
	if r.oauthPublicKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "oauthPublicKey", r.oauthPublicKey, "form", "")
	}
	if r.oauthClientId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "oauthClientId", r.oauthClientId, "form", "")
	}
	if r.oauthSecretKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "oauthSecretKey", r.oauthSecretKey, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCredentialRequest struct {
	ctx context.Context
	ApiService *ThirdPartyCredentialsAPIService
	version float32
	accountId *int64
	networkUID *string
	thirdPartyId *string
	appKey *string
}

// The account id of the user
func (r ApiDeleteCredentialRequest) AccountId(accountId int64) ApiDeleteCredentialRequest {
	r.accountId = &accountId
	return r
}

// The third party network identifier
func (r ApiDeleteCredentialRequest) NetworkUID(networkUID string) ApiDeleteCredentialRequest {
	r.networkUID = &networkUID
	return r
}

// The third party user id
func (r ApiDeleteCredentialRequest) ThirdPartyId(thirdPartyId string) ApiDeleteCredentialRequest {
	r.thirdPartyId = &thirdPartyId
	return r
}

// the application key
func (r ApiDeleteCredentialRequest) AppKey(appKey string) ApiDeleteCredentialRequest {
	r.appKey = &appKey
	return r
}

func (r ApiDeleteCredentialRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.DeleteCredentialExecute(r)
}

/*
DeleteCredential Delete Credential

Delete a third party network on a Sirqul account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiDeleteCredentialRequest
*/
func (a *ThirdPartyCredentialsAPIService) DeleteCredential(ctx context.Context, version float32) ApiDeleteCredentialRequest {
	return ApiDeleteCredentialRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *ThirdPartyCredentialsAPIService) DeleteCredentialExecute(r ApiDeleteCredentialRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ThirdPartyCredentialsAPIService.DeleteCredential")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/thirdparty/credential/delete"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.networkUID == nil {
		return localVarReturnValue, nil, reportError("networkUID is required and must be specified")
	}
	if r.thirdPartyId == nil {
		return localVarReturnValue, nil, reportError("thirdPartyId is required and must be specified")
	}
	if r.appKey == nil {
		return localVarReturnValue, nil, reportError("appKey is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "networkUID", r.networkUID, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "thirdPartyId", r.thirdPartyId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteNetworkRequest struct {
	ctx context.Context
	ApiService *ThirdPartyCredentialsAPIService
	version float32
	accountId *int64
	networkUID *string
}

// the id of the logged in user
func (r ApiDeleteNetworkRequest) AccountId(accountId int64) ApiDeleteNetworkRequest {
	r.accountId = &accountId
	return r
}

// The unique identifier for the third party network defined by Sirqul
func (r ApiDeleteNetworkRequest) NetworkUID(networkUID string) ApiDeleteNetworkRequest {
	r.networkUID = &networkUID
	return r
}

func (r ApiDeleteNetworkRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.DeleteNetworkExecute(r)
}

/*
DeleteNetwork Delete Network

Marks a custom third party network as deleted. Only the network owners and managers have access to this.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiDeleteNetworkRequest
*/
func (a *ThirdPartyCredentialsAPIService) DeleteNetwork(ctx context.Context, version float32) ApiDeleteNetworkRequest {
	return ApiDeleteNetworkRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *ThirdPartyCredentialsAPIService) DeleteNetworkExecute(r ApiDeleteNetworkRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ThirdPartyCredentialsAPIService.DeleteNetwork")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/thirdparty/network/delete"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.networkUID == nil {
		return localVarReturnValue, nil, reportError("networkUID is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "networkUID", r.networkUID, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCredentialRequest struct {
	ctx context.Context
	ApiService *ThirdPartyCredentialsAPIService
	version float32
	networkUID *string
	appKey *string
	accountId *int64
	deviceId *string
	sessionId *string
	thirdPartyCredentialId *int64
	thirdPartyToken *string
	thirdPartySecret *string
	createNewAccount *bool
	responseFilters *string
	latitude *float64
	longitude *float64
	audienceIdsToAdd *string
	audienceIdsToRemove *string
	referralAccountId *int64
}

// the access provider to authenticate against
func (r ApiGetCredentialRequest) NetworkUID(networkUID string) ApiGetCredentialRequest {
	r.networkUID = &networkUID
	return r
}

// the application key
func (r ApiGetCredentialRequest) AppKey(appKey string) ApiGetCredentialRequest {
	r.appKey = &appKey
	return r
}

// the unique account id of a specific account that will be bound to the third-party credentials
func (r ApiGetCredentialRequest) AccountId(accountId int64) ApiGetCredentialRequest {
	r.accountId = &accountId
	return r
}

// the unique id of the device making the request
func (r ApiGetCredentialRequest) DeviceId(deviceId string) ApiGetCredentialRequest {
	r.deviceId = &deviceId
	return r
}

// the session id for the request
func (r ApiGetCredentialRequest) SessionId(sessionId string) ApiGetCredentialRequest {
	r.sessionId = &sessionId
	return r
}

// the third-party credentials id from the response of the credential/create step
func (r ApiGetCredentialRequest) ThirdPartyCredentialId(thirdPartyCredentialId int64) ApiGetCredentialRequest {
	r.thirdPartyCredentialId = &thirdPartyCredentialId
	return r
}

// the access token to authenticate with
func (r ApiGetCredentialRequest) ThirdPartyToken(thirdPartyToken string) ApiGetCredentialRequest {
	r.thirdPartyToken = &thirdPartyToken
	return r
}

// the secret code to authenticate with (used for MFA)
func (r ApiGetCredentialRequest) ThirdPartySecret(thirdPartySecret string) ApiGetCredentialRequest {
	r.thirdPartySecret = &thirdPartySecret
	return r
}

// flag to force creation of a new account when no accountId is passed and user chooses not to use listed accounts
func (r ApiGetCredentialRequest) CreateNewAccount(createNewAccount bool) ApiGetCredentialRequest {
	r.createNewAccount = &createNewAccount
	return r
}

// this determines how much of the profile should be returned, see ProfileFilters
func (r ApiGetCredentialRequest) ResponseFilters(responseFilters string) ApiGetCredentialRequest {
	r.responseFilters = &responseFilters
	return r
}

// the latitude of the user
func (r ApiGetCredentialRequest) Latitude(latitude float64) ApiGetCredentialRequest {
	r.latitude = &latitude
	return r
}

// the longitude of the user
func (r ApiGetCredentialRequest) Longitude(longitude float64) ApiGetCredentialRequest {
	r.longitude = &longitude
	return r
}

// audience ids to add to the account
func (r ApiGetCredentialRequest) AudienceIdsToAdd(audienceIdsToAdd string) ApiGetCredentialRequest {
	r.audienceIdsToAdd = &audienceIdsToAdd
	return r
}

// audience ids to remove from the account
func (r ApiGetCredentialRequest) AudienceIdsToRemove(audienceIdsToRemove string) ApiGetCredentialRequest {
	r.audienceIdsToRemove = &audienceIdsToRemove
	return r
}

// account id of the referrer (inviter-invitee relationship)
func (r ApiGetCredentialRequest) ReferralAccountId(referralAccountId int64) ApiGetCredentialRequest {
	r.referralAccountId = &referralAccountId
	return r
}

func (r ApiGetCredentialRequest) Execute() (*ProfileResponse, *http.Response, error) {
	return r.ApiService.GetCredentialExecute(r)
}

/*
GetCredential Get Credential

Gets the account information given a third party token.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiGetCredentialRequest
*/
func (a *ThirdPartyCredentialsAPIService) GetCredential(ctx context.Context, version float32) ApiGetCredentialRequest {
	return ApiGetCredentialRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return ProfileResponse
func (a *ThirdPartyCredentialsAPIService) GetCredentialExecute(r ApiGetCredentialRequest) (*ProfileResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProfileResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ThirdPartyCredentialsAPIService.GetCredential")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/thirdparty/credential/get"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.networkUID == nil {
		return localVarReturnValue, nil, reportError("networkUID is required and must be specified")
	}
	if r.appKey == nil {
		return localVarReturnValue, nil, reportError("appKey is required and must be specified")
	}

	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.sessionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sessionId", r.sessionId, "form", "")
	}
	if r.thirdPartyCredentialId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "thirdPartyCredentialId", r.thirdPartyCredentialId, "form", "")
	}
	if r.thirdPartyToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "thirdPartyToken", r.thirdPartyToken, "form", "")
	}
	if r.thirdPartySecret != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "thirdPartySecret", r.thirdPartySecret, "form", "")
	}
	if r.createNewAccount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createNewAccount", r.createNewAccount, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "createNewAccount", defaultValue, "form", "")
		r.createNewAccount = &defaultValue
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "networkUID", r.networkUID, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	if r.responseFilters != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "responseFilters", r.responseFilters, "form", "")
	}
	if r.latitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latitude", r.latitude, "form", "")
	}
	if r.longitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "longitude", r.longitude, "form", "")
	}
	if r.audienceIdsToAdd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audienceIdsToAdd", r.audienceIdsToAdd, "form", "")
	}
	if r.audienceIdsToRemove != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audienceIdsToRemove", r.audienceIdsToRemove, "form", "")
	}
	if r.referralAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "referralAccountId", r.referralAccountId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNetworkRequest struct {
	ctx context.Context
	ApiService *ThirdPartyCredentialsAPIService
	version float32
	accountId *int64
	networkUID *string
}

// The account id making the request
func (r ApiGetNetworkRequest) AccountId(accountId int64) ApiGetNetworkRequest {
	r.accountId = &accountId
	return r
}

// The unique identifier for the third party network defined by Sirqul
func (r ApiGetNetworkRequest) NetworkUID(networkUID string) ApiGetNetworkRequest {
	r.networkUID = &networkUID
	return r
}

func (r ApiGetNetworkRequest) Execute() (*ThirdPartyNetworkResponse, *http.Response, error) {
	return r.ApiService.GetNetworkExecute(r)
}

/*
GetNetwork Get Network

Get the details of a third party network. Only the network owners and managers have access to this.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiGetNetworkRequest
*/
func (a *ThirdPartyCredentialsAPIService) GetNetwork(ctx context.Context, version float32) ApiGetNetworkRequest {
	return ApiGetNetworkRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return ThirdPartyNetworkResponse
func (a *ThirdPartyCredentialsAPIService) GetNetworkExecute(r ApiGetNetworkRequest) (*ThirdPartyNetworkResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ThirdPartyNetworkResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ThirdPartyCredentialsAPIService.GetNetwork")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/thirdparty/network/get"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.networkUID == nil {
		return localVarReturnValue, nil, reportError("networkUID is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "networkUID", r.networkUID, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchCredentialsRequest struct {
	ctx context.Context
	ApiService *ThirdPartyCredentialsAPIService
	version float32
	accountId *int64
	keyword *string
	networkUID *string
	descending *bool
	start *int32
	limit *int32
}

// The account id of the user
func (r ApiSearchCredentialsRequest) AccountId(accountId int64) ApiSearchCredentialsRequest {
	r.accountId = &accountId
	return r
}

// The keyword used to search on the third party name and network string
func (r ApiSearchCredentialsRequest) Keyword(keyword string) ApiSearchCredentialsRequest {
	r.keyword = &keyword
	return r
}

// The network UID to filter results with
func (r ApiSearchCredentialsRequest) NetworkUID(networkUID string) ApiSearchCredentialsRequest {
	r.networkUID = &networkUID
	return r
}

// The order to return the search results
func (r ApiSearchCredentialsRequest) Descending(descending bool) ApiSearchCredentialsRequest {
	r.descending = &descending
	return r
}

// The start of the pagination
func (r ApiSearchCredentialsRequest) Start(start int32) ApiSearchCredentialsRequest {
	r.start = &start
	return r
}

// The limit of the pagination
func (r ApiSearchCredentialsRequest) Limit(limit int32) ApiSearchCredentialsRequest {
	r.limit = &limit
	return r
}

func (r ApiSearchCredentialsRequest) Execute() ([]ThirdPartyCredentialResponse, *http.Response, error) {
	return r.ApiService.SearchCredentialsExecute(r)
}

/*
SearchCredentials Search Credentials

Search on a user's linked third party networks.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiSearchCredentialsRequest
*/
func (a *ThirdPartyCredentialsAPIService) SearchCredentials(ctx context.Context, version float32) ApiSearchCredentialsRequest {
	return ApiSearchCredentialsRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return []ThirdPartyCredentialResponse
func (a *ThirdPartyCredentialsAPIService) SearchCredentialsExecute(r ApiSearchCredentialsRequest) ([]ThirdPartyCredentialResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ThirdPartyCredentialResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ThirdPartyCredentialsAPIService.SearchCredentials")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/thirdparty/credential/search"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	if r.keyword != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyword", r.keyword, "form", "")
	}
	if r.networkUID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "networkUID", r.networkUID, "form", "")
	}
	if r.descending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "form", "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	} else {
		var defaultValue int32 = 0
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", defaultValue, "form", "")
		r.start = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 20
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchNetworksRequest struct {
	ctx context.Context
	ApiService *ThirdPartyCredentialsAPIService
	version float32
	accountId *int64
	sortField *string
	descending *bool
	start *int32
	limit *int32
	activeOnly *bool
	keyword *string
	filterBillable *bool
}

// The account id making the request
func (r ApiSearchNetworksRequest) AccountId(accountId int64) ApiSearchNetworksRequest {
	r.accountId = &accountId
	return r
}

// The column to sort the search on, possible values include: UPDATED (default), CREATED, NAME
func (r ApiSearchNetworksRequest) SortField(sortField string) ApiSearchNetworksRequest {
	r.sortField = &sortField
	return r
}

// The order to return the search results
func (r ApiSearchNetworksRequest) Descending(descending bool) ApiSearchNetworksRequest {
	r.descending = &descending
	return r
}

// The start of the pagination
func (r ApiSearchNetworksRequest) Start(start int32) ApiSearchNetworksRequest {
	r.start = &start
	return r
}

// The limit of the pagination
func (r ApiSearchNetworksRequest) Limit(limit int32) ApiSearchNetworksRequest {
	r.limit = &limit
	return r
}

// Return only active results
func (r ApiSearchNetworksRequest) ActiveOnly(activeOnly bool) ApiSearchNetworksRequest {
	r.activeOnly = &activeOnly
	return r
}

// The keyword used to search on the network name and description fields
func (r ApiSearchNetworksRequest) Keyword(keyword string) ApiSearchNetworksRequest {
	r.keyword = &keyword
	return r
}

// Determines whether to only return applications that the user has access to
func (r ApiSearchNetworksRequest) FilterBillable(filterBillable bool) ApiSearchNetworksRequest {
	r.filterBillable = &filterBillable
	return r
}

func (r ApiSearchNetworksRequest) Execute() ([]ThirdPartyNetworkShortResponse, *http.Response, error) {
	return r.ApiService.SearchNetworksExecute(r)
}

/*
SearchNetworks Search Networks

Search on supported third party networks and custom networks from external users.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiSearchNetworksRequest
*/
func (a *ThirdPartyCredentialsAPIService) SearchNetworks(ctx context.Context, version float32) ApiSearchNetworksRequest {
	return ApiSearchNetworksRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return []ThirdPartyNetworkShortResponse
func (a *ThirdPartyCredentialsAPIService) SearchNetworksExecute(r ApiSearchNetworksRequest) ([]ThirdPartyNetworkShortResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ThirdPartyNetworkShortResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ThirdPartyCredentialsAPIService.SearchNetworks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/thirdparty/network/search"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.sortField == nil {
		return localVarReturnValue, nil, reportError("sortField is required and must be specified")
	}
	if r.descending == nil {
		return localVarReturnValue, nil, reportError("descending is required and must be specified")
	}
	if r.start == nil {
		return localVarReturnValue, nil, reportError("start is required and must be specified")
	}
	if r.limit == nil {
		return localVarReturnValue, nil, reportError("limit is required and must be specified")
	}
	if r.activeOnly == nil {
		return localVarReturnValue, nil, reportError("activeOnly is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	if r.keyword != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyword", r.keyword, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", r.sortField, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "activeOnly", r.activeOnly, "form", "")
	if r.filterBillable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filterBillable", r.filterBillable, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSendMFAChallengeRequest struct {
	ctx context.Context
	ApiService *ThirdPartyCredentialsAPIService
	version float32
	networkUID *string
	appKey *string
	thirdPartyToken *string
	thirdPartyCredentialId *int64
	deviceId *string
}

// the third party network provider that has MFA enabled
func (r ApiSendMFAChallengeRequest) NetworkUID(networkUID string) ApiSendMFAChallengeRequest {
	r.networkUID = &networkUID
	return r
}

// the application key
func (r ApiSendMFAChallengeRequest) AppKey(appKey string) ApiSendMFAChallengeRequest {
	r.appKey = &appKey
	return r
}

// the access token to authenticate with
func (r ApiSendMFAChallengeRequest) ThirdPartyToken(thirdPartyToken string) ApiSendMFAChallengeRequest {
	r.thirdPartyToken = &thirdPartyToken
	return r
}

// optional id of the existing third party credential
func (r ApiSendMFAChallengeRequest) ThirdPartyCredentialId(thirdPartyCredentialId int64) ApiSendMFAChallengeRequest {
	r.thirdPartyCredentialId = &thirdPartyCredentialId
	return r
}

// the unique id of the device making the request
func (r ApiSendMFAChallengeRequest) DeviceId(deviceId string) ApiSendMFAChallengeRequest {
	r.deviceId = &deviceId
	return r
}

func (r ApiSendMFAChallengeRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.SendMFAChallengeExecute(r)
}

/*
SendMFAChallenge Send MFA Challenge

Sends an MFA challenge (SMS or Email) for networks with MFA enabled.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiSendMFAChallengeRequest
*/
func (a *ThirdPartyCredentialsAPIService) SendMFAChallenge(ctx context.Context, version float32) ApiSendMFAChallengeRequest {
	return ApiSendMFAChallengeRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *ThirdPartyCredentialsAPIService) SendMFAChallengeExecute(r ApiSendMFAChallengeRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ThirdPartyCredentialsAPIService.SendMFAChallenge")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/thirdparty/credential/mfa/send"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.networkUID == nil {
		return localVarReturnValue, nil, reportError("networkUID is required and must be specified")
	}
	if r.appKey == nil {
		return localVarReturnValue, nil, reportError("appKey is required and must be specified")
	}

	if r.thirdPartyToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "thirdPartyToken", r.thirdPartyToken, "form", "")
	}
	if r.thirdPartyCredentialId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "thirdPartyCredentialId", r.thirdPartyCredentialId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "networkUID", r.networkUID, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateCredentialRequest struct {
	ctx context.Context
	ApiService *ThirdPartyCredentialsAPIService
	version float32
	networkUID *string
	thirdPartyId *string
	appKey *string
	deviceId *string
	thirdPartyName *string
	thirdPartyToken *string
	responseFilters *string
	metaData *string
	thirdPartyRefreshToken *string
}

// the access provider to authenticate against
func (r ApiUpdateCredentialRequest) NetworkUID(networkUID string) ApiUpdateCredentialRequest {
	r.networkUID = &networkUID
	return r
}

// the third party user account id
func (r ApiUpdateCredentialRequest) ThirdPartyId(thirdPartyId string) ApiUpdateCredentialRequest {
	r.thirdPartyId = &thirdPartyId
	return r
}

// the application key
func (r ApiUpdateCredentialRequest) AppKey(appKey string) ApiUpdateCredentialRequest {
	r.appKey = &appKey
	return r
}

// the unique id of the device making the request
func (r ApiUpdateCredentialRequest) DeviceId(deviceId string) ApiUpdateCredentialRequest {
	r.deviceId = &deviceId
	return r
}

// the third party user name
func (r ApiUpdateCredentialRequest) ThirdPartyName(thirdPartyName string) ApiUpdateCredentialRequest {
	r.thirdPartyName = &thirdPartyName
	return r
}

// the access token to authenticate with (ex: username or fb token)
func (r ApiUpdateCredentialRequest) ThirdPartyToken(thirdPartyToken string) ApiUpdateCredentialRequest {
	r.thirdPartyToken = &thirdPartyToken
	return r
}

// this determines how much of the profile should be returned, see ProfileFilters
func (r ApiUpdateCredentialRequest) ResponseFilters(responseFilters string) ApiUpdateCredentialRequest {
	r.responseFilters = &responseFilters
	return r
}

// External custom client defined data
func (r ApiUpdateCredentialRequest) MetaData(metaData string) ApiUpdateCredentialRequest {
	r.metaData = &metaData
	return r
}

// optional refresh token for the third party
func (r ApiUpdateCredentialRequest) ThirdPartyRefreshToken(thirdPartyRefreshToken string) ApiUpdateCredentialRequest {
	r.thirdPartyRefreshToken = &thirdPartyRefreshToken
	return r
}

func (r ApiUpdateCredentialRequest) Execute() (*ProfileResponse, *http.Response, error) {
	return r.ApiService.UpdateCredentialExecute(r)
}

/*
UpdateCredential Update Credential

Updates a third-party login for an account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiUpdateCredentialRequest
*/
func (a *ThirdPartyCredentialsAPIService) UpdateCredential(ctx context.Context, version float32) ApiUpdateCredentialRequest {
	return ApiUpdateCredentialRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return ProfileResponse
func (a *ThirdPartyCredentialsAPIService) UpdateCredentialExecute(r ApiUpdateCredentialRequest) (*ProfileResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProfileResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ThirdPartyCredentialsAPIService.UpdateCredential")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/thirdparty/credential/update"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.networkUID == nil {
		return localVarReturnValue, nil, reportError("networkUID is required and must be specified")
	}
	if r.thirdPartyId == nil {
		return localVarReturnValue, nil, reportError("thirdPartyId is required and must be specified")
	}
	if r.appKey == nil {
		return localVarReturnValue, nil, reportError("appKey is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "networkUID", r.networkUID, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "thirdPartyId", r.thirdPartyId, "form", "")
	if r.thirdPartyName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "thirdPartyName", r.thirdPartyName, "form", "")
	}
	if r.thirdPartyToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "thirdPartyToken", r.thirdPartyToken, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	if r.responseFilters != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "responseFilters", r.responseFilters, "form", "")
	}
	if r.metaData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metaData", r.metaData, "form", "")
	}
	if r.thirdPartyRefreshToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "thirdPartyRefreshToken", r.thirdPartyRefreshToken, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateNetworkRequest struct {
	ctx context.Context
	ApiService *ThirdPartyCredentialsAPIService
	version float32
	accountId *int64
	networkUID *string
	name *string
	description *string
	enableIntrospection *bool
	introspectionMethod *string
	introspectionURL *string
	introspectionParams *string
	requiredRootField *string
	enableMFA *bool
	sizeMFA *int32
	shelfLifeMFA *int32
	oauthTokenURL *string
	oauthPrivateKey *os.File
	oauthPublicKey *os.File
	oauthClientId *string
	oauthSecretKey *string
	body *string
}

// The account id making the request
func (r ApiUpdateNetworkRequest) AccountId(accountId int64) ApiUpdateNetworkRequest {
	r.accountId = &accountId
	return r
}

// The unique identifier for the third party network defined by Sirqul
func (r ApiUpdateNetworkRequest) NetworkUID(networkUID string) ApiUpdateNetworkRequest {
	r.networkUID = &networkUID
	return r
}

// The name of the network
func (r ApiUpdateNetworkRequest) Name(name string) ApiUpdateNetworkRequest {
	r.name = &name
	return r
}

// The description of the network
func (r ApiUpdateNetworkRequest) Description(description string) ApiUpdateNetworkRequest {
	r.description = &description
	return r
}

// Whether the network uses introspection calls
func (r ApiUpdateNetworkRequest) EnableIntrospection(enableIntrospection bool) ApiUpdateNetworkRequest {
	r.enableIntrospection = &enableIntrospection
	return r
}

// HTTP method to use for introspection calls (e.g., GET, POST)
func (r ApiUpdateNetworkRequest) IntrospectionMethod(introspectionMethod string) ApiUpdateNetworkRequest {
	r.introspectionMethod = &introspectionMethod
	return r
}

// The HTTP URL of the introspection call
func (r ApiUpdateNetworkRequest) IntrospectionURL(introspectionURL string) ApiUpdateNetworkRequest {
	r.introspectionURL = &introspectionURL
	return r
}

// The parameters of the introspection call
func (r ApiUpdateNetworkRequest) IntrospectionParams(introspectionParams string) ApiUpdateNetworkRequest {
	r.introspectionParams = &introspectionParams
	return r
}

// Required response params
func (r ApiUpdateNetworkRequest) RequiredRootField(requiredRootField string) ApiUpdateNetworkRequest {
	r.requiredRootField = &requiredRootField
	return r
}

// Whether this network uses MFA
func (r ApiUpdateNetworkRequest) EnableMFA(enableMFA bool) ApiUpdateNetworkRequest {
	r.enableMFA = &enableMFA
	return r
}

// Size of the MFA token
func (r ApiUpdateNetworkRequest) SizeMFA(sizeMFA int32) ApiUpdateNetworkRequest {
	r.sizeMFA = &sizeMFA
	return r
}

// Shelf life (seconds) of the MFA token
func (r ApiUpdateNetworkRequest) ShelfLifeMFA(shelfLifeMFA int32) ApiUpdateNetworkRequest {
	r.shelfLifeMFA = &shelfLifeMFA
	return r
}

// OAuth token endpoint URL
func (r ApiUpdateNetworkRequest) OauthTokenURL(oauthTokenURL string) ApiUpdateNetworkRequest {
	r.oauthTokenURL = &oauthTokenURL
	return r
}

// OAuth private key file (multipart)
func (r ApiUpdateNetworkRequest) OauthPrivateKey(oauthPrivateKey *os.File) ApiUpdateNetworkRequest {
	r.oauthPrivateKey = oauthPrivateKey
	return r
}

// OAuth public key file (multipart)
func (r ApiUpdateNetworkRequest) OauthPublicKey(oauthPublicKey *os.File) ApiUpdateNetworkRequest {
	r.oauthPublicKey = oauthPublicKey
	return r
}

// OAuth client id
func (r ApiUpdateNetworkRequest) OauthClientId(oauthClientId string) ApiUpdateNetworkRequest {
	r.oauthClientId = &oauthClientId
	return r
}

// OAuth secret key
func (r ApiUpdateNetworkRequest) OauthSecretKey(oauthSecretKey string) ApiUpdateNetworkRequest {
	r.oauthSecretKey = &oauthSecretKey
	return r
}

func (r ApiUpdateNetworkRequest) Body(body string) ApiUpdateNetworkRequest {
	r.body = &body
	return r
}

func (r ApiUpdateNetworkRequest) Execute() (*ThirdPartyNetworkResponse, *http.Response, error) {
	return r.ApiService.UpdateNetworkExecute(r)
}

/*
UpdateNetwork Update Network

Updates a custom third party network. Only the network owners and managers have access to this.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiUpdateNetworkRequest
*/
func (a *ThirdPartyCredentialsAPIService) UpdateNetwork(ctx context.Context, version float32) ApiUpdateNetworkRequest {
	return ApiUpdateNetworkRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return ThirdPartyNetworkResponse
func (a *ThirdPartyCredentialsAPIService) UpdateNetworkExecute(r ApiUpdateNetworkRequest) (*ThirdPartyNetworkResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ThirdPartyNetworkResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ThirdPartyCredentialsAPIService.UpdateNetwork")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/thirdparty/network/update"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.networkUID == nil {
		return localVarReturnValue, nil, reportError("networkUID is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "networkUID", r.networkUID, "form", "")
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "form", "")
	}
	if r.enableIntrospection != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableIntrospection", r.enableIntrospection, "form", "")
	}
	if r.introspectionMethod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "introspectionMethod", r.introspectionMethod, "form", "")
	}
	if r.introspectionURL != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "introspectionURL", r.introspectionURL, "form", "")
	}
	if r.introspectionParams != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "introspectionParams", r.introspectionParams, "form", "")
	}
	if r.requiredRootField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "requiredRootField", r.requiredRootField, "form", "")
	}
	if r.enableMFA != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableMFA", r.enableMFA, "form", "")
	}
	if r.sizeMFA != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sizeMFA", r.sizeMFA, "form", "")
	}
	if r.shelfLifeMFA != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "shelfLifeMFA", r.shelfLifeMFA, "form", "")
	}
	if r.oauthTokenURL != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "oauthTokenURL", r.oauthTokenURL, "form", "")
	}
	if r.oauthPrivateKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "oauthPrivateKey", r.oauthPrivateKey, "form", "")
	}
	if r.oauthPublicKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "oauthPublicKey", r.oauthPublicKey, "form", "")
	}
	if r.oauthClientId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "oauthClientId", r.oauthClientId, "form", "")
	}
	if r.oauthSecretKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "oauthSecretKey", r.oauthSecretKey, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
