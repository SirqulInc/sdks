/*
Sirqul IoT Platform

Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

API version: 3.16
Contact: info@sirqul.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// BillingInfoAPIService BillingInfoAPI service
type BillingInfoAPIService service

type ApiAddPaymentMethodRequest struct {
	ctx context.Context
	ApiService *BillingInfoAPIService
	accountId *int64
	paymentMethodId *int64
	accountName *string
	firstName *string
	lastName *string
	address *string
	city *string
	state *string
	postalCode *string
	country *string
	phone *string
	creditCardNumber *string
	expirationDate *string
	ccv *string
	accountNumber *string
	bankName *string
	routingNumber *string
	defaultPaymentMethod *bool
	paymentMethodNickname *string
	taxId *string
	providerCustomerProfileId *string
	providerPaymentProfileId *string
	metaData *string
}

// The account used to perform the the request
func (r ApiAddPaymentMethodRequest) AccountId(accountId int64) ApiAddPaymentMethodRequest {
	r.accountId = &accountId
	return r
}

// Payment Method Id
func (r ApiAddPaymentMethodRequest) PaymentMethodId(paymentMethodId int64) ApiAddPaymentMethodRequest {
	r.paymentMethodId = &paymentMethodId
	return r
}

// the name of the account
func (r ApiAddPaymentMethodRequest) AccountName(accountName string) ApiAddPaymentMethodRequest {
	r.accountName = &accountName
	return r
}

// First Name that the account is filed as
func (r ApiAddPaymentMethodRequest) FirstName(firstName string) ApiAddPaymentMethodRequest {
	r.firstName = &firstName
	return r
}

// Last Name that the account is filed as
func (r ApiAddPaymentMethodRequest) LastName(lastName string) ApiAddPaymentMethodRequest {
	r.lastName = &lastName
	return r
}

// Address that the account is filed as
func (r ApiAddPaymentMethodRequest) Address(address string) ApiAddPaymentMethodRequest {
	r.address = &address
	return r
}

// City that the account is filed as
func (r ApiAddPaymentMethodRequest) City(city string) ApiAddPaymentMethodRequest {
	r.city = &city
	return r
}

// State that the account is filed as
func (r ApiAddPaymentMethodRequest) State(state string) ApiAddPaymentMethodRequest {
	r.state = &state
	return r
}

// Postal Code that the account is filed as
func (r ApiAddPaymentMethodRequest) PostalCode(postalCode string) ApiAddPaymentMethodRequest {
	r.postalCode = &postalCode
	return r
}

// Country that the account is filed as
func (r ApiAddPaymentMethodRequest) Country(country string) ApiAddPaymentMethodRequest {
	r.country = &country
	return r
}

// Phone that the account is filed as
func (r ApiAddPaymentMethodRequest) Phone(phone string) ApiAddPaymentMethodRequest {
	r.phone = &phone
	return r
}

// The full credit card number to store on file
func (r ApiAddPaymentMethodRequest) CreditCardNumber(creditCardNumber string) ApiAddPaymentMethodRequest {
	r.creditCardNumber = &creditCardNumber
	return r
}

// The credit card expiration date YYYY-MM
func (r ApiAddPaymentMethodRequest) ExpirationDate(expirationDate string) ApiAddPaymentMethodRequest {
	r.expirationDate = &expirationDate
	return r
}

// The 3 digit confirmation code
func (r ApiAddPaymentMethodRequest) Ccv(ccv string) ApiAddPaymentMethodRequest {
	r.ccv = &ccv
	return r
}

// The bank account number
func (r ApiAddPaymentMethodRequest) AccountNumber(accountNumber string) ApiAddPaymentMethodRequest {
	r.accountNumber = &accountNumber
	return r
}

// The bank name
func (r ApiAddPaymentMethodRequest) BankName(bankName string) ApiAddPaymentMethodRequest {
	r.bankName = &bankName
	return r
}

// Routing Number
func (r ApiAddPaymentMethodRequest) RoutingNumber(routingNumber string) ApiAddPaymentMethodRequest {
	r.routingNumber = &routingNumber
	return r
}

// Default Payment Method
func (r ApiAddPaymentMethodRequest) DefaultPaymentMethod(defaultPaymentMethod bool) ApiAddPaymentMethodRequest {
	r.defaultPaymentMethod = &defaultPaymentMethod
	return r
}

// Payment Method Nickname
func (r ApiAddPaymentMethodRequest) PaymentMethodNickname(paymentMethodNickname string) ApiAddPaymentMethodRequest {
	r.paymentMethodNickname = &paymentMethodNickname
	return r
}

// Tax Id
func (r ApiAddPaymentMethodRequest) TaxId(taxId string) ApiAddPaymentMethodRequest {
	r.taxId = &taxId
	return r
}

// Provider customer profile Id
func (r ApiAddPaymentMethodRequest) ProviderCustomerProfileId(providerCustomerProfileId string) ApiAddPaymentMethodRequest {
	r.providerCustomerProfileId = &providerCustomerProfileId
	return r
}

// Provider customer payment profile Id
func (r ApiAddPaymentMethodRequest) ProviderPaymentProfileId(providerPaymentProfileId string) ApiAddPaymentMethodRequest {
	r.providerPaymentProfileId = &providerPaymentProfileId
	return r
}

// Meta Data
func (r ApiAddPaymentMethodRequest) MetaData(metaData string) ApiAddPaymentMethodRequest {
	r.metaData = &metaData
	return r
}

func (r ApiAddPaymentMethodRequest) Execute() (*PaymentTypesResponse, *http.Response, error) {
	return r.ApiService.AddPaymentMethodExecute(r)
}

/*
AddPaymentMethod Update Payment Method

Update a method of payment. If the paymentMethodId is not passed in then will update their default payment method.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAddPaymentMethodRequest
*/
func (a *BillingInfoAPIService) AddPaymentMethod(ctx context.Context) ApiAddPaymentMethodRequest {
	return ApiAddPaymentMethodRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaymentTypesResponse
func (a *BillingInfoAPIService) AddPaymentMethodExecute(r ApiAddPaymentMethodRequest) (*PaymentTypesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaymentTypesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingInfoAPIService.AddPaymentMethod")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/billing/update"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	if r.paymentMethodId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paymentMethodId", r.paymentMethodId, "form", "")
	}
	if r.accountName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountName", r.accountName, "form", "")
	}
	if r.firstName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "firstName", r.firstName, "form", "")
	}
	if r.lastName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastName", r.lastName, "form", "")
	}
	if r.address != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "address", r.address, "form", "")
	}
	if r.city != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "city", r.city, "form", "")
	}
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "form", "")
	}
	if r.postalCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "postalCode", r.postalCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.phone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "phone", r.phone, "form", "")
	}
	if r.creditCardNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creditCardNumber", r.creditCardNumber, "form", "")
	}
	if r.expirationDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expirationDate", r.expirationDate, "form", "")
	}
	if r.ccv != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ccv", r.ccv, "form", "")
	}
	if r.accountNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountNumber", r.accountNumber, "form", "")
	}
	if r.bankName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bankName", r.bankName, "form", "")
	}
	if r.routingNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routingNumber", r.routingNumber, "form", "")
	}
	if r.defaultPaymentMethod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "defaultPaymentMethod", r.defaultPaymentMethod, "form", "")
	}
	if r.paymentMethodNickname != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paymentMethodNickname", r.paymentMethodNickname, "form", "")
	}
	if r.taxId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "taxId", r.taxId, "form", "")
	}
	if r.providerCustomerProfileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "providerCustomerProfileId", r.providerCustomerProfileId, "form", "")
	}
	if r.providerPaymentProfileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "providerPaymentProfileId", r.providerPaymentProfileId, "form", "")
	}
	if r.metaData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metaData", r.metaData, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreatePaymentMethodRequest struct {
	ctx context.Context
	ApiService *BillingInfoAPIService
	accountId *int64
	accountName *string
	firstName *string
	lastName *string
	address *string
	city *string
	state *string
	postalCode *string
	country *string
	phone *string
	creditCardNumber *string
	expirationDate *string
	ccv *string
	accountNumber *string
	bankName *string
	routingNumber *string
	paymentMethodNickname *string
	taxId *string
	defaultPaymentMethod *bool
	authToken *string
	provider *string
	providerCustomerProfileId *string
	providerPaymentProfileId *string
	metaData *string
	appKey *string
}

// The account used to perform the the request
func (r ApiCreatePaymentMethodRequest) AccountId(accountId int64) ApiCreatePaymentMethodRequest {
	r.accountId = &accountId
	return r
}

// Account Name of the credit card user
func (r ApiCreatePaymentMethodRequest) AccountName(accountName string) ApiCreatePaymentMethodRequest {
	r.accountName = &accountName
	return r
}

// The first name on the credit card
func (r ApiCreatePaymentMethodRequest) FirstName(firstName string) ApiCreatePaymentMethodRequest {
	r.firstName = &firstName
	return r
}

// The last name on the credit card
func (r ApiCreatePaymentMethodRequest) LastName(lastName string) ApiCreatePaymentMethodRequest {
	r.lastName = &lastName
	return r
}

// The billing address of the credit card
func (r ApiCreatePaymentMethodRequest) Address(address string) ApiCreatePaymentMethodRequest {
	r.address = &address
	return r
}

// The billing city of the credit card
func (r ApiCreatePaymentMethodRequest) City(city string) ApiCreatePaymentMethodRequest {
	r.city = &city
	return r
}

// The billing state of the credit card
func (r ApiCreatePaymentMethodRequest) State(state string) ApiCreatePaymentMethodRequest {
	r.state = &state
	return r
}

// The billing zip code of the credit card
func (r ApiCreatePaymentMethodRequest) PostalCode(postalCode string) ApiCreatePaymentMethodRequest {
	r.postalCode = &postalCode
	return r
}

// Country of the credit card
func (r ApiCreatePaymentMethodRequest) Country(country string) ApiCreatePaymentMethodRequest {
	r.country = &country
	return r
}

// The billing phone of the credit card
func (r ApiCreatePaymentMethodRequest) Phone(phone string) ApiCreatePaymentMethodRequest {
	r.phone = &phone
	return r
}

// The full credit card number to store on file
func (r ApiCreatePaymentMethodRequest) CreditCardNumber(creditCardNumber string) ApiCreatePaymentMethodRequest {
	r.creditCardNumber = &creditCardNumber
	return r
}

// The credit card expiration date YYYY-MM
func (r ApiCreatePaymentMethodRequest) ExpirationDate(expirationDate string) ApiCreatePaymentMethodRequest {
	r.expirationDate = &expirationDate
	return r
}

// The 3 digit confirmation code
func (r ApiCreatePaymentMethodRequest) Ccv(ccv string) ApiCreatePaymentMethodRequest {
	r.ccv = &ccv
	return r
}

// The bank account number
func (r ApiCreatePaymentMethodRequest) AccountNumber(accountNumber string) ApiCreatePaymentMethodRequest {
	r.accountNumber = &accountNumber
	return r
}

// The bank name
func (r ApiCreatePaymentMethodRequest) BankName(bankName string) ApiCreatePaymentMethodRequest {
	r.bankName = &bankName
	return r
}

// The bank routing number
func (r ApiCreatePaymentMethodRequest) RoutingNumber(routingNumber string) ApiCreatePaymentMethodRequest {
	r.routingNumber = &routingNumber
	return r
}

// The nickname to give the payment method
func (r ApiCreatePaymentMethodRequest) PaymentMethodNickname(paymentMethodNickname string) ApiCreatePaymentMethodRequest {
	r.paymentMethodNickname = &paymentMethodNickname
	return r
}

// Tax Id
func (r ApiCreatePaymentMethodRequest) TaxId(taxId string) ApiCreatePaymentMethodRequest {
	r.taxId = &taxId
	return r
}

// Whether this should be the default payment method
func (r ApiCreatePaymentMethodRequest) DefaultPaymentMethod(defaultPaymentMethod bool) ApiCreatePaymentMethodRequest {
	r.defaultPaymentMethod = &defaultPaymentMethod
	return r
}

// An authorization token for providers that provide this (like Amazon Payments)
func (r ApiCreatePaymentMethodRequest) AuthToken(authToken string) ApiCreatePaymentMethodRequest {
	r.authToken = &authToken
	return r
}

// The payment provider (see PaymentMethodProvider)
func (r ApiCreatePaymentMethodRequest) Provider(provider string) ApiCreatePaymentMethodRequest {
	r.provider = &provider
	return r
}

// Provider customer profile Id
func (r ApiCreatePaymentMethodRequest) ProviderCustomerProfileId(providerCustomerProfileId string) ApiCreatePaymentMethodRequest {
	r.providerCustomerProfileId = &providerCustomerProfileId
	return r
}

// Provider customer payment profile Id
func (r ApiCreatePaymentMethodRequest) ProviderPaymentProfileId(providerPaymentProfileId string) ApiCreatePaymentMethodRequest {
	r.providerPaymentProfileId = &providerPaymentProfileId
	return r
}

// Meta Data
func (r ApiCreatePaymentMethodRequest) MetaData(metaData string) ApiCreatePaymentMethodRequest {
	r.metaData = &metaData
	return r
}

// Application Key
func (r ApiCreatePaymentMethodRequest) AppKey(appKey string) ApiCreatePaymentMethodRequest {
	r.appKey = &appKey
	return r
}

func (r ApiCreatePaymentMethodRequest) Execute() (*PaymentTypesResponse, *http.Response, error) {
	return r.ApiService.CreatePaymentMethodExecute(r)
}

/*
CreatePaymentMethod Create Payment Method

Add a new method of payment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreatePaymentMethodRequest
*/
func (a *BillingInfoAPIService) CreatePaymentMethod(ctx context.Context) ApiCreatePaymentMethodRequest {
	return ApiCreatePaymentMethodRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaymentTypesResponse
func (a *BillingInfoAPIService) CreatePaymentMethodExecute(r ApiCreatePaymentMethodRequest) (*PaymentTypesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaymentTypesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingInfoAPIService.CreatePaymentMethod")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/billing/create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	if r.accountName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountName", r.accountName, "form", "")
	}
	if r.firstName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "firstName", r.firstName, "form", "")
	}
	if r.lastName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastName", r.lastName, "form", "")
	}
	if r.address != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "address", r.address, "form", "")
	}
	if r.city != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "city", r.city, "form", "")
	}
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "form", "")
	}
	if r.postalCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "postalCode", r.postalCode, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	if r.phone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "phone", r.phone, "form", "")
	}
	if r.creditCardNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creditCardNumber", r.creditCardNumber, "form", "")
	}
	if r.expirationDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expirationDate", r.expirationDate, "form", "")
	}
	if r.ccv != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ccv", r.ccv, "form", "")
	}
	if r.accountNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountNumber", r.accountNumber, "form", "")
	}
	if r.bankName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bankName", r.bankName, "form", "")
	}
	if r.routingNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routingNumber", r.routingNumber, "form", "")
	}
	if r.paymentMethodNickname != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paymentMethodNickname", r.paymentMethodNickname, "form", "")
	}
	if r.taxId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "taxId", r.taxId, "form", "")
	}
	if r.defaultPaymentMethod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "defaultPaymentMethod", r.defaultPaymentMethod, "form", "")
	} else {
		var defaultValue bool = true
		parameterAddToHeaderOrQuery(localVarQueryParams, "defaultPaymentMethod", defaultValue, "form", "")
		r.defaultPaymentMethod = &defaultValue
	}
	if r.authToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "authToken", r.authToken, "form", "")
	}
	if r.provider != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "provider", r.provider, "form", "")
	} else {
		var defaultValue string = "AUTHORIZE_NET"
		parameterAddToHeaderOrQuery(localVarQueryParams, "provider", defaultValue, "form", "")
		r.provider = &defaultValue
	}
	if r.providerCustomerProfileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "providerCustomerProfileId", r.providerCustomerProfileId, "form", "")
	}
	if r.providerPaymentProfileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "providerPaymentProfileId", r.providerPaymentProfileId, "form", "")
	}
	if r.metaData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metaData", r.metaData, "form", "")
	}
	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateSmartContractRequest struct {
	ctx context.Context
	ApiService *BillingInfoAPIService
	accountId *int64
	tokenName *string
	tokenSymbol *string
	paymentMethodId *int64
}

// The account used to perform the the request
func (r ApiCreateSmartContractRequest) AccountId(accountId int64) ApiCreateSmartContractRequest {
	r.accountId = &accountId
	return r
}

// The token name
func (r ApiCreateSmartContractRequest) TokenName(tokenName string) ApiCreateSmartContractRequest {
	r.tokenName = &tokenName
	return r
}

// The token symbol
func (r ApiCreateSmartContractRequest) TokenSymbol(tokenSymbol string) ApiCreateSmartContractRequest {
	r.tokenSymbol = &tokenSymbol
	return r
}

// The payment method to return details on. If this is not set, then the user&#39;s default payment method will be returned.
func (r ApiCreateSmartContractRequest) PaymentMethodId(paymentMethodId int64) ApiCreateSmartContractRequest {
	r.paymentMethodId = &paymentMethodId
	return r
}

func (r ApiCreateSmartContractRequest) Execute() (*PaymentTypesResponse, *http.Response, error) {
	return r.ApiService.CreateSmartContractExecute(r)
}

/*
CreateSmartContract Create Smart Contract

Adds a smart contract.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateSmartContractRequest
*/
func (a *BillingInfoAPIService) CreateSmartContract(ctx context.Context) ApiCreateSmartContractRequest {
	return ApiCreateSmartContractRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaymentTypesResponse
func (a *BillingInfoAPIService) CreateSmartContractExecute(r ApiCreateSmartContractRequest) (*PaymentTypesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaymentTypesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingInfoAPIService.CreateSmartContract")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/billing/crypto/transfer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.tokenName == nil {
		return localVarReturnValue, nil, reportError("tokenName is required and must be specified")
	}
	if r.tokenSymbol == nil {
		return localVarReturnValue, nil, reportError("tokenSymbol is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	if r.paymentMethodId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paymentMethodId", r.paymentMethodId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "tokenName", r.tokenName, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "tokenSymbol", r.tokenSymbol, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCryptoBalanceRequest struct {
	ctx context.Context
	ApiService *BillingInfoAPIService
	accountId *int64
	ownerAccountId *int64
	paymentMethodId *int64
}

// The account used to perform the the request
func (r ApiGetCryptoBalanceRequest) AccountId(accountId int64) ApiGetCryptoBalanceRequest {
	r.accountId = &accountId
	return r
}

// The account to retreive balances for
func (r ApiGetCryptoBalanceRequest) OwnerAccountId(ownerAccountId int64) ApiGetCryptoBalanceRequest {
	r.ownerAccountId = &ownerAccountId
	return r
}

// The payment method to return details on. If this is not set, then the user&#39;s default payment method will be returned.
func (r ApiGetCryptoBalanceRequest) PaymentMethodId(paymentMethodId int64) ApiGetCryptoBalanceRequest {
	r.paymentMethodId = &paymentMethodId
	return r
}

func (r ApiGetCryptoBalanceRequest) Execute() (*PaymentTypesResponse, *http.Response, error) {
	return r.ApiService.GetCryptoBalanceExecute(r)
}

/*
GetCryptoBalance Get Crypto Balances

Get the cypto balance details for a user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCryptoBalanceRequest
*/
func (a *BillingInfoAPIService) GetCryptoBalance(ctx context.Context) ApiGetCryptoBalanceRequest {
	return ApiGetCryptoBalanceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaymentTypesResponse
func (a *BillingInfoAPIService) GetCryptoBalanceExecute(r ApiGetCryptoBalanceRequest) (*PaymentTypesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaymentTypesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingInfoAPIService.GetCryptoBalance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/billing/crypto/get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	if r.ownerAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ownerAccountId", r.ownerAccountId, "form", "")
	}
	if r.paymentMethodId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paymentMethodId", r.paymentMethodId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPaymentMethodRequest struct {
	ctx context.Context
	ApiService *BillingInfoAPIService
	accountId *int64
	paymentMethodId *int64
	getCurrentBalance *bool
}

// The account used to perform the the request
func (r ApiGetPaymentMethodRequest) AccountId(accountId int64) ApiGetPaymentMethodRequest {
	r.accountId = &accountId
	return r
}

// The payment method to return details on. If this is not set, then the user&#39;s default payment method will be returned.
func (r ApiGetPaymentMethodRequest) PaymentMethodId(paymentMethodId int64) ApiGetPaymentMethodRequest {
	r.paymentMethodId = &paymentMethodId
	return r
}

// Determines whether to get the user&#39;s current balance for the requested payment method option (not all payment method options support this)
func (r ApiGetPaymentMethodRequest) GetCurrentBalance(getCurrentBalance bool) ApiGetPaymentMethodRequest {
	r.getCurrentBalance = &getCurrentBalance
	return r
}

func (r ApiGetPaymentMethodRequest) Execute() (*PaymentTypesResponse, *http.Response, error) {
	return r.ApiService.GetPaymentMethodExecute(r)
}

/*
GetPaymentMethod Get Payment Method

Get the details of the user's payment method or their current default method of payment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetPaymentMethodRequest
*/
func (a *BillingInfoAPIService) GetPaymentMethod(ctx context.Context) ApiGetPaymentMethodRequest {
	return ApiGetPaymentMethodRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaymentTypesResponse
func (a *BillingInfoAPIService) GetPaymentMethodExecute(r ApiGetPaymentMethodRequest) (*PaymentTypesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaymentTypesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingInfoAPIService.GetPaymentMethod")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/billing/get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	if r.paymentMethodId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paymentMethodId", r.paymentMethodId, "form", "")
	}
	if r.getCurrentBalance != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "getCurrentBalance", r.getCurrentBalance, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchPaymentMethodRequest struct {
	ctx context.Context
	ApiService *BillingInfoAPIService
	accountId *int64
	provider *string
	type_ *string
	keyword *string
	sortField *string
	descending *bool
	start *int32
	limit *int32
}

// Account Id to search on
func (r ApiSearchPaymentMethodRequest) AccountId(accountId int64) ApiSearchPaymentMethodRequest {
	r.accountId = &accountId
	return r
}

// Provider to search on
func (r ApiSearchPaymentMethodRequest) Provider(provider string) ApiSearchPaymentMethodRequest {
	r.provider = &provider
	return r
}

// the type to search on
func (r ApiSearchPaymentMethodRequest) Type_(type_ string) ApiSearchPaymentMethodRequest {
	r.type_ = &type_
	return r
}

// the keyword to search on
func (r ApiSearchPaymentMethodRequest) Keyword(keyword string) ApiSearchPaymentMethodRequest {
	r.keyword = &keyword
	return r
}

// the sort field to use for the search
func (r ApiSearchPaymentMethodRequest) SortField(sortField string) ApiSearchPaymentMethodRequest {
	r.sortField = &sortField
	return r
}

// if the results should be in descending order
func (r ApiSearchPaymentMethodRequest) Descending(descending bool) ApiSearchPaymentMethodRequest {
	r.descending = &descending
	return r
}

// the start of the search
func (r ApiSearchPaymentMethodRequest) Start(start int32) ApiSearchPaymentMethodRequest {
	r.start = &start
	return r
}

// the limit of the search
func (r ApiSearchPaymentMethodRequest) Limit(limit int32) ApiSearchPaymentMethodRequest {
	r.limit = &limit
	return r
}

func (r ApiSearchPaymentMethodRequest) Execute() (*PaymentTypesResponse, *http.Response, error) {
	return r.ApiService.SearchPaymentMethodExecute(r)
}

/*
SearchPaymentMethod Search Payment Methods

Search the payment methods of an account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchPaymentMethodRequest
*/
func (a *BillingInfoAPIService) SearchPaymentMethod(ctx context.Context) ApiSearchPaymentMethodRequest {
	return ApiSearchPaymentMethodRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaymentTypesResponse
func (a *BillingInfoAPIService) SearchPaymentMethodExecute(r ApiSearchPaymentMethodRequest) (*PaymentTypesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaymentTypesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingInfoAPIService.SearchPaymentMethod")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/billing/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	if r.provider != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "provider", r.provider, "form", "")
	} else {
		var defaultValue string = "AUTHORIZE_NET"
		parameterAddToHeaderOrQuery(localVarQueryParams, "provider", defaultValue, "form", "")
		r.provider = &defaultValue
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.keyword != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyword", r.keyword, "form", "")
	}
	if r.sortField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", r.sortField, "form", "")
	} else {
		var defaultValue string = "UPDATED"
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", defaultValue, "form", "")
		r.sortField = &defaultValue
	}
	if r.descending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "form", "")
	} else {
		var defaultValue bool = true
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", defaultValue, "form", "")
		r.descending = &defaultValue
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	} else {
		var defaultValue int32 = 0
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", defaultValue, "form", "")
		r.start = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 5
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
