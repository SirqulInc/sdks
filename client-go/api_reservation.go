/*
Sirqul IoT Platform

Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

API version: 3.16
Contact: info@sirqul.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// ReservationAPIService ReservationAPI service
type ReservationAPIService service

type ApiCreateReservationRequest struct {
	ctx context.Context
	ApiService *ReservationAPIService
	version float32
	deviceId *string
	accountId *int64
	startDate *int64
	endDate *int64
	offerId *int64
	offerLocationId *int64
	appKey *string
	metaData *string
}

// The device id (deviceId or accountId required)
func (r ApiCreateReservationRequest) DeviceId(deviceId string) ApiCreateReservationRequest {
	r.deviceId = &deviceId
	return r
}

// The account id of the user (deviceId or accountId required)
func (r ApiCreateReservationRequest) AccountId(accountId int64) ApiCreateReservationRequest {
	r.accountId = &accountId
	return r
}

// The start date
func (r ApiCreateReservationRequest) StartDate(startDate int64) ApiCreateReservationRequest {
	r.startDate = &startDate
	return r
}

// The end date
func (r ApiCreateReservationRequest) EndDate(endDate int64) ApiCreateReservationRequest {
	r.endDate = &endDate
	return r
}

// The id of the offer being added (offerId or offeLocationId required)
func (r ApiCreateReservationRequest) OfferId(offerId int64) ApiCreateReservationRequest {
	r.offerId = &offerId
	return r
}

// The id of the offer location being added (offerId or offeLocationId required)
func (r ApiCreateReservationRequest) OfferLocationId(offerLocationId int64) ApiCreateReservationRequest {
	r.offerLocationId = &offerLocationId
	return r
}

// The application requesting the reservation
func (r ApiCreateReservationRequest) AppKey(appKey string) ApiCreateReservationRequest {
	r.appKey = &appKey
	return r
}

// External custom client defined data
func (r ApiCreateReservationRequest) MetaData(metaData string) ApiCreateReservationRequest {
	r.metaData = &metaData
	return r
}

func (r ApiCreateReservationRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateReservationExecute(r)
}

/*
CreateReservation Create Reservation

Creates a reservation on an offer object

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiCreateReservationRequest
*/
func (a *ReservationAPIService) CreateReservation(ctx context.Context, version float32) ApiCreateReservationRequest {
	return ApiCreateReservationRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
func (a *ReservationAPIService) CreateReservationExecute(r ApiCreateReservationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationAPIService.CreateReservation")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/reservation/create"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "form", "")
	}
	if r.offerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offerId", r.offerId, "form", "")
	}
	if r.offerLocationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offerLocationId", r.offerLocationId, "form", "")
	}
	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	if r.metaData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metaData", r.metaData, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteReservationRequest struct {
	ctx context.Context
	ApiService *ReservationAPIService
	version float32
	reservationId *int64
	deviceId *string
	accountId *int64
}

// The reservation id
func (r ApiDeleteReservationRequest) ReservationId(reservationId int64) ApiDeleteReservationRequest {
	r.reservationId = &reservationId
	return r
}

// The device id (deviceId or accountId required)
func (r ApiDeleteReservationRequest) DeviceId(deviceId string) ApiDeleteReservationRequest {
	r.deviceId = &deviceId
	return r
}

// The account id of the user (deviceId or accountId required)
func (r ApiDeleteReservationRequest) AccountId(accountId int64) ApiDeleteReservationRequest {
	r.accountId = &accountId
	return r
}

func (r ApiDeleteReservationRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteReservationExecute(r)
}

/*
DeleteReservation Delete Reservation

Deleted a reservation on a reservation object

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiDeleteReservationRequest
*/
func (a *ReservationAPIService) DeleteReservation(ctx context.Context, version float32) ApiDeleteReservationRequest {
	return ApiDeleteReservationRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
func (a *ReservationAPIService) DeleteReservationExecute(r ApiDeleteReservationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationAPIService.DeleteReservation")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/reservation/delete"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.reservationId == nil {
		return nil, reportError("reservationId is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "reservationId", r.reservationId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiReservableAvailabilityRequest struct {
	ctx context.Context
	ApiService *ReservationAPIService
	version float32
	reservableId *int64
	reservableType *string
	deviceId *string
	accountId *int64
	availability *string
	availabilitySummary *string
}

// the id of the reservation
func (r ApiReservableAvailabilityRequest) ReservableId(reservableId int64) ApiReservableAvailabilityRequest {
	r.reservableId = &reservableId
	return r
}

// the type of reservation
func (r ApiReservableAvailabilityRequest) ReservableType(reservableType string) ApiReservableAvailabilityRequest {
	r.reservableType = &reservableType
	return r
}

// the device id of the reservation
func (r ApiReservableAvailabilityRequest) DeviceId(deviceId string) ApiReservableAvailabilityRequest {
	r.deviceId = &deviceId
	return r
}

// the id of the logged in user
func (r ApiReservableAvailabilityRequest) AccountId(accountId int64) ApiReservableAvailabilityRequest {
	r.accountId = &accountId
	return r
}

// Availability
func (r ApiReservableAvailabilityRequest) Availability(availability string) ApiReservableAvailabilityRequest {
	r.availability = &availability
	return r
}

// Availability Summary
func (r ApiReservableAvailabilityRequest) AvailabilitySummary(availabilitySummary string) ApiReservableAvailabilityRequest {
	r.availabilitySummary = &availabilitySummary
	return r
}

func (r ApiReservableAvailabilityRequest) Execute() ([]AvailabilityResponse, *http.Response, error) {
	return r.ApiService.ReservableAvailabilityExecute(r)
}

/*
ReservableAvailability Update Availability

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiReservableAvailabilityRequest
*/
func (a *ReservationAPIService) ReservableAvailability(ctx context.Context, version float32) ApiReservableAvailabilityRequest {
	return ApiReservableAvailabilityRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return []AvailabilityResponse
func (a *ReservationAPIService) ReservableAvailabilityExecute(r ApiReservableAvailabilityRequest) ([]AvailabilityResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []AvailabilityResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationAPIService.ReservableAvailability")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/reservable/availability/update"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.reservableId == nil {
		return localVarReturnValue, nil, reportError("reservableId is required and must be specified")
	}
	if r.reservableType == nil {
		return localVarReturnValue, nil, reportError("reservableType is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "reservableId", r.reservableId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "reservableType", r.reservableType, "form", "")
	if r.availability != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "availability", r.availability, "form", "")
	}
	if r.availabilitySummary != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "availabilitySummary", r.availabilitySummary, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchAvailabilityRequest struct {
	ctx context.Context
	ApiService *ReservationAPIService
	version float32
	reservableId *int64
	reservableType *string
	deviceId *string
	accountId *int64
	startDate *int64
	endDate *int64
	start *int32
	limit *int32
}

// the id of the reservation
func (r ApiSearchAvailabilityRequest) ReservableId(reservableId int64) ApiSearchAvailabilityRequest {
	r.reservableId = &reservableId
	return r
}

// the reservable type
func (r ApiSearchAvailabilityRequest) ReservableType(reservableType string) ApiSearchAvailabilityRequest {
	r.reservableType = &reservableType
	return r
}

// the device ID that the reservation is on
func (r ApiSearchAvailabilityRequest) DeviceId(deviceId string) ApiSearchAvailabilityRequest {
	r.deviceId = &deviceId
	return r
}

// the id of the logged in user
func (r ApiSearchAvailabilityRequest) AccountId(accountId int64) ApiSearchAvailabilityRequest {
	r.accountId = &accountId
	return r
}

// the start date of the reservation
func (r ApiSearchAvailabilityRequest) StartDate(startDate int64) ApiSearchAvailabilityRequest {
	r.startDate = &startDate
	return r
}

// the end date of the reservation
func (r ApiSearchAvailabilityRequest) EndDate(endDate int64) ApiSearchAvailabilityRequest {
	r.endDate = &endDate
	return r
}

// the start of the index and/or pagination
func (r ApiSearchAvailabilityRequest) Start(start int32) ApiSearchAvailabilityRequest {
	r.start = &start
	return r
}

// the limit of the index and/or pagination
func (r ApiSearchAvailabilityRequest) Limit(limit int32) ApiSearchAvailabilityRequest {
	r.limit = &limit
	return r
}

func (r ApiSearchAvailabilityRequest) Execute() ([]AvailabilityResponse, *http.Response, error) {
	return r.ApiService.SearchAvailabilityExecute(r)
}

/*
SearchAvailability Search Availability

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiSearchAvailabilityRequest
*/
func (a *ReservationAPIService) SearchAvailability(ctx context.Context, version float32) ApiSearchAvailabilityRequest {
	return ApiSearchAvailabilityRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return []AvailabilityResponse
func (a *ReservationAPIService) SearchAvailabilityExecute(r ApiSearchAvailabilityRequest) ([]AvailabilityResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []AvailabilityResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationAPIService.SearchAvailability")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/reservable/availability/search"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.reservableId == nil {
		return localVarReturnValue, nil, reportError("reservableId is required and must be specified")
	}
	if r.reservableType == nil {
		return localVarReturnValue, nil, reportError("reservableType is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "reservableId", r.reservableId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "reservableType", r.reservableType, "form", "")
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "form", "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	} else {
		var defaultValue int32 = 0
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", defaultValue, "form", "")
		r.start = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 100
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchReservationsRequest struct {
	ctx context.Context
	ApiService *ReservationAPIService
	version float32
	deviceId *string
	appKey *string
	accountId *int64
	filterAccountId *int64
	reservableId *int64
	reservableType *string
	keyword *string
	startDate *int64
	endDate *int64
	start *int32
	limit *int32
}

// Device Id
func (r ApiSearchReservationsRequest) DeviceId(deviceId string) ApiSearchReservationsRequest {
	r.deviceId = &deviceId
	return r
}

// Appilcation Key
func (r ApiSearchReservationsRequest) AppKey(appKey string) ApiSearchReservationsRequest {
	r.appKey = &appKey
	return r
}

// the id of the logged in user
func (r ApiSearchReservationsRequest) AccountId(accountId int64) ApiSearchReservationsRequest {
	r.accountId = &accountId
	return r
}

// filter reservations by account ID
func (r ApiSearchReservationsRequest) FilterAccountId(filterAccountId int64) ApiSearchReservationsRequest {
	r.filterAccountId = &filterAccountId
	return r
}

// the reservation ID
func (r ApiSearchReservationsRequest) ReservableId(reservableId int64) ApiSearchReservationsRequest {
	r.reservableId = &reservableId
	return r
}

// the type of reservation
func (r ApiSearchReservationsRequest) ReservableType(reservableType string) ApiSearchReservationsRequest {
	r.reservableType = &reservableType
	return r
}

// the keyword to search the reservation on
func (r ApiSearchReservationsRequest) Keyword(keyword string) ApiSearchReservationsRequest {
	r.keyword = &keyword
	return r
}

// the start date of the reservation search
func (r ApiSearchReservationsRequest) StartDate(startDate int64) ApiSearchReservationsRequest {
	r.startDate = &startDate
	return r
}

// the end date of the reservation search
func (r ApiSearchReservationsRequest) EndDate(endDate int64) ApiSearchReservationsRequest {
	r.endDate = &endDate
	return r
}

// the start of the index and/or pagination
func (r ApiSearchReservationsRequest) Start(start int32) ApiSearchReservationsRequest {
	r.start = &start
	return r
}

// the limit of the index and/or pagination
func (r ApiSearchReservationsRequest) Limit(limit int32) ApiSearchReservationsRequest {
	r.limit = &limit
	return r
}

func (r ApiSearchReservationsRequest) Execute() ([]ReservationResponse, *http.Response, error) {
	return r.ApiService.SearchReservationsExecute(r)
}

/*
SearchReservations Search Reservations

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiSearchReservationsRequest
*/
func (a *ReservationAPIService) SearchReservations(ctx context.Context, version float32) ApiSearchReservationsRequest {
	return ApiSearchReservationsRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return []ReservationResponse
func (a *ReservationAPIService) SearchReservationsExecute(r ApiSearchReservationsRequest) ([]ReservationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ReservationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationAPIService.SearchReservations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/reservation/search"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.filterAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filterAccountId", r.filterAccountId, "form", "")
	}
	if r.reservableId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservableId", r.reservableId, "form", "")
	}
	if r.reservableType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservableType", r.reservableType, "form", "")
	}
	if r.keyword != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyword", r.keyword, "form", "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "form", "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	} else {
		var defaultValue int32 = 0
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", defaultValue, "form", "")
		r.start = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 100
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchScheduleRequest struct {
	ctx context.Context
	ApiService *ReservationAPIService
	version float32
	reservableId *int64
	reservableType *string
	startDate *int64
	endDate *int64
	deviceId *string
	accountId *int64
	timeBucketMins *int32
}

// the id of the reservation
func (r ApiSearchScheduleRequest) ReservableId(reservableId int64) ApiSearchScheduleRequest {
	r.reservableId = &reservableId
	return r
}

// the reservation type
func (r ApiSearchScheduleRequest) ReservableType(reservableType string) ApiSearchScheduleRequest {
	r.reservableType = &reservableType
	return r
}

// the start date of the reservation
func (r ApiSearchScheduleRequest) StartDate(startDate int64) ApiSearchScheduleRequest {
	r.startDate = &startDate
	return r
}

// the end date of the reservation
func (r ApiSearchScheduleRequest) EndDate(endDate int64) ApiSearchScheduleRequest {
	r.endDate = &endDate
	return r
}

// the id of the device that the reservation is on
func (r ApiSearchScheduleRequest) DeviceId(deviceId string) ApiSearchScheduleRequest {
	r.deviceId = &deviceId
	return r
}

// the id of the logged in user
func (r ApiSearchScheduleRequest) AccountId(accountId int64) ApiSearchScheduleRequest {
	r.accountId = &accountId
	return r
}

// the length of time in minutes to search on for reservation
func (r ApiSearchScheduleRequest) TimeBucketMins(timeBucketMins int32) ApiSearchScheduleRequest {
	r.timeBucketMins = &timeBucketMins
	return r
}

func (r ApiSearchScheduleRequest) Execute() ([]TimeSlotResponse, *http.Response, error) {
	return r.ApiService.SearchScheduleExecute(r)
}

/*
SearchSchedule Search Schedule

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiSearchScheduleRequest
*/
func (a *ReservationAPIService) SearchSchedule(ctx context.Context, version float32) ApiSearchScheduleRequest {
	return ApiSearchScheduleRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return []TimeSlotResponse
func (a *ReservationAPIService) SearchScheduleExecute(r ApiSearchScheduleRequest) ([]TimeSlotResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []TimeSlotResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationAPIService.SearchSchedule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/reservable/schedule/search"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.reservableId == nil {
		return localVarReturnValue, nil, reportError("reservableId is required and must be specified")
	}
	if r.reservableType == nil {
		return localVarReturnValue, nil, reportError("reservableType is required and must be specified")
	}
	if r.startDate == nil {
		return localVarReturnValue, nil, reportError("startDate is required and must be specified")
	}
	if r.endDate == nil {
		return localVarReturnValue, nil, reportError("endDate is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "reservableId", r.reservableId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "reservableType", r.reservableType, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "form", "")
	if r.timeBucketMins != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeBucketMins", r.timeBucketMins, "form", "")
	} else {
		var defaultValue int32 = 30
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeBucketMins", defaultValue, "form", "")
		r.timeBucketMins = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
