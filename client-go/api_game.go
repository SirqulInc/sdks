/*
Sirqul IoT Platform

Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

API version: 3.16
Contact: info@sirqul.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// GameAPIService GameAPI service
type GameAPIService service

type ApiCreateGameRequest struct {
	ctx context.Context
	ApiService *GameAPIService
	accountId *int64
	appKey *string
	title *string
	description *string
	metaData *string
	packIds *string
	includeGameData *bool
}

// The logged in user.
func (r ApiCreateGameRequest) AccountId(accountId int64) ApiCreateGameRequest {
	r.accountId = &accountId
	return r
}

// The game application key to save the level for.
func (r ApiCreateGameRequest) AppKey(appKey string) ApiCreateGameRequest {
	r.appKey = &appKey
	return r
}

// Title of the game.
func (r ApiCreateGameRequest) Title(title string) ApiCreateGameRequest {
	r.title = &title
	return r
}

// Description of the game.
func (r ApiCreateGameRequest) Description(description string) ApiCreateGameRequest {
	r.description = &description
	return r
}

// metaData of the Game.
func (r ApiCreateGameRequest) MetaData(metaData string) ApiCreateGameRequest {
	r.metaData = &metaData
	return r
}

// comma separated String of pack Ids that will associate with the game.
func (r ApiCreateGameRequest) PackIds(packIds string) ApiCreateGameRequest {
	r.packIds = &packIds
	return r
}

// Show more details in response.
func (r ApiCreateGameRequest) IncludeGameData(includeGameData bool) ApiCreateGameRequest {
	r.includeGameData = &includeGameData
	return r
}

func (r ApiCreateGameRequest) Execute() (*GameResponse, *http.Response, error) {
	return r.ApiService.CreateGameExecute(r)
}

/*
CreateGame Create a Game

Create a Game.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateGameRequest
*/
func (a *GameAPIService) CreateGame(ctx context.Context) ApiCreateGameRequest {
	return ApiCreateGameRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GameResponse
func (a *GameAPIService) CreateGameExecute(r ApiCreateGameRequest) (*GameResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GameResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GameAPIService.CreateGame")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/game/create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	if r.title != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "title", r.title, "form", "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "form", "")
	}
	if r.metaData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metaData", r.metaData, "form", "")
	}
	if r.packIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "packIds", r.packIds, "form", "")
	}
	if r.includeGameData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeGameData", r.includeGameData, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteGameRequest struct {
	ctx context.Context
	ApiService *GameAPIService
	accountId *int64
	gameId *int64
}

// The logged in user.
func (r ApiDeleteGameRequest) AccountId(accountId int64) ApiDeleteGameRequest {
	r.accountId = &accountId
	return r
}

// the updating game&#39;s id.
func (r ApiDeleteGameRequest) GameId(gameId int64) ApiDeleteGameRequest {
	r.gameId = &gameId
	return r
}

func (r ApiDeleteGameRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.DeleteGameExecute(r)
}

/*
DeleteGame Delete a Game

Delete a game.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteGameRequest
*/
func (a *GameAPIService) DeleteGame(ctx context.Context) ApiDeleteGameRequest {
	return ApiDeleteGameRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *GameAPIService) DeleteGameExecute(r ApiDeleteGameRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GameAPIService.DeleteGame")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/game/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.gameId == nil {
		return localVarReturnValue, nil, reportError("gameId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "gameId", r.gameId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGameRequest struct {
	ctx context.Context
	ApiService *GameAPIService
	accountId *int64
	gameId *int64
	includeGameData *bool
}

// The logged in user.
func (r ApiGetGameRequest) AccountId(accountId int64) ApiGetGameRequest {
	r.accountId = &accountId
	return r
}

// the updating game&#39;s id.
func (r ApiGetGameRequest) GameId(gameId int64) ApiGetGameRequest {
	r.gameId = &gameId
	return r
}

// If true include the game level data, otherwise don&#39;t. default is false.
func (r ApiGetGameRequest) IncludeGameData(includeGameData bool) ApiGetGameRequest {
	r.includeGameData = &includeGameData
	return r
}

func (r ApiGetGameRequest) Execute() (*GameResponse, *http.Response, error) {
	return r.ApiService.GetGameExecute(r)
}

/*
GetGame Get a Game by id

Get a Game by id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetGameRequest
*/
func (a *GameAPIService) GetGame(ctx context.Context) ApiGetGameRequest {
	return ApiGetGameRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GameResponse
func (a *GameAPIService) GetGameExecute(r ApiGetGameRequest) (*GameResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GameResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GameAPIService.GetGame")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/game/get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.gameId == nil {
		return localVarReturnValue, nil, reportError("gameId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "gameId", r.gameId, "form", "")
	if r.includeGameData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeGameData", r.includeGameData, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchGamesRequest struct {
	ctx context.Context
	ApiService *GameAPIService
	accountId *int64
	appKey *string
	start *int32
	limit *int32
	keyword *string
	appVersion *string
	includeGameData *bool
	includeInactive *bool
}

// The logged in user.
func (r ApiSearchGamesRequest) AccountId(accountId int64) ApiSearchGamesRequest {
	r.accountId = &accountId
	return r
}

// the application key
func (r ApiSearchGamesRequest) AppKey(appKey string) ApiSearchGamesRequest {
	r.appKey = &appKey
	return r
}

// Start the result set at some index.
func (r ApiSearchGamesRequest) Start(start int32) ApiSearchGamesRequest {
	r.start = &start
	return r
}

// Limit the result to some number.
func (r ApiSearchGamesRequest) Limit(limit int32) ApiSearchGamesRequest {
	r.limit = &limit
	return r
}

// Match the keyword to the owner name or level name.
func (r ApiSearchGamesRequest) Keyword(keyword string) ApiSearchGamesRequest {
	r.keyword = &keyword
	return r
}

// The maximum version of the level to return.
func (r ApiSearchGamesRequest) AppVersion(appVersion string) ApiSearchGamesRequest {
	r.appVersion = &appVersion
	return r
}

// more details in response
func (r ApiSearchGamesRequest) IncludeGameData(includeGameData bool) ApiSearchGamesRequest {
	r.includeGameData = &includeGameData
	return r
}

// more details in response
func (r ApiSearchGamesRequest) IncludeInactive(includeInactive bool) ApiSearchGamesRequest {
	r.includeInactive = &includeInactive
	return r
}

func (r ApiSearchGamesRequest) Execute() (*GameResponse, *http.Response, error) {
	return r.ApiService.SearchGamesExecute(r)
}

/*
SearchGames Search a Game

Get a list of games for an application, just those the account has permissions to view.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchGamesRequest
*/
func (a *GameAPIService) SearchGames(ctx context.Context) ApiSearchGamesRequest {
	return ApiSearchGamesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GameResponse
func (a *GameAPIService) SearchGamesExecute(r ApiSearchGamesRequest) (*GameResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GameResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GameAPIService.SearchGames")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/game/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.appKey == nil {
		return localVarReturnValue, nil, reportError("appKey is required and must be specified")
	}
	if r.start == nil {
		return localVarReturnValue, nil, reportError("start is required and must be specified")
	}
	if r.limit == nil {
		return localVarReturnValue, nil, reportError("limit is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	if r.keyword != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyword", r.keyword, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	if r.appVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appVersion", r.appVersion, "form", "")
	}
	if r.includeGameData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeGameData", r.includeGameData, "form", "")
	}
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateGameRequest struct {
	ctx context.Context
	ApiService *GameAPIService
	accountId *int64
	gameId *int64
	appKey *string
	title *string
	description *string
	metaData *string
	packIds *string
	includeGameData *bool
}

// The logged in user.
func (r ApiUpdateGameRequest) AccountId(accountId int64) ApiUpdateGameRequest {
	r.accountId = &accountId
	return r
}

// the updating game&#39;s id
func (r ApiUpdateGameRequest) GameId(gameId int64) ApiUpdateGameRequest {
	r.gameId = &gameId
	return r
}

// The game application key to save the level for.
func (r ApiUpdateGameRequest) AppKey(appKey string) ApiUpdateGameRequest {
	r.appKey = &appKey
	return r
}

// Title of the Game.
func (r ApiUpdateGameRequest) Title(title string) ApiUpdateGameRequest {
	r.title = &title
	return r
}

// Description of the Game.
func (r ApiUpdateGameRequest) Description(description string) ApiUpdateGameRequest {
	r.description = &description
	return r
}

// metaData of the Game.
func (r ApiUpdateGameRequest) MetaData(metaData string) ApiUpdateGameRequest {
	r.metaData = &metaData
	return r
}

// comma separated String of pack Ids that will associate with the game.
func (r ApiUpdateGameRequest) PackIds(packIds string) ApiUpdateGameRequest {
	r.packIds = &packIds
	return r
}

// show more details in response.
func (r ApiUpdateGameRequest) IncludeGameData(includeGameData bool) ApiUpdateGameRequest {
	r.includeGameData = &includeGameData
	return r
}

func (r ApiUpdateGameRequest) Execute() (*GameResponse, *http.Response, error) {
	return r.ApiService.UpdateGameExecute(r)
}

/*
UpdateGame Update a Game

Update a Game

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateGameRequest
*/
func (a *GameAPIService) UpdateGame(ctx context.Context) ApiUpdateGameRequest {
	return ApiUpdateGameRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GameResponse
func (a *GameAPIService) UpdateGameExecute(r ApiUpdateGameRequest) (*GameResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GameResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GameAPIService.UpdateGame")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/game/update"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.gameId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gameId", r.gameId, "form", "")
	}
	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	if r.title != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "title", r.title, "form", "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "form", "")
	}
	if r.metaData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metaData", r.metaData, "form", "")
	}
	if r.packIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "packIds", r.packIds, "form", "")
	}
	if r.includeGameData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeGameData", r.includeGameData, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
