/*
Sirqul IoT Platform

Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

API version: 3.16
Contact: info@sirqul.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// BillableEntityAPIService BillableEntityAPI service
type BillableEntityAPIService service

type ApiCreateBillableEntityRequest struct {
	ctx context.Context
	ApiService *BillableEntityAPIService
	version float32
	deviceId *string
	accountId *int64
	name *string
	streetAddress *string
	streetAddress2 *string
	city *string
	state *string
	postalCode *string
	businessPhone *string
	businessPhoneExt *string
	authorizeNetApiKey *string
	authorizeNetTransactionKey *string
}

// The unique device identifier that made the request (either deviceId or accountId must be used)
func (r ApiCreateBillableEntityRequest) DeviceId(deviceId string) ApiCreateBillableEntityRequest {
	r.deviceId = &deviceId
	return r
}

// The unique accountId that made the request (either deviceId or accountId must be used)
func (r ApiCreateBillableEntityRequest) AccountId(accountId int64) ApiCreateBillableEntityRequest {
	r.accountId = &accountId
	return r
}

// The name of the entity responsible for billing 
func (r ApiCreateBillableEntityRequest) Name(name string) ApiCreateBillableEntityRequest {
	r.name = &name
	return r
}

// The street address of the billable entity
func (r ApiCreateBillableEntityRequest) StreetAddress(streetAddress string) ApiCreateBillableEntityRequest {
	r.streetAddress = &streetAddress
	return r
}

// Additional address information (such as a suite number, floor number, building name, or PO Box) 
func (r ApiCreateBillableEntityRequest) StreetAddress2(streetAddress2 string) ApiCreateBillableEntityRequest {
	r.streetAddress2 = &streetAddress2
	return r
}

// The city of the billable entity
func (r ApiCreateBillableEntityRequest) City(city string) ApiCreateBillableEntityRequest {
	r.city = &city
	return r
}

// The state of the billable entity
func (r ApiCreateBillableEntityRequest) State(state string) ApiCreateBillableEntityRequest {
	r.state = &state
	return r
}

// The postal code of the billable entity
func (r ApiCreateBillableEntityRequest) PostalCode(postalCode string) ApiCreateBillableEntityRequest {
	r.postalCode = &postalCode
	return r
}

// The business phone of the billable entity
func (r ApiCreateBillableEntityRequest) BusinessPhone(businessPhone string) ApiCreateBillableEntityRequest {
	r.businessPhone = &businessPhone
	return r
}

// The business phone extension
func (r ApiCreateBillableEntityRequest) BusinessPhoneExt(businessPhoneExt string) ApiCreateBillableEntityRequest {
	r.businessPhoneExt = &businessPhoneExt
	return r
}

// Authorize Net Api Key
func (r ApiCreateBillableEntityRequest) AuthorizeNetApiKey(authorizeNetApiKey string) ApiCreateBillableEntityRequest {
	r.authorizeNetApiKey = &authorizeNetApiKey
	return r
}

// Authorize Net Transaction Key
func (r ApiCreateBillableEntityRequest) AuthorizeNetTransactionKey(authorizeNetTransactionKey string) ApiCreateBillableEntityRequest {
	r.authorizeNetTransactionKey = &authorizeNetTransactionKey
	return r
}

func (r ApiCreateBillableEntityRequest) Execute() (*BillableEntityResponse, *http.Response, error) {
	return r.ApiService.CreateBillableEntityExecute(r)
}

/*
CreateBillableEntity Create Billable

reate a billable entity for an account. The creator is assumed to be the responsible account. An account can only have one billable entity

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiCreateBillableEntityRequest
*/
func (a *BillableEntityAPIService) CreateBillableEntity(ctx context.Context, version float32) ApiCreateBillableEntityRequest {
	return ApiCreateBillableEntityRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return BillableEntityResponse
func (a *BillableEntityAPIService) CreateBillableEntityExecute(r ApiCreateBillableEntityRequest) (*BillableEntityResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BillableEntityResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillableEntityAPIService.CreateBillableEntity")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/billable/create"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.streetAddress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "streetAddress", r.streetAddress, "form", "")
	}
	if r.streetAddress2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "streetAddress2", r.streetAddress2, "form", "")
	}
	if r.city != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "city", r.city, "form", "")
	}
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "form", "")
	}
	if r.postalCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "postalCode", r.postalCode, "form", "")
	}
	if r.businessPhone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "businessPhone", r.businessPhone, "form", "")
	}
	if r.businessPhoneExt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "businessPhoneExt", r.businessPhoneExt, "form", "")
	}
	if r.authorizeNetApiKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "authorizeNetApiKey", r.authorizeNetApiKey, "form", "")
	}
	if r.authorizeNetTransactionKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "authorizeNetTransactionKey", r.authorizeNetTransactionKey, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteBillableEntityRequest struct {
	ctx context.Context
	ApiService *BillableEntityAPIService
	version float32
	deviceId *string
	accountId *int64
}

// The device id (deviceId or accountId required)
func (r ApiDeleteBillableEntityRequest) DeviceId(deviceId string) ApiDeleteBillableEntityRequest {
	r.deviceId = &deviceId
	return r
}

// The account used to perform the delete, must have rights to edit the billable entity.
func (r ApiDeleteBillableEntityRequest) AccountId(accountId int64) ApiDeleteBillableEntityRequest {
	r.accountId = &accountId
	return r
}

func (r ApiDeleteBillableEntityRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.DeleteBillableEntityExecute(r)
}

/*
DeleteBillableEntity Delete Billable

Mark the billable as deleted

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiDeleteBillableEntityRequest
*/
func (a *BillableEntityAPIService) DeleteBillableEntity(ctx context.Context, version float32) ApiDeleteBillableEntityRequest {
	return ApiDeleteBillableEntityRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *BillableEntityAPIService) DeleteBillableEntityExecute(r ApiDeleteBillableEntityRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillableEntityAPIService.DeleteBillableEntity")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/billable/delete"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBillableEntityRequest struct {
	ctx context.Context
	ApiService *BillableEntityAPIService
	version float32
	deviceId *string
	accountId *int64
	includeCounts *bool
	includePayments *bool
}

// The unique device identifier that made the request (either deviceId or accountId must be used)
func (r ApiGetBillableEntityRequest) DeviceId(deviceId string) ApiGetBillableEntityRequest {
	r.deviceId = &deviceId
	return r
}

// The unique accountId that made the request (either deviceId or accountId must be used)
func (r ApiGetBillableEntityRequest) AccountId(accountId int64) ApiGetBillableEntityRequest {
	r.accountId = &accountId
	return r
}

// Determines whether to include the retailer dash board counts into the response
func (r ApiGetBillableEntityRequest) IncludeCounts(includeCounts bool) ApiGetBillableEntityRequest {
	r.includeCounts = &includeCounts
	return r
}

// Whether to enable payments or not
func (r ApiGetBillableEntityRequest) IncludePayments(includePayments bool) ApiGetBillableEntityRequest {
	r.includePayments = &includePayments
	return r
}

func (r ApiGetBillableEntityRequest) Execute() (*BillableEntityResponse, *http.Response, error) {
	return r.ApiService.GetBillableEntityExecute(r)
}

/*
GetBillableEntity Get Billable

Used to determine the associated BillableEntity of an account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiGetBillableEntityRequest
*/
func (a *BillableEntityAPIService) GetBillableEntity(ctx context.Context, version float32) ApiGetBillableEntityRequest {
	return ApiGetBillableEntityRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return BillableEntityResponse
func (a *BillableEntityAPIService) GetBillableEntityExecute(r ApiGetBillableEntityRequest) (*BillableEntityResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BillableEntityResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillableEntityAPIService.GetBillableEntity")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/billable/get"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.includeCounts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeCounts", r.includeCounts, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeCounts", defaultValue, "form", "")
		r.includeCounts = &defaultValue
	}
	if r.includePayments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includePayments", r.includePayments, "form", "")
	} else {
		var defaultValue bool = true
		parameterAddToHeaderOrQuery(localVarQueryParams, "includePayments", defaultValue, "form", "")
		r.includePayments = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateBillableEntityRequest struct {
	ctx context.Context
	ApiService *BillableEntityAPIService
	version float32
	deviceId *string
	accountId *int64
	name *string
	streetAddress *string
	streetAddress2 *string
	city *string
	state *string
	postalCode *string
	businessPhone *string
	businessPhoneExt *string
	authorizeNetApiKey *string
	authorizeNetTransactionKey *string
}

// The unique device identifier that made the request (either deviceId or accountId must be used)
func (r ApiUpdateBillableEntityRequest) DeviceId(deviceId string) ApiUpdateBillableEntityRequest {
	r.deviceId = &deviceId
	return r
}

// The unique accountId that made the request (either deviceId or accountId must be used). The account must have rights to edit the billable entity.
func (r ApiUpdateBillableEntityRequest) AccountId(accountId int64) ApiUpdateBillableEntityRequest {
	r.accountId = &accountId
	return r
}

// The name of the entity responsible for billing 
func (r ApiUpdateBillableEntityRequest) Name(name string) ApiUpdateBillableEntityRequest {
	r.name = &name
	return r
}

// The street address of the billable entity
func (r ApiUpdateBillableEntityRequest) StreetAddress(streetAddress string) ApiUpdateBillableEntityRequest {
	r.streetAddress = &streetAddress
	return r
}

// Additional address information (such as a suite number, floor number, building name, or PO Box) 
func (r ApiUpdateBillableEntityRequest) StreetAddress2(streetAddress2 string) ApiUpdateBillableEntityRequest {
	r.streetAddress2 = &streetAddress2
	return r
}

// The city of the billable entity
func (r ApiUpdateBillableEntityRequest) City(city string) ApiUpdateBillableEntityRequest {
	r.city = &city
	return r
}

// The state of the billable entity
func (r ApiUpdateBillableEntityRequest) State(state string) ApiUpdateBillableEntityRequest {
	r.state = &state
	return r
}

// The postal code of the billable entity
func (r ApiUpdateBillableEntityRequest) PostalCode(postalCode string) ApiUpdateBillableEntityRequest {
	r.postalCode = &postalCode
	return r
}

// The business phone of the billable entity
func (r ApiUpdateBillableEntityRequest) BusinessPhone(businessPhone string) ApiUpdateBillableEntityRequest {
	r.businessPhone = &businessPhone
	return r
}

// The business phone extension of the billable entity
func (r ApiUpdateBillableEntityRequest) BusinessPhoneExt(businessPhoneExt string) ApiUpdateBillableEntityRequest {
	r.businessPhoneExt = &businessPhoneExt
	return r
}

// Authorize Net Api Key of the billable entity
func (r ApiUpdateBillableEntityRequest) AuthorizeNetApiKey(authorizeNetApiKey string) ApiUpdateBillableEntityRequest {
	r.authorizeNetApiKey = &authorizeNetApiKey
	return r
}

// Authorize Net Transaction Key of the billable entity
func (r ApiUpdateBillableEntityRequest) AuthorizeNetTransactionKey(authorizeNetTransactionKey string) ApiUpdateBillableEntityRequest {
	r.authorizeNetTransactionKey = &authorizeNetTransactionKey
	return r
}

func (r ApiUpdateBillableEntityRequest) Execute() (*BillableEntityResponse, *http.Response, error) {
	return r.ApiService.UpdateBillableEntityExecute(r)
}

/*
UpdateBillableEntity Update Billable

Updates the billable record for an account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiUpdateBillableEntityRequest
*/
func (a *BillableEntityAPIService) UpdateBillableEntity(ctx context.Context, version float32) ApiUpdateBillableEntityRequest {
	return ApiUpdateBillableEntityRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return BillableEntityResponse
func (a *BillableEntityAPIService) UpdateBillableEntityExecute(r ApiUpdateBillableEntityRequest) (*BillableEntityResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BillableEntityResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillableEntityAPIService.UpdateBillableEntity")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/billable/update"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.streetAddress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "streetAddress", r.streetAddress, "form", "")
	}
	if r.streetAddress2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "streetAddress2", r.streetAddress2, "form", "")
	}
	if r.city != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "city", r.city, "form", "")
	}
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "form", "")
	}
	if r.postalCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "postalCode", r.postalCode, "form", "")
	}
	if r.businessPhone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "businessPhone", r.businessPhone, "form", "")
	}
	if r.businessPhoneExt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "businessPhoneExt", r.businessPhoneExt, "form", "")
	}
	if r.authorizeNetApiKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "authorizeNetApiKey", r.authorizeNetApiKey, "form", "")
	}
	if r.authorizeNetTransactionKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "authorizeNetTransactionKey", r.authorizeNetTransactionKey, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
