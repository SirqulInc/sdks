/*
Sirqul IoT Platform

Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

API version: 3.16
Contact: info@sirqul.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// SubscriptionAPIService SubscriptionAPI service
type SubscriptionAPIService service

type ApiCreateSubscriptionRequest struct {
	ctx context.Context
	ApiService *SubscriptionAPIService
	version float32
	accountId *int64
	planId *int64
	promoCode *string
}

// The account used to perform the create, must be the responsible manager
func (r ApiCreateSubscriptionRequest) AccountId(accountId int64) ApiCreateSubscriptionRequest {
	r.accountId = &accountId
	return r
}

// The plan to subscribe to, if null use default plan
func (r ApiCreateSubscriptionRequest) PlanId(planId int64) ApiCreateSubscriptionRequest {
	r.planId = &planId
	return r
}

// Set a promo code for a discount.
func (r ApiCreateSubscriptionRequest) PromoCode(promoCode string) ApiCreateSubscriptionRequest {
	r.promoCode = &promoCode
	return r
}

func (r ApiCreateSubscriptionRequest) Execute() (*SubscriptionResponse, *http.Response, error) {
	return r.ApiService.CreateSubscriptionExecute(r)
}

/*
CreateSubscription Create Subscription

Create a subscription for a billable entity.  Provide a planId, if not provided then the base plan will be assigned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiCreateSubscriptionRequest
*/
func (a *SubscriptionAPIService) CreateSubscription(ctx context.Context, version float32) ApiCreateSubscriptionRequest {
	return ApiCreateSubscriptionRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return SubscriptionResponse
func (a *SubscriptionAPIService) CreateSubscriptionExecute(r ApiCreateSubscriptionRequest) (*SubscriptionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubscriptionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionAPIService.CreateSubscription")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/subscription/create"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	if r.planId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "planId", r.planId, "form", "")
	}
	if r.promoCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "promoCode", r.promoCode, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteSubscriptionRequest struct {
	ctx context.Context
	ApiService *SubscriptionAPIService
	version float32
	accountId *int64
}

// The account used to perform the delete, must be the responsible manager
func (r ApiDeleteSubscriptionRequest) AccountId(accountId int64) ApiDeleteSubscriptionRequest {
	r.accountId = &accountId
	return r
}

func (r ApiDeleteSubscriptionRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.DeleteSubscriptionExecute(r)
}

/*
DeleteSubscription Delete Subscription

Suspend the current subscription for the billable entity managed by the account.  The account must be the responsible manager to perform this action

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiDeleteSubscriptionRequest
*/
func (a *SubscriptionAPIService) DeleteSubscription(ctx context.Context, version float32) ApiDeleteSubscriptionRequest {
	return ApiDeleteSubscriptionRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *SubscriptionAPIService) DeleteSubscriptionExecute(r ApiDeleteSubscriptionRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionAPIService.DeleteSubscription")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/subscription/delete"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSubscriptionRequest struct {
	ctx context.Context
	ApiService *SubscriptionAPIService
	version float32
	accountId *int64
}

// The account used to perform the lookup
func (r ApiGetSubscriptionRequest) AccountId(accountId int64) ApiGetSubscriptionRequest {
	r.accountId = &accountId
	return r
}

func (r ApiGetSubscriptionRequest) Execute() (*SubscriptionResponse, *http.Response, error) {
	return r.ApiService.GetSubscriptionExecute(r)
}

/*
GetSubscription Get Subscription

Use the accountId to determine the associated BillableEntity.  Then get the subscription.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiGetSubscriptionRequest
*/
func (a *SubscriptionAPIService) GetSubscription(ctx context.Context, version float32) ApiGetSubscriptionRequest {
	return ApiGetSubscriptionRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return SubscriptionResponse
func (a *SubscriptionAPIService) GetSubscriptionExecute(r ApiGetSubscriptionRequest) (*SubscriptionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubscriptionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionAPIService.GetSubscription")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/subscription/get"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSubscriptionPlanRequest struct {
	ctx context.Context
	ApiService *SubscriptionAPIService
	version float32
	planId *int64
}

// The ID of the plan to get
func (r ApiGetSubscriptionPlanRequest) PlanId(planId int64) ApiGetSubscriptionPlanRequest {
	r.planId = &planId
	return r
}

func (r ApiGetSubscriptionPlanRequest) Execute() (*SubscriptionPlanResponse, *http.Response, error) {
	return r.ApiService.GetSubscriptionPlanExecute(r)
}

/*
GetSubscriptionPlan Get Subscription Plan

Get the matched subscription plan

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiGetSubscriptionPlanRequest
*/
func (a *SubscriptionAPIService) GetSubscriptionPlan(ctx context.Context, version float32) ApiGetSubscriptionPlanRequest {
	return ApiGetSubscriptionPlanRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return SubscriptionPlanResponse
func (a *SubscriptionAPIService) GetSubscriptionPlanExecute(r ApiGetSubscriptionPlanRequest) (*SubscriptionPlanResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubscriptionPlanResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionAPIService.GetSubscriptionPlan")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/subscription/plan/get"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.planId == nil {
		return localVarReturnValue, nil, reportError("planId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "planId", r.planId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSubscriptionPlansRequest struct {
	ctx context.Context
	ApiService *SubscriptionAPIService
	version float32
	visible *bool
	role *string
}

// Include visible only (true), hidden only (false), or all (null)
func (r ApiGetSubscriptionPlansRequest) Visible(visible bool) ApiGetSubscriptionPlansRequest {
	r.visible = &visible
	return r
}

// The role the plan is targeted for, values are: DEVELOPER, RETAILER, ADVERTISER
func (r ApiGetSubscriptionPlansRequest) Role(role string) ApiGetSubscriptionPlansRequest {
	r.role = &role
	return r
}

func (r ApiGetSubscriptionPlansRequest) Execute() ([]SubscriptionPlanResponse, *http.Response, error) {
	return r.ApiService.GetSubscriptionPlansExecute(r)
}

/*
GetSubscriptionPlans List Subscription Plans

Get the matched subscription plan

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiGetSubscriptionPlansRequest
*/
func (a *SubscriptionAPIService) GetSubscriptionPlans(ctx context.Context, version float32) ApiGetSubscriptionPlansRequest {
	return ApiGetSubscriptionPlansRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return []SubscriptionPlanResponse
func (a *SubscriptionAPIService) GetSubscriptionPlansExecute(r ApiGetSubscriptionPlansRequest) ([]SubscriptionPlanResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SubscriptionPlanResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionAPIService.GetSubscriptionPlans")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/subscription/plan/list"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.visible != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "visible", r.visible, "form", "")
	}
	if r.role != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "role", r.role, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSubscriptionUsageRequest struct {
	ctx context.Context
	ApiService *SubscriptionAPIService
	version float32
	accountId *int64
	applicationId *int64
	start *int64
	end *int64
}

// The account used to perform the lookup
func (r ApiGetSubscriptionUsageRequest) AccountId(accountId int64) ApiGetSubscriptionUsageRequest {
	r.accountId = &accountId
	return r
}

// Get for just 1 application instead of the BillableEntity
func (r ApiGetSubscriptionUsageRequest) ApplicationId(applicationId int64) ApiGetSubscriptionUsageRequest {
	r.applicationId = &applicationId
	return r
}

// The start time frame
func (r ApiGetSubscriptionUsageRequest) Start(start int64) ApiGetSubscriptionUsageRequest {
	r.start = &start
	return r
}

// The end time frame
func (r ApiGetSubscriptionUsageRequest) End(end int64) ApiGetSubscriptionUsageRequest {
	r.end = &end
	return r
}

func (r ApiGetSubscriptionUsageRequest) Execute() (*ApplicationUsageResponse, *http.Response, error) {
	return r.ApiService.GetSubscriptionUsageExecute(r)
}

/*
GetSubscriptionUsage Get Subscription Usage

Use the accountId to determine the associated BillableEntity.  Then get the application usage.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiGetSubscriptionUsageRequest
*/
func (a *SubscriptionAPIService) GetSubscriptionUsage(ctx context.Context, version float32) ApiGetSubscriptionUsageRequest {
	return ApiGetSubscriptionUsageRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return ApplicationUsageResponse
func (a *SubscriptionAPIService) GetSubscriptionUsageExecute(r ApiGetSubscriptionUsageRequest) (*ApplicationUsageResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApplicationUsageResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionAPIService.GetSubscriptionUsage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/subscription/usage/get"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	if r.applicationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "applicationId", r.applicationId, "form", "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateSubscriptionRequest struct {
	ctx context.Context
	ApiService *SubscriptionAPIService
	version float32
	accountId *int64
	planId *int64
	promoCode *string
	active *bool
}

// The account used to perform the update, must be the responsible manager
func (r ApiUpdateSubscriptionRequest) AccountId(accountId int64) ApiUpdateSubscriptionRequest {
	r.accountId = &accountId
	return r
}

// The plan to subscribe to
func (r ApiUpdateSubscriptionRequest) PlanId(planId int64) ApiUpdateSubscriptionRequest {
	r.planId = &planId
	return r
}

// Set a promo code for a discount.
func (r ApiUpdateSubscriptionRequest) PromoCode(promoCode string) ApiUpdateSubscriptionRequest {
	r.promoCode = &promoCode
	return r
}

// Set active status
func (r ApiUpdateSubscriptionRequest) Active(active bool) ApiUpdateSubscriptionRequest {
	r.active = &active
	return r
}

func (r ApiUpdateSubscriptionRequest) Execute() (*SubscriptionResponse, *http.Response, error) {
	return r.ApiService.UpdateSubscriptionExecute(r)
}

/*
UpdateSubscription Update Subscription

Updates the subscription for the billable entity for an account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiUpdateSubscriptionRequest
*/
func (a *SubscriptionAPIService) UpdateSubscription(ctx context.Context, version float32) ApiUpdateSubscriptionRequest {
	return ApiUpdateSubscriptionRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return SubscriptionResponse
func (a *SubscriptionAPIService) UpdateSubscriptionExecute(r ApiUpdateSubscriptionRequest) (*SubscriptionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubscriptionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionAPIService.UpdateSubscription")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/subscription/update"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	if r.planId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "planId", r.planId, "form", "")
	}
	if r.promoCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "promoCode", r.promoCode, "form", "")
	}
	if r.active != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active", r.active, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
