/*
Sirqul IoT Platform

Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

API version: 3.16
Contact: info@sirqul.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// ScoreAPIService ScoreAPI service
type ScoreAPIService service

type ApiCreateScoreRequest struct {
	ctx context.Context
	ApiService *ScoreAPIService
	version float32
	accountId *int64
	appKey *string
	points *int32
	missionId *int64
	gameId *int64
	packId *int64
	gameLevelId *int64
	gameObjectId *int64
	timeTaken *int32
	highest *bool
}

// The logged in user.
func (r ApiCreateScoreRequest) AccountId(accountId int64) ApiCreateScoreRequest {
	r.accountId = &accountId
	return r
}

// The game application key to save the score for.
func (r ApiCreateScoreRequest) AppKey(appKey string) ApiCreateScoreRequest {
	r.appKey = &appKey
	return r
}

// The score
func (r ApiCreateScoreRequest) Points(points int32) ApiCreateScoreRequest {
	r.points = &points
	return r
}

// The missionId to score for, ignore if not playing mission.
func (r ApiCreateScoreRequest) MissionId(missionId int64) ApiCreateScoreRequest {
	r.missionId = &missionId
	return r
}

// The gameId to score for, ignore if not playing mission.
func (r ApiCreateScoreRequest) GameId(gameId int64) ApiCreateScoreRequest {
	r.gameId = &gameId
	return r
}

// The packId to score for, send -2 if playing community levels.
func (r ApiCreateScoreRequest) PackId(packId int64) ApiCreateScoreRequest {
	r.packId = &packId
	return r
}

// The gameLevelId to score for.
func (r ApiCreateScoreRequest) GameLevelId(gameLevelId int64) ApiCreateScoreRequest {
	r.gameLevelId = &gameLevelId
	return r
}

// The gameObjectId to score for, ignore if level based scoring.
func (r ApiCreateScoreRequest) GameObjectId(gameObjectId int64) ApiCreateScoreRequest {
	r.gameObjectId = &gameObjectId
	return r
}

// The time taken to complete task
func (r ApiCreateScoreRequest) TimeTaken(timeTaken int32) ApiCreateScoreRequest {
	r.timeTaken = &timeTaken
	return r
}

// 
func (r ApiCreateScoreRequest) Highest(highest bool) ApiCreateScoreRequest {
	r.highest = &highest
	return r
}

func (r ApiCreateScoreRequest) Execute() (*ScoreResponse, *http.Response, error) {
	return r.ApiService.CreateScoreExecute(r)
}

/*
CreateScore Create Score

Create a score.  The response object will contain a series of   coded messages detailing what items were completed, the score registered,   and any tickets allocated.  Scoring a  level could complete the pack it   is in, completing that pack could complete the game, which  in turn could   complete the mission.  This completion chain is indicated to the client   via 
a list of {@link MessageResponse}.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiCreateScoreRequest
*/
func (a *ScoreAPIService) CreateScore(ctx context.Context, version float32) ApiCreateScoreRequest {
	return ApiCreateScoreRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return ScoreResponse
func (a *ScoreAPIService) CreateScoreExecute(r ApiCreateScoreRequest) (*ScoreResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ScoreResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScoreAPIService.CreateScore")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/score/create"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.appKey == nil {
		return localVarReturnValue, nil, reportError("appKey is required and must be specified")
	}
	if r.points == nil {
		return localVarReturnValue, nil, reportError("points is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	if r.missionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "missionId", r.missionId, "form", "")
	}
	if r.gameId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gameId", r.gameId, "form", "")
	}
	if r.packId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "packId", r.packId, "form", "")
	}
	if r.gameLevelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gameLevelId", r.gameLevelId, "form", "")
	}
	if r.gameObjectId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gameObjectId", r.gameObjectId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "points", r.points, "form", "")
	if r.timeTaken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeTaken", r.timeTaken, "form", "")
	}
	if r.highest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "highest", r.highest, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetScoreRequest struct {
	ctx context.Context
	ApiService *ScoreAPIService
	version float32
	accountId *int64
	appKey *string
	missionId *int64
	gameId *int64
	packId *int64
	gameLevelId *int64
	gameObjectId *int64
	scoreObjectType *string
	scoreStatus *string
}

// The logged in user.
func (r ApiGetScoreRequest) AccountId(accountId int64) ApiGetScoreRequest {
	r.accountId = &accountId
	return r
}

// The game application key to get the level for.
func (r ApiGetScoreRequest) AppKey(appKey string) ApiGetScoreRequest {
	r.appKey = &appKey
	return r
}

// The missionId to score for, null if not playing mission.
func (r ApiGetScoreRequest) MissionId(missionId int64) ApiGetScoreRequest {
	r.missionId = &missionId
	return r
}

// The gameId to score for, null if not playing mission.
func (r ApiGetScoreRequest) GameId(gameId int64) ApiGetScoreRequest {
	r.gameId = &gameId
	return r
}

// The packId to score for, null if playing community levels.
func (r ApiGetScoreRequest) PackId(packId int64) ApiGetScoreRequest {
	r.packId = &packId
	return r
}

// The gameLevelId to score for.
func (r ApiGetScoreRequest) GameLevelId(gameLevelId int64) ApiGetScoreRequest {
	r.gameLevelId = &gameLevelId
	return r
}

// The gameObjectId to score for, null if level based scoring.
func (r ApiGetScoreRequest) GameObjectId(gameObjectId int64) ApiGetScoreRequest {
	r.gameObjectId = &gameObjectId
	return r
}

// The object type to filter scores by (TicketObjectType)
func (r ApiGetScoreRequest) ScoreObjectType(scoreObjectType string) ApiGetScoreRequest {
	r.scoreObjectType = &scoreObjectType
	return r
}

// The status of the score to filter (ScoreStatus)
func (r ApiGetScoreRequest) ScoreStatus(scoreStatus string) ApiGetScoreRequest {
	r.scoreStatus = &scoreStatus
	return r
}

func (r ApiGetScoreRequest) Execute() (*ScoreResponse, *http.Response, error) {
	return r.ApiService.GetScoreExecute(r)
}

/*
GetScore Get Score

Get the high score for an item.  Pass in the full path IDs for the score.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiGetScoreRequest
*/
func (a *ScoreAPIService) GetScore(ctx context.Context, version float32) ApiGetScoreRequest {
	return ApiGetScoreRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return ScoreResponse
func (a *ScoreAPIService) GetScoreExecute(r ApiGetScoreRequest) (*ScoreResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ScoreResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScoreAPIService.GetScore")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/score/get"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.appKey == nil {
		return localVarReturnValue, nil, reportError("appKey is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	if r.missionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "missionId", r.missionId, "form", "")
	}
	if r.gameId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gameId", r.gameId, "form", "")
	}
	if r.packId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "packId", r.packId, "form", "")
	}
	if r.gameLevelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gameLevelId", r.gameLevelId, "form", "")
	}
	if r.gameObjectId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gameObjectId", r.gameObjectId, "form", "")
	}
	if r.scoreObjectType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scoreObjectType", r.scoreObjectType, "form", "")
	}
	if r.scoreStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scoreStatus", r.scoreStatus, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchScoresRequest struct {
	ctx context.Context
	ApiService *ScoreAPIService
	version float32
	accountId *int64
	appKey *string
	missionId *int64
	gameId *int64
	packId *int64
	gameLevelId *int64
	gameObjectId *int64
}

// The logged in user.
func (r ApiSearchScoresRequest) AccountId(accountId int64) ApiSearchScoresRequest {
	r.accountId = &accountId
	return r
}

// The game application key to get the level for.
func (r ApiSearchScoresRequest) AppKey(appKey string) ApiSearchScoresRequest {
	r.appKey = &appKey
	return r
}

// The missionId to score for, null if not playing mission.
func (r ApiSearchScoresRequest) MissionId(missionId int64) ApiSearchScoresRequest {
	r.missionId = &missionId
	return r
}

// The gameId to score for, null if not playing mission.
func (r ApiSearchScoresRequest) GameId(gameId int64) ApiSearchScoresRequest {
	r.gameId = &gameId
	return r
}

// The packId to score for, null if playing community levels.
func (r ApiSearchScoresRequest) PackId(packId int64) ApiSearchScoresRequest {
	r.packId = &packId
	return r
}

// The gameLevelId to score for.
func (r ApiSearchScoresRequest) GameLevelId(gameLevelId int64) ApiSearchScoresRequest {
	r.gameLevelId = &gameLevelId
	return r
}

// The gameObjectId to score for, null if level based scoring.
func (r ApiSearchScoresRequest) GameObjectId(gameObjectId int64) ApiSearchScoresRequest {
	r.gameObjectId = &gameObjectId
	return r
}

func (r ApiSearchScoresRequest) Execute() ([]ScoreResponse, *http.Response, error) {
	return r.ApiService.SearchScoresExecute(r)
}

/*
SearchScores Search Score

Search the scores for an item.  Pass in the full path IDs for the scores.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiSearchScoresRequest
*/
func (a *ScoreAPIService) SearchScores(ctx context.Context, version float32) ApiSearchScoresRequest {
	return ApiSearchScoresRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return []ScoreResponse
func (a *ScoreAPIService) SearchScoresExecute(r ApiSearchScoresRequest) ([]ScoreResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ScoreResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScoreAPIService.SearchScores")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/score/search"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.appKey == nil {
		return localVarReturnValue, nil, reportError("appKey is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	if r.missionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "missionId", r.missionId, "form", "")
	}
	if r.gameId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gameId", r.gameId, "form", "")
	}
	if r.packId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "packId", r.packId, "form", "")
	}
	if r.gameLevelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gameLevelId", r.gameLevelId, "form", "")
	}
	if r.gameObjectId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gameObjectId", r.gameObjectId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
