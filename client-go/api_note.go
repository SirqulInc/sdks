/*
Sirqul IoT Platform

Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

API version: 3.16
Contact: info@sirqul.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
)


// NoteAPIService NoteAPI service
type NoteAPIService service

type ApiBatchOperationRequest struct {
	ctx context.Context
	ApiService *NoteAPIService
	version float32
	notableId *int64
	notableType *string
	deviceId *string
	accountId *int64
	batchOperation *string
}

// The id of the notable object the batch operation will affect
func (r ApiBatchOperationRequest) NotableId(notableId int64) ApiBatchOperationRequest {
	r.notableId = &notableId
	return r
}

// The notable object type (for example ALBUM, ASSET, OFFER, etc.)
func (r ApiBatchOperationRequest) NotableType(notableType string) ApiBatchOperationRequest {
	r.notableType = &notableType
	return r
}

// The device id (deviceId or accountId required)
func (r ApiBatchOperationRequest) DeviceId(deviceId string) ApiBatchOperationRequest {
	r.deviceId = &deviceId
	return r
}

// The account id of the user (deviceId or accountId required)
func (r ApiBatchOperationRequest) AccountId(accountId int64) ApiBatchOperationRequest {
	r.accountId = &accountId
	return r
}

// The batch operation to perform (e.g., DELETE_ALL_NOTES_IN_NOTABLE). Optional.
func (r ApiBatchOperationRequest) BatchOperation(batchOperation string) ApiBatchOperationRequest {
	r.batchOperation = &batchOperation
	return r
}

func (r ApiBatchOperationRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.BatchOperationExecute(r)
}

/*
BatchOperation Batch Note Operation

Perform a batch operation on notes for a notable object (for example: DELETE_ALL_NOTES_IN_NOTABLE).


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiBatchOperationRequest
*/
func (a *NoteAPIService) BatchOperation(ctx context.Context, version float32) ApiBatchOperationRequest {
	return ApiBatchOperationRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *NoteAPIService) BatchOperationExecute(r ApiBatchOperationRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NoteAPIService.BatchOperation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/note/batch"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.notableId == nil {
		return localVarReturnValue, nil, reportError("notableId is required and must be specified")
	}
	if r.notableType == nil {
		return localVarReturnValue, nil, reportError("notableType is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "notableId", r.notableId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "notableType", r.notableType, "form", "")
	if r.batchOperation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "batchOperation", r.batchOperation, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateNoteRequest struct {
	ctx context.Context
	ApiService *NoteAPIService
	version float32
	comment *string
	deviceId *string
	accountId *int64
	notableType *string
	notableId *int64
	noteType *string
	assetIds *string
	tags *string
	permissionableType *string
	permissionableId *int64
	appKey *string
	locationDescription *string
	latitude *float64
	longitude *float64
	metaData *string
	receiverAccountIds *string
	returnFullResponse *bool
	initializeAsset *bool
	assetReturnNulls *bool
	assetAlbumId *int64
	assetCollectionId *int64
	assetAddToDefaultAlbum *string
	assetAddToMediaLibrary *bool
	assetVersionCode *int32
	assetVersionName *string
	assetMetaData *string
	assetCaption *string
	assetMedia *os.File
	assetMediaUrl *string
	assetMediaString *string
	assetMediaStringFileName *string
	assetMediaStringContentType *string
	assetAttachedMedia *os.File
	assetAttachedMediaUrl *string
	assetAttachedMediaString *string
	assetAttachedMediaStringFileName *string
	assetAttachedMediaStringContentType *string
	assetLocationDescription *string
	assetApp *string
	assetSearchTags *string
	assetLatitude *float64
	assetLongitude *float32
}

// The message the user wishes to leave a comment on
func (r ApiCreateNoteRequest) Comment(comment string) ApiCreateNoteRequest {
	r.comment = &comment
	return r
}

// The unique device identifier that made the request (either deviceId or accountId must be used)
func (r ApiCreateNoteRequest) DeviceId(deviceId string) ApiCreateNoteRequest {
	r.deviceId = &deviceId
	return r
}

// The unique accountId that made the request (either deviceId or accountId must be used)
func (r ApiCreateNoteRequest) AccountId(accountId int64) ApiCreateNoteRequest {
	r.accountId = &accountId
	return r
}

// The notable object type {ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, OFFER, OFFER_LOCATION, RETAILER, RETAILER_LOCATION, THEME_DESCRIPTOR}
func (r ApiCreateNoteRequest) NotableType(notableType string) ApiCreateNoteRequest {
	r.notableType = &notableType
	return r
}

// The id of the notable object
func (r ApiCreateNoteRequest) NotableId(notableId int64) ApiCreateNoteRequest {
	r.notableId = &notableId
	return r
}

// The custom string defined by the client (used for differentiating various note types)
func (r ApiCreateNoteRequest) NoteType(noteType string) ApiCreateNoteRequest {
	r.noteType = &noteType
	return r
}

// A comma separated list of asset IDs to add with the note
func (r ApiCreateNoteRequest) AssetIds(assetIds string) ApiCreateNoteRequest {
	r.assetIds = &assetIds
	return r
}

// search tags
func (r ApiCreateNoteRequest) Tags(tags string) ApiCreateNoteRequest {
	r.tags = &tags
	return r
}

// This is used for sending out group notifications. For example, when someone adds a note to an asset which is also a part of an album, everyone in the album will receive a notification. This is achieved by passing in the permissionable type (in this case \&quot;album\&quot;), and the permissionable id (the album id). Possible types: {ALBUM, ALBUM_CONTEST, GAME_LEVEL, THEME_DESCRIPTOR}
func (r ApiCreateNoteRequest) PermissionableType(permissionableType string) ApiCreateNoteRequest {
	r.permissionableType = &permissionableType
	return r
}

// The id of the permissionable object (for sending group notifications)
func (r ApiCreateNoteRequest) PermissionableId(permissionableId int64) ApiCreateNoteRequest {
	r.permissionableId = &permissionableId
	return r
}

// The application key used to identify the application
func (r ApiCreateNoteRequest) AppKey(appKey string) ApiCreateNoteRequest {
	r.appKey = &appKey
	return r
}

// The description of the location
func (r ApiCreateNoteRequest) LocationDescription(locationDescription string) ApiCreateNoteRequest {
	r.locationDescription = &locationDescription
	return r
}

// The current location of the user
func (r ApiCreateNoteRequest) Latitude(latitude float64) ApiCreateNoteRequest {
	r.latitude = &latitude
	return r
}

// The current location of the user
func (r ApiCreateNoteRequest) Longitude(longitude float64) ApiCreateNoteRequest {
	r.longitude = &longitude
	return r
}

// External custom client defined data
func (r ApiCreateNoteRequest) MetaData(metaData string) ApiCreateNoteRequest {
	r.metaData = &metaData
	return r
}

// Comma separated list of additional account IDs that will receive the note notifications
func (r ApiCreateNoteRequest) ReceiverAccountIds(receiverAccountIds string) ApiCreateNoteRequest {
	r.receiverAccountIds = &receiverAccountIds
	return r
}

// whether to return the full response or not
func (r ApiCreateNoteRequest) ReturnFullResponse(returnFullResponse bool) ApiCreateNoteRequest {
	r.returnFullResponse = &returnFullResponse
	return r
}

// Check true if need to initialize an asset and assign to current note
func (r ApiCreateNoteRequest) InitializeAsset(initializeAsset bool) ApiCreateNoteRequest {
	r.initializeAsset = &initializeAsset
	return r
}

// Return null fields for asset response when creating an asset
func (r ApiCreateNoteRequest) AssetReturnNulls(assetReturnNulls bool) ApiCreateNoteRequest {
	r.assetReturnNulls = &assetReturnNulls
	return r
}

// the album the asset will be added to (optional)
func (r ApiCreateNoteRequest) AssetAlbumId(assetAlbumId int64) ApiCreateNoteRequest {
	r.assetAlbumId = &assetAlbumId
	return r
}

// the collection ID that the asset is associated with
func (r ApiCreateNoteRequest) AssetCollectionId(assetCollectionId int64) ApiCreateNoteRequest {
	r.assetCollectionId = &assetCollectionId
	return r
}

// the default album to add the asset to
func (r ApiCreateNoteRequest) AssetAddToDefaultAlbum(assetAddToDefaultAlbum string) ApiCreateNoteRequest {
	r.assetAddToDefaultAlbum = &assetAddToDefaultAlbum
	return r
}

// the media library to add the asset to
func (r ApiCreateNoteRequest) AssetAddToMediaLibrary(assetAddToMediaLibrary bool) ApiCreateNoteRequest {
	r.assetAddToMediaLibrary = &assetAddToMediaLibrary
	return r
}

// the version code of the asset
func (r ApiCreateNoteRequest) AssetVersionCode(assetVersionCode int32) ApiCreateNoteRequest {
	r.assetVersionCode = &assetVersionCode
	return r
}

// the version name of the asset
func (r ApiCreateNoteRequest) AssetVersionName(assetVersionName string) ApiCreateNoteRequest {
	r.assetVersionName = &assetVersionName
	return r
}

// the meta data of the asset
func (r ApiCreateNoteRequest) AssetMetaData(assetMetaData string) ApiCreateNoteRequest {
	r.assetMetaData = &assetMetaData
	return r
}

// the caption of the asset
func (r ApiCreateNoteRequest) AssetCaption(assetCaption string) ApiCreateNoteRequest {
	r.assetCaption = &assetCaption
	return r
}

// the media of the asset
func (r ApiCreateNoteRequest) AssetMedia(assetMedia *os.File) ApiCreateNoteRequest {
	r.assetMedia = assetMedia
	return r
}

// the media URL of the asset
func (r ApiCreateNoteRequest) AssetMediaUrl(assetMediaUrl string) ApiCreateNoteRequest {
	r.assetMediaUrl = &assetMediaUrl
	return r
}

// the media string of the asset
func (r ApiCreateNoteRequest) AssetMediaString(assetMediaString string) ApiCreateNoteRequest {
	r.assetMediaString = &assetMediaString
	return r
}

// the media string file name of the asset
func (r ApiCreateNoteRequest) AssetMediaStringFileName(assetMediaStringFileName string) ApiCreateNoteRequest {
	r.assetMediaStringFileName = &assetMediaStringFileName
	return r
}

// the media string content type of the asset
func (r ApiCreateNoteRequest) AssetMediaStringContentType(assetMediaStringContentType string) ApiCreateNoteRequest {
	r.assetMediaStringContentType = &assetMediaStringContentType
	return r
}

// the attached media of the asset
func (r ApiCreateNoteRequest) AssetAttachedMedia(assetAttachedMedia *os.File) ApiCreateNoteRequest {
	r.assetAttachedMedia = assetAttachedMedia
	return r
}

// the attached media URL of the asset
func (r ApiCreateNoteRequest) AssetAttachedMediaUrl(assetAttachedMediaUrl string) ApiCreateNoteRequest {
	r.assetAttachedMediaUrl = &assetAttachedMediaUrl
	return r
}

// the attached media string of the asset
func (r ApiCreateNoteRequest) AssetAttachedMediaString(assetAttachedMediaString string) ApiCreateNoteRequest {
	r.assetAttachedMediaString = &assetAttachedMediaString
	return r
}

// the attached media string file name of the asset
func (r ApiCreateNoteRequest) AssetAttachedMediaStringFileName(assetAttachedMediaStringFileName string) ApiCreateNoteRequest {
	r.assetAttachedMediaStringFileName = &assetAttachedMediaStringFileName
	return r
}

// the attached media string content type of the asset
func (r ApiCreateNoteRequest) AssetAttachedMediaStringContentType(assetAttachedMediaStringContentType string) ApiCreateNoteRequest {
	r.assetAttachedMediaStringContentType = &assetAttachedMediaStringContentType
	return r
}

// the location description for the asset
func (r ApiCreateNoteRequest) AssetLocationDescription(assetLocationDescription string) ApiCreateNoteRequest {
	r.assetLocationDescription = &assetLocationDescription
	return r
}

// the application for the asset
func (r ApiCreateNoteRequest) AssetApp(assetApp string) ApiCreateNoteRequest {
	r.assetApp = &assetApp
	return r
}

// the search tags used for the asset
func (r ApiCreateNoteRequest) AssetSearchTags(assetSearchTags string) ApiCreateNoteRequest {
	r.assetSearchTags = &assetSearchTags
	return r
}

// the latitude of the asset
func (r ApiCreateNoteRequest) AssetLatitude(assetLatitude float64) ApiCreateNoteRequest {
	r.assetLatitude = &assetLatitude
	return r
}

// the longitude of the asset
func (r ApiCreateNoteRequest) AssetLongitude(assetLongitude float32) ApiCreateNoteRequest {
	r.assetLongitude = &assetLongitude
	return r
}

func (r ApiCreateNoteRequest) Execute() (*NoteResponse, *http.Response, error) {
	return r.ApiService.CreateNoteExecute(r)
}

/*
CreateNote Create Note

This is used to leave a comment (note) on a notable object (i.e. albums, album contests, assets, game levels, offers, offer locations, retailers, retailer locations, and theme descriptors). Leaving a comment on a notable object will be visiable to everyone who has access to view the object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiCreateNoteRequest
*/
func (a *NoteAPIService) CreateNote(ctx context.Context, version float32) ApiCreateNoteRequest {
	return ApiCreateNoteRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return NoteResponse
func (a *NoteAPIService) CreateNoteExecute(r ApiCreateNoteRequest) (*NoteResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NoteResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NoteAPIService.CreateNote")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/note/create"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.comment == nil {
		return localVarReturnValue, nil, reportError("comment is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.notableType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "notableType", r.notableType, "form", "")
	}
	if r.notableId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "notableId", r.notableId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "comment", r.comment, "form", "")
	if r.noteType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "noteType", r.noteType, "form", "")
	}
	if r.assetIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetIds", r.assetIds, "form", "")
	}
	if r.tags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tags", r.tags, "form", "")
	}
	if r.permissionableType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "permissionableType", r.permissionableType, "form", "")
	}
	if r.permissionableId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "permissionableId", r.permissionableId, "form", "")
	}
	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	if r.locationDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locationDescription", r.locationDescription, "form", "")
	}
	if r.latitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latitude", r.latitude, "form", "")
	}
	if r.longitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "longitude", r.longitude, "form", "")
	}
	if r.metaData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metaData", r.metaData, "form", "")
	}
	if r.receiverAccountIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "receiverAccountIds", r.receiverAccountIds, "form", "")
	}
	if r.returnFullResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnFullResponse", r.returnFullResponse, "form", "")
	}
	if r.initializeAsset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "initializeAsset", r.initializeAsset, "form", "")
	}
	if r.assetReturnNulls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetReturnNulls", r.assetReturnNulls, "form", "")
	}
	if r.assetAlbumId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetAlbumId", r.assetAlbumId, "form", "")
	}
	if r.assetCollectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetCollectionId", r.assetCollectionId, "form", "")
	}
	if r.assetAddToDefaultAlbum != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetAddToDefaultAlbum", r.assetAddToDefaultAlbum, "form", "")
	}
	if r.assetAddToMediaLibrary != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetAddToMediaLibrary", r.assetAddToMediaLibrary, "form", "")
	}
	if r.assetVersionCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetVersionCode", r.assetVersionCode, "form", "")
	}
	if r.assetVersionName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetVersionName", r.assetVersionName, "form", "")
	}
	if r.assetMetaData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetMetaData", r.assetMetaData, "form", "")
	}
	if r.assetCaption != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetCaption", r.assetCaption, "form", "")
	}
	if r.assetMedia != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetMedia", r.assetMedia, "form", "")
	}
	if r.assetMediaUrl != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetMediaUrl", r.assetMediaUrl, "form", "")
	}
	if r.assetMediaString != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetMediaString", r.assetMediaString, "form", "")
	}
	if r.assetMediaStringFileName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetMediaStringFileName", r.assetMediaStringFileName, "form", "")
	}
	if r.assetMediaStringContentType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetMediaStringContentType", r.assetMediaStringContentType, "form", "")
	}
	if r.assetAttachedMedia != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetAttachedMedia", r.assetAttachedMedia, "form", "")
	}
	if r.assetAttachedMediaUrl != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetAttachedMediaUrl", r.assetAttachedMediaUrl, "form", "")
	}
	if r.assetAttachedMediaString != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetAttachedMediaString", r.assetAttachedMediaString, "form", "")
	}
	if r.assetAttachedMediaStringFileName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetAttachedMediaStringFileName", r.assetAttachedMediaStringFileName, "form", "")
	}
	if r.assetAttachedMediaStringContentType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetAttachedMediaStringContentType", r.assetAttachedMediaStringContentType, "form", "")
	}
	if r.assetLocationDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetLocationDescription", r.assetLocationDescription, "form", "")
	}
	if r.assetApp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetApp", r.assetApp, "form", "")
	}
	if r.assetSearchTags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetSearchTags", r.assetSearchTags, "form", "")
	}
	if r.assetLatitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetLatitude", r.assetLatitude, "form", "")
	}
	if r.assetLongitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetLongitude", r.assetLongitude, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteNoteRequest struct {
	ctx context.Context
	ApiService *NoteAPIService
	version float32
	noteId *int64
	deviceId *string
	accountId *int64
	latitude *float64
	longitude *float64
	appKey *string
}

// The ID of the note to delete
func (r ApiDeleteNoteRequest) NoteId(noteId int64) ApiDeleteNoteRequest {
	r.noteId = &noteId
	return r
}

// The unique device identifier that made the request (either deviceId or accountId must be used)
func (r ApiDeleteNoteRequest) DeviceId(deviceId string) ApiDeleteNoteRequest {
	r.deviceId = &deviceId
	return r
}

// The unique accountId that made the request (either deviceId or accountId must be used)
func (r ApiDeleteNoteRequest) AccountId(accountId int64) ApiDeleteNoteRequest {
	r.accountId = &accountId
	return r
}

// The current location of the user
func (r ApiDeleteNoteRequest) Latitude(latitude float64) ApiDeleteNoteRequest {
	r.latitude = &latitude
	return r
}

// The current location of the user
func (r ApiDeleteNoteRequest) Longitude(longitude float64) ApiDeleteNoteRequest {
	r.longitude = &longitude
	return r
}

// The application key used to identify the application
func (r ApiDeleteNoteRequest) AppKey(appKey string) ApiDeleteNoteRequest {
	r.appKey = &appKey
	return r
}

func (r ApiDeleteNoteRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.DeleteNoteExecute(r)
}

/*
DeleteNote Delete Note

Sets a comment (note) as deleted.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiDeleteNoteRequest
*/
func (a *NoteAPIService) DeleteNote(ctx context.Context, version float32) ApiDeleteNoteRequest {
	return ApiDeleteNoteRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *NoteAPIService) DeleteNoteExecute(r ApiDeleteNoteRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NoteAPIService.DeleteNote")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/note/delete"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.noteId == nil {
		return localVarReturnValue, nil, reportError("noteId is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "noteId", r.noteId, "form", "")
	if r.latitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latitude", r.latitude, "form", "")
	}
	if r.longitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "longitude", r.longitude, "form", "")
	}
	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNoteRequest struct {
	ctx context.Context
	ApiService *NoteAPIService
	version float32
	noteId *int64
	deviceId *string
	accountId *int64
	returnFullResponse *bool
}

// the id of the note to get
func (r ApiGetNoteRequest) NoteId(noteId int64) ApiGetNoteRequest {
	r.noteId = &noteId
	return r
}

// The unique device identifier that made the request (either deviceId or accountId must be used)
func (r ApiGetNoteRequest) DeviceId(deviceId string) ApiGetNoteRequest {
	r.deviceId = &deviceId
	return r
}

// The unique accountId that made the request (either deviceId or accountId must be used)
func (r ApiGetNoteRequest) AccountId(accountId int64) ApiGetNoteRequest {
	r.accountId = &accountId
	return r
}

// Determines whether to return the NoteFullResponse for the item
func (r ApiGetNoteRequest) ReturnFullResponse(returnFullResponse bool) ApiGetNoteRequest {
	r.returnFullResponse = &returnFullResponse
	return r
}

func (r ApiGetNoteRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.GetNoteExecute(r)
}

/*
GetNote Get Note

Get for a note based on its Id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiGetNoteRequest
*/
func (a *NoteAPIService) GetNote(ctx context.Context, version float32) ApiGetNoteRequest {
	return ApiGetNoteRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *NoteAPIService) GetNoteExecute(r ApiGetNoteRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NoteAPIService.GetNote")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/note/get"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.noteId == nil {
		return localVarReturnValue, nil, reportError("noteId is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.returnFullResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnFullResponse", r.returnFullResponse, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "noteId", r.noteId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchNotesRequest struct {
	ctx context.Context
	ApiService *NoteAPIService
	version float32
	deviceId *string
	accountId *int64
	notableType *string
	notableId *int64
	noteTypes *string
	appKey *string
	keyword *string
	flagCountMinimum *int64
	flagsExceedThreshold *bool
	includeInactive *bool
	sortField *string
	descending *bool
	returnFullResponse *bool
	updatedSince *int64
	updatedBefore *int64
	start *int32
	limit *int32
}

// The device id (deviceId or accountId required)
func (r ApiSearchNotesRequest) DeviceId(deviceId string) ApiSearchNotesRequest {
	r.deviceId = &deviceId
	return r
}

// The account id of the user (deviceId or accountId required)
func (r ApiSearchNotesRequest) AccountId(accountId int64) ApiSearchNotesRequest {
	r.accountId = &accountId
	return r
}

// The notable object type {ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, OFFER, OFFER_LOCATION, RETAILER, RETAILER_LOCATION, THEME_DESCRIPTOR}
func (r ApiSearchNotesRequest) NotableType(notableType string) ApiSearchNotesRequest {
	r.notableType = &notableType
	return r
}

// The id of the notable object
func (r ApiSearchNotesRequest) NotableId(notableId int64) ApiSearchNotesRequest {
	r.notableId = &notableId
	return r
}

// Comma separated list of noteType strings to filter results with
func (r ApiSearchNotesRequest) NoteTypes(noteTypes string) ApiSearchNotesRequest {
	r.noteTypes = &noteTypes
	return r
}

// The application key used to identify the application
func (r ApiSearchNotesRequest) AppKey(appKey string) ApiSearchNotesRequest {
	r.appKey = &appKey
	return r
}

// The keyword used to search
func (r ApiSearchNotesRequest) Keyword(keyword string) ApiSearchNotesRequest {
	r.keyword = &keyword
	return r
}

// return items that has flagCount &gt;&#x3D; flagCountMinimum if this is set, return all items, even ones with flagCount &gt;&#x3D; flagThreshold
func (r ApiSearchNotesRequest) FlagCountMinimum(flagCountMinimum int64) ApiSearchNotesRequest {
	r.flagCountMinimum = &flagCountMinimum
	return r
}

// return items that has flagCount &gt;&#x3D; flagThreshold, which are hidden by default
func (r ApiSearchNotesRequest) FlagsExceedThreshold(flagsExceedThreshold bool) ApiSearchNotesRequest {
	r.flagsExceedThreshold = &flagsExceedThreshold
	return r
}

// include inactive in the result
func (r ApiSearchNotesRequest) IncludeInactive(includeInactive bool) ApiSearchNotesRequest {
	r.includeInactive = &includeInactive
	return r
}

// The column to sort the search on
func (r ApiSearchNotesRequest) SortField(sortField string) ApiSearchNotesRequest {
	r.sortField = &sortField
	return r
}

// The order to return the search results
func (r ApiSearchNotesRequest) Descending(descending bool) ApiSearchNotesRequest {
	r.descending = &descending
	return r
}

// Determines whether to return the NoteFullResponse for each search item
func (r ApiSearchNotesRequest) ReturnFullResponse(returnFullResponse bool) ApiSearchNotesRequest {
	r.returnFullResponse = &returnFullResponse
	return r
}

// return items that have been updated since this date (time-stamp in milliseconds)
func (r ApiSearchNotesRequest) UpdatedSince(updatedSince int64) ApiSearchNotesRequest {
	r.updatedSince = &updatedSince
	return r
}

// return items that have been updated before this date (time-stamp in milliseconds)
func (r ApiSearchNotesRequest) UpdatedBefore(updatedBefore int64) ApiSearchNotesRequest {
	r.updatedBefore = &updatedBefore
	return r
}

// The record to begin the return set on
func (r ApiSearchNotesRequest) Start(start int32) ApiSearchNotesRequest {
	r.start = &start
	return r
}

// The number of records to return
func (r ApiSearchNotesRequest) Limit(limit int32) ApiSearchNotesRequest {
	r.limit = &limit
	return r
}

func (r ApiSearchNotesRequest) Execute() ([]NoteResponse, *http.Response, error) {
	return r.ApiService.SearchNotesExecute(r)
}

/*
SearchNotes Search Notes

Search for notes on a notable object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiSearchNotesRequest
*/
func (a *NoteAPIService) SearchNotes(ctx context.Context, version float32) ApiSearchNotesRequest {
	return ApiSearchNotesRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return []NoteResponse
func (a *NoteAPIService) SearchNotesExecute(r ApiSearchNotesRequest) ([]NoteResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []NoteResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NoteAPIService.SearchNotes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/note/search"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.notableType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "notableType", r.notableType, "form", "")
	}
	if r.notableId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "notableId", r.notableId, "form", "")
	}
	if r.noteTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "noteTypes", r.noteTypes, "form", "")
	}
	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	if r.keyword != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyword", r.keyword, "form", "")
	}
	if r.flagCountMinimum != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flagCountMinimum", r.flagCountMinimum, "form", "")
	}
	if r.flagsExceedThreshold != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flagsExceedThreshold", r.flagsExceedThreshold, "form", "")
	}
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "form", "")
	}
	if r.sortField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", r.sortField, "form", "")
	}
	if r.descending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "form", "")
	}
	if r.returnFullResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnFullResponse", r.returnFullResponse, "form", "")
	}
	if r.updatedSince != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedSince", r.updatedSince, "form", "")
	}
	if r.updatedBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedBefore", r.updatedBefore, "form", "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateNoteRequest struct {
	ctx context.Context
	ApiService *NoteAPIService
	version float32
	noteId *int64
	deviceId *string
	accountId *int64
	comment *string
	noteType *string
	assetIds *string
	tags *string
	permissionableType *string
	permissionableId *int64
	appKey *string
	locationDescription *string
	latitude *float64
	longitude *float64
	metaData *string
	returnFullResponse *bool
	active *bool
	updateAsset *bool
	assetReturnNulls *bool
	assetAlbumId *int64
	assetCollectionId *int64
	assetAddToDefaultAlbum *string
	assetAddToMediaLibrary *bool
	assetVersionCode *int32
	assetVersionName *string
	assetMetaData *string
	assetCaption *string
	assetMedia *os.File
	assetMediaUrl *string
	assetMediaString *string
	assetMediaStringFileName *string
	assetMediaStringContentType *string
	assetAttachedMedia *os.File
	assetAttachedMediaUrl *string
	assetAttachedMediaString *string
	assetAttachedMediaStringFileName *string
	assetAttachedMediaStringContentType *string
	assetLocationDescription *string
	assetApp *string
	assetSearchTags *string
	assetLatitude *float64
	assetLongitude *float64
}

// The id of the note, used when editing a comment
func (r ApiUpdateNoteRequest) NoteId(noteId int64) ApiUpdateNoteRequest {
	r.noteId = &noteId
	return r
}

// The unique device identifier that made the request (either deviceId or accountId must be used)
func (r ApiUpdateNoteRequest) DeviceId(deviceId string) ApiUpdateNoteRequest {
	r.deviceId = &deviceId
	return r
}

// The unique accountId that made the request (either deviceId or accountId must be used)
func (r ApiUpdateNoteRequest) AccountId(accountId int64) ApiUpdateNoteRequest {
	r.accountId = &accountId
	return r
}

// The message the user wishes to leave a comment on
func (r ApiUpdateNoteRequest) Comment(comment string) ApiUpdateNoteRequest {
	r.comment = &comment
	return r
}

// The custom string defined by the client (used for differentiating on various note types)
func (r ApiUpdateNoteRequest) NoteType(noteType string) ApiUpdateNoteRequest {
	r.noteType = &noteType
	return r
}

// A comma separated list of asset IDs to add with the note
func (r ApiUpdateNoteRequest) AssetIds(assetIds string) ApiUpdateNoteRequest {
	r.assetIds = &assetIds
	return r
}

// search tags
func (r ApiUpdateNoteRequest) Tags(tags string) ApiUpdateNoteRequest {
	r.tags = &tags
	return r
}

// This is used for sending out group notifications. For example, when someone adds a note to an asset which is also a part of an album, everyone in the album will receive a notification. This is achieved by passing in the permissionable type (in this case \&quot;album\&quot;), and the permissionable id (the album id). Possible types: {ALBUM, ALBUM_CONTEST, GAME_LEVEL, THEME_DESCRIPTOR}
func (r ApiUpdateNoteRequest) PermissionableType(permissionableType string) ApiUpdateNoteRequest {
	r.permissionableType = &permissionableType
	return r
}

// The id of the permissionable object (for sending group notifications)
func (r ApiUpdateNoteRequest) PermissionableId(permissionableId int64) ApiUpdateNoteRequest {
	r.permissionableId = &permissionableId
	return r
}

// The application key used to identify the application
func (r ApiUpdateNoteRequest) AppKey(appKey string) ApiUpdateNoteRequest {
	r.appKey = &appKey
	return r
}

// The description of the location
func (r ApiUpdateNoteRequest) LocationDescription(locationDescription string) ApiUpdateNoteRequest {
	r.locationDescription = &locationDescription
	return r
}

// The current location of the user
func (r ApiUpdateNoteRequest) Latitude(latitude float64) ApiUpdateNoteRequest {
	r.latitude = &latitude
	return r
}

// The current location of the user
func (r ApiUpdateNoteRequest) Longitude(longitude float64) ApiUpdateNoteRequest {
	r.longitude = &longitude
	return r
}

// meta data to update with the note
func (r ApiUpdateNoteRequest) MetaData(metaData string) ApiUpdateNoteRequest {
	r.metaData = &metaData
	return r
}

// whether to return the full response or not
func (r ApiUpdateNoteRequest) ReturnFullResponse(returnFullResponse bool) ApiUpdateNoteRequest {
	r.returnFullResponse = &returnFullResponse
	return r
}

// Sets the active flag for the note
func (r ApiUpdateNoteRequest) Active(active bool) ApiUpdateNoteRequest {
	r.active = &active
	return r
}

// main flag for updating asset in note, must set to true if you want to update the note&#39;s asset
func (r ApiUpdateNoteRequest) UpdateAsset(updateAsset bool) ApiUpdateNoteRequest {
	r.updateAsset = &updateAsset
	return r
}

// Return null fields for asset response when updating an asset
func (r ApiUpdateNoteRequest) AssetReturnNulls(assetReturnNulls bool) ApiUpdateNoteRequest {
	r.assetReturnNulls = &assetReturnNulls
	return r
}

// the album the asset will be added to (optional)
func (r ApiUpdateNoteRequest) AssetAlbumId(assetAlbumId int64) ApiUpdateNoteRequest {
	r.assetAlbumId = &assetAlbumId
	return r
}

// the collection ID that the asset is associated with
func (r ApiUpdateNoteRequest) AssetCollectionId(assetCollectionId int64) ApiUpdateNoteRequest {
	r.assetCollectionId = &assetCollectionId
	return r
}

// the default album to add the asset to
func (r ApiUpdateNoteRequest) AssetAddToDefaultAlbum(assetAddToDefaultAlbum string) ApiUpdateNoteRequest {
	r.assetAddToDefaultAlbum = &assetAddToDefaultAlbum
	return r
}

// the media library to add the asset to
func (r ApiUpdateNoteRequest) AssetAddToMediaLibrary(assetAddToMediaLibrary bool) ApiUpdateNoteRequest {
	r.assetAddToMediaLibrary = &assetAddToMediaLibrary
	return r
}

// the version code of the asset
func (r ApiUpdateNoteRequest) AssetVersionCode(assetVersionCode int32) ApiUpdateNoteRequest {
	r.assetVersionCode = &assetVersionCode
	return r
}

// the version name of the asset
func (r ApiUpdateNoteRequest) AssetVersionName(assetVersionName string) ApiUpdateNoteRequest {
	r.assetVersionName = &assetVersionName
	return r
}

// the meta data of the asset
func (r ApiUpdateNoteRequest) AssetMetaData(assetMetaData string) ApiUpdateNoteRequest {
	r.assetMetaData = &assetMetaData
	return r
}

// the caption of the asset
func (r ApiUpdateNoteRequest) AssetCaption(assetCaption string) ApiUpdateNoteRequest {
	r.assetCaption = &assetCaption
	return r
}

// the media of the asset
func (r ApiUpdateNoteRequest) AssetMedia(assetMedia *os.File) ApiUpdateNoteRequest {
	r.assetMedia = assetMedia
	return r
}

// the media URL of the asset
func (r ApiUpdateNoteRequest) AssetMediaUrl(assetMediaUrl string) ApiUpdateNoteRequest {
	r.assetMediaUrl = &assetMediaUrl
	return r
}

// the media string of the asset
func (r ApiUpdateNoteRequest) AssetMediaString(assetMediaString string) ApiUpdateNoteRequest {
	r.assetMediaString = &assetMediaString
	return r
}

// the media string file name of the asset
func (r ApiUpdateNoteRequest) AssetMediaStringFileName(assetMediaStringFileName string) ApiUpdateNoteRequest {
	r.assetMediaStringFileName = &assetMediaStringFileName
	return r
}

// the media string content type of the asset
func (r ApiUpdateNoteRequest) AssetMediaStringContentType(assetMediaStringContentType string) ApiUpdateNoteRequest {
	r.assetMediaStringContentType = &assetMediaStringContentType
	return r
}

// the attached media of the asset
func (r ApiUpdateNoteRequest) AssetAttachedMedia(assetAttachedMedia *os.File) ApiUpdateNoteRequest {
	r.assetAttachedMedia = assetAttachedMedia
	return r
}

// the attached media URL of the asset
func (r ApiUpdateNoteRequest) AssetAttachedMediaUrl(assetAttachedMediaUrl string) ApiUpdateNoteRequest {
	r.assetAttachedMediaUrl = &assetAttachedMediaUrl
	return r
}

// the attached media string of the asset
func (r ApiUpdateNoteRequest) AssetAttachedMediaString(assetAttachedMediaString string) ApiUpdateNoteRequest {
	r.assetAttachedMediaString = &assetAttachedMediaString
	return r
}

// the attached media string file name of the asset
func (r ApiUpdateNoteRequest) AssetAttachedMediaStringFileName(assetAttachedMediaStringFileName string) ApiUpdateNoteRequest {
	r.assetAttachedMediaStringFileName = &assetAttachedMediaStringFileName
	return r
}

// the attached media string content type of the asset
func (r ApiUpdateNoteRequest) AssetAttachedMediaStringContentType(assetAttachedMediaStringContentType string) ApiUpdateNoteRequest {
	r.assetAttachedMediaStringContentType = &assetAttachedMediaStringContentType
	return r
}

// the location description for the asset
func (r ApiUpdateNoteRequest) AssetLocationDescription(assetLocationDescription string) ApiUpdateNoteRequest {
	r.assetLocationDescription = &assetLocationDescription
	return r
}

// the application for the asset
func (r ApiUpdateNoteRequest) AssetApp(assetApp string) ApiUpdateNoteRequest {
	r.assetApp = &assetApp
	return r
}

// the search tags used for the asset
func (r ApiUpdateNoteRequest) AssetSearchTags(assetSearchTags string) ApiUpdateNoteRequest {
	r.assetSearchTags = &assetSearchTags
	return r
}

// the latitude of the asset
func (r ApiUpdateNoteRequest) AssetLatitude(assetLatitude float64) ApiUpdateNoteRequest {
	r.assetLatitude = &assetLatitude
	return r
}

// the longitude of the asset
func (r ApiUpdateNoteRequest) AssetLongitude(assetLongitude float64) ApiUpdateNoteRequest {
	r.assetLongitude = &assetLongitude
	return r
}

func (r ApiUpdateNoteRequest) Execute() (*NoteResponse, *http.Response, error) {
	return r.ApiService.UpdateNoteExecute(r)
}

/*
UpdateNote Update Note

Update an existing comment (note). Only the creator of the note have permission to update.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiUpdateNoteRequest
*/
func (a *NoteAPIService) UpdateNote(ctx context.Context, version float32) ApiUpdateNoteRequest {
	return ApiUpdateNoteRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return NoteResponse
func (a *NoteAPIService) UpdateNoteExecute(r ApiUpdateNoteRequest) (*NoteResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NoteResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NoteAPIService.UpdateNote")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/note/update"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.noteId == nil {
		return localVarReturnValue, nil, reportError("noteId is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "noteId", r.noteId, "form", "")
	if r.comment != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "comment", r.comment, "form", "")
	}
	if r.noteType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "noteType", r.noteType, "form", "")
	}
	if r.assetIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetIds", r.assetIds, "form", "")
	}
	if r.tags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tags", r.tags, "form", "")
	}
	if r.permissionableType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "permissionableType", r.permissionableType, "form", "")
	}
	if r.permissionableId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "permissionableId", r.permissionableId, "form", "")
	}
	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	if r.locationDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locationDescription", r.locationDescription, "form", "")
	}
	if r.latitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latitude", r.latitude, "form", "")
	}
	if r.longitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "longitude", r.longitude, "form", "")
	}
	if r.metaData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metaData", r.metaData, "form", "")
	}
	if r.returnFullResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnFullResponse", r.returnFullResponse, "form", "")
	}
	if r.active != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active", r.active, "form", "")
	}
	if r.updateAsset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateAsset", r.updateAsset, "form", "")
	}
	if r.assetReturnNulls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetReturnNulls", r.assetReturnNulls, "form", "")
	}
	if r.assetAlbumId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetAlbumId", r.assetAlbumId, "form", "")
	}
	if r.assetCollectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetCollectionId", r.assetCollectionId, "form", "")
	}
	if r.assetAddToDefaultAlbum != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetAddToDefaultAlbum", r.assetAddToDefaultAlbum, "form", "")
	}
	if r.assetAddToMediaLibrary != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetAddToMediaLibrary", r.assetAddToMediaLibrary, "form", "")
	}
	if r.assetVersionCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetVersionCode", r.assetVersionCode, "form", "")
	}
	if r.assetVersionName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetVersionName", r.assetVersionName, "form", "")
	}
	if r.assetMetaData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetMetaData", r.assetMetaData, "form", "")
	}
	if r.assetCaption != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetCaption", r.assetCaption, "form", "")
	}
	if r.assetMedia != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetMedia", r.assetMedia, "form", "")
	}
	if r.assetMediaUrl != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetMediaUrl", r.assetMediaUrl, "form", "")
	}
	if r.assetMediaString != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetMediaString", r.assetMediaString, "form", "")
	}
	if r.assetMediaStringFileName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetMediaStringFileName", r.assetMediaStringFileName, "form", "")
	}
	if r.assetMediaStringContentType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetMediaStringContentType", r.assetMediaStringContentType, "form", "")
	}
	if r.assetAttachedMedia != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetAttachedMedia", r.assetAttachedMedia, "form", "")
	}
	if r.assetAttachedMediaUrl != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetAttachedMediaUrl", r.assetAttachedMediaUrl, "form", "")
	}
	if r.assetAttachedMediaString != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetAttachedMediaString", r.assetAttachedMediaString, "form", "")
	}
	if r.assetAttachedMediaStringFileName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetAttachedMediaStringFileName", r.assetAttachedMediaStringFileName, "form", "")
	}
	if r.assetAttachedMediaStringContentType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetAttachedMediaStringContentType", r.assetAttachedMediaStringContentType, "form", "")
	}
	if r.assetLocationDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetLocationDescription", r.assetLocationDescription, "form", "")
	}
	if r.assetApp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetApp", r.assetApp, "form", "")
	}
	if r.assetSearchTags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetSearchTags", r.assetSearchTags, "form", "")
	}
	if r.assetLatitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetLatitude", r.assetLatitude, "form", "")
	}
	if r.assetLongitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetLongitude", r.assetLongitude, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
