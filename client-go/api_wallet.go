/*
Sirqul IoT Platform

Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

API version: 3.16
Contact: info@sirqul.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// WalletAPIService WalletAPI service
type WalletAPIService service

type ApiCreateOfferTransactionRequest struct {
	ctx context.Context
	ApiService *WalletAPIService
	deviceId *string
	accountId *int64
	offerId *int64
	offerLocationId *int64
	offerCart *string
	promoCode *string
	currencyType *string
	usePoints *bool
	metaData *string
	appKey *string
	status *int32
}

// The device id (deviceId or accountId required)
func (r ApiCreateOfferTransactionRequest) DeviceId(deviceId string) ApiCreateOfferTransactionRequest {
	r.deviceId = &deviceId
	return r
}

// The account id of the user (deviceId or accountId required)
func (r ApiCreateOfferTransactionRequest) AccountId(accountId int64) ApiCreateOfferTransactionRequest {
	r.accountId = &accountId
	return r
}

// The id of the offer being added (offerId or offeLocationId required)
func (r ApiCreateOfferTransactionRequest) OfferId(offerId int64) ApiCreateOfferTransactionRequest {
	r.offerId = &offerId
	return r
}

// The id of the offer location being added (offerId or offeLocationId required)
func (r ApiCreateOfferTransactionRequest) OfferLocationId(offerLocationId int64) ApiCreateOfferTransactionRequest {
	r.offerLocationId = &offerLocationId
	return r
}

// A JSON list of offers to purchase. &#x60;&#x60;&#x60;json [   {     \&quot;offerId\&quot;: 123,     \&quot;offerLocationId\&quot;: 234,     \&quot;quantity\&quot;: 2   },   {     \&quot;offerId\&quot;: 456,     \&quot;offerLocationId\&quot;: 567,     \&quot;quantity\&quot;: 1   } ] &#x60;&#x60;&#x60; 
func (r ApiCreateOfferTransactionRequest) OfferCart(offerCart string) ApiCreateOfferTransactionRequest {
	r.offerCart = &offerCart
	return r
}

// The promoCode
func (r ApiCreateOfferTransactionRequest) PromoCode(promoCode string) ApiCreateOfferTransactionRequest {
	r.promoCode = &promoCode
	return r
}

// Determines the method of purchasing offer. CASH &#x3D; use card on file, POINTS &#x3D; use points, TICKETS &#x3D; use tickets
func (r ApiCreateOfferTransactionRequest) CurrencyType(currencyType string) ApiCreateOfferTransactionRequest {
	r.currencyType = &currencyType
	return r
}

// Sets the currencyType to POINTS
// Deprecated
func (r ApiCreateOfferTransactionRequest) UsePoints(usePoints bool) ApiCreateOfferTransactionRequest {
	r.usePoints = &usePoints
	return r
}

// External custom client defined data
func (r ApiCreateOfferTransactionRequest) MetaData(metaData string) ApiCreateOfferTransactionRequest {
	r.metaData = &metaData
	return r
}

// The application requesting the purchase, required when currencyType is TICKETS
func (r ApiCreateOfferTransactionRequest) AppKey(appKey string) ApiCreateOfferTransactionRequest {
	r.appKey = &appKey
	return r
}

// Custom status value to change to (0 or 1 for redeem, 5 or 6 for membership)
func (r ApiCreateOfferTransactionRequest) Status(status int32) ApiCreateOfferTransactionRequest {
	r.status = &status
	return r
}

func (r ApiCreateOfferTransactionRequest) Execute() ([]OfferTransactionResponse, *http.Response, error) {
	return r.ApiService.CreateOfferTransactionExecute(r)
}

/*
CreateOfferTransaction Create Wallet Offers

Adds offers to the wallet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateOfferTransactionRequest
*/
func (a *WalletAPIService) CreateOfferTransaction(ctx context.Context) ApiCreateOfferTransactionRequest {
	return ApiCreateOfferTransactionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []OfferTransactionResponse
func (a *WalletAPIService) CreateOfferTransactionExecute(r ApiCreateOfferTransactionRequest) ([]OfferTransactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []OfferTransactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletAPIService.CreateOfferTransaction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wallet/create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.offerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offerId", r.offerId, "form", "")
	}
	if r.offerLocationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offerLocationId", r.offerLocationId, "form", "")
	}
	if r.offerCart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offerCart", r.offerCart, "form", "")
	}
	if r.promoCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "promoCode", r.promoCode, "form", "")
	}
	if r.currencyType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currencyType", r.currencyType, "form", "")
	} else {
		var defaultValue string = "CASH"
		parameterAddToHeaderOrQuery(localVarQueryParams, "currencyType", defaultValue, "form", "")
		r.currencyType = &defaultValue
	}
	if r.usePoints != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usePoints", r.usePoints, "form", "")
	}
	if r.metaData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metaData", r.metaData, "form", "")
	}
	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteOfferTransactionRequest struct {
	ctx context.Context
	ApiService *WalletAPIService
	transactionId *int64
	deviceId *string
	accountId *int64
}

// The offer transaction id to remove
func (r ApiDeleteOfferTransactionRequest) TransactionId(transactionId int64) ApiDeleteOfferTransactionRequest {
	r.transactionId = &transactionId
	return r
}

// The device id (deviceId or accountId required)
func (r ApiDeleteOfferTransactionRequest) DeviceId(deviceId string) ApiDeleteOfferTransactionRequest {
	r.deviceId = &deviceId
	return r
}

// The account id of the user (deviceId or accountId required)
func (r ApiDeleteOfferTransactionRequest) AccountId(accountId int64) ApiDeleteOfferTransactionRequest {
	r.accountId = &accountId
	return r
}

func (r ApiDeleteOfferTransactionRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.DeleteOfferTransactionExecute(r)
}

/*
DeleteOfferTransaction Delete Wallet Offer

Removes the transaction from the wallet by setting the deleted date to the current date/time.  Requires a valid account and transactionId.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteOfferTransactionRequest
*/
func (a *WalletAPIService) DeleteOfferTransaction(ctx context.Context) ApiDeleteOfferTransactionRequest {
	return ApiDeleteOfferTransactionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *WalletAPIService) DeleteOfferTransactionExecute(r ApiDeleteOfferTransactionRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletAPIService.DeleteOfferTransaction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wallet/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.transactionId == nil {
		return localVarReturnValue, nil, reportError("transactionId is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "transactionId", r.transactionId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOfferTransactionRequest struct {
	ctx context.Context
	ApiService *WalletAPIService
	transactionId *int64
	deviceId *string
	accountId *int64
	includeMission *bool
	latitude *float64
	longitude *float64
	returnFullResponse *bool
}

// The offer transaction id to get details of
func (r ApiGetOfferTransactionRequest) TransactionId(transactionId int64) ApiGetOfferTransactionRequest {
	r.transactionId = &transactionId
	return r
}

// The device id (deviceId or accountId required)
func (r ApiGetOfferTransactionRequest) DeviceId(deviceId string) ApiGetOfferTransactionRequest {
	r.deviceId = &deviceId
	return r
}

// The account id of the user (deviceId or accountId required)
func (r ApiGetOfferTransactionRequest) AccountId(accountId int64) ApiGetOfferTransactionRequest {
	r.accountId = &accountId
	return r
}

// If true then include mission data, false to not include
func (r ApiGetOfferTransactionRequest) IncludeMission(includeMission bool) ApiGetOfferTransactionRequest {
	r.includeMission = &includeMission
	return r
}

// The latitude location of the user
func (r ApiGetOfferTransactionRequest) Latitude(latitude float64) ApiGetOfferTransactionRequest {
	r.latitude = &latitude
	return r
}

// The latitude location of the user
func (r ApiGetOfferTransactionRequest) Longitude(longitude float64) ApiGetOfferTransactionRequest {
	r.longitude = &longitude
	return r
}

// Determines whether to return a detailed version of the response
func (r ApiGetOfferTransactionRequest) ReturnFullResponse(returnFullResponse bool) ApiGetOfferTransactionRequest {
	r.returnFullResponse = &returnFullResponse
	return r
}

func (r ApiGetOfferTransactionRequest) Execute() (*OfferTransactionResponse, *http.Response, error) {
	return r.ApiService.GetOfferTransactionExecute(r)
}

/*
GetOfferTransaction Get Wallet Offer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetOfferTransactionRequest
*/
func (a *WalletAPIService) GetOfferTransaction(ctx context.Context) ApiGetOfferTransactionRequest {
	return ApiGetOfferTransactionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return OfferTransactionResponse
func (a *WalletAPIService) GetOfferTransactionExecute(r ApiGetOfferTransactionRequest) (*OfferTransactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OfferTransactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletAPIService.GetOfferTransaction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wallet/get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.transactionId == nil {
		return localVarReturnValue, nil, reportError("transactionId is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "transactionId", r.transactionId, "form", "")
	if r.includeMission != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeMission", r.includeMission, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeMission", defaultValue, "form", "")
		r.includeMission = &defaultValue
	}
	if r.latitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latitude", r.latitude, "form", "")
	}
	if r.longitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "longitude", r.longitude, "form", "")
	}
	if r.returnFullResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnFullResponse", r.returnFullResponse, "form", "")
	} else {
		var defaultValue bool = true
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnFullResponse", defaultValue, "form", "")
		r.returnFullResponse = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPreviewOfferTransactionRequest struct {
	ctx context.Context
	ApiService *WalletAPIService
	deviceId *string
	accountId *int64
	offerId *int64
	offerLocationId *int64
	offerCart *string
	promoCode *string
	currencyType *string
	usePoints *bool
	metaData *string
	appKey *string
}

// The device id (deviceId or accountId required)
func (r ApiPreviewOfferTransactionRequest) DeviceId(deviceId string) ApiPreviewOfferTransactionRequest {
	r.deviceId = &deviceId
	return r
}

// The account id of the user (deviceId or accountId required)
func (r ApiPreviewOfferTransactionRequest) AccountId(accountId int64) ApiPreviewOfferTransactionRequest {
	r.accountId = &accountId
	return r
}

// The id of the offer being added (offerId or offeLocationId required)
func (r ApiPreviewOfferTransactionRequest) OfferId(offerId int64) ApiPreviewOfferTransactionRequest {
	r.offerId = &offerId
	return r
}

// The id of the offer location being added (offerId or offeLocationId required)
func (r ApiPreviewOfferTransactionRequest) OfferLocationId(offerLocationId int64) ApiPreviewOfferTransactionRequest {
	r.offerLocationId = &offerLocationId
	return r
}

// A JSON list of offers to purchase.
func (r ApiPreviewOfferTransactionRequest) OfferCart(offerCart string) ApiPreviewOfferTransactionRequest {
	r.offerCart = &offerCart
	return r
}

// The promoCode
func (r ApiPreviewOfferTransactionRequest) PromoCode(promoCode string) ApiPreviewOfferTransactionRequest {
	r.promoCode = &promoCode
	return r
}

// Determines the method of purchasing offer. CASH &#x3D; use card on file, POINTS &#x3D; use points, TICKETS &#x3D; use tickets
func (r ApiPreviewOfferTransactionRequest) CurrencyType(currencyType string) ApiPreviewOfferTransactionRequest {
	r.currencyType = &currencyType
	return r
}

// Sets the currencyType to POINTS
// Deprecated
func (r ApiPreviewOfferTransactionRequest) UsePoints(usePoints bool) ApiPreviewOfferTransactionRequest {
	r.usePoints = &usePoints
	return r
}

// External custom client defined data
func (r ApiPreviewOfferTransactionRequest) MetaData(metaData string) ApiPreviewOfferTransactionRequest {
	r.metaData = &metaData
	return r
}

// The application requesting the purchase, required when currencyType is TICKETS
func (r ApiPreviewOfferTransactionRequest) AppKey(appKey string) ApiPreviewOfferTransactionRequest {
	r.appKey = &appKey
	return r
}

func (r ApiPreviewOfferTransactionRequest) Execute() ([]OfferTransactionResponse, *http.Response, error) {
	return r.ApiService.PreviewOfferTransactionExecute(r)
}

/*
PreviewOfferTransaction Preview Wallet Offers

Preview the final cost of a transaction without charging the user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPreviewOfferTransactionRequest
*/
func (a *WalletAPIService) PreviewOfferTransaction(ctx context.Context) ApiPreviewOfferTransactionRequest {
	return ApiPreviewOfferTransactionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []OfferTransactionResponse
func (a *WalletAPIService) PreviewOfferTransactionExecute(r ApiPreviewOfferTransactionRequest) ([]OfferTransactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []OfferTransactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletAPIService.PreviewOfferTransaction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wallet/preview"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.offerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offerId", r.offerId, "form", "")
	}
	if r.offerLocationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offerLocationId", r.offerLocationId, "form", "")
	}
	if r.offerCart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offerCart", r.offerCart, "form", "")
	}
	if r.promoCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "promoCode", r.promoCode, "form", "")
	}
	if r.currencyType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currencyType", r.currencyType, "form", "")
	} else {
		var defaultValue string = "CASH"
		parameterAddToHeaderOrQuery(localVarQueryParams, "currencyType", defaultValue, "form", "")
		r.currencyType = &defaultValue
	}
	if r.usePoints != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usePoints", r.usePoints, "form", "")
	}
	if r.metaData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metaData", r.metaData, "form", "")
	}
	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchOfferTransactionsRequest struct {
	ctx context.Context
	ApiService *WalletAPIService
	deviceId *string
	accountId *int64
	keyword *string
	retailerId *int64
	retailerIds *string
	retailerLocationId *int64
	retailerLocationIds *string
	excludeRetailerLocationIds *string
	offerId *int64
	offerIds *string
	offerLocationId *int64
	offerLocationIds *string
	offerType *string
	offerTypes *string
	specialOfferType *string
	specialOfferTypes *string
	categoryIds *string
	filterIds *string
	offerAudienceIds *string
	sortField *string
	descending *bool
	start *int32
	limit *int32
	latitude *float64
	longitude *float64
	redeemableStartDate *int64
	redeemableEndDate *int64
	filterByParentOffer *bool
	startedSince *int64
	startedBefore *int64
	endedSince *int64
	endedBefore *int64
	redeemed *bool
	statuses *string
	reservationsOnly *bool
	activeOnly *bool
	returnFullResponse *bool
	recurringStartedSince *int64
	recurringStartedBefore *int64
	recurringExpirationSince *int64
	recurringExpirationBefore *int64
}

// The device id (deviceId or accountId required)
func (r ApiSearchOfferTransactionsRequest) DeviceId(deviceId string) ApiSearchOfferTransactionsRequest {
	r.deviceId = &deviceId
	return r
}

// The account id of the user (deviceId or accountId required)
func (r ApiSearchOfferTransactionsRequest) AccountId(accountId int64) ApiSearchOfferTransactionsRequest {
	r.accountId = &accountId
	return r
}

// The keyword to search for
func (r ApiSearchOfferTransactionsRequest) Keyword(keyword string) ApiSearchOfferTransactionsRequest {
	r.keyword = &keyword
	return r
}

// Filter results for this retailer
func (r ApiSearchOfferTransactionsRequest) RetailerId(retailerId int64) ApiSearchOfferTransactionsRequest {
	r.retailerId = &retailerId
	return r
}

// Filter results for a list of retailers
func (r ApiSearchOfferTransactionsRequest) RetailerIds(retailerIds string) ApiSearchOfferTransactionsRequest {
	r.retailerIds = &retailerIds
	return r
}

// Filter results for this retailer location
func (r ApiSearchOfferTransactionsRequest) RetailerLocationId(retailerLocationId int64) ApiSearchOfferTransactionsRequest {
	r.retailerLocationId = &retailerLocationId
	return r
}

// Filter results for a list of retailer locations
func (r ApiSearchOfferTransactionsRequest) RetailerLocationIds(retailerLocationIds string) ApiSearchOfferTransactionsRequest {
	r.retailerLocationIds = &retailerLocationIds
	return r
}

// Filter results to exclude retailer locations
func (r ApiSearchOfferTransactionsRequest) ExcludeRetailerLocationIds(excludeRetailerLocationIds string) ApiSearchOfferTransactionsRequest {
	r.excludeRetailerLocationIds = &excludeRetailerLocationIds
	return r
}

// Filter results for this offer
func (r ApiSearchOfferTransactionsRequest) OfferId(offerId int64) ApiSearchOfferTransactionsRequest {
	r.offerId = &offerId
	return r
}

// Filter results for a list of offer
func (r ApiSearchOfferTransactionsRequest) OfferIds(offerIds string) ApiSearchOfferTransactionsRequest {
	r.offerIds = &offerIds
	return r
}

// Filter results for this offer location
func (r ApiSearchOfferTransactionsRequest) OfferLocationId(offerLocationId int64) ApiSearchOfferTransactionsRequest {
	r.offerLocationId = &offerLocationId
	return r
}

// Filter results for a list of offer locations
func (r ApiSearchOfferTransactionsRequest) OfferLocationIds(offerLocationIds string) ApiSearchOfferTransactionsRequest {
	r.offerLocationIds = &offerLocationIds
	return r
}

// Filter results to return a specific offer type
func (r ApiSearchOfferTransactionsRequest) OfferType(offerType string) ApiSearchOfferTransactionsRequest {
	r.offerType = &offerType
	return r
}

// Filter results to return specific offer types
func (r ApiSearchOfferTransactionsRequest) OfferTypes(offerTypes string) ApiSearchOfferTransactionsRequest {
	r.offerTypes = &offerTypes
	return r
}

// Filter results to return a specific special offer type
func (r ApiSearchOfferTransactionsRequest) SpecialOfferType(specialOfferType string) ApiSearchOfferTransactionsRequest {
	r.specialOfferType = &specialOfferType
	return r
}

// Filter results to return specific special offer types
func (r ApiSearchOfferTransactionsRequest) SpecialOfferTypes(specialOfferTypes string) ApiSearchOfferTransactionsRequest {
	r.specialOfferTypes = &specialOfferTypes
	return r
}

// Category Ids
func (r ApiSearchOfferTransactionsRequest) CategoryIds(categoryIds string) ApiSearchOfferTransactionsRequest {
	r.categoryIds = &categoryIds
	return r
}

// Filter Ids
func (r ApiSearchOfferTransactionsRequest) FilterIds(filterIds string) ApiSearchOfferTransactionsRequest {
	r.filterIds = &filterIds
	return r
}

// Offer Audience Ids
func (r ApiSearchOfferTransactionsRequest) OfferAudienceIds(offerAudienceIds string) ApiSearchOfferTransactionsRequest {
	r.offerAudienceIds = &offerAudienceIds
	return r
}

// Determines what to sort the results by
func (r ApiSearchOfferTransactionsRequest) SortField(sortField string) ApiSearchOfferTransactionsRequest {
	r.sortField = &sortField
	return r
}

// Determines whether the results are in descending order
func (r ApiSearchOfferTransactionsRequest) Descending(descending bool) ApiSearchOfferTransactionsRequest {
	r.descending = &descending
	return r
}

// The start index for pagination
func (r ApiSearchOfferTransactionsRequest) Start(start int32) ApiSearchOfferTransactionsRequest {
	r.start = &start
	return r
}

// The limit for pagination
func (r ApiSearchOfferTransactionsRequest) Limit(limit int32) ApiSearchOfferTransactionsRequest {
	r.limit = &limit
	return r
}

// The latitude location of the user
func (r ApiSearchOfferTransactionsRequest) Latitude(latitude float64) ApiSearchOfferTransactionsRequest {
	r.latitude = &latitude
	return r
}

// The latitude location of the user
func (r ApiSearchOfferTransactionsRequest) Longitude(longitude float64) ApiSearchOfferTransactionsRequest {
	r.longitude = &longitude
	return r
}

// Filter results by the offer redeemable date
func (r ApiSearchOfferTransactionsRequest) RedeemableStartDate(redeemableStartDate int64) ApiSearchOfferTransactionsRequest {
	r.redeemableStartDate = &redeemableStartDate
	return r
}

// Filter results by the offer redeemable date
func (r ApiSearchOfferTransactionsRequest) RedeemableEndDate(redeemableEndDate int64) ApiSearchOfferTransactionsRequest {
	r.redeemableEndDate = &redeemableEndDate
	return r
}

// Apply params to offer&#39;s parent
func (r ApiSearchOfferTransactionsRequest) FilterByParentOffer(filterByParentOffer bool) ApiSearchOfferTransactionsRequest {
	r.filterByParentOffer = &filterByParentOffer
	return r
}

// Filter results by the offer start date
func (r ApiSearchOfferTransactionsRequest) StartedSince(startedSince int64) ApiSearchOfferTransactionsRequest {
	r.startedSince = &startedSince
	return r
}

// Filter results by the offer start date
func (r ApiSearchOfferTransactionsRequest) StartedBefore(startedBefore int64) ApiSearchOfferTransactionsRequest {
	r.startedBefore = &startedBefore
	return r
}

// Filter results by the offer end date
func (r ApiSearchOfferTransactionsRequest) EndedSince(endedSince int64) ApiSearchOfferTransactionsRequest {
	r.endedSince = &endedSince
	return r
}

// Filter results by the offer end date
func (r ApiSearchOfferTransactionsRequest) EndedBefore(endedBefore int64) ApiSearchOfferTransactionsRequest {
	r.endedBefore = &endedBefore
	return r
}

// If true return redeemed transactions (status 2), otherwise return active transactions (status 0 or 1)
func (r ApiSearchOfferTransactionsRequest) Redeemed(redeemed bool) ApiSearchOfferTransactionsRequest {
	r.redeemed = &redeemed
	return r
}

// Custom status value to change to (0 or 1 for redeem, 5 or 6 for membership)
func (r ApiSearchOfferTransactionsRequest) Statuses(statuses string) ApiSearchOfferTransactionsRequest {
	r.statuses = &statuses
	return r
}

// Returns only reservation transactions if true
func (r ApiSearchOfferTransactionsRequest) ReservationsOnly(reservationsOnly bool) ApiSearchOfferTransactionsRequest {
	r.reservationsOnly = &reservationsOnly
	return r
}

// Active Only
func (r ApiSearchOfferTransactionsRequest) ActiveOnly(activeOnly bool) ApiSearchOfferTransactionsRequest {
	r.activeOnly = &activeOnly
	return r
}

// Determines whether to return a detailed version of the response
func (r ApiSearchOfferTransactionsRequest) ReturnFullResponse(returnFullResponse bool) ApiSearchOfferTransactionsRequest {
	r.returnFullResponse = &returnFullResponse
	return r
}

// Filter results by the recurring billing start date
func (r ApiSearchOfferTransactionsRequest) RecurringStartedSince(recurringStartedSince int64) ApiSearchOfferTransactionsRequest {
	r.recurringStartedSince = &recurringStartedSince
	return r
}

// Filter results by the recurring billing start date
func (r ApiSearchOfferTransactionsRequest) RecurringStartedBefore(recurringStartedBefore int64) ApiSearchOfferTransactionsRequest {
	r.recurringStartedBefore = &recurringStartedBefore
	return r
}

// Filter results by the recurring billing expiration date
func (r ApiSearchOfferTransactionsRequest) RecurringExpirationSince(recurringExpirationSince int64) ApiSearchOfferTransactionsRequest {
	r.recurringExpirationSince = &recurringExpirationSince
	return r
}

// Filter results by the recurring billing expiration date
func (r ApiSearchOfferTransactionsRequest) RecurringExpirationBefore(recurringExpirationBefore int64) ApiSearchOfferTransactionsRequest {
	r.recurringExpirationBefore = &recurringExpirationBefore
	return r
}

func (r ApiSearchOfferTransactionsRequest) Execute() ([]OfferTransactionResponse, *http.Response, error) {
	return r.ApiService.SearchOfferTransactionsExecute(r)
}

/*
SearchOfferTransactions Search Wallet Offers

Search on active offers currently in the user's wallet, or past offers the user has already redeemed.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchOfferTransactionsRequest
*/
func (a *WalletAPIService) SearchOfferTransactions(ctx context.Context) ApiSearchOfferTransactionsRequest {
	return ApiSearchOfferTransactionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []OfferTransactionResponse
func (a *WalletAPIService) SearchOfferTransactionsExecute(r ApiSearchOfferTransactionsRequest) ([]OfferTransactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []OfferTransactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletAPIService.SearchOfferTransactions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wallet/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.keyword != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyword", r.keyword, "form", "")
	}
	if r.retailerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "retailerId", r.retailerId, "form", "")
	}
	if r.retailerIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "retailerIds", r.retailerIds, "form", "")
	}
	if r.retailerLocationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "retailerLocationId", r.retailerLocationId, "form", "")
	}
	if r.retailerLocationIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "retailerLocationIds", r.retailerLocationIds, "form", "")
	}
	if r.excludeRetailerLocationIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeRetailerLocationIds", r.excludeRetailerLocationIds, "form", "")
	}
	if r.offerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offerId", r.offerId, "form", "")
	}
	if r.offerIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offerIds", r.offerIds, "form", "")
	}
	if r.offerLocationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offerLocationId", r.offerLocationId, "form", "")
	}
	if r.offerLocationIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offerLocationIds", r.offerLocationIds, "form", "")
	}
	if r.offerType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offerType", r.offerType, "form", "")
	}
	if r.offerTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offerTypes", r.offerTypes, "form", "")
	}
	if r.specialOfferType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "specialOfferType", r.specialOfferType, "form", "")
	}
	if r.specialOfferTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "specialOfferTypes", r.specialOfferTypes, "form", "")
	}
	if r.categoryIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "categoryIds", r.categoryIds, "form", "")
	}
	if r.filterIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filterIds", r.filterIds, "form", "")
	}
	if r.offerAudienceIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offerAudienceIds", r.offerAudienceIds, "form", "")
	}
	if r.sortField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", r.sortField, "form", "")
	} else {
		var defaultValue string = "CREATED"
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", defaultValue, "form", "")
		r.sortField = &defaultValue
	}
	if r.descending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "form", "")
	} else {
		var defaultValue bool = true
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", defaultValue, "form", "")
		r.descending = &defaultValue
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	} else {
		var defaultValue int32 = 0
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", defaultValue, "form", "")
		r.start = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 20
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	if r.latitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latitude", r.latitude, "form", "")
	}
	if r.longitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "longitude", r.longitude, "form", "")
	}
	if r.redeemableStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "redeemableStartDate", r.redeemableStartDate, "form", "")
	}
	if r.redeemableEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "redeemableEndDate", r.redeemableEndDate, "form", "")
	}
	if r.filterByParentOffer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filterByParentOffer", r.filterByParentOffer, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "filterByParentOffer", defaultValue, "form", "")
		r.filterByParentOffer = &defaultValue
	}
	if r.startedSince != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startedSince", r.startedSince, "form", "")
	}
	if r.startedBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startedBefore", r.startedBefore, "form", "")
	}
	if r.endedSince != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endedSince", r.endedSince, "form", "")
	}
	if r.endedBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endedBefore", r.endedBefore, "form", "")
	}
	if r.redeemed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "redeemed", r.redeemed, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "redeemed", defaultValue, "form", "")
		r.redeemed = &defaultValue
	}
	if r.statuses != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "statuses", r.statuses, "form", "")
	}
	if r.reservationsOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationsOnly", r.reservationsOnly, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationsOnly", defaultValue, "form", "")
		r.reservationsOnly = &defaultValue
	}
	if r.activeOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activeOnly", r.activeOnly, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "activeOnly", defaultValue, "form", "")
		r.activeOnly = &defaultValue
	}
	if r.returnFullResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnFullResponse", r.returnFullResponse, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnFullResponse", defaultValue, "form", "")
		r.returnFullResponse = &defaultValue
	}
	if r.recurringStartedSince != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recurringStartedSince", r.recurringStartedSince, "form", "")
	}
	if r.recurringStartedBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recurringStartedBefore", r.recurringStartedBefore, "form", "")
	}
	if r.recurringExpirationSince != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recurringExpirationSince", r.recurringExpirationSince, "form", "")
	}
	if r.recurringExpirationBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recurringExpirationBefore", r.recurringExpirationBefore, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateOfferTransactionRequest struct {
	ctx context.Context
	ApiService *WalletAPIService
	transactionId *int64
	status *int32
	deviceId *string
	accountId *int64
	offerLocationId *int64
	currencyType *string
	usePoints *bool
	appKey *string
	latitude *float64
	longitude *float64
	metaData *string
	returnFullResponse *bool
	exceptionMembershipOfferIds *string
}

// The offer transaction id to remove
func (r ApiUpdateOfferTransactionRequest) TransactionId(transactionId int64) ApiUpdateOfferTransactionRequest {
	r.transactionId = &transactionId
	return r
}

// The status value to change to (0 or 1)
func (r ApiUpdateOfferTransactionRequest) Status(status int32) ApiUpdateOfferTransactionRequest {
	r.status = &status
	return r
}

// The device id (deviceId or accountId required)
func (r ApiUpdateOfferTransactionRequest) DeviceId(deviceId string) ApiUpdateOfferTransactionRequest {
	r.deviceId = &deviceId
	return r
}

// The account id of the user (deviceId or accountId required)
func (r ApiUpdateOfferTransactionRequest) AccountId(accountId int64) ApiUpdateOfferTransactionRequest {
	r.accountId = &accountId
	return r
}

// Offer Location Id
func (r ApiUpdateOfferTransactionRequest) OfferLocationId(offerLocationId int64) ApiUpdateOfferTransactionRequest {
	r.offerLocationId = &offerLocationId
	return r
}

// Currency Type
func (r ApiUpdateOfferTransactionRequest) CurrencyType(currencyType string) ApiUpdateOfferTransactionRequest {
	r.currencyType = &currencyType
	return r
}

// Use Points
// Deprecated
func (r ApiUpdateOfferTransactionRequest) UsePoints(usePoints bool) ApiUpdateOfferTransactionRequest {
	r.usePoints = &usePoints
	return r
}

// App Key
func (r ApiUpdateOfferTransactionRequest) AppKey(appKey string) ApiUpdateOfferTransactionRequest {
	r.appKey = &appKey
	return r
}

// The latitude location of the user
func (r ApiUpdateOfferTransactionRequest) Latitude(latitude float64) ApiUpdateOfferTransactionRequest {
	r.latitude = &latitude
	return r
}

// The latitude location of the user
func (r ApiUpdateOfferTransactionRequest) Longitude(longitude float64) ApiUpdateOfferTransactionRequest {
	r.longitude = &longitude
	return r
}

// External custom client defined data
func (r ApiUpdateOfferTransactionRequest) MetaData(metaData string) ApiUpdateOfferTransactionRequest {
	r.metaData = &metaData
	return r
}

// Determines whether to return a detailed version of the response
func (r ApiUpdateOfferTransactionRequest) ReturnFullResponse(returnFullResponse bool) ApiUpdateOfferTransactionRequest {
	r.returnFullResponse = &returnFullResponse
	return r
}

// Exception Offers, transaction audiences of these offers won&#39;t be removed out of the account when up
func (r ApiUpdateOfferTransactionRequest) ExceptionMembershipOfferIds(exceptionMembershipOfferIds string) ApiUpdateOfferTransactionRequest {
	r.exceptionMembershipOfferIds = &exceptionMembershipOfferIds
	return r
}

func (r ApiUpdateOfferTransactionRequest) Execute() (*OfferTransactionResponse, *http.Response, error) {
	return r.ApiService.UpdateOfferTransactionExecute(r)
}

/*
UpdateOfferTransaction Update Wallet Offer

Update offer status. The status values are: 0 - not redeemable, 1 - redeemable.

Not redeemable means the customer has received the offer but has not decided to use (or print) it yet.  Until they choose to do this the merchant cannot redeem the offer (has not been given permission yet). 

Redeemable means the customer has chosen to use the offer and wishes to redeem it.

Redeemed means the merchant has accepted the offer and the given the customer its value, then marked it a used in the system.  This status change is handled by a merchant end point.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateOfferTransactionRequest
*/
func (a *WalletAPIService) UpdateOfferTransaction(ctx context.Context) ApiUpdateOfferTransactionRequest {
	return ApiUpdateOfferTransactionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return OfferTransactionResponse
func (a *WalletAPIService) UpdateOfferTransactionExecute(r ApiUpdateOfferTransactionRequest) (*OfferTransactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OfferTransactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletAPIService.UpdateOfferTransaction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wallet/update"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.transactionId == nil {
		return localVarReturnValue, nil, reportError("transactionId is required and must be specified")
	}
	if r.status == nil {
		return localVarReturnValue, nil, reportError("status is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "transactionId", r.transactionId, "form", "")
	if r.offerLocationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offerLocationId", r.offerLocationId, "form", "")
	}
	if r.currencyType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currencyType", r.currencyType, "form", "")
	} else {
		var defaultValue string = "CASH"
		parameterAddToHeaderOrQuery(localVarQueryParams, "currencyType", defaultValue, "form", "")
		r.currencyType = &defaultValue
	}
	if r.usePoints != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usePoints", r.usePoints, "form", "")
	}
	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	if r.latitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latitude", r.latitude, "form", "")
	}
	if r.longitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "longitude", r.longitude, "form", "")
	}
	if r.metaData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metaData", r.metaData, "form", "")
	}
	if r.returnFullResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnFullResponse", r.returnFullResponse, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnFullResponse", defaultValue, "form", "")
		r.returnFullResponse = &defaultValue
	}
	if r.exceptionMembershipOfferIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exceptionMembershipOfferIds", r.exceptionMembershipOfferIds, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
