/*
Sirqul IoT Platform

Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

API version: 3.16
Contact: info@sirqul.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"os"
)


// AchievementAPIService AchievementAPI service
type AchievementAPIService service

type ApiAchievementTierSearchPostRequest struct {
	ctx context.Context
	ApiService *AchievementAPIService
	deviceId *string
	accountId *int64
	appKey *string
	keyword *string
	achievementType *int64
	rankType *string
	sortField *string
	descending *bool
	descendingGoal *bool
	start *int64
	limit *int64
}

// a unique id given by the device (deviceId or accountId required)
func (r ApiAchievementTierSearchPostRequest) DeviceId(deviceId string) ApiAchievementTierSearchPostRequest {
	r.deviceId = &deviceId
	return r
}

// the account id of the user (deviceId or accountId required)
func (r ApiAchievementTierSearchPostRequest) AccountId(accountId int64) ApiAchievementTierSearchPostRequest {
	r.accountId = &accountId
	return r
}

// the application key
func (r ApiAchievementTierSearchPostRequest) AppKey(appKey string) ApiAchievementTierSearchPostRequest {
	r.appKey = &appKey
	return r
}

// the keyword used to filter resutls with (this returns results that have the keyword in the title or the description of the achievement tier)
func (r ApiAchievementTierSearchPostRequest) Keyword(keyword string) ApiAchievementTierSearchPostRequest {
	r.keyword = &keyword
	return r
}

// filter results by achievementType (these are exact case sensitive matches)
func (r ApiAchievementTierSearchPostRequest) AchievementType(achievementType int64) ApiAchievementTierSearchPostRequest {
	r.achievementType = &achievementType
	return r
}

// filter results by the rankType (these are the exact case sensitive matches)
func (r ApiAchievementTierSearchPostRequest) RankType(rankType string) ApiAchievementTierSearchPostRequest {
	r.rankType = &rankType
	return r
}

// the field to sort by. See {@link AchievementApiMap}
func (r ApiAchievementTierSearchPostRequest) SortField(sortField string) ApiAchievementTierSearchPostRequest {
	r.sortField = &sortField
	return r
}

// determines whether the sort list is in descending or ascending order (of the achievement)
func (r ApiAchievementTierSearchPostRequest) Descending(descending bool) ApiAchievementTierSearchPostRequest {
	r.descending = &descending
	return r
}

// determines whether the results are in descending or ascending order by the tier goal count (after the initial sort on the achievement)
func (r ApiAchievementTierSearchPostRequest) DescendingGoal(descendingGoal bool) ApiAchievementTierSearchPostRequest {
	r.descendingGoal = &descendingGoal
	return r
}

// The start of the index for pagination
func (r ApiAchievementTierSearchPostRequest) Start(start int64) ApiAchievementTierSearchPostRequest {
	r.start = &start
	return r
}

// the limit for pagination (has a hard limit of 1000)
func (r ApiAchievementTierSearchPostRequest) Limit(limit int64) ApiAchievementTierSearchPostRequest {
	r.limit = &limit
	return r
}

func (r ApiAchievementTierSearchPostRequest) Execute() (*AchievementTierResponse, *http.Response, error) {
	return r.ApiService.AchievementTierSearchPostExecute(r)
}

/*
AchievementTierSearchPost Searches an Achievement Tier

Searches a tier of an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAchievementTierSearchPostRequest
*/
func (a *AchievementAPIService) AchievementTierSearchPost(ctx context.Context) ApiAchievementTierSearchPostRequest {
	return ApiAchievementTierSearchPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AchievementTierResponse
func (a *AchievementAPIService) AchievementTierSearchPostExecute(r ApiAchievementTierSearchPostRequest) (*AchievementTierResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AchievementTierResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AchievementAPIService.AchievementTierSearchPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/achievement/tier/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	if r.keyword != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyword", r.keyword, "form", "")
	}
	if r.achievementType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "achievementType", r.achievementType, "form", "")
	}
	if r.rankType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rankType", r.rankType, "form", "")
	}
	if r.sortField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", r.sortField, "form", "")
	}
	if r.descending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "form", "")
	}
	if r.descendingGoal != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descendingGoal", r.descendingGoal, "form", "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAchievementRequest struct {
	ctx context.Context
	ApiService *AchievementAPIService
	appKey *string
	title *string
	deviceId *string
	accountId *int64
	analyticsTag *string
	description *string
	rankType *string
	rankIncrement *int32
	minIncrement *int32
	maxIncrement *int32
	validate *bool
	active *bool
	triggerDefinition *string
}

// the application key the achievement is for
func (r ApiCreateAchievementRequest) AppKey(appKey string) ApiCreateAchievementRequest {
	r.appKey = &appKey
	return r
}

// the title of the achievement (255 character limit)
func (r ApiCreateAchievementRequest) Title(title string) ApiCreateAchievementRequest {
	r.title = &title
	return r
}

// a unique id given by the device (deviceId or accountId required)
func (r ApiCreateAchievementRequest) DeviceId(deviceId string) ApiCreateAchievementRequest {
	r.deviceId = &deviceId
	return r
}

// the account id of the user (deviceId or accountId required)
func (r ApiCreateAchievementRequest) AccountId(accountId int64) ApiCreateAchievementRequest {
	r.accountId = &accountId
	return r
}

// the analytics tag that will trigger when a user&#39;s achievement count gets updated
func (r ApiCreateAchievementRequest) AnalyticsTag(analyticsTag string) ApiCreateAchievementRequest {
	r.analyticsTag = &analyticsTag
	return r
}

// the description of the achievement
func (r ApiCreateAchievementRequest) Description(description string) ApiCreateAchievementRequest {
	r.description = &description
	return r
}

// the rank type for updating leader boards
func (r ApiCreateAchievementRequest) RankType(rankType string) ApiCreateAchievementRequest {
	r.rankType = &rankType
	return r
}

// determines how much the rank count is incremented
func (r ApiCreateAchievementRequest) RankIncrement(rankIncrement int32) ApiCreateAchievementRequest {
	r.rankIncrement = &rankIncrement
	return r
}

// restrict scores to be above or equal to this minimum value
func (r ApiCreateAchievementRequest) MinIncrement(minIncrement int32) ApiCreateAchievementRequest {
	r.minIncrement = &minIncrement
	return r
}

// restrict scores to be below or equal to this maximum value
func (r ApiCreateAchievementRequest) MaxIncrement(maxIncrement int32) ApiCreateAchievementRequest {
	r.maxIncrement = &maxIncrement
	return r
}

// determines whether the customId on analytics are used to validate a user&#39;s achievement progress.
func (r ApiCreateAchievementRequest) Validate(validate bool) ApiCreateAchievementRequest {
	r.validate = &validate
	return r
}

// achievement is active or inactive
func (r ApiCreateAchievementRequest) Active(active bool) ApiCreateAchievementRequest {
	r.active = &active
	return r
}

// if provided will define what triggers to run after a tier is completed
func (r ApiCreateAchievementRequest) TriggerDefinition(triggerDefinition string) ApiCreateAchievementRequest {
	r.triggerDefinition = &triggerDefinition
	return r
}

func (r ApiCreateAchievementRequest) Execute() (*AchievementResponse, *http.Response, error) {
	return r.ApiService.CreateAchievementExecute(r)
}

/*
CreateAchievement Create Achievement

Updates an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAchievementRequest
*/
func (a *AchievementAPIService) CreateAchievement(ctx context.Context) ApiCreateAchievementRequest {
	return ApiCreateAchievementRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AchievementResponse
func (a *AchievementAPIService) CreateAchievementExecute(r ApiCreateAchievementRequest) (*AchievementResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AchievementResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AchievementAPIService.CreateAchievement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/achievement/create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.appKey == nil {
		return localVarReturnValue, nil, reportError("appKey is required and must be specified")
	}
	if r.title == nil {
		return localVarReturnValue, nil, reportError("title is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	if r.analyticsTag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "analyticsTag", r.analyticsTag, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "title", r.title, "form", "")
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "form", "")
	}
	if r.rankType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rankType", r.rankType, "form", "")
	}
	if r.rankIncrement != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rankIncrement", r.rankIncrement, "form", "")
	}
	if r.minIncrement != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "minIncrement", r.minIncrement, "form", "")
	}
	if r.maxIncrement != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxIncrement", r.maxIncrement, "form", "")
	}
	if r.validate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "validate", r.validate, "form", "")
	}
	if r.active != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active", r.active, "form", "")
	}
	if r.triggerDefinition != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "triggerDefinition", r.triggerDefinition, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAchievementTierRequest struct {
	ctx context.Context
	ApiService *AchievementAPIService
	achievementId *int64
	scoreAllInstances *bool
	deviceId *string
	accountId *int64
	icon *os.File
	iconAssetId *int64
	title *string
	description *string
	goalCount *int64
	missionId *int64
	gameId *int64
	packId *int64
	gameLevelId *int64
	gameObjectId *int32
}

// the achievement id for adding a new tier
func (r ApiCreateAchievementTierRequest) AchievementId(achievementId int64) ApiCreateAchievementTierRequest {
	r.achievementId = &achievementId
	return r
}

// score all instances
func (r ApiCreateAchievementTierRequest) ScoreAllInstances(scoreAllInstances bool) ApiCreateAchievementTierRequest {
	r.scoreAllInstances = &scoreAllInstances
	return r
}

// a unique id given by the device (deviceId or accountId required)
func (r ApiCreateAchievementTierRequest) DeviceId(deviceId string) ApiCreateAchievementTierRequest {
	r.deviceId = &deviceId
	return r
}

// the account id of the user (deviceId or accountId required)
func (r ApiCreateAchievementTierRequest) AccountId(accountId int64) ApiCreateAchievementTierRequest {
	r.accountId = &accountId
	return r
}

// achievement tier icon image file
func (r ApiCreateAchievementTierRequest) Icon(icon *os.File) ApiCreateAchievementTierRequest {
	r.icon = icon
	return r
}

// the icon assetId, if icon is provided, icon will overrule
func (r ApiCreateAchievementTierRequest) IconAssetId(iconAssetId int64) ApiCreateAchievementTierRequest {
	r.iconAssetId = &iconAssetId
	return r
}

// the title of the achievement tier
func (r ApiCreateAchievementTierRequest) Title(title string) ApiCreateAchievementTierRequest {
	r.title = &title
	return r
}

// the description of the achievement tier
func (r ApiCreateAchievementTierRequest) Description(description string) ApiCreateAchievementTierRequest {
	r.description = &description
	return r
}

// the count requirement for completing the achievement tier
func (r ApiCreateAchievementTierRequest) GoalCount(goalCount int64) ApiCreateAchievementTierRequest {
	r.goalCount = &goalCount
	return r
}

// The ID of the mission to associate with the achievement
func (r ApiCreateAchievementTierRequest) MissionId(missionId int64) ApiCreateAchievementTierRequest {
	r.missionId = &missionId
	return r
}

// The ID of the game to associate with the achievement
func (r ApiCreateAchievementTierRequest) GameId(gameId int64) ApiCreateAchievementTierRequest {
	r.gameId = &gameId
	return r
}

// The ID of the pack to associate with the achievement
func (r ApiCreateAchievementTierRequest) PackId(packId int64) ApiCreateAchievementTierRequest {
	r.packId = &packId
	return r
}

// The ID of the game level to associate with the achievement
func (r ApiCreateAchievementTierRequest) GameLevelId(gameLevelId int64) ApiCreateAchievementTierRequest {
	r.gameLevelId = &gameLevelId
	return r
}

// The ID of the game object to associate with the achievement
func (r ApiCreateAchievementTierRequest) GameObjectId(gameObjectId int32) ApiCreateAchievementTierRequest {
	r.gameObjectId = &gameObjectId
	return r
}

func (r ApiCreateAchievementTierRequest) Execute() (*AchievementTierResponse, *http.Response, error) {
	return r.ApiService.CreateAchievementTierExecute(r)
}

/*
CreateAchievementTier Create Achievement Tier

Create a tier of an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAchievementTierRequest
*/
func (a *AchievementAPIService) CreateAchievementTier(ctx context.Context) ApiCreateAchievementTierRequest {
	return ApiCreateAchievementTierRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AchievementTierResponse
func (a *AchievementAPIService) CreateAchievementTierExecute(r ApiCreateAchievementTierRequest) (*AchievementTierResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AchievementTierResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AchievementAPIService.CreateAchievementTier")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/achievement/tier/create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.achievementId == nil {
		return localVarReturnValue, nil, reportError("achievementId is required and must be specified")
	}
	if r.scoreAllInstances == nil {
		return localVarReturnValue, nil, reportError("scoreAllInstances is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "achievementId", r.achievementId, "form", "")
	if r.icon != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "icon", r.icon, "form", "")
	}
	if r.iconAssetId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "iconAssetId", r.iconAssetId, "form", "")
	}
	if r.title != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "title", r.title, "form", "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "form", "")
	}
	if r.goalCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "goalCount", r.goalCount, "form", "")
	}
	if r.missionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "missionId", r.missionId, "form", "")
	}
	if r.gameId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gameId", r.gameId, "form", "")
	}
	if r.packId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "packId", r.packId, "form", "")
	}
	if r.gameLevelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gameLevelId", r.gameLevelId, "form", "")
	}
	if r.gameObjectId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gameObjectId", r.gameObjectId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "scoreAllInstances", r.scoreAllInstances, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteAchievementRequest struct {
	ctx context.Context
	ApiService *AchievementAPIService
	achievementId *int64
	accountId *int64
}

// The ID of the achievement
func (r ApiDeleteAchievementRequest) AchievementId(achievementId int64) ApiDeleteAchievementRequest {
	r.achievementId = &achievementId
	return r
}

// the account id of the user (deviceId or accountId required)
func (r ApiDeleteAchievementRequest) AccountId(accountId int64) ApiDeleteAchievementRequest {
	r.accountId = &accountId
	return r
}

func (r ApiDeleteAchievementRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.DeleteAchievementExecute(r)
}

/*
DeleteAchievement Delete Achievement

Deletes an achievement (for developer/retailer use). User must have permissions to the application the achievement was created for.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteAchievementRequest
*/
func (a *AchievementAPIService) DeleteAchievement(ctx context.Context) ApiDeleteAchievementRequest {
	return ApiDeleteAchievementRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *AchievementAPIService) DeleteAchievementExecute(r ApiDeleteAchievementRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AchievementAPIService.DeleteAchievement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/achievement/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.achievementId == nil {
		return localVarReturnValue, nil, reportError("achievementId is required and must be specified")
	}

	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "achievementId", r.achievementId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteAchievementTierRequest struct {
	ctx context.Context
	ApiService *AchievementAPIService
	achievementTierId *int64
	accountId *int64
}

// the achievement id for deletion
func (r ApiDeleteAchievementTierRequest) AchievementTierId(achievementTierId int64) ApiDeleteAchievementTierRequest {
	r.achievementTierId = &achievementTierId
	return r
}

// the account id of the user (deviceId or accountId required).
func (r ApiDeleteAchievementTierRequest) AccountId(accountId int64) ApiDeleteAchievementTierRequest {
	r.accountId = &accountId
	return r
}

func (r ApiDeleteAchievementTierRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.DeleteAchievementTierExecute(r)
}

/*
DeleteAchievementTier Delete Achievement Tier

Deletes an achievement tier (for developer/retailer use). User must have permissions to the application the achievement was created for.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteAchievementTierRequest
*/
func (a *AchievementAPIService) DeleteAchievementTier(ctx context.Context) ApiDeleteAchievementTierRequest {
	return ApiDeleteAchievementTierRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *AchievementAPIService) DeleteAchievementTierExecute(r ApiDeleteAchievementTierRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AchievementAPIService.DeleteAchievementTier")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/achievement/tier/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.achievementTierId == nil {
		return localVarReturnValue, nil, reportError("achievementTierId is required and must be specified")
	}

	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "achievementTierId", r.achievementTierId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAchievementRequest struct {
	ctx context.Context
	ApiService *AchievementAPIService
	achievementId *int64
	deviceId *string
	accountId *int64
	achievementType *string
}

// The ID of the achievement
func (r ApiGetAchievementRequest) AchievementId(achievementId int64) ApiGetAchievementRequest {
	r.achievementId = &achievementId
	return r
}

// a unique id given by the device (deviceId or accountId required)
func (r ApiGetAchievementRequest) DeviceId(deviceId string) ApiGetAchievementRequest {
	r.deviceId = &deviceId
	return r
}

// the account id of the user (deviceId or accountId required)
func (r ApiGetAchievementRequest) AccountId(accountId int64) ApiGetAchievementRequest {
	r.accountId = &accountId
	return r
}

// achievementType
func (r ApiGetAchievementRequest) AchievementType(achievementType string) ApiGetAchievementRequest {
	r.achievementType = &achievementType
	return r
}

func (r ApiGetAchievementRequest) Execute() (*AchievementTierResponse, *http.Response, error) {
	return r.ApiService.GetAchievementExecute(r)
}

/*
GetAchievement Get Achievement

Get an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAchievementRequest
*/
func (a *AchievementAPIService) GetAchievement(ctx context.Context) ApiGetAchievementRequest {
	return ApiGetAchievementRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AchievementTierResponse
func (a *AchievementAPIService) GetAchievementExecute(r ApiGetAchievementRequest) (*AchievementTierResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AchievementTierResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AchievementAPIService.GetAchievement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/achievement/get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.achievementId == nil {
		return localVarReturnValue, nil, reportError("achievementId is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "achievementId", r.achievementId, "form", "")
	if r.achievementType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "achievementType", r.achievementType, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAchievementTierRequest struct {
	ctx context.Context
	ApiService *AchievementAPIService
	accountId *int64
	achievementTierId *int64
}

// the account id of the user (deviceId or accountId required)
func (r ApiGetAchievementTierRequest) AccountId(accountId int64) ApiGetAchievementTierRequest {
	r.accountId = &accountId
	return r
}

// the achievement tier id that is being retrieved
func (r ApiGetAchievementTierRequest) AchievementTierId(achievementTierId int64) ApiGetAchievementTierRequest {
	r.achievementTierId = &achievementTierId
	return r
}

func (r ApiGetAchievementTierRequest) Execute() (*AchievementTierResponse, *http.Response, error) {
	return r.ApiService.GetAchievementTierExecute(r)
}

/*
GetAchievementTier Gets an achievement tier

Gets an achievement tier (for developer/retailer use). User must have permissions to the application the achievement is created for.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAchievementTierRequest
*/
func (a *AchievementAPIService) GetAchievementTier(ctx context.Context) ApiGetAchievementTierRequest {
	return ApiGetAchievementTierRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AchievementTierResponse
func (a *AchievementAPIService) GetAchievementTierExecute(r ApiGetAchievementTierRequest) (*AchievementTierResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AchievementTierResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AchievementAPIService.GetAchievementTier")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/achievement/tier/get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.achievementTierId == nil {
		return localVarReturnValue, nil, reportError("achievementTierId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "achievementTierId", r.achievementTierId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserAchievementsRequest struct {
	ctx context.Context
	ApiService *AchievementAPIService
	returnNulls *bool
	appKey *string
	includeUndiscovered *bool
	deviceId *string
	accountId *int64
	connectionAccountEmail *string
	connectionAccountId *int64
	rankType *string
	achievementType *string
	latitude *float64
	longitude *float64
}

// determines whether to return null fields in the response
func (r ApiGetUserAchievementsRequest) ReturnNulls(returnNulls bool) ApiGetUserAchievementsRequest {
	r.returnNulls = &returnNulls
	return r
}

// the application key for filtering results by application
func (r ApiGetUserAchievementsRequest) AppKey(appKey string) ApiGetUserAchievementsRequest {
	r.appKey = &appKey
	return r
}

// determines whether to return achievements that the user has not discovered yet
func (r ApiGetUserAchievementsRequest) IncludeUndiscovered(includeUndiscovered bool) ApiGetUserAchievementsRequest {
	r.includeUndiscovered = &includeUndiscovered
	return r
}

// a unique id given by the device (deviceId or accountId required)
func (r ApiGetUserAchievementsRequest) DeviceId(deviceId string) ApiGetUserAchievementsRequest {
	r.deviceId = &deviceId
	return r
}

// the account id of the user (deviceId or accountId required)
func (r ApiGetUserAchievementsRequest) AccountId(accountId int64) ApiGetUserAchievementsRequest {
	r.accountId = &accountId
	return r
}

// the email of the account to view achievements
func (r ApiGetUserAchievementsRequest) ConnectionAccountEmail(connectionAccountEmail string) ApiGetUserAchievementsRequest {
	r.connectionAccountEmail = &connectionAccountEmail
	return r
}

// the id of the account to view achievements
func (r ApiGetUserAchievementsRequest) ConnectionAccountId(connectionAccountId int64) ApiGetUserAchievementsRequest {
	r.connectionAccountId = &connectionAccountId
	return r
}

// filter results by achievement rankType
func (r ApiGetUserAchievementsRequest) RankType(rankType string) ApiGetUserAchievementsRequest {
	r.rankType = &rankType
	return r
}

// filter results by achievement type
func (r ApiGetUserAchievementsRequest) AchievementType(achievementType string) ApiGetUserAchievementsRequest {
	r.achievementType = &achievementType
	return r
}

// the current latitude of the user
func (r ApiGetUserAchievementsRequest) Latitude(latitude float64) ApiGetUserAchievementsRequest {
	r.latitude = &latitude
	return r
}

// the current longitude of the user
func (r ApiGetUserAchievementsRequest) Longitude(longitude float64) ApiGetUserAchievementsRequest {
	r.longitude = &longitude
	return r
}

func (r ApiGetUserAchievementsRequest) Execute() ([]AchievementProgressResponse, *http.Response, error) {
	return r.ApiService.GetUserAchievementsExecute(r)
}

/*
GetUserAchievements Get Achievement Progress

Gets a list of user achievements.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUserAchievementsRequest
*/
func (a *AchievementAPIService) GetUserAchievements(ctx context.Context) ApiGetUserAchievementsRequest {
	return ApiGetUserAchievementsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []AchievementProgressResponse
func (a *AchievementAPIService) GetUserAchievementsExecute(r ApiGetUserAchievementsRequest) ([]AchievementProgressResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []AchievementProgressResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AchievementAPIService.GetUserAchievements")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/achievement/progress/get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.returnNulls == nil {
		return localVarReturnValue, nil, reportError("returnNulls is required and must be specified")
	}
	if r.appKey == nil {
		return localVarReturnValue, nil, reportError("appKey is required and must be specified")
	}
	if r.includeUndiscovered == nil {
		return localVarReturnValue, nil, reportError("includeUndiscovered is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "returnNulls", r.returnNulls, "form", "")
	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.connectionAccountEmail != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionAccountEmail", r.connectionAccountEmail, "form", "")
	}
	if r.connectionAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionAccountId", r.connectionAccountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	if r.rankType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rankType", r.rankType, "form", "")
	}
	if r.achievementType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "achievementType", r.achievementType, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "includeUndiscovered", r.includeUndiscovered, "form", "")
	if r.latitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latitude", r.latitude, "form", "")
	}
	if r.longitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "longitude", r.longitude, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListAchievementTagsRequest struct {
	ctx context.Context
	ApiService *AchievementAPIService
	appKey *string
}

// filter results by application key
func (r ApiListAchievementTagsRequest) AppKey(appKey string) ApiListAchievementTagsRequest {
	r.appKey = &appKey
	return r
}

func (r ApiListAchievementTagsRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.ListAchievementTagsExecute(r)
}

/*
ListAchievementTags List Achievement Tags

List achievement tags by application

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListAchievementTagsRequest
*/
func (a *AchievementAPIService) ListAchievementTags(ctx context.Context) ApiListAchievementTagsRequest {
	return ApiListAchievementTagsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *AchievementAPIService) ListAchievementTagsExecute(r ApiListAchievementTagsRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AchievementAPIService.ListAchievementTags")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/achievement/tag/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListAchievementsRequest struct {
	ctx context.Context
	ApiService *AchievementAPIService
	sortField *string
	descending *bool
	start *int32
	limit *int32
	activeOnly *bool
	deviceId *string
	accountId *int64
	appKey *string
	keyword *string
	achievementType *string
	rankType *string
}

// the field to sort by. See AchievementApiMap
func (r ApiListAchievementsRequest) SortField(sortField string) ApiListAchievementsRequest {
	r.sortField = &sortField
	return r
}

// determines whether the sorted list is in descending or ascending order
func (r ApiListAchievementsRequest) Descending(descending bool) ApiListAchievementsRequest {
	r.descending = &descending
	return r
}

// the start index for pagination
func (r ApiListAchievementsRequest) Start(start int32) ApiListAchievementsRequest {
	r.start = &start
	return r
}

// the limit for pagination (has a hard limit of 1000)
func (r ApiListAchievementsRequest) Limit(limit int32) ApiListAchievementsRequest {
	r.limit = &limit
	return r
}

// Filter results to only return active achievements
func (r ApiListAchievementsRequest) ActiveOnly(activeOnly bool) ApiListAchievementsRequest {
	r.activeOnly = &activeOnly
	return r
}

// a unique id given by the device (deviceId or accountId required)
func (r ApiListAchievementsRequest) DeviceId(deviceId string) ApiListAchievementsRequest {
	r.deviceId = &deviceId
	return r
}

// the account id of the user (deviceId or accountId required)
func (r ApiListAchievementsRequest) AccountId(accountId int64) ApiListAchievementsRequest {
	r.accountId = &accountId
	return r
}

// the application key
func (r ApiListAchievementsRequest) AppKey(appKey string) ApiListAchievementsRequest {
	r.appKey = &appKey
	return r
}

// the keyword used to filter results with (this returns results that have the keyword in the title or description of the achievement)
func (r ApiListAchievementsRequest) Keyword(keyword string) ApiListAchievementsRequest {
	r.keyword = &keyword
	return r
}

// filter results by the achievementType (these are exact case sensitive matches)
func (r ApiListAchievementsRequest) AchievementType(achievementType string) ApiListAchievementsRequest {
	r.achievementType = &achievementType
	return r
}

// filter results by the rankType (these are exact case sensitive matches)
func (r ApiListAchievementsRequest) RankType(rankType string) ApiListAchievementsRequest {
	r.rankType = &rankType
	return r
}

func (r ApiListAchievementsRequest) Execute() ([]AchievementShortResponse, *http.Response, error) {
	return r.ApiService.ListAchievementsExecute(r)
}

/*
ListAchievements List Achievements

List achievements by billable.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListAchievementsRequest
*/
func (a *AchievementAPIService) ListAchievements(ctx context.Context) ApiListAchievementsRequest {
	return ApiListAchievementsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []AchievementShortResponse
func (a *AchievementAPIService) ListAchievementsExecute(r ApiListAchievementsRequest) ([]AchievementShortResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []AchievementShortResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AchievementAPIService.ListAchievements")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/achievement/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sortField == nil {
		return localVarReturnValue, nil, reportError("sortField is required and must be specified")
	}
	if r.descending == nil {
		return localVarReturnValue, nil, reportError("descending is required and must be specified")
	}
	if r.start == nil {
		return localVarReturnValue, nil, reportError("start is required and must be specified")
	}
	if r.limit == nil {
		return localVarReturnValue, nil, reportError("limit is required and must be specified")
	}
	if r.activeOnly == nil {
		return localVarReturnValue, nil, reportError("activeOnly is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	if r.keyword != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyword", r.keyword, "form", "")
	}
	if r.achievementType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "achievementType", r.achievementType, "form", "")
	}
	if r.rankType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rankType", r.rankType, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", r.sortField, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "activeOnly", r.activeOnly, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchAchievementsRequest struct {
	ctx context.Context
	ApiService *AchievementAPIService
	appKey *string
	sortField *string
	descending *bool
	includeTiers *bool
	includeInactiveTiers *bool
	start *int32
	limit *int32
	deviceId *string
	accountId *int64
	keyword *string
	achievementType *string
	rankType *string
}

// the application key
func (r ApiSearchAchievementsRequest) AppKey(appKey string) ApiSearchAchievementsRequest {
	r.appKey = &appKey
	return r
}

// the field to sort by. See AchievementApiMap
func (r ApiSearchAchievementsRequest) SortField(sortField string) ApiSearchAchievementsRequest {
	r.sortField = &sortField
	return r
}

// determines whether the sorted list is in descending or ascending order
func (r ApiSearchAchievementsRequest) Descending(descending bool) ApiSearchAchievementsRequest {
	r.descending = &descending
	return r
}

// return tiers, only applicable for version &gt;3.18
func (r ApiSearchAchievementsRequest) IncludeTiers(includeTiers bool) ApiSearchAchievementsRequest {
	r.includeTiers = &includeTiers
	return r
}

// return inactive tiers, only applicable when includeTiers is true, only applicable for version &gt;3.18
func (r ApiSearchAchievementsRequest) IncludeInactiveTiers(includeInactiveTiers bool) ApiSearchAchievementsRequest {
	r.includeInactiveTiers = &includeInactiveTiers
	return r
}

// the start index for pagination
func (r ApiSearchAchievementsRequest) Start(start int32) ApiSearchAchievementsRequest {
	r.start = &start
	return r
}

// the limit for pagination (has a hard limit of 1000)
func (r ApiSearchAchievementsRequest) Limit(limit int32) ApiSearchAchievementsRequest {
	r.limit = &limit
	return r
}

// a unique id given by the device (deviceId or accountId required)
func (r ApiSearchAchievementsRequest) DeviceId(deviceId string) ApiSearchAchievementsRequest {
	r.deviceId = &deviceId
	return r
}

// the account id of the user (deviceId or accountId required)
func (r ApiSearchAchievementsRequest) AccountId(accountId int64) ApiSearchAchievementsRequest {
	r.accountId = &accountId
	return r
}

// the keyword used to filter results with (this returns results that have the keyword in the title or description of the achievement)
func (r ApiSearchAchievementsRequest) Keyword(keyword string) ApiSearchAchievementsRequest {
	r.keyword = &keyword
	return r
}

// filter results by the achievementType (these are exact case sensitive matches)
func (r ApiSearchAchievementsRequest) AchievementType(achievementType string) ApiSearchAchievementsRequest {
	r.achievementType = &achievementType
	return r
}

// filter results by the rankType (these are exact case sensitive matches)
func (r ApiSearchAchievementsRequest) RankType(rankType string) ApiSearchAchievementsRequest {
	r.rankType = &rankType
	return r
}

func (r ApiSearchAchievementsRequest) Execute() ([]AchievementShortResponse, *http.Response, error) {
	return r.ApiService.SearchAchievementsExecute(r)
}

/*
SearchAchievements Search Achievements

Searches achievements by application for consumers.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchAchievementsRequest
*/
func (a *AchievementAPIService) SearchAchievements(ctx context.Context) ApiSearchAchievementsRequest {
	return ApiSearchAchievementsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []AchievementShortResponse
func (a *AchievementAPIService) SearchAchievementsExecute(r ApiSearchAchievementsRequest) ([]AchievementShortResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []AchievementShortResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AchievementAPIService.SearchAchievements")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/achievement/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.appKey == nil {
		return localVarReturnValue, nil, reportError("appKey is required and must be specified")
	}
	if r.sortField == nil {
		return localVarReturnValue, nil, reportError("sortField is required and must be specified")
	}
	if r.descending == nil {
		return localVarReturnValue, nil, reportError("descending is required and must be specified")
	}
	if r.includeTiers == nil {
		return localVarReturnValue, nil, reportError("includeTiers is required and must be specified")
	}
	if r.includeInactiveTiers == nil {
		return localVarReturnValue, nil, reportError("includeInactiveTiers is required and must be specified")
	}
	if r.start == nil {
		return localVarReturnValue, nil, reportError("start is required and must be specified")
	}
	if r.limit == nil {
		return localVarReturnValue, nil, reportError("limit is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	if r.keyword != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyword", r.keyword, "form", "")
	}
	if r.achievementType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "achievementType", r.achievementType, "form", "")
	}
	if r.rankType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rankType", r.rankType, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", r.sortField, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "includeTiers", r.includeTiers, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactiveTiers", r.includeInactiveTiers, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateAchievementRequest struct {
	ctx context.Context
	ApiService *AchievementAPIService
	deviceId *string
	accountId *int64
	achievementId *int64
	analyticsTag *string
	title *string
	description *string
	rankType *string
	rankIncrement *int32
	minIncrement *int32
	nullMinIncrement *bool
	maxIncrement *int32
	nullMaxIncrement *bool
	validate *bool
	active *bool
	triggerDefinition *string
}

// a unique id given by the device (deviceId or accountId required)
func (r ApiUpdateAchievementRequest) DeviceId(deviceId string) ApiUpdateAchievementRequest {
	r.deviceId = &deviceId
	return r
}

// the account id of the user (deviceId or accountId required)
func (r ApiUpdateAchievementRequest) AccountId(accountId int64) ApiUpdateAchievementRequest {
	r.accountId = &accountId
	return r
}

// the achievement ID for updating an existing achievement
func (r ApiUpdateAchievementRequest) AchievementId(achievementId int64) ApiUpdateAchievementRequest {
	r.achievementId = &achievementId
	return r
}

// the analytics tag that will trigger when a user&#39;s achievement count gets updated
func (r ApiUpdateAchievementRequest) AnalyticsTag(analyticsTag string) ApiUpdateAchievementRequest {
	r.analyticsTag = &analyticsTag
	return r
}

// the title of the achievement (255 character limit)
func (r ApiUpdateAchievementRequest) Title(title string) ApiUpdateAchievementRequest {
	r.title = &title
	return r
}

// the description of the achievement
func (r ApiUpdateAchievementRequest) Description(description string) ApiUpdateAchievementRequest {
	r.description = &description
	return r
}

// the rank type for updating leader boards
func (r ApiUpdateAchievementRequest) RankType(rankType string) ApiUpdateAchievementRequest {
	r.rankType = &rankType
	return r
}

// determines how much the rank count is incremented
func (r ApiUpdateAchievementRequest) RankIncrement(rankIncrement int32) ApiUpdateAchievementRequest {
	r.rankIncrement = &rankIncrement
	return r
}

// restrict scores to be above or equal to this minimum value
func (r ApiUpdateAchievementRequest) MinIncrement(minIncrement int32) ApiUpdateAchievementRequest {
	r.minIncrement = &minIncrement
	return r
}

// enable to ignore usage of minIncrement
func (r ApiUpdateAchievementRequest) NullMinIncrement(nullMinIncrement bool) ApiUpdateAchievementRequest {
	r.nullMinIncrement = &nullMinIncrement
	return r
}

// restrict scores to be below or equal to this maximum value
func (r ApiUpdateAchievementRequest) MaxIncrement(maxIncrement int32) ApiUpdateAchievementRequest {
	r.maxIncrement = &maxIncrement
	return r
}

// enable to ignore usage of maxIncrement
func (r ApiUpdateAchievementRequest) NullMaxIncrement(nullMaxIncrement bool) ApiUpdateAchievementRequest {
	r.nullMaxIncrement = &nullMaxIncrement
	return r
}

// determines whether the customId on analytics are used to validate a user&#39;s achievement progress.
func (r ApiUpdateAchievementRequest) Validate(validate bool) ApiUpdateAchievementRequest {
	r.validate = &validate
	return r
}

// if it&#39;s active or inactive
func (r ApiUpdateAchievementRequest) Active(active bool) ApiUpdateAchievementRequest {
	r.active = &active
	return r
}

// if provided will define what triggers to run after a tier is completed
func (r ApiUpdateAchievementRequest) TriggerDefinition(triggerDefinition string) ApiUpdateAchievementRequest {
	r.triggerDefinition = &triggerDefinition
	return r
}

func (r ApiUpdateAchievementRequest) Execute() (*AchievementResponse, *http.Response, error) {
	return r.ApiService.UpdateAchievementExecute(r)
}

/*
UpdateAchievement Update Achievement

Updates an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateAchievementRequest
*/
func (a *AchievementAPIService) UpdateAchievement(ctx context.Context) ApiUpdateAchievementRequest {
	return ApiUpdateAchievementRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AchievementResponse
func (a *AchievementAPIService) UpdateAchievementExecute(r ApiUpdateAchievementRequest) (*AchievementResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AchievementResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AchievementAPIService.UpdateAchievement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/achievement/update"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.achievementId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "achievementId", r.achievementId, "form", "")
	}
	if r.analyticsTag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "analyticsTag", r.analyticsTag, "form", "")
	}
	if r.title != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "title", r.title, "form", "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "form", "")
	}
	if r.rankType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rankType", r.rankType, "form", "")
	}
	if r.rankIncrement != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rankIncrement", r.rankIncrement, "form", "")
	}
	if r.minIncrement != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "minIncrement", r.minIncrement, "form", "")
	}
	if r.nullMinIncrement != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nullMinIncrement", r.nullMinIncrement, "form", "")
	}
	if r.maxIncrement != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxIncrement", r.maxIncrement, "form", "")
	}
	if r.nullMaxIncrement != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nullMaxIncrement", r.nullMaxIncrement, "form", "")
	}
	if r.validate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "validate", r.validate, "form", "")
	}
	if r.active != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active", r.active, "form", "")
	}
	if r.triggerDefinition != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "triggerDefinition", r.triggerDefinition, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateAchievementTierRequest struct {
	ctx context.Context
	ApiService *AchievementAPIService
	achievementTierId *int64
	deviceId *string
	accountId *int64
	icon *os.File
	iconAssetId *int64
	title *string
	description *string
	goalCount *int64
	missionId *int64
	gameId *int64
	packId *int64
	gameLevelId *int64
	gameObjectId *int64
	scoreAllInstances *bool
}

// the achievement tier id for updating
func (r ApiUpdateAchievementTierRequest) AchievementTierId(achievementTierId int64) ApiUpdateAchievementTierRequest {
	r.achievementTierId = &achievementTierId
	return r
}

// a unique id given by the device (deviceId or accountId required)
func (r ApiUpdateAchievementTierRequest) DeviceId(deviceId string) ApiUpdateAchievementTierRequest {
	r.deviceId = &deviceId
	return r
}

// the account id of the user (deviceId or accountId required)
func (r ApiUpdateAchievementTierRequest) AccountId(accountId int64) ApiUpdateAchievementTierRequest {
	r.accountId = &accountId
	return r
}

// achievement tier icon image file
func (r ApiUpdateAchievementTierRequest) Icon(icon *os.File) ApiUpdateAchievementTierRequest {
	r.icon = icon
	return r
}

// the icon assetId, if icon is provided, icon will overrule
func (r ApiUpdateAchievementTierRequest) IconAssetId(iconAssetId int64) ApiUpdateAchievementTierRequest {
	r.iconAssetId = &iconAssetId
	return r
}

// the title of the achievement tier
func (r ApiUpdateAchievementTierRequest) Title(title string) ApiUpdateAchievementTierRequest {
	r.title = &title
	return r
}

// the description of the achievement tier
func (r ApiUpdateAchievementTierRequest) Description(description string) ApiUpdateAchievementTierRequest {
	r.description = &description
	return r
}

// the count requirement for completing the achievement tier
func (r ApiUpdateAchievementTierRequest) GoalCount(goalCount int64) ApiUpdateAchievementTierRequest {
	r.goalCount = &goalCount
	return r
}

// The ID of the mission to associate with the achievement
func (r ApiUpdateAchievementTierRequest) MissionId(missionId int64) ApiUpdateAchievementTierRequest {
	r.missionId = &missionId
	return r
}

// The ID of the game to associate with the achievement
func (r ApiUpdateAchievementTierRequest) GameId(gameId int64) ApiUpdateAchievementTierRequest {
	r.gameId = &gameId
	return r
}

// The ID of the pack to associate with the achievement
func (r ApiUpdateAchievementTierRequest) PackId(packId int64) ApiUpdateAchievementTierRequest {
	r.packId = &packId
	return r
}

// The ID of the game level to associate with the achievement
func (r ApiUpdateAchievementTierRequest) GameLevelId(gameLevelId int64) ApiUpdateAchievementTierRequest {
	r.gameLevelId = &gameLevelId
	return r
}

// The ID of the game object to associate with the achievement
func (r ApiUpdateAchievementTierRequest) GameObjectId(gameObjectId int64) ApiUpdateAchievementTierRequest {
	r.gameObjectId = &gameObjectId
	return r
}

// score all instances
func (r ApiUpdateAchievementTierRequest) ScoreAllInstances(scoreAllInstances bool) ApiUpdateAchievementTierRequest {
	r.scoreAllInstances = &scoreAllInstances
	return r
}

func (r ApiUpdateAchievementTierRequest) Execute() (*AchievementTierResponse, *http.Response, error) {
	return r.ApiService.UpdateAchievementTierExecute(r)
}

/*
UpdateAchievementTier Update Achievement Tier

Updates a tier of an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateAchievementTierRequest
*/
func (a *AchievementAPIService) UpdateAchievementTier(ctx context.Context) ApiUpdateAchievementTierRequest {
	return ApiUpdateAchievementTierRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AchievementTierResponse
func (a *AchievementAPIService) UpdateAchievementTierExecute(r ApiUpdateAchievementTierRequest) (*AchievementTierResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AchievementTierResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AchievementAPIService.UpdateAchievementTier")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/achievement/tier/update"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.achievementTierId == nil {
		return localVarReturnValue, nil, reportError("achievementTierId is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "achievementTierId", r.achievementTierId, "form", "")
	if r.icon != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "icon", r.icon, "form", "")
	}
	if r.iconAssetId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "iconAssetId", r.iconAssetId, "form", "")
	}
	if r.title != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "title", r.title, "form", "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "form", "")
	}
	if r.goalCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "goalCount", r.goalCount, "form", "")
	}
	if r.missionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "missionId", r.missionId, "form", "")
	}
	if r.gameId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gameId", r.gameId, "form", "")
	}
	if r.packId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "packId", r.packId, "form", "")
	}
	if r.gameLevelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gameLevelId", r.gameLevelId, "form", "")
	}
	if r.gameObjectId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gameObjectId", r.gameObjectId, "form", "")
	}
	if r.scoreAllInstances != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scoreAllInstances", r.scoreAllInstances, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateUserAchievementRequest struct {
	ctx context.Context
	ApiService *AchievementAPIService
	accountId *int64
	achievementId *int64
	tag *string
	customId *int64
	increment *int64
	startDate *int64
	endDate *int64
	returnProgress *bool
}

// the account id of the user
func (r ApiUpdateUserAchievementRequest) AccountId(accountId int64) ApiUpdateUserAchievementRequest {
	r.accountId = &accountId
	return r
}

// the achievement id (achievementId or tag required)
func (r ApiUpdateUserAchievementRequest) AchievementId(achievementId int64) ApiUpdateUserAchievementRequest {
	r.achievementId = &achievementId
	return r
}

// the analytic tag to identify an achievement (achievementId or tag required)
func (r ApiUpdateUserAchievementRequest) Tag(tag string) ApiUpdateUserAchievementRequest {
	r.tag = &tag
	return r
}

// a custom identifier used for validation
func (r ApiUpdateUserAchievementRequest) CustomId(customId int64) ApiUpdateUserAchievementRequest {
	r.customId = &customId
	return r
}

// the amount to increment an achievement progress by (if no increment is sent in, the server defaults to using the achievement&#39;s rankIncrement value)
func (r ApiUpdateUserAchievementRequest) Increment(increment int64) ApiUpdateUserAchievementRequest {
	r.increment = &increment
	return r
}

// a custom start date that the client can set (not yet used in server logic)
func (r ApiUpdateUserAchievementRequest) StartDate(startDate int64) ApiUpdateUserAchievementRequest {
	r.startDate = &startDate
	return r
}

// a custom end date that the client can set (not yet used in server logic)
func (r ApiUpdateUserAchievementRequest) EndDate(endDate int64) ApiUpdateUserAchievementRequest {
	r.endDate = &endDate
	return r
}

// determines whether to return the achievement progress response
func (r ApiUpdateUserAchievementRequest) ReturnProgress(returnProgress bool) ApiUpdateUserAchievementRequest {
	r.returnProgress = &returnProgress
	return r
}

func (r ApiUpdateUserAchievementRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.UpdateUserAchievementExecute(r)
}

/*
UpdateUserAchievement Update Achievement Progress

Update user achievement progress.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateUserAchievementRequest
*/
func (a *AchievementAPIService) UpdateUserAchievement(ctx context.Context) ApiUpdateUserAchievementRequest {
	return ApiUpdateUserAchievementRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *AchievementAPIService) UpdateUserAchievementExecute(r ApiUpdateUserAchievementRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AchievementAPIService.UpdateUserAchievement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/achievement/progress/update"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	if r.achievementId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "achievementId", r.achievementId, "form", "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.customId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "customId", r.customId, "form", "")
	}
	if r.increment != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "increment", r.increment, "form", "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "form", "")
	}
	if r.returnProgress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnProgress", r.returnProgress, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
