/*
Sirqul IoT Platform

Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

API version: 3.16
Contact: info@sirqul.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// TournamentAPIService TournamentAPI service
type TournamentAPIService service

type ApiCreateTournamentRequest struct {
	ctx context.Context
	ApiService *TournamentAPIService
	version float32
	accountId *int64
	appKey *string
	title *string
	costToPlay *int32
	startDate *int64
	subType *string
	imageAssetId *int64
	secondsBetweenLevels *int32
	secondsForTieBreaker *int32
	secondsBetweenPacks *int32
	maximumLevelLength *int32
	costToPlayType *string
	minimumToPlay *int32
	startingLimit *int32
	availableLimit *int32
	description *string
	metaData *string
	audienceIds *string
	active *bool
	enableBuyBack *bool
	offerIds *string
	offerAssetId *int64
	fixedReward *bool
	splitReward *string
	allocateTickets *bool
	tournamentData *string
	missionType *string
	visibility *string
	preliminaryGroups *int32
	preliminaryGroupAdvancements *string
	enableMultipleEntries *bool
	enableMultipleVotes *bool
	featured *bool
	winnerTag *string
	tieTag *string
}

// The logged in user.
func (r ApiCreateTournamentRequest) AccountId(accountId int64) ApiCreateTournamentRequest {
	r.accountId = &accountId
	return r
}

// The appKey the tournament is created for.
func (r ApiCreateTournamentRequest) AppKey(appKey string) ApiCreateTournamentRequest {
	r.appKey = &appKey
	return r
}

// The title of the tournament
func (r ApiCreateTournamentRequest) Title(title string) ApiCreateTournamentRequest {
	r.title = &title
	return r
}

// The number of tickets required to pay to enter the tournament
func (r ApiCreateTournamentRequest) CostToPlay(costToPlay int32) ApiCreateTournamentRequest {
	r.costToPlay = &costToPlay
	return r
}

// The date/time to start the tournament
func (r ApiCreateTournamentRequest) StartDate(startDate int64) ApiCreateTournamentRequest {
	r.startDate = &startDate
	return r
}

// Custom string client apps can use for searching/filtering tournaments
func (r ApiCreateTournamentRequest) SubType(subType string) ApiCreateTournamentRequest {
	r.subType = &subType
	return r
}

// The asset ID to attach to the tournament
func (r ApiCreateTournamentRequest) ImageAssetId(imageAssetId int64) ApiCreateTournamentRequest {
	r.imageAssetId = &imageAssetId
	return r
}

// The number of seconds in between the start of each tournament game/group
func (r ApiCreateTournamentRequest) SecondsBetweenLevels(secondsBetweenLevels int32) ApiCreateTournamentRequest {
	r.secondsBetweenLevels = &secondsBetweenLevels
	return r
}

// The number of seconds to extend the round end time in the case of a tie breaker
func (r ApiCreateTournamentRequest) SecondsForTieBreaker(secondsForTieBreaker int32) ApiCreateTournamentRequest {
	r.secondsForTieBreaker = &secondsForTieBreaker
	return r
}

// The number of seconds in between the start of each tournament round
func (r ApiCreateTournamentRequest) SecondsBetweenPacks(secondsBetweenPacks int32) ApiCreateTournamentRequest {
	r.secondsBetweenPacks = &secondsBetweenPacks
	return r
}

// The maximum number of seconds the match is expected to end at, which gets used to determine when a match should end when there is no activity
func (r ApiCreateTournamentRequest) MaximumLevelLength(maximumLevelLength int32) ApiCreateTournamentRequest {
	r.maximumLevelLength = &maximumLevelLength
	return r
}

// The type of ticket required to pay
func (r ApiCreateTournamentRequest) CostToPlayType(costToPlayType string) ApiCreateTournamentRequest {
	r.costToPlayType = &costToPlayType
	return r
}

// The minimum number of players required to sign up for the tournament to be played
func (r ApiCreateTournamentRequest) MinimumToPlay(minimumToPlay int32) ApiCreateTournamentRequest {
	r.minimumToPlay = &minimumToPlay
	return r
}

// The starting number of players for a tournament (filled with AI&#39;s)
func (r ApiCreateTournamentRequest) StartingLimit(startingLimit int32) ApiCreateTournamentRequest {
	r.startingLimit = &startingLimit
	return r
}

// The maximum number of players for a tournament (currently 128 but not enforced)
func (r ApiCreateTournamentRequest) AvailableLimit(availableLimit int32) ApiCreateTournamentRequest {
	r.availableLimit = &availableLimit
	return r
}

// The description of the tournament
func (r ApiCreateTournamentRequest) Description(description string) ApiCreateTournamentRequest {
	r.description = &description
	return r
}

// External custom client defined data
func (r ApiCreateTournamentRequest) MetaData(metaData string) ApiCreateTournamentRequest {
	r.metaData = &metaData
	return r
}

// The audiences associated with the tournament
func (r ApiCreateTournamentRequest) AudienceIds(audienceIds string) ApiCreateTournamentRequest {
	r.audienceIds = &audienceIds
	return r
}

// Activate/deactivate the tournament
func (r ApiCreateTournamentRequest) Active(active bool) ApiCreateTournamentRequest {
	r.active = &active
	return r
}

// Determines whether to allow players to buy back into a tournament
func (r ApiCreateTournamentRequest) EnableBuyBack(enableBuyBack bool) ApiCreateTournamentRequest {
	r.enableBuyBack = &enableBuyBack
	return r
}

// The list of offers to give as a reward beyond the tickets
func (r ApiCreateTournamentRequest) OfferIds(offerIds string) ApiCreateTournamentRequest {
	r.offerIds = &offerIds
	return r
}

// The artwork ID to attach to the reward tickets offers
func (r ApiCreateTournamentRequest) OfferAssetId(offerAssetId int64) ApiCreateTournamentRequest {
	r.offerAssetId = &offerAssetId
	return r
}

// If set then do not update the ticket reward, auto set to true if offerIds provided
func (r ApiCreateTournamentRequest) FixedReward(fixedReward bool) ApiCreateTournamentRequest {
	r.fixedReward = &fixedReward
	return r
}

// Set the rules for handling the reward in case of a tie, values: EVEN split the reward evenly ALL everyone gets the full reward value FIRST first score submitted RANDOM random player who scored
func (r ApiCreateTournamentRequest) SplitReward(splitReward string) ApiCreateTournamentRequest {
	r.splitReward = &splitReward
	return r
}

// Flag to indicate owner should receive tickets for completed missions
func (r ApiCreateTournamentRequest) AllocateTickets(allocateTickets bool) ApiCreateTournamentRequest {
	r.allocateTickets = &allocateTickets
	return r
}

// A text based string that will be passed into each tournament setup to populate the content
func (r ApiCreateTournamentRequest) TournamentData(tournamentData string) ApiCreateTournamentRequest {
	r.tournamentData = &tournamentData
	return r
}

// The style of tournament to build, options are: TOURNAMENT, POOLPLAY
func (r ApiCreateTournamentRequest) MissionType(missionType string) ApiCreateTournamentRequest {
	r.missionType = &missionType
	return r
}

// Sets the visibility flag for the tournament
func (r ApiCreateTournamentRequest) Visibility(visibility string) ApiCreateTournamentRequest {
	r.visibility = &visibility
	return r
}

// The number of initial preliminary groups in a multi-stage tournament (this is expected to be a power of two number)
func (r ApiCreateTournamentRequest) PreliminaryGroups(preliminaryGroups int32) ApiCreateTournamentRequest {
	r.preliminaryGroups = &preliminaryGroups
	return r
}

// This determines how many people can advance per round in a preliminary group (this is a comma separated list of integers)
func (r ApiCreateTournamentRequest) PreliminaryGroupAdvancements(preliminaryGroupAdvancements string) ApiCreateTournamentRequest {
	r.preliminaryGroupAdvancements = &preliminaryGroupAdvancements
	return r
}

// This determines if multiple submissions/entries are allowed in a multi-stage album tournament
func (r ApiCreateTournamentRequest) EnableMultipleEntries(enableMultipleEntries bool) ApiCreateTournamentRequest {
	r.enableMultipleEntries = &enableMultipleEntries
	return r
}

// This determines if users are allowed to vote multiple times per group in a multi-stage album tournament
func (r ApiCreateTournamentRequest) EnableMultipleVotes(enableMultipleVotes bool) ApiCreateTournamentRequest {
	r.enableMultipleVotes = &enableMultipleVotes
	return r
}

// This determines whether the tournament is \&quot;featured\&quot; or not
func (r ApiCreateTournamentRequest) Featured(featured bool) ApiCreateTournamentRequest {
	r.featured = &featured
	return r
}

// This sets what analytic tag is used when a winner is determined
func (r ApiCreateTournamentRequest) WinnerTag(winnerTag string) ApiCreateTournamentRequest {
	r.winnerTag = &winnerTag
	return r
}

// This sets what analytic tag is used when a tie has occurred
func (r ApiCreateTournamentRequest) TieTag(tieTag string) ApiCreateTournamentRequest {
	r.tieTag = &tieTag
	return r
}

func (r ApiCreateTournamentRequest) Execute() (*TournamentResponse, *http.Response, error) {
	return r.ApiService.CreateTournamentExecute(r)
}

/*
CreateTournament Create Tournament

Create a tournament.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiCreateTournamentRequest
*/
func (a *TournamentAPIService) CreateTournament(ctx context.Context, version float32) ApiCreateTournamentRequest {
	return ApiCreateTournamentRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return TournamentResponse
func (a *TournamentAPIService) CreateTournamentExecute(r ApiCreateTournamentRequest) (*TournamentResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TournamentResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TournamentAPIService.CreateTournament")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/tournament/create"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.appKey == nil {
		return localVarReturnValue, nil, reportError("appKey is required and must be specified")
	}
	if r.title == nil {
		return localVarReturnValue, nil, reportError("title is required and must be specified")
	}
	if r.costToPlay == nil {
		return localVarReturnValue, nil, reportError("costToPlay is required and must be specified")
	}
	if r.startDate == nil {
		return localVarReturnValue, nil, reportError("startDate is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "title", r.title, "form", "")
	if r.subType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subType", r.subType, "form", "")
	}
	if r.imageAssetId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageAssetId", r.imageAssetId, "form", "")
	}
	if r.secondsBetweenLevels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "secondsBetweenLevels", r.secondsBetweenLevels, "form", "")
	} else {
		var defaultValue int32 = 600
		parameterAddToHeaderOrQuery(localVarQueryParams, "secondsBetweenLevels", defaultValue, "form", "")
		r.secondsBetweenLevels = &defaultValue
	}
	if r.secondsForTieBreaker != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "secondsForTieBreaker", r.secondsForTieBreaker, "form", "")
	} else {
		var defaultValue int32 = 600
		parameterAddToHeaderOrQuery(localVarQueryParams, "secondsForTieBreaker", defaultValue, "form", "")
		r.secondsForTieBreaker = &defaultValue
	}
	if r.secondsBetweenPacks != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "secondsBetweenPacks", r.secondsBetweenPacks, "form", "")
	} else {
		var defaultValue int32 = 86400
		parameterAddToHeaderOrQuery(localVarQueryParams, "secondsBetweenPacks", defaultValue, "form", "")
		r.secondsBetweenPacks = &defaultValue
	}
	if r.maximumLevelLength != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maximumLevelLength", r.maximumLevelLength, "form", "")
	} else {
		var defaultValue int32 = 1800
		parameterAddToHeaderOrQuery(localVarQueryParams, "maximumLevelLength", defaultValue, "form", "")
		r.maximumLevelLength = &defaultValue
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "costToPlay", r.costToPlay, "form", "")
	if r.costToPlayType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "costToPlayType", r.costToPlayType, "form", "")
	}
	if r.minimumToPlay != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "minimumToPlay", r.minimumToPlay, "form", "")
	} else {
		var defaultValue int32 = 1
		parameterAddToHeaderOrQuery(localVarQueryParams, "minimumToPlay", defaultValue, "form", "")
		r.minimumToPlay = &defaultValue
	}
	if r.startingLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startingLimit", r.startingLimit, "form", "")
	}
	if r.availableLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "availableLimit", r.availableLimit, "form", "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "form", "")
	}
	if r.metaData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metaData", r.metaData, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "form", "")
	if r.audienceIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audienceIds", r.audienceIds, "form", "")
	}
	if r.active != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active", r.active, "form", "")
	}
	if r.enableBuyBack != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableBuyBack", r.enableBuyBack, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableBuyBack", defaultValue, "form", "")
		r.enableBuyBack = &defaultValue
	}
	if r.offerIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offerIds", r.offerIds, "form", "")
	}
	if r.offerAssetId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offerAssetId", r.offerAssetId, "form", "")
	}
	if r.fixedReward != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fixedReward", r.fixedReward, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "fixedReward", defaultValue, "form", "")
		r.fixedReward = &defaultValue
	}
	if r.splitReward != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "splitReward", r.splitReward, "form", "")
	} else {
		var defaultValue string = "ALL"
		parameterAddToHeaderOrQuery(localVarQueryParams, "splitReward", defaultValue, "form", "")
		r.splitReward = &defaultValue
	}
	if r.allocateTickets != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allocateTickets", r.allocateTickets, "form", "")
	}
	if r.tournamentData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tournamentData", r.tournamentData, "form", "")
	}
	if r.missionType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "missionType", r.missionType, "form", "")
	} else {
		var defaultValue string = "MULTISTAGE"
		parameterAddToHeaderOrQuery(localVarQueryParams, "missionType", defaultValue, "form", "")
		r.missionType = &defaultValue
	}
	if r.visibility != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "visibility", r.visibility, "form", "")
	} else {
		var defaultValue string = "PUBLIC"
		parameterAddToHeaderOrQuery(localVarQueryParams, "visibility", defaultValue, "form", "")
		r.visibility = &defaultValue
	}
	if r.preliminaryGroups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preliminaryGroups", r.preliminaryGroups, "form", "")
	} else {
		var defaultValue int32 = 1
		parameterAddToHeaderOrQuery(localVarQueryParams, "preliminaryGroups", defaultValue, "form", "")
		r.preliminaryGroups = &defaultValue
	}
	if r.preliminaryGroupAdvancements != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preliminaryGroupAdvancements", r.preliminaryGroupAdvancements, "form", "")
	} else {
		var defaultValue string = "1"
		parameterAddToHeaderOrQuery(localVarQueryParams, "preliminaryGroupAdvancements", defaultValue, "form", "")
		r.preliminaryGroupAdvancements = &defaultValue
	}
	if r.enableMultipleEntries != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableMultipleEntries", r.enableMultipleEntries, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableMultipleEntries", defaultValue, "form", "")
		r.enableMultipleEntries = &defaultValue
	}
	if r.enableMultipleVotes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableMultipleVotes", r.enableMultipleVotes, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableMultipleVotes", defaultValue, "form", "")
		r.enableMultipleVotes = &defaultValue
	}
	if r.featured != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "featured", r.featured, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "featured", defaultValue, "form", "")
		r.featured = &defaultValue
	}
	if r.winnerTag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "winnerTag", r.winnerTag, "form", "")
	}
	if r.tieTag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tieTag", r.tieTag, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteTournamentRequest struct {
	ctx context.Context
	ApiService *TournamentAPIService
	version float32
	accountId *int64
	missionId *int64
}

// the id of the logged in user
func (r ApiDeleteTournamentRequest) AccountId(accountId int64) ApiDeleteTournamentRequest {
	r.accountId = &accountId
	return r
}

// the id of the mission to delete
func (r ApiDeleteTournamentRequest) MissionId(missionId int64) ApiDeleteTournamentRequest {
	r.missionId = &missionId
	return r
}

func (r ApiDeleteTournamentRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.DeleteTournamentExecute(r)
}

/*
DeleteTournament Delete Tournament

Delete a tournament.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiDeleteTournamentRequest
*/
func (a *TournamentAPIService) DeleteTournament(ctx context.Context, version float32) ApiDeleteTournamentRequest {
	return ApiDeleteTournamentRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *TournamentAPIService) DeleteTournamentExecute(r ApiDeleteTournamentRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TournamentAPIService.DeleteTournament")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/tournament/delete"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.missionId == nil {
		return localVarReturnValue, nil, reportError("missionId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "missionId", r.missionId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTournamentRequest struct {
	ctx context.Context
	ApiService *TournamentAPIService
	version float32
	accountId *int64
	missionId *int64
	joinCode *string
	includeScores *string
	objectPreviewSize *int32
}

// The id of the logged in user
func (r ApiGetTournamentRequest) AccountId(accountId int64) ApiGetTournamentRequest {
	r.accountId = &accountId
	return r
}

// The id of the mission to return (either missionId or joinCode is required)
func (r ApiGetTournamentRequest) MissionId(missionId int64) ApiGetTournamentRequest {
	r.missionId = &missionId
	return r
}

// Optional identifier for getting the tournament (either missionId or joinCode is required)
func (r ApiGetTournamentRequest) JoinCode(joinCode string) ApiGetTournamentRequest {
	r.joinCode = &joinCode
	return r
}

// Determines which type of scores are returned. Possible values include: ALL, MINE
func (r ApiGetTournamentRequest) IncludeScores(includeScores string) ApiGetTournamentRequest {
	r.includeScores = &includeScores
	return r
}

// Determines the max number of game objects that will get returned for each game level response
func (r ApiGetTournamentRequest) ObjectPreviewSize(objectPreviewSize int32) ApiGetTournamentRequest {
	r.objectPreviewSize = &objectPreviewSize
	return r
}

func (r ApiGetTournamentRequest) Execute() (*TournamentResponse, *http.Response, error) {
	return r.ApiService.GetTournamentExecute(r)
}

/*
GetTournament Get Tournament

Get a tournament.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiGetTournamentRequest
*/
func (a *TournamentAPIService) GetTournament(ctx context.Context, version float32) ApiGetTournamentRequest {
	return ApiGetTournamentRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return TournamentResponse
func (a *TournamentAPIService) GetTournamentExecute(r ApiGetTournamentRequest) (*TournamentResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TournamentResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TournamentAPIService.GetTournament")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/tournament/get"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	if r.missionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "missionId", r.missionId, "form", "")
	}
	if r.joinCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "joinCode", r.joinCode, "form", "")
	}
	if r.includeScores != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeScores", r.includeScores, "form", "")
	}
	if r.objectPreviewSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "objectPreviewSize", r.objectPreviewSize, "form", "")
	} else {
		var defaultValue int32 = 50
		parameterAddToHeaderOrQuery(localVarQueryParams, "objectPreviewSize", defaultValue, "form", "")
		r.objectPreviewSize = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchObjectsRequest struct {
	ctx context.Context
	ApiService *TournamentAPIService
	version float32
	accountId *int64
	gameLevelId *int64
	sortField *string
	descending *bool
	start *int32
	limit *int32
}

// the account ID
func (r ApiSearchObjectsRequest) AccountId(accountId int64) ApiSearchObjectsRequest {
	r.accountId = &accountId
	return r
}

// the game level id to filter results by
func (r ApiSearchObjectsRequest) GameLevelId(gameLevelId int64) ApiSearchObjectsRequest {
	r.gameLevelId = &gameLevelId
	return r
}

// the field to sort by
func (r ApiSearchObjectsRequest) SortField(sortField string) ApiSearchObjectsRequest {
	r.sortField = &sortField
	return r
}

// determines whether the sorted list is in descending or ascending order
func (r ApiSearchObjectsRequest) Descending(descending bool) ApiSearchObjectsRequest {
	r.descending = &descending
	return r
}

// the start index for pagination
func (r ApiSearchObjectsRequest) Start(start int32) ApiSearchObjectsRequest {
	r.start = &start
	return r
}

// the limit for pagination
func (r ApiSearchObjectsRequest) Limit(limit int32) ApiSearchObjectsRequest {
	r.limit = &limit
	return r
}

func (r ApiSearchObjectsRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.SearchObjectsExecute(r)
}

/*
SearchObjects Search Tournament Objects

Search on game objects of tournaments

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiSearchObjectsRequest
*/
func (a *TournamentAPIService) SearchObjects(ctx context.Context, version float32) ApiSearchObjectsRequest {
	return ApiSearchObjectsRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *TournamentAPIService) SearchObjectsExecute(r ApiSearchObjectsRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TournamentAPIService.SearchObjects")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/tournament/object/search"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.gameLevelId == nil {
		return localVarReturnValue, nil, reportError("gameLevelId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "gameLevelId", r.gameLevelId, "form", "")
	if r.sortField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", r.sortField, "form", "")
	} else {
		var defaultValue string = "PLAYER_SCORE_COUNT"
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", defaultValue, "form", "")
		r.sortField = &defaultValue
	}
	if r.descending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "form", "")
	} else {
		var defaultValue bool = true
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", defaultValue, "form", "")
		r.descending = &defaultValue
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	} else {
		var defaultValue int32 = 0
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", defaultValue, "form", "")
		r.start = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 20
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchRoundsRequest struct {
	ctx context.Context
	ApiService *TournamentAPIService
	version float32
	accountId *int64
	appKey *string
	status *string
	missionType *string
	currentOnly *bool
	visibilities *string
	start *int32
	limit *int32
}

// the account ID
func (r ApiSearchRoundsRequest) AccountId(accountId int64) ApiSearchRoundsRequest {
	r.accountId = &accountId
	return r
}

// the application key
func (r ApiSearchRoundsRequest) AppKey(appKey string) ApiSearchRoundsRequest {
	r.appKey = &appKey
	return r
}

// comma separated list of statuses to filter results by
func (r ApiSearchRoundsRequest) Status(status string) ApiSearchRoundsRequest {
	r.status = &status
	return r
}

// The style of tournament to search for, options are: TOURNAMENT, POOLPLAY
func (r ApiSearchRoundsRequest) MissionType(missionType string) ApiSearchRoundsRequest {
	r.missionType = &missionType
	return r
}

// search for games that are flagged current only
func (r ApiSearchRoundsRequest) CurrentOnly(currentOnly bool) ApiSearchRoundsRequest {
	r.currentOnly = &currentOnly
	return r
}

// Filter tournament rounds by the mission visibility flag
func (r ApiSearchRoundsRequest) Visibilities(visibilities string) ApiSearchRoundsRequest {
	r.visibilities = &visibilities
	return r
}

// the start index for pagination
func (r ApiSearchRoundsRequest) Start(start int32) ApiSearchRoundsRequest {
	r.start = &start
	return r
}

// the limit for pagination
func (r ApiSearchRoundsRequest) Limit(limit int32) ApiSearchRoundsRequest {
	r.limit = &limit
	return r
}

func (r ApiSearchRoundsRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.SearchRoundsExecute(r)
}

/*
SearchRounds Search Tournament Rounds

Search for the user's tournament games.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiSearchRoundsRequest
*/
func (a *TournamentAPIService) SearchRounds(ctx context.Context, version float32) ApiSearchRoundsRequest {
	return ApiSearchRoundsRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *TournamentAPIService) SearchRoundsExecute(r ApiSearchRoundsRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TournamentAPIService.SearchRounds")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/tournament/round/search"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.appKey == nil {
		return localVarReturnValue, nil, reportError("appKey is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	} else {
		var defaultValue string = "ACCEPTED,ACTIVE"
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", defaultValue, "form", "")
		r.status = &defaultValue
	}
	if r.missionType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "missionType", r.missionType, "form", "")
	}
	if r.currentOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currentOnly", r.currentOnly, "form", "")
	} else {
		var defaultValue bool = true
		parameterAddToHeaderOrQuery(localVarQueryParams, "currentOnly", defaultValue, "form", "")
		r.currentOnly = &defaultValue
	}
	if r.visibilities != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "visibilities", r.visibilities, "form", "")
	} else {
		var defaultValue string = "PUBLIC"
		parameterAddToHeaderOrQuery(localVarQueryParams, "visibilities", defaultValue, "form", "")
		r.visibilities = &defaultValue
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	} else {
		var defaultValue int32 = 0
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", defaultValue, "form", "")
		r.start = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 20
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchTournamentsRequest struct {
	ctx context.Context
	ApiService *TournamentAPIService
	version float32
	accountId *int64
	appKey *string
	keyword *string
	subType *string
	includeInactive *bool
	missionTypes *string
	filter *string
	sortField *string
	descending *bool
	visibility *string
	start *int32
	limit *int32
}

// The logged in user.
func (r ApiSearchTournamentsRequest) AccountId(accountId int64) ApiSearchTournamentsRequest {
	r.accountId = &accountId
	return r
}

// The application key
func (r ApiSearchTournamentsRequest) AppKey(appKey string) ApiSearchTournamentsRequest {
	r.appKey = &appKey
	return r
}

// the keyword to search tournament on
func (r ApiSearchTournamentsRequest) Keyword(keyword string) ApiSearchTournamentsRequest {
	r.keyword = &keyword
	return r
}

// filter results by subType
func (r ApiSearchTournamentsRequest) SubType(subType string) ApiSearchTournamentsRequest {
	r.subType = &subType
	return r
}

// whether to include inactives in the search or not
func (r ApiSearchTournamentsRequest) IncludeInactive(includeInactive bool) ApiSearchTournamentsRequest {
	r.includeInactive = &includeInactive
	return r
}

// comma separated list of mission types to filter results, possbile values include: TOURNAMENT, POOLPLAY, MULTISTAGE
func (r ApiSearchTournamentsRequest) MissionTypes(missionTypes string) ApiSearchTournamentsRequest {
	r.missionTypes = &missionTypes
	return r
}

// filter tournaments by the tournament&#39;s current state
func (r ApiSearchTournamentsRequest) Filter(filter string) ApiSearchTournamentsRequest {
	r.filter = &filter
	return r
}

// which field to sort on
func (r ApiSearchTournamentsRequest) SortField(sortField string) ApiSearchTournamentsRequest {
	r.sortField = &sortField
	return r
}

// Determines whether to return results in descending order. The default value will be true if the filter is \&quot;PAST\&quot;, otherwise the default value will be false.
func (r ApiSearchTournamentsRequest) Descending(descending bool) ApiSearchTournamentsRequest {
	r.descending = &descending
	return r
}

// Comma separated list of visibility flags for search for, possible values include: PUBLIC, LISTABLE, REWARDABLE, TRIGGERABLE, PRIVATE
func (r ApiSearchTournamentsRequest) Visibility(visibility string) ApiSearchTournamentsRequest {
	r.visibility = &visibility
	return r
}

// Start the result set at some index.
func (r ApiSearchTournamentsRequest) Start(start int32) ApiSearchTournamentsRequest {
	r.start = &start
	return r
}

// Limit the result to some number
func (r ApiSearchTournamentsRequest) Limit(limit int32) ApiSearchTournamentsRequest {
	r.limit = &limit
	return r
}

func (r ApiSearchTournamentsRequest) Execute() (*MissionShortResponse, *http.Response, error) {
	return r.ApiService.SearchTournamentsExecute(r)
}

/*
SearchTournaments Search Tournaments

Search for tournaments

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiSearchTournamentsRequest
*/
func (a *TournamentAPIService) SearchTournaments(ctx context.Context, version float32) ApiSearchTournamentsRequest {
	return ApiSearchTournamentsRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return MissionShortResponse
func (a *TournamentAPIService) SearchTournamentsExecute(r ApiSearchTournamentsRequest) (*MissionShortResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MissionShortResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TournamentAPIService.SearchTournaments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/tournament/search"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.appKey == nil {
		return localVarReturnValue, nil, reportError("appKey is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	if r.keyword != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyword", r.keyword, "form", "")
	}
	if r.subType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subType", r.subType, "form", "")
	}
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", defaultValue, "form", "")
		r.includeInactive = &defaultValue
	}
	if r.missionTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "missionTypes", r.missionTypes, "form", "")
	} else {
		var defaultValue string = "MULTISTAGE,TOURNAMENT,POOLPLAY"
		parameterAddToHeaderOrQuery(localVarQueryParams, "missionTypes", defaultValue, "form", "")
		r.missionTypes = &defaultValue
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	} else {
		var defaultValue string = "UPCOMING"
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", defaultValue, "form", "")
		r.filter = &defaultValue
	}
	if r.sortField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", r.sortField, "form", "")
	} else {
		var defaultValue string = "START_DATE"
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", defaultValue, "form", "")
		r.sortField = &defaultValue
	}
	if r.descending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "form", "")
	}
	if r.visibility != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "visibility", r.visibility, "form", "")
	} else {
		var defaultValue string = "PUBLIC"
		parameterAddToHeaderOrQuery(localVarQueryParams, "visibility", defaultValue, "form", "")
		r.visibility = &defaultValue
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	} else {
		var defaultValue int32 = 0
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", defaultValue, "form", "")
		r.start = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 20
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubmitTournamentScoreRequest struct {
	ctx context.Context
	ApiService *TournamentAPIService
	version float32
	accountId *int64
	appKey *string
	missionId *int64
	gameId *int64
	packId *int64
	scores *string
	gameLevelId *int64
}

// The logged in user account ID.
func (r ApiSubmitTournamentScoreRequest) AccountId(accountId int64) ApiSubmitTournamentScoreRequest {
	r.accountId = &accountId
	return r
}

// The application key.
func (r ApiSubmitTournamentScoreRequest) AppKey(appKey string) ApiSubmitTournamentScoreRequest {
	r.appKey = &appKey
	return r
}

// The missionId to score for
func (r ApiSubmitTournamentScoreRequest) MissionId(missionId int64) ApiSubmitTournamentScoreRequest {
	r.missionId = &missionId
	return r
}

// The gameId to score for
func (r ApiSubmitTournamentScoreRequest) GameId(gameId int64) ApiSubmitTournamentScoreRequest {
	r.gameId = &gameId
	return r
}

// The packId to score for
func (r ApiSubmitTournamentScoreRequest) PackId(packId int64) ApiSubmitTournamentScoreRequest {
	r.packId = &packId
	return r
}

// a JSON Array of scores to submit for a tournament match &#x60;&#x60;&#x60;json [   {     \&quot;accountId\&quot;: 2,     \&quot;points\&quot;: 3   },   {     \&quot;accountId\&quot;: 1777662,     \&quot;points\&quot;: 7   } ] &#x60;&#x60;&#x60; 
func (r ApiSubmitTournamentScoreRequest) Scores(scores string) ApiSubmitTournamentScoreRequest {
	r.scores = &scores
	return r
}

// The gameLevelId to score for
func (r ApiSubmitTournamentScoreRequest) GameLevelId(gameLevelId int64) ApiSubmitTournamentScoreRequest {
	r.gameLevelId = &gameLevelId
	return r
}

func (r ApiSubmitTournamentScoreRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.SubmitTournamentScoreExecute(r)
}

/*
SubmitTournamentScore Submit Tournament Score

Submit an array of scores for a tournament match. 

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiSubmitTournamentScoreRequest
*/
func (a *TournamentAPIService) SubmitTournamentScore(ctx context.Context, version float32) ApiSubmitTournamentScoreRequest {
	return ApiSubmitTournamentScoreRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *TournamentAPIService) SubmitTournamentScoreExecute(r ApiSubmitTournamentScoreRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TournamentAPIService.SubmitTournamentScore")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/tournament/score"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.appKey == nil {
		return localVarReturnValue, nil, reportError("appKey is required and must be specified")
	}
	if r.missionId == nil {
		return localVarReturnValue, nil, reportError("missionId is required and must be specified")
	}
	if r.gameId == nil {
		return localVarReturnValue, nil, reportError("gameId is required and must be specified")
	}
	if r.packId == nil {
		return localVarReturnValue, nil, reportError("packId is required and must be specified")
	}
	if r.scores == nil {
		return localVarReturnValue, nil, reportError("scores is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "missionId", r.missionId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "gameId", r.gameId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "packId", r.packId, "form", "")
	if r.gameLevelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gameLevelId", r.gameLevelId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "scores", r.scores, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubmitTournamentVoteRequest struct {
	ctx context.Context
	ApiService *TournamentAPIService
	version float32
	accountId *int64
	appKey *string
	missionId *int64
	gameObjectId *int64
	deviceId *string
	checkIfDeviceAlreadyVoted *bool
}

// The logged in user.
func (r ApiSubmitTournamentVoteRequest) AccountId(accountId int64) ApiSubmitTournamentVoteRequest {
	r.accountId = &accountId
	return r
}

// The application to target
func (r ApiSubmitTournamentVoteRequest) AppKey(appKey string) ApiSubmitTournamentVoteRequest {
	r.appKey = &appKey
	return r
}

// The tournament&#39;s primary id
func (r ApiSubmitTournamentVoteRequest) MissionId(missionId int64) ApiSubmitTournamentVoteRequest {
	r.missionId = &missionId
	return r
}

// The tournament game object the user wants to vote on
func (r ApiSubmitTournamentVoteRequest) GameObjectId(gameObjectId int64) ApiSubmitTournamentVoteRequest {
	r.gameObjectId = &gameObjectId
	return r
}

// The unique id of the device making the request (optional)
func (r ApiSubmitTournamentVoteRequest) DeviceId(deviceId string) ApiSubmitTournamentVoteRequest {
	r.deviceId = &deviceId
	return r
}

// When true, check if the device already voted to prevent duplicate votes from the same device
func (r ApiSubmitTournamentVoteRequest) CheckIfDeviceAlreadyVoted(checkIfDeviceAlreadyVoted bool) ApiSubmitTournamentVoteRequest {
	r.checkIfDeviceAlreadyVoted = &checkIfDeviceAlreadyVoted
	return r
}

func (r ApiSubmitTournamentVoteRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.SubmitTournamentVoteExecute(r)
}

/*
SubmitTournamentVote Submit a vote for a multi-stage album tournament.

Submit a vote for a multi-stage album tournament.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiSubmitTournamentVoteRequest
*/
func (a *TournamentAPIService) SubmitTournamentVote(ctx context.Context, version float32) ApiSubmitTournamentVoteRequest {
	return ApiSubmitTournamentVoteRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *TournamentAPIService) SubmitTournamentVoteExecute(r ApiSubmitTournamentVoteRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TournamentAPIService.SubmitTournamentVote")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/tournament/vote"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.appKey == nil {
		return localVarReturnValue, nil, reportError("appKey is required and must be specified")
	}
	if r.missionId == nil {
		return localVarReturnValue, nil, reportError("missionId is required and must be specified")
	}
	if r.gameObjectId == nil {
		return localVarReturnValue, nil, reportError("gameObjectId is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "missionId", r.missionId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "gameObjectId", r.gameObjectId, "form", "")
	if r.checkIfDeviceAlreadyVoted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "checkIfDeviceAlreadyVoted", r.checkIfDeviceAlreadyVoted, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "checkIfDeviceAlreadyVoted", defaultValue, "form", "")
		r.checkIfDeviceAlreadyVoted = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubstituteTournamentPlayerRequest struct {
	ctx context.Context
	ApiService *TournamentAPIService
	version float32
	accountId *int64
	missionId *int64
	packId *int64
	gameLevelId *int64
}

// the id of the logged in user
func (r ApiSubstituteTournamentPlayerRequest) AccountId(accountId int64) ApiSubstituteTournamentPlayerRequest {
	r.accountId = &accountId
	return r
}

// the id of the mission
func (r ApiSubstituteTournamentPlayerRequest) MissionId(missionId int64) ApiSubstituteTournamentPlayerRequest {
	r.missionId = &missionId
	return r
}

// the id of the pack
func (r ApiSubstituteTournamentPlayerRequest) PackId(packId int64) ApiSubstituteTournamentPlayerRequest {
	r.packId = &packId
	return r
}

// the id of the game level
func (r ApiSubstituteTournamentPlayerRequest) GameLevelId(gameLevelId int64) ApiSubstituteTournamentPlayerRequest {
	r.gameLevelId = &gameLevelId
	return r
}

func (r ApiSubstituteTournamentPlayerRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.SubstituteTournamentPlayerExecute(r)
}

/*
SubstituteTournamentPlayer Substitute Tournament Player

Service to replace the user's opponent in the current level - pack - mission with an AI account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiSubstituteTournamentPlayerRequest
*/
func (a *TournamentAPIService) SubstituteTournamentPlayer(ctx context.Context, version float32) ApiSubstituteTournamentPlayerRequest {
	return ApiSubstituteTournamentPlayerRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *TournamentAPIService) SubstituteTournamentPlayerExecute(r ApiSubstituteTournamentPlayerRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TournamentAPIService.SubstituteTournamentPlayer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/tournament/substitute"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.missionId == nil {
		return localVarReturnValue, nil, reportError("missionId is required and must be specified")
	}
	if r.packId == nil {
		return localVarReturnValue, nil, reportError("packId is required and must be specified")
	}
	if r.gameLevelId == nil {
		return localVarReturnValue, nil, reportError("gameLevelId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "missionId", r.missionId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "packId", r.packId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "gameLevelId", r.gameLevelId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateTournamentRequest struct {
	ctx context.Context
	ApiService *TournamentAPIService
	version float32
	accountId *int64
	missionId *int64
	title *string
	subType *string
	imageAssetId *int64
	secondsBetweenLevels *int32
	secondsForTieBreaker *int32
	secondsBetweenPacks *int32
	maximumLevelLength *int32
	costToPlay *int32
	costToPlayType *string
	minimumToPlay *int32
	startingLimit *int32
	availableLimit *int32
	description *string
	metaData *string
	startDate *int64
	audienceIds *string
	active *bool
	enableBuyBack *bool
	offerIds *string
	offerAssetId *int64
	fixedReward *bool
	splitReward *string
	allocateTickets *bool
	tournamentData *string
	visibility *string
	preliminaryGroups *int32
	preliminaryGroupAdvancements *string
	enableMultipleEntries *bool
	enableMultipleVotes *bool
	featured *bool
	winnerTag *string
	tieTag *string
}

// The logged in user.
func (r ApiUpdateTournamentRequest) AccountId(accountId int64) ApiUpdateTournamentRequest {
	r.accountId = &accountId
	return r
}

// The mission/tournament to update
func (r ApiUpdateTournamentRequest) MissionId(missionId int64) ApiUpdateTournamentRequest {
	r.missionId = &missionId
	return r
}

// The title of the tournament
func (r ApiUpdateTournamentRequest) Title(title string) ApiUpdateTournamentRequest {
	r.title = &title
	return r
}

// Custom string client apps can use for searching/filtering missions
func (r ApiUpdateTournamentRequest) SubType(subType string) ApiUpdateTournamentRequest {
	r.subType = &subType
	return r
}

// The asset ID to attach to the tournament
func (r ApiUpdateTournamentRequest) ImageAssetId(imageAssetId int64) ApiUpdateTournamentRequest {
	r.imageAssetId = &imageAssetId
	return r
}

// The number of seconds in between the start of each tournament game
func (r ApiUpdateTournamentRequest) SecondsBetweenLevels(secondsBetweenLevels int32) ApiUpdateTournamentRequest {
	r.secondsBetweenLevels = &secondsBetweenLevels
	return r
}

// The number of seconds to extend the round end time in the case of a tie breaker
func (r ApiUpdateTournamentRequest) SecondsForTieBreaker(secondsForTieBreaker int32) ApiUpdateTournamentRequest {
	r.secondsForTieBreaker = &secondsForTieBreaker
	return r
}

// The number of seconds in between the start of each tournament round
func (r ApiUpdateTournamentRequest) SecondsBetweenPacks(secondsBetweenPacks int32) ApiUpdateTournamentRequest {
	r.secondsBetweenPacks = &secondsBetweenPacks
	return r
}

// The maximum number of seconds the match is expected to end at, which gets used to determine when a match should end when there is no activity
func (r ApiUpdateTournamentRequest) MaximumLevelLength(maximumLevelLength int32) ApiUpdateTournamentRequest {
	r.maximumLevelLength = &maximumLevelLength
	return r
}

// The number of tickets required to pay to enter the tournament
func (r ApiUpdateTournamentRequest) CostToPlay(costToPlay int32) ApiUpdateTournamentRequest {
	r.costToPlay = &costToPlay
	return r
}

// The type of ticket required to pay
func (r ApiUpdateTournamentRequest) CostToPlayType(costToPlayType string) ApiUpdateTournamentRequest {
	r.costToPlayType = &costToPlayType
	return r
}

// The minimum number of players required to sign up for the tournament to be played
func (r ApiUpdateTournamentRequest) MinimumToPlay(minimumToPlay int32) ApiUpdateTournamentRequest {
	r.minimumToPlay = &minimumToPlay
	return r
}

// The starting number of players for a tournament (filled with AI&#39;s)
func (r ApiUpdateTournamentRequest) StartingLimit(startingLimit int32) ApiUpdateTournamentRequest {
	r.startingLimit = &startingLimit
	return r
}

// The maximum number of players for a tournament (currently 128 but not enforced)
func (r ApiUpdateTournamentRequest) AvailableLimit(availableLimit int32) ApiUpdateTournamentRequest {
	r.availableLimit = &availableLimit
	return r
}

// The description of the tournament
func (r ApiUpdateTournamentRequest) Description(description string) ApiUpdateTournamentRequest {
	r.description = &description
	return r
}

// External custom client defined data
func (r ApiUpdateTournamentRequest) MetaData(metaData string) ApiUpdateTournamentRequest {
	r.metaData = &metaData
	return r
}

// The date/time to start the tournament
func (r ApiUpdateTournamentRequest) StartDate(startDate int64) ApiUpdateTournamentRequest {
	r.startDate = &startDate
	return r
}

// The audiences associated with the tournament
func (r ApiUpdateTournamentRequest) AudienceIds(audienceIds string) ApiUpdateTournamentRequest {
	r.audienceIds = &audienceIds
	return r
}

// Activate/deactivate the mission
func (r ApiUpdateTournamentRequest) Active(active bool) ApiUpdateTournamentRequest {
	r.active = &active
	return r
}

// Determines whether to allow players to buy back into a tournament
func (r ApiUpdateTournamentRequest) EnableBuyBack(enableBuyBack bool) ApiUpdateTournamentRequest {
	r.enableBuyBack = &enableBuyBack
	return r
}

// The list of offers to give as a reward beyond the tickets
func (r ApiUpdateTournamentRequest) OfferIds(offerIds string) ApiUpdateTournamentRequest {
	r.offerIds = &offerIds
	return r
}

// The artwork ID to attach to the reward offer
func (r ApiUpdateTournamentRequest) OfferAssetId(offerAssetId int64) ApiUpdateTournamentRequest {
	r.offerAssetId = &offerAssetId
	return r
}

// If set then do not update the ticket reward, auto set to true if offerIds provided
func (r ApiUpdateTournamentRequest) FixedReward(fixedReward bool) ApiUpdateTournamentRequest {
	r.fixedReward = &fixedReward
	return r
}

// Set the rules for handling the reward in case of a tie, values: EVEN split the reward evenly ALL everyone gets the full reward value FIRST first score submitted RANDOM random player who scored
func (r ApiUpdateTournamentRequest) SplitReward(splitReward string) ApiUpdateTournamentRequest {
	r.splitReward = &splitReward
	return r
}

// Flag to indicate owner should receive tickets for completed missions
func (r ApiUpdateTournamentRequest) AllocateTickets(allocateTickets bool) ApiUpdateTournamentRequest {
	r.allocateTickets = &allocateTickets
	return r
}

// A text based string that will be passed into each tournament setup to populate the content
func (r ApiUpdateTournamentRequest) TournamentData(tournamentData string) ApiUpdateTournamentRequest {
	r.tournamentData = &tournamentData
	return r
}

// Sets the visibility flag for the tournament
func (r ApiUpdateTournamentRequest) Visibility(visibility string) ApiUpdateTournamentRequest {
	r.visibility = &visibility
	return r
}

// The number of initial preliminary groups in a multi-stage tournament (this is expected to be a power of two number)
func (r ApiUpdateTournamentRequest) PreliminaryGroups(preliminaryGroups int32) ApiUpdateTournamentRequest {
	r.preliminaryGroups = &preliminaryGroups
	return r
}

// This determines how many people can advance per round in a preliminary group (this is a comma separated list of integers)
func (r ApiUpdateTournamentRequest) PreliminaryGroupAdvancements(preliminaryGroupAdvancements string) ApiUpdateTournamentRequest {
	r.preliminaryGroupAdvancements = &preliminaryGroupAdvancements
	return r
}

// This determines if multiple submissions/entries are allowed in a multi-stage album tournament
func (r ApiUpdateTournamentRequest) EnableMultipleEntries(enableMultipleEntries bool) ApiUpdateTournamentRequest {
	r.enableMultipleEntries = &enableMultipleEntries
	return r
}

// This determines if users are allowed to vote multiple times per group in a multi-stage album tournament
func (r ApiUpdateTournamentRequest) EnableMultipleVotes(enableMultipleVotes bool) ApiUpdateTournamentRequest {
	r.enableMultipleVotes = &enableMultipleVotes
	return r
}

// This determines whether the tournament is \&quot;featured\&quot; or not
func (r ApiUpdateTournamentRequest) Featured(featured bool) ApiUpdateTournamentRequest {
	r.featured = &featured
	return r
}

// This sets what analytic tag is used when a winner is determined
func (r ApiUpdateTournamentRequest) WinnerTag(winnerTag string) ApiUpdateTournamentRequest {
	r.winnerTag = &winnerTag
	return r
}

// This sets what analytic tag is used when a winner is determined
func (r ApiUpdateTournamentRequest) TieTag(tieTag string) ApiUpdateTournamentRequest {
	r.tieTag = &tieTag
	return r
}

func (r ApiUpdateTournamentRequest) Execute() (*TournamentResponse, *http.Response, error) {
	return r.ApiService.UpdateTournamentExecute(r)
}

/*
UpdateTournament Update Tournament

Update a tournament.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiUpdateTournamentRequest
*/
func (a *TournamentAPIService) UpdateTournament(ctx context.Context, version float32) ApiUpdateTournamentRequest {
	return ApiUpdateTournamentRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return TournamentResponse
func (a *TournamentAPIService) UpdateTournamentExecute(r ApiUpdateTournamentRequest) (*TournamentResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TournamentResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TournamentAPIService.UpdateTournament")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/tournament/update"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.missionId == nil {
		return localVarReturnValue, nil, reportError("missionId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "missionId", r.missionId, "form", "")
	if r.title != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "title", r.title, "form", "")
	}
	if r.subType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subType", r.subType, "form", "")
	}
	if r.imageAssetId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageAssetId", r.imageAssetId, "form", "")
	}
	if r.secondsBetweenLevels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "secondsBetweenLevels", r.secondsBetweenLevels, "form", "")
	}
	if r.secondsForTieBreaker != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "secondsForTieBreaker", r.secondsForTieBreaker, "form", "")
	}
	if r.secondsBetweenPacks != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "secondsBetweenPacks", r.secondsBetweenPacks, "form", "")
	}
	if r.maximumLevelLength != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maximumLevelLength", r.maximumLevelLength, "form", "")
	}
	if r.costToPlay != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "costToPlay", r.costToPlay, "form", "")
	}
	if r.costToPlayType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "costToPlayType", r.costToPlayType, "form", "")
	}
	if r.minimumToPlay != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "minimumToPlay", r.minimumToPlay, "form", "")
	}
	if r.startingLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startingLimit", r.startingLimit, "form", "")
	}
	if r.availableLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "availableLimit", r.availableLimit, "form", "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "form", "")
	}
	if r.metaData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metaData", r.metaData, "form", "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "form", "")
	}
	if r.audienceIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audienceIds", r.audienceIds, "form", "")
	}
	if r.active != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active", r.active, "form", "")
	}
	if r.enableBuyBack != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableBuyBack", r.enableBuyBack, "form", "")
	}
	if r.offerIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offerIds", r.offerIds, "form", "")
	}
	if r.offerAssetId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offerAssetId", r.offerAssetId, "form", "")
	}
	if r.fixedReward != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fixedReward", r.fixedReward, "form", "")
	}
	if r.splitReward != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "splitReward", r.splitReward, "form", "")
	}
	if r.allocateTickets != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allocateTickets", r.allocateTickets, "form", "")
	}
	if r.tournamentData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tournamentData", r.tournamentData, "form", "")
	}
	if r.visibility != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "visibility", r.visibility, "form", "")
	}
	if r.preliminaryGroups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preliminaryGroups", r.preliminaryGroups, "form", "")
	}
	if r.preliminaryGroupAdvancements != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preliminaryGroupAdvancements", r.preliminaryGroupAdvancements, "form", "")
	}
	if r.enableMultipleEntries != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableMultipleEntries", r.enableMultipleEntries, "form", "")
	}
	if r.enableMultipleVotes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableMultipleVotes", r.enableMultipleVotes, "form", "")
	}
	if r.featured != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "featured", r.featured, "form", "")
	}
	if r.winnerTag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "winnerTag", r.winnerTag, "form", "")
	}
	if r.tieTag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tieTag", r.tieTag, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
