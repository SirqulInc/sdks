/*
Sirqul IoT Platform

Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

API version: 3.16
Contact: info@sirqul.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// CategoryAPIService CategoryAPI service
type CategoryAPIService service

type ApiCategoryDistanceSearchRequest struct {
	ctx context.Context
	ApiService *CategoryAPIService
	version float32
	accountId *int64
	keyword *string
	appKey *string
	categoryIds *string
	parentCategoryIds *string
	rootOnly *bool
	sortField *string
	responseGroup *string
	descending *bool
	start *int32
	limit *int32
	activeOnly *bool
	returnExternal *bool
	exactMatch *bool
	type_ *string
	externalType *string
	minOfferCount *int32
	latitude *float64
	longitude *float64
	range_ *float64
}

// The account id of the user
func (r ApiCategoryDistanceSearchRequest) AccountId(accountId int64) ApiCategoryDistanceSearchRequest {
	r.accountId = &accountId
	return r
}

// The keyword string to search on
func (r ApiCategoryDistanceSearchRequest) Keyword(keyword string) ApiCategoryDistanceSearchRequest {
	r.keyword = &keyword
	return r
}

// the appKey of the application to retrieve categories for, if not specified then search on the global application.
func (r ApiCategoryDistanceSearchRequest) AppKey(appKey string) ApiCategoryDistanceSearchRequest {
	r.appKey = &appKey
	return r
}

// Restrict the search by specific categories
func (r ApiCategoryDistanceSearchRequest) CategoryIds(categoryIds string) ApiCategoryDistanceSearchRequest {
	r.categoryIds = &categoryIds
	return r
}

// Restrict the search by specific parent categories so that only its sub children are searched.
func (r ApiCategoryDistanceSearchRequest) ParentCategoryIds(parentCategoryIds string) ApiCategoryDistanceSearchRequest {
	r.parentCategoryIds = &parentCategoryIds
	return r
}

// Restrict the search to only those categories with no parent category assigned.
func (r ApiCategoryDistanceSearchRequest) RootOnly(rootOnly bool) ApiCategoryDistanceSearchRequest {
	r.rootOnly = &rootOnly
	return r
}

// The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, DISPLAY
func (r ApiCategoryDistanceSearchRequest) SortField(sortField string) ApiCategoryDistanceSearchRequest {
	r.sortField = &sortField
	return r
}

// The group of categories to return: ALL, GLOBAL or MINE. ALL returns both global and application specific matches, GLOBAL only returns global matches, and MINE only returns the application specific matches. If not provided search on the application provided.
func (r ApiCategoryDistanceSearchRequest) ResponseGroup(responseGroup string) ApiCategoryDistanceSearchRequest {
	r.responseGroup = &responseGroup
	return r
}

// The order to return the search results
func (r ApiCategoryDistanceSearchRequest) Descending(descending bool) ApiCategoryDistanceSearchRequest {
	r.descending = &descending
	return r
}

// The record to begin the return set on
func (r ApiCategoryDistanceSearchRequest) Start(start int32) ApiCategoryDistanceSearchRequest {
	r.start = &start
	return r
}

// The number of records to return
func (r ApiCategoryDistanceSearchRequest) Limit(limit int32) ApiCategoryDistanceSearchRequest {
	r.limit = &limit
	return r
}

// Determines whether to return only active categories
func (r ApiCategoryDistanceSearchRequest) ActiveOnly(activeOnly bool) ApiCategoryDistanceSearchRequest {
	r.activeOnly = &activeOnly
	return r
}

// Determines whether to return extra info about the category&#39;s \&quot;Participant\&quot; reference
func (r ApiCategoryDistanceSearchRequest) ReturnExternal(returnExternal bool) ApiCategoryDistanceSearchRequest {
	r.returnExternal = &returnExternal
	return r
}

// If true search categories using the exact keyword, if false then do a partial match (like) search.
func (r ApiCategoryDistanceSearchRequest) ExactMatch(exactMatch bool) ApiCategoryDistanceSearchRequest {
	r.exactMatch = &exactMatch
	return r
}

// Filters results by the Category&#39;s type
func (r ApiCategoryDistanceSearchRequest) Type_(type_ string) ApiCategoryDistanceSearchRequest {
	r.type_ = &type_
	return r
}

// Filters results by externalType
func (r ApiCategoryDistanceSearchRequest) ExternalType(externalType string) ApiCategoryDistanceSearchRequest {
	r.externalType = &externalType
	return r
}

// Filters results to only return Categories that have been referenced by a minimum number of Offers
func (r ApiCategoryDistanceSearchRequest) MinOfferCount(minOfferCount int32) ApiCategoryDistanceSearchRequest {
	r.minOfferCount = &minOfferCount
	return r
}

// the latitude of where the search is centered on
func (r ApiCategoryDistanceSearchRequest) Latitude(latitude float64) ApiCategoryDistanceSearchRequest {
	r.latitude = &latitude
	return r
}

// the longitude of where the search is centered on
func (r ApiCategoryDistanceSearchRequest) Longitude(longitude float64) ApiCategoryDistanceSearchRequest {
	r.longitude = &longitude
	return r
}

// the maximum range the category can be from the center
func (r ApiCategoryDistanceSearchRequest) Range_(range_ float64) ApiCategoryDistanceSearchRequest {
	r.range_ = &range_
	return r
}

func (r ApiCategoryDistanceSearchRequest) Execute() ([]CategoryResponse, *http.Response, error) {
	return r.ApiService.CategoryDistanceSearchExecute(r)
}

/*
CategoryDistanceSearch Search Categories by Distance

Search for categories by distance.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiCategoryDistanceSearchRequest
*/
func (a *CategoryAPIService) CategoryDistanceSearch(ctx context.Context, version float32) ApiCategoryDistanceSearchRequest {
	return ApiCategoryDistanceSearchRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return []CategoryResponse
func (a *CategoryAPIService) CategoryDistanceSearchExecute(r ApiCategoryDistanceSearchRequest) ([]CategoryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CategoryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CategoryAPIService.CategoryDistanceSearch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/category/distancesearch"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.keyword != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyword", r.keyword, "form", "")
	}
	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	if r.categoryIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "categoryIds", r.categoryIds, "form", "")
	}
	if r.parentCategoryIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parentCategoryIds", r.parentCategoryIds, "form", "")
	}
	if r.rootOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootOnly", r.rootOnly, "form", "")
	}
	if r.sortField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", r.sortField, "form", "")
	} else {
		var defaultValue string = "DISPLAY"
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", defaultValue, "form", "")
		r.sortField = &defaultValue
	}
	if r.responseGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "responseGroup", r.responseGroup, "form", "")
	}
	if r.descending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", defaultValue, "form", "")
		r.descending = &defaultValue
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	} else {
		var defaultValue int32 = 0
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", defaultValue, "form", "")
		r.start = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 20
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	if r.activeOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activeOnly", r.activeOnly, "form", "")
	} else {
		var defaultValue bool = true
		parameterAddToHeaderOrQuery(localVarQueryParams, "activeOnly", defaultValue, "form", "")
		r.activeOnly = &defaultValue
	}
	if r.returnExternal != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnExternal", r.returnExternal, "form", "")
	}
	if r.exactMatch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exactMatch", r.exactMatch, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.externalType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "externalType", r.externalType, "form", "")
	}
	if r.minOfferCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "minOfferCount", r.minOfferCount, "form", "")
	}
	if r.latitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latitude", r.latitude, "form", "")
	}
	if r.longitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "longitude", r.longitude, "form", "")
	}
	if r.range_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "range", r.range_, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCategoryRequest struct {
	ctx context.Context
	ApiService *CategoryAPIService
	version float32
	accountId *int64
	name *string
	appKey *string
	parentCategoryId *int64
	description *string
	type_ *string
	assetId *int64
	externalId *string
	externalType *string
	externalCategorySlug *string
	sqootSlug *string
	active *bool
	metaData *string
	searchTags *string
}

// The account id of the user (must have permissions to the target application)
func (r ApiCreateCategoryRequest) AccountId(accountId int64) ApiCreateCategoryRequest {
	r.accountId = &accountId
	return r
}

// The name of the category
func (r ApiCreateCategoryRequest) Name(name string) ApiCreateCategoryRequest {
	r.name = &name
	return r
}

// The appKey of the application to assign the category to, if not provided then the category will be applied to the global application (if the account has permissions)
func (r ApiCreateCategoryRequest) AppKey(appKey string) ApiCreateCategoryRequest {
	r.appKey = &appKey
	return r
}

// The ID of the parent category, if not provided then the parent category will be null
func (r ApiCreateCategoryRequest) ParentCategoryId(parentCategoryId int64) ApiCreateCategoryRequest {
	r.parentCategoryId = &parentCategoryId
	return r
}

// The description of the category
func (r ApiCreateCategoryRequest) Description(description string) ApiCreateCategoryRequest {
	r.description = &description
	return r
}

// The type of the category
func (r ApiCreateCategoryRequest) Type_(type_ string) ApiCreateCategoryRequest {
	r.type_ = &type_
	return r
}

// The ID of the image asset previously uploaded using the media service
func (r ApiCreateCategoryRequest) AssetId(assetId int64) ApiCreateCategoryRequest {
	r.assetId = &assetId
	return r
}

// A string identifier used by client applications to store external information
func (r ApiCreateCategoryRequest) ExternalId(externalId string) ApiCreateCategoryRequest {
	r.externalId = &externalId
	return r
}

// A string type used by client applications to store external information
func (r ApiCreateCategoryRequest) ExternalType(externalType string) ApiCreateCategoryRequest {
	r.externalType = &externalType
	return r
}

// external category slug
func (r ApiCreateCategoryRequest) ExternalCategorySlug(externalCategorySlug string) ApiCreateCategoryRequest {
	r.externalCategorySlug = &externalCategorySlug
	return r
}

// sqoot slug
func (r ApiCreateCategoryRequest) SqootSlug(sqootSlug string) ApiCreateCategoryRequest {
	r.sqootSlug = &sqootSlug
	return r
}

// Sets whether the category is active or inactive (hidden from consumers)
func (r ApiCreateCategoryRequest) Active(active bool) ApiCreateCategoryRequest {
	r.active = &active
	return r
}

// external custom client defined data
func (r ApiCreateCategoryRequest) MetaData(metaData string) ApiCreateCategoryRequest {
	r.metaData = &metaData
	return r
}

// user defined strings for searching
func (r ApiCreateCategoryRequest) SearchTags(searchTags string) ApiCreateCategoryRequest {
	r.searchTags = &searchTags
	return r
}

func (r ApiCreateCategoryRequest) Execute() (*CategoryTreeResponse, *http.Response, error) {
	return r.ApiService.CreateCategoryExecute(r)
}

/*
CreateCategory Create Category

Create a new category.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiCreateCategoryRequest
*/
func (a *CategoryAPIService) CreateCategory(ctx context.Context, version float32) ApiCreateCategoryRequest {
	return ApiCreateCategoryRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return CategoryTreeResponse
func (a *CategoryAPIService) CreateCategoryExecute(r ApiCreateCategoryRequest) (*CategoryTreeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CategoryTreeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CategoryAPIService.CreateCategory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/category/create"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.name == nil {
		return localVarReturnValue, nil, reportError("name is required and must be specified")
	}

	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	if r.parentCategoryId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parentCategoryId", r.parentCategoryId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.assetId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetId", r.assetId, "form", "")
	}
	if r.externalId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "externalId", r.externalId, "form", "")
	}
	if r.externalType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "externalType", r.externalType, "form", "")
	}
	if r.externalCategorySlug != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "externalCategorySlug", r.externalCategorySlug, "form", "")
	}
	if r.sqootSlug != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sqootSlug", r.sqootSlug, "form", "")
	}
	if r.active != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active", r.active, "form", "")
	}
	if r.metaData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metaData", r.metaData, "form", "")
	}
	if r.searchTags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "searchTags", r.searchTags, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCategoryRequest struct {
	ctx context.Context
	ApiService *CategoryAPIService
	version float32
	accountId *int64
	categoryId *int64
}

// the ID of the account
func (r ApiDeleteCategoryRequest) AccountId(accountId int64) ApiDeleteCategoryRequest {
	r.accountId = &accountId
	return r
}

// the ID of the category
func (r ApiDeleteCategoryRequest) CategoryId(categoryId int64) ApiDeleteCategoryRequest {
	r.categoryId = &categoryId
	return r
}

func (r ApiDeleteCategoryRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.DeleteCategoryExecute(r)
}

/*
DeleteCategory Delete Category

Delete a category.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiDeleteCategoryRequest
*/
func (a *CategoryAPIService) DeleteCategory(ctx context.Context, version float32) ApiDeleteCategoryRequest {
	return ApiDeleteCategoryRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *CategoryAPIService) DeleteCategoryExecute(r ApiDeleteCategoryRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CategoryAPIService.DeleteCategory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/category/delete"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.categoryId == nil {
		return localVarReturnValue, nil, reportError("categoryId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "categoryId", r.categoryId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDuplicateCategoryRequest struct {
	ctx context.Context
	ApiService *CategoryAPIService
	version float32
	accountId *int64
	categoryId *int64
	appKey *string
	parentCategoryId *int64
}

// The account id of the user (must have permissions to the target application)
func (r ApiDuplicateCategoryRequest) AccountId(accountId int64) ApiDuplicateCategoryRequest {
	r.accountId = &accountId
	return r
}

// The category ID to duplicate (includes all children)
func (r ApiDuplicateCategoryRequest) CategoryId(categoryId int64) ApiDuplicateCategoryRequest {
	r.categoryId = &categoryId
	return r
}

// The application to assign the new category to, may be different then the application the source category is assigned to
func (r ApiDuplicateCategoryRequest) AppKey(appKey string) ApiDuplicateCategoryRequest {
	r.appKey = &appKey
	return r
}

// The parent category ID to add the target category to.
func (r ApiDuplicateCategoryRequest) ParentCategoryId(parentCategoryId int64) ApiDuplicateCategoryRequest {
	r.parentCategoryId = &parentCategoryId
	return r
}

func (r ApiDuplicateCategoryRequest) Execute() (*CategoryTreeResponse, *http.Response, error) {
	return r.ApiService.DuplicateCategoryExecute(r)
}

/*
DuplicateCategory Duplicate Category

Duplicate a category, including all its children.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiDuplicateCategoryRequest
*/
func (a *CategoryAPIService) DuplicateCategory(ctx context.Context, version float32) ApiDuplicateCategoryRequest {
	return ApiDuplicateCategoryRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return CategoryTreeResponse
func (a *CategoryAPIService) DuplicateCategoryExecute(r ApiDuplicateCategoryRequest) (*CategoryTreeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CategoryTreeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CategoryAPIService.DuplicateCategory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/category/duplicate"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.categoryId == nil {
		return localVarReturnValue, nil, reportError("categoryId is required and must be specified")
	}

	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "categoryId", r.categoryId, "form", "")
	if r.parentCategoryId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parentCategoryId", r.parentCategoryId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCategoryRequest struct {
	ctx context.Context
	ApiService *CategoryAPIService
	version float32
	categoryId *int64
	returnExternal *bool
}

// the ID of the category
func (r ApiGetCategoryRequest) CategoryId(categoryId int64) ApiGetCategoryRequest {
	r.categoryId = &categoryId
	return r
}

// Determines whether to return extra info about the category&#39;s \&quot;Participant\&quot; reference
func (r ApiGetCategoryRequest) ReturnExternal(returnExternal bool) ApiGetCategoryRequest {
	r.returnExternal = &returnExternal
	return r
}

func (r ApiGetCategoryRequest) Execute() (*CategoryTreeResponse, *http.Response, error) {
	return r.ApiService.GetCategoryExecute(r)
}

/*
GetCategory Get Category

Get the details of a specific category. Recursively include all child categories and their children.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiGetCategoryRequest
*/
func (a *CategoryAPIService) GetCategory(ctx context.Context, version float32) ApiGetCategoryRequest {
	return ApiGetCategoryRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return CategoryTreeResponse
func (a *CategoryAPIService) GetCategoryExecute(r ApiGetCategoryRequest) (*CategoryTreeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CategoryTreeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CategoryAPIService.GetCategory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/category/get"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.categoryId == nil {
		return localVarReturnValue, nil, reportError("categoryId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "categoryId", r.categoryId, "form", "")
	if r.returnExternal != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnExternal", r.returnExternal, "form", "")
	} else {
		var defaultValue bool = true
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnExternal", defaultValue, "form", "")
		r.returnExternal = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchCategoriesRequest struct {
	ctx context.Context
	ApiService *CategoryAPIService
	version float32
	accountId *int64
	keyword *string
	appKey *string
	categoryId *string
	categoryIds *string
	parentCategoryIds *string
	rootOnly *bool
	sortField *string
	responseGroup *string
	descending *bool
	start *int32
	limit *int32
	activeOnly *bool
	returnExternal *bool
	exactMatch *bool
	type_ *string
	externalType *string
	excludeExternalType *bool
	minOfferCount *int32
	searchDepth *int32
	searchMode *string
}

// The account id of the user
func (r ApiSearchCategoriesRequest) AccountId(accountId int64) ApiSearchCategoriesRequest {
	r.accountId = &accountId
	return r
}

// The string to search on
func (r ApiSearchCategoriesRequest) Keyword(keyword string) ApiSearchCategoriesRequest {
	r.keyword = &keyword
	return r
}

// the appKey of the application to retrieve categories for, if not specified then search on the global application.
func (r ApiSearchCategoriesRequest) AppKey(appKey string) ApiSearchCategoriesRequest {
	r.appKey = &appKey
	return r
}

// @Deprecated, use parentCategoryIds instead
func (r ApiSearchCategoriesRequest) CategoryId(categoryId string) ApiSearchCategoriesRequest {
	r.categoryId = &categoryId
	return r
}

// Restrict the search by specific categories
func (r ApiSearchCategoriesRequest) CategoryIds(categoryIds string) ApiSearchCategoriesRequest {
	r.categoryIds = &categoryIds
	return r
}

// Restrict the search by specific parent categories so that only its sub children are searched.
func (r ApiSearchCategoriesRequest) ParentCategoryIds(parentCategoryIds string) ApiSearchCategoriesRequest {
	r.parentCategoryIds = &parentCategoryIds
	return r
}

// Restrict the search to only those categories with no parent category assigned.
func (r ApiSearchCategoriesRequest) RootOnly(rootOnly bool) ApiSearchCategoriesRequest {
	r.rootOnly = &rootOnly
	return r
}

// The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, DISPLAY
func (r ApiSearchCategoriesRequest) SortField(sortField string) ApiSearchCategoriesRequest {
	r.sortField = &sortField
	return r
}

// The group of categories to return: ALL, GLOBAL or MINE. ALL returns both global and application specific matches, GLOBAL only returns global matches, and MINE only returns the application specific matches. If not provided search on the application provided.
func (r ApiSearchCategoriesRequest) ResponseGroup(responseGroup string) ApiSearchCategoriesRequest {
	r.responseGroup = &responseGroup
	return r
}

// The order to return the search results
func (r ApiSearchCategoriesRequest) Descending(descending bool) ApiSearchCategoriesRequest {
	r.descending = &descending
	return r
}

// The record to begin the return set on
func (r ApiSearchCategoriesRequest) Start(start int32) ApiSearchCategoriesRequest {
	r.start = &start
	return r
}

// The number of records to return
func (r ApiSearchCategoriesRequest) Limit(limit int32) ApiSearchCategoriesRequest {
	r.limit = &limit
	return r
}

// Determines whether to return only active categories
func (r ApiSearchCategoriesRequest) ActiveOnly(activeOnly bool) ApiSearchCategoriesRequest {
	r.activeOnly = &activeOnly
	return r
}

// Determines whether to return extra info about the category&#39;s \&quot;Participant\&quot; reference
func (r ApiSearchCategoriesRequest) ReturnExternal(returnExternal bool) ApiSearchCategoriesRequest {
	r.returnExternal = &returnExternal
	return r
}

// If true search categories using the exact keyword, if false then do a partial match (like) search. Default is false.
func (r ApiSearchCategoriesRequest) ExactMatch(exactMatch bool) ApiSearchCategoriesRequest {
	r.exactMatch = &exactMatch
	return r
}

// Filters results by the Category&#39;s type
func (r ApiSearchCategoriesRequest) Type_(type_ string) ApiSearchCategoriesRequest {
	r.type_ = &type_
	return r
}

// Filters results by externalType
func (r ApiSearchCategoriesRequest) ExternalType(externalType string) ApiSearchCategoriesRequest {
	r.externalType = &externalType
	return r
}

// Determines whether the \&quot;externalType\&quot; param is excluded from the search results
func (r ApiSearchCategoriesRequest) ExcludeExternalType(excludeExternalType bool) ApiSearchCategoriesRequest {
	r.excludeExternalType = &excludeExternalType
	return r
}

// Filters results to only return Categories that have been referenced by a minimum number of Offers
func (r ApiSearchCategoriesRequest) MinOfferCount(minOfferCount int32) ApiSearchCategoriesRequest {
	r.minOfferCount = &minOfferCount
	return r
}

// When searching by a specific parent category (to return sub children), this determines the number of child layers to search in. The minimum is 1, the maximum is 4.
func (r ApiSearchCategoriesRequest) SearchDepth(searchDepth int32) ApiSearchCategoriesRequest {
	r.searchDepth = &searchDepth
	return r
}

// The search index mode to use (e.g. OPENSEARCH or RDS)
func (r ApiSearchCategoriesRequest) SearchMode(searchMode string) ApiSearchCategoriesRequest {
	r.searchMode = &searchMode
	return r
}

func (r ApiSearchCategoriesRequest) Execute() ([]CategoryResponse, *http.Response, error) {
	return r.ApiService.SearchCategoriesExecute(r)
}

/*
SearchCategories Search Categories

Search for categories.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiSearchCategoriesRequest
*/
func (a *CategoryAPIService) SearchCategories(ctx context.Context, version float32) ApiSearchCategoriesRequest {
	return ApiSearchCategoriesRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return []CategoryResponse
func (a *CategoryAPIService) SearchCategoriesExecute(r ApiSearchCategoriesRequest) ([]CategoryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CategoryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CategoryAPIService.SearchCategories")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/category/search"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.keyword != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyword", r.keyword, "form", "")
	}
	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	if r.categoryId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "categoryId", r.categoryId, "form", "")
	}
	if r.categoryIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "categoryIds", r.categoryIds, "form", "")
	}
	if r.parentCategoryIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parentCategoryIds", r.parentCategoryIds, "form", "")
	}
	if r.rootOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootOnly", r.rootOnly, "form", "")
	}
	if r.sortField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", r.sortField, "form", "")
	} else {
		var defaultValue string = "DISPLAY"
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", defaultValue, "form", "")
		r.sortField = &defaultValue
	}
	if r.responseGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "responseGroup", r.responseGroup, "form", "")
	}
	if r.descending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", defaultValue, "form", "")
		r.descending = &defaultValue
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	} else {
		var defaultValue int32 = 0
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", defaultValue, "form", "")
		r.start = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 20
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	if r.activeOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activeOnly", r.activeOnly, "form", "")
	} else {
		var defaultValue bool = true
		parameterAddToHeaderOrQuery(localVarQueryParams, "activeOnly", defaultValue, "form", "")
		r.activeOnly = &defaultValue
	}
	if r.returnExternal != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnExternal", r.returnExternal, "form", "")
	} else {
		var defaultValue bool = true
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnExternal", defaultValue, "form", "")
		r.returnExternal = &defaultValue
	}
	if r.exactMatch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exactMatch", r.exactMatch, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "exactMatch", defaultValue, "form", "")
		r.exactMatch = &defaultValue
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.externalType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "externalType", r.externalType, "form", "")
	}
	if r.excludeExternalType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeExternalType", r.excludeExternalType, "form", "")
	}
	if r.minOfferCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "minOfferCount", r.minOfferCount, "form", "")
	}
	if r.searchDepth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "searchDepth", r.searchDepth, "form", "")
	} else {
		var defaultValue int32 = 4
		parameterAddToHeaderOrQuery(localVarQueryParams, "searchDepth", defaultValue, "form", "")
		r.searchDepth = &defaultValue
	}
	if r.searchMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "searchMode", r.searchMode, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateCategoryRequest struct {
	ctx context.Context
	ApiService *CategoryAPIService
	version float32
	accountId *int64
	categoryId *int64
	parentCategoryId *int64
	name *string
	description *string
	type_ *string
	assetId *int64
	externalId *string
	externalType *string
	externalCategorySlug *string
	sqootSlug *string
	active *bool
	metaData *string
	searchTags *string
}

// The account id of the user
func (r ApiUpdateCategoryRequest) AccountId(accountId int64) ApiUpdateCategoryRequest {
	r.accountId = &accountId
	return r
}

// The ID of the category to edit
func (r ApiUpdateCategoryRequest) CategoryId(categoryId int64) ApiUpdateCategoryRequest {
	r.categoryId = &categoryId
	return r
}

// The ID of the parent category, if not provided then the parent category will be null
func (r ApiUpdateCategoryRequest) ParentCategoryId(parentCategoryId int64) ApiUpdateCategoryRequest {
	r.parentCategoryId = &parentCategoryId
	return r
}

// The name of the category
func (r ApiUpdateCategoryRequest) Name(name string) ApiUpdateCategoryRequest {
	r.name = &name
	return r
}

// The description of the category
func (r ApiUpdateCategoryRequest) Description(description string) ApiUpdateCategoryRequest {
	r.description = &description
	return r
}

// The type of the category
func (r ApiUpdateCategoryRequest) Type_(type_ string) ApiUpdateCategoryRequest {
	r.type_ = &type_
	return r
}

// The ID of the image asset previously uploaded using the media service
func (r ApiUpdateCategoryRequest) AssetId(assetId int64) ApiUpdateCategoryRequest {
	r.assetId = &assetId
	return r
}

// A string identifier used by client applications to store external information
func (r ApiUpdateCategoryRequest) ExternalId(externalId string) ApiUpdateCategoryRequest {
	r.externalId = &externalId
	return r
}

// A string type used by client applications to store external information
func (r ApiUpdateCategoryRequest) ExternalType(externalType string) ApiUpdateCategoryRequest {
	r.externalType = &externalType
	return r
}

// external category slug
func (r ApiUpdateCategoryRequest) ExternalCategorySlug(externalCategorySlug string) ApiUpdateCategoryRequest {
	r.externalCategorySlug = &externalCategorySlug
	return r
}

// sqoot slug
func (r ApiUpdateCategoryRequest) SqootSlug(sqootSlug string) ApiUpdateCategoryRequest {
	r.sqootSlug = &sqootSlug
	return r
}

// Sets whether the category is active or inactive (hidden from consumers)
func (r ApiUpdateCategoryRequest) Active(active bool) ApiUpdateCategoryRequest {
	r.active = &active
	return r
}

// external custom client defined data
func (r ApiUpdateCategoryRequest) MetaData(metaData string) ApiUpdateCategoryRequest {
	r.metaData = &metaData
	return r
}

// user defined strings for searching
func (r ApiUpdateCategoryRequest) SearchTags(searchTags string) ApiUpdateCategoryRequest {
	r.searchTags = &searchTags
	return r
}

func (r ApiUpdateCategoryRequest) Execute() (*CategoryTreeResponse, *http.Response, error) {
	return r.ApiService.UpdateCategoryExecute(r)
}

/*
UpdateCategory Update Category

Update a category.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiUpdateCategoryRequest
*/
func (a *CategoryAPIService) UpdateCategory(ctx context.Context, version float32) ApiUpdateCategoryRequest {
	return ApiUpdateCategoryRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return CategoryTreeResponse
func (a *CategoryAPIService) UpdateCategoryExecute(r ApiUpdateCategoryRequest) (*CategoryTreeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CategoryTreeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CategoryAPIService.UpdateCategory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/category/update"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.categoryId == nil {
		return localVarReturnValue, nil, reportError("categoryId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "categoryId", r.categoryId, "form", "")
	if r.parentCategoryId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parentCategoryId", r.parentCategoryId, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.assetId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetId", r.assetId, "form", "")
	}
	if r.externalId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "externalId", r.externalId, "form", "")
	}
	if r.externalType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "externalType", r.externalType, "form", "")
	}
	if r.externalCategorySlug != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "externalCategorySlug", r.externalCategorySlug, "form", "")
	}
	if r.sqootSlug != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sqootSlug", r.sqootSlug, "form", "")
	}
	if r.active != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active", r.active, "form", "")
	}
	if r.metaData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metaData", r.metaData, "form", "")
	}
	if r.searchTags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "searchTags", r.searchTags, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
