/*
Sirqul IoT Platform

Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

API version: 3.16
Contact: info@sirqul.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
)


// OrsonAPIService OrsonAPI service
type OrsonAPIService service

type ApiAddMovieRequest struct {
	ctx context.Context
	ApiService *OrsonAPIService
	version float32
	accountId *int64
	movieName *string
	thirdPartyAccountId *string
	tags *string
	file *os.File
	url *string
	callback *string
}

// Sirqul Account Id
func (r ApiAddMovieRequest) AccountId(accountId int64) ApiAddMovieRequest {
	r.accountId = &accountId
	return r
}

// Movie Name
func (r ApiAddMovieRequest) MovieName(movieName string) ApiAddMovieRequest {
	r.movieName = &movieName
	return r
}

// A third-party account id that is meaningful to your systems
func (r ApiAddMovieRequest) ThirdPartyAccountId(thirdPartyAccountId string) ApiAddMovieRequest {
	r.thirdPartyAccountId = &thirdPartyAccountId
	return r
}

// A user defined list (comma-delimited) of tags associated with the movie
func (r ApiAddMovieRequest) Tags(tags string) ApiAddMovieRequest {
	r.tags = &tags
	return r
}

// An uploaded recording to analyze (Currently limited to 10MB)
func (r ApiAddMovieRequest) File(file *os.File) ApiAddMovieRequest {
	r.file = file
	return r
}

// A recording file to download and analyze (Size limit: 1GB)
func (r ApiAddMovieRequest) Url(url string) ApiAddMovieRequest {
	r.url = &url
	return r
}

// When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open
func (r ApiAddMovieRequest) Callback(callback string) ApiAddMovieRequest {
	r.callback = &callback
	return r
}

func (r ApiAddMovieRequest) Execute() (*OrsonAiAddMovieResponse, *http.Response, error) {
	return r.ApiService.AddMovieExecute(r)
}

/*
AddMovie Add Movie

Add a movie to be indexed for Topics. Indexing a movie analyses the content and incorporates it into the topics model for future /topics calls. This does not store the movie file long-term.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiAddMovieRequest
*/
func (a *OrsonAPIService) AddMovie(ctx context.Context, version float32) ApiAddMovieRequest {
	return ApiAddMovieRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return OrsonAiAddMovieResponse
func (a *OrsonAPIService) AddMovieExecute(r ApiAddMovieRequest) (*OrsonAiAddMovieResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrsonAiAddMovieResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrsonAPIService.AddMovie")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/orson/ai/addMovie"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.movieName == nil {
		return localVarReturnValue, nil, reportError("movieName is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	if r.thirdPartyAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "thirdPartyAccountId", r.thirdPartyAccountId, "form", "")
	}
	if r.tags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tags", r.tags, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "movieName", r.movieName, "form", "")
	if r.file != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "file", r.file, "form", "")
	}
	if r.url != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "url", r.url, "form", "")
	}
	if r.callback != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "callback", r.callback, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAiDocsRequest struct {
	ctx context.Context
	ApiService *OrsonAPIService
	version float32
	accountId *int64
	doc *string
	returnTopics *bool
	limit *int32
	offset *int32
}

// Sirqul Account Id
func (r ApiAiDocsRequest) AccountId(accountId int64) ApiAiDocsRequest {
	r.accountId = &accountId
	return r
}

// Doc
func (r ApiAiDocsRequest) Doc(doc string) ApiAiDocsRequest {
	r.doc = &doc
	return r
}

// Return Topics
func (r ApiAiDocsRequest) ReturnTopics(returnTopics bool) ApiAiDocsRequest {
	r.returnTopics = &returnTopics
	return r
}

// Limit
func (r ApiAiDocsRequest) Limit(limit int32) ApiAiDocsRequest {
	r.limit = &limit
	return r
}

// Offset
func (r ApiAiDocsRequest) Offset(offset int32) ApiAiDocsRequest {
	r.offset = &offset
	return r
}

func (r ApiAiDocsRequest) Execute() (*OrsonAiProtoResponse, *http.Response, error) {
	return r.ApiService.AiDocsExecute(r)
}

/*
AiDocs Search Docs

Takes in a text string representing one or more sentences and it returns a list of documents which are related to the provided document.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiAiDocsRequest
*/
func (a *OrsonAPIService) AiDocs(ctx context.Context, version float32) ApiAiDocsRequest {
	return ApiAiDocsRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return OrsonAiProtoResponse
func (a *OrsonAPIService) AiDocsExecute(r ApiAiDocsRequest) (*OrsonAiProtoResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrsonAiProtoResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrsonAPIService.AiDocs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/orson/ai/docs"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.doc == nil {
		return localVarReturnValue, nil, reportError("doc is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "doc", r.doc, "form", "")
	if r.returnTopics != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "return_topics", r.returnTopics, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAiFindImagesRequest struct {
	ctx context.Context
	ApiService *OrsonAPIService
	version float32
	accountId *int64
	text *string
	parseFlag *string
	fetchFlag *string
	size *string
}

// Sirqul Account Id
func (r ApiAiFindImagesRequest) AccountId(accountId int64) ApiAiFindImagesRequest {
	r.accountId = &accountId
	return r
}

// Text
func (r ApiAiFindImagesRequest) Text(text string) ApiAiFindImagesRequest {
	r.text = &text
	return r
}

// Parse Flag
func (r ApiAiFindImagesRequest) ParseFlag(parseFlag string) ApiAiFindImagesRequest {
	r.parseFlag = &parseFlag
	return r
}

// Fetch Flag
func (r ApiAiFindImagesRequest) FetchFlag(fetchFlag string) ApiAiFindImagesRequest {
	r.fetchFlag = &fetchFlag
	return r
}

// Size
func (r ApiAiFindImagesRequest) Size(size string) ApiAiFindImagesRequest {
	r.size = &size
	return r
}

func (r ApiAiFindImagesRequest) Execute() (*OrsonAiProtoResponse, *http.Response, error) {
	return r.ApiService.AiFindImagesExecute(r)
}

/*
AiFindImages Find images

Returns a list of URIs of images that match the text.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiAiFindImagesRequest
*/
func (a *OrsonAPIService) AiFindImages(ctx context.Context, version float32) ApiAiFindImagesRequest {
	return ApiAiFindImagesRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return OrsonAiProtoResponse
func (a *OrsonAPIService) AiFindImagesExecute(r ApiAiFindImagesRequest) (*OrsonAiProtoResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrsonAiProtoResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrsonAPIService.AiFindImages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/orson/ai/img"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.text == nil {
		return localVarReturnValue, nil, reportError("text is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "text", r.text, "form", "")
	if r.parseFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parse_flag", r.parseFlag, "form", "")
	}
	if r.fetchFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetch_flag", r.fetchFlag, "form", "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAiTagsRequest struct {
	ctx context.Context
	ApiService *OrsonAPIService
	version float32
	accountId *int64
	tags *string
	conditional *string
	limit *int32
	offset *int32
}

// Sirqul Account Id
func (r ApiAiTagsRequest) AccountId(accountId int64) ApiAiTagsRequest {
	r.accountId = &accountId
	return r
}

// Tags
func (r ApiAiTagsRequest) Tags(tags string) ApiAiTagsRequest {
	r.tags = &tags
	return r
}

// Conditional
func (r ApiAiTagsRequest) Conditional(conditional string) ApiAiTagsRequest {
	r.conditional = &conditional
	return r
}

// Limit
func (r ApiAiTagsRequest) Limit(limit int32) ApiAiTagsRequest {
	r.limit = &limit
	return r
}

// Offset
func (r ApiAiTagsRequest) Offset(offset int32) ApiAiTagsRequest {
	r.offset = &offset
	return r
}

func (r ApiAiTagsRequest) Execute() (*OrsonAiProtoResponse, *http.Response, error) {
	return r.ApiService.AiTagsExecute(r)
}

/*
AiTags Search Tags

Search the tags column of user provided tags using this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiAiTagsRequest
*/
func (a *OrsonAPIService) AiTags(ctx context.Context, version float32) ApiAiTagsRequest {
	return ApiAiTagsRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return OrsonAiProtoResponse
func (a *OrsonAPIService) AiTagsExecute(r ApiAiTagsRequest) (*OrsonAiProtoResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrsonAiProtoResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrsonAPIService.AiTags")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/orson/ai/tags"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.tags == nil {
		return localVarReturnValue, nil, reportError("tags is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "tags", r.tags, "form", "")
	if r.conditional != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "conditional", r.conditional, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAiTextRequest struct {
	ctx context.Context
	ApiService *OrsonAPIService
	version float32
	accountId *int64
	terms *string
	conditional *string
	limit *int32
	offset *int32
}

// Sirqul Account Id
func (r ApiAiTextRequest) AccountId(accountId int64) ApiAiTextRequest {
	r.accountId = &accountId
	return r
}

// Terms
func (r ApiAiTextRequest) Terms(terms string) ApiAiTextRequest {
	r.terms = &terms
	return r
}

// Conditional
func (r ApiAiTextRequest) Conditional(conditional string) ApiAiTextRequest {
	r.conditional = &conditional
	return r
}

// Limit
func (r ApiAiTextRequest) Limit(limit int32) ApiAiTextRequest {
	r.limit = &limit
	return r
}

// Offset
func (r ApiAiTextRequest) Offset(offset int32) ApiAiTextRequest {
	r.offset = &offset
	return r
}

func (r ApiAiTextRequest) Execute() (*OrsonAiProtoResponse, *http.Response, error) {
	return r.ApiService.AiTextExecute(r)
}

/*
AiText Search Text

Search the movie text column of movie text using this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiAiTextRequest
*/
func (a *OrsonAPIService) AiText(ctx context.Context, version float32) ApiAiTextRequest {
	return ApiAiTextRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return OrsonAiProtoResponse
func (a *OrsonAPIService) AiTextExecute(r ApiAiTextRequest) (*OrsonAiProtoResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrsonAiProtoResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrsonAPIService.AiText")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/orson/ai/text"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.terms == nil {
		return localVarReturnValue, nil, reportError("terms is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "terms", r.terms, "form", "")
	if r.conditional != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "conditional", r.conditional, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBatchRequest struct {
	ctx context.Context
	ApiService *OrsonAPIService
	version float32
	accountId *int64
	thirdPartyAccountId *string
	limit *int32
	operations *string
	file *os.File
	url *string
	callback *string
}

// Sirqul Account Id
func (r ApiBatchRequest) AccountId(accountId int64) ApiBatchRequest {
	r.accountId = &accountId
	return r
}

// A third-party account id that is meaningful to your systems
func (r ApiBatchRequest) ThirdPartyAccountId(thirdPartyAccountId string) ApiBatchRequest {
	r.thirdPartyAccountId = &thirdPartyAccountId
	return r
}

// The number of topics to return
func (r ApiBatchRequest) Limit(limit int32) ApiBatchRequest {
	r.limit = &limit
	return r
}

// The comma-delimited list of A/V batch analysis operations to run on this file. Possible values: Transcript,Topics,Emotions
func (r ApiBatchRequest) Operations(operations string) ApiBatchRequest {
	r.operations = &operations
	return r
}

// An uploaded recording to analyze (Currently limited to 10MB)
func (r ApiBatchRequest) File(file *os.File) ApiBatchRequest {
	r.file = file
	return r
}

// A recording file to download and analyze (Size limit: 1GB)
func (r ApiBatchRequest) Url(url string) ApiBatchRequest {
	r.url = &url
	return r
}

// When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open
func (r ApiBatchRequest) Callback(callback string) ApiBatchRequest {
	r.callback = &callback
	return r
}

func (r ApiBatchRequest) Execute() (*OrsonAiBatchResponse, *http.Response, error) {
	return r.ApiService.BatchExecute(r)
}

/*
Batch Batch Analysis

Run several types of analysis on an audio or video file in a single API call, instead of calling several operations for the same file..

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiBatchRequest
*/
func (a *OrsonAPIService) Batch(ctx context.Context, version float32) ApiBatchRequest {
	return ApiBatchRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return OrsonAiBatchResponse
func (a *OrsonAPIService) BatchExecute(r ApiBatchRequest) (*OrsonAiBatchResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrsonAiBatchResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrsonAPIService.Batch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/orson/ai/batch"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	if r.thirdPartyAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "thirdPartyAccountId", r.thirdPartyAccountId, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.operations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "operations", r.operations, "form", "")
	}
	if r.file != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "file", r.file, "form", "")
	}
	if r.url != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "url", r.url, "form", "")
	}
	if r.callback != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "callback", r.callback, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateInstantEpisodeRequest struct {
	ctx context.Context
	ApiService *OrsonAPIService
	version float32
	accountId *int64
	data *string
}

// Sirqul Account Id
func (r ApiCreateInstantEpisodeRequest) AccountId(accountId int64) ApiCreateInstantEpisodeRequest {
	r.accountId = &accountId
	return r
}

// Request Data String
func (r ApiCreateInstantEpisodeRequest) Data(data string) ApiCreateInstantEpisodeRequest {
	r.data = &data
	return r
}

func (r ApiCreateInstantEpisodeRequest) Execute() (*OrsonEpisodeResponse, *http.Response, error) {
	return r.ApiService.CreateInstantEpisodeExecute(r)
}

/*
CreateInstantEpisode Creates an instant episode

Creates an instant episode for a given StoryStrip by providing all necessary inputs, interview recordings, and pictures, kicking off a render immediately.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiCreateInstantEpisodeRequest
*/
func (a *OrsonAPIService) CreateInstantEpisode(ctx context.Context, version float32) ApiCreateInstantEpisodeRequest {
	return ApiCreateInstantEpisodeRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return OrsonEpisodeResponse
func (a *OrsonAPIService) CreateInstantEpisodeExecute(r ApiCreateInstantEpisodeRequest) (*OrsonEpisodeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrsonEpisodeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrsonAPIService.CreateInstantEpisode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/orson/stories/episodes/instant"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "data", r.data, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateVoiceCanvasRequest struct {
	ctx context.Context
	ApiService *OrsonAPIService
	version float32
	accountId *int64
	dimensions *string
	thirdPartyAccountId *string
	text *string
	file *os.File
	url *string
	parseFlag *bool
	fetchFlag *bool
	callback *string
}

// Sirqul Account Id
func (r ApiCreateVoiceCanvasRequest) AccountId(accountId int64) ApiCreateVoiceCanvasRequest {
	r.accountId = &accountId
	return r
}

// Enum: \&quot;256x256\&quot; \&quot;512x512\&quot; \&quot;1024x1024\&quot;
func (r ApiCreateVoiceCanvasRequest) Dimensions(dimensions string) ApiCreateVoiceCanvasRequest {
	r.dimensions = &dimensions
	return r
}

// A third-party account id that is meaningful to your systems
func (r ApiCreateVoiceCanvasRequest) ThirdPartyAccountId(thirdPartyAccountId string) ApiCreateVoiceCanvasRequest {
	r.thirdPartyAccountId = &thirdPartyAccountId
	return r
}

// Provide a transcript or previously extracted topics for image generation
func (r ApiCreateVoiceCanvasRequest) Text(text string) ApiCreateVoiceCanvasRequest {
	r.text = &text
	return r
}

// An uploaded recording to analyze (Currently limited to 10MB)
func (r ApiCreateVoiceCanvasRequest) File(file *os.File) ApiCreateVoiceCanvasRequest {
	r.file = file
	return r
}

// A recording file to download and analyze (Size limit: 1GB)
func (r ApiCreateVoiceCanvasRequest) Url(url string) ApiCreateVoiceCanvasRequest {
	r.url = &url
	return r
}

// When false, uses the raw value from text instead of identifying topics to fetch/generate from
func (r ApiCreateVoiceCanvasRequest) ParseFlag(parseFlag bool) ApiCreateVoiceCanvasRequest {
	r.parseFlag = &parseFlag
	return r
}

// When true, fetches images instead of generating them
func (r ApiCreateVoiceCanvasRequest) FetchFlag(fetchFlag bool) ApiCreateVoiceCanvasRequest {
	r.fetchFlag = &fetchFlag
	return r
}

// When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open
func (r ApiCreateVoiceCanvasRequest) Callback(callback string) ApiCreateVoiceCanvasRequest {
	r.callback = &callback
	return r
}

func (r ApiCreateVoiceCanvasRequest) Execute() (*OrsonAiVoiceCanvasResponse, *http.Response, error) {
	return r.ApiService.CreateVoiceCanvasExecute(r)
}

/*
CreateVoiceCanvas Create VoiceCanvas images

Create VoiceCanvas images for provided text, file upload, or file URL

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiCreateVoiceCanvasRequest
*/
func (a *OrsonAPIService) CreateVoiceCanvas(ctx context.Context, version float32) ApiCreateVoiceCanvasRequest {
	return ApiCreateVoiceCanvasRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return OrsonAiVoiceCanvasResponse
func (a *OrsonAPIService) CreateVoiceCanvasExecute(r ApiCreateVoiceCanvasRequest) (*OrsonAiVoiceCanvasResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrsonAiVoiceCanvasResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrsonAPIService.CreateVoiceCanvas")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/orson/ai/voiceCanvas"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.dimensions == nil {
		return localVarReturnValue, nil, reportError("dimensions is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	if r.thirdPartyAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "thirdPartyAccountId", r.thirdPartyAccountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "dimensions", r.dimensions, "form", "")
	if r.text != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "text", r.text, "form", "")
	}
	if r.file != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "file", r.file, "form", "")
	}
	if r.url != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "url", r.url, "form", "")
	}
	if r.parseFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parseFlag", r.parseFlag, "form", "")
	}
	if r.fetchFlag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetchFlag", r.fetchFlag, "form", "")
	}
	if r.callback != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "callback", r.callback, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEmotionRequest struct {
	ctx context.Context
	ApiService *OrsonAPIService
	version float32
	accountId *int64
	thirdPartyAccountId *string
	file *os.File
	url *string
	callback *string
}

// Sirqul Account Id
func (r ApiEmotionRequest) AccountId(accountId int64) ApiEmotionRequest {
	r.accountId = &accountId
	return r
}

// A third-party account id that is meaningful to your systems
func (r ApiEmotionRequest) ThirdPartyAccountId(thirdPartyAccountId string) ApiEmotionRequest {
	r.thirdPartyAccountId = &thirdPartyAccountId
	return r
}

// An uploaded recording to analyze (Currently limited to 10MB)
func (r ApiEmotionRequest) File(file *os.File) ApiEmotionRequest {
	r.file = file
	return r
}

// A recording file to download and analyze (Size limit: 1GB)
func (r ApiEmotionRequest) Url(url string) ApiEmotionRequest {
	r.url = &url
	return r
}

// When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open
func (r ApiEmotionRequest) Callback(callback string) ApiEmotionRequest {
	r.callback = &callback
	return r
}

func (r ApiEmotionRequest) Execute() (*OrsonAiEmotionsResponse, *http.Response, error) {
	return r.ApiService.EmotionExecute(r)
}

/*
Emotion Detect emotions

Detects emotions in an audio or video recording.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiEmotionRequest
*/
func (a *OrsonAPIService) Emotion(ctx context.Context, version float32) ApiEmotionRequest {
	return ApiEmotionRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return OrsonAiEmotionsResponse
func (a *OrsonAPIService) EmotionExecute(r ApiEmotionRequest) (*OrsonAiEmotionsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrsonAiEmotionsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrsonAPIService.Emotion")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/orson/ai/emotion"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	if r.thirdPartyAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "thirdPartyAccountId", r.thirdPartyAccountId, "form", "")
	}
	if r.file != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "file", r.file, "form", "")
	}
	if r.url != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "url", r.url, "form", "")
	}
	if r.callback != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "callback", r.callback, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAddMovieResultRequest struct {
	ctx context.Context
	ApiService *OrsonAPIService
	version float32
	requestId string
	accountId *int64
}

// Sirqul Account Id
func (r ApiGetAddMovieResultRequest) AccountId(accountId int64) ApiGetAddMovieResultRequest {
	r.accountId = &accountId
	return r
}

func (r ApiGetAddMovieResultRequest) Execute() (*OrsonAiAddMovieResponse, *http.Response, error) {
	return r.ApiService.GetAddMovieResultExecute(r)
}

/*
GetAddMovieResult Get Add Movie Result

Get the result of an in progress Add Movie request from an earlier POST.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @param requestId Orson Request Id
 @return ApiGetAddMovieResultRequest
*/
func (a *OrsonAPIService) GetAddMovieResult(ctx context.Context, version float32, requestId string) ApiGetAddMovieResultRequest {
	return ApiGetAddMovieResultRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
		requestId: requestId,
	}
}

// Execute executes the request
//  @return OrsonAiAddMovieResponse
func (a *OrsonAPIService) GetAddMovieResultExecute(r ApiGetAddMovieResultRequest) (*OrsonAiAddMovieResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrsonAiAddMovieResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrsonAPIService.GetAddMovieResult")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/orson/ai/addMovie/{requestId}"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"requestId"+"}", url.PathEscape(parameterValueToString(r.requestId, "requestId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBatchRequest struct {
	ctx context.Context
	ApiService *OrsonAPIService
	version float32
	requestId string
	accountId *int64
}

// Sirqul Account Id
func (r ApiGetBatchRequest) AccountId(accountId int64) ApiGetBatchRequest {
	r.accountId = &accountId
	return r
}

func (r ApiGetBatchRequest) Execute() (*OrsonAiBatchResponse, *http.Response, error) {
	return r.ApiService.GetBatchExecute(r)
}

/*
GetBatch Get Batch Analysis Results

Gets the completed Video Batch results, if done, or an error or status update if not.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @param requestId Orson Request Id
 @return ApiGetBatchRequest
*/
func (a *OrsonAPIService) GetBatch(ctx context.Context, version float32, requestId string) ApiGetBatchRequest {
	return ApiGetBatchRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
		requestId: requestId,
	}
}

// Execute executes the request
//  @return OrsonAiBatchResponse
func (a *OrsonAPIService) GetBatchExecute(r ApiGetBatchRequest) (*OrsonAiBatchResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrsonAiBatchResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrsonAPIService.GetBatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/orson/ai/batch/{requestId}"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"requestId"+"}", url.PathEscape(parameterValueToString(r.requestId, "requestId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEmotionRequest struct {
	ctx context.Context
	ApiService *OrsonAPIService
	version float32
	requestId string
	accountId *int64
}

// Sirqul Account Id
func (r ApiGetEmotionRequest) AccountId(accountId int64) ApiGetEmotionRequest {
	r.accountId = &accountId
	return r
}

func (r ApiGetEmotionRequest) Execute() (*OrsonAiEmotionsResponse, *http.Response, error) {
	return r.ApiService.GetEmotionExecute(r)
}

/*
GetEmotion Get Emotion Results

Checks the Emotion analysis and returns in progress, results, or error.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @param requestId Orson Request Id
 @return ApiGetEmotionRequest
*/
func (a *OrsonAPIService) GetEmotion(ctx context.Context, version float32, requestId string) ApiGetEmotionRequest {
	return ApiGetEmotionRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
		requestId: requestId,
	}
}

// Execute executes the request
//  @return OrsonAiEmotionsResponse
func (a *OrsonAPIService) GetEmotionExecute(r ApiGetEmotionRequest) (*OrsonAiEmotionsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrsonAiEmotionsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrsonAPIService.GetEmotion")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/orson/ai/emotion/{requestId}"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"requestId"+"}", url.PathEscape(parameterValueToString(r.requestId, "requestId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEpisodeStatusRequest struct {
	ctx context.Context
	ApiService *OrsonAPIService
	version float32
	episodeId int64
	accountId *int64
}

// Sirqul Account Id
func (r ApiGetEpisodeStatusRequest) AccountId(accountId int64) ApiGetEpisodeStatusRequest {
	r.accountId = &accountId
	return r
}

func (r ApiGetEpisodeStatusRequest) Execute() (*OrsonEpisodeResponse, *http.Response, error) {
	return r.ApiService.GetEpisodeStatusExecute(r)
}

/*
GetEpisodeStatus Check episode status

Gets a summary of the episode's status, including any renders.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @param episodeId Episode ID
 @return ApiGetEpisodeStatusRequest
*/
func (a *OrsonAPIService) GetEpisodeStatus(ctx context.Context, version float32, episodeId int64) ApiGetEpisodeStatusRequest {
	return ApiGetEpisodeStatusRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
		episodeId: episodeId,
	}
}

// Execute executes the request
//  @return OrsonEpisodeResponse
func (a *OrsonAPIService) GetEpisodeStatusExecute(r ApiGetEpisodeStatusRequest) (*OrsonEpisodeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrsonEpisodeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrsonAPIService.GetEpisodeStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/orson/stories/episodes/{episodeId}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"episodeId"+"}", url.PathEscape(parameterValueToString(r.episodeId, "episodeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRenderStatusRequest struct {
	ctx context.Context
	ApiService *OrsonAPIService
	version float32
	renderId string
	accountId *int64
}

// Sirqul Account Id
func (r ApiGetRenderStatusRequest) AccountId(accountId int64) ApiGetRenderStatusRequest {
	r.accountId = &accountId
	return r
}

func (r ApiGetRenderStatusRequest) Execute() (*OrsonRenderResponse, *http.Response, error) {
	return r.ApiService.GetRenderStatusExecute(r)
}

/*
GetRenderStatus Check episode status

Gets a summary of the episode's status, including any renders.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @param renderId Render ID
 @return ApiGetRenderStatusRequest
*/
func (a *OrsonAPIService) GetRenderStatus(ctx context.Context, version float32, renderId string) ApiGetRenderStatusRequest {
	return ApiGetRenderStatusRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
		renderId: renderId,
	}
}

// Execute executes the request
//  @return OrsonRenderResponse
func (a *OrsonAPIService) GetRenderStatusExecute(r ApiGetRenderStatusRequest) (*OrsonRenderResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrsonRenderResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrsonAPIService.GetRenderStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/orson/stories/renders/{renderId}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"renderId"+"}", url.PathEscape(parameterValueToString(r.renderId, "renderId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSTTRequest struct {
	ctx context.Context
	ApiService *OrsonAPIService
	version float32
	requestId string
	accountId *int64
}

// Sirqul Account Id
func (r ApiGetSTTRequest) AccountId(accountId int64) ApiGetSTTRequest {
	r.accountId = &accountId
	return r
}

func (r ApiGetSTTRequest) Execute() (*OrsonAiSTTResponse, *http.Response, error) {
	return r.ApiService.GetSTTExecute(r)
}

/*
GetSTT Get Speach to Text Result

The results of the video transcription and optional translation.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @param requestId Orson Request Id
 @return ApiGetSTTRequest
*/
func (a *OrsonAPIService) GetSTT(ctx context.Context, version float32, requestId string) ApiGetSTTRequest {
	return ApiGetSTTRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
		requestId: requestId,
	}
}

// Execute executes the request
//  @return OrsonAiSTTResponse
func (a *OrsonAPIService) GetSTTExecute(r ApiGetSTTRequest) (*OrsonAiSTTResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrsonAiSTTResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrsonAPIService.GetSTT")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/orson/ai/stt/{requestId}"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"requestId"+"}", url.PathEscape(parameterValueToString(r.requestId, "requestId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTTSRequest struct {
	ctx context.Context
	ApiService *OrsonAPIService
	version float32
	requestId string
	accountId *int64
}

// Sirqul Account Id
func (r ApiGetTTSRequest) AccountId(accountId int64) ApiGetTTSRequest {
	r.accountId = &accountId
	return r
}

func (r ApiGetTTSRequest) Execute() (*OrsonAiTTSResponse, *http.Response, error) {
	return r.ApiService.GetTTSExecute(r)
}

/*
GetTTS Get Text to Speach Result

Check the status of an in progress Text-to-Speech call or download the result.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @param requestId Orson Request Id
 @return ApiGetTTSRequest
*/
func (a *OrsonAPIService) GetTTS(ctx context.Context, version float32, requestId string) ApiGetTTSRequest {
	return ApiGetTTSRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
		requestId: requestId,
	}
}

// Execute executes the request
//  @return OrsonAiTTSResponse
func (a *OrsonAPIService) GetTTSExecute(r ApiGetTTSRequest) (*OrsonAiTTSResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrsonAiTTSResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrsonAPIService.GetTTS")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/orson/ai/tts/{requestId}"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"requestId"+"}", url.PathEscape(parameterValueToString(r.requestId, "requestId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTechTuneRequest struct {
	ctx context.Context
	ApiService *OrsonAPIService
	version float32
	requestId string
	accountId *int64
}

// Sirqul Account Id
func (r ApiGetTechTuneRequest) AccountId(accountId int64) ApiGetTechTuneRequest {
	r.accountId = &accountId
	return r
}

func (r ApiGetTechTuneRequest) Execute() (*OrsonAiTechTuneResponse, *http.Response, error) {
	return r.ApiService.GetTechTuneExecute(r)
}

/*
GetTechTune Get TechTune Results

Get a result or continue waiting for a pending request for TechTune analysis.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @param requestId Orson Request Id
 @return ApiGetTechTuneRequest
*/
func (a *OrsonAPIService) GetTechTune(ctx context.Context, version float32, requestId string) ApiGetTechTuneRequest {
	return ApiGetTechTuneRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
		requestId: requestId,
	}
}

// Execute executes the request
//  @return OrsonAiTechTuneResponse
func (a *OrsonAPIService) GetTechTuneExecute(r ApiGetTechTuneRequest) (*OrsonAiTechTuneResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrsonAiTechTuneResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrsonAPIService.GetTechTune")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/orson/ai/techTune/{requestId}"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"requestId"+"}", url.PathEscape(parameterValueToString(r.requestId, "requestId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTopicsRequest struct {
	ctx context.Context
	ApiService *OrsonAPIService
	version float32
	requestId string
	accountId *int64
}

// Sirqul Account Id
func (r ApiGetTopicsRequest) AccountId(accountId int64) ApiGetTopicsRequest {
	r.accountId = &accountId
	return r
}

func (r ApiGetTopicsRequest) Execute() (*OrsonAiTopicsResponse, *http.Response, error) {
	return r.ApiService.GetTopicsExecute(r)
}

/*
GetTopics Get Topics

Get the result of an in progress Topics Analysis from an earlier POST.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @param requestId Orson Request Id
 @return ApiGetTopicsRequest
*/
func (a *OrsonAPIService) GetTopics(ctx context.Context, version float32, requestId string) ApiGetTopicsRequest {
	return ApiGetTopicsRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
		requestId: requestId,
	}
}

// Execute executes the request
//  @return OrsonAiTopicsResponse
func (a *OrsonAPIService) GetTopicsExecute(r ApiGetTopicsRequest) (*OrsonAiTopicsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrsonAiTopicsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrsonAPIService.GetTopics")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/orson/ai/topics/{requestId}"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"requestId"+"}", url.PathEscape(parameterValueToString(r.requestId, "requestId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetVoiceCanvasRequest struct {
	ctx context.Context
	ApiService *OrsonAPIService
	version float32
	requestId string
	accountId *int64
}

// Sirqul Account Id
func (r ApiGetVoiceCanvasRequest) AccountId(accountId int64) ApiGetVoiceCanvasRequest {
	r.accountId = &accountId
	return r
}

func (r ApiGetVoiceCanvasRequest) Execute() (*OrsonAiVoiceCanvasResponse, *http.Response, error) {
	return r.ApiService.GetVoiceCanvasExecute(r)
}

/*
GetVoiceCanvas Get VoiceCanvas images

Get a result or continue waiting for a pending request for VoiceCanvas Images.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @param requestId Orson Request Id
 @return ApiGetVoiceCanvasRequest
*/
func (a *OrsonAPIService) GetVoiceCanvas(ctx context.Context, version float32, requestId string) ApiGetVoiceCanvasRequest {
	return ApiGetVoiceCanvasRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
		requestId: requestId,
	}
}

// Execute executes the request
//  @return OrsonAiVoiceCanvasResponse
func (a *OrsonAPIService) GetVoiceCanvasExecute(r ApiGetVoiceCanvasRequest) (*OrsonAiVoiceCanvasResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrsonAiVoiceCanvasResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrsonAPIService.GetVoiceCanvas")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/orson/ai/voiceCanvas/{requestId}"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"requestId"+"}", url.PathEscape(parameterValueToString(r.requestId, "requestId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStartVideoRenderRequest struct {
	ctx context.Context
	ApiService *OrsonAPIService
	version float32
	accountId *int64
	data *string
}

// Sirqul Account Id
func (r ApiStartVideoRenderRequest) AccountId(accountId int64) ApiStartVideoRenderRequest {
	r.accountId = &accountId
	return r
}

// Request Data String
func (r ApiStartVideoRenderRequest) Data(data string) ApiStartVideoRenderRequest {
	r.data = &data
	return r
}

func (r ApiStartVideoRenderRequest) Execute() (*OrsonRenderResponse, *http.Response, error) {
	return r.ApiService.StartVideoRenderExecute(r)
}

/*
StartVideoRender Starts a StoryStitch video render

Starts a StoryStitch video render to produce your final video, returning the status details.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiStartVideoRenderRequest
*/
func (a *OrsonAPIService) StartVideoRender(ctx context.Context, version float32) ApiStartVideoRenderRequest {
	return ApiStartVideoRenderRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return OrsonRenderResponse
func (a *OrsonAPIService) StartVideoRenderExecute(r ApiStartVideoRenderRequest) (*OrsonRenderResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrsonRenderResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrsonAPIService.StartVideoRender")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/orson/stories/renders"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "data", r.data, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSttRequest struct {
	ctx context.Context
	ApiService *OrsonAPIService
	version float32
	accountId *int64
	thirdPartyAccountId *string
	sourceLanguage *string
	targetLanguage *string
	file *os.File
	url *string
	callback *string
}

// Sirqul Account Id
func (r ApiSttRequest) AccountId(accountId int64) ApiSttRequest {
	r.accountId = &accountId
	return r
}

// A third-party account id that is meaningful to your systems
func (r ApiSttRequest) ThirdPartyAccountId(thirdPartyAccountId string) ApiSttRequest {
	r.thirdPartyAccountId = &thirdPartyAccountId
	return r
}

// Source Language
func (r ApiSttRequest) SourceLanguage(sourceLanguage string) ApiSttRequest {
	r.sourceLanguage = &sourceLanguage
	return r
}

// Target Language
func (r ApiSttRequest) TargetLanguage(targetLanguage string) ApiSttRequest {
	r.targetLanguage = &targetLanguage
	return r
}

// An uploaded recording to analyze (Currently limited to 10MB)
func (r ApiSttRequest) File(file *os.File) ApiSttRequest {
	r.file = file
	return r
}

// A recording file to download and analyze (Size limit: 1GB)
func (r ApiSttRequest) Url(url string) ApiSttRequest {
	r.url = &url
	return r
}

// When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open
func (r ApiSttRequest) Callback(callback string) ApiSttRequest {
	r.callback = &callback
	return r
}

func (r ApiSttRequest) Execute() (*OrsonAiSTTResponse, *http.Response, error) {
	return r.ApiService.SttExecute(r)
}

/*
Stt Speach to Text

Accepts a movie URL or uploaded file and transcribes it. You also have the option to translate it into one of our additional supported languages.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiSttRequest
*/
func (a *OrsonAPIService) Stt(ctx context.Context, version float32) ApiSttRequest {
	return ApiSttRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return OrsonAiSTTResponse
func (a *OrsonAPIService) SttExecute(r ApiSttRequest) (*OrsonAiSTTResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrsonAiSTTResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrsonAPIService.Stt")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/orson/ai/stt"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	if r.thirdPartyAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "thirdPartyAccountId", r.thirdPartyAccountId, "form", "")
	}
	if r.sourceLanguage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sourceLanguage", r.sourceLanguage, "form", "")
	}
	if r.targetLanguage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "targetLanguage", r.targetLanguage, "form", "")
	}
	if r.file != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "file", r.file, "form", "")
	}
	if r.url != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "url", r.url, "form", "")
	}
	if r.callback != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "callback", r.callback, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSummarizeTopicsRequest struct {
	ctx context.Context
	ApiService *OrsonAPIService
	version float32
	accountId *int64
	thirdPartyAccountId *string
	doc *string
	file *os.File
	url *string
	limit *int32
	offset *int32
	callback *string
}

// Sirqul Account Id
func (r ApiSummarizeTopicsRequest) AccountId(accountId int64) ApiSummarizeTopicsRequest {
	r.accountId = &accountId
	return r
}

// A third-party account id that is meaningful to your systems
func (r ApiSummarizeTopicsRequest) ThirdPartyAccountId(thirdPartyAccountId string) ApiSummarizeTopicsRequest {
	r.thirdPartyAccountId = &thirdPartyAccountId
	return r
}

// The text to get topics for.
func (r ApiSummarizeTopicsRequest) Doc(doc string) ApiSummarizeTopicsRequest {
	r.doc = &doc
	return r
}

// An uploaded recording to analyze (Currently limited to 10MB)
func (r ApiSummarizeTopicsRequest) File(file *os.File) ApiSummarizeTopicsRequest {
	r.file = file
	return r
}

// A recording file to download and analyze (Size limit: 1GB)
func (r ApiSummarizeTopicsRequest) Url(url string) ApiSummarizeTopicsRequest {
	r.url = &url
	return r
}

// The number of results to return
func (r ApiSummarizeTopicsRequest) Limit(limit int32) ApiSummarizeTopicsRequest {
	r.limit = &limit
	return r
}

// The starting offset into the total result set to start from
func (r ApiSummarizeTopicsRequest) Offset(offset int32) ApiSummarizeTopicsRequest {
	r.offset = &offset
	return r
}

// When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open
func (r ApiSummarizeTopicsRequest) Callback(callback string) ApiSummarizeTopicsRequest {
	r.callback = &callback
	return r
}

func (r ApiSummarizeTopicsRequest) Execute() (*OrsonAiTopicsResponse, *http.Response, error) {
	return r.ApiService.SummarizeTopicsExecute(r)
}

/*
SummarizeTopics Summarize Topics

Takes in a string of text sentences (also known as a document) and returns a list of associated topics and their proximity score.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiSummarizeTopicsRequest
*/
func (a *OrsonAPIService) SummarizeTopics(ctx context.Context, version float32) ApiSummarizeTopicsRequest {
	return ApiSummarizeTopicsRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return OrsonAiTopicsResponse
func (a *OrsonAPIService) SummarizeTopicsExecute(r ApiSummarizeTopicsRequest) (*OrsonAiTopicsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrsonAiTopicsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrsonAPIService.SummarizeTopics")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/orson/ai/topics"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	if r.thirdPartyAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "thirdPartyAccountId", r.thirdPartyAccountId, "form", "")
	}
	if r.doc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "doc", r.doc, "form", "")
	}
	if r.file != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "file", r.file, "form", "")
	}
	if r.url != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "url", r.url, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.callback != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "callback", r.callback, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTechTuneRequest struct {
	ctx context.Context
	ApiService *OrsonAPIService
	version float32
	accountId *int64
	numFacesExpected *int32
	thirdPartyAccountId *string
	file *os.File
	url *string
	callback *string
}

// Sirqul Account Id
func (r ApiTechTuneRequest) AccountId(accountId int64) ApiTechTuneRequest {
	r.accountId = &accountId
	return r
}

// Number of expected faces
func (r ApiTechTuneRequest) NumFacesExpected(numFacesExpected int32) ApiTechTuneRequest {
	r.numFacesExpected = &numFacesExpected
	return r
}

// A third-party account id that is meaningful to your systems
func (r ApiTechTuneRequest) ThirdPartyAccountId(thirdPartyAccountId string) ApiTechTuneRequest {
	r.thirdPartyAccountId = &thirdPartyAccountId
	return r
}

// An uploaded recording to analyze (Currently limited to 10MB)
func (r ApiTechTuneRequest) File(file *os.File) ApiTechTuneRequest {
	r.file = file
	return r
}

// A recording file to download and analyze (Size limit: 1GB)
func (r ApiTechTuneRequest) Url(url string) ApiTechTuneRequest {
	r.url = &url
	return r
}

// When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open
func (r ApiTechTuneRequest) Callback(callback string) ApiTechTuneRequest {
	r.callback = &callback
	return r
}

func (r ApiTechTuneRequest) Execute() (*OrsonAiTechTuneResponse, *http.Response, error) {
	return r.ApiService.TechTuneExecute(r)
}

/*
TechTune Detect Technical Issues

Analyses a movie file to detect technical issues, such as too few people in frame.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiTechTuneRequest
*/
func (a *OrsonAPIService) TechTune(ctx context.Context, version float32) ApiTechTuneRequest {
	return ApiTechTuneRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return OrsonAiTechTuneResponse
func (a *OrsonAPIService) TechTuneExecute(r ApiTechTuneRequest) (*OrsonAiTechTuneResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrsonAiTechTuneResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrsonAPIService.TechTune")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/orson/ai/techTune"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.numFacesExpected == nil {
		return localVarReturnValue, nil, reportError("numFacesExpected is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	if r.thirdPartyAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "thirdPartyAccountId", r.thirdPartyAccountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "numFacesExpected", r.numFacesExpected, "form", "")
	if r.file != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "file", r.file, "form", "")
	}
	if r.url != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "url", r.url, "form", "")
	}
	if r.callback != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "callback", r.callback, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTtsRequest struct {
	ctx context.Context
	ApiService *OrsonAPIService
	version float32
	accountId *int64
	text *string
	thirdPartyAccountId *string
	language *string
	voice *string
	callback *string
}

// Sirqul Account Id
func (r ApiTtsRequest) AccountId(accountId int64) ApiTtsRequest {
	r.accountId = &accountId
	return r
}

// Text
func (r ApiTtsRequest) Text(text string) ApiTtsRequest {
	r.text = &text
	return r
}

// A third-party account id that is meaningful to your systems
func (r ApiTtsRequest) ThirdPartyAccountId(thirdPartyAccountId string) ApiTtsRequest {
	r.thirdPartyAccountId = &thirdPartyAccountId
	return r
}

// The language to use for the speaker and incoming text
func (r ApiTtsRequest) Language(language string) ApiTtsRequest {
	r.language = &language
	return r
}

// A language-specific voice to use, or picks the language default if not provided
func (r ApiTtsRequest) Voice(voice string) ApiTtsRequest {
	r.voice = &voice
	return r
}

// When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open
func (r ApiTtsRequest) Callback(callback string) ApiTtsRequest {
	r.callback = &callback
	return r
}

func (r ApiTtsRequest) Execute() (*OrsonAiTTSResponse, *http.Response, error) {
	return r.ApiService.TtsExecute(r)
}

/*
Tts Text to Speach

Creates an audio file for the given text, with the option of language and voice selection.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiTtsRequest
*/
func (a *OrsonAPIService) Tts(ctx context.Context, version float32) ApiTtsRequest {
	return ApiTtsRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return OrsonAiTTSResponse
func (a *OrsonAPIService) TtsExecute(r ApiTtsRequest) (*OrsonAiTTSResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrsonAiTTSResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrsonAPIService.Tts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/orson/ai/tts"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.text == nil {
		return localVarReturnValue, nil, reportError("text is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	if r.thirdPartyAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "thirdPartyAccountId", r.thirdPartyAccountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "text", r.text, "form", "")
	if r.language != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "language", r.language, "form", "")
	}
	if r.voice != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "voice", r.voice, "form", "")
	}
	if r.callback != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "callback", r.callback, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
