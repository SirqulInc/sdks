/*
Sirqul IoT Platform

Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

API version: 3.16
Contact: info@sirqul.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// AudienceAPIService AudienceAPI service
type AudienceAPIService service

type ApiCreateAudienceRequest struct {
	ctx context.Context
	ApiService *AudienceAPIService
	version float32
	accountId *int64
	name *string
	description *string
	searchTags *string
	gender *string
	ageGroups *string
	categoryIds *string
	applicationIds *string
	gameExperienceLevel *string
	devices *string
	deviceIds *string
	deviceVersions *string
	locations *string
	radius *string
	startTimeOffset *int32
	endTimeOffset *int32
	sendSuggestion *bool
	associateDescription *string
	associateType *string
	associateId *int64
	groupingId *string
	metaData *string
	visibility *string
	audienceType *string
	useOrder *bool
	cohortRegionsData *string
	appKey *string
	trilaterationTypes *string
	uniqueName *bool
}

// The logged in user.
func (r ApiCreateAudienceRequest) AccountId(accountId int64) ApiCreateAudienceRequest {
	r.accountId = &accountId
	return r
}

// The name of the audience
func (r ApiCreateAudienceRequest) Name(name string) ApiCreateAudienceRequest {
	r.name = &name
	return r
}

// The description of the audience
func (r ApiCreateAudienceRequest) Description(description string) ApiCreateAudienceRequest {
	r.description = &description
	return r
}

// The search tags
func (r ApiCreateAudienceRequest) SearchTags(searchTags string) ApiCreateAudienceRequest {
	r.searchTags = &searchTags
	return r
}

// The gender; possible values are: MALE, FEMALE, ANY
func (r ApiCreateAudienceRequest) Gender(gender string) ApiCreateAudienceRequest {
	r.gender = &gender
	return r
}

// The list of age groups, comma separated; possible values are AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS, AGE_ANY (to reset to none)
func (r ApiCreateAudienceRequest) AgeGroups(ageGroups string) ApiCreateAudienceRequest {
	r.ageGroups = &ageGroups
	return r
}

// The list of category ids, comma separated; possible values are retrieved via /api/{version}/category/search (pass in id values)
func (r ApiCreateAudienceRequest) CategoryIds(categoryIds string) ApiCreateAudienceRequest {
	r.categoryIds = &categoryIds
	return r
}

// The list of application ids, comma separated; possible values are retrieved via /api/{version}/application/list (pass in id values)
func (r ApiCreateAudienceRequest) ApplicationIds(applicationIds string) ApiCreateAudienceRequest {
	r.applicationIds = &applicationIds
	return r
}

// The experience level of the player; possible values are: ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT
func (r ApiCreateAudienceRequest) GameExperienceLevel(gameExperienceLevel string) ApiCreateAudienceRequest {
	r.gameExperienceLevel = &gameExperienceLevel
	return r
}

// (Deprecated) Use deviceIds. The list of targeted device names, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in name values)
func (r ApiCreateAudienceRequest) Devices(devices string) ApiCreateAudienceRequest {
	r.devices = &devices
	return r
}

// The list of targeted device ids, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in id values)
func (r ApiCreateAudienceRequest) DeviceIds(deviceIds string) ApiCreateAudienceRequest {
	r.deviceIds = &deviceIds
	return r
}

// The list of targeted device version ranges that are aligned with the provided devices list, comma separated (examples: 2.3-X, 0-5.1.4, 4.3.1-6.1.4)
func (r ApiCreateAudienceRequest) DeviceVersions(deviceVersions string) ApiCreateAudienceRequest {
	r.deviceVersions = &deviceVersions
	return r
}

// The list of locations to build the center around; comma separated list of latitude/longitude pairs (example: lat1,long1,lat2,long2)
func (r ApiCreateAudienceRequest) Locations(locations string) ApiCreateAudienceRequest {
	r.locations = &locations
	return r
}

// The list of radius of influence for the audience, in miles; comma separated list. Either provide 1 to be applied to all location pairs or a matching list to each lat/long pair.
func (r ApiCreateAudienceRequest) Radius(radius string) ApiCreateAudienceRequest {
	r.radius = &radius
	return r
}

// Seconds from the start time of an event
func (r ApiCreateAudienceRequest) StartTimeOffset(startTimeOffset int32) ApiCreateAudienceRequest {
	r.startTimeOffset = &startTimeOffset
	return r
}

// Seconds from the end time of an event
func (r ApiCreateAudienceRequest) EndTimeOffset(endTimeOffset int32) ApiCreateAudienceRequest {
	r.endTimeOffset = &endTimeOffset
	return r
}

// If true, then notify matching users when they are inside the radius
func (r ApiCreateAudienceRequest) SendSuggestion(sendSuggestion bool) ApiCreateAudienceRequest {
	r.sendSuggestion = &sendSuggestion
	return r
}

// The description of the associated object
func (r ApiCreateAudienceRequest) AssociateDescription(associateDescription string) ApiCreateAudienceRequest {
	r.associateDescription = &associateDescription
	return r
}

// The type of the object to center the audience geofence
func (r ApiCreateAudienceRequest) AssociateType(associateType string) ApiCreateAudienceRequest {
	r.associateType = &associateType
	return r
}

// The ID of the object to center the audience geofence
func (r ApiCreateAudienceRequest) AssociateId(associateId int64) ApiCreateAudienceRequest {
	r.associateId = &associateId
	return r
}

// Optional grouping id for the audience
func (r ApiCreateAudienceRequest) GroupingId(groupingId string) ApiCreateAudienceRequest {
	r.groupingId = &groupingId
	return r
}

// External custom client defined data
func (r ApiCreateAudienceRequest) MetaData(metaData string) ApiCreateAudienceRequest {
	r.metaData = &metaData
	return r
}

// Visibility of the audience
func (r ApiCreateAudienceRequest) Visibility(visibility string) ApiCreateAudienceRequest {
	r.visibility = &visibility
	return r
}

// Type of audience
func (r ApiCreateAudienceRequest) AudienceType(audienceType string) ApiCreateAudienceRequest {
	r.audienceType = &audienceType
	return r
}

// Use order for cohort
func (r ApiCreateAudienceRequest) UseOrder(useOrder bool) ApiCreateAudienceRequest {
	r.useOrder = &useOrder
	return r
}

// Cohort data for \&quot;cohort\&quot; audience type
func (r ApiCreateAudienceRequest) CohortRegionsData(cohortRegionsData string) ApiCreateAudienceRequest {
	r.cohortRegionsData = &cohortRegionsData
	return r
}

// Filter results by application key
func (r ApiCreateAudienceRequest) AppKey(appKey string) ApiCreateAudienceRequest {
	r.appKey = &appKey
	return r
}

// Trilateration types
func (r ApiCreateAudienceRequest) TrilaterationTypes(trilaterationTypes string) ApiCreateAudienceRequest {
	r.trilaterationTypes = &trilaterationTypes
	return r
}

// If true, makes sure the audience name is unique
func (r ApiCreateAudienceRequest) UniqueName(uniqueName bool) ApiCreateAudienceRequest {
	r.uniqueName = &uniqueName
	return r
}

func (r ApiCreateAudienceRequest) Execute() (*AudienceResponse, *http.Response, error) {
	return r.ApiService.CreateAudienceExecute(r)
}

/*
CreateAudience Create Audience

Create a user defined audience.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiCreateAudienceRequest
*/
func (a *AudienceAPIService) CreateAudience(ctx context.Context, version float32) ApiCreateAudienceRequest {
	return ApiCreateAudienceRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return AudienceResponse
func (a *AudienceAPIService) CreateAudienceExecute(r ApiCreateAudienceRequest) (*AudienceResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AudienceResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AudienceAPIService.CreateAudience")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/audience/create"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.name == nil {
		return localVarReturnValue, nil, reportError("name is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "form", "")
	}
	if r.searchTags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "searchTags", r.searchTags, "form", "")
	}
	if r.gender != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gender", r.gender, "form", "")
	}
	if r.ageGroups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ageGroups", r.ageGroups, "form", "")
	}
	if r.categoryIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "categoryIds", r.categoryIds, "form", "")
	}
	if r.applicationIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "applicationIds", r.applicationIds, "form", "")
	}
	if r.gameExperienceLevel != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gameExperienceLevel", r.gameExperienceLevel, "form", "")
	}
	if r.devices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "devices", r.devices, "form", "")
	}
	if r.deviceIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceIds", r.deviceIds, "form", "")
	}
	if r.deviceVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceVersions", r.deviceVersions, "form", "")
	}
	if r.locations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locations", r.locations, "form", "")
	}
	if r.radius != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "radius", r.radius, "form", "")
	}
	if r.startTimeOffset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTimeOffset", r.startTimeOffset, "form", "")
	}
	if r.endTimeOffset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTimeOffset", r.endTimeOffset, "form", "")
	}
	if r.sendSuggestion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sendSuggestion", r.sendSuggestion, "form", "")
	} else {
		var defaultValue bool = true
		parameterAddToHeaderOrQuery(localVarQueryParams, "sendSuggestion", defaultValue, "form", "")
		r.sendSuggestion = &defaultValue
	}
	if r.associateDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "associateDescription", r.associateDescription, "form", "")
	}
	if r.associateType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "associateType", r.associateType, "form", "")
	}
	if r.associateId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "associateId", r.associateId, "form", "")
	}
	if r.groupingId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "groupingId", r.groupingId, "form", "")
	}
	if r.metaData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metaData", r.metaData, "form", "")
	}
	if r.visibility != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "visibility", r.visibility, "form", "")
	}
	if r.audienceType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audienceType", r.audienceType, "form", "")
	}
	if r.useOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "useOrder", r.useOrder, "form", "")
	}
	if r.cohortRegionsData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cohortRegionsData", r.cohortRegionsData, "form", "")
	}
	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	if r.trilaterationTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "trilaterationTypes", r.trilaterationTypes, "form", "")
	}
	if r.uniqueName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueName", r.uniqueName, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteAudienceRequest struct {
	ctx context.Context
	ApiService *AudienceAPIService
	version float32
	accountId *int64
	audienceId *int64
}

// The logged in user.
func (r ApiDeleteAudienceRequest) AccountId(accountId int64) ApiDeleteAudienceRequest {
	r.accountId = &accountId
	return r
}

// The id of the audience to delete.
func (r ApiDeleteAudienceRequest) AudienceId(audienceId int64) ApiDeleteAudienceRequest {
	r.audienceId = &audienceId
	return r
}

func (r ApiDeleteAudienceRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.DeleteAudienceExecute(r)
}

/*
DeleteAudience Delete Audience

Delete an audience. The audience and account must be valid and have the appropirate permissions to view the content.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiDeleteAudienceRequest
*/
func (a *AudienceAPIService) DeleteAudience(ctx context.Context, version float32) ApiDeleteAudienceRequest {
	return ApiDeleteAudienceRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *AudienceAPIService) DeleteAudienceExecute(r ApiDeleteAudienceRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AudienceAPIService.DeleteAudience")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/audience/delete"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.audienceId == nil {
		return localVarReturnValue, nil, reportError("audienceId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "audienceId", r.audienceId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAgeGroupsRequest struct {
	ctx context.Context
	ApiService *AudienceAPIService
	version float32
}

func (r ApiGetAgeGroupsRequest) Execute() ([]AgeGroupResponse, *http.Response, error) {
	return r.ApiService.GetAgeGroupsExecute(r)
}

/*
GetAgeGroups Get Age Groups

Gets the list of available age groups that can be selected by consumers and retailers targeting offers.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiGetAgeGroupsRequest
*/
func (a *AudienceAPIService) GetAgeGroups(ctx context.Context, version float32) ApiGetAgeGroupsRequest {
	return ApiGetAgeGroupsRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return []AgeGroupResponse
func (a *AudienceAPIService) GetAgeGroupsExecute(r ApiGetAgeGroupsRequest) ([]AgeGroupResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []AgeGroupResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AudienceAPIService.GetAgeGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/audience/ageGroups"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAudienceRequest struct {
	ctx context.Context
	ApiService *AudienceAPIService
	version float32
	accountId *int64
	audienceId *int64
	appKey *string
	returnAccountCount *bool
	returnAlbumCount *bool
	albumTypesForCount *string
}

// The logged in user.
func (r ApiGetAudienceRequest) AccountId(accountId int64) ApiGetAudienceRequest {
	r.accountId = &accountId
	return r
}

// The id of the audience to return.
func (r ApiGetAudienceRequest) AudienceId(audienceId int64) ApiGetAudienceRequest {
	r.audienceId = &audienceId
	return r
}

// The application key (optional). If provided, results may be scoped to this application.
func (r ApiGetAudienceRequest) AppKey(appKey string) ApiGetAudienceRequest {
	r.appKey = &appKey
	return r
}

// (boolean) set to true to include the accountCount associated with current audience of the current app
func (r ApiGetAudienceRequest) ReturnAccountCount(returnAccountCount bool) ApiGetAudienceRequest {
	r.returnAccountCount = &returnAccountCount
	return r
}

// (boolean) set to true to include the albumCount associated with current audience of the current app
func (r ApiGetAudienceRequest) ReturnAlbumCount(returnAlbumCount bool) ApiGetAudienceRequest {
	r.returnAlbumCount = &returnAlbumCount
	return r
}

// (String) comma separated list, return an array with each item is the count of each album type. If not provided, \&quot;all_types\&quot; count is returned.
func (r ApiGetAudienceRequest) AlbumTypesForCount(albumTypesForCount string) ApiGetAudienceRequest {
	r.albumTypesForCount = &albumTypesForCount
	return r
}

func (r ApiGetAudienceRequest) Execute() (*AudienceResponse, *http.Response, error) {
	return r.ApiService.GetAudienceExecute(r)
}

/*
GetAudience Get Audience

Get an audience. The audience and account must be valid and have the appropriate permissions to view the content.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiGetAudienceRequest
*/
func (a *AudienceAPIService) GetAudience(ctx context.Context, version float32) ApiGetAudienceRequest {
	return ApiGetAudienceRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return AudienceResponse
func (a *AudienceAPIService) GetAudienceExecute(r ApiGetAudienceRequest) (*AudienceResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AudienceResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AudienceAPIService.GetAudience")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/audience/get"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.audienceId == nil {
		return localVarReturnValue, nil, reportError("audienceId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "audienceId", r.audienceId, "form", "")
	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	if r.returnAccountCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnAccountCount", r.returnAccountCount, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnAccountCount", defaultValue, "form", "")
		r.returnAccountCount = &defaultValue
	}
	if r.returnAlbumCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnAlbumCount", r.returnAlbumCount, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnAlbumCount", defaultValue, "form", "")
		r.returnAlbumCount = &defaultValue
	}
	if r.albumTypesForCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "albumTypesForCount", r.albumTypesForCount, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAudienceListRequest struct {
	ctx context.Context
	ApiService *AudienceAPIService
	version float32
	accountId *int64
	albumIds *string
	keyword *string
	keywordFields *string
	sortField *string
	descending *bool
	start *int32
	limit *int32
	sendSuggestion *bool
	activeOnly *bool
	groupByGroupingId *bool
	appKey *string
	returnGlobal *bool
	exactKeyword *bool
	audienceType *string
	audienceTypes *string
	returnAccountCount *bool
	returnAlbumCount *bool
	albumTypesForCount *string
}

// The logged in user.
func (r ApiGetAudienceListRequest) AccountId(accountId int64) ApiGetAudienceListRequest {
	r.accountId = &accountId
	return r
}

// Comma separated list of album IDs to filter results with
func (r ApiGetAudienceListRequest) AlbumIds(albumIds string) ApiGetAudienceListRequest {
	r.albumIds = &albumIds
	return r
}

// The keyword used to search
func (r ApiGetAudienceListRequest) Keyword(keyword string) ApiGetAudienceListRequest {
	r.keyword = &keyword
	return r
}

// Comma separated list of fields that the keywords will match against. Possible values include: SEARCH_TAGS, NAME, DESCRIPTION, OWNER_DISPLAY
func (r ApiGetAudienceListRequest) KeywordFields(keywordFields string) ApiGetAudienceListRequest {
	r.keywordFields = &keywordFields
	return r
}

// The field to sort by, possible values include: {ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, NAME, DESCRIPTION, OWNER_ID, OWNER_DISPLAY, GENDER}
func (r ApiGetAudienceListRequest) SortField(sortField string) ApiGetAudienceListRequest {
	r.sortField = &sortField
	return r
}

// The order to return the results. Default is false, which will return the results in ascending order.
func (r ApiGetAudienceListRequest) Descending(descending bool) ApiGetAudienceListRequest {
	r.descending = &descending
	return r
}

// The index into the record set to start with.
func (r ApiGetAudienceListRequest) Start(start int32) ApiGetAudienceListRequest {
	r.start = &start
	return r
}

// The total number of record to return (there is a hard limit of 100).
func (r ApiGetAudienceListRequest) Limit(limit int32) ApiGetAudienceListRequest {
	r.limit = &limit
	return r
}

// Filter results based on whether or not the audience is set to send suggestions
func (r ApiGetAudienceListRequest) SendSuggestion(sendSuggestion bool) ApiGetAudienceListRequest {
	r.sendSuggestion = &sendSuggestion
	return r
}

// Determines whether to return only active results. Default is false.
func (r ApiGetAudienceListRequest) ActiveOnly(activeOnly bool) ApiGetAudienceListRequest {
	r.activeOnly = &activeOnly
	return r
}

// Groups results by the audience groupingId (this does not work in conjunction with the following parameters: albumIds, audienceType, appKey, returnGlobal)
func (r ApiGetAudienceListRequest) GroupByGroupingId(groupByGroupingId bool) ApiGetAudienceListRequest {
	r.groupByGroupingId = &groupByGroupingId
	return r
}

// Filter results by application key
func (r ApiGetAudienceListRequest) AppKey(appKey string) ApiGetAudienceListRequest {
	r.appKey = &appKey
	return r
}

// If filtering by appKey, determines whether or not audiences that do not have an application set will also be returned as well
func (r ApiGetAudienceListRequest) ReturnGlobal(returnGlobal bool) ApiGetAudienceListRequest {
	r.returnGlobal = &returnGlobal
	return r
}

// If true, match keyword exactly
func (r ApiGetAudienceListRequest) ExactKeyword(exactKeyword bool) ApiGetAudienceListRequest {
	r.exactKeyword = &exactKeyword
	return r
}

// (Deprecated) Filter results by audience type
func (r ApiGetAudienceListRequest) AudienceType(audienceType string) ApiGetAudienceListRequest {
	r.audienceType = &audienceType
	return r
}

// comma separated string with the different audience types you want to filter for
func (r ApiGetAudienceListRequest) AudienceTypes(audienceTypes string) ApiGetAudienceListRequest {
	r.audienceTypes = &audienceTypes
	return r
}

// (boolean) set to true to include the accountCount associated with current audience of the current app
func (r ApiGetAudienceListRequest) ReturnAccountCount(returnAccountCount bool) ApiGetAudienceListRequest {
	r.returnAccountCount = &returnAccountCount
	return r
}

// (boolean) set to true to include the albumCount associated with current audience of the current app
func (r ApiGetAudienceListRequest) ReturnAlbumCount(returnAlbumCount bool) ApiGetAudienceListRequest {
	r.returnAlbumCount = &returnAlbumCount
	return r
}

// (String) comma separated list, return an array with each item is the count of each album type. If not provided, \&quot;all_types\&quot; count is returned.
func (r ApiGetAudienceListRequest) AlbumTypesForCount(albumTypesForCount string) ApiGetAudienceListRequest {
	r.albumTypesForCount = &albumTypesForCount
	return r
}

func (r ApiGetAudienceListRequest) Execute() ([]SearchResponse, *http.Response, error) {
	return r.ApiService.GetAudienceListExecute(r)
}

/*
GetAudienceList Search Audiences

Get the list audiences owned by the account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiGetAudienceListRequest
*/
func (a *AudienceAPIService) GetAudienceList(ctx context.Context, version float32) ApiGetAudienceListRequest {
	return ApiGetAudienceListRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return []SearchResponse
func (a *AudienceAPIService) GetAudienceListExecute(r ApiGetAudienceListRequest) ([]SearchResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SearchResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AudienceAPIService.GetAudienceList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/audience/search"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.albumIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "albumIds", r.albumIds, "form", "")
	}
	if r.keyword != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyword", r.keyword, "form", "")
	}
	if r.keywordFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keywordFields", r.keywordFields, "form", "")
	} else {
		var defaultValue string = "SEARCH_TAGS,NAME,DESCRIPTION"
		parameterAddToHeaderOrQuery(localVarQueryParams, "keywordFields", defaultValue, "form", "")
		r.keywordFields = &defaultValue
	}
	if r.sortField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", r.sortField, "form", "")
	} else {
		var defaultValue string = "NAME"
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", defaultValue, "form", "")
		r.sortField = &defaultValue
	}
	if r.descending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", defaultValue, "form", "")
		r.descending = &defaultValue
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	} else {
		var defaultValue int32 = 0
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", defaultValue, "form", "")
		r.start = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 20
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	if r.sendSuggestion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sendSuggestion", r.sendSuggestion, "form", "")
	}
	if r.activeOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activeOnly", r.activeOnly, "form", "")
	}
	if r.groupByGroupingId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "groupByGroupingId", r.groupByGroupingId, "form", "")
	}
	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	if r.returnGlobal != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnGlobal", r.returnGlobal, "form", "")
	}
	if r.exactKeyword != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exactKeyword", r.exactKeyword, "form", "")
	}
	if r.audienceType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audienceType", r.audienceType, "form", "")
	}
	if r.audienceTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audienceTypes", r.audienceTypes, "form", "")
	}
	if r.returnAccountCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnAccountCount", r.returnAccountCount, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnAccountCount", defaultValue, "form", "")
		r.returnAccountCount = &defaultValue
	}
	if r.returnAlbumCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnAlbumCount", r.returnAlbumCount, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnAlbumCount", defaultValue, "form", "")
		r.returnAlbumCount = &defaultValue
	}
	if r.albumTypesForCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "albumTypesForCount", r.albumTypesForCount, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDevicesRequest struct {
	ctx context.Context
	ApiService *AudienceAPIService
	version float32
	includeInactive *bool
}

// If true return inactive record as well. default is false.
func (r ApiGetDevicesRequest) IncludeInactive(includeInactive bool) ApiGetDevicesRequest {
	r.includeInactive = &includeInactive
	return r
}

func (r ApiGetDevicesRequest) Execute() ([]AudienceDeviceResponse, *http.Response, error) {
	return r.ApiService.GetDevicesExecute(r)
}

/*
GetDevices Get Devices

Gets the list of available devices that can be selected by consumers and retailers.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiGetDevicesRequest
*/
func (a *AudienceAPIService) GetDevices(ctx context.Context, version float32) ApiGetDevicesRequest {
	return ApiGetDevicesRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return []AudienceDeviceResponse
func (a *AudienceAPIService) GetDevicesExecute(r ApiGetDevicesRequest) ([]AudienceDeviceResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []AudienceDeviceResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AudienceAPIService.GetDevices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/audience/devices"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.includeInactive == nil {
		return localVarReturnValue, nil, reportError("includeInactive is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetExperiencesRequest struct {
	ctx context.Context
	ApiService *AudienceAPIService
	version float32
}

func (r ApiGetExperiencesRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.GetExperiencesExecute(r)
}

/*
GetExperiences Get Experiences

Gets the list of available experiences that can be selected by consumers and retailers.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiGetExperiencesRequest
*/
func (a *AudienceAPIService) GetExperiences(ctx context.Context, version float32) ApiGetExperiencesRequest {
	return ApiGetExperiencesRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *AudienceAPIService) GetExperiencesExecute(r ApiGetExperiencesRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AudienceAPIService.GetExperiences")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/audience/experiences"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGroupedAudiencesRequest struct {
	ctx context.Context
	ApiService *AudienceAPIService
	version float32
	accountId *int64
	audienceGroupingId *string
}

// The logged in user.
func (r ApiGetGroupedAudiencesRequest) AccountId(accountId int64) ApiGetGroupedAudiencesRequest {
	r.accountId = &accountId
	return r
}

// The audience grouping id to return.
func (r ApiGetGroupedAudiencesRequest) AudienceGroupingId(audienceGroupingId string) ApiGetGroupedAudiencesRequest {
	r.audienceGroupingId = &audienceGroupingId
	return r
}

func (r ApiGetGroupedAudiencesRequest) Execute() (*AudienceResponse, *http.Response, error) {
	return r.ApiService.GetGroupedAudiencesExecute(r)
}

/*
GetGroupedAudiences Get GroupedAudiences

Get a group of audiences. The audience and account must be valid and have the appropriate permissions to view the content.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiGetGroupedAudiencesRequest
*/
func (a *AudienceAPIService) GetGroupedAudiences(ctx context.Context, version float32) ApiGetGroupedAudiencesRequest {
	return ApiGetGroupedAudiencesRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return AudienceResponse
func (a *AudienceAPIService) GetGroupedAudiencesExecute(r ApiGetGroupedAudiencesRequest) (*AudienceResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AudienceResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AudienceAPIService.GetGroupedAudiences")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/audience/grouped/get"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.audienceGroupingId == nil {
		return localVarReturnValue, nil, reportError("audienceGroupingId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "audienceGroupingId", r.audienceGroupingId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListByAccountRequest struct {
	ctx context.Context
	ApiService *AudienceAPIService
	version float32
	accountId *int64
	limit *int32
	suggestionType *string
}

// The account to match offers for.
func (r ApiListByAccountRequest) AccountId(accountId int64) ApiListByAccountRequest {
	r.accountId = &accountId
	return r
}

// the limit of the index
func (r ApiListByAccountRequest) Limit(limit int32) ApiListByAccountRequest {
	r.limit = &limit
	return r
}

// the type of suggestion
func (r ApiListByAccountRequest) SuggestionType(suggestionType string) ApiListByAccountRequest {
	r.suggestionType = &suggestionType
	return r
}

func (r ApiListByAccountRequest) Execute() (*OfferListResponse, *http.Response, error) {
	return r.ApiService.ListByAccountExecute(r)
}

/*
ListByAccount List Suggestions by Audience

List either Missions or Offers that the user matches the assigned audience.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiListByAccountRequest
*/
func (a *AudienceAPIService) ListByAccount(ctx context.Context, version float32) ApiListByAccountRequest {
	return ApiListByAccountRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return OfferListResponse
func (a *AudienceAPIService) ListByAccountExecute(r ApiListByAccountRequest) (*OfferListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OfferListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AudienceAPIService.ListByAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/audience/suggestion/list"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.limit == nil {
		return localVarReturnValue, nil, reportError("limit is required and must be specified")
	}
	if r.suggestionType == nil {
		return localVarReturnValue, nil, reportError("suggestionType is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "suggestionType", r.suggestionType, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListByAudienceRequest struct {
	ctx context.Context
	ApiService *AudienceAPIService
	version float32
	limit *int32
	gender *string
	age *int32
	categoryIds *string
	latitude *float64
	longitude *float64
}

// this is the limit of the index
func (r ApiListByAudienceRequest) Limit(limit int32) ApiListByAudienceRequest {
	r.limit = &limit
	return r
}

// this is the gender to list offers by
func (r ApiListByAudienceRequest) Gender(gender string) ApiListByAudienceRequest {
	r.gender = &gender
	return r
}

// this is the age to list offers by
func (r ApiListByAudienceRequest) Age(age int32) ApiListByAudienceRequest {
	r.age = &age
	return r
}

// this is the category IDs to list offers by
func (r ApiListByAudienceRequest) CategoryIds(categoryIds string) ApiListByAudienceRequest {
	r.categoryIds = &categoryIds
	return r
}

// this is the latitude to list offers by
func (r ApiListByAudienceRequest) Latitude(latitude float64) ApiListByAudienceRequest {
	r.latitude = &latitude
	return r
}

// this is the longitude to list offers by
func (r ApiListByAudienceRequest) Longitude(longitude float64) ApiListByAudienceRequest {
	r.longitude = &longitude
	return r
}

func (r ApiListByAudienceRequest) Execute() (*OfferListResponse, *http.Response, error) {
	return r.ApiService.ListByAudienceExecute(r)
}

/*
ListByAudience List Offers by Audience

Get a list of offer locations based on audience information provided.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiListByAudienceRequest
*/
func (a *AudienceAPIService) ListByAudience(ctx context.Context, version float32) ApiListByAudienceRequest {
	return ApiListByAudienceRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return OfferListResponse
func (a *AudienceAPIService) ListByAudienceExecute(r ApiListByAudienceRequest) (*OfferListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OfferListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AudienceAPIService.ListByAudience")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/audience/suggestion/offersByAudience"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.limit == nil {
		return localVarReturnValue, nil, reportError("limit is required and must be specified")
	}

	if r.gender != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gender", r.gender, "form", "")
	}
	if r.age != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "age", r.age, "form", "")
	}
	if r.categoryIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "categoryIds", r.categoryIds, "form", "")
	}
	if r.latitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latitude", r.latitude, "form", "")
	}
	if r.longitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "longitude", r.longitude, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListLastestByAccountRequest struct {
	ctx context.Context
	ApiService *AudienceAPIService
	version float32
	accountId *int64
	timeframe *int32
	suggestionType *string
}

// The account to match offers for.
func (r ApiListLastestByAccountRequest) AccountId(accountId int64) ApiListLastestByAccountRequest {
	r.accountId = &accountId
	return r
}

// The timeframe in seconds of the latest suggestions
func (r ApiListLastestByAccountRequest) Timeframe(timeframe int32) ApiListLastestByAccountRequest {
	r.timeframe = &timeframe
	return r
}

// The type of trigger suggestions to return
func (r ApiListLastestByAccountRequest) SuggestionType(suggestionType string) ApiListLastestByAccountRequest {
	r.suggestionType = &suggestionType
	return r
}

func (r ApiListLastestByAccountRequest) Execute() (*OfferListResponse, *http.Response, error) {
	return r.ApiService.ListLastestByAccountExecute(r)
}

/*
ListLastestByAccount List Sent Suggestions 

Return list of recent trigger suggestions that have been sent to the user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiListLastestByAccountRequest
*/
func (a *AudienceAPIService) ListLastestByAccount(ctx context.Context, version float32) ApiListLastestByAccountRequest {
	return ApiListLastestByAccountRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return OfferListResponse
func (a *AudienceAPIService) ListLastestByAccountExecute(r ApiListLastestByAccountRequest) (*OfferListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OfferListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AudienceAPIService.ListLastestByAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/audience/suggestion/latest"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.timeframe == nil {
		return localVarReturnValue, nil, reportError("timeframe is required and must be specified")
	}
	if r.suggestionType == nil {
		return localVarReturnValue, nil, reportError("suggestionType is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "timeframe", r.timeframe, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "suggestionType", r.suggestionType, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSendByAccountRequest struct {
	ctx context.Context
	ApiService *AudienceAPIService
	version float32
	accountId *int64
	latitude *float64
	longitude *float64
}

// The account to match offers for.
func (r ApiSendByAccountRequest) AccountId(accountId int64) ApiSendByAccountRequest {
	r.accountId = &accountId
	return r
}

// the latitude
func (r ApiSendByAccountRequest) Latitude(latitude float64) ApiSendByAccountRequest {
	r.latitude = &latitude
	return r
}

// the longitude
func (r ApiSendByAccountRequest) Longitude(longitude float64) ApiSendByAccountRequest {
	r.longitude = &longitude
	return r
}

func (r ApiSendByAccountRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.SendByAccountExecute(r)
}

/*
SendByAccount Send Suggestions

Use the accountId to determine the associated BillableEntity. From there get a list of all triggers associated with the BillableEntity.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiSendByAccountRequest
*/
func (a *AudienceAPIService) SendByAccount(ctx context.Context, version float32) ApiSendByAccountRequest {
	return ApiSendByAccountRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *AudienceAPIService) SendByAccountExecute(r ApiSendByAccountRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AudienceAPIService.SendByAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/audience/suggestion/send"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.latitude == nil {
		return localVarReturnValue, nil, reportError("latitude is required and must be specified")
	}
	if r.longitude == nil {
		return localVarReturnValue, nil, reportError("longitude is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "latitude", r.latitude, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "longitude", r.longitude, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateAudienceRequest struct {
	ctx context.Context
	ApiService *AudienceAPIService
	version float32
	accountId *int64
	audienceId *int64
	name *string
	description *string
	searchTags *string
	gender *string
	ageGroups *string
	categoryIds *string
	applicationIds *string
	gameExperienceLevel *string
	devices *string
	deviceIds *string
	deviceVersions *string
	locations *string
	radius *string
	active *bool
	sendSuggestion *bool
	startTimeOffset *int32
	endTimeOffset *int32
	associateDescription *string
	associateType *string
	associateId *int64
	groupingId *string
	metaData *string
	visibility *string
	audienceType *string
	useOrder *bool
	cohortRegionsData *string
	appKey *string
	trilaterationTypes *string
	uniqueName *bool
}

// The logged in user.
func (r ApiUpdateAudienceRequest) AccountId(accountId int64) ApiUpdateAudienceRequest {
	r.accountId = &accountId
	return r
}

// The id of the audience to update.
func (r ApiUpdateAudienceRequest) AudienceId(audienceId int64) ApiUpdateAudienceRequest {
	r.audienceId = &audienceId
	return r
}

// The name of the audience
func (r ApiUpdateAudienceRequest) Name(name string) ApiUpdateAudienceRequest {
	r.name = &name
	return r
}

// The description of the audience
func (r ApiUpdateAudienceRequest) Description(description string) ApiUpdateAudienceRequest {
	r.description = &description
	return r
}

// The search tags
func (r ApiUpdateAudienceRequest) SearchTags(searchTags string) ApiUpdateAudienceRequest {
	r.searchTags = &searchTags
	return r
}

// The gender; possible values are: MALE, FEMALE, ANY
func (r ApiUpdateAudienceRequest) Gender(gender string) ApiUpdateAudienceRequest {
	r.gender = &gender
	return r
}

// The list of age groups, comma separated; possible values are AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS, AGE_ANY (to reset to none)
func (r ApiUpdateAudienceRequest) AgeGroups(ageGroups string) ApiUpdateAudienceRequest {
	r.ageGroups = &ageGroups
	return r
}

// The list of category ids, comma separated; possible values are retrieved via /api/{version}/category/search (pass in id values)
func (r ApiUpdateAudienceRequest) CategoryIds(categoryIds string) ApiUpdateAudienceRequest {
	r.categoryIds = &categoryIds
	return r
}

// The list of application ids, comma separated; possible values are retrieved via /api/{version}/application/list (pass in id values)
func (r ApiUpdateAudienceRequest) ApplicationIds(applicationIds string) ApiUpdateAudienceRequest {
	r.applicationIds = &applicationIds
	return r
}

// The experience level of the player; possible values are: ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT
func (r ApiUpdateAudienceRequest) GameExperienceLevel(gameExperienceLevel string) ApiUpdateAudienceRequest {
	r.gameExperienceLevel = &gameExperienceLevel
	return r
}

// (Deprecated) Use deviceIds. The list of targeted device names, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in name values)
func (r ApiUpdateAudienceRequest) Devices(devices string) ApiUpdateAudienceRequest {
	r.devices = &devices
	return r
}

// The list of targeted device ids, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in id values)
func (r ApiUpdateAudienceRequest) DeviceIds(deviceIds string) ApiUpdateAudienceRequest {
	r.deviceIds = &deviceIds
	return r
}

// The list of targeted device version ranges that are aligned with the provided devices list, comma separated (examples: 2.3-X, 0-5.1.4, 4.3.1-6.1.4)
func (r ApiUpdateAudienceRequest) DeviceVersions(deviceVersions string) ApiUpdateAudienceRequest {
	r.deviceVersions = &deviceVersions
	return r
}

// The list of locations to build the center around; comma separated list of latitude/longitude pairs (example: lat1,long1,lat2,long2)
func (r ApiUpdateAudienceRequest) Locations(locations string) ApiUpdateAudienceRequest {
	r.locations = &locations
	return r
}

// The list of radius of influence for the audience, in miles; comma separated list. Either provide 1 to be applied to all location pairs or a matching list to each lat/long pair.
func (r ApiUpdateAudienceRequest) Radius(radius string) ApiUpdateAudienceRequest {
	r.radius = &radius
	return r
}

// if audience is active
func (r ApiUpdateAudienceRequest) Active(active bool) ApiUpdateAudienceRequest {
	r.active = &active
	return r
}

// If true, then notify matching users when they are inside the radius
func (r ApiUpdateAudienceRequest) SendSuggestion(sendSuggestion bool) ApiUpdateAudienceRequest {
	r.sendSuggestion = &sendSuggestion
	return r
}

// Seconds from the start time of an event
func (r ApiUpdateAudienceRequest) StartTimeOffset(startTimeOffset int32) ApiUpdateAudienceRequest {
	r.startTimeOffset = &startTimeOffset
	return r
}

// Seconds from the end time of an event
func (r ApiUpdateAudienceRequest) EndTimeOffset(endTimeOffset int32) ApiUpdateAudienceRequest {
	r.endTimeOffset = &endTimeOffset
	return r
}

// the associate description
func (r ApiUpdateAudienceRequest) AssociateDescription(associateDescription string) ApiUpdateAudienceRequest {
	r.associateDescription = &associateDescription
	return r
}

// The type of the object to center the audience geofence
func (r ApiUpdateAudienceRequest) AssociateType(associateType string) ApiUpdateAudienceRequest {
	r.associateType = &associateType
	return r
}

// The ID of the object to center the audience geofence
func (r ApiUpdateAudienceRequest) AssociateId(associateId int64) ApiUpdateAudienceRequest {
	r.associateId = &associateId
	return r
}

// Optional grouping id for the audience
func (r ApiUpdateAudienceRequest) GroupingId(groupingId string) ApiUpdateAudienceRequest {
	r.groupingId = &groupingId
	return r
}

// External custom client defined data
func (r ApiUpdateAudienceRequest) MetaData(metaData string) ApiUpdateAudienceRequest {
	r.metaData = &metaData
	return r
}

// Visibility of the audience
func (r ApiUpdateAudienceRequest) Visibility(visibility string) ApiUpdateAudienceRequest {
	r.visibility = &visibility
	return r
}

// Type of audience
func (r ApiUpdateAudienceRequest) AudienceType(audienceType string) ApiUpdateAudienceRequest {
	r.audienceType = &audienceType
	return r
}

// Use order for cohort
func (r ApiUpdateAudienceRequest) UseOrder(useOrder bool) ApiUpdateAudienceRequest {
	r.useOrder = &useOrder
	return r
}

// Cohort data for \&quot;cohort\&quot; audience type
func (r ApiUpdateAudienceRequest) CohortRegionsData(cohortRegionsData string) ApiUpdateAudienceRequest {
	r.cohortRegionsData = &cohortRegionsData
	return r
}

// Filter results by application key
func (r ApiUpdateAudienceRequest) AppKey(appKey string) ApiUpdateAudienceRequest {
	r.appKey = &appKey
	return r
}

// Trilateration types
func (r ApiUpdateAudienceRequest) TrilaterationTypes(trilaterationTypes string) ApiUpdateAudienceRequest {
	r.trilaterationTypes = &trilaterationTypes
	return r
}

// If true, makes sure the audience name is unique
func (r ApiUpdateAudienceRequest) UniqueName(uniqueName bool) ApiUpdateAudienceRequest {
	r.uniqueName = &uniqueName
	return r
}

func (r ApiUpdateAudienceRequest) Execute() (*AudienceResponse, *http.Response, error) {
	return r.ApiService.UpdateAudienceExecute(r)
}

/*
UpdateAudience Update Audience

Update a user defined audience.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiUpdateAudienceRequest
*/
func (a *AudienceAPIService) UpdateAudience(ctx context.Context, version float32) ApiUpdateAudienceRequest {
	return ApiUpdateAudienceRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return AudienceResponse
func (a *AudienceAPIService) UpdateAudienceExecute(r ApiUpdateAudienceRequest) (*AudienceResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AudienceResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AudienceAPIService.UpdateAudience")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/audience/update"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.audienceId == nil {
		return localVarReturnValue, nil, reportError("audienceId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "audienceId", r.audienceId, "form", "")
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "form", "")
	}
	if r.searchTags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "searchTags", r.searchTags, "form", "")
	}
	if r.gender != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gender", r.gender, "form", "")
	}
	if r.ageGroups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ageGroups", r.ageGroups, "form", "")
	}
	if r.categoryIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "categoryIds", r.categoryIds, "form", "")
	}
	if r.applicationIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "applicationIds", r.applicationIds, "form", "")
	}
	if r.gameExperienceLevel != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gameExperienceLevel", r.gameExperienceLevel, "form", "")
	}
	if r.devices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "devices", r.devices, "form", "")
	}
	if r.deviceIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceIds", r.deviceIds, "form", "")
	}
	if r.deviceVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceVersions", r.deviceVersions, "form", "")
	}
	if r.locations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locations", r.locations, "form", "")
	}
	if r.radius != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "radius", r.radius, "form", "")
	}
	if r.active != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active", r.active, "form", "")
	}
	if r.sendSuggestion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sendSuggestion", r.sendSuggestion, "form", "")
	}
	if r.startTimeOffset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTimeOffset", r.startTimeOffset, "form", "")
	}
	if r.endTimeOffset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTimeOffset", r.endTimeOffset, "form", "")
	}
	if r.associateDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "associateDescription", r.associateDescription, "form", "")
	}
	if r.associateType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "associateType", r.associateType, "form", "")
	}
	if r.associateId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "associateId", r.associateId, "form", "")
	}
	if r.groupingId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "groupingId", r.groupingId, "form", "")
	}
	if r.metaData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metaData", r.metaData, "form", "")
	}
	if r.visibility != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "visibility", r.visibility, "form", "")
	}
	if r.audienceType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audienceType", r.audienceType, "form", "")
	}
	if r.useOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "useOrder", r.useOrder, "form", "")
	}
	if r.cohortRegionsData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cohortRegionsData", r.cohortRegionsData, "form", "")
	}
	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	if r.trilaterationTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "trilaterationTypes", r.trilaterationTypes, "form", "")
	}
	if r.uniqueName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueName", r.uniqueName, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
