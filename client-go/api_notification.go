/*
Sirqul IoT Platform

Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

API version: 3.16
Contact: info@sirqul.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// NotificationAPIService NotificationAPI service
type NotificationAPIService service

type ApiCreateNotificationTemplateRequest struct {
	ctx context.Context
	ApiService *NotificationAPIService
	accountId *int64
	conduit *string
	title *string
	body *string
	appKey *string
	event *string
	tags *string
}

// The account ID of the user.
func (r ApiCreateNotificationTemplateRequest) AccountId(accountId int64) ApiCreateNotificationTemplateRequest {
	r.accountId = &accountId
	return r
}

// Filter results by notification type: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.
func (r ApiCreateNotificationTemplateRequest) Conduit(conduit string) ApiCreateNotificationTemplateRequest {
	r.conduit = &conduit
	return r
}

// title of the notification template
func (r ApiCreateNotificationTemplateRequest) Title(title string) ApiCreateNotificationTemplateRequest {
	r.title = &title
	return r
}

// body of the notification template
func (r ApiCreateNotificationTemplateRequest) Body(body string) ApiCreateNotificationTemplateRequest {
	r.body = &body
	return r
}

// Filter results by application.
func (r ApiCreateNotificationTemplateRequest) AppKey(appKey string) ApiCreateNotificationTemplateRequest {
	r.appKey = &appKey
	return r
}

// Filter results by event.
func (r ApiCreateNotificationTemplateRequest) Event(event string) ApiCreateNotificationTemplateRequest {
	r.event = &event
	return r
}

// tags associated with the note template
func (r ApiCreateNotificationTemplateRequest) Tags(tags string) ApiCreateNotificationTemplateRequest {
	r.tags = &tags
	return r
}

func (r ApiCreateNotificationTemplateRequest) Execute() (*NotificationTemplateResponse, *http.Response, error) {
	return r.ApiService.CreateNotificationTemplateExecute(r)
}

/*
CreateNotificationTemplate Create Notification Template

Create a notification template. Developers will only be able to create notification templates for their own applications.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateNotificationTemplateRequest
*/
func (a *NotificationAPIService) CreateNotificationTemplate(ctx context.Context) ApiCreateNotificationTemplateRequest {
	return ApiCreateNotificationTemplateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return NotificationTemplateResponse
func (a *NotificationAPIService) CreateNotificationTemplateExecute(r ApiCreateNotificationTemplateRequest) (*NotificationTemplateResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationTemplateResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationAPIService.CreateNotificationTemplate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notification/template/create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.conduit == nil {
		return localVarReturnValue, nil, reportError("conduit is required and must be specified")
	}
	if r.title == nil {
		return localVarReturnValue, nil, reportError("title is required and must be specified")
	}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	if r.event != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "event", r.event, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "conduit", r.conduit, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "title", r.title, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "body", r.body, "form", "")
	if r.tags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tags", r.tags, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateOrUpdateBlockedNotificationsRequest struct {
	ctx context.Context
	ApiService *NotificationAPIService
	appKey *string
	data *string
	accountId *int64
}

// The application key
func (r ApiCreateOrUpdateBlockedNotificationsRequest) AppKey(appKey string) ApiCreateOrUpdateBlockedNotificationsRequest {
	r.appKey = &appKey
	return r
}

// batch data payload (application specific)
func (r ApiCreateOrUpdateBlockedNotificationsRequest) Data(data string) ApiCreateOrUpdateBlockedNotificationsRequest {
	r.data = &data
	return r
}

// the account id of the user
func (r ApiCreateOrUpdateBlockedNotificationsRequest) AccountId(accountId int64) ApiCreateOrUpdateBlockedNotificationsRequest {
	r.accountId = &accountId
	return r
}

func (r ApiCreateOrUpdateBlockedNotificationsRequest) Execute() (*BlockedNotificationResponse, *http.Response, error) {
	return r.ApiService.CreateOrUpdateBlockedNotificationsExecute(r)
}

/*
CreateOrUpdateBlockedNotifications Create or update blocked notification settings

Create or update blocked notification settings

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateOrUpdateBlockedNotificationsRequest
*/
func (a *NotificationAPIService) CreateOrUpdateBlockedNotifications(ctx context.Context) ApiCreateOrUpdateBlockedNotificationsRequest {
	return ApiCreateOrUpdateBlockedNotificationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BlockedNotificationResponse
func (a *NotificationAPIService) CreateOrUpdateBlockedNotificationsExecute(r ApiCreateOrUpdateBlockedNotificationsRequest) (*BlockedNotificationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BlockedNotificationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationAPIService.CreateOrUpdateBlockedNotifications")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notification/blocked/batch"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.appKey == nil {
		return localVarReturnValue, nil, reportError("appKey is required and must be specified")
	}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "data", r.data, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteNotificationTemplateRequest struct {
	ctx context.Context
	ApiService *NotificationAPIService
	accountId *int64
	notificationTemplateId *int64
}

// the account id of the user
func (r ApiDeleteNotificationTemplateRequest) AccountId(accountId int64) ApiDeleteNotificationTemplateRequest {
	r.accountId = &accountId
	return r
}

// the id of the notification template to delete
func (r ApiDeleteNotificationTemplateRequest) NotificationTemplateId(notificationTemplateId int64) ApiDeleteNotificationTemplateRequest {
	r.notificationTemplateId = &notificationTemplateId
	return r
}

func (r ApiDeleteNotificationTemplateRequest) Execute() (*NotificationTemplateResponse, *http.Response, error) {
	return r.ApiService.DeleteNotificationTemplateExecute(r)
}

/*
DeleteNotificationTemplate Delete Notification Template

Deletes a notification template. Developers will only be able to delete notification templates for their own applications.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteNotificationTemplateRequest
*/
func (a *NotificationAPIService) DeleteNotificationTemplate(ctx context.Context) ApiDeleteNotificationTemplateRequest {
	return ApiDeleteNotificationTemplateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return NotificationTemplateResponse
func (a *NotificationAPIService) DeleteNotificationTemplateExecute(r ApiDeleteNotificationTemplateRequest) (*NotificationTemplateResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationTemplateResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationAPIService.DeleteNotificationTemplate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notification/template/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.notificationTemplateId == nil {
		return localVarReturnValue, nil, reportError("notificationTemplateId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "notificationTemplateId", r.notificationTemplateId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNotificationTemplateRequest struct {
	ctx context.Context
	ApiService *NotificationAPIService
	accountId *int64
	notificationTemplateId *int64
}

// the id of the account
func (r ApiGetNotificationTemplateRequest) AccountId(accountId int64) ApiGetNotificationTemplateRequest {
	r.accountId = &accountId
	return r
}

// the id of the notification template to get
func (r ApiGetNotificationTemplateRequest) NotificationTemplateId(notificationTemplateId int64) ApiGetNotificationTemplateRequest {
	r.notificationTemplateId = &notificationTemplateId
	return r
}

func (r ApiGetNotificationTemplateRequest) Execute() (*NotificationTemplateResponse, *http.Response, error) {
	return r.ApiService.GetNotificationTemplateExecute(r)
}

/*
GetNotificationTemplate Get Notification Template

Get the details of a notification template. Developers will only be able to see notification templates for their own applications.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetNotificationTemplateRequest
*/
func (a *NotificationAPIService) GetNotificationTemplate(ctx context.Context) ApiGetNotificationTemplateRequest {
	return ApiGetNotificationTemplateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return NotificationTemplateResponse
func (a *NotificationAPIService) GetNotificationTemplateExecute(r ApiGetNotificationTemplateRequest) (*NotificationTemplateResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationTemplateResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationAPIService.GetNotificationTemplate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notification/template/get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.notificationTemplateId == nil {
		return localVarReturnValue, nil, reportError("notificationTemplateId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "notificationTemplateId", r.notificationTemplateId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNotificationsRequest struct {
	ctx context.Context
	ApiService *NotificationAPIService
	deviceId *string
	accountId *int64
	connectionAccountId *int64
	appKey *string
	eventType *string
	contentIds *string
	contentTypes *string
	parentIds *string
	parentTypes *string
	actionCategory *string
	conduits *string
	keyword *string
	returnReadMessages *bool
	markAsRead *bool
	fromDate *int64
	latitude *float64
	longitude *float64
	returnSent *bool
	ignoreFlagged *bool
	start *int32
	limit *int32
}

// the unique id of the device making the request (deviceId or accountId required)
func (r ApiGetNotificationsRequest) DeviceId(deviceId string) ApiGetNotificationsRequest {
	r.deviceId = &deviceId
	return r
}

// the account id of the user (deviceId or accountId required)
func (r ApiGetNotificationsRequest) AccountId(accountId int64) ApiGetNotificationsRequest {
	r.accountId = &accountId
	return r
}

// the account id used to view another person&#39;s notifications
func (r ApiGetNotificationsRequest) ConnectionAccountId(connectionAccountId int64) ApiGetNotificationsRequest {
	r.connectionAccountId = &connectionAccountId
	return r
}

// the application key to filter messages by application
func (r ApiGetNotificationsRequest) AppKey(appKey string) ApiGetNotificationsRequest {
	r.appKey = &appKey
	return r
}

// comma separated list of EVENTS. Filters search results to only include these events. Don&#39;t include this parameter or pass in an empty string to return all event types.
func (r ApiGetNotificationsRequest) EventType(eventType string) ApiGetNotificationsRequest {
	r.eventType = &eventType
	return r
}

// comma separated list of content ids to search notifications on
func (r ApiGetNotificationsRequest) ContentIds(contentIds string) ApiGetNotificationsRequest {
	r.contentIds = &contentIds
	return r
}

// comma separated list of content types to search notifications on
func (r ApiGetNotificationsRequest) ContentTypes(contentTypes string) ApiGetNotificationsRequest {
	r.contentTypes = &contentTypes
	return r
}

// comma separated list of parent ids to search notifications on
func (r ApiGetNotificationsRequest) ParentIds(parentIds string) ApiGetNotificationsRequest {
	r.parentIds = &parentIds
	return r
}

// comma separated list of parent types to search notifications on
func (r ApiGetNotificationsRequest) ParentTypes(parentTypes string) ApiGetNotificationsRequest {
	r.parentTypes = &parentTypes
	return r
}

// Action category used to filter notifications
func (r ApiGetNotificationsRequest) ActionCategory(actionCategory string) ApiGetNotificationsRequest {
	r.actionCategory = &actionCategory
	return r
}

// comma separated list of conduits to search notifications on
func (r ApiGetNotificationsRequest) Conduits(conduits string) ApiGetNotificationsRequest {
	r.conduits = &conduits
	return r
}

// search notifications via keyword
func (r ApiGetNotificationsRequest) Keyword(keyword string) ApiGetNotificationsRequest {
	r.keyword = &keyword
	return r
}

// if set to true, will return notifications that have been marked as read
func (r ApiGetNotificationsRequest) ReturnReadMessages(returnReadMessages bool) ApiGetNotificationsRequest {
	r.returnReadMessages = &returnReadMessages
	return r
}

// if set to true, the returned notifications will be marked as \\\&quot;read\\\&quot; after the response has been sent
func (r ApiGetNotificationsRequest) MarkAsRead(markAsRead bool) ApiGetNotificationsRequest {
	r.markAsRead = &markAsRead
	return r
}

// filter notifications from this date
func (r ApiGetNotificationsRequest) FromDate(fromDate int64) ApiGetNotificationsRequest {
	r.fromDate = &fromDate
	return r
}

// latitude used to update the user&#39;s current location
func (r ApiGetNotificationsRequest) Latitude(latitude float64) ApiGetNotificationsRequest {
	r.latitude = &latitude
	return r
}

// longitude used to update the user&#39;s current location
func (r ApiGetNotificationsRequest) Longitude(longitude float64) ApiGetNotificationsRequest {
	r.longitude = &longitude
	return r
}

// whether to include notifications sent by the requester in the response
func (r ApiGetNotificationsRequest) ReturnSent(returnSent bool) ApiGetNotificationsRequest {
	r.returnSent = &returnSent
	return r
}

// whether to ignore flagged notifications
func (r ApiGetNotificationsRequest) IgnoreFlagged(ignoreFlagged bool) ApiGetNotificationsRequest {
	r.ignoreFlagged = &ignoreFlagged
	return r
}

// start of the pagination
func (r ApiGetNotificationsRequest) Start(start int32) ApiGetNotificationsRequest {
	r.start = &start
	return r
}

// limit of the pagination
func (r ApiGetNotificationsRequest) Limit(limit int32) ApiGetNotificationsRequest {
	r.limit = &limit
	return r
}

func (r ApiGetNotificationsRequest) Execute() (*NotificationMessageListResponse, *http.Response, error) {
	return r.ApiService.GetNotificationsExecute(r)
}

/*
GetNotifications Get Notifications

Get a list of notifications for a user. If the "markAsRead" parameter is set to true, the returned notifications will be marked as "read" after the response has been sent. By default, read messages will not be returned, so to see read messages, set "returnReadMessages" to true.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetNotificationsRequest
*/
func (a *NotificationAPIService) GetNotifications(ctx context.Context) ApiGetNotificationsRequest {
	return ApiGetNotificationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return NotificationMessageListResponse
func (a *NotificationAPIService) GetNotificationsExecute(r ApiGetNotificationsRequest) (*NotificationMessageListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationMessageListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationAPIService.GetNotifications")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notification/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.connectionAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionAccountId", r.connectionAccountId, "form", "")
	}
	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	if r.eventType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "eventType", r.eventType, "form", "")
	}
	if r.contentIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contentIds", r.contentIds, "form", "")
	}
	if r.contentTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contentTypes", r.contentTypes, "form", "")
	}
	if r.parentIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parentIds", r.parentIds, "form", "")
	}
	if r.parentTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parentTypes", r.parentTypes, "form", "")
	}
	if r.actionCategory != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "actionCategory", r.actionCategory, "form", "")
	}
	if r.conduits != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "conduits", r.conduits, "form", "")
	}
	if r.keyword != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyword", r.keyword, "form", "")
	}
	if r.returnReadMessages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnReadMessages", r.returnReadMessages, "form", "")
	}
	if r.markAsRead != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "markAsRead", r.markAsRead, "form", "")
	}
	if r.fromDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromDate", r.fromDate, "form", "")
	}
	if r.latitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latitude", r.latitude, "form", "")
	}
	if r.longitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "longitude", r.longitude, "form", "")
	}
	if r.returnSent != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnSent", r.returnSent, "form", "")
	}
	if r.ignoreFlagged != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignoreFlagged", r.ignoreFlagged, "form", "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRegisterNotificationTokenRequest struct {
	ctx context.Context
	ApiService *NotificationAPIService
	token *string
	pushType *string
	deviceId *string
	accountId *int64
	environment *string
	appKey *string
	gameType *string
	active *bool
	latitude *float64
	longitude *float64
}

// A token that is generated by the device to sign requests for the notification service providers
func (r ApiRegisterNotificationTokenRequest) Token(token string) ApiRegisterNotificationTokenRequest {
	r.token = &token
	return r
}

// The type of push notification. Possible values include: APNS, GCM
func (r ApiRegisterNotificationTokenRequest) PushType(pushType string) ApiRegisterNotificationTokenRequest {
	r.pushType = &pushType
	return r
}

// The unique id of the device making the request (deviceId or accountId required)
func (r ApiRegisterNotificationTokenRequest) DeviceId(deviceId string) ApiRegisterNotificationTokenRequest {
	r.deviceId = &deviceId
	return r
}

// The account id of the user (deviceId or accountId required)
func (r ApiRegisterNotificationTokenRequest) AccountId(accountId int64) ApiRegisterNotificationTokenRequest {
	r.accountId = &accountId
	return r
}

// Determines if the token is a DEVELOPMENT or PRODUCTION token
func (r ApiRegisterNotificationTokenRequest) Environment(environment string) ApiRegisterNotificationTokenRequest {
	r.environment = &environment
	return r
}

// The application key
func (r ApiRegisterNotificationTokenRequest) AppKey(appKey string) ApiRegisterNotificationTokenRequest {
	r.appKey = &appKey
	return r
}

// This parameter is deprecated (use appKey instead)
func (r ApiRegisterNotificationTokenRequest) GameType(gameType string) ApiRegisterNotificationTokenRequest {
	r.gameType = &gameType
	return r
}

// Sets whether the token is active or not (non-active tokens are not used)
func (r ApiRegisterNotificationTokenRequest) Active(active bool) ApiRegisterNotificationTokenRequest {
	r.active = &active
	return r
}

// Latitude used to update the user&#39;s current location
func (r ApiRegisterNotificationTokenRequest) Latitude(latitude float64) ApiRegisterNotificationTokenRequest {
	r.latitude = &latitude
	return r
}

// Longitude used to update the user&#39;s current location
func (r ApiRegisterNotificationTokenRequest) Longitude(longitude float64) ApiRegisterNotificationTokenRequest {
	r.longitude = &longitude
	return r
}

func (r ApiRegisterNotificationTokenRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.RegisterNotificationTokenExecute(r)
}

/*
RegisterNotificationToken Register Notification Token

Register a token to send application dependent notifications like Google Cloud Messaging, or Apple Push Notifications.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRegisterNotificationTokenRequest
*/
func (a *NotificationAPIService) RegisterNotificationToken(ctx context.Context) ApiRegisterNotificationTokenRequest {
	return ApiRegisterNotificationTokenRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *NotificationAPIService) RegisterNotificationTokenExecute(r ApiRegisterNotificationTokenRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationAPIService.RegisterNotificationToken")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notification/token"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.token == nil {
		return localVarReturnValue, nil, reportError("token is required and must be specified")
	}
	if r.pushType == nil {
		return localVarReturnValue, nil, reportError("pushType is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "token", r.token, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "pushType", r.pushType, "form", "")
	if r.environment != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "environment", r.environment, "form", "")
	}
	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	if r.gameType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gameType", r.gameType, "form", "")
	}
	if r.active != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active", r.active, "form", "")
	}
	if r.latitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latitude", r.latitude, "form", "")
	}
	if r.longitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "longitude", r.longitude, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchBlockedNotificationsRequest struct {
	ctx context.Context
	ApiService *NotificationAPIService
	appKey *string
	accountId *int64
	searchTags *string
	events *string
	conduits *string
	customTypes *string
	contentTypes *string
	contentIds *string
	sortField *string
	descending *bool
	start *int32
	limit *int32
}

// The application key
func (r ApiSearchBlockedNotificationsRequest) AppKey(appKey string) ApiSearchBlockedNotificationsRequest {
	r.appKey = &appKey
	return r
}

// the account id of the user
func (r ApiSearchBlockedNotificationsRequest) AccountId(accountId int64) ApiSearchBlockedNotificationsRequest {
	r.accountId = &accountId
	return r
}

// search tags to filter results
func (r ApiSearchBlockedNotificationsRequest) SearchTags(searchTags string) ApiSearchBlockedNotificationsRequest {
	r.searchTags = &searchTags
	return r
}

// events to filter by (comma separated)
func (r ApiSearchBlockedNotificationsRequest) Events(events string) ApiSearchBlockedNotificationsRequest {
	r.events = &events
	return r
}

// conduits to filter by (comma separated)
func (r ApiSearchBlockedNotificationsRequest) Conduits(conduits string) ApiSearchBlockedNotificationsRequest {
	r.conduits = &conduits
	return r
}

// custom types to filter by (comma separated)
func (r ApiSearchBlockedNotificationsRequest) CustomTypes(customTypes string) ApiSearchBlockedNotificationsRequest {
	r.customTypes = &customTypes
	return r
}

// content types to filter by (comma separated)
func (r ApiSearchBlockedNotificationsRequest) ContentTypes(contentTypes string) ApiSearchBlockedNotificationsRequest {
	r.contentTypes = &contentTypes
	return r
}

// content ids to filter by (comma separated)
func (r ApiSearchBlockedNotificationsRequest) ContentIds(contentIds string) ApiSearchBlockedNotificationsRequest {
	r.contentIds = &contentIds
	return r
}

// sort field for results
func (r ApiSearchBlockedNotificationsRequest) SortField(sortField string) ApiSearchBlockedNotificationsRequest {
	r.sortField = &sortField
	return r
}

// whether to sort descending
func (r ApiSearchBlockedNotificationsRequest) Descending(descending bool) ApiSearchBlockedNotificationsRequest {
	r.descending = &descending
	return r
}

// start of the pagination
func (r ApiSearchBlockedNotificationsRequest) Start(start int32) ApiSearchBlockedNotificationsRequest {
	r.start = &start
	return r
}

// limit of the pagination
func (r ApiSearchBlockedNotificationsRequest) Limit(limit int32) ApiSearchBlockedNotificationsRequest {
	r.limit = &limit
	return r
}

func (r ApiSearchBlockedNotificationsRequest) Execute() (*BlockedNotificationResponse, *http.Response, error) {
	return r.ApiService.SearchBlockedNotificationsExecute(r)
}

/*
SearchBlockedNotifications Search on the user's blocked notification settings

Search on the user's blocked notification settings

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchBlockedNotificationsRequest
*/
func (a *NotificationAPIService) SearchBlockedNotifications(ctx context.Context) ApiSearchBlockedNotificationsRequest {
	return ApiSearchBlockedNotificationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BlockedNotificationResponse
func (a *NotificationAPIService) SearchBlockedNotificationsExecute(r ApiSearchBlockedNotificationsRequest) (*BlockedNotificationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BlockedNotificationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationAPIService.SearchBlockedNotifications")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notification/blocked/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.appKey == nil {
		return localVarReturnValue, nil, reportError("appKey is required and must be specified")
	}

	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	if r.searchTags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "searchTags", r.searchTags, "form", "")
	}
	if r.events != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "events", r.events, "form", "")
	}
	if r.conduits != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "conduits", r.conduits, "form", "")
	}
	if r.customTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "customTypes", r.customTypes, "form", "")
	}
	if r.contentTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contentTypes", r.contentTypes, "form", "")
	}
	if r.contentIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contentIds", r.contentIds, "form", "")
	}
	if r.sortField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", r.sortField, "form", "")
	}
	if r.descending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "form", "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchNotificationTemplateRequest struct {
	ctx context.Context
	ApiService *NotificationAPIService
	accountId *int64
	sortField *string
	descending *bool
	start *int32
	limit *int32
	appKey *string
	event *string
	conduit *string
	globalOnly *bool
	reservedOnly *bool
	keyword *string
}

// The account ID of the user.
func (r ApiSearchNotificationTemplateRequest) AccountId(accountId int64) ApiSearchNotificationTemplateRequest {
	r.accountId = &accountId
	return r
}

// Specifies how results are ordered.ID - order results by the notificationTemplateId CREATED - order results by the created date UPDATED - order results by the updated date TITLE - order results by title EVENT - order results by event CONDUIT - order results by conduit APP_NAME - order results by the application name (&#39;global&#39; templates will not have an application and will be returned last if &#39;descending&#39; is set to false.
func (r ApiSearchNotificationTemplateRequest) SortField(sortField string) ApiSearchNotificationTemplateRequest {
	r.sortField = &sortField
	return r
}

// Specified whether the results are returned in descending or ascending order.
func (r ApiSearchNotificationTemplateRequest) Descending(descending bool) ApiSearchNotificationTemplateRequest {
	r.descending = &descending
	return r
}

// The start of the pagination.
func (r ApiSearchNotificationTemplateRequest) Start(start int32) ApiSearchNotificationTemplateRequest {
	r.start = &start
	return r
}

// The limit of the pagination.
func (r ApiSearchNotificationTemplateRequest) Limit(limit int32) ApiSearchNotificationTemplateRequest {
	r.limit = &limit
	return r
}

// Filter results by application.
func (r ApiSearchNotificationTemplateRequest) AppKey(appKey string) ApiSearchNotificationTemplateRequest {
	r.appKey = &appKey
	return r
}

// Filter results by event.
func (r ApiSearchNotificationTemplateRequest) Event(event string) ApiSearchNotificationTemplateRequest {
	r.event = &event
	return r
}

// Filter results by notification type: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.
func (r ApiSearchNotificationTemplateRequest) Conduit(conduit string) ApiSearchNotificationTemplateRequest {
	r.conduit = &conduit
	return r
}

// Returns only templates that have been reserved for system use on all applications (only for admin accounts).
func (r ApiSearchNotificationTemplateRequest) GlobalOnly(globalOnly bool) ApiSearchNotificationTemplateRequest {
	r.globalOnly = &globalOnly
	return r
}

// Returns only templates that use reserved events.
func (r ApiSearchNotificationTemplateRequest) ReservedOnly(reservedOnly bool) ApiSearchNotificationTemplateRequest {
	r.reservedOnly = &reservedOnly
	return r
}

// Filter results by keyword on the title, tags.
func (r ApiSearchNotificationTemplateRequest) Keyword(keyword string) ApiSearchNotificationTemplateRequest {
	r.keyword = &keyword
	return r
}

func (r ApiSearchNotificationTemplateRequest) Execute() (*NotificationTemplateResponse, *http.Response, error) {
	return r.ApiService.SearchNotificationTemplateExecute(r)
}

/*
SearchNotificationTemplate Search Notification Templates

Search for notification templates on owned applications.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchNotificationTemplateRequest
*/
func (a *NotificationAPIService) SearchNotificationTemplate(ctx context.Context) ApiSearchNotificationTemplateRequest {
	return ApiSearchNotificationTemplateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return NotificationTemplateResponse
func (a *NotificationAPIService) SearchNotificationTemplateExecute(r ApiSearchNotificationTemplateRequest) (*NotificationTemplateResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationTemplateResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationAPIService.SearchNotificationTemplate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notification/template/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.sortField == nil {
		return localVarReturnValue, nil, reportError("sortField is required and must be specified")
	}
	if r.descending == nil {
		return localVarReturnValue, nil, reportError("descending is required and must be specified")
	}
	if r.start == nil {
		return localVarReturnValue, nil, reportError("start is required and must be specified")
	}
	if r.limit == nil {
		return localVarReturnValue, nil, reportError("limit is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	if r.event != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "event", r.event, "form", "")
	}
	if r.conduit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "conduit", r.conduit, "form", "")
	}
	if r.globalOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "globalOnly", r.globalOnly, "form", "")
	}
	if r.reservedOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservedOnly", r.reservedOnly, "form", "")
	}
	if r.keyword != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyword", r.keyword, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", r.sortField, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchRecipientsRequest struct {
	ctx context.Context
	ApiService *NotificationAPIService
	sortField *string
	deviceId *string
	accountId *int64
	appKey *string
	conduit *string
	keyword *string
	audienceId *int64
	audienceIds *string
	connectionGroupIds *string
	recipientAccountIds *string
	descending *bool
	start *int32
	limit *int32
}

// The field to sort by. Possible values include: {ACCOUNT_DISPLAY, CREATED, UPDATED, ACTIVE, DELETED, LAST_LOGGED_IN, CONTACT_EMAIL, RETAILER_LOCATION_NAME, RETAILER_NAME, APPLICATION_NAME}
func (r ApiSearchRecipientsRequest) SortField(sortField string) ApiSearchRecipientsRequest {
	r.sortField = &sortField
	return r
}

// the unique id of the device making the request (deviceId or accountId required)
func (r ApiSearchRecipientsRequest) DeviceId(deviceId string) ApiSearchRecipientsRequest {
	r.deviceId = &deviceId
	return r
}

// the account id of the user (deviceId or accountId required)
func (r ApiSearchRecipientsRequest) AccountId(accountId int64) ApiSearchRecipientsRequest {
	r.accountId = &accountId
	return r
}

// filters results by application. If this is empty, will return all recipients for all applications that the user has access to.
func (r ApiSearchRecipientsRequest) AppKey(appKey string) ApiSearchRecipientsRequest {
	r.appKey = &appKey
	return r
}

// the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.
func (r ApiSearchRecipientsRequest) Conduit(conduit string) ApiSearchRecipientsRequest {
	r.conduit = &conduit
	return r
}

// search by keyword on user&#39;s display name and email
func (r ApiSearchRecipientsRequest) Keyword(keyword string) ApiSearchRecipientsRequest {
	r.keyword = &keyword
	return r
}

// This parameter is deprecated. filter results by audience
func (r ApiSearchRecipientsRequest) AudienceId(audienceId int64) ApiSearchRecipientsRequest {
	r.audienceId = &audienceId
	return r
}

// filter results by audiences (comma separated list of audience ids)
func (r ApiSearchRecipientsRequest) AudienceIds(audienceIds string) ApiSearchRecipientsRequest {
	r.audienceIds = &audienceIds
	return r
}

// filter results by connection groups (comma separated list of connection group ids)
func (r ApiSearchRecipientsRequest) ConnectionGroupIds(connectionGroupIds string) ApiSearchRecipientsRequest {
	r.connectionGroupIds = &connectionGroupIds
	return r
}

// filter results by accounts (comma separated list of account ids)
func (r ApiSearchRecipientsRequest) RecipientAccountIds(recipientAccountIds string) ApiSearchRecipientsRequest {
	r.recipientAccountIds = &recipientAccountIds
	return r
}

// Determines whether the sorted list is in descending or ascending order
func (r ApiSearchRecipientsRequest) Descending(descending bool) ApiSearchRecipientsRequest {
	r.descending = &descending
	return r
}

// start of the pagination
func (r ApiSearchRecipientsRequest) Start(start int32) ApiSearchRecipientsRequest {
	r.start = &start
	return r
}

// limit of the pagination (hard limit of 1000)
func (r ApiSearchRecipientsRequest) Limit(limit int32) ApiSearchRecipientsRequest {
	r.limit = &limit
	return r
}

func (r ApiSearchRecipientsRequest) Execute() ([]NotificationRecipientResponse, *http.Response, error) {
	return r.ApiService.SearchRecipientsExecute(r)
}

/*
SearchRecipients Search for Recipients

Search for application users to send notifications.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchRecipientsRequest
*/
func (a *NotificationAPIService) SearchRecipients(ctx context.Context) ApiSearchRecipientsRequest {
	return ApiSearchRecipientsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []NotificationRecipientResponse
func (a *NotificationAPIService) SearchRecipientsExecute(r ApiSearchRecipientsRequest) ([]NotificationRecipientResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []NotificationRecipientResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationAPIService.SearchRecipients")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notification/recipient/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sortField == nil {
		return localVarReturnValue, nil, reportError("sortField is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	if r.conduit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "conduit", r.conduit, "form", "")
	}
	if r.keyword != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyword", r.keyword, "form", "")
	}
	if r.audienceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audienceId", r.audienceId, "form", "")
	}
	if r.audienceIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audienceIds", r.audienceIds, "form", "")
	}
	if r.connectionGroupIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionGroupIds", r.connectionGroupIds, "form", "")
	}
	if r.recipientAccountIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recipientAccountIds", r.recipientAccountIds, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", r.sortField, "form", "")
	if r.descending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "form", "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchRecipientsCountRequest struct {
	ctx context.Context
	ApiService *NotificationAPIService
	deviceId *string
	accountId *int64
	appKey *string
	conduit *string
	keyword *string
	audienceId *int64
	audienceIds *string
	connectionGroupIds *string
	sortField *string
	descending *bool
	start *int32
	limit *int32
}

// the unique id of the device making the request (deviceId or accountId required)
func (r ApiSearchRecipientsCountRequest) DeviceId(deviceId string) ApiSearchRecipientsCountRequest {
	r.deviceId = &deviceId
	return r
}

// the account id of the user (deviceId or accountId required)
func (r ApiSearchRecipientsCountRequest) AccountId(accountId int64) ApiSearchRecipientsCountRequest {
	r.accountId = &accountId
	return r
}

// filters results by application. If this is empty, will return all recipients for all applications that the user has access to.
func (r ApiSearchRecipientsCountRequest) AppKey(appKey string) ApiSearchRecipientsCountRequest {
	r.appKey = &appKey
	return r
}

// the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.
func (r ApiSearchRecipientsCountRequest) Conduit(conduit string) ApiSearchRecipientsCountRequest {
	r.conduit = &conduit
	return r
}

// search by keyword on user&#39;s display name and email
func (r ApiSearchRecipientsCountRequest) Keyword(keyword string) ApiSearchRecipientsCountRequest {
	r.keyword = &keyword
	return r
}

// This parameter is deprecated. filter results by audience
func (r ApiSearchRecipientsCountRequest) AudienceId(audienceId int64) ApiSearchRecipientsCountRequest {
	r.audienceId = &audienceId
	return r
}

// filter results by audiences (comma separated list of audience ids)
func (r ApiSearchRecipientsCountRequest) AudienceIds(audienceIds string) ApiSearchRecipientsCountRequest {
	r.audienceIds = &audienceIds
	return r
}

// filter results by connection groups (comma separated list of connection group ids)
func (r ApiSearchRecipientsCountRequest) ConnectionGroupIds(connectionGroupIds string) ApiSearchRecipientsCountRequest {
	r.connectionGroupIds = &connectionGroupIds
	return r
}

// The field to sort by (see API docs for allowed values).
func (r ApiSearchRecipientsCountRequest) SortField(sortField string) ApiSearchRecipientsCountRequest {
	r.sortField = &sortField
	return r
}

// Determines whether the sorted list is in descending or ascending order
func (r ApiSearchRecipientsCountRequest) Descending(descending bool) ApiSearchRecipientsCountRequest {
	r.descending = &descending
	return r
}

// start of the pagination
func (r ApiSearchRecipientsCountRequest) Start(start int32) ApiSearchRecipientsCountRequest {
	r.start = &start
	return r
}

// limit of the pagination
func (r ApiSearchRecipientsCountRequest) Limit(limit int32) ApiSearchRecipientsCountRequest {
	r.limit = &limit
	return r
}

func (r ApiSearchRecipientsCountRequest) Execute() (*NotificationRecipientResponseListResponse, *http.Response, error) {
	return r.ApiService.SearchRecipientsCountExecute(r)
}

/*
SearchRecipientsCount Search for Recipients (Counts/Grouped)

Search for application users to send notifications (count/grouped variant).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchRecipientsCountRequest
*/
func (a *NotificationAPIService) SearchRecipientsCount(ctx context.Context) ApiSearchRecipientsCountRequest {
	return ApiSearchRecipientsCountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return NotificationRecipientResponseListResponse
func (a *NotificationAPIService) SearchRecipientsCountExecute(r ApiSearchRecipientsCountRequest) (*NotificationRecipientResponseListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationRecipientResponseListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationAPIService.SearchRecipientsCount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notification/recipient/search/count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	if r.conduit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "conduit", r.conduit, "form", "")
	}
	if r.keyword != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyword", r.keyword, "form", "")
	}
	if r.audienceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audienceId", r.audienceId, "form", "")
	}
	if r.audienceIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audienceIds", r.audienceIds, "form", "")
	}
	if r.connectionGroupIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionGroupIds", r.connectionGroupIds, "form", "")
	}
	if r.sortField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", r.sortField, "form", "")
	}
	if r.descending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "form", "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSendBatchNotificationsRequest struct {
	ctx context.Context
	ApiService *NotificationAPIService
	accountId *int64
	appKey *string
	customMessage *string
	conduit *string
	contentId *int64
	contentName *string
	contentType *string
	parentId *int64
	parentType *string
}

// The account id of the application owner/manager
func (r ApiSendBatchNotificationsRequest) AccountId(accountId int64) ApiSendBatchNotificationsRequest {
	r.accountId = &accountId
	return r
}

// The application key for updating an existing application
func (r ApiSendBatchNotificationsRequest) AppKey(appKey string) ApiSendBatchNotificationsRequest {
	r.appKey = &appKey
	return r
}

// Message string that will be displayed in on the notification
func (r ApiSendBatchNotificationsRequest) CustomMessage(customMessage string) ApiSendBatchNotificationsRequest {
	r.customMessage = &customMessage
	return r
}

// The type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.
func (r ApiSendBatchNotificationsRequest) Conduit(conduit string) ApiSendBatchNotificationsRequest {
	r.conduit = &conduit
	return r
}

// Default notification pay-load field (usage is dependent on the app and the type of event)
func (r ApiSendBatchNotificationsRequest) ContentId(contentId int64) ApiSendBatchNotificationsRequest {
	r.contentId = &contentId
	return r
}

// Default notification pay-load field (usage is dependent on the app and the type of event)
func (r ApiSendBatchNotificationsRequest) ContentName(contentName string) ApiSendBatchNotificationsRequest {
	r.contentName = &contentName
	return r
}

// Default notification pay-load field (usage is dependent on the app and the type of event)
func (r ApiSendBatchNotificationsRequest) ContentType(contentType string) ApiSendBatchNotificationsRequest {
	r.contentType = &contentType
	return r
}

// Default notification pay-load field (usage is dependent on the app and the type of event)
func (r ApiSendBatchNotificationsRequest) ParentId(parentId int64) ApiSendBatchNotificationsRequest {
	r.parentId = &parentId
	return r
}

// Default notification pay-load field (usage is dependent on the app and the type of event)
func (r ApiSendBatchNotificationsRequest) ParentType(parentType string) ApiSendBatchNotificationsRequest {
	r.parentType = &parentType
	return r
}

func (r ApiSendBatchNotificationsRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.SendBatchNotificationsExecute(r)
}

/*
SendBatchNotifications Send Batch Notifications

Send notifications to all users of an application. Only someone with permissions to the application can do this.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSendBatchNotificationsRequest
*/
func (a *NotificationAPIService) SendBatchNotifications(ctx context.Context) ApiSendBatchNotificationsRequest {
	return ApiSendBatchNotificationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *NotificationAPIService) SendBatchNotificationsExecute(r ApiSendBatchNotificationsRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationAPIService.SendBatchNotifications")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notification/batch"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.appKey == nil {
		return localVarReturnValue, nil, reportError("appKey is required and must be specified")
	}
	if r.customMessage == nil {
		return localVarReturnValue, nil, reportError("customMessage is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	if r.conduit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "conduit", r.conduit, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "customMessage", r.customMessage, "form", "")
	if r.contentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contentId", r.contentId, "form", "")
	}
	if r.contentName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contentName", r.contentName, "form", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contentType", r.contentType, "form", "")
	}
	if r.parentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parentId", r.parentId, "form", "")
	}
	if r.parentType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parentType", r.parentType, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSendCustomNotificationsRequest struct {
	ctx context.Context
	ApiService *NotificationAPIService
	deviceId *string
	accountId *int64
	receiverAccountIds *string
	includeFriendGroup *bool
	appKey *string
	gameType *string
	conduit *string
	contentId *int64
	contentName *string
	contentType *string
	parentId *int64
	parentType *string
	actionCategory *string
	subject *string
	customMessage *string
	friendOnlyAPNS *bool
	latitude *float64
	longitude *float64
}

// the unique id of the device making the request (deviceId or accountId required)
func (r ApiSendCustomNotificationsRequest) DeviceId(deviceId string) ApiSendCustomNotificationsRequest {
	r.deviceId = &deviceId
	return r
}

// the account id of the user (deviceId or accountId required)
func (r ApiSendCustomNotificationsRequest) AccountId(accountId int64) ApiSendCustomNotificationsRequest {
	r.accountId = &accountId
	return r
}

// comma separated list of account IDs that will receive the notification
func (r ApiSendCustomNotificationsRequest) ReceiverAccountIds(receiverAccountIds string) ApiSendCustomNotificationsRequest {
	r.receiverAccountIds = &receiverAccountIds
	return r
}

// determines whether to send to all of the user&#39;s friends, this flag must be true or receiverAccountIds must not be empty
func (r ApiSendCustomNotificationsRequest) IncludeFriendGroup(includeFriendGroup bool) ApiSendCustomNotificationsRequest {
	r.includeFriendGroup = &includeFriendGroup
	return r
}

// the application key
func (r ApiSendCustomNotificationsRequest) AppKey(appKey string) ApiSendCustomNotificationsRequest {
	r.appKey = &appKey
	return r
}

// This parameter is deprecated.
func (r ApiSendCustomNotificationsRequest) GameType(gameType string) ApiSendCustomNotificationsRequest {
	r.gameType = &gameType
	return r
}

// the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.
func (r ApiSendCustomNotificationsRequest) Conduit(conduit string) ApiSendCustomNotificationsRequest {
	r.conduit = &conduit
	return r
}

// default notification pay-load field (usage is dependent on the app and the type of event)
func (r ApiSendCustomNotificationsRequest) ContentId(contentId int64) ApiSendCustomNotificationsRequest {
	r.contentId = &contentId
	return r
}

// default notification pay-load field (usage is dependent on the app and the type of event)
func (r ApiSendCustomNotificationsRequest) ContentName(contentName string) ApiSendCustomNotificationsRequest {
	r.contentName = &contentName
	return r
}

// default notification pay-load field (usage is dependent on the app and the type of event)
func (r ApiSendCustomNotificationsRequest) ContentType(contentType string) ApiSendCustomNotificationsRequest {
	r.contentType = &contentType
	return r
}

// default notification pay-load field (usage is dependent on the app and the type of event)
func (r ApiSendCustomNotificationsRequest) ParentId(parentId int64) ApiSendCustomNotificationsRequest {
	r.parentId = &parentId
	return r
}

// default notification pay-load field (usage is dependent on the app and the type of event)
func (r ApiSendCustomNotificationsRequest) ParentType(parentType string) ApiSendCustomNotificationsRequest {
	r.parentType = &parentType
	return r
}

// 
func (r ApiSendCustomNotificationsRequest) ActionCategory(actionCategory string) ApiSendCustomNotificationsRequest {
	r.actionCategory = &actionCategory
	return r
}

// the subject line of an email #@param customPayload custom json definition of notification pay-load (usage is dependent on the app and the type of event)
func (r ApiSendCustomNotificationsRequest) Subject(subject string) ApiSendCustomNotificationsRequest {
	r.subject = &subject
	return r
}

// message string that will be displayed in on the notification
func (r ApiSendCustomNotificationsRequest) CustomMessage(customMessage string) ApiSendCustomNotificationsRequest {
	r.customMessage = &customMessage
	return r
}

// only sends APNS to people who are friends of the user (still saves the notification message for feed polling)
func (r ApiSendCustomNotificationsRequest) FriendOnlyAPNS(friendOnlyAPNS bool) ApiSendCustomNotificationsRequest {
	r.friendOnlyAPNS = &friendOnlyAPNS
	return r
}

// latitude used to update the user&#39;s current location
func (r ApiSendCustomNotificationsRequest) Latitude(latitude float64) ApiSendCustomNotificationsRequest {
	r.latitude = &latitude
	return r
}

// longitude used to update the user&#39;s current location
func (r ApiSendCustomNotificationsRequest) Longitude(longitude float64) ApiSendCustomNotificationsRequest {
	r.longitude = &longitude
	return r
}

func (r ApiSendCustomNotificationsRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.SendCustomNotificationsExecute(r)
}

/*
SendCustomNotifications Send Custom Notifications

Send your own custom notification to a user. NOTE: the EventType of these notifications will be CUSTOM. Notifications sent to yourself will currently be ignored.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSendCustomNotificationsRequest
*/
func (a *NotificationAPIService) SendCustomNotifications(ctx context.Context) ApiSendCustomNotificationsRequest {
	return ApiSendCustomNotificationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *NotificationAPIService) SendCustomNotificationsExecute(r ApiSendCustomNotificationsRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationAPIService.SendCustomNotifications")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notification/custom"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.receiverAccountIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "receiverAccountIds", r.receiverAccountIds, "form", "")
	}
	if r.includeFriendGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeFriendGroup", r.includeFriendGroup, "form", "")
	}
	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	if r.gameType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gameType", r.gameType, "form", "")
	}
	if r.conduit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "conduit", r.conduit, "form", "")
	}
	if r.contentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contentId", r.contentId, "form", "")
	}
	if r.contentName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contentName", r.contentName, "form", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contentType", r.contentType, "form", "")
	}
	if r.parentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parentId", r.parentId, "form", "")
	}
	if r.parentType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parentType", r.parentType, "form", "")
	}
	if r.actionCategory != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "actionCategory", r.actionCategory, "form", "")
	}
	if r.subject != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subject", r.subject, "form", "")
	}
	if r.customMessage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "customMessage", r.customMessage, "form", "")
	}
	if r.friendOnlyAPNS != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "friendOnlyAPNS", r.friendOnlyAPNS, "form", "")
	}
	if r.latitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latitude", r.latitude, "form", "")
	}
	if r.longitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "longitude", r.longitude, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateNotificationTemplateRequest struct {
	ctx context.Context
	ApiService *NotificationAPIService
	accountId *int64
	notificationTemplateId *int64
	title *string
	body *string
	tags *string
}

// The account ID of the user.
func (r ApiUpdateNotificationTemplateRequest) AccountId(accountId int64) ApiUpdateNotificationTemplateRequest {
	r.accountId = &accountId
	return r
}

// The notification template ID to update.
func (r ApiUpdateNotificationTemplateRequest) NotificationTemplateId(notificationTemplateId int64) ApiUpdateNotificationTemplateRequest {
	r.notificationTemplateId = &notificationTemplateId
	return r
}

// The title of the message (this would become the subject title for emails). There is a 191 character limit.
func (r ApiUpdateNotificationTemplateRequest) Title(title string) ApiUpdateNotificationTemplateRequest {
	r.title = &title
	return r
}

// The body of the message.
func (r ApiUpdateNotificationTemplateRequest) Body(body string) ApiUpdateNotificationTemplateRequest {
	r.body = &body
	return r
}

// The search tags on the template used during search queries.
func (r ApiUpdateNotificationTemplateRequest) Tags(tags string) ApiUpdateNotificationTemplateRequest {
	r.tags = &tags
	return r
}

func (r ApiUpdateNotificationTemplateRequest) Execute() (*NotificationTemplateResponse, *http.Response, error) {
	return r.ApiService.UpdateNotificationTemplateExecute(r)
}

/*
UpdateNotificationTemplate Update Notification Template

Update a notification template. Developers will only be able to update notification templates for their own applications.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateNotificationTemplateRequest
*/
func (a *NotificationAPIService) UpdateNotificationTemplate(ctx context.Context) ApiUpdateNotificationTemplateRequest {
	return ApiUpdateNotificationTemplateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return NotificationTemplateResponse
func (a *NotificationAPIService) UpdateNotificationTemplateExecute(r ApiUpdateNotificationTemplateRequest) (*NotificationTemplateResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationTemplateResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationAPIService.UpdateNotificationTemplate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notification/template/update"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.notificationTemplateId == nil {
		return localVarReturnValue, nil, reportError("notificationTemplateId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "notificationTemplateId", r.notificationTemplateId, "form", "")
	if r.title != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "title", r.title, "form", "")
	}
	if r.body != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "body", r.body, "form", "")
	}
	if r.tags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tags", r.tags, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
