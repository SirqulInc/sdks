/*
Sirqul IoT Platform

Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

API version: 3.16
Contact: info@sirqul.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// FilterAPIService FilterAPI service
type FilterAPIService service

type ApiCreateFilterRequest struct {
	ctx context.Context
	ApiService *FilterAPIService
	accountId *int64
	name *string
	appKey *string
	parentFilterId *int64
	description *string
	externalId *string
	externalType *string
	active *bool
	metaData *string
}

// The account id of the user (must have permissions to the target application)
func (r ApiCreateFilterRequest) AccountId(accountId int64) ApiCreateFilterRequest {
	r.accountId = &accountId
	return r
}

// The name of the filter
func (r ApiCreateFilterRequest) Name(name string) ApiCreateFilterRequest {
	r.name = &name
	return r
}

// The appKey of the application to assign the filter to, if not provided then the filter will be applied to the global application (if the account has permissions)
func (r ApiCreateFilterRequest) AppKey(appKey string) ApiCreateFilterRequest {
	r.appKey = &appKey
	return r
}

// The ID of the parent filter, if not provided then the parent filter will be null
func (r ApiCreateFilterRequest) ParentFilterId(parentFilterId int64) ApiCreateFilterRequest {
	r.parentFilterId = &parentFilterId
	return r
}

// The description of the filter
func (r ApiCreateFilterRequest) Description(description string) ApiCreateFilterRequest {
	r.description = &description
	return r
}

// A string identifier used by client applications to store external information
func (r ApiCreateFilterRequest) ExternalId(externalId string) ApiCreateFilterRequest {
	r.externalId = &externalId
	return r
}

// A string type used by client applications to store external information
func (r ApiCreateFilterRequest) ExternalType(externalType string) ApiCreateFilterRequest {
	r.externalType = &externalType
	return r
}

// Sets whether the filter is active or inactive (hidden from consumers)
func (r ApiCreateFilterRequest) Active(active bool) ApiCreateFilterRequest {
	r.active = &active
	return r
}

// external custom client defined data
func (r ApiCreateFilterRequest) MetaData(metaData string) ApiCreateFilterRequest {
	r.metaData = &metaData
	return r
}

func (r ApiCreateFilterRequest) Execute() (*FilterTreeResponse, *http.Response, error) {
	return r.ApiService.CreateFilterExecute(r)
}

/*
CreateFilter Create Filter

Create a filter

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateFilterRequest
*/
func (a *FilterAPIService) CreateFilter(ctx context.Context) ApiCreateFilterRequest {
	return ApiCreateFilterRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FilterTreeResponse
func (a *FilterAPIService) CreateFilterExecute(r ApiCreateFilterRequest) (*FilterTreeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FilterTreeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilterAPIService.CreateFilter")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/filter/create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.name == nil {
		return localVarReturnValue, nil, reportError("name is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	if r.parentFilterId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parentFilterId", r.parentFilterId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "form", "")
	}
	if r.externalId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "externalId", r.externalId, "form", "")
	}
	if r.externalType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "externalType", r.externalType, "form", "")
	}
	if r.active != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active", r.active, "form", "")
	}
	if r.metaData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metaData", r.metaData, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteFilterRequest struct {
	ctx context.Context
	ApiService *FilterAPIService
	accountId *int64
	filterId *int64
}

// The account id of the user (must have permissions to the filter&#39;s assigned application)
func (r ApiDeleteFilterRequest) AccountId(accountId int64) ApiDeleteFilterRequest {
	r.accountId = &accountId
	return r
}

// The ID of the filter to delete
func (r ApiDeleteFilterRequest) FilterId(filterId int64) ApiDeleteFilterRequest {
	r.filterId = &filterId
	return r
}

func (r ApiDeleteFilterRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.DeleteFilterExecute(r)
}

/*
DeleteFilter Delete Filter

Delete a filter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteFilterRequest
*/
func (a *FilterAPIService) DeleteFilter(ctx context.Context) ApiDeleteFilterRequest {
	return ApiDeleteFilterRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *FilterAPIService) DeleteFilterExecute(r ApiDeleteFilterRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilterAPIService.DeleteFilter")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/filter/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.filterId == nil {
		return localVarReturnValue, nil, reportError("filterId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "filterId", r.filterId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFilterRequest struct {
	ctx context.Context
	ApiService *FilterAPIService
	filterId *int64
}

// the id of the filter to get
func (r ApiGetFilterRequest) FilterId(filterId int64) ApiGetFilterRequest {
	r.filterId = &filterId
	return r
}

func (r ApiGetFilterRequest) Execute() (*FilterTreeResponse, *http.Response, error) {
	return r.ApiService.GetFilterExecute(r)
}

/*
GetFilter Get Filter

Get the details of a specific filter. Recursively include all child filters and their children.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetFilterRequest
*/
func (a *FilterAPIService) GetFilter(ctx context.Context) ApiGetFilterRequest {
	return ApiGetFilterRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FilterTreeResponse
func (a *FilterAPIService) GetFilterExecute(r ApiGetFilterRequest) (*FilterTreeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FilterTreeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilterAPIService.GetFilter")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/filter/get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.filterId == nil {
		return localVarReturnValue, nil, reportError("filterId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "filterId", r.filterId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchFiltersRequest struct {
	ctx context.Context
	ApiService *FilterAPIService
	accountId *int64
	keyword *string
	appKey *string
	responseGroup *string
	rootOnly *bool
	sortField *string
	descending *bool
	start *int32
	limit *int32
	activeOnly *bool
}

// The account id of the user
func (r ApiSearchFiltersRequest) AccountId(accountId int64) ApiSearchFiltersRequest {
	r.accountId = &accountId
	return r
}

// The string to search on
func (r ApiSearchFiltersRequest) Keyword(keyword string) ApiSearchFiltersRequest {
	r.keyword = &keyword
	return r
}

// the appKey of the application to retrieve filters for
func (r ApiSearchFiltersRequest) AppKey(appKey string) ApiSearchFiltersRequest {
	r.appKey = &appKey
	return r
}

// The group of filters to return: ALL, GLOBAL or MINE. ALL returns both global and application specific matches, GLOBAL only returns global matches, and MINE only returns the application specific matches. If not provided search on the application provided.
func (r ApiSearchFiltersRequest) ResponseGroup(responseGroup string) ApiSearchFiltersRequest {
	r.responseGroup = &responseGroup
	return r
}

// Restrict the search to only those filters with no parent filter assigned.
func (r ApiSearchFiltersRequest) RootOnly(rootOnly bool) ApiSearchFiltersRequest {
	r.rootOnly = &rootOnly
	return r
}

// The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, DISPLAY
func (r ApiSearchFiltersRequest) SortField(sortField string) ApiSearchFiltersRequest {
	r.sortField = &sortField
	return r
}

// The order to return the search results
func (r ApiSearchFiltersRequest) Descending(descending bool) ApiSearchFiltersRequest {
	r.descending = &descending
	return r
}

// The record to begin the return set on
func (r ApiSearchFiltersRequest) Start(start int32) ApiSearchFiltersRequest {
	r.start = &start
	return r
}

// The number of records to return
func (r ApiSearchFiltersRequest) Limit(limit int32) ApiSearchFiltersRequest {
	r.limit = &limit
	return r
}

// Determines whether to return only active categories
func (r ApiSearchFiltersRequest) ActiveOnly(activeOnly bool) ApiSearchFiltersRequest {
	r.activeOnly = &activeOnly
	return r
}

func (r ApiSearchFiltersRequest) Execute() ([]FilterResponse, *http.Response, error) {
	return r.ApiService.SearchFiltersExecute(r)
}

/*
SearchFilters Search Filters

Search for filters.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchFiltersRequest
*/
func (a *FilterAPIService) SearchFilters(ctx context.Context) ApiSearchFiltersRequest {
	return ApiSearchFiltersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []FilterResponse
func (a *FilterAPIService) SearchFiltersExecute(r ApiSearchFiltersRequest) ([]FilterResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []FilterResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilterAPIService.SearchFilters")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/filter/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.keyword != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyword", r.keyword, "form", "")
	}
	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	if r.responseGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "responseGroup", r.responseGroup, "form", "")
	}
	if r.rootOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootOnly", r.rootOnly, "form", "")
	}
	if r.sortField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", r.sortField, "form", "")
	} else {
		var defaultValue string = "DISPLAY"
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", defaultValue, "form", "")
		r.sortField = &defaultValue
	}
	if r.descending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", defaultValue, "form", "")
		r.descending = &defaultValue
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	} else {
		var defaultValue int32 = 0
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", defaultValue, "form", "")
		r.start = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 20
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	if r.activeOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activeOnly", r.activeOnly, "form", "")
	} else {
		var defaultValue bool = true
		parameterAddToHeaderOrQuery(localVarQueryParams, "activeOnly", defaultValue, "form", "")
		r.activeOnly = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateFilterRequest struct {
	ctx context.Context
	ApiService *FilterAPIService
	accountId *int64
	filterId *int64
	parentFilterId *int64
	name *string
	description *string
	externalId *string
	externalType *string
	active *bool
	metaData *string
}

// The account id of the user
func (r ApiUpdateFilterRequest) AccountId(accountId int64) ApiUpdateFilterRequest {
	r.accountId = &accountId
	return r
}

// The ID of the filter to edit
func (r ApiUpdateFilterRequest) FilterId(filterId int64) ApiUpdateFilterRequest {
	r.filterId = &filterId
	return r
}

// The ID of the parent filter, if not provided then the parent filter will be null
func (r ApiUpdateFilterRequest) ParentFilterId(parentFilterId int64) ApiUpdateFilterRequest {
	r.parentFilterId = &parentFilterId
	return r
}

// The name of the filter
func (r ApiUpdateFilterRequest) Name(name string) ApiUpdateFilterRequest {
	r.name = &name
	return r
}

// The description of the filter
func (r ApiUpdateFilterRequest) Description(description string) ApiUpdateFilterRequest {
	r.description = &description
	return r
}

// A string identifier used by client applications to store external information
func (r ApiUpdateFilterRequest) ExternalId(externalId string) ApiUpdateFilterRequest {
	r.externalId = &externalId
	return r
}

// A string type used by client applications to store external information
func (r ApiUpdateFilterRequest) ExternalType(externalType string) ApiUpdateFilterRequest {
	r.externalType = &externalType
	return r
}

// Sets whether the filter is active or inactive (hidden from consumers)
func (r ApiUpdateFilterRequest) Active(active bool) ApiUpdateFilterRequest {
	r.active = &active
	return r
}

// external custom client defined data
func (r ApiUpdateFilterRequest) MetaData(metaData string) ApiUpdateFilterRequest {
	r.metaData = &metaData
	return r
}

func (r ApiUpdateFilterRequest) Execute() (*FilterTreeResponse, *http.Response, error) {
	return r.ApiService.UpdateFilterExecute(r)
}

/*
UpdateFilter Update Filter

Update a filter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateFilterRequest
*/
func (a *FilterAPIService) UpdateFilter(ctx context.Context) ApiUpdateFilterRequest {
	return ApiUpdateFilterRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FilterTreeResponse
func (a *FilterAPIService) UpdateFilterExecute(r ApiUpdateFilterRequest) (*FilterTreeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FilterTreeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilterAPIService.UpdateFilter")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/filter/update"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.filterId == nil {
		return localVarReturnValue, nil, reportError("filterId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "filterId", r.filterId, "form", "")
	if r.parentFilterId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parentFilterId", r.parentFilterId, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "form", "")
	}
	if r.externalId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "externalId", r.externalId, "form", "")
	}
	if r.externalType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "externalType", r.externalType, "form", "")
	}
	if r.active != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active", r.active, "form", "")
	}
	if r.metaData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metaData", r.metaData, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
