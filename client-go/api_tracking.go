/*
Sirqul IoT Platform

Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

API version: 3.16
Contact: info@sirqul.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// TrackingAPIService TrackingAPI service
type TrackingAPIService service

type ApiBatchSaveTrackingRequest struct {
	ctx context.Context
	ApiService *TrackingAPIService
	data *string
	deviceId *string
	accountId *int64
	generateAccounts *bool
	updateAccountLocations *bool
	defaultTag *string
	slaveUID *string
}

// JSON array of tracking legs &#x60;&#x60;&#x60;json [   \&quot;distance\&quot;: \&quot;0.08\&quot;,   \&quot;duration\&quot;: \&quot;10000\&quot;,   \&quot;startLatitude\&quot;: \&quot;47.614603\&quot;,   \&quot;startLongitude\&quot;: \&quot;-122.350518\&quot;,   \&quot;endLatitude\&quot;: \&quot;47.614384\&quot;,   \&quot;endLongitude\&quot;: \&quot;-122.349161\&quot;,   \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,   \&quot;endDate\&quot;: \&quot;1361924020000\&quot;,   \&quot;steps\&quot;: [     {       \&quot;distance\&quot;: \&quot;0.03\&quot;,       \&quot;duration\&quot;: \&quot;5000\&quot;,       \&quot;startLat\&quot;: \&quot;47.614603\&quot;,       \&quot;startLng\&quot;: \&quot;-122.350518\&quot;,       \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,       \&quot;endLat\&quot;: \&quot;47.614941\&quot;,       \&quot;endLng\&quot;: \&quot;-122.350062\&quot;,       \&quot;endDate\&quot;: \&quot;1361924015000\&quot;     },{       \&quot;distance\&quot;: \&quot;0.05\&quot;,       \&quot;duration\&quot;: \&quot;5000\&quot;,       \&quot;startLat\&quot;: \&quot;47.614941\&quot;,       \&quot;startLng\&quot;: \&quot;-122.350062\&quot;,       \&quot;startDate\&quot;: \&quot;1361924015000\&quot;,       \&quot;endLat\&quot;: \&quot;47.614384\&quot;,       \&quot;endLng\&quot;: \&quot;-122.349161\&quot;,       \&quot;endDate\&quot;: \&quot;1361924020000\&quot;     }   ] ] &#x60;&#x60;&#x60; 
func (r ApiBatchSaveTrackingRequest) Data(data string) ApiBatchSaveTrackingRequest {
	r.data = &data
	return r
}

// the device id (deviceId or accountId required)
func (r ApiBatchSaveTrackingRequest) DeviceId(deviceId string) ApiBatchSaveTrackingRequest {
	r.deviceId = &deviceId
	return r
}

// the account id of the user (deviceId or accountId required)
func (r ApiBatchSaveTrackingRequest) AccountId(accountId int64) ApiBatchSaveTrackingRequest {
	r.accountId = &accountId
	return r
}

// Whether to generate accounts for tracking entries when the owner does not exist
func (r ApiBatchSaveTrackingRequest) GenerateAccounts(generateAccounts bool) ApiBatchSaveTrackingRequest {
	r.generateAccounts = &generateAccounts
	return r
}

// Whether to update the account&#39;s current location from the incoming tracking data
func (r ApiBatchSaveTrackingRequest) UpdateAccountLocations(updateAccountLocations bool) ApiBatchSaveTrackingRequest {
	r.updateAccountLocations = &updateAccountLocations
	return r
}

// The default tag to apply to incoming legs when no tag is provided
func (r ApiBatchSaveTrackingRequest) DefaultTag(defaultTag string) ApiBatchSaveTrackingRequest {
	r.defaultTag = &defaultTag
	return r
}

// 
func (r ApiBatchSaveTrackingRequest) SlaveUID(slaveUID string) ApiBatchSaveTrackingRequest {
	r.slaveUID = &slaveUID
	return r
}

func (r ApiBatchSaveTrackingRequest) Execute() ([]Leg, *http.Response, error) {
	return r.ApiService.BatchSaveTrackingExecute(r)
}

/*
BatchSaveTracking Create Batch Tracking

Batch create tracking legs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBatchSaveTrackingRequest
*/
func (a *TrackingAPIService) BatchSaveTracking(ctx context.Context) ApiBatchSaveTrackingRequest {
	return ApiBatchSaveTrackingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Leg
func (a *TrackingAPIService) BatchSaveTrackingExecute(r ApiBatchSaveTrackingRequest) ([]Leg, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Leg
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TrackingAPIService.BatchSaveTracking")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tracking/batch/create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "data", r.data, "form", "")
	if r.generateAccounts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "generateAccounts", r.generateAccounts, "form", "")
	}
	if r.updateAccountLocations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateAccountLocations", r.updateAccountLocations, "form", "")
	}
	if r.defaultTag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "defaultTag", r.defaultTag, "form", "")
	} else {
		var defaultValue string = "PASSIVE"
		parameterAddToHeaderOrQuery(localVarQueryParams, "defaultTag", defaultValue, "form", "")
		r.defaultTag = &defaultValue
	}
	if r.slaveUID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "slaveUID", r.slaveUID, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPredictedLocationsRequest struct {
	ctx context.Context
	ApiService *TrackingAPIService
	accountId *int64
	latitude *float64
	longitude *float64
	dateCheck *int64
	hourCheck *string
	threshold *int64
	distanceUnit *string
	searchRange *float64
	sortOrder *string
}

// The account id of the customer
func (r ApiGetPredictedLocationsRequest) AccountId(accountId int64) ApiGetPredictedLocationsRequest {
	r.accountId = &accountId
	return r
}

// latitude to return a more likely result set based on the user&#39;s current location
func (r ApiGetPredictedLocationsRequest) Latitude(latitude float64) ApiGetPredictedLocationsRequest {
	r.latitude = &latitude
	return r
}

// longitude to return a more likely result set based on the user&#39;s current location
func (r ApiGetPredictedLocationsRequest) Longitude(longitude float64) ApiGetPredictedLocationsRequest {
	r.longitude = &longitude
	return r
}

// Used to specify which day to get predicted locations for. So if you want to look at where they might be tomorrow, pass in tomorrow&#39;s date (timestamp in milliseconds). If no value is passed in, the current date will be used.
func (r ApiGetPredictedLocationsRequest) DateCheck(dateCheck int64) ApiGetPredictedLocationsRequest {
	r.dateCheck = &dateCheck
	return r
}

// Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see predicted locations for the mornings and evening you can pass in \&quot;8,9,10,11,17,18,19,20\&quot;.
func (r ApiGetPredictedLocationsRequest) HourCheck(hourCheck string) ApiGetPredictedLocationsRequest {
	r.hourCheck = &hourCheck
	return r
}

// The minimum number matches in 1 hour to be considered a likely location.
func (r ApiGetPredictedLocationsRequest) Threshold(threshold int64) ApiGetPredictedLocationsRequest {
	r.threshold = &threshold
	return r
}

// Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS}
func (r ApiGetPredictedLocationsRequest) DistanceUnit(distanceUnit string) ApiGetPredictedLocationsRequest {
	r.distanceUnit = &distanceUnit
	return r
}

// Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \&quot;0\&quot; (zero) will ignore the radius restriction.
func (r ApiGetPredictedLocationsRequest) SearchRange(searchRange float64) ApiGetPredictedLocationsRequest {
	r.searchRange = &searchRange
	return r
}

// The ordering algorithm for sorting the returned results: {MATCHES, DISTANCE, WEIGHTED}
func (r ApiGetPredictedLocationsRequest) SortOrder(sortOrder string) ApiGetPredictedLocationsRequest {
	r.sortOrder = &sortOrder
	return r
}

func (r ApiGetPredictedLocationsRequest) Execute() (*PredictedLocationResponse, *http.Response, error) {
	return r.ApiService.GetPredictedLocationsExecute(r)
}

/*
GetPredictedLocations Get Predicted Locations

Get the predicted location for a customer based on previous behavior.  If a customer resides in a place for a period of time this is marked as a preferred location.  We look back over the previous few days and the previous days of the week from the day specified.  If for instance the day was a Wednesday then this would check the days before, including: Tuesday, Monday, Sunday, etc. It will also check some number of previous Wednesdays in the past few weeks.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetPredictedLocationsRequest
*/
func (a *TrackingAPIService) GetPredictedLocations(ctx context.Context) ApiGetPredictedLocationsRequest {
	return ApiGetPredictedLocationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PredictedLocationResponse
func (a *TrackingAPIService) GetPredictedLocationsExecute(r ApiGetPredictedLocationsRequest) (*PredictedLocationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PredictedLocationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TrackingAPIService.GetPredictedLocations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tracking/predicted/get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	if r.latitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latitude", r.latitude, "form", "")
	}
	if r.longitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "longitude", r.longitude, "form", "")
	}
	if r.dateCheck != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dateCheck", r.dateCheck, "form", "")
	}
	if r.hourCheck != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hourCheck", r.hourCheck, "form", "")
	}
	if r.threshold != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "threshold", r.threshold, "form", "")
	} else {
		var defaultValue int64 = 1
		parameterAddToHeaderOrQuery(localVarQueryParams, "threshold", defaultValue, "form", "")
		r.threshold = &defaultValue
	}
	if r.distanceUnit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "distanceUnit", r.distanceUnit, "form", "")
	} else {
		var defaultValue string = "MILES"
		parameterAddToHeaderOrQuery(localVarQueryParams, "distanceUnit", defaultValue, "form", "")
		r.distanceUnit = &defaultValue
	}
	if r.searchRange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "searchRange", r.searchRange, "form", "")
	} else {
		var defaultValue float64 = 0
		parameterAddToHeaderOrQuery(localVarQueryParams, "searchRange", defaultValue, "form", "")
		r.searchRange = &defaultValue
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", r.sortOrder, "form", "")
	} else {
		var defaultValue string = "MATCHES"
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", defaultValue, "form", "")
		r.sortOrder = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPredictedPathRequest struct {
	ctx context.Context
	ApiService *TrackingAPIService
	accountId *int64
	startStepId *int64
	endStepId *int64
}

// The account id of the customer
func (r ApiGetPredictedPathRequest) AccountId(accountId int64) ApiGetPredictedPathRequest {
	r.accountId = &accountId
	return r
}

// The stepId to begin from
func (r ApiGetPredictedPathRequest) StartStepId(startStepId int64) ApiGetPredictedPathRequest {
	r.startStepId = &startStepId
	return r
}

// The stepId to end with
func (r ApiGetPredictedPathRequest) EndStepId(endStepId int64) ApiGetPredictedPathRequest {
	r.endStepId = &endStepId
	return r
}

func (r ApiGetPredictedPathRequest) Execute() ([]StepResponse, *http.Response, error) {
	return r.ApiService.GetPredictedPathExecute(r)
}

/*
GetPredictedPath Get Tracking Path

Get the path (lat/long coordinates) between 2 steps previously logged for a customer.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetPredictedPathRequest
*/
func (a *TrackingAPIService) GetPredictedPath(ctx context.Context) ApiGetPredictedPathRequest {
	return ApiGetPredictedPathRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []StepResponse
func (a *TrackingAPIService) GetPredictedPathExecute(r ApiGetPredictedPathRequest) ([]StepResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []StepResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TrackingAPIService.GetPredictedPath")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tracking/path/get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.startStepId == nil {
		return localVarReturnValue, nil, reportError("startStepId is required and must be specified")
	}
	if r.endStepId == nil {
		return localVarReturnValue, nil, reportError("endStepId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "startStepId", r.startStepId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "endStepId", r.endStepId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPreferredLocationsRequest struct {
	ctx context.Context
	ApiService *TrackingAPIService
	accountId *int64
	latitude *float64
	longitude *float64
	dateCheck *int64
	hourCheck *string
	sortField *string
	descending *bool
	start *int32
	limit *int32
	searchRange *float64
	distanceUnit *string
}

// The account id of the customer
func (r ApiGetPreferredLocationsRequest) AccountId(accountId int64) ApiGetPreferredLocationsRequest {
	r.accountId = &accountId
	return r
}

// latitude to return a more likely result set based on the user&#39;s current location
func (r ApiGetPreferredLocationsRequest) Latitude(latitude float64) ApiGetPreferredLocationsRequest {
	r.latitude = &latitude
	return r
}

// longitude to return a more likely result set based on the user&#39;s current location
func (r ApiGetPreferredLocationsRequest) Longitude(longitude float64) ApiGetPreferredLocationsRequest {
	r.longitude = &longitude
	return r
}

// Used to specify which day to get preferred locations for. So if you want to look at where they might be tomorrow, pass in tomorrow&#39;s date (timestamp in milliseconds). If no value is passed in, results from all time will be returned.
func (r ApiGetPreferredLocationsRequest) DateCheck(dateCheck int64) ApiGetPreferredLocationsRequest {
	r.dateCheck = &dateCheck
	return r
}

// Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see preferred locations for the mornings and evening you can pass in \&quot;8,9,10,11,17,18,19,20\&quot;.
func (r ApiGetPreferredLocationsRequest) HourCheck(hourCheck string) ApiGetPreferredLocationsRequest {
	r.hourCheck = &hourCheck
	return r
}

// Specifies how the results will be ordered. Supported values include: CREATED - the time of when the preferred location data was processed. PREFERRED_DATE - the time of when the user sent in the tracking data. HOUR - the hour of when the user sent in the tracking data. DURATION - the duration of the preferred location
func (r ApiGetPreferredLocationsRequest) SortField(sortField string) ApiGetPreferredLocationsRequest {
	r.sortField = &sortField
	return r
}

// Determines whether the sorted list is in descending or ascending order
func (r ApiGetPreferredLocationsRequest) Descending(descending bool) ApiGetPreferredLocationsRequest {
	r.descending = &descending
	return r
}

// The start index for pagination
func (r ApiGetPreferredLocationsRequest) Start(start int32) ApiGetPreferredLocationsRequest {
	r.start = &start
	return r
}

// The limit for pagination
func (r ApiGetPreferredLocationsRequest) Limit(limit int32) ApiGetPreferredLocationsRequest {
	r.limit = &limit
	return r
}

// Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \&quot;0\&quot; (zero) will ignore the radius restriction.
func (r ApiGetPreferredLocationsRequest) SearchRange(searchRange float64) ApiGetPreferredLocationsRequest {
	r.searchRange = &searchRange
	return r
}

// Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS}
func (r ApiGetPreferredLocationsRequest) DistanceUnit(distanceUnit string) ApiGetPreferredLocationsRequest {
	r.distanceUnit = &distanceUnit
	return r
}

func (r ApiGetPreferredLocationsRequest) Execute() ([]PreferredLocationResponse, *http.Response, error) {
	return r.ApiService.GetPreferredLocationsExecute(r)
}

/*
GetPreferredLocations Search Preferred Locations

Search on preferred locations for a user, which is created when a customer resides in a place for a period of time.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetPreferredLocationsRequest
*/
func (a *TrackingAPIService) GetPreferredLocations(ctx context.Context) ApiGetPreferredLocationsRequest {
	return ApiGetPreferredLocationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []PreferredLocationResponse
func (a *TrackingAPIService) GetPreferredLocationsExecute(r ApiGetPreferredLocationsRequest) ([]PreferredLocationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PreferredLocationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TrackingAPIService.GetPreferredLocations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tracking/preferred/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	if r.latitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latitude", r.latitude, "form", "")
	}
	if r.longitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "longitude", r.longitude, "form", "")
	}
	if r.dateCheck != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dateCheck", r.dateCheck, "form", "")
	}
	if r.hourCheck != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hourCheck", r.hourCheck, "form", "")
	}
	if r.sortField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", r.sortField, "form", "")
	} else {
		var defaultValue string = "PREFERRED_DATE"
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", defaultValue, "form", "")
		r.sortField = &defaultValue
	}
	if r.descending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "form", "")
	} else {
		var defaultValue bool = true
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", defaultValue, "form", "")
		r.descending = &defaultValue
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	} else {
		var defaultValue int32 = 0
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", defaultValue, "form", "")
		r.start = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 20
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	if r.searchRange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "searchRange", r.searchRange, "form", "")
	} else {
		var defaultValue float64 = 0
		parameterAddToHeaderOrQuery(localVarQueryParams, "searchRange", defaultValue, "form", "")
		r.searchRange = &defaultValue
	}
	if r.distanceUnit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "distanceUnit", r.distanceUnit, "form", "")
	} else {
		var defaultValue string = "MILES"
		parameterAddToHeaderOrQuery(localVarQueryParams, "distanceUnit", defaultValue, "form", "")
		r.distanceUnit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTrackingLegsRequest struct {
	ctx context.Context
	ApiService *TrackingAPIService
	deviceId *string
	accountId *int64
	ownerId *int64
	trackingDeviceId *string
	startDate *int64
	endDate *int64
	tags *string
	getLastPoint *bool
}

// the device id (deviceId or accountId required)
func (r ApiGetTrackingLegsRequest) DeviceId(deviceId string) ApiGetTrackingLegsRequest {
	r.deviceId = &deviceId
	return r
}

// the account id of the user (deviceId or accountId required)
func (r ApiGetTrackingLegsRequest) AccountId(accountId int64) ApiGetTrackingLegsRequest {
	r.accountId = &accountId
	return r
}

// the account id of the person the user wants to tracking data for
func (r ApiGetTrackingLegsRequest) OwnerId(ownerId int64) ApiGetTrackingLegsRequest {
	r.ownerId = &ownerId
	return r
}

// the id of the tracking device
func (r ApiGetTrackingLegsRequest) TrackingDeviceId(trackingDeviceId string) ApiGetTrackingLegsRequest {
	r.trackingDeviceId = &trackingDeviceId
	return r
}

// the start date in (UTC milliseconds) to filter the tracking results. If no startDate is passed in, the last 30 days will be returned.
func (r ApiGetTrackingLegsRequest) StartDate(startDate int64) ApiGetTrackingLegsRequest {
	r.startDate = &startDate
	return r
}

// the end date in (UTC milliseconds) to filter the tracking results
func (r ApiGetTrackingLegsRequest) EndDate(endDate int64) ApiGetTrackingLegsRequest {
	r.endDate = &endDate
	return r
}

// filter results by tag
func (r ApiGetTrackingLegsRequest) Tags(tags string) ApiGetTrackingLegsRequest {
	r.tags = &tags
	return r
}

// gets the last known location of the user
func (r ApiGetTrackingLegsRequest) GetLastPoint(getLastPoint bool) ApiGetTrackingLegsRequest {
	r.getLastPoint = &getLastPoint
	return r
}

func (r ApiGetTrackingLegsRequest) Execute() ([]LegResponse, *http.Response, error) {
	return r.ApiService.GetTrackingLegsExecute(r)
}

/*
GetTrackingLegs Search Tracking

Retrieve tracking data to be able to show where a user has been.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTrackingLegsRequest
*/
func (a *TrackingAPIService) GetTrackingLegs(ctx context.Context) ApiGetTrackingLegsRequest {
	return ApiGetTrackingLegsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []LegResponse
func (a *TrackingAPIService) GetTrackingLegsExecute(r ApiGetTrackingLegsRequest) ([]LegResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []LegResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TrackingAPIService.GetTrackingLegs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tracking/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.ownerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ownerId", r.ownerId, "form", "")
	}
	if r.trackingDeviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "trackingDeviceId", r.trackingDeviceId, "form", "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "form", "")
	}
	if r.tags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tags", r.tags, "form", "")
	}
	if r.getLastPoint != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "getLastPoint", r.getLastPoint, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "getLastPoint", defaultValue, "form", "")
		r.getLastPoint = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSaveTrackingLegRequest struct {
	ctx context.Context
	ApiService *TrackingAPIService
	startLat *float64
	startLng *float64
	startDate *int64
	endLat *float64
	endLng *float64
	endDate *int64
	deviceId *string
	accountId *int64
	distance *float64
	duration *int64
	steps *string
	tags *string
}

// the latitude of the first point
func (r ApiSaveTrackingLegRequest) StartLat(startLat float64) ApiSaveTrackingLegRequest {
	r.startLat = &startLat
	return r
}

// the longitude of the first point
func (r ApiSaveTrackingLegRequest) StartLng(startLng float64) ApiSaveTrackingLegRequest {
	r.startLng = &startLng
	return r
}

// the start date (in UTC milliseconds) of the first point
func (r ApiSaveTrackingLegRequest) StartDate(startDate int64) ApiSaveTrackingLegRequest {
	r.startDate = &startDate
	return r
}

// the latitude of the last point
func (r ApiSaveTrackingLegRequest) EndLat(endLat float64) ApiSaveTrackingLegRequest {
	r.endLat = &endLat
	return r
}

// the longitude of the last point
func (r ApiSaveTrackingLegRequest) EndLng(endLng float64) ApiSaveTrackingLegRequest {
	r.endLng = &endLng
	return r
}

// the end date (in UTC milliseconds) of the last point
func (r ApiSaveTrackingLegRequest) EndDate(endDate int64) ApiSaveTrackingLegRequest {
	r.endDate = &endDate
	return r
}

// the device id (deviceId or accountId required)
func (r ApiSaveTrackingLegRequest) DeviceId(deviceId string) ApiSaveTrackingLegRequest {
	r.deviceId = &deviceId
	return r
}

// the account id of the user (deviceId or accountId required)
func (r ApiSaveTrackingLegRequest) AccountId(accountId int64) ApiSaveTrackingLegRequest {
	r.accountId = &accountId
	return r
}

// the total distance
func (r ApiSaveTrackingLegRequest) Distance(distance float64) ApiSaveTrackingLegRequest {
	r.distance = &distance
	return r
}

// the total duration
func (r ApiSaveTrackingLegRequest) Duration(duration int64) ApiSaveTrackingLegRequest {
	r.duration = &duration
	return r
}

// JSON array of tracking vectors used for smoother pathing data. If null then the leg data will be used to generate a single step, if an empty array then no steps will be generated. &#x60;&#x60;&#x60;json [{   \&quot;distance\&quot;: \&quot;0.03\&quot;,   \&quot;duration\&quot;: \&quot;5000\&quot;,   \&quot;startLat\&quot;: \&quot;47.614603\&quot;,   \&quot;startLng\&quot;: \&quot;-122.350518\&quot;,   \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,   \&quot;endLat\&quot;: \&quot;47.614941\&quot;,   \&quot;endLng\&quot;: \&quot;-122.350062\&quot;,   \&quot;endDate\&quot;: \&quot;1361924015000\&quot; }] &#x60;&#x60;&#x60; 
func (r ApiSaveTrackingLegRequest) Steps(steps string) ApiSaveTrackingLegRequest {
	r.steps = &steps
	return r
}

// name the leg for searching
func (r ApiSaveTrackingLegRequest) Tags(tags string) ApiSaveTrackingLegRequest {
	r.tags = &tags
	return r
}

func (r ApiSaveTrackingLegRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.SaveTrackingLegExecute(r)
}

/*
SaveTrackingLeg Create Tracking Leg

Send tracking points to be able to generate pathing data

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSaveTrackingLegRequest
*/
func (a *TrackingAPIService) SaveTrackingLeg(ctx context.Context) ApiSaveTrackingLegRequest {
	return ApiSaveTrackingLegRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *TrackingAPIService) SaveTrackingLegExecute(r ApiSaveTrackingLegRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TrackingAPIService.SaveTrackingLeg")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tracking/leg/create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.startLat == nil {
		return localVarReturnValue, nil, reportError("startLat is required and must be specified")
	}
	if r.startLng == nil {
		return localVarReturnValue, nil, reportError("startLng is required and must be specified")
	}
	if r.startDate == nil {
		return localVarReturnValue, nil, reportError("startDate is required and must be specified")
	}
	if r.endLat == nil {
		return localVarReturnValue, nil, reportError("endLat is required and must be specified")
	}
	if r.endLng == nil {
		return localVarReturnValue, nil, reportError("endLng is required and must be specified")
	}
	if r.endDate == nil {
		return localVarReturnValue, nil, reportError("endDate is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.distance != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "distance", r.distance, "form", "")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "startLat", r.startLat, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "startLng", r.startLng, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "endLat", r.endLat, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "endLng", r.endLng, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "form", "")
	if r.steps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "steps", r.steps, "form", "")
	}
	if r.tags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tags", r.tags, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSaveTrackingStepRequest struct {
	ctx context.Context
	ApiService *TrackingAPIService
	legId *int64
	startLat *float64
	startLng *float64
	startDate *int64
	endLat *float64
	endLng *float64
	endDate *int64
	deviceId *string
	accountId *int64
	distance *float64
	duration *int64
}

// the leg to add the step to
func (r ApiSaveTrackingStepRequest) LegId(legId int64) ApiSaveTrackingStepRequest {
	r.legId = &legId
	return r
}

// the latitude of the first point
func (r ApiSaveTrackingStepRequest) StartLat(startLat float64) ApiSaveTrackingStepRequest {
	r.startLat = &startLat
	return r
}

// the longitude of the first point
func (r ApiSaveTrackingStepRequest) StartLng(startLng float64) ApiSaveTrackingStepRequest {
	r.startLng = &startLng
	return r
}

// the start date (in UTC milliseconds) of the first point
func (r ApiSaveTrackingStepRequest) StartDate(startDate int64) ApiSaveTrackingStepRequest {
	r.startDate = &startDate
	return r
}

// the latitude of the last point
func (r ApiSaveTrackingStepRequest) EndLat(endLat float64) ApiSaveTrackingStepRequest {
	r.endLat = &endLat
	return r
}

// the longitude of the last point
func (r ApiSaveTrackingStepRequest) EndLng(endLng float64) ApiSaveTrackingStepRequest {
	r.endLng = &endLng
	return r
}

// the end date (in UTC milliseconds) of the last point
func (r ApiSaveTrackingStepRequest) EndDate(endDate int64) ApiSaveTrackingStepRequest {
	r.endDate = &endDate
	return r
}

// the device id (deviceId or accountId required)
func (r ApiSaveTrackingStepRequest) DeviceId(deviceId string) ApiSaveTrackingStepRequest {
	r.deviceId = &deviceId
	return r
}

// the account id of the user (deviceId or accountId required)
func (r ApiSaveTrackingStepRequest) AccountId(accountId int64) ApiSaveTrackingStepRequest {
	r.accountId = &accountId
	return r
}

// the total distance
func (r ApiSaveTrackingStepRequest) Distance(distance float64) ApiSaveTrackingStepRequest {
	r.distance = &distance
	return r
}

// the total duration
func (r ApiSaveTrackingStepRequest) Duration(duration int64) ApiSaveTrackingStepRequest {
	r.duration = &duration
	return r
}

func (r ApiSaveTrackingStepRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.SaveTrackingStepExecute(r)
}

/*
SaveTrackingStep Create Tracking Step

Send tracking points to be able to generate pathing data

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSaveTrackingStepRequest
*/
func (a *TrackingAPIService) SaveTrackingStep(ctx context.Context) ApiSaveTrackingStepRequest {
	return ApiSaveTrackingStepRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *TrackingAPIService) SaveTrackingStepExecute(r ApiSaveTrackingStepRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TrackingAPIService.SaveTrackingStep")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tracking/step/create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.legId == nil {
		return localVarReturnValue, nil, reportError("legId is required and must be specified")
	}
	if r.startLat == nil {
		return localVarReturnValue, nil, reportError("startLat is required and must be specified")
	}
	if r.startLng == nil {
		return localVarReturnValue, nil, reportError("startLng is required and must be specified")
	}
	if r.startDate == nil {
		return localVarReturnValue, nil, reportError("startDate is required and must be specified")
	}
	if r.endLat == nil {
		return localVarReturnValue, nil, reportError("endLat is required and must be specified")
	}
	if r.endLng == nil {
		return localVarReturnValue, nil, reportError("endLng is required and must be specified")
	}
	if r.endDate == nil {
		return localVarReturnValue, nil, reportError("endDate is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "legId", r.legId, "form", "")
	if r.distance != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "distance", r.distance, "form", "")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "startLat", r.startLat, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "startLng", r.startLng, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "endLat", r.endLat, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "endLng", r.endLng, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchAccountsWithTrackingLegsRequest struct {
	ctx context.Context
	ApiService *TrackingAPIService
	accountId *int64
	keyword *string
	startDate *int64
	endDate *int64
	tags *string
	audienceIds *string
	latitude *float64
	longitude *float64
	range_ *float64
	sortField *string
	descending *bool
	start *int32
	limit *int32
	activeOnly *bool
}

// The account id of the user
func (r ApiSearchAccountsWithTrackingLegsRequest) AccountId(accountId int64) ApiSearchAccountsWithTrackingLegsRequest {
	r.accountId = &accountId
	return r
}

// Used for LIKE search of first or last name on the acocunt
func (r ApiSearchAccountsWithTrackingLegsRequest) Keyword(keyword string) ApiSearchAccountsWithTrackingLegsRequest {
	r.keyword = &keyword
	return r
}

// Range to begin in UTC milliseconds
func (r ApiSearchAccountsWithTrackingLegsRequest) StartDate(startDate int64) ApiSearchAccountsWithTrackingLegsRequest {
	r.startDate = &startDate
	return r
}

// Range to end in UTC milliseconds
func (r ApiSearchAccountsWithTrackingLegsRequest) EndDate(endDate int64) ApiSearchAccountsWithTrackingLegsRequest {
	r.endDate = &endDate
	return r
}

// Exact match on tag field of Legs&#39;s searchTag
func (r ApiSearchAccountsWithTrackingLegsRequest) Tags(tags string) ApiSearchAccountsWithTrackingLegsRequest {
	r.tags = &tags
	return r
}

// 
func (r ApiSearchAccountsWithTrackingLegsRequest) AudienceIds(audienceIds string) ApiSearchAccountsWithTrackingLegsRequest {
	r.audienceIds = &audienceIds
	return r
}

// Origin latitude to perform searching constraints with given range
func (r ApiSearchAccountsWithTrackingLegsRequest) Latitude(latitude float64) ApiSearchAccountsWithTrackingLegsRequest {
	r.latitude = &latitude
	return r
}

// Origin longitude to perform searching constraints with given range
func (r ApiSearchAccountsWithTrackingLegsRequest) Longitude(longitude float64) ApiSearchAccountsWithTrackingLegsRequest {
	r.longitude = &longitude
	return r
}

// The radius, in miles, to perform the search for
func (r ApiSearchAccountsWithTrackingLegsRequest) Range_(range_ float64) ApiSearchAccountsWithTrackingLegsRequest {
	r.range_ = &range_
	return r
}

// The column to sort the search on. Possible values include: {LEG_START_DATE, ACCOUNT_DISPLAY}
func (r ApiSearchAccountsWithTrackingLegsRequest) SortField(sortField string) ApiSearchAccountsWithTrackingLegsRequest {
	r.sortField = &sortField
	return r
}

// The order to return the results. Default is false, which will return the results in ascending order.
func (r ApiSearchAccountsWithTrackingLegsRequest) Descending(descending bool) ApiSearchAccountsWithTrackingLegsRequest {
	r.descending = &descending
	return r
}

// The index into the record set to start with. Default is 0.
func (r ApiSearchAccountsWithTrackingLegsRequest) Start(start int32) ApiSearchAccountsWithTrackingLegsRequest {
	r.start = &start
	return r
}

// The total number of records to return. Default is 20.
func (r ApiSearchAccountsWithTrackingLegsRequest) Limit(limit int32) ApiSearchAccountsWithTrackingLegsRequest {
	r.limit = &limit
	return r
}

// Determines whether to return only active results. Default is false.
func (r ApiSearchAccountsWithTrackingLegsRequest) ActiveOnly(activeOnly bool) ApiSearchAccountsWithTrackingLegsRequest {
	r.activeOnly = &activeOnly
	return r
}

func (r ApiSearchAccountsWithTrackingLegsRequest) Execute() ([]AccountMiniResponse, *http.Response, error) {
	return r.ApiService.SearchAccountsWithTrackingLegsExecute(r)
}

/*
SearchAccountsWithTrackingLegs List Tracking

Search for all accounts that have tracking legs data by the given constraints.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchAccountsWithTrackingLegsRequest
*/
func (a *TrackingAPIService) SearchAccountsWithTrackingLegs(ctx context.Context) ApiSearchAccountsWithTrackingLegsRequest {
	return ApiSearchAccountsWithTrackingLegsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []AccountMiniResponse
func (a *TrackingAPIService) SearchAccountsWithTrackingLegsExecute(r ApiSearchAccountsWithTrackingLegsRequest) ([]AccountMiniResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []AccountMiniResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TrackingAPIService.SearchAccountsWithTrackingLegs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tracking/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	if r.keyword != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyword", r.keyword, "form", "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "form", "")
	}
	if r.tags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tags", r.tags, "form", "")
	}
	if r.audienceIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audienceIds", r.audienceIds, "form", "")
	}
	if r.latitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latitude", r.latitude, "form", "")
	}
	if r.longitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "longitude", r.longitude, "form", "")
	}
	if r.range_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "range", r.range_, "form", "")
	} else {
		var defaultValue float64 = 5
		parameterAddToHeaderOrQuery(localVarQueryParams, "range", defaultValue, "form", "")
		r.range_ = &defaultValue
	}
	if r.sortField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", r.sortField, "form", "")
	} else {
		var defaultValue string = "LEG_START_DATE"
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", defaultValue, "form", "")
		r.sortField = &defaultValue
	}
	if r.descending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "form", "")
	} else {
		var defaultValue bool = true
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", defaultValue, "form", "")
		r.descending = &defaultValue
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	} else {
		var defaultValue int32 = 0
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", defaultValue, "form", "")
		r.start = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 20
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	if r.activeOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activeOnly", r.activeOnly, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "activeOnly", defaultValue, "form", "")
		r.activeOnly = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchTrackingLegsRequest struct {
	ctx context.Context
	ApiService *TrackingAPIService
	accountId *int64
	appKey *string
	trackingDeviceId *string
	startDate *int64
	endDate *int64
	tags *string
	start *int32
	limit *int32
}

// The account id to search tracking for
func (r ApiSearchTrackingLegsRequest) AccountId(accountId int64) ApiSearchTrackingLegsRequest {
	r.accountId = &accountId
	return r
}

// The application key
func (r ApiSearchTrackingLegsRequest) AppKey(appKey string) ApiSearchTrackingLegsRequest {
	r.appKey = &appKey
	return r
}

// The id of the tracking device
func (r ApiSearchTrackingLegsRequest) TrackingDeviceId(trackingDeviceId string) ApiSearchTrackingLegsRequest {
	r.trackingDeviceId = &trackingDeviceId
	return r
}

// The start date in (UTC milliseconds) to filter the tracking results
func (r ApiSearchTrackingLegsRequest) StartDate(startDate int64) ApiSearchTrackingLegsRequest {
	r.startDate = &startDate
	return r
}

// The end date in (UTC milliseconds) to filter the tracking results
func (r ApiSearchTrackingLegsRequest) EndDate(endDate int64) ApiSearchTrackingLegsRequest {
	r.endDate = &endDate
	return r
}

// Filter results by tag
func (r ApiSearchTrackingLegsRequest) Tags(tags string) ApiSearchTrackingLegsRequest {
	r.tags = &tags
	return r
}

// The start index for pagination
func (r ApiSearchTrackingLegsRequest) Start(start int32) ApiSearchTrackingLegsRequest {
	r.start = &start
	return r
}

// The limit for pagination
func (r ApiSearchTrackingLegsRequest) Limit(limit int32) ApiSearchTrackingLegsRequest {
	r.limit = &limit
	return r
}

func (r ApiSearchTrackingLegsRequest) Execute() ([]LegResponse, *http.Response, error) {
	return r.ApiService.SearchTrackingLegsExecute(r)
}

/*
SearchTrackingLegs Search Tracking (Billable)

Retrieve tracking data for billable/account scoped queries.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchTrackingLegsRequest
*/
func (a *TrackingAPIService) SearchTrackingLegs(ctx context.Context) ApiSearchTrackingLegsRequest {
	return ApiSearchTrackingLegsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []LegResponse
func (a *TrackingAPIService) SearchTrackingLegsExecute(r ApiSearchTrackingLegsRequest) ([]LegResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []LegResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TrackingAPIService.SearchTrackingLegs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tracking/searchByBillable"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.appKey == nil {
		return localVarReturnValue, nil, reportError("appKey is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	if r.trackingDeviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "trackingDeviceId", r.trackingDeviceId, "form", "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "form", "")
	}
	if r.tags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tags", r.tags, "form", "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	} else {
		var defaultValue int32 = 0
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", defaultValue, "form", "")
		r.start = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 100
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
