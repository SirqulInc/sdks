/*
Sirqul IoT Platform

Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

API version: 3.16
Contact: info@sirqul.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// RegionAPIService RegionAPI service
type RegionAPIService service

type ApiCreateRegionRequest struct {
	ctx context.Context
	ApiService *RegionAPIService
	version float32
	accountId *int64
	regionClass *string
	shortName *string
	fullName *string
	parentIds *string
	childrenIds *string
	postalCodeIds *string
	locations *string
	retailerLocationId *int64
	visibility *string
	categoryIds *string
	filterIds *string
	start *int64
	end *int64
	polygon *string
	metaData *string
	latitude *float64
	longitude *float64
	versionCode *int32
	root *bool
	active *bool
}

// The id of the account sending the request
func (r ApiCreateRegionRequest) AccountId(accountId int64) ApiCreateRegionRequest {
	r.accountId = &accountId
	return r
}

// RegionClass of this region
func (r ApiCreateRegionRequest) RegionClass(regionClass string) ApiCreateRegionRequest {
	r.regionClass = &regionClass
	return r
}

// Short name of the region. This is optimized for search
func (r ApiCreateRegionRequest) ShortName(shortName string) ApiCreateRegionRequest {
	r.shortName = &shortName
	return r
}

// Full name of the region
func (r ApiCreateRegionRequest) FullName(fullName string) ApiCreateRegionRequest {
	r.fullName = &fullName
	return r
}

// Comma separated region ids that are parents of this region
func (r ApiCreateRegionRequest) ParentIds(parentIds string) ApiCreateRegionRequest {
	r.parentIds = &parentIds
	return r
}

// Comma separated region ids that are children of this region
func (r ApiCreateRegionRequest) ChildrenIds(childrenIds string) ApiCreateRegionRequest {
	r.childrenIds = &childrenIds
	return r
}

// Comma separated postal code ids the region will include
func (r ApiCreateRegionRequest) PostalCodeIds(postalCodeIds string) ApiCreateRegionRequest {
	r.postalCodeIds = &postalCodeIds
	return r
}

// Sets of name,lat,long used to create new postal codes assigned to the region
func (r ApiCreateRegionRequest) Locations(locations string) ApiCreateRegionRequest {
	r.locations = &locations
	return r
}

// the id of the retailer location that the region is being created for
func (r ApiCreateRegionRequest) RetailerLocationId(retailerLocationId int64) ApiCreateRegionRequest {
	r.retailerLocationId = &retailerLocationId
	return r
}

// The Visibility of the region
func (r ApiCreateRegionRequest) Visibility(visibility string) ApiCreateRegionRequest {
	r.visibility = &visibility
	return r
}

// the categories that the region is assigned to
func (r ApiCreateRegionRequest) CategoryIds(categoryIds string) ApiCreateRegionRequest {
	r.categoryIds = &categoryIds
	return r
}

// the filters that the region is assigned to
func (r ApiCreateRegionRequest) FilterIds(filterIds string) ApiCreateRegionRequest {
	r.filterIds = &filterIds
	return r
}

// 
func (r ApiCreateRegionRequest) Start(start int64) ApiCreateRegionRequest {
	r.start = &start
	return r
}

// 
func (r ApiCreateRegionRequest) End(end int64) ApiCreateRegionRequest {
	r.end = &end
	return r
}

// the polygon generated for the region
func (r ApiCreateRegionRequest) Polygon(polygon string) ApiCreateRegionRequest {
	r.polygon = &polygon
	return r
}

// the meta data associated with the region
func (r ApiCreateRegionRequest) MetaData(metaData string) ApiCreateRegionRequest {
	r.metaData = &metaData
	return r
}

// the latitude of the region
func (r ApiCreateRegionRequest) Latitude(latitude float64) ApiCreateRegionRequest {
	r.latitude = &latitude
	return r
}

// the longitude of the region
func (r ApiCreateRegionRequest) Longitude(longitude float64) ApiCreateRegionRequest {
	r.longitude = &longitude
	return r
}

// the version code
func (r ApiCreateRegionRequest) VersionCode(versionCode int32) ApiCreateRegionRequest {
	r.versionCode = &versionCode
	return r
}

// If this is a root region or not. If true means this region has no parent regions
func (r ApiCreateRegionRequest) Root(root bool) ApiCreateRegionRequest {
	r.root = &root
	return r
}

// Active or inactive status of the region
func (r ApiCreateRegionRequest) Active(active bool) ApiCreateRegionRequest {
	r.active = &active
	return r
}

func (r ApiCreateRegionRequest) Execute() (*RegionResponse, *http.Response, error) {
	return r.ApiService.CreateRegionExecute(r)
}

/*
CreateRegion Create Region

Create a region.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiCreateRegionRequest
*/
func (a *RegionAPIService) CreateRegion(ctx context.Context, version float32) ApiCreateRegionRequest {
	return ApiCreateRegionRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return RegionResponse
func (a *RegionAPIService) CreateRegionExecute(r ApiCreateRegionRequest) (*RegionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RegionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RegionAPIService.CreateRegion")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/region/create"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.regionClass == nil {
		return localVarReturnValue, nil, reportError("regionClass is required and must be specified")
	}
	if r.shortName == nil {
		return localVarReturnValue, nil, reportError("shortName is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "regionClass", r.regionClass, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "shortName", r.shortName, "form", "")
	if r.fullName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fullName", r.fullName, "form", "")
	}
	if r.parentIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parentIds", r.parentIds, "form", "")
	}
	if r.childrenIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "childrenIds", r.childrenIds, "form", "")
	}
	if r.postalCodeIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "postalCodeIds", r.postalCodeIds, "form", "")
	}
	if r.locations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locations", r.locations, "form", "")
	}
	if r.retailerLocationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "retailerLocationId", r.retailerLocationId, "form", "")
	}
	if r.visibility != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "visibility", r.visibility, "form", "")
	}
	if r.categoryIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "categoryIds", r.categoryIds, "form", "")
	}
	if r.filterIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filterIds", r.filterIds, "form", "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "form", "")
	}
	if r.polygon != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "polygon", r.polygon, "form", "")
	}
	if r.metaData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metaData", r.metaData, "form", "")
	}
	if r.latitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latitude", r.latitude, "form", "")
	}
	if r.longitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "longitude", r.longitude, "form", "")
	}
	if r.versionCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "versionCode", r.versionCode, "form", "")
	}
	if r.root != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "root", r.root, "form", "")
	}
	if r.active != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active", r.active, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteRegionRequest struct {
	ctx context.Context
	ApiService *RegionAPIService
	version float32
	accountId *int64
	regionId *int64
}

// the id of the account logged in
func (r ApiDeleteRegionRequest) AccountId(accountId int64) ApiDeleteRegionRequest {
	r.accountId = &accountId
	return r
}

// the id of the region
func (r ApiDeleteRegionRequest) RegionId(regionId int64) ApiDeleteRegionRequest {
	r.regionId = &regionId
	return r
}

func (r ApiDeleteRegionRequest) Execute() (*RegionResponse, *http.Response, error) {
	return r.ApiService.DeleteRegionExecute(r)
}

/*
DeleteRegion Delete Region

Delete a region.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiDeleteRegionRequest
*/
func (a *RegionAPIService) DeleteRegion(ctx context.Context, version float32) ApiDeleteRegionRequest {
	return ApiDeleteRegionRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return RegionResponse
func (a *RegionAPIService) DeleteRegionExecute(r ApiDeleteRegionRequest) (*RegionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RegionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RegionAPIService.DeleteRegion")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/region/delete"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.regionId == nil {
		return localVarReturnValue, nil, reportError("regionId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "regionId", r.regionId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRegionRequest struct {
	ctx context.Context
	ApiService *RegionAPIService
	version float32
	regionId *int64
	accountId *int64
}

// the id of the region to get
func (r ApiGetRegionRequest) RegionId(regionId int64) ApiGetRegionRequest {
	r.regionId = &regionId
	return r
}

// the id of the logged in user
func (r ApiGetRegionRequest) AccountId(accountId int64) ApiGetRegionRequest {
	r.accountId = &accountId
	return r
}

func (r ApiGetRegionRequest) Execute() (*RegionResponse, *http.Response, error) {
	return r.ApiService.GetRegionExecute(r)
}

/*
GetRegion Get Region

Get a region.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiGetRegionRequest
*/
func (a *RegionAPIService) GetRegion(ctx context.Context, version float32) ApiGetRegionRequest {
	return ApiGetRegionRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return RegionResponse
func (a *RegionAPIService) GetRegionExecute(r ApiGetRegionRequest) (*RegionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RegionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RegionAPIService.GetRegion")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/region/get"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.regionId == nil {
		return localVarReturnValue, nil, reportError("regionId is required and must be specified")
	}

	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "regionId", r.regionId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchRegionsRequest struct {
	ctx context.Context
	ApiService *RegionAPIService
	version float32
	accountId *int64
	query *string
	keyword *string
	latitude *float64
	longitude *float64
	range_ *float64
	regionClass *string
	visibility *string
	searchMode *string
	sortField *string
	descending *bool
	includeParent *bool
	includeChildren *bool
	includePostalCodes *bool
	categoryIds *string
	filterIds *string
	versionCode *int32
	activeOnly *bool
	showDeleted *bool
	lastUpdatedSince *int64
	start *int32
	limit *int32
}

// the owner account id of the region to be created
func (r ApiSearchRegionsRequest) AccountId(accountId int64) ApiSearchRegionsRequest {
	r.accountId = &accountId
	return r
}

// This parameter is deprecated. deprecated - use \&quot;keyword\&quot;
func (r ApiSearchRegionsRequest) Query(query string) ApiSearchRegionsRequest {
	r.query = &query
	return r
}

// the keyword to filter results on
func (r ApiSearchRegionsRequest) Keyword(keyword string) ApiSearchRegionsRequest {
	r.keyword = &keyword
	return r
}

// the latitude of the user
func (r ApiSearchRegionsRequest) Latitude(latitude float64) ApiSearchRegionsRequest {
	r.latitude = &latitude
	return r
}

// the longitude of the user
func (r ApiSearchRegionsRequest) Longitude(longitude float64) ApiSearchRegionsRequest {
	r.longitude = &longitude
	return r
}

// the search radius
func (r ApiSearchRegionsRequest) Range_(range_ float64) ApiSearchRegionsRequest {
	r.range_ = &range_
	return r
}

// 
func (r ApiSearchRegionsRequest) RegionClass(regionClass string) ApiSearchRegionsRequest {
	r.regionClass = &regionClass
	return r
}

// 
func (r ApiSearchRegionsRequest) Visibility(visibility string) ApiSearchRegionsRequest {
	r.visibility = &visibility
	return r
}

// the SearchIndexMode: RDS, LUCENE, or CLOUDINDEX. If not provided, will use the default defined in the Sirqul server
func (r ApiSearchRegionsRequest) SearchMode(searchMode string) ApiSearchRegionsRequest {
	r.searchMode = &searchMode
	return r
}

// the field to order results by: ID, UPDATED, NAME, or DISTANCE. If not provided, will use the default which is by ID for text and DISTANCE when lat/long is provided.
func (r ApiSearchRegionsRequest) SortField(sortField string) ApiSearchRegionsRequest {
	r.sortField = &sortField
	return r
}

// determines if the results get ordered in descending order
func (r ApiSearchRegionsRequest) Descending(descending bool) ApiSearchRegionsRequest {
	r.descending = &descending
	return r
}

// include the parent region or not
func (r ApiSearchRegionsRequest) IncludeParent(includeParent bool) ApiSearchRegionsRequest {
	r.includeParent = &includeParent
	return r
}

// include the chidren regions or not
func (r ApiSearchRegionsRequest) IncludeChildren(includeChildren bool) ApiSearchRegionsRequest {
	r.includeChildren = &includeChildren
	return r
}

// include the postal codes associated with the region or not
func (r ApiSearchRegionsRequest) IncludePostalCodes(includePostalCodes bool) ApiSearchRegionsRequest {
	r.includePostalCodes = &includePostalCodes
	return r
}

// search on the categories associated with the region
func (r ApiSearchRegionsRequest) CategoryIds(categoryIds string) ApiSearchRegionsRequest {
	r.categoryIds = &categoryIds
	return r
}

// search on the filters associated with the region
func (r ApiSearchRegionsRequest) FilterIds(filterIds string) ApiSearchRegionsRequest {
	r.filterIds = &filterIds
	return r
}

// filter by a specific version code
func (r ApiSearchRegionsRequest) VersionCode(versionCode int32) ApiSearchRegionsRequest {
	r.versionCode = &versionCode
	return r
}

// filter to show only active results
func (r ApiSearchRegionsRequest) ActiveOnly(activeOnly bool) ApiSearchRegionsRequest {
	r.activeOnly = &activeOnly
	return r
}

// If showDeleted is true and activeOnly is false, will return regions that have been deleted
func (r ApiSearchRegionsRequest) ShowDeleted(showDeleted bool) ApiSearchRegionsRequest {
	r.showDeleted = &showDeleted
	return r
}

// only returns records that have last updated since this date \\(UTC timestamp in milliseconds\\)
func (r ApiSearchRegionsRequest) LastUpdatedSince(lastUpdatedSince int64) ApiSearchRegionsRequest {
	r.lastUpdatedSince = &lastUpdatedSince
	return r
}

// the start index for pagination
func (r ApiSearchRegionsRequest) Start(start int32) ApiSearchRegionsRequest {
	r.start = &start
	return r
}

// the limit for pagination
func (r ApiSearchRegionsRequest) Limit(limit int32) ApiSearchRegionsRequest {
	r.limit = &limit
	return r
}

func (r ApiSearchRegionsRequest) Execute() ([]RegionResponse, *http.Response, error) {
	return r.ApiService.SearchRegionsExecute(r)
}

/*
SearchRegions Search Regions

Get the list of regions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiSearchRegionsRequest
*/
func (a *RegionAPIService) SearchRegions(ctx context.Context, version float32) ApiSearchRegionsRequest {
	return ApiSearchRegionsRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return []RegionResponse
func (a *RegionAPIService) SearchRegionsExecute(r ApiSearchRegionsRequest) ([]RegionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RegionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RegionAPIService.SearchRegions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/region/search"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.query != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "form", "")
	}
	if r.keyword != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyword", r.keyword, "form", "")
	}
	if r.latitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latitude", r.latitude, "form", "")
	}
	if r.longitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "longitude", r.longitude, "form", "")
	}
	if r.range_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "range", r.range_, "form", "")
	}
	if r.regionClass != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "regionClass", r.regionClass, "form", "")
	}
	if r.visibility != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "visibility", r.visibility, "form", "")
	}
	if r.searchMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "searchMode", r.searchMode, "form", "")
	}
	if r.sortField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", r.sortField, "form", "")
	}
	if r.descending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "form", "")
	}
	if r.includeParent != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeParent", r.includeParent, "form", "")
	}
	if r.includeChildren != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeChildren", r.includeChildren, "form", "")
	}
	if r.includePostalCodes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includePostalCodes", r.includePostalCodes, "form", "")
	}
	if r.categoryIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "categoryIds", r.categoryIds, "form", "")
	}
	if r.filterIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filterIds", r.filterIds, "form", "")
	}
	if r.versionCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "versionCode", r.versionCode, "form", "")
	}
	if r.activeOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activeOnly", r.activeOnly, "form", "")
	}
	if r.showDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "showDeleted", r.showDeleted, "form", "")
	}
	if r.lastUpdatedSince != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastUpdatedSince", r.lastUpdatedSince, "form", "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateRegionRequest struct {
	ctx context.Context
	ApiService *RegionAPIService
	version float32
	accountId *int64
	regionId *int64
	regionClass *string
	shortName *string
	fullName *string
	parentIds *string
	childrenIds *string
	postalCodeIds *string
	locations *string
	retailerLocationId *int64
	visibility *string
	categoryIds *string
	filterIds *string
	start *int64
	end *int64
	polygon *string
	metaData *string
	latitude *float64
	longitude *float64
	versionCode *int32
	root *bool
	active *bool
	clearLists *bool
}

// The id of the account sending the request
func (r ApiUpdateRegionRequest) AccountId(accountId int64) ApiUpdateRegionRequest {
	r.accountId = &accountId
	return r
}

// The id of the region to be updated
func (r ApiUpdateRegionRequest) RegionId(regionId int64) ApiUpdateRegionRequest {
	r.regionId = &regionId
	return r
}

// RegionClass of this region
func (r ApiUpdateRegionRequest) RegionClass(regionClass string) ApiUpdateRegionRequest {
	r.regionClass = &regionClass
	return r
}

// Short name of the region. This is optimized for search
func (r ApiUpdateRegionRequest) ShortName(shortName string) ApiUpdateRegionRequest {
	r.shortName = &shortName
	return r
}

// Full name of the region
func (r ApiUpdateRegionRequest) FullName(fullName string) ApiUpdateRegionRequest {
	r.fullName = &fullName
	return r
}

// Comma separated region ids that are parents of this region
func (r ApiUpdateRegionRequest) ParentIds(parentIds string) ApiUpdateRegionRequest {
	r.parentIds = &parentIds
	return r
}

// Comma separated region ids that are children of this region
func (r ApiUpdateRegionRequest) ChildrenIds(childrenIds string) ApiUpdateRegionRequest {
	r.childrenIds = &childrenIds
	return r
}

// Comma separated postal code ids the region will include
func (r ApiUpdateRegionRequest) PostalCodeIds(postalCodeIds string) ApiUpdateRegionRequest {
	r.postalCodeIds = &postalCodeIds
	return r
}

// Sets of name,lat,long used to create new postal codes assigned to the region
func (r ApiUpdateRegionRequest) Locations(locations string) ApiUpdateRegionRequest {
	r.locations = &locations
	return r
}

// the retailer location ID that the region is associated with
func (r ApiUpdateRegionRequest) RetailerLocationId(retailerLocationId int64) ApiUpdateRegionRequest {
	r.retailerLocationId = &retailerLocationId
	return r
}

// The Visibility of the region
func (r ApiUpdateRegionRequest) Visibility(visibility string) ApiUpdateRegionRequest {
	r.visibility = &visibility
	return r
}

// the categories that the region is assigned to
func (r ApiUpdateRegionRequest) CategoryIds(categoryIds string) ApiUpdateRegionRequest {
	r.categoryIds = &categoryIds
	return r
}

// the filters that the region is assigned to
func (r ApiUpdateRegionRequest) FilterIds(filterIds string) ApiUpdateRegionRequest {
	r.filterIds = &filterIds
	return r
}

// 
func (r ApiUpdateRegionRequest) Start(start int64) ApiUpdateRegionRequest {
	r.start = &start
	return r
}

// 
func (r ApiUpdateRegionRequest) End(end int64) ApiUpdateRegionRequest {
	r.end = &end
	return r
}

// the polygon of the region
func (r ApiUpdateRegionRequest) Polygon(polygon string) ApiUpdateRegionRequest {
	r.polygon = &polygon
	return r
}

// the meta data of the region
func (r ApiUpdateRegionRequest) MetaData(metaData string) ApiUpdateRegionRequest {
	r.metaData = &metaData
	return r
}

// the latitude of the region
func (r ApiUpdateRegionRequest) Latitude(latitude float64) ApiUpdateRegionRequest {
	r.latitude = &latitude
	return r
}

// the longitude of the region
func (r ApiUpdateRegionRequest) Longitude(longitude float64) ApiUpdateRegionRequest {
	r.longitude = &longitude
	return r
}

// the version code
func (r ApiUpdateRegionRequest) VersionCode(versionCode int32) ApiUpdateRegionRequest {
	r.versionCode = &versionCode
	return r
}

// If this is a root region or not. If true means this region has no parent regions
func (r ApiUpdateRegionRequest) Root(root bool) ApiUpdateRegionRequest {
	r.root = &root
	return r
}

// Active or inactive status of the region
func (r ApiUpdateRegionRequest) Active(active bool) ApiUpdateRegionRequest {
	r.active = &active
	return r
}

// If true clear the children and postal code lists before add new ones, otherwise just append.
func (r ApiUpdateRegionRequest) ClearLists(clearLists bool) ApiUpdateRegionRequest {
	r.clearLists = &clearLists
	return r
}

func (r ApiUpdateRegionRequest) Execute() (*RegionResponse, *http.Response, error) {
	return r.ApiService.UpdateRegionExecute(r)
}

/*
UpdateRegion Update Region

Update a region.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiUpdateRegionRequest
*/
func (a *RegionAPIService) UpdateRegion(ctx context.Context, version float32) ApiUpdateRegionRequest {
	return ApiUpdateRegionRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return RegionResponse
func (a *RegionAPIService) UpdateRegionExecute(r ApiUpdateRegionRequest) (*RegionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RegionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RegionAPIService.UpdateRegion")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/region/update"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.regionId == nil {
		return localVarReturnValue, nil, reportError("regionId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "regionId", r.regionId, "form", "")
	if r.regionClass != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "regionClass", r.regionClass, "form", "")
	}
	if r.shortName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "shortName", r.shortName, "form", "")
	}
	if r.fullName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fullName", r.fullName, "form", "")
	}
	if r.parentIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parentIds", r.parentIds, "form", "")
	}
	if r.childrenIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "childrenIds", r.childrenIds, "form", "")
	}
	if r.postalCodeIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "postalCodeIds", r.postalCodeIds, "form", "")
	}
	if r.locations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locations", r.locations, "form", "")
	}
	if r.retailerLocationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "retailerLocationId", r.retailerLocationId, "form", "")
	}
	if r.visibility != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "visibility", r.visibility, "form", "")
	}
	if r.categoryIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "categoryIds", r.categoryIds, "form", "")
	}
	if r.filterIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filterIds", r.filterIds, "form", "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "form", "")
	}
	if r.polygon != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "polygon", r.polygon, "form", "")
	}
	if r.metaData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metaData", r.metaData, "form", "")
	}
	if r.latitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latitude", r.latitude, "form", "")
	}
	if r.longitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "longitude", r.longitude, "form", "")
	}
	if r.versionCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "versionCode", r.versionCode, "form", "")
	}
	if r.root != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "root", r.root, "form", "")
	}
	if r.active != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active", r.active, "form", "")
	}
	if r.clearLists != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "clearLists", r.clearLists, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
