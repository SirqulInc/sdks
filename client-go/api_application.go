/*
Sirqul IoT Platform

Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

API version: 3.16
Contact: info@sirqul.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
)


// ApplicationAPIService ApplicationAPI service
type ApplicationAPIService service

type ApiCreateApplicationRequest struct {
	ctx context.Context
	ApiService *ApplicationAPIService
	version float32
	appName *string
	deviceId *string
	accountId *int64
	about *string
	bundleId *string
	appIconAssetId *int64
	appLogoAssetId *int64
	facebookAppId *string
	facebookAppSecret *string
	googleApiKey *string
	updateEULADate *bool
	eulaVersion *string
	landingPageUrl *string
	showInActivities *bool
	activityDescription *string
	inviteWelcomeText *string
	invitePageUrl *string
	urlScheme *string
	platforms *string
	downloadUrls *string
	categoryIds *string
	scoringType *string
	hintCost *int32
	maxScore *int32
	ticketsPerPoint *float32
	hasGameData *bool
	publicNotifications *bool
	useMatchingAlgorithm *bool
	globalTickets *bool
	buildVersion *float32
	apiVersion *float32
	placementName *string
	placementDescription *string
	placementSize *string
	placementHeight *int32
	placementWidth *int32
	placementRefreshInterval *int32
	createObjectStore *bool
	publicContentApproval *bool
	productionMode *bool
	minimumSessionLength *int32
	sessionGapLength *int32
	localAdsEnabled *bool
	sqootApiKey *string
	trilatProcessingType *string
	maxSampleSize *int32
	minRSSI *float64
	modules *string
	authorizedCount *int32
	authorizedServers *string
	defaultTimezone *string
	smtpPass *string
	metaData *string
	placementMetaData *string
	ipsFloor *bool
	enableAPNSBadge *bool
	includeInReport *bool
	defaultAppFilterId *int64
	enableWelcomeEmail *bool
	appleAppId *string
	appleTeamId *string
	appleAuthKeyId *string
	appleAuthKey *os.File
	appleIssuerId *string
	appStoreKeyId *string
	appStoreKey *os.File
	googlePrivateKeyFile *os.File
	authorizeNetApiKey *string
	authorizeNetTransactionKey *string
	emailSender *string
	smtpUser *string
	smtpHost *string
	vatomBusinessId *string
	vatomRestClientId *string
	vatomRestSecretKey *string
	twilioAccountSID *string
	twilioAuthToken *string
	twilioSenderPhoneNumber *string
	openAISecretKey *string
}

// The name of the application
func (r ApiCreateApplicationRequest) AppName(appName string) ApiCreateApplicationRequest {
	r.appName = &appName
	return r
}

// The unique id of the device making the request (deviceId or accountId required)
func (r ApiCreateApplicationRequest) DeviceId(deviceId string) ApiCreateApplicationRequest {
	r.deviceId = &deviceId
	return r
}

// The account id of the user (deviceId or accountId required)
func (r ApiCreateApplicationRequest) AccountId(accountId int64) ApiCreateApplicationRequest {
	r.accountId = &accountId
	return r
}

// The description of the application
func (r ApiCreateApplicationRequest) About(about string) ApiCreateApplicationRequest {
	r.about = &about
	return r
}

// The application bundle identifier (format - com.company.appName)
func (r ApiCreateApplicationRequest) BundleId(bundleId string) ApiCreateApplicationRequest {
	r.bundleId = &bundleId
	return r
}

// The application icon asset id
func (r ApiCreateApplicationRequest) AppIconAssetId(appIconAssetId int64) ApiCreateApplicationRequest {
	r.appIconAssetId = &appIconAssetId
	return r
}

// The application logo asset id
func (r ApiCreateApplicationRequest) AppLogoAssetId(appLogoAssetId int64) ApiCreateApplicationRequest {
	r.appLogoAssetId = &appLogoAssetId
	return r
}

// The Facebook application id
func (r ApiCreateApplicationRequest) FacebookAppId(facebookAppId string) ApiCreateApplicationRequest {
	r.facebookAppId = &facebookAppId
	return r
}

// The Facebook application secret
func (r ApiCreateApplicationRequest) FacebookAppSecret(facebookAppSecret string) ApiCreateApplicationRequest {
	r.facebookAppSecret = &facebookAppSecret
	return r
}

// This is the either the &#39;server key&#39; or &#39;browser key&#39; generated from google to enable Google Cloud Messaging
func (r ApiCreateApplicationRequest) GoogleApiKey(googleApiKey string) ApiCreateApplicationRequest {
	r.googleApiKey = &googleApiKey
	return r
}

// Determines whether to update the EULA date
func (r ApiCreateApplicationRequest) UpdateEULADate(updateEULADate bool) ApiCreateApplicationRequest {
	r.updateEULADate = &updateEULADate
	return r
}

// The EULA version
func (r ApiCreateApplicationRequest) EulaVersion(eulaVersion string) ApiCreateApplicationRequest {
	r.eulaVersion = &eulaVersion
	return r
}

// The landing page URL
func (r ApiCreateApplicationRequest) LandingPageUrl(landingPageUrl string) ApiCreateApplicationRequest {
	r.landingPageUrl = &landingPageUrl
	return r
}

// Determines whether to show the application in the activity feed
func (r ApiCreateApplicationRequest) ShowInActivities(showInActivities bool) ApiCreateApplicationRequest {
	r.showInActivities = &showInActivities
	return r
}

// The description of the application in the activity feed
func (r ApiCreateApplicationRequest) ActivityDescription(activityDescription string) ApiCreateApplicationRequest {
	r.activityDescription = &activityDescription
	return r
}

// The text to display on the invite page
func (r ApiCreateApplicationRequest) InviteWelcomeText(inviteWelcomeText string) ApiCreateApplicationRequest {
	r.inviteWelcomeText = &inviteWelcomeText
	return r
}

// The url to the application invite page
func (r ApiCreateApplicationRequest) InvitePageUrl(invitePageUrl string) ApiCreateApplicationRequest {
	r.invitePageUrl = &invitePageUrl
	return r
}

// The protocal the app uses to load the app via a browser
func (r ApiCreateApplicationRequest) UrlScheme(urlScheme string) ApiCreateApplicationRequest {
	r.urlScheme = &urlScheme
	return r
}

// A json object with a list of supported platforms.  &#x60;&#x60;&#x60;json {   \&quot;platforms\&quot;: [     {       \&quot;deviceId\&quot;: 1,       \&quot;minimum\&quot;: 230,       \&quot;maximum\&quot;: 421,       \&quot;downloadUrl\&quot;: \&quot;http://app.store.com/download\&quot;,       \&quot;description\&quot;: \&quot;description and version info\&quot;     }   ] } &#x60;&#x60;&#x60; 
func (r ApiCreateApplicationRequest) Platforms(platforms string) ApiCreateApplicationRequest {
	r.platforms = &platforms
	return r
}

// Json formatted downloadUrls.  &#x60;&#x60;&#x60;json {   \&quot;ios\&quot;: \&quot;the-url-to-app-store\&quot;,    \&quot;android\&quot;: \&quot;the-url-to-google-play\&quot; } &#x60;&#x60;&#x60;  
func (r ApiCreateApplicationRequest) DownloadUrls(downloadUrls string) ApiCreateApplicationRequest {
	r.downloadUrls = &downloadUrls
	return r
}

// List of categories to apply
func (r ApiCreateApplicationRequest) CategoryIds(categoryIds string) ApiCreateApplicationRequest {
	r.categoryIds = &categoryIds
	return r
}

// The type of scoring this application will use {GAME_LEVEL, GAME_OBJECT
func (r ApiCreateApplicationRequest) ScoringType(scoringType string) ApiCreateApplicationRequest {
	r.scoringType = &scoringType
	return r
}

// The cost of hints
func (r ApiCreateApplicationRequest) HintCost(hintCost int32) ApiCreateApplicationRequest {
	r.hintCost = &hintCost
	return r
}

// The maximum score that will be possible
func (r ApiCreateApplicationRequest) MaxScore(maxScore int32) ApiCreateApplicationRequest {
	r.maxScore = &maxScore
	return r
}

// The point-to-ticket conversion ratio
func (r ApiCreateApplicationRequest) TicketsPerPoint(ticketsPerPoint float32) ApiCreateApplicationRequest {
	r.ticketsPerPoint = &ticketsPerPoint
	return r
}

// Determines whether the application uses services to save custom game objects
func (r ApiCreateApplicationRequest) HasGameData(hasGameData bool) ApiCreateApplicationRequest {
	r.hasGameData = &hasGameData
	return r
}

// Public Notifications
func (r ApiCreateApplicationRequest) PublicNotifications(publicNotifications bool) ApiCreateApplicationRequest {
	r.publicNotifications = &publicNotifications
	return r
}

// Use Matching Algorithm
func (r ApiCreateApplicationRequest) UseMatchingAlgorithm(useMatchingAlgorithm bool) ApiCreateApplicationRequest {
	r.useMatchingAlgorithm = &useMatchingAlgorithm
	return r
}

// Determines whether earned tickets are applied across all applications
func (r ApiCreateApplicationRequest) GlobalTickets(globalTickets bool) ApiCreateApplicationRequest {
	r.globalTickets = &globalTickets
	return r
}

// The current build version of the application
func (r ApiCreateApplicationRequest) BuildVersion(buildVersion float32) ApiCreateApplicationRequest {
	r.buildVersion = &buildVersion
	return r
}

// The current API version the application uses
func (r ApiCreateApplicationRequest) ApiVersion(apiVersion float32) ApiCreateApplicationRequest {
	r.apiVersion = &apiVersion
	return r
}

// The name of the placement
func (r ApiCreateApplicationRequest) PlacementName(placementName string) ApiCreateApplicationRequest {
	r.placementName = &placementName
	return r
}

// The description of the placement
func (r ApiCreateApplicationRequest) PlacementDescription(placementDescription string) ApiCreateApplicationRequest {
	r.placementDescription = &placementDescription
	return r
}

// The ad placement size {BANNER, LEADERBOARD, SKYSCRAPER, INTERSTITIAL, CUSTOM (this is required if a placements is to be created)
func (r ApiCreateApplicationRequest) PlacementSize(placementSize string) ApiCreateApplicationRequest {
	r.placementSize = &placementSize
	return r
}

// The height of a custom ad size
func (r ApiCreateApplicationRequest) PlacementHeight(placementHeight int32) ApiCreateApplicationRequest {
	r.placementHeight = &placementHeight
	return r
}

// The width of a custom ad size
func (r ApiCreateApplicationRequest) PlacementWidth(placementWidth int32) ApiCreateApplicationRequest {
	r.placementWidth = &placementWidth
	return r
}

// The refresh interval in seconds
func (r ApiCreateApplicationRequest) PlacementRefreshInterval(placementRefreshInterval int32) ApiCreateApplicationRequest {
	r.placementRefreshInterval = &placementRefreshInterval
	return r
}

// Generate a custom object store to use
func (r ApiCreateApplicationRequest) CreateObjectStore(createObjectStore bool) ApiCreateApplicationRequest {
	r.createObjectStore = &createObjectStore
	return r
}

// Determine whether or not public content requires admin approval before it becomes public
func (r ApiCreateApplicationRequest) PublicContentApproval(publicContentApproval bool) ApiCreateApplicationRequest {
	r.publicContentApproval = &publicContentApproval
	return r
}

// Determines whether the application uses production or sandbox services
func (r ApiCreateApplicationRequest) ProductionMode(productionMode bool) ApiCreateApplicationRequest {
	r.productionMode = &productionMode
	return r
}

// Minimum Session Length
func (r ApiCreateApplicationRequest) MinimumSessionLength(minimumSessionLength int32) ApiCreateApplicationRequest {
	r.minimumSessionLength = &minimumSessionLength
	return r
}

// Session Gap Length
func (r ApiCreateApplicationRequest) SessionGapLength(sessionGapLength int32) ApiCreateApplicationRequest {
	r.sessionGapLength = &sessionGapLength
	return r
}

// Local Ads Enabled
func (r ApiCreateApplicationRequest) LocalAdsEnabled(localAdsEnabled bool) ApiCreateApplicationRequest {
	r.localAdsEnabled = &localAdsEnabled
	return r
}

// Sqoot Api Key
func (r ApiCreateApplicationRequest) SqootApiKey(sqootApiKey string) ApiCreateApplicationRequest {
	r.sqootApiKey = &sqootApiKey
	return r
}

// Determines how to process trilateration data. Possible values include: DEFAULT, FINGERPRINT
func (r ApiCreateApplicationRequest) TrilatProcessingType(trilatProcessingType string) ApiCreateApplicationRequest {
	r.trilatProcessingType = &trilatProcessingType
	return r
}

// Determines what the maximum sample size during trilateration
func (r ApiCreateApplicationRequest) MaxSampleSize(maxSampleSize int32) ApiCreateApplicationRequest {
	r.maxSampleSize = &maxSampleSize
	return r
}

// Determines what the minimum acceptable RSSI value
func (r ApiCreateApplicationRequest) MinRSSI(minRSSI float64) ApiCreateApplicationRequest {
	r.minRSSI = &minRSSI
	return r
}

// List modules allowed to be served by the server, possible values include: COMMON, MEDIA, OFFER, GAME, SOCIAL, CONSUMER_WEBSITE, ALL
func (r ApiCreateApplicationRequest) Modules(modules string) ApiCreateApplicationRequest {
	r.modules = &modules
	return r
}

// How many servers the license will support
func (r ApiCreateApplicationRequest) AuthorizedCount(authorizedCount int32) ApiCreateApplicationRequest {
	r.authorizedCount = &authorizedCount
	return r
}

// The list of ip addresses of servers the license will support, leave null for any server
func (r ApiCreateApplicationRequest) AuthorizedServers(authorizedServers string) ApiCreateApplicationRequest {
	r.authorizedServers = &authorizedServers
	return r
}

// Sets the default timezone for the app (used for leaderboards and other time specific content)
func (r ApiCreateApplicationRequest) DefaultTimezone(defaultTimezone string) ApiCreateApplicationRequest {
	r.defaultTimezone = &defaultTimezone
	return r
}

// SMTP Pass
func (r ApiCreateApplicationRequest) SmtpPass(smtpPass string) ApiCreateApplicationRequest {
	r.smtpPass = &smtpPass
	return r
}

// The application meta data. Defined by the client
func (r ApiCreateApplicationRequest) MetaData(metaData string) ApiCreateApplicationRequest {
	r.metaData = &metaData
	return r
}

// The ad placement meta data. Defined by the client
func (r ApiCreateApplicationRequest) PlacementMetaData(placementMetaData string) ApiCreateApplicationRequest {
	r.placementMetaData = &placementMetaData
	return r
}

// Create floor tables for Ips
func (r ApiCreateApplicationRequest) IpsFloor(ipsFloor bool) ApiCreateApplicationRequest {
	r.ipsFloor = &ipsFloor
	return r
}

// Enables setting the APNS badge value in the payload
func (r ApiCreateApplicationRequest) EnableAPNSBadge(enableAPNSBadge bool) ApiCreateApplicationRequest {
	r.enableAPNSBadge = &enableAPNSBadge
	return r
}

// Enables using the application in session reports
func (r ApiCreateApplicationRequest) IncludeInReport(includeInReport bool) ApiCreateApplicationRequest {
	r.includeInReport = &includeInReport
	return r
}

// Sets the default filter to use (if none is passed in) for certain search APIs including Album Search.
func (r ApiCreateApplicationRequest) DefaultAppFilterId(defaultAppFilterId int64) ApiCreateApplicationRequest {
	r.defaultAppFilterId = &defaultAppFilterId
	return r
}

// Enables whether the default welcome email will be sent for new app users
func (r ApiCreateApplicationRequest) EnableWelcomeEmail(enableWelcomeEmail bool) ApiCreateApplicationRequest {
	r.enableWelcomeEmail = &enableWelcomeEmail
	return r
}

// The Apple Application ID
func (r ApiCreateApplicationRequest) AppleAppId(appleAppId string) ApiCreateApplicationRequest {
	r.appleAppId = &appleAppId
	return r
}

// The Apple Team ID
func (r ApiCreateApplicationRequest) AppleTeamId(appleTeamId string) ApiCreateApplicationRequest {
	r.appleTeamId = &appleTeamId
	return r
}

// The Apple Auth Key ID
func (r ApiCreateApplicationRequest) AppleAuthKeyId(appleAuthKeyId string) ApiCreateApplicationRequest {
	r.appleAuthKeyId = &appleAuthKeyId
	return r
}

// The Apple Auth Signin Key (p8) File
func (r ApiCreateApplicationRequest) AppleAuthKey(appleAuthKey *os.File) ApiCreateApplicationRequest {
	r.appleAuthKey = appleAuthKey
	return r
}

// The Apple Issuer ID
func (r ApiCreateApplicationRequest) AppleIssuerId(appleIssuerId string) ApiCreateApplicationRequest {
	r.appleIssuerId = &appleIssuerId
	return r
}

// The Apple App Store Key ID
func (r ApiCreateApplicationRequest) AppStoreKeyId(appStoreKeyId string) ApiCreateApplicationRequest {
	r.appStoreKeyId = &appStoreKeyId
	return r
}

// The Apple App Store Key (p8) File
func (r ApiCreateApplicationRequest) AppStoreKey(appStoreKey *os.File) ApiCreateApplicationRequest {
	r.appStoreKey = appStoreKey
	return r
}

// This is the private key file for your Google service account.
func (r ApiCreateApplicationRequest) GooglePrivateKeyFile(googlePrivateKeyFile *os.File) ApiCreateApplicationRequest {
	r.googlePrivateKeyFile = googlePrivateKeyFile
	return r
}

// Authorize Net Api Key
func (r ApiCreateApplicationRequest) AuthorizeNetApiKey(authorizeNetApiKey string) ApiCreateApplicationRequest {
	r.authorizeNetApiKey = &authorizeNetApiKey
	return r
}

// Authorize Net Transaction Key
func (r ApiCreateApplicationRequest) AuthorizeNetTransactionKey(authorizeNetTransactionKey string) ApiCreateApplicationRequest {
	r.authorizeNetTransactionKey = &authorizeNetTransactionKey
	return r
}

// Email Sender
func (r ApiCreateApplicationRequest) EmailSender(emailSender string) ApiCreateApplicationRequest {
	r.emailSender = &emailSender
	return r
}

// SMTP User
func (r ApiCreateApplicationRequest) SmtpUser(smtpUser string) ApiCreateApplicationRequest {
	r.smtpUser = &smtpUser
	return r
}

// SMTP Host
func (r ApiCreateApplicationRequest) SmtpHost(smtpHost string) ApiCreateApplicationRequest {
	r.smtpHost = &smtpHost
	return r
}

// Vatom Business Id
func (r ApiCreateApplicationRequest) VatomBusinessId(vatomBusinessId string) ApiCreateApplicationRequest {
	r.vatomBusinessId = &vatomBusinessId
	return r
}

// Vatom REST Client Id
func (r ApiCreateApplicationRequest) VatomRestClientId(vatomRestClientId string) ApiCreateApplicationRequest {
	r.vatomRestClientId = &vatomRestClientId
	return r
}

// Vatom Secret Key
func (r ApiCreateApplicationRequest) VatomRestSecretKey(vatomRestSecretKey string) ApiCreateApplicationRequest {
	r.vatomRestSecretKey = &vatomRestSecretKey
	return r
}

// Twilio Account SID
func (r ApiCreateApplicationRequest) TwilioAccountSID(twilioAccountSID string) ApiCreateApplicationRequest {
	r.twilioAccountSID = &twilioAccountSID
	return r
}

// Twilio Auth Token
func (r ApiCreateApplicationRequest) TwilioAuthToken(twilioAuthToken string) ApiCreateApplicationRequest {
	r.twilioAuthToken = &twilioAuthToken
	return r
}

// Twilio Sender Phone Number
func (r ApiCreateApplicationRequest) TwilioSenderPhoneNumber(twilioSenderPhoneNumber string) ApiCreateApplicationRequest {
	r.twilioSenderPhoneNumber = &twilioSenderPhoneNumber
	return r
}

// OpenAI Secret API Key
func (r ApiCreateApplicationRequest) OpenAISecretKey(openAISecretKey string) ApiCreateApplicationRequest {
	r.openAISecretKey = &openAISecretKey
	return r
}

func (r ApiCreateApplicationRequest) Execute() (*ApplicationResponse, *http.Response, error) {
	return r.ApiService.CreateApplicationExecute(r)
}

/*
CreateApplication Create Application

Create an application record and one placement record for that application. You can create more placements for this application by using {@link createApplicationPlacement}.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiCreateApplicationRequest
*/
func (a *ApplicationAPIService) CreateApplication(ctx context.Context, version float32) ApiCreateApplicationRequest {
	return ApiCreateApplicationRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return ApplicationResponse
func (a *ApplicationAPIService) CreateApplicationExecute(r ApiCreateApplicationRequest) (*ApplicationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApplicationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationAPIService.CreateApplication")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/application/create"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.appName == nil {
		return localVarReturnValue, nil, reportError("appName is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "appName", r.appName, "form", "")
	if r.about != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "about", r.about, "form", "")
	}
	if r.bundleId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bundleId", r.bundleId, "form", "")
	}
	if r.appIconAssetId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appIconAssetId", r.appIconAssetId, "form", "")
	}
	if r.appLogoAssetId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appLogoAssetId", r.appLogoAssetId, "form", "")
	}
	if r.facebookAppId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "facebookAppId", r.facebookAppId, "form", "")
	}
	if r.facebookAppSecret != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "facebookAppSecret", r.facebookAppSecret, "form", "")
	}
	if r.googleApiKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "googleApiKey", r.googleApiKey, "form", "")
	}
	if r.updateEULADate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateEULADate", r.updateEULADate, "form", "")
	}
	if r.eulaVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "eulaVersion", r.eulaVersion, "form", "")
	}
	if r.landingPageUrl != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "landingPageUrl", r.landingPageUrl, "form", "")
	}
	if r.showInActivities != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "showInActivities", r.showInActivities, "form", "")
	}
	if r.activityDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activityDescription", r.activityDescription, "form", "")
	}
	if r.inviteWelcomeText != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inviteWelcomeText", r.inviteWelcomeText, "form", "")
	}
	if r.invitePageUrl != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "invitePageUrl", r.invitePageUrl, "form", "")
	}
	if r.urlScheme != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "urlScheme", r.urlScheme, "form", "")
	}
	if r.platforms != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "platforms", r.platforms, "form", "")
	}
	if r.downloadUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "downloadUrls", r.downloadUrls, "form", "")
	}
	if r.categoryIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "categoryIds", r.categoryIds, "form", "")
	}
	if r.scoringType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scoringType", r.scoringType, "form", "")
	} else {
		var defaultValue string = "GAME_LEVEL"
		parameterAddToHeaderOrQuery(localVarQueryParams, "scoringType", defaultValue, "form", "")
		r.scoringType = &defaultValue
	}
	if r.hintCost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hintCost", r.hintCost, "form", "")
	} else {
		var defaultValue int32 = 11
		parameterAddToHeaderOrQuery(localVarQueryParams, "hintCost", defaultValue, "form", "")
		r.hintCost = &defaultValue
	}
	if r.maxScore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxScore", r.maxScore, "form", "")
	} else {
		var defaultValue int32 = 125
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxScore", defaultValue, "form", "")
		r.maxScore = &defaultValue
	}
	if r.ticketsPerPoint != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ticketsPerPoint", r.ticketsPerPoint, "form", "")
	} else {
		var defaultValue float32 = 0.037
		parameterAddToHeaderOrQuery(localVarQueryParams, "ticketsPerPoint", defaultValue, "form", "")
		r.ticketsPerPoint = &defaultValue
	}
	if r.hasGameData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hasGameData", r.hasGameData, "form", "")
	} else {
		var defaultValue bool = true
		parameterAddToHeaderOrQuery(localVarQueryParams, "hasGameData", defaultValue, "form", "")
		r.hasGameData = &defaultValue
	}
	if r.publicNotifications != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "publicNotifications", r.publicNotifications, "form", "")
	}
	if r.useMatchingAlgorithm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "useMatchingAlgorithm", r.useMatchingAlgorithm, "form", "")
	}
	if r.globalTickets != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "globalTickets", r.globalTickets, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "globalTickets", defaultValue, "form", "")
		r.globalTickets = &defaultValue
	}
	if r.buildVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "buildVersion", r.buildVersion, "form", "")
	} else {
		var defaultValue float32 = 1
		parameterAddToHeaderOrQuery(localVarQueryParams, "buildVersion", defaultValue, "form", "")
		r.buildVersion = &defaultValue
	}
	if r.apiVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "apiVersion", r.apiVersion, "form", "")
	}
	if r.placementName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "placementName", r.placementName, "form", "")
	}
	if r.placementDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "placementDescription", r.placementDescription, "form", "")
	}
	if r.placementSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "placementSize", r.placementSize, "form", "")
	}
	if r.placementHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "placementHeight", r.placementHeight, "form", "")
	}
	if r.placementWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "placementWidth", r.placementWidth, "form", "")
	}
	if r.placementRefreshInterval != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "placementRefreshInterval", r.placementRefreshInterval, "form", "")
	}
	if r.createObjectStore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createObjectStore", r.createObjectStore, "form", "")
	} else {
		var defaultValue bool = true
		parameterAddToHeaderOrQuery(localVarQueryParams, "createObjectStore", defaultValue, "form", "")
		r.createObjectStore = &defaultValue
	}
	if r.publicContentApproval != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "publicContentApproval", r.publicContentApproval, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "publicContentApproval", defaultValue, "form", "")
		r.publicContentApproval = &defaultValue
	}
	if r.productionMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "productionMode", r.productionMode, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "productionMode", defaultValue, "form", "")
		r.productionMode = &defaultValue
	}
	if r.minimumSessionLength != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "minimumSessionLength", r.minimumSessionLength, "form", "")
	}
	if r.sessionGapLength != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sessionGapLength", r.sessionGapLength, "form", "")
	}
	if r.localAdsEnabled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "localAdsEnabled", r.localAdsEnabled, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "localAdsEnabled", defaultValue, "form", "")
		r.localAdsEnabled = &defaultValue
	}
	if r.sqootApiKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sqootApiKey", r.sqootApiKey, "form", "")
	}
	if r.trilatProcessingType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "trilatProcessingType", r.trilatProcessingType, "form", "")
	} else {
		var defaultValue string = "FINGERPRINT"
		parameterAddToHeaderOrQuery(localVarQueryParams, "trilatProcessingType", defaultValue, "form", "")
		r.trilatProcessingType = &defaultValue
	}
	if r.maxSampleSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxSampleSize", r.maxSampleSize, "form", "")
	}
	if r.minRSSI != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "minRSSI", r.minRSSI, "form", "")
	}
	if r.modules != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modules", r.modules, "form", "")
	} else {
		var defaultValue string = "ALL"
		parameterAddToHeaderOrQuery(localVarQueryParams, "modules", defaultValue, "form", "")
		r.modules = &defaultValue
	}
	if r.authorizedCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "authorizedCount", r.authorizedCount, "form", "")
	} else {
		var defaultValue int32 = 1
		parameterAddToHeaderOrQuery(localVarQueryParams, "authorizedCount", defaultValue, "form", "")
		r.authorizedCount = &defaultValue
	}
	if r.authorizedServers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "authorizedServers", r.authorizedServers, "form", "")
	}
	if r.defaultTimezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "defaultTimezone", r.defaultTimezone, "form", "")
	}
	if r.smtpPass != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "smtpPass", r.smtpPass, "form", "")
	}
	if r.metaData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metaData", r.metaData, "form", "")
	}
	if r.placementMetaData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "placementMetaData", r.placementMetaData, "form", "")
	}
	if r.ipsFloor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ipsFloor", r.ipsFloor, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "ipsFloor", defaultValue, "form", "")
		r.ipsFloor = &defaultValue
	}
	if r.enableAPNSBadge != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableAPNSBadge", r.enableAPNSBadge, "form", "")
	} else {
		var defaultValue bool = true
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableAPNSBadge", defaultValue, "form", "")
		r.enableAPNSBadge = &defaultValue
	}
	if r.includeInReport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInReport", r.includeInReport, "form", "")
	} else {
		var defaultValue bool = true
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInReport", defaultValue, "form", "")
		r.includeInReport = &defaultValue
	}
	if r.defaultAppFilterId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "defaultAppFilterId", r.defaultAppFilterId, "form", "")
	}
	if r.enableWelcomeEmail != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableWelcomeEmail", r.enableWelcomeEmail, "form", "")
	}
	if r.appleAppId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appleAppId", r.appleAppId, "form", "")
	}
	if r.appleTeamId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appleTeamId", r.appleTeamId, "form", "")
	}
	if r.appleAuthKeyId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appleAuthKeyId", r.appleAuthKeyId, "form", "")
	}
	if r.appleAuthKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appleAuthKey", r.appleAuthKey, "form", "")
	}
	if r.appleIssuerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appleIssuerId", r.appleIssuerId, "form", "")
	}
	if r.appStoreKeyId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appStoreKeyId", r.appStoreKeyId, "form", "")
	}
	if r.appStoreKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appStoreKey", r.appStoreKey, "form", "")
	}
	if r.googlePrivateKeyFile != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "googlePrivateKeyFile", r.googlePrivateKeyFile, "form", "")
	}
	if r.authorizeNetApiKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "authorizeNetApiKey", r.authorizeNetApiKey, "form", "")
	}
	if r.authorizeNetTransactionKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "authorizeNetTransactionKey", r.authorizeNetTransactionKey, "form", "")
	}
	if r.emailSender != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailSender", r.emailSender, "form", "")
	}
	if r.smtpUser != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "smtpUser", r.smtpUser, "form", "")
	}
	if r.smtpHost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "smtpHost", r.smtpHost, "form", "")
	}
	if r.vatomBusinessId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vatomBusinessId", r.vatomBusinessId, "form", "")
	}
	if r.vatomRestClientId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vatomRestClientId", r.vatomRestClientId, "form", "")
	}
	if r.vatomRestSecretKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vatomRestSecretKey", r.vatomRestSecretKey, "form", "")
	}
	if r.twilioAccountSID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "twilioAccountSID", r.twilioAccountSID, "form", "")
	}
	if r.twilioAuthToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "twilioAuthToken", r.twilioAuthToken, "form", "")
	}
	if r.twilioSenderPhoneNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "twilioSenderPhoneNumber", r.twilioSenderPhoneNumber, "form", "")
	}
	if r.openAISecretKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "openAISecretKey", r.openAISecretKey, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateApplicationPlacementRequest struct {
	ctx context.Context
	ApiService *ApplicationAPIService
	version float32
	appKey *string
	size *string
	deviceId *string
	accountId *int64
	name *string
	description *string
	height *int32
	width *int32
	refreshInterval *int32
	defaultImageId *int64
	active *bool
}

// The appKey of the application the ad placement is for
func (r ApiCreateApplicationPlacementRequest) AppKey(appKey string) ApiCreateApplicationPlacementRequest {
	r.appKey = &appKey
	return r
}

// The ad placement size {BANNER, LEADERBOARD, SKYSCRAPER, INTERSTITIAL, CUSTOM
func (r ApiCreateApplicationPlacementRequest) Size(size string) ApiCreateApplicationPlacementRequest {
	r.size = &size
	return r
}

// The unique id of the device making the request (deviceId or accountId required)
func (r ApiCreateApplicationPlacementRequest) DeviceId(deviceId string) ApiCreateApplicationPlacementRequest {
	r.deviceId = &deviceId
	return r
}

// The account id of the user (deviceId or accountId required)
func (r ApiCreateApplicationPlacementRequest) AccountId(accountId int64) ApiCreateApplicationPlacementRequest {
	r.accountId = &accountId
	return r
}

// The name of the placement
func (r ApiCreateApplicationPlacementRequest) Name(name string) ApiCreateApplicationPlacementRequest {
	r.name = &name
	return r
}

// The description of the placement
func (r ApiCreateApplicationPlacementRequest) Description(description string) ApiCreateApplicationPlacementRequest {
	r.description = &description
	return r
}

// The height of a custom ad size
func (r ApiCreateApplicationPlacementRequest) Height(height int32) ApiCreateApplicationPlacementRequest {
	r.height = &height
	return r
}

// The width of a custom ad size
func (r ApiCreateApplicationPlacementRequest) Width(width int32) ApiCreateApplicationPlacementRequest {
	r.width = &width
	return r
}

// The refresh interval in seconds
func (r ApiCreateApplicationPlacementRequest) RefreshInterval(refreshInterval int32) ApiCreateApplicationPlacementRequest {
	r.refreshInterval = &refreshInterval
	return r
}

// Default Image Id
func (r ApiCreateApplicationPlacementRequest) DefaultImageId(defaultImageId int64) ApiCreateApplicationPlacementRequest {
	r.defaultImageId = &defaultImageId
	return r
}

// Active
func (r ApiCreateApplicationPlacementRequest) Active(active bool) ApiCreateApplicationPlacementRequest {
	r.active = &active
	return r
}

func (r ApiCreateApplicationPlacementRequest) Execute() (*PlacementResponse, *http.Response, error) {
	return r.ApiService.CreateApplicationPlacementExecute(r)
}

/*
CreateApplicationPlacement Create Ad Placement

Creates a new ad placement for an application.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiCreateApplicationPlacementRequest
*/
func (a *ApplicationAPIService) CreateApplicationPlacement(ctx context.Context, version float32) ApiCreateApplicationPlacementRequest {
	return ApiCreateApplicationPlacementRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return PlacementResponse
func (a *ApplicationAPIService) CreateApplicationPlacementExecute(r ApiCreateApplicationPlacementRequest) (*PlacementResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PlacementResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationAPIService.CreateApplicationPlacement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/application/placement/create"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.appKey == nil {
		return localVarReturnValue, nil, reportError("appKey is required and must be specified")
	}
	if r.size == nil {
		return localVarReturnValue, nil, reportError("size is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.refreshInterval != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refreshInterval", r.refreshInterval, "form", "")
	}
	if r.defaultImageId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "defaultImageId", r.defaultImageId, "form", "")
	}
	if r.active != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active", r.active, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteApplicationRequest struct {
	ctx context.Context
	ApiService *ApplicationAPIService
	version float32
	accountId *int64
	appKey *string
}

// The account used to perform the delete, must have rights to edit the application.
func (r ApiDeleteApplicationRequest) AccountId(accountId int64) ApiDeleteApplicationRequest {
	r.accountId = &accountId
	return r
}

// The key of the application to be deleted
func (r ApiDeleteApplicationRequest) AppKey(appKey string) ApiDeleteApplicationRequest {
	r.appKey = &appKey
	return r
}

func (r ApiDeleteApplicationRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.DeleteApplicationExecute(r)
}

/*
DeleteApplication Delete Application

Set the deleted timestamp to current time. This effectively deletes the application since all queries should ignore any records with a deleted timestamp

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiDeleteApplicationRequest
*/
func (a *ApplicationAPIService) DeleteApplication(ctx context.Context, version float32) ApiDeleteApplicationRequest {
	return ApiDeleteApplicationRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *ApplicationAPIService) DeleteApplicationExecute(r ApiDeleteApplicationRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationAPIService.DeleteApplication")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/application/delete"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteApplicationPlacementRequest struct {
	ctx context.Context
	ApiService *ApplicationAPIService
	version float32
	placementId *int64
	deviceId *string
	accountId *int64
}

// The id of the placement to delete, the user must have rights to the application the ad placement is for
func (r ApiDeleteApplicationPlacementRequest) PlacementId(placementId int64) ApiDeleteApplicationPlacementRequest {
	r.placementId = &placementId
	return r
}

// The unique id of the device making the request (deviceId or accountId required)
func (r ApiDeleteApplicationPlacementRequest) DeviceId(deviceId string) ApiDeleteApplicationPlacementRequest {
	r.deviceId = &deviceId
	return r
}

// The account id of the user (deviceId or accountId required)
func (r ApiDeleteApplicationPlacementRequest) AccountId(accountId int64) ApiDeleteApplicationPlacementRequest {
	r.accountId = &accountId
	return r
}

func (r ApiDeleteApplicationPlacementRequest) Execute() (*PlacementResponse, *http.Response, error) {
	return r.ApiService.DeleteApplicationPlacementExecute(r)
}

/*
DeleteApplicationPlacement Delete Ad Placement

Deletes an ad placement for an application.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiDeleteApplicationPlacementRequest
*/
func (a *ApplicationAPIService) DeleteApplicationPlacement(ctx context.Context, version float32) ApiDeleteApplicationPlacementRequest {
	return ApiDeleteApplicationPlacementRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return PlacementResponse
func (a *ApplicationAPIService) DeleteApplicationPlacementExecute(r ApiDeleteApplicationPlacementRequest) (*PlacementResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PlacementResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationAPIService.DeleteApplicationPlacement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/application/placement/delete"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.placementId == nil {
		return localVarReturnValue, nil, reportError("placementId is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "placementId", r.placementId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetApplicationRequest struct {
	ctx context.Context
	ApiService *ApplicationAPIService
	version float32
	appKey *string
	applicationId *int64
}

// The key of the application
func (r ApiGetApplicationRequest) AppKey(appKey string) ApiGetApplicationRequest {
	r.appKey = &appKey
	return r
}

// Application Id
func (r ApiGetApplicationRequest) ApplicationId(applicationId int64) ApiGetApplicationRequest {
	r.applicationId = &applicationId
	return r
}

func (r ApiGetApplicationRequest) Execute() (*ApplicationResponse, *http.Response, error) {
	return r.ApiService.GetApplicationExecute(r)
}

/*
GetApplication Get Application

Get a specific application by appKey

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiGetApplicationRequest
*/
func (a *ApplicationAPIService) GetApplication(ctx context.Context, version float32) ApiGetApplicationRequest {
	return ApiGetApplicationRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return ApplicationResponse
func (a *ApplicationAPIService) GetApplicationExecute(r ApiGetApplicationRequest) (*ApplicationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApplicationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationAPIService.GetApplication")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/application/get"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	if r.applicationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "applicationId", r.applicationId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetApplicationPlacementRequest struct {
	ctx context.Context
	ApiService *ApplicationAPIService
	version float32
	placementId *int64
	deviceId *string
	accountId *int64
}

// The id of the placement
func (r ApiGetApplicationPlacementRequest) PlacementId(placementId int64) ApiGetApplicationPlacementRequest {
	r.placementId = &placementId
	return r
}

// The unique id of the device making the request (deviceId or accountId required)
func (r ApiGetApplicationPlacementRequest) DeviceId(deviceId string) ApiGetApplicationPlacementRequest {
	r.deviceId = &deviceId
	return r
}

// The account id of the user (deviceId or accountId required)
func (r ApiGetApplicationPlacementRequest) AccountId(accountId int64) ApiGetApplicationPlacementRequest {
	r.accountId = &accountId
	return r
}

func (r ApiGetApplicationPlacementRequest) Execute() (*PlacementResponse, *http.Response, error) {
	return r.ApiService.GetApplicationPlacementExecute(r)
}

/*
GetApplicationPlacement Get Ad Placement

Get details of an ad placement

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiGetApplicationPlacementRequest
*/
func (a *ApplicationAPIService) GetApplicationPlacement(ctx context.Context, version float32) ApiGetApplicationPlacementRequest {
	return ApiGetApplicationPlacementRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return PlacementResponse
func (a *ApplicationAPIService) GetApplicationPlacementExecute(r ApiGetApplicationPlacementRequest) (*PlacementResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PlacementResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationAPIService.GetApplicationPlacement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/application/placement/get"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.placementId == nil {
		return localVarReturnValue, nil, reportError("placementId is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "placementId", r.placementId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetApplicationVersionsRequest struct {
	ctx context.Context
	ApiService *ApplicationAPIService
	version float32
}

func (r ApiGetApplicationVersionsRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.GetApplicationVersionsExecute(r)
}

/*
GetApplicationVersions Get API versions

Will return a comma separated list of numbers, newest first. For example: 3.0, 2.2, 2.1, 1.8

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiGetApplicationVersionsRequest
*/
func (a *ApplicationAPIService) GetApplicationVersions(ctx context.Context, version float32) ApiGetApplicationVersionsRequest {
	return ApiGetApplicationVersionsRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *ApplicationAPIService) GetApplicationVersionsExecute(r ApiGetApplicationVersionsRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationAPIService.GetApplicationVersions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/application/versions"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUniqueUsersByAppRequest struct {
	ctx context.Context
	ApiService *ApplicationAPIService
	version float32
	appKey *string
	q *string
	keyword *string
	since *int64
	i *int32
	start *int32
	l *int32
	limit *int32
}

// The application key
func (r ApiGetUniqueUsersByAppRequest) AppKey(appKey string) ApiGetUniqueUsersByAppRequest {
	r.appKey = &appKey
	return r
}

// Q
// Deprecated
func (r ApiGetUniqueUsersByAppRequest) Q(q string) ApiGetUniqueUsersByAppRequest {
	r.q = &q
	return r
}

// The keyword used to search
func (r ApiGetUniqueUsersByAppRequest) Keyword(keyword string) ApiGetUniqueUsersByAppRequest {
	r.keyword = &keyword
	return r
}

// Return accounts that have been active after this date (UNIX time-stamp in milliseconds)
func (r ApiGetUniqueUsersByAppRequest) Since(since int64) ApiGetUniqueUsersByAppRequest {
	r.since = &since
	return r
}

// the start of the index
// Deprecated
func (r ApiGetUniqueUsersByAppRequest) I(i int32) ApiGetUniqueUsersByAppRequest {
	r.i = &i
	return r
}

// The start of the pagination
func (r ApiGetUniqueUsersByAppRequest) Start(start int32) ApiGetUniqueUsersByAppRequest {
	r.start = &start
	return r
}

// the limit of the index
// Deprecated
func (r ApiGetUniqueUsersByAppRequest) L(l int32) ApiGetUniqueUsersByAppRequest {
	r.l = &l
	return r
}

// The limit of the pagination
func (r ApiGetUniqueUsersByAppRequest) Limit(limit int32) ApiGetUniqueUsersByAppRequest {
	r.limit = &limit
	return r
}

func (r ApiGetUniqueUsersByAppRequest) Execute() (*AccountListResponse, *http.Response, error) {
	return r.ApiService.GetUniqueUsersByAppExecute(r)
}

/*
GetUniqueUsersByApp Search Application Users

Get a list of users per application

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiGetUniqueUsersByAppRequest
*/
func (a *ApplicationAPIService) GetUniqueUsersByApp(ctx context.Context, version float32) ApiGetUniqueUsersByAppRequest {
	return ApiGetUniqueUsersByAppRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return AccountListResponse
func (a *ApplicationAPIService) GetUniqueUsersByAppExecute(r ApiGetUniqueUsersByAppRequest) (*AccountListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AccountListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationAPIService.GetUniqueUsersByApp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/application/users"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.appKey == nil {
		return localVarReturnValue, nil, reportError("appKey is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.keyword != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyword", r.keyword, "form", "")
	}
	if r.since != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "since", r.since, "form", "")
	}
	if r.i != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "_i", r.i, "form", "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	} else {
		var defaultValue int32 = 0
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", defaultValue, "form", "")
		r.start = &defaultValue
	}
	if r.l != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "_l", r.l, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 20
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListApplicationsRequest struct {
	ctx context.Context
	ApiService *ApplicationAPIService
	version float32
	accountId *int64
	q *string
	keyword *string
	platforms *string
	deviceIds *string
	deviceVersions *string
	categoryIds *string
	sortField *string
	hasAds *bool
	publicNotifications *bool
	filterBillable *bool
	filterContentAdmin *bool
	descending *bool
	i *int32
	start *int32
	l *int32
	limit *int32
	applicationIds *string
	hasObjectStore *bool
	activeOnly *bool
}

// The account id of the application owner/manager
func (r ApiListApplicationsRequest) AccountId(accountId int64) ApiListApplicationsRequest {
	r.accountId = &accountId
	return r
}

// Q
// Deprecated
func (r ApiListApplicationsRequest) Q(q string) ApiListApplicationsRequest {
	r.q = &q
	return r
}

// The keyword used to search for title, about, and description fields
func (r ApiListApplicationsRequest) Keyword(keyword string) ApiListApplicationsRequest {
	r.keyword = &keyword
	return r
}

// Deprecated, use deviceIds and deviceVersions
func (r ApiListApplicationsRequest) Platforms(platforms string) ApiListApplicationsRequest {
	r.platforms = &platforms
	return r
}

// The list of targeted device ids, comma separated; possible values are retreived via /api/{version/audience/devices com.sirqul.geoapps.common.service.AudienceApi#getDevices getDevices (pass in deviceId values)
func (r ApiListApplicationsRequest) DeviceIds(deviceIds string) ApiListApplicationsRequest {
	r.deviceIds = &deviceIds
	return r
}

// The list of targeted device version ranges that are aligned  with the provided devices list (see devices param for possible values),  comma separated; examples are: 2.3-X, 0-5.1.4, 4.3.1-6.1.4 where X  is no maximum and 0 is no minimum. 
func (r ApiListApplicationsRequest) DeviceVersions(deviceVersions string) ApiListApplicationsRequest {
	r.deviceVersions = &deviceVersions
	return r
}

// The list of category ids to filter the list by
func (r ApiListApplicationsRequest) CategoryIds(categoryIds string) ApiListApplicationsRequest {
	r.categoryIds = &categoryIds
	return r
}

// The column to sort the search on, possible values include: UPDATED (default), CREATED, TITLE
func (r ApiListApplicationsRequest) SortField(sortField string) ApiListApplicationsRequest {
	r.sortField = &sortField
	return r
}

// Filter results on whether the application supports ads or not. Ignore this parameter to return all results.
func (r ApiListApplicationsRequest) HasAds(hasAds bool) ApiListApplicationsRequest {
	r.hasAds = &hasAds
	return r
}

// Filter results on whether the application is available for public trigger notifications
func (r ApiListApplicationsRequest) PublicNotifications(publicNotifications bool) ApiListApplicationsRequest {
	r.publicNotifications = &publicNotifications
	return r
}

// Determines whether to only return applications that the user has access to
func (r ApiListApplicationsRequest) FilterBillable(filterBillable bool) ApiListApplicationsRequest {
	r.filterBillable = &filterBillable
	return r
}

// Determines whether to only return applications that the user is a content admin of
func (r ApiListApplicationsRequest) FilterContentAdmin(filterContentAdmin bool) ApiListApplicationsRequest {
	r.filterContentAdmin = &filterContentAdmin
	return r
}

// The order to return the search results
func (r ApiListApplicationsRequest) Descending(descending bool) ApiListApplicationsRequest {
	r.descending = &descending
	return r
}

// the start of the index
// Deprecated
func (r ApiListApplicationsRequest) I(i int32) ApiListApplicationsRequest {
	r.i = &i
	return r
}

// The start of the pagination
func (r ApiListApplicationsRequest) Start(start int32) ApiListApplicationsRequest {
	r.start = &start
	return r
}

// The limit of the index
// Deprecated
func (r ApiListApplicationsRequest) L(l int32) ApiListApplicationsRequest {
	r.l = &l
	return r
}

// The limit of the pagination
func (r ApiListApplicationsRequest) Limit(limit int32) ApiListApplicationsRequest {
	r.limit = &limit
	return r
}

// The list of application ids, comma separated. If provided will ignore all other params.
func (r ApiListApplicationsRequest) ApplicationIds(applicationIds string) ApiListApplicationsRequest {
	r.applicationIds = &applicationIds
	return r
}

// Only include applications with a object store (default is false)
func (r ApiListApplicationsRequest) HasObjectStore(hasObjectStore bool) ApiListApplicationsRequest {
	r.hasObjectStore = &hasObjectStore
	return r
}

// Return only active results
func (r ApiListApplicationsRequest) ActiveOnly(activeOnly bool) ApiListApplicationsRequest {
	r.activeOnly = &activeOnly
	return r
}

func (r ApiListApplicationsRequest) Execute() ([]ApplicationShortResponse, *http.Response, error) {
	return r.ApiService.ListApplicationsExecute(r)
}

/*
ListApplications List Applications

List active applications matching the criteria (as a consumer)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiListApplicationsRequest
*/
func (a *ApplicationAPIService) ListApplications(ctx context.Context, version float32) ApiListApplicationsRequest {
	return ApiListApplicationsRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return []ApplicationShortResponse
func (a *ApplicationAPIService) ListApplicationsExecute(r ApiListApplicationsRequest) ([]ApplicationShortResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ApplicationShortResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationAPIService.ListApplications")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/application/list"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.keyword != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyword", r.keyword, "form", "")
	}
	if r.platforms != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "platforms", r.platforms, "form", "")
	}
	if r.deviceIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceIds", r.deviceIds, "form", "")
	}
	if r.deviceVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceVersions", r.deviceVersions, "form", "")
	}
	if r.categoryIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "categoryIds", r.categoryIds, "form", "")
	}
	if r.sortField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", r.sortField, "form", "")
	} else {
		var defaultValue string = "UPDATED"
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", defaultValue, "form", "")
		r.sortField = &defaultValue
	}
	if r.hasAds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hasAds", r.hasAds, "form", "")
	}
	if r.publicNotifications != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "publicNotifications", r.publicNotifications, "form", "")
	}
	if r.filterBillable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filterBillable", r.filterBillable, "form", "")
	}
	if r.filterContentAdmin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filterContentAdmin", r.filterContentAdmin, "form", "")
	}
	if r.descending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "form", "")
	} else {
		var defaultValue bool = true
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", defaultValue, "form", "")
		r.descending = &defaultValue
	}
	if r.i != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "_i", r.i, "form", "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	} else {
		var defaultValue int32 = 0
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", defaultValue, "form", "")
		r.start = &defaultValue
	}
	if r.l != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "_l", r.l, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 20
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	if r.applicationIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "applicationIds", r.applicationIds, "form", "")
	}
	if r.hasObjectStore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hasObjectStore", r.hasObjectStore, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "hasObjectStore", defaultValue, "form", "")
		r.hasObjectStore = &defaultValue
	}
	if r.activeOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activeOnly", r.activeOnly, "form", "")
	} else {
		var defaultValue bool = true
		parameterAddToHeaderOrQuery(localVarQueryParams, "activeOnly", defaultValue, "form", "")
		r.activeOnly = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchApplicationPlacementRequest struct {
	ctx context.Context
	ApiService *ApplicationAPIService
	version float32
	appKey *string
	deviceId *string
	accountId *int64
	start *int32
	limit *int32
}

// The key of the application
func (r ApiSearchApplicationPlacementRequest) AppKey(appKey string) ApiSearchApplicationPlacementRequest {
	r.appKey = &appKey
	return r
}

// The unique id of the device making the request (deviceId or accountId required)
func (r ApiSearchApplicationPlacementRequest) DeviceId(deviceId string) ApiSearchApplicationPlacementRequest {
	r.deviceId = &deviceId
	return r
}

// The account id of the user (deviceId or accountId required)
func (r ApiSearchApplicationPlacementRequest) AccountId(accountId int64) ApiSearchApplicationPlacementRequest {
	r.accountId = &accountId
	return r
}

// The start of the pagination
func (r ApiSearchApplicationPlacementRequest) Start(start int32) ApiSearchApplicationPlacementRequest {
	r.start = &start
	return r
}

// The limit of the pagination
func (r ApiSearchApplicationPlacementRequest) Limit(limit int32) ApiSearchApplicationPlacementRequest {
	r.limit = &limit
	return r
}

func (r ApiSearchApplicationPlacementRequest) Execute() ([]PlacementResponse, *http.Response, error) {
	return r.ApiService.SearchApplicationPlacementExecute(r)
}

/*
SearchApplicationPlacement Search for Ad Placements

Searches placements for an application.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiSearchApplicationPlacementRequest
*/
func (a *ApplicationAPIService) SearchApplicationPlacement(ctx context.Context, version float32) ApiSearchApplicationPlacementRequest {
	return ApiSearchApplicationPlacementRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return []PlacementResponse
func (a *ApplicationAPIService) SearchApplicationPlacementExecute(r ApiSearchApplicationPlacementRequest) ([]PlacementResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PlacementResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationAPIService.SearchApplicationPlacement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/application/placement/search"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.appKey == nil {
		return localVarReturnValue, nil, reportError("appKey is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	} else {
		var defaultValue int32 = 0
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", defaultValue, "form", "")
		r.start = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 100
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchApplicationSettingsRequest struct {
	ctx context.Context
	ApiService *ApplicationAPIService
	version float32
	deviceId *string
	accountId *int64
	connectionAccountId *int64
	keyword *string
	sortField *string
	descending *bool
	start *int32
	limit *int32
}

// The device id (deviceId or accountId required)
func (r ApiSearchApplicationSettingsRequest) DeviceId(deviceId string) ApiSearchApplicationSettingsRequest {
	r.deviceId = &deviceId
	return r
}

// The account id of the user (deviceId or accountId required)
func (r ApiSearchApplicationSettingsRequest) AccountId(accountId int64) ApiSearchApplicationSettingsRequest {
	r.accountId = &accountId
	return r
}

// The account id used to view another person&#39;s account
func (r ApiSearchApplicationSettingsRequest) ConnectionAccountId(connectionAccountId int64) ApiSearchApplicationSettingsRequest {
	r.connectionAccountId = &connectionAccountId
	return r
}

// The string to search applications on
func (r ApiSearchApplicationSettingsRequest) Keyword(keyword string) ApiSearchApplicationSettingsRequest {
	r.keyword = &keyword
	return r
}

// The column to sort the search on. Possible values include: CREATED, UPDATED, APPLICATION_TITLE
func (r ApiSearchApplicationSettingsRequest) SortField(sortField string) ApiSearchApplicationSettingsRequest {
	r.sortField = &sortField
	return r
}

// The order to return the search results
func (r ApiSearchApplicationSettingsRequest) Descending(descending bool) ApiSearchApplicationSettingsRequest {
	r.descending = &descending
	return r
}

// The start index for pagination
func (r ApiSearchApplicationSettingsRequest) Start(start int32) ApiSearchApplicationSettingsRequest {
	r.start = &start
	return r
}

// The limit per result set for pagination
func (r ApiSearchApplicationSettingsRequest) Limit(limit int32) ApiSearchApplicationSettingsRequest {
	r.limit = &limit
	return r
}

func (r ApiSearchApplicationSettingsRequest) Execute() (*ApplicationSettingsResponse, *http.Response, error) {
	return r.ApiService.SearchApplicationSettingsExecute(r)
}

/*
SearchApplicationSettings Search for Application Settings

Returns a list of applications that the user has logged into before, and returns specific settings for that application and user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiSearchApplicationSettingsRequest
*/
func (a *ApplicationAPIService) SearchApplicationSettings(ctx context.Context, version float32) ApiSearchApplicationSettingsRequest {
	return ApiSearchApplicationSettingsRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return ApplicationSettingsResponse
func (a *ApplicationAPIService) SearchApplicationSettingsExecute(r ApiSearchApplicationSettingsRequest) (*ApplicationSettingsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApplicationSettingsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationAPIService.SearchApplicationSettings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/application/settings/search"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.connectionAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionAccountId", r.connectionAccountId, "form", "")
	}
	if r.keyword != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyword", r.keyword, "form", "")
	}
	if r.sortField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", r.sortField, "form", "")
	} else {
		var defaultValue string = "APPLICATION_TITLE"
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", defaultValue, "form", "")
		r.sortField = &defaultValue
	}
	if r.descending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", defaultValue, "form", "")
		r.descending = &defaultValue
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	} else {
		var defaultValue int32 = 0
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", defaultValue, "form", "")
		r.start = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 20
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchApplicationsRequest struct {
	ctx context.Context
	ApiService *ApplicationAPIService
	version float32
	deviceId *string
	accountId *int64
	latitude *float64
	longitude *float64
	q *string
	keyword *string
	qSearchFields *string
	sortField *string
	descending *bool
	i *int32
	start *int32
	l *int32
	limit *int32
	hasAds *bool
	publicNotifications *bool
	activeOnly *bool
}

// The unique id of the device making the request (deviceId or accountId required)
func (r ApiSearchApplicationsRequest) DeviceId(deviceId string) ApiSearchApplicationsRequest {
	r.deviceId = &deviceId
	return r
}

// The account id of the user (deviceId or accountId required)
func (r ApiSearchApplicationsRequest) AccountId(accountId int64) ApiSearchApplicationsRequest {
	r.accountId = &accountId
	return r
}

// The location of the device
func (r ApiSearchApplicationsRequest) Latitude(latitude float64) ApiSearchApplicationsRequest {
	r.latitude = &latitude
	return r
}

// The location of the device
func (r ApiSearchApplicationsRequest) Longitude(longitude float64) ApiSearchApplicationsRequest {
	r.longitude = &longitude
	return r
}

// Q
// Deprecated
func (r ApiSearchApplicationsRequest) Q(q string) ApiSearchApplicationsRequest {
	r.q = &q
	return r
}

// The keyword used to search
func (r ApiSearchApplicationsRequest) Keyword(keyword string) ApiSearchApplicationsRequest {
	r.keyword = &keyword
	return r
}

// The columns to applied the keyword search to
func (r ApiSearchApplicationsRequest) QSearchFields(qSearchFields string) ApiSearchApplicationsRequest {
	r.qSearchFields = &qSearchFields
	return r
}

// The column to sort the search on
func (r ApiSearchApplicationsRequest) SortField(sortField string) ApiSearchApplicationsRequest {
	r.sortField = &sortField
	return r
}

// The order to return the search results
func (r ApiSearchApplicationsRequest) Descending(descending bool) ApiSearchApplicationsRequest {
	r.descending = &descending
	return r
}

// the start of the index
// Deprecated
func (r ApiSearchApplicationsRequest) I(i int32) ApiSearchApplicationsRequest {
	r.i = &i
	return r
}

// The start of the pagination
func (r ApiSearchApplicationsRequest) Start(start int32) ApiSearchApplicationsRequest {
	r.start = &start
	return r
}

// the limit of the index
// Deprecated
func (r ApiSearchApplicationsRequest) L(l int32) ApiSearchApplicationsRequest {
	r.l = &l
	return r
}

// The limit of the pagination
func (r ApiSearchApplicationsRequest) Limit(limit int32) ApiSearchApplicationsRequest {
	r.limit = &limit
	return r
}

// Filter results on whether the application supports ads or not. Ignore this parameter to return all results.
func (r ApiSearchApplicationsRequest) HasAds(hasAds bool) ApiSearchApplicationsRequest {
	r.hasAds = &hasAds
	return r
}

// Filter results on whether the application is available for public trigger notifications
func (r ApiSearchApplicationsRequest) PublicNotifications(publicNotifications bool) ApiSearchApplicationsRequest {
	r.publicNotifications = &publicNotifications
	return r
}

// Return only active results
func (r ApiSearchApplicationsRequest) ActiveOnly(activeOnly bool) ApiSearchApplicationsRequest {
	r.activeOnly = &activeOnly
	return r
}

func (r ApiSearchApplicationsRequest) Execute() ([]ApplicationResponse, *http.Response, error) {
	return r.ApiService.SearchApplicationsExecute(r)
}

/*
SearchApplications Search Applications

Search for applications matching the criteria that the logged in user has access to

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiSearchApplicationsRequest
*/
func (a *ApplicationAPIService) SearchApplications(ctx context.Context, version float32) ApiSearchApplicationsRequest {
	return ApiSearchApplicationsRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return []ApplicationResponse
func (a *ApplicationAPIService) SearchApplicationsExecute(r ApiSearchApplicationsRequest) ([]ApplicationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ApplicationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationAPIService.SearchApplications")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/application/search"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.latitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latitude", r.latitude, "form", "")
	}
	if r.longitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "longitude", r.longitude, "form", "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.keyword != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyword", r.keyword, "form", "")
	}
	if r.qSearchFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "qSearchFields", r.qSearchFields, "form", "")
	} else {
		var defaultValue string = "NAME,ABOUT,BILLABLE_ENTITY_NAME"
		parameterAddToHeaderOrQuery(localVarQueryParams, "qSearchFields", defaultValue, "form", "")
		r.qSearchFields = &defaultValue
	}
	if r.sortField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", r.sortField, "form", "")
	} else {
		var defaultValue string = "APPLICATION_ID"
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", defaultValue, "form", "")
		r.sortField = &defaultValue
	}
	if r.descending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", defaultValue, "form", "")
		r.descending = &defaultValue
	}
	if r.i != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "_i", r.i, "form", "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	} else {
		var defaultValue int32 = 0
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", defaultValue, "form", "")
		r.start = &defaultValue
	}
	if r.l != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "_l", r.l, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 100
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	if r.hasAds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hasAds", r.hasAds, "form", "")
	}
	if r.publicNotifications != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "publicNotifications", r.publicNotifications, "form", "")
	}
	if r.activeOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activeOnly", r.activeOnly, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "activeOnly", defaultValue, "form", "")
		r.activeOnly = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateApplicationRequest struct {
	ctx context.Context
	ApiService *ApplicationAPIService
	version float32
	appKey *string
	appName *string
	deviceId *string
	accountId *int64
	about *string
	bundleId *string
	appIconAssetId *int64
	appLogoAssetId *int64
	facebookAppId *string
	facebookAppSecret *string
	googleApiKey *string
	updateEULADate *bool
	eulaVersion *string
	landingPageUrl *string
	showInActivities *bool
	activityDescription *string
	inviteWelcomeText *string
	invitePageUrl *string
	urlScheme *string
	platforms *string
	downloadUrls *string
	categoryIds *string
	scoringType *string
	hintCost *int32
	maxScore *int32
	ticketsPerPoint *float32
	hasGameData *bool
	publicNotifications *bool
	useMatchingAlgorithm *bool
	globalTickets *bool
	buildVersion *float32
	apiVersion *float32
	placementName *string
	placementDescription *string
	placementSize *string
	placementHeight *int32
	placementWidth *int32
	placementRefreshInterval *int32
	createObjectStore *bool
	publicContentApproval *bool
	productionMode *bool
	minimumSessionLength *int32
	sessionGapLength *int32
	localAdsEnabled *bool
	sqootApiKey *string
	trilatProcessingType *string
	maxSampleSize *int32
	minRSSI *float64
	modules *string
	authorizedCount *int32
	authorizedServers *string
	defaultTimezone *string
	smtpPass *string
	metaData *string
	placementMetaData *string
	ipsFloor *bool
	enableAPNSBadge *bool
	includeInReport *bool
	defaultAppFilterId *int64
	enableWelcomeEmail *bool
	appleAppId *string
	appleTeamId *string
	appleAuthKeyId *string
	appleAuthKey *os.File
	appleIssuerId *string
	appStoreKeyId *string
	appStoreKey *os.File
	googlePrivateKeyFile *os.File
	authorizeNetApiKey *string
	authorizeNetTransactionKey *string
	emailSender *string
	smtpUser *string
	smtpHost *string
	vatomBusinessId *string
	vatomRestClientId *string
	vatomRestSecretKey *string
	twilioAccountSID *string
	twilioAuthToken *string
	twilioSenderPhoneNumber *string
	openAISecretKey *string
}

// The application key for updating an existing application
func (r ApiUpdateApplicationRequest) AppKey(appKey string) ApiUpdateApplicationRequest {
	r.appKey = &appKey
	return r
}

// The name of the application
func (r ApiUpdateApplicationRequest) AppName(appName string) ApiUpdateApplicationRequest {
	r.appName = &appName
	return r
}

// The unique id of the device making the request (deviceId or accountId required)
func (r ApiUpdateApplicationRequest) DeviceId(deviceId string) ApiUpdateApplicationRequest {
	r.deviceId = &deviceId
	return r
}

// The account id of the user (deviceId or accountId required)
func (r ApiUpdateApplicationRequest) AccountId(accountId int64) ApiUpdateApplicationRequest {
	r.accountId = &accountId
	return r
}

// The description of the application
func (r ApiUpdateApplicationRequest) About(about string) ApiUpdateApplicationRequest {
	r.about = &about
	return r
}

// The application bundle identifier (format - com.company.appName)
func (r ApiUpdateApplicationRequest) BundleId(bundleId string) ApiUpdateApplicationRequest {
	r.bundleId = &bundleId
	return r
}

// The application icon asset id
func (r ApiUpdateApplicationRequest) AppIconAssetId(appIconAssetId int64) ApiUpdateApplicationRequest {
	r.appIconAssetId = &appIconAssetId
	return r
}

// The application logo asset id
func (r ApiUpdateApplicationRequest) AppLogoAssetId(appLogoAssetId int64) ApiUpdateApplicationRequest {
	r.appLogoAssetId = &appLogoAssetId
	return r
}

// The Facebook application id
func (r ApiUpdateApplicationRequest) FacebookAppId(facebookAppId string) ApiUpdateApplicationRequest {
	r.facebookAppId = &facebookAppId
	return r
}

// The Facebook application secret
func (r ApiUpdateApplicationRequest) FacebookAppSecret(facebookAppSecret string) ApiUpdateApplicationRequest {
	r.facebookAppSecret = &facebookAppSecret
	return r
}

// This is the either the &#39;server key&#39; or &#39;browser key&#39; generated from google to enable Google Cloud Messaging
func (r ApiUpdateApplicationRequest) GoogleApiKey(googleApiKey string) ApiUpdateApplicationRequest {
	r.googleApiKey = &googleApiKey
	return r
}

// Determines whether to update the EULA date
func (r ApiUpdateApplicationRequest) UpdateEULADate(updateEULADate bool) ApiUpdateApplicationRequest {
	r.updateEULADate = &updateEULADate
	return r
}

// The EULA version
func (r ApiUpdateApplicationRequest) EulaVersion(eulaVersion string) ApiUpdateApplicationRequest {
	r.eulaVersion = &eulaVersion
	return r
}

// The landing page URL
func (r ApiUpdateApplicationRequest) LandingPageUrl(landingPageUrl string) ApiUpdateApplicationRequest {
	r.landingPageUrl = &landingPageUrl
	return r
}

// Determines whether to show the application in the activity feed
func (r ApiUpdateApplicationRequest) ShowInActivities(showInActivities bool) ApiUpdateApplicationRequest {
	r.showInActivities = &showInActivities
	return r
}

// The description of the application in the activity feed
func (r ApiUpdateApplicationRequest) ActivityDescription(activityDescription string) ApiUpdateApplicationRequest {
	r.activityDescription = &activityDescription
	return r
}

// The text to display on the invite page
func (r ApiUpdateApplicationRequest) InviteWelcomeText(inviteWelcomeText string) ApiUpdateApplicationRequest {
	r.inviteWelcomeText = &inviteWelcomeText
	return r
}

// The url to the application invite page
func (r ApiUpdateApplicationRequest) InvitePageUrl(invitePageUrl string) ApiUpdateApplicationRequest {
	r.invitePageUrl = &invitePageUrl
	return r
}

// The protocal the app uses to load the app via a browser
func (r ApiUpdateApplicationRequest) UrlScheme(urlScheme string) ApiUpdateApplicationRequest {
	r.urlScheme = &urlScheme
	return r
}

// A json object with a list of supported platforms.  &#x60;&#x60;&#x60;json {   \&quot;platforms\&quot;: [     {       \&quot;deviceId\&quot;: 1,       \&quot;minimum\&quot;: 230,       \&quot;maximum\&quot;: 421,       \&quot;downloadUrl\&quot;: \&quot;http://app.store.com/download\&quot;,       \&quot;description\&quot;: \&quot;description and version info\&quot;     }   ] } &#x60;&#x60;&#x60; 
func (r ApiUpdateApplicationRequest) Platforms(platforms string) ApiUpdateApplicationRequest {
	r.platforms = &platforms
	return r
}

// Json formatted downloadUrls.  &#x60;&#x60;&#x60;json {   \&quot;ios\&quot;: \&quot;the-url-to-app-store\&quot;,    \&quot;android\&quot;: \&quot;the-url-to-google-play\&quot; } &#x60;&#x60;&#x60;  
func (r ApiUpdateApplicationRequest) DownloadUrls(downloadUrls string) ApiUpdateApplicationRequest {
	r.downloadUrls = &downloadUrls
	return r
}

// List of categories to apply
func (r ApiUpdateApplicationRequest) CategoryIds(categoryIds string) ApiUpdateApplicationRequest {
	r.categoryIds = &categoryIds
	return r
}

// The type of scoring this application will use {GAME_LEVEL, GAME_OBJECT
func (r ApiUpdateApplicationRequest) ScoringType(scoringType string) ApiUpdateApplicationRequest {
	r.scoringType = &scoringType
	return r
}

// The cost of hints
func (r ApiUpdateApplicationRequest) HintCost(hintCost int32) ApiUpdateApplicationRequest {
	r.hintCost = &hintCost
	return r
}

// The maximum score that will be possible
func (r ApiUpdateApplicationRequest) MaxScore(maxScore int32) ApiUpdateApplicationRequest {
	r.maxScore = &maxScore
	return r
}

// The point-to-ticket conversion ratio
func (r ApiUpdateApplicationRequest) TicketsPerPoint(ticketsPerPoint float32) ApiUpdateApplicationRequest {
	r.ticketsPerPoint = &ticketsPerPoint
	return r
}

// Determines whether the application uses services to save custom game objects
func (r ApiUpdateApplicationRequest) HasGameData(hasGameData bool) ApiUpdateApplicationRequest {
	r.hasGameData = &hasGameData
	return r
}

// Public Notifications
func (r ApiUpdateApplicationRequest) PublicNotifications(publicNotifications bool) ApiUpdateApplicationRequest {
	r.publicNotifications = &publicNotifications
	return r
}

// Use Matching Algorithm
func (r ApiUpdateApplicationRequest) UseMatchingAlgorithm(useMatchingAlgorithm bool) ApiUpdateApplicationRequest {
	r.useMatchingAlgorithm = &useMatchingAlgorithm
	return r
}

// Determines whether earned tickets are applied across all applications
func (r ApiUpdateApplicationRequest) GlobalTickets(globalTickets bool) ApiUpdateApplicationRequest {
	r.globalTickets = &globalTickets
	return r
}

// The current build version of the application
func (r ApiUpdateApplicationRequest) BuildVersion(buildVersion float32) ApiUpdateApplicationRequest {
	r.buildVersion = &buildVersion
	return r
}

// The current API version the application uses
func (r ApiUpdateApplicationRequest) ApiVersion(apiVersion float32) ApiUpdateApplicationRequest {
	r.apiVersion = &apiVersion
	return r
}

// The name of the placement
func (r ApiUpdateApplicationRequest) PlacementName(placementName string) ApiUpdateApplicationRequest {
	r.placementName = &placementName
	return r
}

// The description of the placement
func (r ApiUpdateApplicationRequest) PlacementDescription(placementDescription string) ApiUpdateApplicationRequest {
	r.placementDescription = &placementDescription
	return r
}

// The ad placement size {BANNER, LEADERBOARD, SKYSCRAPER, INTERSTITIAL, CUSTOM (this is required if a placements is to be created)
func (r ApiUpdateApplicationRequest) PlacementSize(placementSize string) ApiUpdateApplicationRequest {
	r.placementSize = &placementSize
	return r
}

// The height of a custom ad size
func (r ApiUpdateApplicationRequest) PlacementHeight(placementHeight int32) ApiUpdateApplicationRequest {
	r.placementHeight = &placementHeight
	return r
}

// The width of a custom ad size
func (r ApiUpdateApplicationRequest) PlacementWidth(placementWidth int32) ApiUpdateApplicationRequest {
	r.placementWidth = &placementWidth
	return r
}

// The refresh interval in seconds
func (r ApiUpdateApplicationRequest) PlacementRefreshInterval(placementRefreshInterval int32) ApiUpdateApplicationRequest {
	r.placementRefreshInterval = &placementRefreshInterval
	return r
}

// Generate a custom object store to use
func (r ApiUpdateApplicationRequest) CreateObjectStore(createObjectStore bool) ApiUpdateApplicationRequest {
	r.createObjectStore = &createObjectStore
	return r
}

// Determine whether or not public content requires admin approval before it becomes public
func (r ApiUpdateApplicationRequest) PublicContentApproval(publicContentApproval bool) ApiUpdateApplicationRequest {
	r.publicContentApproval = &publicContentApproval
	return r
}

// Determines whether the application uses production or sandbox services
func (r ApiUpdateApplicationRequest) ProductionMode(productionMode bool) ApiUpdateApplicationRequest {
	r.productionMode = &productionMode
	return r
}

// Minimum Session Length
func (r ApiUpdateApplicationRequest) MinimumSessionLength(minimumSessionLength int32) ApiUpdateApplicationRequest {
	r.minimumSessionLength = &minimumSessionLength
	return r
}

// Session Gap Length
func (r ApiUpdateApplicationRequest) SessionGapLength(sessionGapLength int32) ApiUpdateApplicationRequest {
	r.sessionGapLength = &sessionGapLength
	return r
}

// Local Ads Enabled
func (r ApiUpdateApplicationRequest) LocalAdsEnabled(localAdsEnabled bool) ApiUpdateApplicationRequest {
	r.localAdsEnabled = &localAdsEnabled
	return r
}

// Sqoot Api Key
func (r ApiUpdateApplicationRequest) SqootApiKey(sqootApiKey string) ApiUpdateApplicationRequest {
	r.sqootApiKey = &sqootApiKey
	return r
}

// Determines how to process trilateration data. Possible values include: DEFAULT, FINGERPRINT
func (r ApiUpdateApplicationRequest) TrilatProcessingType(trilatProcessingType string) ApiUpdateApplicationRequest {
	r.trilatProcessingType = &trilatProcessingType
	return r
}

// Determines what the maximum sample size during trilateration
func (r ApiUpdateApplicationRequest) MaxSampleSize(maxSampleSize int32) ApiUpdateApplicationRequest {
	r.maxSampleSize = &maxSampleSize
	return r
}

// Determines what the minimum acceptable RSSI value
func (r ApiUpdateApplicationRequest) MinRSSI(minRSSI float64) ApiUpdateApplicationRequest {
	r.minRSSI = &minRSSI
	return r
}

// List modules allowed to be served by the server, possible values include: COMMON, MEDIA, OFFER, GAME, SOCIAL, CONSUMER_WEBSITE, ALL
func (r ApiUpdateApplicationRequest) Modules(modules string) ApiUpdateApplicationRequest {
	r.modules = &modules
	return r
}

// How many servers the license will support
func (r ApiUpdateApplicationRequest) AuthorizedCount(authorizedCount int32) ApiUpdateApplicationRequest {
	r.authorizedCount = &authorizedCount
	return r
}

// The list of ip addresses of servers the license will support, leave null for any server
func (r ApiUpdateApplicationRequest) AuthorizedServers(authorizedServers string) ApiUpdateApplicationRequest {
	r.authorizedServers = &authorizedServers
	return r
}

// Sets the default timezone for the app (used for leaderboards and other time specific content)
func (r ApiUpdateApplicationRequest) DefaultTimezone(defaultTimezone string) ApiUpdateApplicationRequest {
	r.defaultTimezone = &defaultTimezone
	return r
}

// SMTP Pass
func (r ApiUpdateApplicationRequest) SmtpPass(smtpPass string) ApiUpdateApplicationRequest {
	r.smtpPass = &smtpPass
	return r
}

// The application meta data. Defined by the client
func (r ApiUpdateApplicationRequest) MetaData(metaData string) ApiUpdateApplicationRequest {
	r.metaData = &metaData
	return r
}

// The ad placement meta data. Defined by the client
func (r ApiUpdateApplicationRequest) PlacementMetaData(placementMetaData string) ApiUpdateApplicationRequest {
	r.placementMetaData = &placementMetaData
	return r
}

// Create floor tables for Ips
func (r ApiUpdateApplicationRequest) IpsFloor(ipsFloor bool) ApiUpdateApplicationRequest {
	r.ipsFloor = &ipsFloor
	return r
}

// Enables setting the APNS badge value in the payload
func (r ApiUpdateApplicationRequest) EnableAPNSBadge(enableAPNSBadge bool) ApiUpdateApplicationRequest {
	r.enableAPNSBadge = &enableAPNSBadge
	return r
}

// Enables using the application in session reports
func (r ApiUpdateApplicationRequest) IncludeInReport(includeInReport bool) ApiUpdateApplicationRequest {
	r.includeInReport = &includeInReport
	return r
}

// Sets the default filter to use (if none is passed in) for certain search APIs including Album Search.
func (r ApiUpdateApplicationRequest) DefaultAppFilterId(defaultAppFilterId int64) ApiUpdateApplicationRequest {
	r.defaultAppFilterId = &defaultAppFilterId
	return r
}

// Enables whether the default welcome email will be sent for new app users
func (r ApiUpdateApplicationRequest) EnableWelcomeEmail(enableWelcomeEmail bool) ApiUpdateApplicationRequest {
	r.enableWelcomeEmail = &enableWelcomeEmail
	return r
}

// The Apple Application ID
func (r ApiUpdateApplicationRequest) AppleAppId(appleAppId string) ApiUpdateApplicationRequest {
	r.appleAppId = &appleAppId
	return r
}

// The Apple Team ID
func (r ApiUpdateApplicationRequest) AppleTeamId(appleTeamId string) ApiUpdateApplicationRequest {
	r.appleTeamId = &appleTeamId
	return r
}

// The Apple Auth Key ID
func (r ApiUpdateApplicationRequest) AppleAuthKeyId(appleAuthKeyId string) ApiUpdateApplicationRequest {
	r.appleAuthKeyId = &appleAuthKeyId
	return r
}

// The Apple Auth Signin Key (p8) File
func (r ApiUpdateApplicationRequest) AppleAuthKey(appleAuthKey *os.File) ApiUpdateApplicationRequest {
	r.appleAuthKey = appleAuthKey
	return r
}

// The Apple Issuer ID
func (r ApiUpdateApplicationRequest) AppleIssuerId(appleIssuerId string) ApiUpdateApplicationRequest {
	r.appleIssuerId = &appleIssuerId
	return r
}

// The Apple App Store Key ID
func (r ApiUpdateApplicationRequest) AppStoreKeyId(appStoreKeyId string) ApiUpdateApplicationRequest {
	r.appStoreKeyId = &appStoreKeyId
	return r
}

// The Apple App Store Key (p8) File
func (r ApiUpdateApplicationRequest) AppStoreKey(appStoreKey *os.File) ApiUpdateApplicationRequest {
	r.appStoreKey = appStoreKey
	return r
}

// This is the private key file for your Google service account.
func (r ApiUpdateApplicationRequest) GooglePrivateKeyFile(googlePrivateKeyFile *os.File) ApiUpdateApplicationRequest {
	r.googlePrivateKeyFile = googlePrivateKeyFile
	return r
}

// Authorize Net Api Key
func (r ApiUpdateApplicationRequest) AuthorizeNetApiKey(authorizeNetApiKey string) ApiUpdateApplicationRequest {
	r.authorizeNetApiKey = &authorizeNetApiKey
	return r
}

// Authorize Net Transaction Key
func (r ApiUpdateApplicationRequest) AuthorizeNetTransactionKey(authorizeNetTransactionKey string) ApiUpdateApplicationRequest {
	r.authorizeNetTransactionKey = &authorizeNetTransactionKey
	return r
}

// Email Sender
func (r ApiUpdateApplicationRequest) EmailSender(emailSender string) ApiUpdateApplicationRequest {
	r.emailSender = &emailSender
	return r
}

// SMTP User
func (r ApiUpdateApplicationRequest) SmtpUser(smtpUser string) ApiUpdateApplicationRequest {
	r.smtpUser = &smtpUser
	return r
}

// SMTP Host
func (r ApiUpdateApplicationRequest) SmtpHost(smtpHost string) ApiUpdateApplicationRequest {
	r.smtpHost = &smtpHost
	return r
}

// Vatom Business Id
func (r ApiUpdateApplicationRequest) VatomBusinessId(vatomBusinessId string) ApiUpdateApplicationRequest {
	r.vatomBusinessId = &vatomBusinessId
	return r
}

// Vatom REST Client Id
func (r ApiUpdateApplicationRequest) VatomRestClientId(vatomRestClientId string) ApiUpdateApplicationRequest {
	r.vatomRestClientId = &vatomRestClientId
	return r
}

// Vatom Secret Key
func (r ApiUpdateApplicationRequest) VatomRestSecretKey(vatomRestSecretKey string) ApiUpdateApplicationRequest {
	r.vatomRestSecretKey = &vatomRestSecretKey
	return r
}

// Twilio Account SID
func (r ApiUpdateApplicationRequest) TwilioAccountSID(twilioAccountSID string) ApiUpdateApplicationRequest {
	r.twilioAccountSID = &twilioAccountSID
	return r
}

// Twilio Auth Token
func (r ApiUpdateApplicationRequest) TwilioAuthToken(twilioAuthToken string) ApiUpdateApplicationRequest {
	r.twilioAuthToken = &twilioAuthToken
	return r
}

// Twilio Sender Phone Number
func (r ApiUpdateApplicationRequest) TwilioSenderPhoneNumber(twilioSenderPhoneNumber string) ApiUpdateApplicationRequest {
	r.twilioSenderPhoneNumber = &twilioSenderPhoneNumber
	return r
}

// OpenAI Secret API Key
func (r ApiUpdateApplicationRequest) OpenAISecretKey(openAISecretKey string) ApiUpdateApplicationRequest {
	r.openAISecretKey = &openAISecretKey
	return r
}

func (r ApiUpdateApplicationRequest) Execute() (*ApplicationResponse, *http.Response, error) {
	return r.ApiService.UpdateApplicationExecute(r)
}

/*
UpdateApplication Update Application

Update an application record

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiUpdateApplicationRequest
*/
func (a *ApplicationAPIService) UpdateApplication(ctx context.Context, version float32) ApiUpdateApplicationRequest {
	return ApiUpdateApplicationRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return ApplicationResponse
func (a *ApplicationAPIService) UpdateApplicationExecute(r ApiUpdateApplicationRequest) (*ApplicationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApplicationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationAPIService.UpdateApplication")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/application/update"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.appKey == nil {
		return localVarReturnValue, nil, reportError("appKey is required and must be specified")
	}
	if r.appName == nil {
		return localVarReturnValue, nil, reportError("appName is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "appName", r.appName, "form", "")
	if r.about != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "about", r.about, "form", "")
	}
	if r.bundleId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bundleId", r.bundleId, "form", "")
	}
	if r.appIconAssetId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appIconAssetId", r.appIconAssetId, "form", "")
	}
	if r.appLogoAssetId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appLogoAssetId", r.appLogoAssetId, "form", "")
	}
	if r.facebookAppId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "facebookAppId", r.facebookAppId, "form", "")
	}
	if r.facebookAppSecret != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "facebookAppSecret", r.facebookAppSecret, "form", "")
	}
	if r.googleApiKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "googleApiKey", r.googleApiKey, "form", "")
	}
	if r.updateEULADate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateEULADate", r.updateEULADate, "form", "")
	}
	if r.eulaVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "eulaVersion", r.eulaVersion, "form", "")
	}
	if r.landingPageUrl != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "landingPageUrl", r.landingPageUrl, "form", "")
	}
	if r.showInActivities != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "showInActivities", r.showInActivities, "form", "")
	}
	if r.activityDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activityDescription", r.activityDescription, "form", "")
	}
	if r.inviteWelcomeText != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inviteWelcomeText", r.inviteWelcomeText, "form", "")
	}
	if r.invitePageUrl != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "invitePageUrl", r.invitePageUrl, "form", "")
	}
	if r.urlScheme != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "urlScheme", r.urlScheme, "form", "")
	}
	if r.platforms != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "platforms", r.platforms, "form", "")
	}
	if r.downloadUrls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "downloadUrls", r.downloadUrls, "form", "")
	}
	if r.categoryIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "categoryIds", r.categoryIds, "form", "")
	}
	if r.scoringType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scoringType", r.scoringType, "form", "")
	} else {
		var defaultValue string = "GAME_LEVEL"
		parameterAddToHeaderOrQuery(localVarQueryParams, "scoringType", defaultValue, "form", "")
		r.scoringType = &defaultValue
	}
	if r.hintCost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hintCost", r.hintCost, "form", "")
	} else {
		var defaultValue int32 = 11
		parameterAddToHeaderOrQuery(localVarQueryParams, "hintCost", defaultValue, "form", "")
		r.hintCost = &defaultValue
	}
	if r.maxScore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxScore", r.maxScore, "form", "")
	} else {
		var defaultValue int32 = 125
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxScore", defaultValue, "form", "")
		r.maxScore = &defaultValue
	}
	if r.ticketsPerPoint != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ticketsPerPoint", r.ticketsPerPoint, "form", "")
	} else {
		var defaultValue float32 = 0.037
		parameterAddToHeaderOrQuery(localVarQueryParams, "ticketsPerPoint", defaultValue, "form", "")
		r.ticketsPerPoint = &defaultValue
	}
	if r.hasGameData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hasGameData", r.hasGameData, "form", "")
	} else {
		var defaultValue bool = true
		parameterAddToHeaderOrQuery(localVarQueryParams, "hasGameData", defaultValue, "form", "")
		r.hasGameData = &defaultValue
	}
	if r.publicNotifications != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "publicNotifications", r.publicNotifications, "form", "")
	}
	if r.useMatchingAlgorithm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "useMatchingAlgorithm", r.useMatchingAlgorithm, "form", "")
	}
	if r.globalTickets != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "globalTickets", r.globalTickets, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "globalTickets", defaultValue, "form", "")
		r.globalTickets = &defaultValue
	}
	if r.buildVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "buildVersion", r.buildVersion, "form", "")
	} else {
		var defaultValue float32 = 1
		parameterAddToHeaderOrQuery(localVarQueryParams, "buildVersion", defaultValue, "form", "")
		r.buildVersion = &defaultValue
	}
	if r.apiVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "apiVersion", r.apiVersion, "form", "")
	}
	if r.placementName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "placementName", r.placementName, "form", "")
	}
	if r.placementDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "placementDescription", r.placementDescription, "form", "")
	}
	if r.placementSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "placementSize", r.placementSize, "form", "")
	}
	if r.placementHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "placementHeight", r.placementHeight, "form", "")
	}
	if r.placementWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "placementWidth", r.placementWidth, "form", "")
	}
	if r.placementRefreshInterval != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "placementRefreshInterval", r.placementRefreshInterval, "form", "")
	}
	if r.createObjectStore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createObjectStore", r.createObjectStore, "form", "")
	} else {
		var defaultValue bool = true
		parameterAddToHeaderOrQuery(localVarQueryParams, "createObjectStore", defaultValue, "form", "")
		r.createObjectStore = &defaultValue
	}
	if r.publicContentApproval != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "publicContentApproval", r.publicContentApproval, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "publicContentApproval", defaultValue, "form", "")
		r.publicContentApproval = &defaultValue
	}
	if r.productionMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "productionMode", r.productionMode, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "productionMode", defaultValue, "form", "")
		r.productionMode = &defaultValue
	}
	if r.minimumSessionLength != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "minimumSessionLength", r.minimumSessionLength, "form", "")
	}
	if r.sessionGapLength != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sessionGapLength", r.sessionGapLength, "form", "")
	}
	if r.localAdsEnabled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "localAdsEnabled", r.localAdsEnabled, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "localAdsEnabled", defaultValue, "form", "")
		r.localAdsEnabled = &defaultValue
	}
	if r.sqootApiKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sqootApiKey", r.sqootApiKey, "form", "")
	}
	if r.trilatProcessingType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "trilatProcessingType", r.trilatProcessingType, "form", "")
	} else {
		var defaultValue string = "FINGERPRINT"
		parameterAddToHeaderOrQuery(localVarQueryParams, "trilatProcessingType", defaultValue, "form", "")
		r.trilatProcessingType = &defaultValue
	}
	if r.maxSampleSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxSampleSize", r.maxSampleSize, "form", "")
	}
	if r.minRSSI != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "minRSSI", r.minRSSI, "form", "")
	}
	if r.modules != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modules", r.modules, "form", "")
	} else {
		var defaultValue string = "ALL"
		parameterAddToHeaderOrQuery(localVarQueryParams, "modules", defaultValue, "form", "")
		r.modules = &defaultValue
	}
	if r.authorizedCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "authorizedCount", r.authorizedCount, "form", "")
	} else {
		var defaultValue int32 = 1
		parameterAddToHeaderOrQuery(localVarQueryParams, "authorizedCount", defaultValue, "form", "")
		r.authorizedCount = &defaultValue
	}
	if r.authorizedServers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "authorizedServers", r.authorizedServers, "form", "")
	}
	if r.defaultTimezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "defaultTimezone", r.defaultTimezone, "form", "")
	}
	if r.smtpPass != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "smtpPass", r.smtpPass, "form", "")
	}
	if r.metaData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metaData", r.metaData, "form", "")
	}
	if r.placementMetaData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "placementMetaData", r.placementMetaData, "form", "")
	}
	if r.ipsFloor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ipsFloor", r.ipsFloor, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "ipsFloor", defaultValue, "form", "")
		r.ipsFloor = &defaultValue
	}
	if r.enableAPNSBadge != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableAPNSBadge", r.enableAPNSBadge, "form", "")
	} else {
		var defaultValue bool = true
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableAPNSBadge", defaultValue, "form", "")
		r.enableAPNSBadge = &defaultValue
	}
	if r.includeInReport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInReport", r.includeInReport, "form", "")
	} else {
		var defaultValue bool = true
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInReport", defaultValue, "form", "")
		r.includeInReport = &defaultValue
	}
	if r.defaultAppFilterId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "defaultAppFilterId", r.defaultAppFilterId, "form", "")
	}
	if r.enableWelcomeEmail != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableWelcomeEmail", r.enableWelcomeEmail, "form", "")
	}
	if r.appleAppId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appleAppId", r.appleAppId, "form", "")
	}
	if r.appleTeamId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appleTeamId", r.appleTeamId, "form", "")
	}
	if r.appleAuthKeyId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appleAuthKeyId", r.appleAuthKeyId, "form", "")
	}
	if r.appleAuthKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appleAuthKey", r.appleAuthKey, "form", "")
	}
	if r.appleIssuerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appleIssuerId", r.appleIssuerId, "form", "")
	}
	if r.appStoreKeyId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appStoreKeyId", r.appStoreKeyId, "form", "")
	}
	if r.appStoreKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appStoreKey", r.appStoreKey, "form", "")
	}
	if r.googlePrivateKeyFile != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "googlePrivateKeyFile", r.googlePrivateKeyFile, "form", "")
	}
	if r.authorizeNetApiKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "authorizeNetApiKey", r.authorizeNetApiKey, "form", "")
	}
	if r.authorizeNetTransactionKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "authorizeNetTransactionKey", r.authorizeNetTransactionKey, "form", "")
	}
	if r.emailSender != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailSender", r.emailSender, "form", "")
	}
	if r.smtpUser != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "smtpUser", r.smtpUser, "form", "")
	}
	if r.smtpHost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "smtpHost", r.smtpHost, "form", "")
	}
	if r.vatomBusinessId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vatomBusinessId", r.vatomBusinessId, "form", "")
	}
	if r.vatomRestClientId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vatomRestClientId", r.vatomRestClientId, "form", "")
	}
	if r.vatomRestSecretKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vatomRestSecretKey", r.vatomRestSecretKey, "form", "")
	}
	if r.twilioAccountSID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "twilioAccountSID", r.twilioAccountSID, "form", "")
	}
	if r.twilioAuthToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "twilioAuthToken", r.twilioAuthToken, "form", "")
	}
	if r.twilioSenderPhoneNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "twilioSenderPhoneNumber", r.twilioSenderPhoneNumber, "form", "")
	}
	if r.openAISecretKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "openAISecretKey", r.openAISecretKey, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateApplicationActiveRequest struct {
	ctx context.Context
	ApiService *ApplicationAPIService
	version float32
	accountId *int64
	appKey *string
	active *bool
}

// The account used to perform the delete, must have rights to edit the application.
func (r ApiUpdateApplicationActiveRequest) AccountId(accountId int64) ApiUpdateApplicationActiveRequest {
	r.accountId = &accountId
	return r
}

// The key of the application to be deleted
func (r ApiUpdateApplicationActiveRequest) AppKey(appKey string) ApiUpdateApplicationActiveRequest {
	r.appKey = &appKey
	return r
}

// If true then set to active, false otherwise
func (r ApiUpdateApplicationActiveRequest) Active(active bool) ApiUpdateApplicationActiveRequest {
	r.active = &active
	return r
}

func (r ApiUpdateApplicationActiveRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.UpdateApplicationActiveExecute(r)
}

/*
UpdateApplicationActive Change Appliation Status

Set the application's active flag to true/false. This effectively activates or deactivates the application.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiUpdateApplicationActiveRequest
*/
func (a *ApplicationAPIService) UpdateApplicationActive(ctx context.Context, version float32) ApiUpdateApplicationActiveRequest {
	return ApiUpdateApplicationActiveRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *ApplicationAPIService) UpdateApplicationActiveExecute(r ApiUpdateApplicationActiveRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationAPIService.UpdateApplicationActive")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/application/active"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.appKey == nil {
		return localVarReturnValue, nil, reportError("appKey is required and must be specified")
	}
	if r.active == nil {
		return localVarReturnValue, nil, reportError("active is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "active", r.active, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateApplicationPlacementRequest struct {
	ctx context.Context
	ApiService *ApplicationAPIService
	version float32
	placementId *int64
	deviceId *string
	accountId *int64
	name *string
	description *string
	size *string
	height *int32
	width *int32
	refreshInterval *int32
	defaultImageId *int64
	active *bool
}

// The id of the placement to update, the user must have rights to the application the ad placement is for
func (r ApiUpdateApplicationPlacementRequest) PlacementId(placementId int64) ApiUpdateApplicationPlacementRequest {
	r.placementId = &placementId
	return r
}

// The unique id of the device making the request (deviceId or accountId required)
func (r ApiUpdateApplicationPlacementRequest) DeviceId(deviceId string) ApiUpdateApplicationPlacementRequest {
	r.deviceId = &deviceId
	return r
}

// The account id of the user (deviceId or accountId required)
func (r ApiUpdateApplicationPlacementRequest) AccountId(accountId int64) ApiUpdateApplicationPlacementRequest {
	r.accountId = &accountId
	return r
}

// The name of the placement
func (r ApiUpdateApplicationPlacementRequest) Name(name string) ApiUpdateApplicationPlacementRequest {
	r.name = &name
	return r
}

// The description of the placement
func (r ApiUpdateApplicationPlacementRequest) Description(description string) ApiUpdateApplicationPlacementRequest {
	r.description = &description
	return r
}

// The ad placement size {BANNER, LEADERBOARD, SKYSCRAPER, INTERSTITIAL, CUSTOM
func (r ApiUpdateApplicationPlacementRequest) Size(size string) ApiUpdateApplicationPlacementRequest {
	r.size = &size
	return r
}

// The height of a custom ad size
func (r ApiUpdateApplicationPlacementRequest) Height(height int32) ApiUpdateApplicationPlacementRequest {
	r.height = &height
	return r
}

// The width of a custom ad size
func (r ApiUpdateApplicationPlacementRequest) Width(width int32) ApiUpdateApplicationPlacementRequest {
	r.width = &width
	return r
}

// The refresh interval in seconds
func (r ApiUpdateApplicationPlacementRequest) RefreshInterval(refreshInterval int32) ApiUpdateApplicationPlacementRequest {
	r.refreshInterval = &refreshInterval
	return r
}

// Default Image Id
func (r ApiUpdateApplicationPlacementRequest) DefaultImageId(defaultImageId int64) ApiUpdateApplicationPlacementRequest {
	r.defaultImageId = &defaultImageId
	return r
}

// Active
func (r ApiUpdateApplicationPlacementRequest) Active(active bool) ApiUpdateApplicationPlacementRequest {
	r.active = &active
	return r
}

func (r ApiUpdateApplicationPlacementRequest) Execute() (*PlacementResponse, *http.Response, error) {
	return r.ApiService.UpdateApplicationPlacementExecute(r)
}

/*
UpdateApplicationPlacement Update Ad Placement

Updates an ad placement for an application.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiUpdateApplicationPlacementRequest
*/
func (a *ApplicationAPIService) UpdateApplicationPlacement(ctx context.Context, version float32) ApiUpdateApplicationPlacementRequest {
	return ApiUpdateApplicationPlacementRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return PlacementResponse
func (a *ApplicationAPIService) UpdateApplicationPlacementExecute(r ApiUpdateApplicationPlacementRequest) (*PlacementResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PlacementResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationAPIService.UpdateApplicationPlacement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/application/placement/update"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.placementId == nil {
		return localVarReturnValue, nil, reportError("placementId is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "placementId", r.placementId, "form", "")
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "form", "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.refreshInterval != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refreshInterval", r.refreshInterval, "form", "")
	}
	if r.defaultImageId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "defaultImageId", r.defaultImageId, "form", "")
	}
	if r.active != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active", r.active, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUploadApplicationCertificateRequest struct {
	ctx context.Context
	ApiService *ApplicationAPIService
	version float32
	appKey *string
	deviceId *string
	accountId *int64
	certificate *os.File
}

// The key of the application
func (r ApiUploadApplicationCertificateRequest) AppKey(appKey string) ApiUploadApplicationCertificateRequest {
	r.appKey = &appKey
	return r
}

// Device Id
func (r ApiUploadApplicationCertificateRequest) DeviceId(deviceId string) ApiUploadApplicationCertificateRequest {
	r.deviceId = &deviceId
	return r
}

// The account used to perform the delete, must have rights to edit the application.
func (r ApiUploadApplicationCertificateRequest) AccountId(accountId int64) ApiUploadApplicationCertificateRequest {
	r.accountId = &accountId
	return r
}

// Certificate
func (r ApiUploadApplicationCertificateRequest) Certificate(certificate *os.File) ApiUploadApplicationCertificateRequest {
	r.certificate = certificate
	return r
}

func (r ApiUploadApplicationCertificateRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.UploadApplicationCertificateExecute(r)
}

/*
UploadApplicationCertificate Create Application Certificate

Uploads a certificate for an application that the user has access to.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiUploadApplicationCertificateRequest
*/
func (a *ApplicationAPIService) UploadApplicationCertificate(ctx context.Context, version float32) ApiUploadApplicationCertificateRequest {
	return ApiUploadApplicationCertificateRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *ApplicationAPIService) UploadApplicationCertificateExecute(r ApiUploadApplicationCertificateRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationAPIService.UploadApplicationCertificate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/application/certificate/create"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.appKey == nil {
		return localVarReturnValue, nil, reportError("appKey is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	if r.certificate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "certificate", r.certificate, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
