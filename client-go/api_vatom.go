/*
Sirqul IoT Platform

Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

API version: 3.16
Contact: info@sirqul.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// VatomAPIService VatomAPI service
type VatomAPIService service

type ApiCreateFollowingRequest struct {
	ctx context.Context
	ApiService *VatomAPIService
	accountId *int64
	vatomParameters *string
	returnRawResponse *bool
}

// Sirqul Account Id
func (r ApiCreateFollowingRequest) AccountId(accountId int64) ApiCreateFollowingRequest {
	r.accountId = &accountId
	return r
}

// Vatom Parameters
func (r ApiCreateFollowingRequest) VatomParameters(vatomParameters string) ApiCreateFollowingRequest {
	r.vatomParameters = &vatomParameters
	return r
}

// Return raw response
func (r ApiCreateFollowingRequest) ReturnRawResponse(returnRawResponse bool) ApiCreateFollowingRequest {
	r.returnRawResponse = &returnRawResponse
	return r
}

func (r ApiCreateFollowingRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateFollowingExecute(r)
}

/*
CreateFollowing Create following

Create following.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateFollowingRequest
*/
func (a *VatomAPIService) CreateFollowing(ctx context.Context) ApiCreateFollowingRequest {
	return ApiCreateFollowingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *VatomAPIService) CreateFollowingExecute(r ApiCreateFollowingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VatomAPIService.CreateFollowing")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vatom/me/rels/following/create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return nil, reportError("accountId is required and must be specified")
	}
	if r.vatomParameters == nil {
		return nil, reportError("vatomParameters is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "vatomParameters", r.vatomParameters, "form", "")
	if r.returnRawResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnRawResponse", r.returnRawResponse, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateSpaceRequest struct {
	ctx context.Context
	ApiService *VatomAPIService
	accountId *int64
	appKey *string
	vatomParameters *string
	returnRawResponse *bool
}

// Sirqul Account Id
func (r ApiCreateSpaceRequest) AccountId(accountId int64) ApiCreateSpaceRequest {
	r.accountId = &accountId
	return r
}

// Sirqul Application Key
func (r ApiCreateSpaceRequest) AppKey(appKey string) ApiCreateSpaceRequest {
	r.appKey = &appKey
	return r
}

// Vatom Parameters
func (r ApiCreateSpaceRequest) VatomParameters(vatomParameters string) ApiCreateSpaceRequest {
	r.vatomParameters = &vatomParameters
	return r
}

// Return raw response
func (r ApiCreateSpaceRequest) ReturnRawResponse(returnRawResponse bool) ApiCreateSpaceRequest {
	r.returnRawResponse = &returnRawResponse
	return r
}

func (r ApiCreateSpaceRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateSpaceExecute(r)
}

/*
CreateSpace Create Vatom Space

Create a Vatom space.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateSpaceRequest
*/
func (a *VatomAPIService) CreateSpace(ctx context.Context) ApiCreateSpaceRequest {
	return ApiCreateSpaceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *VatomAPIService) CreateSpaceExecute(r ApiCreateSpaceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VatomAPIService.CreateSpace")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vatom/b/spaces/create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return nil, reportError("accountId is required and must be specified")
	}
	if r.appKey == nil {
		return nil, reportError("appKey is required and must be specified")
	}
	if r.vatomParameters == nil {
		return nil, reportError("vatomParameters is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "vatomParameters", r.vatomParameters, "form", "")
	if r.returnRawResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnRawResponse", r.returnRawResponse, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateVatomEventRequest struct {
	ctx context.Context
	ApiService *VatomAPIService
	accountId *int64
	appKey *string
	vatomParameters *string
	returnRawResponse *bool
}

// Sirqul Account Id
func (r ApiCreateVatomEventRequest) AccountId(accountId int64) ApiCreateVatomEventRequest {
	r.accountId = &accountId
	return r
}

// Sirqul Application Key
func (r ApiCreateVatomEventRequest) AppKey(appKey string) ApiCreateVatomEventRequest {
	r.appKey = &appKey
	return r
}

// Vatom Parameters
func (r ApiCreateVatomEventRequest) VatomParameters(vatomParameters string) ApiCreateVatomEventRequest {
	r.vatomParameters = &vatomParameters
	return r
}

// Return raw response
func (r ApiCreateVatomEventRequest) ReturnRawResponse(returnRawResponse bool) ApiCreateVatomEventRequest {
	r.returnRawResponse = &returnRawResponse
	return r
}

func (r ApiCreateVatomEventRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateVatomEventExecute(r)
}

/*
CreateVatomEvent Create Vatom Event

Create a Vatom event.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateVatomEventRequest
*/
func (a *VatomAPIService) CreateVatomEvent(ctx context.Context) ApiCreateVatomEventRequest {
	return ApiCreateVatomEventRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *VatomAPIService) CreateVatomEventExecute(r ApiCreateVatomEventRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VatomAPIService.CreateVatomEvent")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vatom/b/events/create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return nil, reportError("accountId is required and must be specified")
	}
	if r.appKey == nil {
		return nil, reportError("appKey is required and must be specified")
	}
	if r.vatomParameters == nil {
		return nil, reportError("vatomParameters is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "vatomParameters", r.vatomParameters, "form", "")
	if r.returnRawResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnRawResponse", r.returnRawResponse, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteFollowingRequest struct {
	ctx context.Context
	ApiService *VatomAPIService
	accountId *int64
	vatomRelsKey *string
	returnRawResponse *bool
}

// Sirqul Account Id
func (r ApiDeleteFollowingRequest) AccountId(accountId int64) ApiDeleteFollowingRequest {
	r.accountId = &accountId
	return r
}

// Vatom Rels Key
func (r ApiDeleteFollowingRequest) VatomRelsKey(vatomRelsKey string) ApiDeleteFollowingRequest {
	r.vatomRelsKey = &vatomRelsKey
	return r
}

// Return raw response
func (r ApiDeleteFollowingRequest) ReturnRawResponse(returnRawResponse bool) ApiDeleteFollowingRequest {
	r.returnRawResponse = &returnRawResponse
	return r
}

func (r ApiDeleteFollowingRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteFollowingExecute(r)
}

/*
DeleteFollowing Delete following

Delete following.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteFollowingRequest
*/
func (a *VatomAPIService) DeleteFollowing(ctx context.Context) ApiDeleteFollowingRequest {
	return ApiDeleteFollowingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *VatomAPIService) DeleteFollowingExecute(r ApiDeleteFollowingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VatomAPIService.DeleteFollowing")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vatom/me/rels/following/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return nil, reportError("accountId is required and must be specified")
	}
	if r.vatomRelsKey == nil {
		return nil, reportError("vatomRelsKey is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "vatomRelsKey", r.vatomRelsKey, "form", "")
	if r.returnRawResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnRawResponse", r.returnRawResponse, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeletePointsBalanceRequest struct {
	ctx context.Context
	ApiService *VatomAPIService
	accountId *int64
	appKey *string
	vatomCampaignId *string
	returnRawResponse *bool
}

// Sirqul Account Id
func (r ApiDeletePointsBalanceRequest) AccountId(accountId int64) ApiDeletePointsBalanceRequest {
	r.accountId = &accountId
	return r
}

// Sirqul Application Key
func (r ApiDeletePointsBalanceRequest) AppKey(appKey string) ApiDeletePointsBalanceRequest {
	r.appKey = &appKey
	return r
}

// Vatom Campaign Id
func (r ApiDeletePointsBalanceRequest) VatomCampaignId(vatomCampaignId string) ApiDeletePointsBalanceRequest {
	r.vatomCampaignId = &vatomCampaignId
	return r
}

// Return raw response
func (r ApiDeletePointsBalanceRequest) ReturnRawResponse(returnRawResponse bool) ApiDeletePointsBalanceRequest {
	r.returnRawResponse = &returnRawResponse
	return r
}

func (r ApiDeletePointsBalanceRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeletePointsBalanceExecute(r)
}

/*
DeletePointsBalance Reset All Points Balance

Reset All Points Balance.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeletePointsBalanceRequest
*/
func (a *VatomAPIService) DeletePointsBalance(ctx context.Context) ApiDeletePointsBalanceRequest {
	return ApiDeletePointsBalanceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *VatomAPIService) DeletePointsBalanceExecute(r ApiDeletePointsBalanceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VatomAPIService.DeletePointsBalance")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vatom/b/campaign/points/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return nil, reportError("accountId is required and must be specified")
	}
	if r.appKey == nil {
		return nil, reportError("appKey is required and must be specified")
	}
	if r.vatomCampaignId == nil {
		return nil, reportError("vatomCampaignId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "vatomCampaignId", r.vatomCampaignId, "form", "")
	if r.returnRawResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnRawResponse", r.returnRawResponse, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteSpaceRequest struct {
	ctx context.Context
	ApiService *VatomAPIService
	accountId *int64
	appKey *string
	vatomSpaceId *string
	returnRawResponse *bool
}

// Sirqul Account Id
func (r ApiDeleteSpaceRequest) AccountId(accountId int64) ApiDeleteSpaceRequest {
	r.accountId = &accountId
	return r
}

// Sirqul Application Key
func (r ApiDeleteSpaceRequest) AppKey(appKey string) ApiDeleteSpaceRequest {
	r.appKey = &appKey
	return r
}

// Vatom Space Id
func (r ApiDeleteSpaceRequest) VatomSpaceId(vatomSpaceId string) ApiDeleteSpaceRequest {
	r.vatomSpaceId = &vatomSpaceId
	return r
}

// Return raw response
func (r ApiDeleteSpaceRequest) ReturnRawResponse(returnRawResponse bool) ApiDeleteSpaceRequest {
	r.returnRawResponse = &returnRawResponse
	return r
}

func (r ApiDeleteSpaceRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteSpaceExecute(r)
}

/*
DeleteSpace Delete Vatom Space

Delete a Vatom space.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteSpaceRequest
*/
func (a *VatomAPIService) DeleteSpace(ctx context.Context) ApiDeleteSpaceRequest {
	return ApiDeleteSpaceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *VatomAPIService) DeleteSpaceExecute(r ApiDeleteSpaceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VatomAPIService.DeleteSpace")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vatom/b/spaces/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return nil, reportError("accountId is required and must be specified")
	}
	if r.appKey == nil {
		return nil, reportError("appKey is required and must be specified")
	}
	if r.vatomSpaceId == nil {
		return nil, reportError("vatomSpaceId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "vatomSpaceId", r.vatomSpaceId, "form", "")
	if r.returnRawResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnRawResponse", r.returnRawResponse, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteVatomEventRequest struct {
	ctx context.Context
	ApiService *VatomAPIService
	accountId *int64
	appKey *string
	vatomEventId *string
	returnRawResponse *bool
}

// Sirqul Account Id
func (r ApiDeleteVatomEventRequest) AccountId(accountId int64) ApiDeleteVatomEventRequest {
	r.accountId = &accountId
	return r
}

// Sirqul Application Key
func (r ApiDeleteVatomEventRequest) AppKey(appKey string) ApiDeleteVatomEventRequest {
	r.appKey = &appKey
	return r
}

// Vatom Event Id
func (r ApiDeleteVatomEventRequest) VatomEventId(vatomEventId string) ApiDeleteVatomEventRequest {
	r.vatomEventId = &vatomEventId
	return r
}

// Return raw response
func (r ApiDeleteVatomEventRequest) ReturnRawResponse(returnRawResponse bool) ApiDeleteVatomEventRequest {
	r.returnRawResponse = &returnRawResponse
	return r
}

func (r ApiDeleteVatomEventRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteVatomEventExecute(r)
}

/*
DeleteVatomEvent Delete Vatom Event

Delete a Vatom event.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteVatomEventRequest
*/
func (a *VatomAPIService) DeleteVatomEvent(ctx context.Context) ApiDeleteVatomEventRequest {
	return ApiDeleteVatomEventRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *VatomAPIService) DeleteVatomEventExecute(r ApiDeleteVatomEventRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VatomAPIService.DeleteVatomEvent")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vatom/b/events/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return nil, reportError("accountId is required and must be specified")
	}
	if r.appKey == nil {
		return nil, reportError("appKey is required and must be specified")
	}
	if r.vatomEventId == nil {
		return nil, reportError("vatomEventId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "vatomEventId", r.vatomEventId, "form", "")
	if r.returnRawResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnRawResponse", r.returnRawResponse, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteVatomNFTRequest struct {
	ctx context.Context
	ApiService *VatomAPIService
	accountId *int64
	vatomId *string
	returnRawResponse *bool
}

// Sirqul Account Id
func (r ApiDeleteVatomNFTRequest) AccountId(accountId int64) ApiDeleteVatomNFTRequest {
	r.accountId = &accountId
	return r
}

// Vatom NFT Id
func (r ApiDeleteVatomNFTRequest) VatomId(vatomId string) ApiDeleteVatomNFTRequest {
	r.vatomId = &vatomId
	return r
}

// Return raw response
func (r ApiDeleteVatomNFTRequest) ReturnRawResponse(returnRawResponse bool) ApiDeleteVatomNFTRequest {
	r.returnRawResponse = &returnRawResponse
	return r
}

func (r ApiDeleteVatomNFTRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteVatomNFTExecute(r)
}

/*
DeleteVatomNFT Delete Vatom NFT

Delete Vatom NFT

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteVatomNFTRequest
*/
func (a *VatomAPIService) DeleteVatomNFT(ctx context.Context) ApiDeleteVatomNFTRequest {
	return ApiDeleteVatomNFTRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *VatomAPIService) DeleteVatomNFTExecute(r ApiDeleteVatomNFTRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VatomAPIService.DeleteVatomNFT")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vatom/vatoms/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return nil, reportError("accountId is required and must be specified")
	}
	if r.vatomId == nil {
		return nil, reportError("vatomId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "vatomId", r.vatomId, "form", "")
	if r.returnRawResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnRawResponse", r.returnRawResponse, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiExecuteActionOnNFTRequest struct {
	ctx context.Context
	ApiService *VatomAPIService
	accountId *int64
	vatomId *string
	vatomParameters *string
	returnRawResponse *bool
}

// Sirqul Account Id
func (r ApiExecuteActionOnNFTRequest) AccountId(accountId int64) ApiExecuteActionOnNFTRequest {
	r.accountId = &accountId
	return r
}

// Vatom NFT Id
func (r ApiExecuteActionOnNFTRequest) VatomId(vatomId string) ApiExecuteActionOnNFTRequest {
	r.vatomId = &vatomId
	return r
}

// Vatom Parameters
func (r ApiExecuteActionOnNFTRequest) VatomParameters(vatomParameters string) ApiExecuteActionOnNFTRequest {
	r.vatomParameters = &vatomParameters
	return r
}

// Return raw response
func (r ApiExecuteActionOnNFTRequest) ReturnRawResponse(returnRawResponse bool) ApiExecuteActionOnNFTRequest {
	r.returnRawResponse = &returnRawResponse
	return r
}

func (r ApiExecuteActionOnNFTRequest) Execute() (*http.Response, error) {
	return r.ApiService.ExecuteActionOnNFTExecute(r)
}

/*
ExecuteActionOnNFT Execute Action on NFT

Execute Action on NFT.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiExecuteActionOnNFTRequest
*/
func (a *VatomAPIService) ExecuteActionOnNFT(ctx context.Context) ApiExecuteActionOnNFTRequest {
	return ApiExecuteActionOnNFTRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *VatomAPIService) ExecuteActionOnNFTExecute(r ApiExecuteActionOnNFTRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VatomAPIService.ExecuteActionOnNFT")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vatom/vatoms/execute-action"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return nil, reportError("accountId is required and must be specified")
	}
	if r.vatomId == nil {
		return nil, reportError("vatomId is required and must be specified")
	}
	if r.vatomParameters == nil {
		return nil, reportError("vatomParameters is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "vatomId", r.vatomId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "vatomParameters", r.vatomParameters, "form", "")
	if r.returnRawResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnRawResponse", r.returnRawResponse, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGeomapSearchRequest struct {
	ctx context.Context
	ApiService *VatomAPIService
	accountId *int64
	vatomParameters *string
	returnRawResponse *bool
}

// Sirqul Account Id
func (r ApiGeomapSearchRequest) AccountId(accountId int64) ApiGeomapSearchRequest {
	r.accountId = &accountId
	return r
}

// Vatom Parameters
func (r ApiGeomapSearchRequest) VatomParameters(vatomParameters string) ApiGeomapSearchRequest {
	r.vatomParameters = &vatomParameters
	return r
}

// Return raw response
func (r ApiGeomapSearchRequest) ReturnRawResponse(returnRawResponse bool) ApiGeomapSearchRequest {
	r.returnRawResponse = &returnRawResponse
	return r
}

func (r ApiGeomapSearchRequest) Execute() (*http.Response, error) {
	return r.ApiService.GeomapSearchExecute(r)
}

/*
GeomapSearch Search Vatom Geo Map

Search Vatom Geo Map

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGeomapSearchRequest
*/
func (a *VatomAPIService) GeomapSearch(ctx context.Context) ApiGeomapSearchRequest {
	return ApiGeomapSearchRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *VatomAPIService) GeomapSearchExecute(r ApiGeomapSearchRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VatomAPIService.GeomapSearch")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vatom/vatoms/geo-map/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return nil, reportError("accountId is required and must be specified")
	}
	if r.vatomParameters == nil {
		return nil, reportError("vatomParameters is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "vatomParameters", r.vatomParameters, "form", "")
	if r.returnRawResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnRawResponse", r.returnRawResponse, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetBusinessBehaviorsRequest struct {
	ctx context.Context
	ApiService *VatomAPIService
	accountId *int64
	appKey *string
	returnRawResponse *bool
}

// Sirqul Account Id
func (r ApiGetBusinessBehaviorsRequest) AccountId(accountId int64) ApiGetBusinessBehaviorsRequest {
	r.accountId = &accountId
	return r
}

// Sirqul Application Key
func (r ApiGetBusinessBehaviorsRequest) AppKey(appKey string) ApiGetBusinessBehaviorsRequest {
	r.appKey = &appKey
	return r
}

// Return raw response
func (r ApiGetBusinessBehaviorsRequest) ReturnRawResponse(returnRawResponse bool) ApiGetBusinessBehaviorsRequest {
	r.returnRawResponse = &returnRawResponse
	return r
}

func (r ApiGetBusinessBehaviorsRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetBusinessBehaviorsExecute(r)
}

/*
GetBusinessBehaviors Get Vatom Business Behaviors

Gets the behaviors of a business.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetBusinessBehaviorsRequest
*/
func (a *VatomAPIService) GetBusinessBehaviors(ctx context.Context) ApiGetBusinessBehaviorsRequest {
	return ApiGetBusinessBehaviorsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *VatomAPIService) GetBusinessBehaviorsExecute(r ApiGetBusinessBehaviorsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VatomAPIService.GetBusinessBehaviors")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vatom/b/behaviors"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return nil, reportError("accountId is required and must be specified")
	}
	if r.appKey == nil {
		return nil, reportError("appKey is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	if r.returnRawResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnRawResponse", r.returnRawResponse, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetBusinessCoinsBalanceRequest struct {
	ctx context.Context
	ApiService *VatomAPIService
	accountId *int64
	appKey *string
	returnRawResponse *bool
}

// Sirqul Account Id
func (r ApiGetBusinessCoinsBalanceRequest) AccountId(accountId int64) ApiGetBusinessCoinsBalanceRequest {
	r.accountId = &accountId
	return r
}

// Sirqul Application Key
func (r ApiGetBusinessCoinsBalanceRequest) AppKey(appKey string) ApiGetBusinessCoinsBalanceRequest {
	r.appKey = &appKey
	return r
}

// Return raw response
func (r ApiGetBusinessCoinsBalanceRequest) ReturnRawResponse(returnRawResponse bool) ApiGetBusinessCoinsBalanceRequest {
	r.returnRawResponse = &returnRawResponse
	return r
}

func (r ApiGetBusinessCoinsBalanceRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetBusinessCoinsBalanceExecute(r)
}

/*
GetBusinessCoinsBalance Get the coins for a Business

Get the coins for a Businesss.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetBusinessCoinsBalanceRequest
*/
func (a *VatomAPIService) GetBusinessCoinsBalance(ctx context.Context) ApiGetBusinessCoinsBalanceRequest {
	return ApiGetBusinessCoinsBalanceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *VatomAPIService) GetBusinessCoinsBalanceExecute(r ApiGetBusinessCoinsBalanceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VatomAPIService.GetBusinessCoinsBalance")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vatom/b/coins/get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return nil, reportError("accountId is required and must be specified")
	}
	if r.appKey == nil {
		return nil, reportError("appKey is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	if r.returnRawResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnRawResponse", r.returnRawResponse, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetBusinessIdsRequest struct {
	ctx context.Context
	ApiService *VatomAPIService
	accountId *int64
	returnRawResponse *bool
}

// Sirqul Account Id
func (r ApiGetBusinessIdsRequest) AccountId(accountId int64) ApiGetBusinessIdsRequest {
	r.accountId = &accountId
	return r
}

// Return raw response
func (r ApiGetBusinessIdsRequest) ReturnRawResponse(returnRawResponse bool) ApiGetBusinessIdsRequest {
	r.returnRawResponse = &returnRawResponse
	return r
}

func (r ApiGetBusinessIdsRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetBusinessIdsExecute(r)
}

/*
GetBusinessIds Get the user business ids

Get the business ids the logged in user has access to.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetBusinessIdsRequest
*/
func (a *VatomAPIService) GetBusinessIds(ctx context.Context) ApiGetBusinessIdsRequest {
	return ApiGetBusinessIdsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *VatomAPIService) GetBusinessIdsExecute(r ApiGetBusinessIdsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VatomAPIService.GetBusinessIds")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vatom/me/businesses"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return nil, reportError("accountId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	if r.returnRawResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnRawResponse", r.returnRawResponse, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetBusinessInfoRequest struct {
	ctx context.Context
	ApiService *VatomAPIService
	accountId *int64
	appKey *string
	vatomParameters *string
	returnRawResponse *bool
}

// Sirqul Account Id
func (r ApiGetBusinessInfoRequest) AccountId(accountId int64) ApiGetBusinessInfoRequest {
	r.accountId = &accountId
	return r
}

// Sirqul Application Key
func (r ApiGetBusinessInfoRequest) AppKey(appKey string) ApiGetBusinessInfoRequest {
	r.appKey = &appKey
	return r
}

// Vatom Parameters
func (r ApiGetBusinessInfoRequest) VatomParameters(vatomParameters string) ApiGetBusinessInfoRequest {
	r.vatomParameters = &vatomParameters
	return r
}

// Return raw response
func (r ApiGetBusinessInfoRequest) ReturnRawResponse(returnRawResponse bool) ApiGetBusinessInfoRequest {
	r.returnRawResponse = &returnRawResponse
	return r
}

func (r ApiGetBusinessInfoRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetBusinessInfoExecute(r)
}

/*
GetBusinessInfo Get Vatom Business Info

Gets the business info tied to this account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetBusinessInfoRequest
*/
func (a *VatomAPIService) GetBusinessInfo(ctx context.Context) ApiGetBusinessInfoRequest {
	return ApiGetBusinessInfoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *VatomAPIService) GetBusinessInfoExecute(r ApiGetBusinessInfoRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VatomAPIService.GetBusinessInfo")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vatom/b/get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return nil, reportError("accountId is required and must be specified")
	}
	if r.appKey == nil {
		return nil, reportError("appKey is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	if r.vatomParameters != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vatomParameters", r.vatomParameters, "form", "")
	}
	if r.returnRawResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnRawResponse", r.returnRawResponse, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetBusinessUsersRequest struct {
	ctx context.Context
	ApiService *VatomAPIService
	accountId *int64
	appKey *string
	returnRawResponse *bool
}

// Sirqul Account Id
func (r ApiGetBusinessUsersRequest) AccountId(accountId int64) ApiGetBusinessUsersRequest {
	r.accountId = &accountId
	return r
}

// Sirqul Application Key
func (r ApiGetBusinessUsersRequest) AppKey(appKey string) ApiGetBusinessUsersRequest {
	r.appKey = &appKey
	return r
}

// Return raw response
func (r ApiGetBusinessUsersRequest) ReturnRawResponse(returnRawResponse bool) ApiGetBusinessUsersRequest {
	r.returnRawResponse = &returnRawResponse
	return r
}

func (r ApiGetBusinessUsersRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetBusinessUsersExecute(r)
}

/*
GetBusinessUsers Get Vatom Business Users

Gets the users of a business.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetBusinessUsersRequest
*/
func (a *VatomAPIService) GetBusinessUsers(ctx context.Context) ApiGetBusinessUsersRequest {
	return ApiGetBusinessUsersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *VatomAPIService) GetBusinessUsersExecute(r ApiGetBusinessUsersRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VatomAPIService.GetBusinessUsers")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vatom/b/users"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return nil, reportError("accountId is required and must be specified")
	}
	if r.appKey == nil {
		return nil, reportError("appKey is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	if r.returnRawResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnRawResponse", r.returnRawResponse, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetCampaignGroupEntitiesRequest struct {
	ctx context.Context
	ApiService *VatomAPIService
	accountId *int64
	appKey *string
	vatomCampaignId *string
	returnRawResponse *bool
}

// Sirqul Account Id
func (r ApiGetCampaignGroupEntitiesRequest) AccountId(accountId int64) ApiGetCampaignGroupEntitiesRequest {
	r.accountId = &accountId
	return r
}

// Sirqul Application Key
func (r ApiGetCampaignGroupEntitiesRequest) AppKey(appKey string) ApiGetCampaignGroupEntitiesRequest {
	r.appKey = &appKey
	return r
}

// Vatom Campaign Id
func (r ApiGetCampaignGroupEntitiesRequest) VatomCampaignId(vatomCampaignId string) ApiGetCampaignGroupEntitiesRequest {
	r.vatomCampaignId = &vatomCampaignId
	return r
}

// Return raw response
func (r ApiGetCampaignGroupEntitiesRequest) ReturnRawResponse(returnRawResponse bool) ApiGetCampaignGroupEntitiesRequest {
	r.returnRawResponse = &returnRawResponse
	return r
}

func (r ApiGetCampaignGroupEntitiesRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetCampaignGroupEntitiesExecute(r)
}

/*
GetCampaignGroupEntities Get Campaign Group Entities

Get campaign group entities.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCampaignGroupEntitiesRequest
*/
func (a *VatomAPIService) GetCampaignGroupEntities(ctx context.Context) ApiGetCampaignGroupEntitiesRequest {
	return ApiGetCampaignGroupEntitiesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *VatomAPIService) GetCampaignGroupEntitiesExecute(r ApiGetCampaignGroupEntitiesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VatomAPIService.GetCampaignGroupEntities")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vatom/b/campaign-groups/entities"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return nil, reportError("accountId is required and must be specified")
	}
	if r.appKey == nil {
		return nil, reportError("appKey is required and must be specified")
	}
	if r.vatomCampaignId == nil {
		return nil, reportError("vatomCampaignId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "vatomCampaignId", r.vatomCampaignId, "form", "")
	if r.returnRawResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnRawResponse", r.returnRawResponse, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetCampaignGroupRulesRequest struct {
	ctx context.Context
	ApiService *VatomAPIService
	accountId *int64
	appKey *string
	vatomCampaignId *string
	returnRawResponse *bool
}

// Sirqul Account Id
func (r ApiGetCampaignGroupRulesRequest) AccountId(accountId int64) ApiGetCampaignGroupRulesRequest {
	r.accountId = &accountId
	return r
}

// Sirqul Application Key
func (r ApiGetCampaignGroupRulesRequest) AppKey(appKey string) ApiGetCampaignGroupRulesRequest {
	r.appKey = &appKey
	return r
}

// Vatom Campaign Id
func (r ApiGetCampaignGroupRulesRequest) VatomCampaignId(vatomCampaignId string) ApiGetCampaignGroupRulesRequest {
	r.vatomCampaignId = &vatomCampaignId
	return r
}

// Return raw response
func (r ApiGetCampaignGroupRulesRequest) ReturnRawResponse(returnRawResponse bool) ApiGetCampaignGroupRulesRequest {
	r.returnRawResponse = &returnRawResponse
	return r
}

func (r ApiGetCampaignGroupRulesRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetCampaignGroupRulesExecute(r)
}

/*
GetCampaignGroupRules Get Campaign Group Rules

Get campaign group rules.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCampaignGroupRulesRequest
*/
func (a *VatomAPIService) GetCampaignGroupRules(ctx context.Context) ApiGetCampaignGroupRulesRequest {
	return ApiGetCampaignGroupRulesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *VatomAPIService) GetCampaignGroupRulesExecute(r ApiGetCampaignGroupRulesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VatomAPIService.GetCampaignGroupRules")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vatom/b/campaign-groups/rules"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return nil, reportError("accountId is required and must be specified")
	}
	if r.appKey == nil {
		return nil, reportError("appKey is required and must be specified")
	}
	if r.vatomCampaignId == nil {
		return nil, reportError("vatomCampaignId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "vatomCampaignId", r.vatomCampaignId, "form", "")
	if r.returnRawResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnRawResponse", r.returnRawResponse, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetCampaignGroupStatsRequest struct {
	ctx context.Context
	ApiService *VatomAPIService
	accountId *int64
	appKey *string
	vatomCampaignId *string
	returnRawResponse *bool
}

// Sirqul Account Id
func (r ApiGetCampaignGroupStatsRequest) AccountId(accountId int64) ApiGetCampaignGroupStatsRequest {
	r.accountId = &accountId
	return r
}

// Sirqul Application Key
func (r ApiGetCampaignGroupStatsRequest) AppKey(appKey string) ApiGetCampaignGroupStatsRequest {
	r.appKey = &appKey
	return r
}

// Vatom Campaign Id
func (r ApiGetCampaignGroupStatsRequest) VatomCampaignId(vatomCampaignId string) ApiGetCampaignGroupStatsRequest {
	r.vatomCampaignId = &vatomCampaignId
	return r
}

// Return raw response
func (r ApiGetCampaignGroupStatsRequest) ReturnRawResponse(returnRawResponse bool) ApiGetCampaignGroupStatsRequest {
	r.returnRawResponse = &returnRawResponse
	return r
}

func (r ApiGetCampaignGroupStatsRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetCampaignGroupStatsExecute(r)
}

/*
GetCampaignGroupStats Get Campaign Group Stats

Get campaign group stats.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCampaignGroupStatsRequest
*/
func (a *VatomAPIService) GetCampaignGroupStats(ctx context.Context) ApiGetCampaignGroupStatsRequest {
	return ApiGetCampaignGroupStatsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *VatomAPIService) GetCampaignGroupStatsExecute(r ApiGetCampaignGroupStatsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VatomAPIService.GetCampaignGroupStats")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vatom/b/campaign-groups/stats"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return nil, reportError("accountId is required and must be specified")
	}
	if r.appKey == nil {
		return nil, reportError("appKey is required and must be specified")
	}
	if r.vatomCampaignId == nil {
		return nil, reportError("vatomCampaignId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "vatomCampaignId", r.vatomCampaignId, "form", "")
	if r.returnRawResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnRawResponse", r.returnRawResponse, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetCampaignInfoRequest struct {
	ctx context.Context
	ApiService *VatomAPIService
	accountId *int64
	appKey *string
	vatomCampaignId *string
	returnRawResponse *bool
}

// Sirqul Account Id
func (r ApiGetCampaignInfoRequest) AccountId(accountId int64) ApiGetCampaignInfoRequest {
	r.accountId = &accountId
	return r
}

// Sirqul Application Key
func (r ApiGetCampaignInfoRequest) AppKey(appKey string) ApiGetCampaignInfoRequest {
	r.appKey = &appKey
	return r
}

// Vatom Campaign Id
func (r ApiGetCampaignInfoRequest) VatomCampaignId(vatomCampaignId string) ApiGetCampaignInfoRequest {
	r.vatomCampaignId = &vatomCampaignId
	return r
}

// Return raw response
func (r ApiGetCampaignInfoRequest) ReturnRawResponse(returnRawResponse bool) ApiGetCampaignInfoRequest {
	r.returnRawResponse = &returnRawResponse
	return r
}

func (r ApiGetCampaignInfoRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetCampaignInfoExecute(r)
}

/*
GetCampaignInfo Get Campaign Info

Gets the info on a campaign.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCampaignInfoRequest
*/
func (a *VatomAPIService) GetCampaignInfo(ctx context.Context) ApiGetCampaignInfoRequest {
	return ApiGetCampaignInfoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *VatomAPIService) GetCampaignInfoExecute(r ApiGetCampaignInfoRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VatomAPIService.GetCampaignInfo")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vatom/b/campaign-groups/get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return nil, reportError("accountId is required and must be specified")
	}
	if r.appKey == nil {
		return nil, reportError("appKey is required and must be specified")
	}
	if r.vatomCampaignId == nil {
		return nil, reportError("vatomCampaignId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "vatomCampaignId", r.vatomCampaignId, "form", "")
	if r.returnRawResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnRawResponse", r.returnRawResponse, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetEventGuestListRequest struct {
	ctx context.Context
	ApiService *VatomAPIService
	accountId *int64
	appKey *string
	vatomEventId *string
	returnRawResponse *bool
}

// Sirqul Account Id
func (r ApiGetEventGuestListRequest) AccountId(accountId int64) ApiGetEventGuestListRequest {
	r.accountId = &accountId
	return r
}

// Sirqul Application Key
func (r ApiGetEventGuestListRequest) AppKey(appKey string) ApiGetEventGuestListRequest {
	r.appKey = &appKey
	return r
}

// Vatom Event Id
func (r ApiGetEventGuestListRequest) VatomEventId(vatomEventId string) ApiGetEventGuestListRequest {
	r.vatomEventId = &vatomEventId
	return r
}

// Return raw response
func (r ApiGetEventGuestListRequest) ReturnRawResponse(returnRawResponse bool) ApiGetEventGuestListRequest {
	r.returnRawResponse = &returnRawResponse
	return r
}

func (r ApiGetEventGuestListRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetEventGuestListExecute(r)
}

/*
GetEventGuestList Get Vatom Event Guest List

Gets the guest list of an event.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEventGuestListRequest
*/
func (a *VatomAPIService) GetEventGuestList(ctx context.Context) ApiGetEventGuestListRequest {
	return ApiGetEventGuestListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *VatomAPIService) GetEventGuestListExecute(r ApiGetEventGuestListRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VatomAPIService.GetEventGuestList")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vatom/b/events/guests/get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return nil, reportError("accountId is required and must be specified")
	}
	if r.appKey == nil {
		return nil, reportError("appKey is required and must be specified")
	}
	if r.vatomEventId == nil {
		return nil, reportError("vatomEventId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "vatomEventId", r.vatomEventId, "form", "")
	if r.returnRawResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnRawResponse", r.returnRawResponse, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetInventoryRequest struct {
	ctx context.Context
	ApiService *VatomAPIService
	accountId *int64
	vatomParameters *string
	returnRawResponse *bool
}

// Sirqul Account Id
func (r ApiGetInventoryRequest) AccountId(accountId int64) ApiGetInventoryRequest {
	r.accountId = &accountId
	return r
}

// Vatom Parameters
func (r ApiGetInventoryRequest) VatomParameters(vatomParameters string) ApiGetInventoryRequest {
	r.vatomParameters = &vatomParameters
	return r
}

// Return raw response
func (r ApiGetInventoryRequest) ReturnRawResponse(returnRawResponse bool) ApiGetInventoryRequest {
	r.returnRawResponse = &returnRawResponse
	return r
}

func (r ApiGetInventoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetInventoryExecute(r)
}

/*
GetInventory Get Vatom User's Inventory

Gets the logged in user's Vatom Inventory.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetInventoryRequest
*/
func (a *VatomAPIService) GetInventory(ctx context.Context) ApiGetInventoryRequest {
	return ApiGetInventoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *VatomAPIService) GetInventoryExecute(r ApiGetInventoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VatomAPIService.GetInventory")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vatom/me/inventory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return nil, reportError("accountId is required and must be specified")
	}
	if r.vatomParameters == nil {
		return nil, reportError("vatomParameters is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "vatomParameters", r.vatomParameters, "form", "")
	if r.returnRawResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnRawResponse", r.returnRawResponse, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetMyFollowingRequest struct {
	ctx context.Context
	ApiService *VatomAPIService
	accountId *int64
	returnRawResponse *bool
}

// Sirqul Account Id
func (r ApiGetMyFollowingRequest) AccountId(accountId int64) ApiGetMyFollowingRequest {
	r.accountId = &accountId
	return r
}

// Return raw response
func (r ApiGetMyFollowingRequest) ReturnRawResponse(returnRawResponse bool) ApiGetMyFollowingRequest {
	r.returnRawResponse = &returnRawResponse
	return r
}

func (r ApiGetMyFollowingRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetMyFollowingExecute(r)
}

/*
GetMyFollowing Get following

Get following.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMyFollowingRequest
*/
func (a *VatomAPIService) GetMyFollowing(ctx context.Context) ApiGetMyFollowingRequest {
	return ApiGetMyFollowingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *VatomAPIService) GetMyFollowingExecute(r ApiGetMyFollowingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VatomAPIService.GetMyFollowing")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vatom/me/rels/following"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return nil, reportError("accountId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	if r.returnRawResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnRawResponse", r.returnRawResponse, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetPointsBalanceRequest struct {
	ctx context.Context
	ApiService *VatomAPIService
	accountId *int64
	vatomUserId *string
	vatomCampaignId *string
	returnRawResponse *bool
}

// Sirqul Account Id
func (r ApiGetPointsBalanceRequest) AccountId(accountId int64) ApiGetPointsBalanceRequest {
	r.accountId = &accountId
	return r
}

// Vatom User Id
func (r ApiGetPointsBalanceRequest) VatomUserId(vatomUserId string) ApiGetPointsBalanceRequest {
	r.vatomUserId = &vatomUserId
	return r
}

// Vatom Campaign Id
func (r ApiGetPointsBalanceRequest) VatomCampaignId(vatomCampaignId string) ApiGetPointsBalanceRequest {
	r.vatomCampaignId = &vatomCampaignId
	return r
}

// Return raw response
func (r ApiGetPointsBalanceRequest) ReturnRawResponse(returnRawResponse bool) ApiGetPointsBalanceRequest {
	r.returnRawResponse = &returnRawResponse
	return r
}

func (r ApiGetPointsBalanceRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetPointsBalanceExecute(r)
}

/*
GetPointsBalance Get Points Balance

Gets the points balance of a Vatom user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetPointsBalanceRequest
*/
func (a *VatomAPIService) GetPointsBalance(ctx context.Context) ApiGetPointsBalanceRequest {
	return ApiGetPointsBalanceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *VatomAPIService) GetPointsBalanceExecute(r ApiGetPointsBalanceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VatomAPIService.GetPointsBalance")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vatom/u/campaign/points/get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return nil, reportError("accountId is required and must be specified")
	}
	if r.vatomUserId == nil {
		return nil, reportError("vatomUserId is required and must be specified")
	}
	if r.vatomCampaignId == nil {
		return nil, reportError("vatomCampaignId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "vatomUserId", r.vatomUserId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "vatomCampaignId", r.vatomCampaignId, "form", "")
	if r.returnRawResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnRawResponse", r.returnRawResponse, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetPointsBalanceAsBusinessRequest struct {
	ctx context.Context
	ApiService *VatomAPIService
	accountId *int64
	appKey *string
	vatomUserId *string
	vatomCampaignId *string
	returnRawResponse *bool
}

// Sirqul Account Id
func (r ApiGetPointsBalanceAsBusinessRequest) AccountId(accountId int64) ApiGetPointsBalanceAsBusinessRequest {
	r.accountId = &accountId
	return r
}

// Sirqul Application Key
func (r ApiGetPointsBalanceAsBusinessRequest) AppKey(appKey string) ApiGetPointsBalanceAsBusinessRequest {
	r.appKey = &appKey
	return r
}

// Vatom User Id
func (r ApiGetPointsBalanceAsBusinessRequest) VatomUserId(vatomUserId string) ApiGetPointsBalanceAsBusinessRequest {
	r.vatomUserId = &vatomUserId
	return r
}

// Vatom Campaign Id
func (r ApiGetPointsBalanceAsBusinessRequest) VatomCampaignId(vatomCampaignId string) ApiGetPointsBalanceAsBusinessRequest {
	r.vatomCampaignId = &vatomCampaignId
	return r
}

// Return raw response
func (r ApiGetPointsBalanceAsBusinessRequest) ReturnRawResponse(returnRawResponse bool) ApiGetPointsBalanceAsBusinessRequest {
	r.returnRawResponse = &returnRawResponse
	return r
}

func (r ApiGetPointsBalanceAsBusinessRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetPointsBalanceAsBusinessExecute(r)
}

/*
GetPointsBalanceAsBusiness Get Points Balance as Business

Gets the points balance of a Vatom user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetPointsBalanceAsBusinessRequest
*/
func (a *VatomAPIService) GetPointsBalanceAsBusiness(ctx context.Context) ApiGetPointsBalanceAsBusinessRequest {
	return ApiGetPointsBalanceAsBusinessRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *VatomAPIService) GetPointsBalanceAsBusinessExecute(r ApiGetPointsBalanceAsBusinessRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VatomAPIService.GetPointsBalanceAsBusiness")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vatom/b/campaign/u/points/get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return nil, reportError("accountId is required and must be specified")
	}
	if r.appKey == nil {
		return nil, reportError("appKey is required and must be specified")
	}
	if r.vatomUserId == nil {
		return nil, reportError("vatomUserId is required and must be specified")
	}
	if r.vatomCampaignId == nil {
		return nil, reportError("vatomCampaignId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "vatomUserId", r.vatomUserId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "vatomCampaignId", r.vatomCampaignId, "form", "")
	if r.returnRawResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnRawResponse", r.returnRawResponse, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetSpaceRequest struct {
	ctx context.Context
	ApiService *VatomAPIService
	accountId *int64
	appKey *string
	vatomSpaceId *string
	returnRawResponse *bool
}

// Sirqul Account Id
func (r ApiGetSpaceRequest) AccountId(accountId int64) ApiGetSpaceRequest {
	r.accountId = &accountId
	return r
}

// Sirqul Application Key
func (r ApiGetSpaceRequest) AppKey(appKey string) ApiGetSpaceRequest {
	r.appKey = &appKey
	return r
}

// Vatom Space Id
func (r ApiGetSpaceRequest) VatomSpaceId(vatomSpaceId string) ApiGetSpaceRequest {
	r.vatomSpaceId = &vatomSpaceId
	return r
}

// Return raw response
func (r ApiGetSpaceRequest) ReturnRawResponse(returnRawResponse bool) ApiGetSpaceRequest {
	r.returnRawResponse = &returnRawResponse
	return r
}

func (r ApiGetSpaceRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetSpaceExecute(r)
}

/*
GetSpace Get Vatom Space

Gets the details of a space.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSpaceRequest
*/
func (a *VatomAPIService) GetSpace(ctx context.Context) ApiGetSpaceRequest {
	return ApiGetSpaceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *VatomAPIService) GetSpaceExecute(r ApiGetSpaceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VatomAPIService.GetSpace")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vatom/b/spaces/get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return nil, reportError("accountId is required and must be specified")
	}
	if r.appKey == nil {
		return nil, reportError("appKey is required and must be specified")
	}
	if r.vatomSpaceId == nil {
		return nil, reportError("vatomSpaceId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "vatomSpaceId", r.vatomSpaceId, "form", "")
	if r.returnRawResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnRawResponse", r.returnRawResponse, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetUserCoinsAsBusinessRequest struct {
	ctx context.Context
	ApiService *VatomAPIService
	accountId *int64
	vatomUserId *string
	appKey *string
	returnRawResponse *bool
}

// Sirqul Account Id
func (r ApiGetUserCoinsAsBusinessRequest) AccountId(accountId int64) ApiGetUserCoinsAsBusinessRequest {
	r.accountId = &accountId
	return r
}

// Vatom User Id
func (r ApiGetUserCoinsAsBusinessRequest) VatomUserId(vatomUserId string) ApiGetUserCoinsAsBusinessRequest {
	r.vatomUserId = &vatomUserId
	return r
}

// Sirqul Application Key
func (r ApiGetUserCoinsAsBusinessRequest) AppKey(appKey string) ApiGetUserCoinsAsBusinessRequest {
	r.appKey = &appKey
	return r
}

// Return raw response
func (r ApiGetUserCoinsAsBusinessRequest) ReturnRawResponse(returnRawResponse bool) ApiGetUserCoinsAsBusinessRequest {
	r.returnRawResponse = &returnRawResponse
	return r
}

func (r ApiGetUserCoinsAsBusinessRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetUserCoinsAsBusinessExecute(r)
}

/*
GetUserCoinsAsBusiness Get the coins for a user (as a Business)

Get the coins for a user (as a Business).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUserCoinsAsBusinessRequest
*/
func (a *VatomAPIService) GetUserCoinsAsBusiness(ctx context.Context) ApiGetUserCoinsAsBusinessRequest {
	return ApiGetUserCoinsAsBusinessRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *VatomAPIService) GetUserCoinsAsBusinessExecute(r ApiGetUserCoinsAsBusinessRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VatomAPIService.GetUserCoinsAsBusiness")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vatom/b/users/coins/get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return nil, reportError("accountId is required and must be specified")
	}
	if r.vatomUserId == nil {
		return nil, reportError("vatomUserId is required and must be specified")
	}
	if r.appKey == nil {
		return nil, reportError("appKey is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "vatomUserId", r.vatomUserId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	if r.returnRawResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnRawResponse", r.returnRawResponse, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetUserCoinsBalanceRequest struct {
	ctx context.Context
	ApiService *VatomAPIService
	accountId *int64
	vatomUserId *string
	vatomParameters *string
	returnRawResponse *bool
}

// Sirqul Account Id
func (r ApiGetUserCoinsBalanceRequest) AccountId(accountId int64) ApiGetUserCoinsBalanceRequest {
	r.accountId = &accountId
	return r
}

// Vatom User Id
func (r ApiGetUserCoinsBalanceRequest) VatomUserId(vatomUserId string) ApiGetUserCoinsBalanceRequest {
	r.vatomUserId = &vatomUserId
	return r
}

// Vatom Parameters
func (r ApiGetUserCoinsBalanceRequest) VatomParameters(vatomParameters string) ApiGetUserCoinsBalanceRequest {
	r.vatomParameters = &vatomParameters
	return r
}

// Return raw response
func (r ApiGetUserCoinsBalanceRequest) ReturnRawResponse(returnRawResponse bool) ApiGetUserCoinsBalanceRequest {
	r.returnRawResponse = &returnRawResponse
	return r
}

func (r ApiGetUserCoinsBalanceRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetUserCoinsBalanceExecute(r)
}

/*
GetUserCoinsBalance Gets the coins balance for a Vatom User

Gets the coins balance for a Vatom User.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUserCoinsBalanceRequest
*/
func (a *VatomAPIService) GetUserCoinsBalance(ctx context.Context) ApiGetUserCoinsBalanceRequest {
	return ApiGetUserCoinsBalanceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *VatomAPIService) GetUserCoinsBalanceExecute(r ApiGetUserCoinsBalanceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VatomAPIService.GetUserCoinsBalance")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vatom/u/coins/get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return nil, reportError("accountId is required and must be specified")
	}
	if r.vatomUserId == nil {
		return nil, reportError("vatomUserId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "vatomUserId", r.vatomUserId, "form", "")
	if r.vatomParameters != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vatomParameters", r.vatomParameters, "form", "")
	}
	if r.returnRawResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnRawResponse", r.returnRawResponse, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetUserFollowersRequest struct {
	ctx context.Context
	ApiService *VatomAPIService
	accountId *int64
	vatomUserId *string
	returnRawResponse *bool
}

// Sirqul Account Id
func (r ApiGetUserFollowersRequest) AccountId(accountId int64) ApiGetUserFollowersRequest {
	r.accountId = &accountId
	return r
}

// Vatom User Id
func (r ApiGetUserFollowersRequest) VatomUserId(vatomUserId string) ApiGetUserFollowersRequest {
	r.vatomUserId = &vatomUserId
	return r
}

// Return raw response
func (r ApiGetUserFollowersRequest) ReturnRawResponse(returnRawResponse bool) ApiGetUserFollowersRequest {
	r.returnRawResponse = &returnRawResponse
	return r
}

func (r ApiGetUserFollowersRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetUserFollowersExecute(r)
}

/*
GetUserFollowers Get user followers

Get user followers.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUserFollowersRequest
*/
func (a *VatomAPIService) GetUserFollowers(ctx context.Context) ApiGetUserFollowersRequest {
	return ApiGetUserFollowersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *VatomAPIService) GetUserFollowersExecute(r ApiGetUserFollowersRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VatomAPIService.GetUserFollowers")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vatom/users/rels/followers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return nil, reportError("accountId is required and must be specified")
	}
	if r.vatomUserId == nil {
		return nil, reportError("vatomUserId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "vatomUserId", r.vatomUserId, "form", "")
	if r.returnRawResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnRawResponse", r.returnRawResponse, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetUserFollowingRequest struct {
	ctx context.Context
	ApiService *VatomAPIService
	accountId *int64
	vatomUserId *string
	returnRawResponse *bool
}

// Sirqul Account Id
func (r ApiGetUserFollowingRequest) AccountId(accountId int64) ApiGetUserFollowingRequest {
	r.accountId = &accountId
	return r
}

// Vatom User Id
func (r ApiGetUserFollowingRequest) VatomUserId(vatomUserId string) ApiGetUserFollowingRequest {
	r.vatomUserId = &vatomUserId
	return r
}

// Return raw response
func (r ApiGetUserFollowingRequest) ReturnRawResponse(returnRawResponse bool) ApiGetUserFollowingRequest {
	r.returnRawResponse = &returnRawResponse
	return r
}

func (r ApiGetUserFollowingRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetUserFollowingExecute(r)
}

/*
GetUserFollowing Get user following

Get user following.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUserFollowingRequest
*/
func (a *VatomAPIService) GetUserFollowing(ctx context.Context) ApiGetUserFollowingRequest {
	return ApiGetUserFollowingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *VatomAPIService) GetUserFollowingExecute(r ApiGetUserFollowingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VatomAPIService.GetUserFollowing")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vatom/users/rels/following"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return nil, reportError("accountId is required and must be specified")
	}
	if r.vatomUserId == nil {
		return nil, reportError("vatomUserId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "vatomUserId", r.vatomUserId, "form", "")
	if r.returnRawResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnRawResponse", r.returnRawResponse, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetUserInfoRequest struct {
	ctx context.Context
	ApiService *VatomAPIService
	accountId *int64
	vatomUserId *string
	returnRawResponse *bool
}

// Sirqul Account Id
func (r ApiGetUserInfoRequest) AccountId(accountId int64) ApiGetUserInfoRequest {
	r.accountId = &accountId
	return r
}

// Vatom User Id
func (r ApiGetUserInfoRequest) VatomUserId(vatomUserId string) ApiGetUserInfoRequest {
	r.vatomUserId = &vatomUserId
	return r
}

// Return raw response
func (r ApiGetUserInfoRequest) ReturnRawResponse(returnRawResponse bool) ApiGetUserInfoRequest {
	r.returnRawResponse = &returnRawResponse
	return r
}

func (r ApiGetUserInfoRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetUserInfoExecute(r)
}

/*
GetUserInfo Get User Info

Get a User's Info.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUserInfoRequest
*/
func (a *VatomAPIService) GetUserInfo(ctx context.Context) ApiGetUserInfoRequest {
	return ApiGetUserInfoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *VatomAPIService) GetUserInfoExecute(r ApiGetUserInfoRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VatomAPIService.GetUserInfo")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vatom/user/get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return nil, reportError("accountId is required and must be specified")
	}
	if r.vatomUserId == nil {
		return nil, reportError("vatomUserId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "vatomUserId", r.vatomUserId, "form", "")
	if r.returnRawResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnRawResponse", r.returnRawResponse, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetUserProfileRequest struct {
	ctx context.Context
	ApiService *VatomAPIService
	accountId *int64
	returnRawResponse *bool
}

// Sirqul Account Id
func (r ApiGetUserProfileRequest) AccountId(accountId int64) ApiGetUserProfileRequest {
	r.accountId = &accountId
	return r
}

// Return raw response
func (r ApiGetUserProfileRequest) ReturnRawResponse(returnRawResponse bool) ApiGetUserProfileRequest {
	r.returnRawResponse = &returnRawResponse
	return r
}

func (r ApiGetUserProfileRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetUserProfileExecute(r)
}

/*
GetUserProfile Get Vatom User Profile

Gets the logged in user's profile in Vatom.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUserProfileRequest
*/
func (a *VatomAPIService) GetUserProfile(ctx context.Context) ApiGetUserProfileRequest {
	return ApiGetUserProfileRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *VatomAPIService) GetUserProfileExecute(r ApiGetUserProfileRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VatomAPIService.GetUserProfile")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vatom/me/get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return nil, reportError("accountId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	if r.returnRawResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnRawResponse", r.returnRawResponse, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetVatomEventRequest struct {
	ctx context.Context
	ApiService *VatomAPIService
	accountId *int64
	appKey *string
	vatomEventId *string
	returnRawResponse *bool
}

// Sirqul Account Id
func (r ApiGetVatomEventRequest) AccountId(accountId int64) ApiGetVatomEventRequest {
	r.accountId = &accountId
	return r
}

// Sirqul Application Key
func (r ApiGetVatomEventRequest) AppKey(appKey string) ApiGetVatomEventRequest {
	r.appKey = &appKey
	return r
}

// Vatom Event Id
func (r ApiGetVatomEventRequest) VatomEventId(vatomEventId string) ApiGetVatomEventRequest {
	r.vatomEventId = &vatomEventId
	return r
}

// Return raw response
func (r ApiGetVatomEventRequest) ReturnRawResponse(returnRawResponse bool) ApiGetVatomEventRequest {
	r.returnRawResponse = &returnRawResponse
	return r
}

func (r ApiGetVatomEventRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetVatomEventExecute(r)
}

/*
GetVatomEvent Get Vatom Event

Gets the details of a event.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetVatomEventRequest
*/
func (a *VatomAPIService) GetVatomEvent(ctx context.Context) ApiGetVatomEventRequest {
	return ApiGetVatomEventRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *VatomAPIService) GetVatomEventExecute(r ApiGetVatomEventRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VatomAPIService.GetVatomEvent")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vatom/b/events/get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return nil, reportError("accountId is required and must be specified")
	}
	if r.appKey == nil {
		return nil, reportError("appKey is required and must be specified")
	}
	if r.vatomEventId == nil {
		return nil, reportError("vatomEventId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "vatomEventId", r.vatomEventId, "form", "")
	if r.returnRawResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnRawResponse", r.returnRawResponse, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetVatomNFTRequest struct {
	ctx context.Context
	ApiService *VatomAPIService
	accountId *int64
	vatomId *string
	returnRawResponse *bool
}

// Sirqul Account Id
func (r ApiGetVatomNFTRequest) AccountId(accountId int64) ApiGetVatomNFTRequest {
	r.accountId = &accountId
	return r
}

// Vatom NFT Id
func (r ApiGetVatomNFTRequest) VatomId(vatomId string) ApiGetVatomNFTRequest {
	r.vatomId = &vatomId
	return r
}

// Return raw response
func (r ApiGetVatomNFTRequest) ReturnRawResponse(returnRawResponse bool) ApiGetVatomNFTRequest {
	r.returnRawResponse = &returnRawResponse
	return r
}

func (r ApiGetVatomNFTRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetVatomNFTExecute(r)
}

/*
GetVatomNFT Get Vatom NFT Details

Get Vatom NFT Details

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetVatomNFTRequest
*/
func (a *VatomAPIService) GetVatomNFT(ctx context.Context) ApiGetVatomNFTRequest {
	return ApiGetVatomNFTRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *VatomAPIService) GetVatomNFTExecute(r ApiGetVatomNFTRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VatomAPIService.GetVatomNFT")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vatom/vatoms/get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return nil, reportError("accountId is required and must be specified")
	}
	if r.vatomId == nil {
		return nil, reportError("vatomId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "vatomId", r.vatomId, "form", "")
	if r.returnRawResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnRawResponse", r.returnRawResponse, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiListCommunitiesRequest struct {
	ctx context.Context
	ApiService *VatomAPIService
	accountId *int64
	appKey *string
	vatomParameters *string
	returnRawResponse *bool
}

// Sirqul Account Id
func (r ApiListCommunitiesRequest) AccountId(accountId int64) ApiListCommunitiesRequest {
	r.accountId = &accountId
	return r
}

// Sirqul Application Key
func (r ApiListCommunitiesRequest) AppKey(appKey string) ApiListCommunitiesRequest {
	r.appKey = &appKey
	return r
}

// Vatom Parameters
func (r ApiListCommunitiesRequest) VatomParameters(vatomParameters string) ApiListCommunitiesRequest {
	r.vatomParameters = &vatomParameters
	return r
}

// Return raw response
func (r ApiListCommunitiesRequest) ReturnRawResponse(returnRawResponse bool) ApiListCommunitiesRequest {
	r.returnRawResponse = &returnRawResponse
	return r
}

func (r ApiListCommunitiesRequest) Execute() (*http.Response, error) {
	return r.ApiService.ListCommunitiesExecute(r)
}

/*
ListCommunities List Vatom Communities

Gets the communities tied to a business.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListCommunitiesRequest
*/
func (a *VatomAPIService) ListCommunities(ctx context.Context) ApiListCommunitiesRequest {
	return ApiListCommunitiesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *VatomAPIService) ListCommunitiesExecute(r ApiListCommunitiesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VatomAPIService.ListCommunities")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vatom/b/communities/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return nil, reportError("accountId is required and must be specified")
	}
	if r.appKey == nil {
		return nil, reportError("appKey is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	if r.vatomParameters != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vatomParameters", r.vatomParameters, "form", "")
	}
	if r.returnRawResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnRawResponse", r.returnRawResponse, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiListEventsRequest struct {
	ctx context.Context
	ApiService *VatomAPIService
	accountId *int64
	appKey *string
	vatomParameters *string
	returnRawResponse *bool
}

// Sirqul Account Id
func (r ApiListEventsRequest) AccountId(accountId int64) ApiListEventsRequest {
	r.accountId = &accountId
	return r
}

// Sirqul Application Key
func (r ApiListEventsRequest) AppKey(appKey string) ApiListEventsRequest {
	r.appKey = &appKey
	return r
}

// Vatom Parameters
func (r ApiListEventsRequest) VatomParameters(vatomParameters string) ApiListEventsRequest {
	r.vatomParameters = &vatomParameters
	return r
}

// Return raw response
func (r ApiListEventsRequest) ReturnRawResponse(returnRawResponse bool) ApiListEventsRequest {
	r.returnRawResponse = &returnRawResponse
	return r
}

func (r ApiListEventsRequest) Execute() (*http.Response, error) {
	return r.ApiService.ListEventsExecute(r)
}

/*
ListEvents List Vatom Events

Gets the events tied to a business.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListEventsRequest
*/
func (a *VatomAPIService) ListEvents(ctx context.Context) ApiListEventsRequest {
	return ApiListEventsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *VatomAPIService) ListEventsExecute(r ApiListEventsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VatomAPIService.ListEvents")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vatom/b/events/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return nil, reportError("accountId is required and must be specified")
	}
	if r.appKey == nil {
		return nil, reportError("appKey is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	if r.vatomParameters != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vatomParameters", r.vatomParameters, "form", "")
	}
	if r.returnRawResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnRawResponse", r.returnRawResponse, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiListSpacesRequest struct {
	ctx context.Context
	ApiService *VatomAPIService
	accountId *int64
	appKey *string
	vatomParameters *string
	returnRawResponse *bool
}

// Sirqul Account Id
func (r ApiListSpacesRequest) AccountId(accountId int64) ApiListSpacesRequest {
	r.accountId = &accountId
	return r
}

// Sirqul Application Key
func (r ApiListSpacesRequest) AppKey(appKey string) ApiListSpacesRequest {
	r.appKey = &appKey
	return r
}

// Vatom Parameters
func (r ApiListSpacesRequest) VatomParameters(vatomParameters string) ApiListSpacesRequest {
	r.vatomParameters = &vatomParameters
	return r
}

// Return raw response
func (r ApiListSpacesRequest) ReturnRawResponse(returnRawResponse bool) ApiListSpacesRequest {
	r.returnRawResponse = &returnRawResponse
	return r
}

func (r ApiListSpacesRequest) Execute() (*http.Response, error) {
	return r.ApiService.ListSpacesExecute(r)
}

/*
ListSpaces List Vatom Spaces

Gets the spaces tied to a business.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListSpacesRequest
*/
func (a *VatomAPIService) ListSpaces(ctx context.Context) ApiListSpacesRequest {
	return ApiListSpacesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *VatomAPIService) ListSpacesExecute(r ApiListSpacesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VatomAPIService.ListSpaces")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vatom/b/spaces/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return nil, reportError("accountId is required and must be specified")
	}
	if r.appKey == nil {
		return nil, reportError("appKey is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	if r.vatomParameters != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vatomParameters", r.vatomParameters, "form", "")
	}
	if r.returnRawResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnRawResponse", r.returnRawResponse, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiListUserCoinTransactionsRequest struct {
	ctx context.Context
	ApiService *VatomAPIService
	accountId *int64
	vatomUserId *string
	vatomParameters *string
	returnRawResponse *bool
}

// Sirqul Account Id
func (r ApiListUserCoinTransactionsRequest) AccountId(accountId int64) ApiListUserCoinTransactionsRequest {
	r.accountId = &accountId
	return r
}

// Vatom User Id
func (r ApiListUserCoinTransactionsRequest) VatomUserId(vatomUserId string) ApiListUserCoinTransactionsRequest {
	r.vatomUserId = &vatomUserId
	return r
}

// Vatom Parameters
func (r ApiListUserCoinTransactionsRequest) VatomParameters(vatomParameters string) ApiListUserCoinTransactionsRequest {
	r.vatomParameters = &vatomParameters
	return r
}

// Return raw response
func (r ApiListUserCoinTransactionsRequest) ReturnRawResponse(returnRawResponse bool) ApiListUserCoinTransactionsRequest {
	r.returnRawResponse = &returnRawResponse
	return r
}

func (r ApiListUserCoinTransactionsRequest) Execute() (*http.Response, error) {
	return r.ApiService.ListUserCoinTransactionsExecute(r)
}

/*
ListUserCoinTransactions List Coin Transactions for a Vatom User

Gets the logged in user's Vatom coin transactions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListUserCoinTransactionsRequest
*/
func (a *VatomAPIService) ListUserCoinTransactions(ctx context.Context) ApiListUserCoinTransactionsRequest {
	return ApiListUserCoinTransactionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *VatomAPIService) ListUserCoinTransactionsExecute(r ApiListUserCoinTransactionsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VatomAPIService.ListUserCoinTransactions")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vatom/u/coins/txns/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return nil, reportError("accountId is required and must be specified")
	}
	if r.vatomUserId == nil {
		return nil, reportError("vatomUserId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "vatomUserId", r.vatomUserId, "form", "")
	if r.vatomParameters != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vatomParameters", r.vatomParameters, "form", "")
	}
	if r.returnRawResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnRawResponse", r.returnRawResponse, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiListUserCoinTransactionsAsBusinessRequest struct {
	ctx context.Context
	ApiService *VatomAPIService
	accountId *int64
	vatomUserId *string
	appKey *string
	vatomParameters *string
	returnRawResponse *bool
}

// Sirqul Account Id
func (r ApiListUserCoinTransactionsAsBusinessRequest) AccountId(accountId int64) ApiListUserCoinTransactionsAsBusinessRequest {
	r.accountId = &accountId
	return r
}

// Vatom User Id
func (r ApiListUserCoinTransactionsAsBusinessRequest) VatomUserId(vatomUserId string) ApiListUserCoinTransactionsAsBusinessRequest {
	r.vatomUserId = &vatomUserId
	return r
}

// Sirqul Application Key
func (r ApiListUserCoinTransactionsAsBusinessRequest) AppKey(appKey string) ApiListUserCoinTransactionsAsBusinessRequest {
	r.appKey = &appKey
	return r
}

// Vatom Parameters
func (r ApiListUserCoinTransactionsAsBusinessRequest) VatomParameters(vatomParameters string) ApiListUserCoinTransactionsAsBusinessRequest {
	r.vatomParameters = &vatomParameters
	return r
}

// Return raw response
func (r ApiListUserCoinTransactionsAsBusinessRequest) ReturnRawResponse(returnRawResponse bool) ApiListUserCoinTransactionsAsBusinessRequest {
	r.returnRawResponse = &returnRawResponse
	return r
}

func (r ApiListUserCoinTransactionsAsBusinessRequest) Execute() (*http.Response, error) {
	return r.ApiService.ListUserCoinTransactionsAsBusinessExecute(r)
}

/*
ListUserCoinTransactionsAsBusiness List coin transactions for a user (as a Business)

List coin transactions for a user (as a Business).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListUserCoinTransactionsAsBusinessRequest
*/
func (a *VatomAPIService) ListUserCoinTransactionsAsBusiness(ctx context.Context) ApiListUserCoinTransactionsAsBusinessRequest {
	return ApiListUserCoinTransactionsAsBusinessRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *VatomAPIService) ListUserCoinTransactionsAsBusinessExecute(r ApiListUserCoinTransactionsAsBusinessRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VatomAPIService.ListUserCoinTransactionsAsBusiness")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vatom/b/users/coins/txns/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return nil, reportError("accountId is required and must be specified")
	}
	if r.vatomUserId == nil {
		return nil, reportError("vatomUserId is required and must be specified")
	}
	if r.appKey == nil {
		return nil, reportError("appKey is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "vatomUserId", r.vatomUserId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	if r.vatomParameters != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vatomParameters", r.vatomParameters, "form", "")
	}
	if r.returnRawResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnRawResponse", r.returnRawResponse, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPerformActionOnNFTRequest struct {
	ctx context.Context
	ApiService *VatomAPIService
	accountId *int64
	vatomId *string
	vatomAction *string
	vatomParameters *string
	returnRawResponse *bool
}

// Sirqul Account Id
func (r ApiPerformActionOnNFTRequest) AccountId(accountId int64) ApiPerformActionOnNFTRequest {
	r.accountId = &accountId
	return r
}

// Vatom NFT Id
func (r ApiPerformActionOnNFTRequest) VatomId(vatomId string) ApiPerformActionOnNFTRequest {
	r.vatomId = &vatomId
	return r
}

// Vatom Action
func (r ApiPerformActionOnNFTRequest) VatomAction(vatomAction string) ApiPerformActionOnNFTRequest {
	r.vatomAction = &vatomAction
	return r
}

// Vatom Parameters
func (r ApiPerformActionOnNFTRequest) VatomParameters(vatomParameters string) ApiPerformActionOnNFTRequest {
	r.vatomParameters = &vatomParameters
	return r
}

// Return raw response
func (r ApiPerformActionOnNFTRequest) ReturnRawResponse(returnRawResponse bool) ApiPerformActionOnNFTRequest {
	r.returnRawResponse = &returnRawResponse
	return r
}

func (r ApiPerformActionOnNFTRequest) Execute() (*http.Response, error) {
	return r.ApiService.PerformActionOnNFTExecute(r)
}

/*
PerformActionOnNFT Perform Action on NFT

Perform Action on NFT.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPerformActionOnNFTRequest
*/
func (a *VatomAPIService) PerformActionOnNFT(ctx context.Context) ApiPerformActionOnNFTRequest {
	return ApiPerformActionOnNFTRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *VatomAPIService) PerformActionOnNFTExecute(r ApiPerformActionOnNFTRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VatomAPIService.PerformActionOnNFT")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vatom/me/vatoms/actions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return nil, reportError("accountId is required and must be specified")
	}
	if r.vatomId == nil {
		return nil, reportError("vatomId is required and must be specified")
	}
	if r.vatomAction == nil {
		return nil, reportError("vatomAction is required and must be specified")
	}
	if r.vatomParameters == nil {
		return nil, reportError("vatomParameters is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "vatomId", r.vatomId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "vatomAction", r.vatomAction, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "vatomParameters", r.vatomParameters, "form", "")
	if r.returnRawResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnRawResponse", r.returnRawResponse, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRedeemNFTRequest struct {
	ctx context.Context
	ApiService *VatomAPIService
	accountId *int64
	appKey *string
	vatomParameters *string
	returnRawResponse *bool
}

// Sirqul Account Id
func (r ApiRedeemNFTRequest) AccountId(accountId int64) ApiRedeemNFTRequest {
	r.accountId = &accountId
	return r
}

// Sirqul Application Key
func (r ApiRedeemNFTRequest) AppKey(appKey string) ApiRedeemNFTRequest {
	r.appKey = &appKey
	return r
}

// Vatom Parameters
func (r ApiRedeemNFTRequest) VatomParameters(vatomParameters string) ApiRedeemNFTRequest {
	r.vatomParameters = &vatomParameters
	return r
}

// Return raw response
func (r ApiRedeemNFTRequest) ReturnRawResponse(returnRawResponse bool) ApiRedeemNFTRequest {
	r.returnRawResponse = &returnRawResponse
	return r
}

func (r ApiRedeemNFTRequest) Execute() (*http.Response, error) {
	return r.ApiService.RedeemNFTExecute(r)
}

/*
RedeemNFT Redeem NFT

Redeem an NFT.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRedeemNFTRequest
*/
func (a *VatomAPIService) RedeemNFT(ctx context.Context) ApiRedeemNFTRequest {
	return ApiRedeemNFTRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *VatomAPIService) RedeemNFTExecute(r ApiRedeemNFTRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VatomAPIService.RedeemNFT")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vatom/b/redemptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return nil, reportError("accountId is required and must be specified")
	}
	if r.appKey == nil {
		return nil, reportError("appKey is required and must be specified")
	}
	if r.vatomParameters == nil {
		return nil, reportError("vatomParameters is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "vatomParameters", r.vatomParameters, "form", "")
	if r.returnRawResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnRawResponse", r.returnRawResponse, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRedeemUserCoinsAsBusinessRequest struct {
	ctx context.Context
	ApiService *VatomAPIService
	accountId *int64
	vatomUserId *string
	appKey *string
	vatomParameters *string
	returnRawResponse *bool
}

// Sirqul Account Id
func (r ApiRedeemUserCoinsAsBusinessRequest) AccountId(accountId int64) ApiRedeemUserCoinsAsBusinessRequest {
	r.accountId = &accountId
	return r
}

// Vatom User Id
func (r ApiRedeemUserCoinsAsBusinessRequest) VatomUserId(vatomUserId string) ApiRedeemUserCoinsAsBusinessRequest {
	r.vatomUserId = &vatomUserId
	return r
}

// Sirqul Application Key
func (r ApiRedeemUserCoinsAsBusinessRequest) AppKey(appKey string) ApiRedeemUserCoinsAsBusinessRequest {
	r.appKey = &appKey
	return r
}

// Vatom Parameters
func (r ApiRedeemUserCoinsAsBusinessRequest) VatomParameters(vatomParameters string) ApiRedeemUserCoinsAsBusinessRequest {
	r.vatomParameters = &vatomParameters
	return r
}

// Return raw response
func (r ApiRedeemUserCoinsAsBusinessRequest) ReturnRawResponse(returnRawResponse bool) ApiRedeemUserCoinsAsBusinessRequest {
	r.returnRawResponse = &returnRawResponse
	return r
}

func (r ApiRedeemUserCoinsAsBusinessRequest) Execute() (*http.Response, error) {
	return r.ApiService.RedeemUserCoinsAsBusinessExecute(r)
}

/*
RedeemUserCoinsAsBusiness Redeem the coins for a user (as a Business)

Redeem the coins for a user (as a Business).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRedeemUserCoinsAsBusinessRequest
*/
func (a *VatomAPIService) RedeemUserCoinsAsBusiness(ctx context.Context) ApiRedeemUserCoinsAsBusinessRequest {
	return ApiRedeemUserCoinsAsBusinessRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *VatomAPIService) RedeemUserCoinsAsBusinessExecute(r ApiRedeemUserCoinsAsBusinessRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VatomAPIService.RedeemUserCoinsAsBusiness")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vatom/b/users/coins/redeem"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return nil, reportError("accountId is required and must be specified")
	}
	if r.vatomUserId == nil {
		return nil, reportError("vatomUserId is required and must be specified")
	}
	if r.appKey == nil {
		return nil, reportError("appKey is required and must be specified")
	}
	if r.vatomParameters == nil {
		return nil, reportError("vatomParameters is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "vatomUserId", r.vatomUserId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "vatomParameters", r.vatomParameters, "form", "")
	if r.returnRawResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnRawResponse", r.returnRawResponse, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSearchBusinessesRequest struct {
	ctx context.Context
	ApiService *VatomAPIService
	accountId *int64
	vatomParameters *string
	returnRawResponse *bool
}

// Sirqul Account Id
func (r ApiSearchBusinessesRequest) AccountId(accountId int64) ApiSearchBusinessesRequest {
	r.accountId = &accountId
	return r
}

// Vatom Parameters
func (r ApiSearchBusinessesRequest) VatomParameters(vatomParameters string) ApiSearchBusinessesRequest {
	r.vatomParameters = &vatomParameters
	return r
}

// Return raw response
func (r ApiSearchBusinessesRequest) ReturnRawResponse(returnRawResponse bool) ApiSearchBusinessesRequest {
	r.returnRawResponse = &returnRawResponse
	return r
}

func (r ApiSearchBusinessesRequest) Execute() (*http.Response, error) {
	return r.ApiService.SearchBusinessesExecute(r)
}

/*
SearchBusinesses Search for Vatom Businesses

Searches for Vatom businesses.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchBusinessesRequest
*/
func (a *VatomAPIService) SearchBusinesses(ctx context.Context) ApiSearchBusinessesRequest {
	return ApiSearchBusinessesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *VatomAPIService) SearchBusinessesExecute(r ApiSearchBusinessesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VatomAPIService.SearchBusinesses")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vatom/b/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return nil, reportError("accountId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	if r.vatomParameters != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vatomParameters", r.vatomParameters, "form", "")
	}
	if r.returnRawResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnRawResponse", r.returnRawResponse, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSearchCampaignGroupsRequest struct {
	ctx context.Context
	ApiService *VatomAPIService
	accountId *int64
	appKey *string
	returnRawResponse *bool
}

// Sirqul Account Id
func (r ApiSearchCampaignGroupsRequest) AccountId(accountId int64) ApiSearchCampaignGroupsRequest {
	r.accountId = &accountId
	return r
}

// Sirqul Application Key
func (r ApiSearchCampaignGroupsRequest) AppKey(appKey string) ApiSearchCampaignGroupsRequest {
	r.appKey = &appKey
	return r
}

// Return raw response
func (r ApiSearchCampaignGroupsRequest) ReturnRawResponse(returnRawResponse bool) ApiSearchCampaignGroupsRequest {
	r.returnRawResponse = &returnRawResponse
	return r
}

func (r ApiSearchCampaignGroupsRequest) Execute() (*http.Response, error) {
	return r.ApiService.SearchCampaignGroupsExecute(r)
}

/*
SearchCampaignGroups Search Campaign Groups

Search campaign groups.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchCampaignGroupsRequest
*/
func (a *VatomAPIService) SearchCampaignGroups(ctx context.Context) ApiSearchCampaignGroupsRequest {
	return ApiSearchCampaignGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *VatomAPIService) SearchCampaignGroupsExecute(r ApiSearchCampaignGroupsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VatomAPIService.SearchCampaignGroups")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vatom/b/campaign-groups/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return nil, reportError("accountId is required and must be specified")
	}
	if r.appKey == nil {
		return nil, reportError("appKey is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	if r.returnRawResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnRawResponse", r.returnRawResponse, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSearchIdentitiesRequest struct {
	ctx context.Context
	ApiService *VatomAPIService
	accountId *int64
	returnRawResponse *bool
}

// Sirqul Account Id
func (r ApiSearchIdentitiesRequest) AccountId(accountId int64) ApiSearchIdentitiesRequest {
	r.accountId = &accountId
	return r
}

// Return raw response
func (r ApiSearchIdentitiesRequest) ReturnRawResponse(returnRawResponse bool) ApiSearchIdentitiesRequest {
	r.returnRawResponse = &returnRawResponse
	return r
}

func (r ApiSearchIdentitiesRequest) Execute() (*http.Response, error) {
	return r.ApiService.SearchIdentitiesExecute(r)
}

/*
SearchIdentities Search User Identities

Search User Identities.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchIdentitiesRequest
*/
func (a *VatomAPIService) SearchIdentities(ctx context.Context) ApiSearchIdentitiesRequest {
	return ApiSearchIdentitiesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *VatomAPIService) SearchIdentitiesExecute(r ApiSearchIdentitiesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VatomAPIService.SearchIdentities")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vatom/me/identities/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return nil, reportError("accountId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	if r.returnRawResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnRawResponse", r.returnRawResponse, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSearchInventoryRequest struct {
	ctx context.Context
	ApiService *VatomAPIService
	accountId *int64
	vatomParameters *string
	returnRawResponse *bool
}

// Sirqul Account Id
func (r ApiSearchInventoryRequest) AccountId(accountId int64) ApiSearchInventoryRequest {
	r.accountId = &accountId
	return r
}

// Vatom Parameters
func (r ApiSearchInventoryRequest) VatomParameters(vatomParameters string) ApiSearchInventoryRequest {
	r.vatomParameters = &vatomParameters
	return r
}

// Return raw response
func (r ApiSearchInventoryRequest) ReturnRawResponse(returnRawResponse bool) ApiSearchInventoryRequest {
	r.returnRawResponse = &returnRawResponse
	return r
}

func (r ApiSearchInventoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.SearchInventoryExecute(r)
}

/*
SearchInventory Search Vatom User's Inventory

Searches the logged in user's Vatom Inventory.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchInventoryRequest
*/
func (a *VatomAPIService) SearchInventory(ctx context.Context) ApiSearchInventoryRequest {
	return ApiSearchInventoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *VatomAPIService) SearchInventoryExecute(r ApiSearchInventoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VatomAPIService.SearchInventory")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vatom/user-inventory/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return nil, reportError("accountId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	if r.vatomParameters != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vatomParameters", r.vatomParameters, "form", "")
	}
	if r.returnRawResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnRawResponse", r.returnRawResponse, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSendNFTRequest struct {
	ctx context.Context
	ApiService *VatomAPIService
	accountId *int64
	appKey *string
	vatomCampaignId *string
	vatomParameters *string
	returnRawResponse *bool
}

// Sirqul Account Id
func (r ApiSendNFTRequest) AccountId(accountId int64) ApiSendNFTRequest {
	r.accountId = &accountId
	return r
}

// Sirqul Application Key
func (r ApiSendNFTRequest) AppKey(appKey string) ApiSendNFTRequest {
	r.appKey = &appKey
	return r
}

// Vatom Campaign Id
func (r ApiSendNFTRequest) VatomCampaignId(vatomCampaignId string) ApiSendNFTRequest {
	r.vatomCampaignId = &vatomCampaignId
	return r
}

// Vatom Parameters
func (r ApiSendNFTRequest) VatomParameters(vatomParameters string) ApiSendNFTRequest {
	r.vatomParameters = &vatomParameters
	return r
}

// Return raw response
func (r ApiSendNFTRequest) ReturnRawResponse(returnRawResponse bool) ApiSendNFTRequest {
	r.returnRawResponse = &returnRawResponse
	return r
}

func (r ApiSendNFTRequest) Execute() (*http.Response, error) {
	return r.ApiService.SendNFTExecute(r)
}

/*
SendNFT Send NFT

Send an NFT.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSendNFTRequest
*/
func (a *VatomAPIService) SendNFT(ctx context.Context) ApiSendNFTRequest {
	return ApiSendNFTRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *VatomAPIService) SendNFTExecute(r ApiSendNFTRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VatomAPIService.SendNFT")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vatom/b/campaigns/send"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return nil, reportError("accountId is required and must be specified")
	}
	if r.appKey == nil {
		return nil, reportError("appKey is required and must be specified")
	}
	if r.vatomCampaignId == nil {
		return nil, reportError("vatomCampaignId is required and must be specified")
	}
	if r.vatomParameters == nil {
		return nil, reportError("vatomParameters is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "vatomCampaignId", r.vatomCampaignId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "vatomParameters", r.vatomParameters, "form", "")
	if r.returnRawResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnRawResponse", r.returnRawResponse, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetPointsBalanceAsBusinessRequest struct {
	ctx context.Context
	ApiService *VatomAPIService
	accountId *int64
	appKey *string
	vatomUserId *string
	vatomCampaignId *string
	vatomParameters *string
	returnRawResponse *bool
}

// Sirqul Account Id
func (r ApiSetPointsBalanceAsBusinessRequest) AccountId(accountId int64) ApiSetPointsBalanceAsBusinessRequest {
	r.accountId = &accountId
	return r
}

// Sirqul Application Key
func (r ApiSetPointsBalanceAsBusinessRequest) AppKey(appKey string) ApiSetPointsBalanceAsBusinessRequest {
	r.appKey = &appKey
	return r
}

// Vatom User Id
func (r ApiSetPointsBalanceAsBusinessRequest) VatomUserId(vatomUserId string) ApiSetPointsBalanceAsBusinessRequest {
	r.vatomUserId = &vatomUserId
	return r
}

// Vatom Campaign Id
func (r ApiSetPointsBalanceAsBusinessRequest) VatomCampaignId(vatomCampaignId string) ApiSetPointsBalanceAsBusinessRequest {
	r.vatomCampaignId = &vatomCampaignId
	return r
}

// Vatom Parameters
func (r ApiSetPointsBalanceAsBusinessRequest) VatomParameters(vatomParameters string) ApiSetPointsBalanceAsBusinessRequest {
	r.vatomParameters = &vatomParameters
	return r
}

// Return raw response
func (r ApiSetPointsBalanceAsBusinessRequest) ReturnRawResponse(returnRawResponse bool) ApiSetPointsBalanceAsBusinessRequest {
	r.returnRawResponse = &returnRawResponse
	return r
}

func (r ApiSetPointsBalanceAsBusinessRequest) Execute() (*http.Response, error) {
	return r.ApiService.SetPointsBalanceAsBusinessExecute(r)
}

/*
SetPointsBalanceAsBusiness Set Points Balance as Business

Sets the points balance of a Vatom user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSetPointsBalanceAsBusinessRequest
*/
func (a *VatomAPIService) SetPointsBalanceAsBusiness(ctx context.Context) ApiSetPointsBalanceAsBusinessRequest {
	return ApiSetPointsBalanceAsBusinessRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *VatomAPIService) SetPointsBalanceAsBusinessExecute(r ApiSetPointsBalanceAsBusinessRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VatomAPIService.SetPointsBalanceAsBusiness")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vatom/b/campaign/u/points/update"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return nil, reportError("accountId is required and must be specified")
	}
	if r.appKey == nil {
		return nil, reportError("appKey is required and must be specified")
	}
	if r.vatomUserId == nil {
		return nil, reportError("vatomUserId is required and must be specified")
	}
	if r.vatomCampaignId == nil {
		return nil, reportError("vatomCampaignId is required and must be specified")
	}
	if r.vatomParameters == nil {
		return nil, reportError("vatomParameters is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "vatomUserId", r.vatomUserId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "vatomCampaignId", r.vatomCampaignId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "vatomParameters", r.vatomParameters, "form", "")
	if r.returnRawResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnRawResponse", r.returnRawResponse, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTransferUserCoinsRequest struct {
	ctx context.Context
	ApiService *VatomAPIService
	accountId *int64
	vatomUserId *string
	vatomParameters *string
	returnRawResponse *bool
}

// Sirqul Account Id
func (r ApiTransferUserCoinsRequest) AccountId(accountId int64) ApiTransferUserCoinsRequest {
	r.accountId = &accountId
	return r
}

// Vatom User Id
func (r ApiTransferUserCoinsRequest) VatomUserId(vatomUserId string) ApiTransferUserCoinsRequest {
	r.vatomUserId = &vatomUserId
	return r
}

// Vatom Parameters
func (r ApiTransferUserCoinsRequest) VatomParameters(vatomParameters string) ApiTransferUserCoinsRequest {
	r.vatomParameters = &vatomParameters
	return r
}

// Return raw response
func (r ApiTransferUserCoinsRequest) ReturnRawResponse(returnRawResponse bool) ApiTransferUserCoinsRequest {
	r.returnRawResponse = &returnRawResponse
	return r
}

func (r ApiTransferUserCoinsRequest) Execute() (*http.Response, error) {
	return r.ApiService.TransferUserCoinsExecute(r)
}

/*
TransferUserCoins Transfer coins from Vatom Users

Transfer coins from Vatom Users.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTransferUserCoinsRequest
*/
func (a *VatomAPIService) TransferUserCoins(ctx context.Context) ApiTransferUserCoinsRequest {
	return ApiTransferUserCoinsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *VatomAPIService) TransferUserCoinsExecute(r ApiTransferUserCoinsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VatomAPIService.TransferUserCoins")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vatom/u/coins/transfer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return nil, reportError("accountId is required and must be specified")
	}
	if r.vatomUserId == nil {
		return nil, reportError("vatomUserId is required and must be specified")
	}
	if r.vatomParameters == nil {
		return nil, reportError("vatomParameters is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "vatomUserId", r.vatomUserId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "vatomParameters", r.vatomParameters, "form", "")
	if r.returnRawResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnRawResponse", r.returnRawResponse, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateBusinessCoinsRequest struct {
	ctx context.Context
	ApiService *VatomAPIService
	accountId *int64
	appKey *string
	vatomParameters *string
	returnRawResponse *bool
}

// Sirqul Account Id
func (r ApiUpdateBusinessCoinsRequest) AccountId(accountId int64) ApiUpdateBusinessCoinsRequest {
	r.accountId = &accountId
	return r
}

// Sirqul Application Key
func (r ApiUpdateBusinessCoinsRequest) AppKey(appKey string) ApiUpdateBusinessCoinsRequest {
	r.appKey = &appKey
	return r
}

// Vatom Parameters
func (r ApiUpdateBusinessCoinsRequest) VatomParameters(vatomParameters string) ApiUpdateBusinessCoinsRequest {
	r.vatomParameters = &vatomParameters
	return r
}

// Return raw response
func (r ApiUpdateBusinessCoinsRequest) ReturnRawResponse(returnRawResponse bool) ApiUpdateBusinessCoinsRequest {
	r.returnRawResponse = &returnRawResponse
	return r
}

func (r ApiUpdateBusinessCoinsRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateBusinessCoinsExecute(r)
}

/*
UpdateBusinessCoins Fund coins for a Business

Fund/update coins for a Businesss.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateBusinessCoinsRequest
*/
func (a *VatomAPIService) UpdateBusinessCoins(ctx context.Context) ApiUpdateBusinessCoinsRequest {
	return ApiUpdateBusinessCoinsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *VatomAPIService) UpdateBusinessCoinsExecute(r ApiUpdateBusinessCoinsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VatomAPIService.UpdateBusinessCoins")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vatom/b/coins/update"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return nil, reportError("accountId is required and must be specified")
	}
	if r.appKey == nil {
		return nil, reportError("appKey is required and must be specified")
	}
	if r.vatomParameters == nil {
		return nil, reportError("vatomParameters is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "vatomParameters", r.vatomParameters, "form", "")
	if r.returnRawResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnRawResponse", r.returnRawResponse, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateEventGuestListRequest struct {
	ctx context.Context
	ApiService *VatomAPIService
	accountId *int64
	appKey *string
	vatomEventId *string
	vatomParameters *string
	returnRawResponse *bool
}

// Sirqul Account Id
func (r ApiUpdateEventGuestListRequest) AccountId(accountId int64) ApiUpdateEventGuestListRequest {
	r.accountId = &accountId
	return r
}

// Sirqul Application Key
func (r ApiUpdateEventGuestListRequest) AppKey(appKey string) ApiUpdateEventGuestListRequest {
	r.appKey = &appKey
	return r
}

// Vatom Event Id
func (r ApiUpdateEventGuestListRequest) VatomEventId(vatomEventId string) ApiUpdateEventGuestListRequest {
	r.vatomEventId = &vatomEventId
	return r
}

// Vatom Parameters
func (r ApiUpdateEventGuestListRequest) VatomParameters(vatomParameters string) ApiUpdateEventGuestListRequest {
	r.vatomParameters = &vatomParameters
	return r
}

// Return raw response
func (r ApiUpdateEventGuestListRequest) ReturnRawResponse(returnRawResponse bool) ApiUpdateEventGuestListRequest {
	r.returnRawResponse = &returnRawResponse
	return r
}

func (r ApiUpdateEventGuestListRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateEventGuestListExecute(r)
}

/*
UpdateEventGuestList Update Vatom Event Guest List

Update the guest list of an event.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateEventGuestListRequest
*/
func (a *VatomAPIService) UpdateEventGuestList(ctx context.Context) ApiUpdateEventGuestListRequest {
	return ApiUpdateEventGuestListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *VatomAPIService) UpdateEventGuestListExecute(r ApiUpdateEventGuestListRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VatomAPIService.UpdateEventGuestList")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vatom/b/events/guests/update"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return nil, reportError("accountId is required and must be specified")
	}
	if r.appKey == nil {
		return nil, reportError("appKey is required and must be specified")
	}
	if r.vatomEventId == nil {
		return nil, reportError("vatomEventId is required and must be specified")
	}
	if r.vatomParameters == nil {
		return nil, reportError("vatomParameters is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "vatomEventId", r.vatomEventId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "vatomParameters", r.vatomParameters, "form", "")
	if r.returnRawResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnRawResponse", r.returnRawResponse, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateSpaceRequest struct {
	ctx context.Context
	ApiService *VatomAPIService
	accountId *int64
	appKey *string
	vatomSpaceId *string
	vatomParameters *string
	returnRawResponse *bool
}

// Sirqul Account Id
func (r ApiUpdateSpaceRequest) AccountId(accountId int64) ApiUpdateSpaceRequest {
	r.accountId = &accountId
	return r
}

// Sirqul Application Key
func (r ApiUpdateSpaceRequest) AppKey(appKey string) ApiUpdateSpaceRequest {
	r.appKey = &appKey
	return r
}

// Vatom Space Id
func (r ApiUpdateSpaceRequest) VatomSpaceId(vatomSpaceId string) ApiUpdateSpaceRequest {
	r.vatomSpaceId = &vatomSpaceId
	return r
}

// Vatom Parameters
func (r ApiUpdateSpaceRequest) VatomParameters(vatomParameters string) ApiUpdateSpaceRequest {
	r.vatomParameters = &vatomParameters
	return r
}

// Return raw response
func (r ApiUpdateSpaceRequest) ReturnRawResponse(returnRawResponse bool) ApiUpdateSpaceRequest {
	r.returnRawResponse = &returnRawResponse
	return r
}

func (r ApiUpdateSpaceRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateSpaceExecute(r)
}

/*
UpdateSpace Update Vatom Space

Update a Vatom space.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateSpaceRequest
*/
func (a *VatomAPIService) UpdateSpace(ctx context.Context) ApiUpdateSpaceRequest {
	return ApiUpdateSpaceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *VatomAPIService) UpdateSpaceExecute(r ApiUpdateSpaceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VatomAPIService.UpdateSpace")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vatom/b/spaces/update"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return nil, reportError("accountId is required and must be specified")
	}
	if r.appKey == nil {
		return nil, reportError("appKey is required and must be specified")
	}
	if r.vatomSpaceId == nil {
		return nil, reportError("vatomSpaceId is required and must be specified")
	}
	if r.vatomParameters == nil {
		return nil, reportError("vatomParameters is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "vatomSpaceId", r.vatomSpaceId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "vatomParameters", r.vatomParameters, "form", "")
	if r.returnRawResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnRawResponse", r.returnRawResponse, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateUserCoinsAsBusinessRequest struct {
	ctx context.Context
	ApiService *VatomAPIService
	accountId *int64
	vatomUserId *string
	appKey *string
	vatomParameters *string
	returnRawResponse *bool
}

// Sirqul Account Id
func (r ApiUpdateUserCoinsAsBusinessRequest) AccountId(accountId int64) ApiUpdateUserCoinsAsBusinessRequest {
	r.accountId = &accountId
	return r
}

// Vatom User Id
func (r ApiUpdateUserCoinsAsBusinessRequest) VatomUserId(vatomUserId string) ApiUpdateUserCoinsAsBusinessRequest {
	r.vatomUserId = &vatomUserId
	return r
}

// Sirqul Application Key
func (r ApiUpdateUserCoinsAsBusinessRequest) AppKey(appKey string) ApiUpdateUserCoinsAsBusinessRequest {
	r.appKey = &appKey
	return r
}

// Vatom Parameters
func (r ApiUpdateUserCoinsAsBusinessRequest) VatomParameters(vatomParameters string) ApiUpdateUserCoinsAsBusinessRequest {
	r.vatomParameters = &vatomParameters
	return r
}

// Return raw response
func (r ApiUpdateUserCoinsAsBusinessRequest) ReturnRawResponse(returnRawResponse bool) ApiUpdateUserCoinsAsBusinessRequest {
	r.returnRawResponse = &returnRawResponse
	return r
}

func (r ApiUpdateUserCoinsAsBusinessRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateUserCoinsAsBusinessExecute(r)
}

/*
UpdateUserCoinsAsBusiness Update the coins for a user (as a Business)

Update the coins for a user (as a Business).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateUserCoinsAsBusinessRequest
*/
func (a *VatomAPIService) UpdateUserCoinsAsBusiness(ctx context.Context) ApiUpdateUserCoinsAsBusinessRequest {
	return ApiUpdateUserCoinsAsBusinessRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *VatomAPIService) UpdateUserCoinsAsBusinessExecute(r ApiUpdateUserCoinsAsBusinessRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VatomAPIService.UpdateUserCoinsAsBusiness")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vatom/b/users/coins/update"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return nil, reportError("accountId is required and must be specified")
	}
	if r.vatomUserId == nil {
		return nil, reportError("vatomUserId is required and must be specified")
	}
	if r.appKey == nil {
		return nil, reportError("appKey is required and must be specified")
	}
	if r.vatomParameters == nil {
		return nil, reportError("vatomParameters is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "vatomUserId", r.vatomUserId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "vatomParameters", r.vatomParameters, "form", "")
	if r.returnRawResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnRawResponse", r.returnRawResponse, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateUserProfileRequest struct {
	ctx context.Context
	ApiService *VatomAPIService
	accountId *int64
	vatomParameters *string
	returnRawResponse *bool
}

// Sirqul Account Id
func (r ApiUpdateUserProfileRequest) AccountId(accountId int64) ApiUpdateUserProfileRequest {
	r.accountId = &accountId
	return r
}

// Vatom Parameters
func (r ApiUpdateUserProfileRequest) VatomParameters(vatomParameters string) ApiUpdateUserProfileRequest {
	r.vatomParameters = &vatomParameters
	return r
}

// Return raw response
func (r ApiUpdateUserProfileRequest) ReturnRawResponse(returnRawResponse bool) ApiUpdateUserProfileRequest {
	r.returnRawResponse = &returnRawResponse
	return r
}

func (r ApiUpdateUserProfileRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateUserProfileExecute(r)
}

/*
UpdateUserProfile Update Vatom User Profile

Gets the logged in user's profile in Vatom.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateUserProfileRequest
*/
func (a *VatomAPIService) UpdateUserProfile(ctx context.Context) ApiUpdateUserProfileRequest {
	return ApiUpdateUserProfileRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *VatomAPIService) UpdateUserProfileExecute(r ApiUpdateUserProfileRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VatomAPIService.UpdateUserProfile")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vatom/me/update"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return nil, reportError("accountId is required and must be specified")
	}
	if r.vatomParameters == nil {
		return nil, reportError("vatomParameters is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "vatomParameters", r.vatomParameters, "form", "")
	if r.returnRawResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnRawResponse", r.returnRawResponse, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateVatomEventRequest struct {
	ctx context.Context
	ApiService *VatomAPIService
	accountId *int64
	appKey *string
	vatomEventId *string
	vatomParameters *string
	returnRawResponse *bool
}

// Sirqul Account Id
func (r ApiUpdateVatomEventRequest) AccountId(accountId int64) ApiUpdateVatomEventRequest {
	r.accountId = &accountId
	return r
}

// Sirqul Application Key
func (r ApiUpdateVatomEventRequest) AppKey(appKey string) ApiUpdateVatomEventRequest {
	r.appKey = &appKey
	return r
}

// Vatom Event Id
func (r ApiUpdateVatomEventRequest) VatomEventId(vatomEventId string) ApiUpdateVatomEventRequest {
	r.vatomEventId = &vatomEventId
	return r
}

// Vatom Parameters
func (r ApiUpdateVatomEventRequest) VatomParameters(vatomParameters string) ApiUpdateVatomEventRequest {
	r.vatomParameters = &vatomParameters
	return r
}

// Return raw response
func (r ApiUpdateVatomEventRequest) ReturnRawResponse(returnRawResponse bool) ApiUpdateVatomEventRequest {
	r.returnRawResponse = &returnRawResponse
	return r
}

func (r ApiUpdateVatomEventRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateVatomEventExecute(r)
}

/*
UpdateVatomEvent Update Vatom Event

Update a Vatom event.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateVatomEventRequest
*/
func (a *VatomAPIService) UpdateVatomEvent(ctx context.Context) ApiUpdateVatomEventRequest {
	return ApiUpdateVatomEventRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *VatomAPIService) UpdateVatomEventExecute(r ApiUpdateVatomEventRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VatomAPIService.UpdateVatomEvent")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vatom/b/events/update"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return nil, reportError("accountId is required and must be specified")
	}
	if r.appKey == nil {
		return nil, reportError("appKey is required and must be specified")
	}
	if r.vatomEventId == nil {
		return nil, reportError("vatomEventId is required and must be specified")
	}
	if r.vatomParameters == nil {
		return nil, reportError("vatomParameters is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "vatomEventId", r.vatomEventId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "vatomParameters", r.vatomParameters, "form", "")
	if r.returnRawResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnRawResponse", r.returnRawResponse, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
