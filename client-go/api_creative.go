/*
Sirqul IoT Platform

Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

API version: 3.16
Contact: info@sirqul.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// CreativeAPIService CreativeAPI service
type CreativeAPIService service

type ApiAddPreviewRequest struct {
	ctx context.Context
	ApiService *CreativeAPIService
	accountId *int64
	creativeId *int64
}

// the id of the account
func (r ApiAddPreviewRequest) AccountId(accountId int64) ApiAddPreviewRequest {
	r.accountId = &accountId
	return r
}

// The id of the creative that want to enable preview. The type of the creative should be CONFIG, otherwise no action will be applied.
func (r ApiAddPreviewRequest) CreativeId(creativeId int64) ApiAddPreviewRequest {
	r.creativeId = &creativeId
	return r
}

func (r ApiAddPreviewRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.AddPreviewExecute(r)
}

/*
AddPreview Add Preview

Enable this ad for preview for this account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAddPreviewRequest
*/
func (a *CreativeAPIService) AddPreview(ctx context.Context) ApiAddPreviewRequest {
	return ApiAddPreviewRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *CreativeAPIService) AddPreviewExecute(r ApiAddPreviewRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CreativeAPIService.AddPreview")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/creative/addpreview"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.creativeId == nil {
		return localVarReturnValue, nil, reportError("creativeId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "creativeId", r.creativeId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdsFindRequest struct {
	ctx context.Context
	ApiService *CreativeAPIService
	appKey *string
	randomize *bool
	targetedAdsOnly *bool
	type_ *string
	accountId *int64
	appVersion *string
	latitude *float64
	longitude *float64
	device *string
	deviceIdentifier *int64
	deviceVersion *string
	start *int32
	limit *int32
	includeAudiences *bool
	allocatesTickets *bool
	missionIds *string
}

// The application key, if provided return missions specific for the app. Will always return mission levels that are app agnostic.
func (r ApiAdsFindRequest) AppKey(appKey string) ApiAdsFindRequest {
	r.appKey = &appKey
	return r
}

// return a random set of results, default is true. If false returns in nature order.
func (r ApiAdsFindRequest) Randomize(randomize bool) ApiAdsFindRequest {
	r.randomize = &randomize
	return r
}

// return only ads targets to the specific app, no global ads.
func (r ApiAdsFindRequest) TargetedAdsOnly(targetedAdsOnly bool) ApiAdsFindRequest {
	r.targetedAdsOnly = &targetedAdsOnly
	return r
}

// The type of ads to get, possible values are: BANNER, LEADERBOARD, SKYSCRAPER, FULL, VIDEO, ZIP, CONFIG. Use this instead of suffix.
func (r ApiAdsFindRequest) Type_(type_ string) ApiAdsFindRequest {
	r.type_ = &type_
	return r
}

// The logged in user.
func (r ApiAdsFindRequest) AccountId(accountId int64) ApiAdsFindRequest {
	r.accountId = &accountId
	return r
}

// The version of the application, will not return levels newer than the appVersion.
func (r ApiAdsFindRequest) AppVersion(appVersion string) ApiAdsFindRequest {
	r.appVersion = &appVersion
	return r
}

// The current location of the requesting device
func (r ApiAdsFindRequest) Latitude(latitude float64) ApiAdsFindRequest {
	r.latitude = &latitude
	return r
}

// The current location of the requesting device
func (r ApiAdsFindRequest) Longitude(longitude float64) ApiAdsFindRequest {
	r.longitude = &longitude
	return r
}

// Should use deviceId if possible. The name of the requesting device; possible values are: Android, iPhone, iPad, iPod, etc. use /audience/devices for list.
func (r ApiAdsFindRequest) Device(device string) ApiAdsFindRequest {
	r.device = &device
	return r
}

// The device ID of the requesting device, use /audience/devices for list
func (r ApiAdsFindRequest) DeviceIdentifier(deviceIdentifier int64) ApiAdsFindRequest {
	r.deviceIdentifier = &deviceIdentifier
	return r
}

// The requesting device version; examples are: 2.3, 5.1.4, 6.1.4. Supports X, X.X, or X.X.X formated string.
func (r ApiAdsFindRequest) DeviceVersion(deviceVersion string) ApiAdsFindRequest {
	r.deviceVersion = &deviceVersion
	return r
}

// The index into the record set to start with.
func (r ApiAdsFindRequest) Start(start int32) ApiAdsFindRequest {
	r.start = &start
	return r
}

// The total number of record to return.
func (r ApiAdsFindRequest) Limit(limit int32) ApiAdsFindRequest {
	r.limit = &limit
	return r
}

// If true then return the audience data in the response. Default is false.
func (r ApiAdsFindRequest) IncludeAudiences(includeAudiences bool) ApiAdsFindRequest {
	r.includeAudiences = &includeAudiences
	return r
}

// If true/false only return missions whose game levels allocate (or don&#39;t allocate) tickets. Do not provide a value to return both.
func (r ApiAdsFindRequest) AllocatesTickets(allocatesTickets bool) ApiAdsFindRequest {
	r.allocatesTickets = &allocatesTickets
	return r
}

// return only ads from the specified campaigns.
func (r ApiAdsFindRequest) MissionIds(missionIds string) ApiAdsFindRequest {
	r.missionIds = &missionIds
	return r
}

func (r ApiAdsFindRequest) Execute() ([]MissionResponse, *http.Response, error) {
	return r.ApiService.AdsFindExecute(r)
}

/*
AdsFind Find Missions

Get a set of ad filtered by the parameters provided.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAdsFindRequest
*/
func (a *CreativeAPIService) AdsFind(ctx context.Context) ApiAdsFindRequest {
	return ApiAdsFindRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []MissionResponse
func (a *CreativeAPIService) AdsFindExecute(r ApiAdsFindRequest) ([]MissionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []MissionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CreativeAPIService.AdsFind")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ads/find"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.appKey == nil {
		return localVarReturnValue, nil, reportError("appKey is required and must be specified")
	}
	if r.randomize == nil {
		return localVarReturnValue, nil, reportError("randomize is required and must be specified")
	}
	if r.targetedAdsOnly == nil {
		return localVarReturnValue, nil, reportError("targetedAdsOnly is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.appVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appVersion", r.appVersion, "form", "")
	}
	if r.latitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latitude", r.latitude, "form", "")
	}
	if r.longitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "longitude", r.longitude, "form", "")
	}
	if r.device != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "device", r.device, "form", "")
	}
	if r.deviceIdentifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceIdentifier", r.deviceIdentifier, "form", "")
	}
	if r.deviceVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceVersion", r.deviceVersion, "form", "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.includeAudiences != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeAudiences", r.includeAudiences, "form", "")
	}
	if r.allocatesTickets != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allocatesTickets", r.allocatesTickets, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "randomize", r.randomize, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "targetedAdsOnly", r.targetedAdsOnly, "form", "")
	if r.missionIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "missionIds", r.missionIds, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCreativeRequest struct {
	ctx context.Context
	ApiService *CreativeAPIService
	accountId *int64
	name *string
	active *bool
	waitForAsset *bool
	description *string
	assetImageId *int64
	action *string
	data *string
	suffix *string
	type_ *string
	balance *float64
	referenceId *int64
	appVersion *string
	missionId *int64
	offerId *int64
}

// The logged in user.
func (r ApiCreateCreativeRequest) AccountId(accountId int64) ApiCreateCreativeRequest {
	r.accountId = &accountId
	return r
}

// The name of the level.
func (r ApiCreateCreativeRequest) Name(name string) ApiCreateCreativeRequest {
	r.name = &name
	return r
}

// If true set the game level as active. Default is false.
func (r ApiCreateCreativeRequest) Active(active bool) ApiCreateCreativeRequest {
	r.active = &active
	return r
}

// determines whether the response will wait until the asset gets created
func (r ApiCreateCreativeRequest) WaitForAsset(waitForAsset bool) ApiCreateCreativeRequest {
	r.waitForAsset = &waitForAsset
	return r
}

// The description of the level.
func (r ApiCreateCreativeRequest) Description(description string) ApiCreateCreativeRequest {
	r.description = &description
	return r
}

// The asset Id of the level image.
func (r ApiCreateCreativeRequest) AssetImageId(assetImageId int64) ApiCreateCreativeRequest {
	r.assetImageId = &assetImageId
	return r
}

// This parameter is deprecated. deprecated use data field
func (r ApiCreateCreativeRequest) Action(action string) ApiCreateCreativeRequest {
	r.action = &action
	return r
}

// The creative data, json based format depending on type. If not using action then data is required.
func (r ApiCreateCreativeRequest) Data(data string) ApiCreateCreativeRequest {
	r.data = &data
	return r
}

// This parameter is deprecated. deprecated use type field
func (r ApiCreateCreativeRequest) Suffix(suffix string) ApiCreateCreativeRequest {
	r.suffix = &suffix
	return r
}

// The type of creative. If not using suffix then type is required.
func (r ApiCreateCreativeRequest) Type_(type_ string) ApiCreateCreativeRequest {
	r.type_ = &type_
	return r
}

// Set the amount of money available to spend, once 0 deactivate level. Set to a negative value for unlimited.
func (r ApiCreateCreativeRequest) Balance(balance float64) ApiCreateCreativeRequest {
	r.balance = &balance
	return r
}

// if creative related so some other content provided the id
func (r ApiCreateCreativeRequest) ReferenceId(referenceId int64) ApiCreateCreativeRequest {
	r.referenceId = &referenceId
	return r
}

// The version of the application, will not return creatives newer than the appVersion. Only used when requesting application configuration creatives.
func (r ApiCreateCreativeRequest) AppVersion(appVersion string) ApiCreateCreativeRequest {
	r.appVersion = &appVersion
	return r
}

// Assign the creative to a campaign for timing and audience matching.
func (r ApiCreateCreativeRequest) MissionId(missionId int64) ApiCreateCreativeRequest {
	r.missionId = &missionId
	return r
}

// the id of the offer
func (r ApiCreateCreativeRequest) OfferId(offerId int64) ApiCreateCreativeRequest {
	r.offerId = &offerId
	return r
}

func (r ApiCreateCreativeRequest) Execute() (*CreativeResponse, *http.Response, error) {
	return r.ApiService.CreateCreativeExecute(r)
}

/*
CreateCreative Create Creative

Create a creative

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateCreativeRequest
*/
func (a *CreativeAPIService) CreateCreative(ctx context.Context) ApiCreateCreativeRequest {
	return ApiCreateCreativeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreativeResponse
func (a *CreativeAPIService) CreateCreativeExecute(r ApiCreateCreativeRequest) (*CreativeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreativeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CreativeAPIService.CreateCreative")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/creative/create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.name == nil {
		return localVarReturnValue, nil, reportError("name is required and must be specified")
	}
	if r.active == nil {
		return localVarReturnValue, nil, reportError("active is required and must be specified")
	}
	if r.waitForAsset == nil {
		return localVarReturnValue, nil, reportError("waitForAsset is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "form", "")
	}
	if r.assetImageId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetImageId", r.assetImageId, "form", "")
	}
	if r.action != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "action", r.action, "form", "")
	}
	if r.data != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "data", r.data, "form", "")
	}
	if r.suffix != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "suffix", r.suffix, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.balance != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "balance", r.balance, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "active", r.active, "form", "")
	if r.referenceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "referenceId", r.referenceId, "form", "")
	}
	if r.appVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appVersion", r.appVersion, "form", "")
	}
	if r.missionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "missionId", r.missionId, "form", "")
	}
	if r.offerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offerId", r.offerId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "waitForAsset", r.waitForAsset, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCreativeRequest struct {
	ctx context.Context
	ApiService *CreativeAPIService
	accountId *int64
	creativeId *int64
}

// the id of the logged in user
func (r ApiDeleteCreativeRequest) AccountId(accountId int64) ApiDeleteCreativeRequest {
	r.accountId = &accountId
	return r
}

// the id of the creative to delete
func (r ApiDeleteCreativeRequest) CreativeId(creativeId int64) ApiDeleteCreativeRequest {
	r.creativeId = &creativeId
	return r
}

func (r ApiDeleteCreativeRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.DeleteCreativeExecute(r)
}

/*
DeleteCreative Delete Creative

Delete a creative

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteCreativeRequest
*/
func (a *CreativeAPIService) DeleteCreative(ctx context.Context) ApiDeleteCreativeRequest {
	return ApiDeleteCreativeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *CreativeAPIService) DeleteCreativeExecute(r ApiDeleteCreativeRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CreativeAPIService.DeleteCreative")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/creative/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.creativeId == nil {
		return localVarReturnValue, nil, reportError("creativeId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "creativeId", r.creativeId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCreativeRequest struct {
	ctx context.Context
	ApiService *CreativeAPIService
	accountId *int64
	creativeId *int64
}

// the id of the logged in user
func (r ApiGetCreativeRequest) AccountId(accountId int64) ApiGetCreativeRequest {
	r.accountId = &accountId
	return r
}

// the ID of the creative to get
func (r ApiGetCreativeRequest) CreativeId(creativeId int64) ApiGetCreativeRequest {
	r.creativeId = &creativeId
	return r
}

func (r ApiGetCreativeRequest) Execute() (*CreativeResponse, *http.Response, error) {
	return r.ApiService.GetCreativeExecute(r)
}

/*
GetCreative Get Creative

Get a creative

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCreativeRequest
*/
func (a *CreativeAPIService) GetCreative(ctx context.Context) ApiGetCreativeRequest {
	return ApiGetCreativeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreativeResponse
func (a *CreativeAPIService) GetCreativeExecute(r ApiGetCreativeRequest) (*CreativeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreativeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CreativeAPIService.GetCreative")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/creative/get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.creativeId == nil {
		return localVarReturnValue, nil, reportError("creativeId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "creativeId", r.creativeId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCreativesByApplicationRequest struct {
	ctx context.Context
	ApiService *CreativeAPIService
	accountId *int64
	appKey *string
	start *int32
	limit *int32
	missionId *int64
	keyword *string
}

// The logged in user.
func (r ApiGetCreativesByApplicationRequest) AccountId(accountId int64) ApiGetCreativesByApplicationRequest {
	r.accountId = &accountId
	return r
}

// the application key
func (r ApiGetCreativesByApplicationRequest) AppKey(appKey string) ApiGetCreativesByApplicationRequest {
	r.appKey = &appKey
	return r
}

// Start the result set at some index.
func (r ApiGetCreativesByApplicationRequest) Start(start int32) ApiGetCreativesByApplicationRequest {
	r.start = &start
	return r
}

// Limit the result to some number.
func (r ApiGetCreativesByApplicationRequest) Limit(limit int32) ApiGetCreativesByApplicationRequest {
	r.limit = &limit
	return r
}

// Creatives contained in the provided mission.
func (r ApiGetCreativesByApplicationRequest) MissionId(missionId int64) ApiGetCreativesByApplicationRequest {
	r.missionId = &missionId
	return r
}

// Match the keyword to the owner name or level name.
func (r ApiGetCreativesByApplicationRequest) Keyword(keyword string) ApiGetCreativesByApplicationRequest {
	r.keyword = &keyword
	return r
}

func (r ApiGetCreativesByApplicationRequest) Execute() ([]CreativeResponse, *http.Response, error) {
	return r.ApiService.GetCreativesByApplicationExecute(r)
}

/*
GetCreativesByApplication Search Creatives

Get a list of levels for an application, just those the account has permissions to view.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCreativesByApplicationRequest
*/
func (a *CreativeAPIService) GetCreativesByApplication(ctx context.Context) ApiGetCreativesByApplicationRequest {
	return ApiGetCreativesByApplicationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CreativeResponse
func (a *CreativeAPIService) GetCreativesByApplicationExecute(r ApiGetCreativesByApplicationRequest) ([]CreativeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CreativeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CreativeAPIService.GetCreativesByApplication")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/creative/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.appKey == nil {
		return localVarReturnValue, nil, reportError("appKey is required and must be specified")
	}
	if r.start == nil {
		return localVarReturnValue, nil, reportError("start is required and must be specified")
	}
	if r.limit == nil {
		return localVarReturnValue, nil, reportError("limit is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	if r.missionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "missionId", r.missionId, "form", "")
	}
	if r.keyword != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyword", r.keyword, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRemovePreviewRequest struct {
	ctx context.Context
	ApiService *CreativeAPIService
	accountId *int64
	creativeId *int64
}

// the ID of the logged in user
func (r ApiRemovePreviewRequest) AccountId(accountId int64) ApiRemovePreviewRequest {
	r.accountId = &accountId
	return r
}

// the ID of the creative to remove preview
func (r ApiRemovePreviewRequest) CreativeId(creativeId int64) ApiRemovePreviewRequest {
	r.creativeId = &creativeId
	return r
}

func (r ApiRemovePreviewRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.RemovePreviewExecute(r)
}

/*
RemovePreview Remove Preview

Remove this ad for preview for this account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRemovePreviewRequest
*/
func (a *CreativeAPIService) RemovePreview(ctx context.Context) ApiRemovePreviewRequest {
	return ApiRemovePreviewRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *CreativeAPIService) RemovePreviewExecute(r ApiRemovePreviewRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CreativeAPIService.RemovePreview")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/creative/removepreview"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.creativeId == nil {
		return localVarReturnValue, nil, reportError("creativeId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "creativeId", r.creativeId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateCreativeRequest struct {
	ctx context.Context
	ApiService *CreativeAPIService
	accountId *int64
	creativeId *int64
	name *string
	description *string
	assetImageId *int64
	action *string
	data *string
	suffix *string
	type_ *string
	balance *float64
	active *bool
	referenceId *int64
	appVersion *string
	missionId *int64
}

// The logged in user.
func (r ApiUpdateCreativeRequest) AccountId(accountId int64) ApiUpdateCreativeRequest {
	r.accountId = &accountId
	return r
}

// the creative Id to upate.
func (r ApiUpdateCreativeRequest) CreativeId(creativeId int64) ApiUpdateCreativeRequest {
	r.creativeId = &creativeId
	return r
}

// The name of the level.
func (r ApiUpdateCreativeRequest) Name(name string) ApiUpdateCreativeRequest {
	r.name = &name
	return r
}

// The description of the level.
func (r ApiUpdateCreativeRequest) Description(description string) ApiUpdateCreativeRequest {
	r.description = &description
	return r
}

// The asset Id of the level image.
func (r ApiUpdateCreativeRequest) AssetImageId(assetImageId int64) ApiUpdateCreativeRequest {
	r.assetImageId = &assetImageId
	return r
}

// This parameter is deprecated. deprecated use data field
func (r ApiUpdateCreativeRequest) Action(action string) ApiUpdateCreativeRequest {
	r.action = &action
	return r
}

// The creative data, json based format depending on type
func (r ApiUpdateCreativeRequest) Data(data string) ApiUpdateCreativeRequest {
	r.data = &data
	return r
}

// This parameter is deprecated. deprecated use type field
func (r ApiUpdateCreativeRequest) Suffix(suffix string) ApiUpdateCreativeRequest {
	r.suffix = &suffix
	return r
}

// The type of creative.
func (r ApiUpdateCreativeRequest) Type_(type_ string) ApiUpdateCreativeRequest {
	r.type_ = &type_
	return r
}

// Set the amount of money available to spend, once 0 deactivate level. Set to a negative value for unlimited.
func (r ApiUpdateCreativeRequest) Balance(balance float64) ApiUpdateCreativeRequest {
	r.balance = &balance
	return r
}

// If true set the game level as active. Default is false.
func (r ApiUpdateCreativeRequest) Active(active bool) ApiUpdateCreativeRequest {
	r.active = &active
	return r
}

// if creative related so some other content provided the id
func (r ApiUpdateCreativeRequest) ReferenceId(referenceId int64) ApiUpdateCreativeRequest {
	r.referenceId = &referenceId
	return r
}

// The version of the application, will not return creatives newer than the appVersion. Only used when requesting application configuration creatives.
func (r ApiUpdateCreativeRequest) AppVersion(appVersion string) ApiUpdateCreativeRequest {
	r.appVersion = &appVersion
	return r
}

// Assign the creative to a campaign for timing and audience matching.
func (r ApiUpdateCreativeRequest) MissionId(missionId int64) ApiUpdateCreativeRequest {
	r.missionId = &missionId
	return r
}

func (r ApiUpdateCreativeRequest) Execute() (*CreativeResponse, *http.Response, error) {
	return r.ApiService.UpdateCreativeExecute(r)
}

/*
UpdateCreative Update Creative

Update a creative

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateCreativeRequest
*/
func (a *CreativeAPIService) UpdateCreative(ctx context.Context) ApiUpdateCreativeRequest {
	return ApiUpdateCreativeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreativeResponse
func (a *CreativeAPIService) UpdateCreativeExecute(r ApiUpdateCreativeRequest) (*CreativeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreativeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CreativeAPIService.UpdateCreative")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/creative/update"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.creativeId == nil {
		return localVarReturnValue, nil, reportError("creativeId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "creativeId", r.creativeId, "form", "")
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "form", "")
	}
	if r.assetImageId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetImageId", r.assetImageId, "form", "")
	}
	if r.action != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "action", r.action, "form", "")
	}
	if r.data != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "data", r.data, "form", "")
	}
	if r.suffix != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "suffix", r.suffix, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.balance != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "balance", r.balance, "form", "")
	}
	if r.active != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active", r.active, "form", "")
	}
	if r.referenceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "referenceId", r.referenceId, "form", "")
	}
	if r.appVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appVersion", r.appVersion, "form", "")
	}
	if r.missionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "missionId", r.missionId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
