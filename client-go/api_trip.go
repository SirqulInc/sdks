/*
Sirqul IoT Platform

Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

API version: 3.16
Contact: info@sirqul.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// TripAPIService TripAPI service
type TripAPIService service

type ApiCreateTripRequest struct {
	ctx context.Context
	ApiService *TripAPIService
	version float32
	body *Trip
}

func (r ApiCreateTripRequest) Body(body Trip) ApiCreateTripRequest {
	r.body = &body
	return r
}

func (r ApiCreateTripRequest) Execute() (*Trip, *http.Response, error) {
	return r.ApiService.CreateTripExecute(r)
}

/*
CreateTrip Create Trip

Create a new trip

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiCreateTripRequest
*/
func (a *TripAPIService) CreateTrip(ctx context.Context, version float32) ApiCreateTripRequest {
	return ApiCreateTripRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return Trip
func (a *TripAPIService) CreateTripExecute(r ApiCreateTripRequest) (*Trip, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Trip
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TripAPIService.CreateTrip")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/trip"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteRequest struct {
	ctx context.Context
	ApiService *TripAPIService
	version float32
	id int64
}

func (r ApiDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteExecute(r)
}

/*
Delete Delete Trip

Delete an existing trip

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @param id the id of the trip to delete
 @return ApiDeleteRequest
*/
func (a *TripAPIService) Delete(ctx context.Context, version float32, id int64) ApiDeleteRequest {
	return ApiDeleteRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
		id: id,
	}
}

// Execute executes the request
func (a *TripAPIService) DeleteExecute(r ApiDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TripAPIService.Delete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/trip/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDriveTripRequest struct {
	ctx context.Context
	ApiService *TripAPIService
	version float32
	id int64
	recurrence *bool
}

// the frequency of the trip (e.g. weekly, until 2018-08-09)
func (r ApiDriveTripRequest) Recurrence(recurrence bool) ApiDriveTripRequest {
	r.recurrence = &recurrence
	return r
}

func (r ApiDriveTripRequest) Execute() (*Trip, *http.Response, error) {
	return r.ApiService.DriveTripExecute(r)
}

/*
DriveTrip Set Trip Preference Driver

Update trip preference to drive, also create a route and assign the trip to the route

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @param id the id of the trip
 @return ApiDriveTripRequest
*/
func (a *TripAPIService) DriveTrip(ctx context.Context, version float32, id int64) ApiDriveTripRequest {
	return ApiDriveTripRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
		id: id,
	}
}

// Execute executes the request
//  @return Trip
func (a *TripAPIService) DriveTripExecute(r ApiDriveTripRequest) (*Trip, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Trip
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TripAPIService.DriveTrip")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/trip/{id}/drive"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.recurrence == nil {
		return localVarReturnValue, nil, reportError("recurrence is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "recurrence", r.recurrence, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFlexibleTripRequest struct {
	ctx context.Context
	ApiService *TripAPIService
	version float32
	id int64
	recurrence *bool
}

// the frequency of the trip (e.g. weekly, until 2018-08-09)
func (r ApiFlexibleTripRequest) Recurrence(recurrence bool) ApiFlexibleTripRequest {
	r.recurrence = &recurrence
	return r
}

func (r ApiFlexibleTripRequest) Execute() (*Trip, *http.Response, error) {
	return r.ApiService.FlexibleTripExecute(r)
}

/*
FlexibleTrip Set Trip Preference Flexible

Update trip preference to flexible.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @param id the id of the trip
 @return ApiFlexibleTripRequest
*/
func (a *TripAPIService) FlexibleTrip(ctx context.Context, version float32, id int64) ApiFlexibleTripRequest {
	return ApiFlexibleTripRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
		id: id,
	}
}

// Execute executes the request
//  @return Trip
func (a *TripAPIService) FlexibleTripExecute(r ApiFlexibleTripRequest) (*Trip, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Trip
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TripAPIService.FlexibleTrip")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/trip/{id}/flexible"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.recurrence == nil {
		return localVarReturnValue, nil, reportError("recurrence is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "recurrence", r.recurrence, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTripRequest struct {
	ctx context.Context
	ApiService *TripAPIService
	version float32
	id int64
}

func (r ApiGetTripRequest) Execute() (*Trip, *http.Response, error) {
	return r.ApiService.GetTripExecute(r)
}

/*
GetTrip Get Trip

Get an existing trip

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @param id the id of the trip to get
 @return ApiGetTripRequest
*/
func (a *TripAPIService) GetTrip(ctx context.Context, version float32, id int64) ApiGetTripRequest {
	return ApiGetTripRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
		id: id,
	}
}

// Execute executes the request
//  @return Trip
func (a *TripAPIService) GetTripExecute(r ApiGetTripRequest) (*Trip, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Trip
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TripAPIService.GetTrip")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/trip/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTripMatchesRequest struct {
	ctx context.Context
	ApiService *TripAPIService
	version float32
	id int64
	sortField *string
	descending *bool
	start *int32
	limit *int32
	activeOnly *bool
	matchedHasRoute *bool
	matchedHasDriver *bool
}

// The field to sort by
func (r ApiGetTripMatchesRequest) SortField(sortField string) ApiGetTripMatchesRequest {
	r.sortField = &sortField
	return r
}

// Determines whether the sorted list is in descending or ascending order
func (r ApiGetTripMatchesRequest) Descending(descending bool) ApiGetTripMatchesRequest {
	r.descending = &descending
	return r
}

// The start index for pagination
func (r ApiGetTripMatchesRequest) Start(start int32) ApiGetTripMatchesRequest {
	r.start = &start
	return r
}

// The limit for pagination
func (r ApiGetTripMatchesRequest) Limit(limit int32) ApiGetTripMatchesRequest {
	r.limit = &limit
	return r
}

// Return only active results
func (r ApiGetTripMatchesRequest) ActiveOnly(activeOnly bool) ApiGetTripMatchesRequest {
	r.activeOnly = &activeOnly
	return r
}

// Only return matchings that already have route assigned
func (r ApiGetTripMatchesRequest) MatchedHasRoute(matchedHasRoute bool) ApiGetTripMatchesRequest {
	r.matchedHasRoute = &matchedHasRoute
	return r
}

// Only return matchings that already have driver assigned
func (r ApiGetTripMatchesRequest) MatchedHasDriver(matchedHasDriver bool) ApiGetTripMatchesRequest {
	r.matchedHasDriver = &matchedHasDriver
	return r
}

func (r ApiGetTripMatchesRequest) Execute() ([]Trip, *http.Response, error) {
	return r.ApiService.GetTripMatchesExecute(r)
}

/*
GetTripMatches Get Trip Matches

Get matching trips of specific trip

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @param id The id The id of the trip to search for matches for
 @return ApiGetTripMatchesRequest
*/
func (a *TripAPIService) GetTripMatches(ctx context.Context, version float32, id int64) ApiGetTripMatchesRequest {
	return ApiGetTripMatchesRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
		id: id,
	}
}

// Execute executes the request
//  @return []Trip
func (a *TripAPIService) GetTripMatchesExecute(r ApiGetTripMatchesRequest) ([]Trip, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Trip
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TripAPIService.GetTripMatches")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/trip/{id}/match"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sortField == nil {
		return localVarReturnValue, nil, reportError("sortField is required and must be specified")
	}
	if r.descending == nil {
		return localVarReturnValue, nil, reportError("descending is required and must be specified")
	}
	if r.start == nil {
		return localVarReturnValue, nil, reportError("start is required and must be specified")
	}
	if r.limit == nil {
		return localVarReturnValue, nil, reportError("limit is required and must be specified")
	}
	if r.activeOnly == nil {
		return localVarReturnValue, nil, reportError("activeOnly is required and must be specified")
	}

	if r.matchedHasRoute != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "matchedHasRoute", r.matchedHasRoute, "form", "")
	}
	if r.matchedHasDriver != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "matchedHasDriver", r.matchedHasDriver, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", r.sortField, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "activeOnly", r.activeOnly, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProcessTripMatchesRequest struct {
	ctx context.Context
	ApiService *TripAPIService
	version float32
	startDate *int64
	endDate *int64
	tripId *int64
}

// The lower bound date to process matchings
func (r ApiProcessTripMatchesRequest) StartDate(startDate int64) ApiProcessTripMatchesRequest {
	r.startDate = &startDate
	return r
}

// The upper bound date to process matchings
func (r ApiProcessTripMatchesRequest) EndDate(endDate int64) ApiProcessTripMatchesRequest {
	r.endDate = &endDate
	return r
}

// the id of the trip to process
func (r ApiProcessTripMatchesRequest) TripId(tripId int64) ApiProcessTripMatchesRequest {
	r.tripId = &tripId
	return r
}

func (r ApiProcessTripMatchesRequest) Execute() ([]Trip, *http.Response, error) {
	return r.ApiService.ProcessTripMatchesExecute(r)
}

/*
ProcessTripMatches Process Trip Matches

Process trip matching, assign trips with no route to matched trips with route.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiProcessTripMatchesRequest
*/
func (a *TripAPIService) ProcessTripMatches(ctx context.Context, version float32) ApiProcessTripMatchesRequest {
	return ApiProcessTripMatchesRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return []Trip
func (a *TripAPIService) ProcessTripMatchesExecute(r ApiProcessTripMatchesRequest) ([]Trip, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Trip
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TripAPIService.ProcessTripMatches")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/trip/match/process"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "form", "")
	}
	if r.tripId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tripId", r.tripId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRideRequest struct {
	ctx context.Context
	ApiService *TripAPIService
	version float32
	id int64
	recurrence *bool
}

// the frequency of the trip (e.g. weekly, until 2018-08-09)
func (r ApiRideRequest) Recurrence(recurrence bool) ApiRideRequest {
	r.recurrence = &recurrence
	return r
}

func (r ApiRideRequest) Execute() (*Trip, *http.Response, error) {
	return r.ApiService.RideExecute(r)
}

/*
Ride Set Trip Preference Rider

Update trip preference to ride.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @param id the id of the trip
 @return ApiRideRequest
*/
func (a *TripAPIService) Ride(ctx context.Context, version float32, id int64) ApiRideRequest {
	return ApiRideRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
		id: id,
	}
}

// Execute executes the request
//  @return Trip
func (a *TripAPIService) RideExecute(r ApiRideRequest) (*Trip, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Trip
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TripAPIService.Ride")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/trip/{id}/ride"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.recurrence == nil {
		return localVarReturnValue, nil, reportError("recurrence is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "recurrence", r.recurrence, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchRequest struct {
	ctx context.Context
	ApiService *TripAPIService
	version float32
	accountId *int64
	sortField *string
	descending *bool
	start *int32
	limit *int32
	activeOnly *bool
	startDate *int64
	endDate *int64
	hasNotifications *bool
}

// The owner of the trips
func (r ApiSearchRequest) AccountId(accountId int64) ApiSearchRequest {
	r.accountId = &accountId
	return r
}

// The field to sort by
func (r ApiSearchRequest) SortField(sortField string) ApiSearchRequest {
	r.sortField = &sortField
	return r
}

// Determines whether the sorted list is in descending or ascending order
func (r ApiSearchRequest) Descending(descending bool) ApiSearchRequest {
	r.descending = &descending
	return r
}

// The start index for pagination
func (r ApiSearchRequest) Start(start int32) ApiSearchRequest {
	r.start = &start
	return r
}

// The limit for pagination
func (r ApiSearchRequest) Limit(limit int32) ApiSearchRequest {
	r.limit = &limit
	return r
}

// Return only active results
func (r ApiSearchRequest) ActiveOnly(activeOnly bool) ApiSearchRequest {
	r.activeOnly = &activeOnly
	return r
}

// The lower bound limit of time
func (r ApiSearchRequest) StartDate(startDate int64) ApiSearchRequest {
	r.startDate = &startDate
	return r
}

// The upper bound limit of time
func (r ApiSearchRequest) EndDate(endDate int64) ApiSearchRequest {
	r.endDate = &endDate
	return r
}

// whether to search on trips that have notifications or not
func (r ApiSearchRequest) HasNotifications(hasNotifications bool) ApiSearchRequest {
	r.hasNotifications = &hasNotifications
	return r
}

func (r ApiSearchRequest) Execute() ([]Trip, *http.Response, error) {
	return r.ApiService.SearchExecute(r)
}

/*
Search Search Trips

Search for trips

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiSearchRequest
*/
func (a *TripAPIService) Search(ctx context.Context, version float32) ApiSearchRequest {
	return ApiSearchRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return []Trip
func (a *TripAPIService) SearchExecute(r ApiSearchRequest) ([]Trip, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Trip
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TripAPIService.Search")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/trip"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.sortField == nil {
		return localVarReturnValue, nil, reportError("sortField is required and must be specified")
	}
	if r.descending == nil {
		return localVarReturnValue, nil, reportError("descending is required and must be specified")
	}
	if r.start == nil {
		return localVarReturnValue, nil, reportError("start is required and must be specified")
	}
	if r.limit == nil {
		return localVarReturnValue, nil, reportError("limit is required and must be specified")
	}
	if r.activeOnly == nil {
		return localVarReturnValue, nil, reportError("activeOnly is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "form", "")
	}
	if r.hasNotifications != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hasNotifications", r.hasNotifications, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", r.sortField, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "activeOnly", r.activeOnly, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchTripsRequest struct {
	ctx context.Context
	ApiService *TripAPIService
	version float32
	accountId *int64
	sortField *string
	descending *bool
	start *int32
	limit *int32
	activeOnly *bool
	startDate *int64
	endDate *int64
	matchedHasRoute *bool
	matchedHasDriver *bool
}

// The owner of the trips
func (r ApiSearchTripsRequest) AccountId(accountId int64) ApiSearchTripsRequest {
	r.accountId = &accountId
	return r
}

// The field to sort by
func (r ApiSearchTripsRequest) SortField(sortField string) ApiSearchTripsRequest {
	r.sortField = &sortField
	return r
}

// Determines whether the sorted list is in descending or ascending order
func (r ApiSearchTripsRequest) Descending(descending bool) ApiSearchTripsRequest {
	r.descending = &descending
	return r
}

// The start index for pagination
func (r ApiSearchTripsRequest) Start(start int32) ApiSearchTripsRequest {
	r.start = &start
	return r
}

// The limit for pagination
func (r ApiSearchTripsRequest) Limit(limit int32) ApiSearchTripsRequest {
	r.limit = &limit
	return r
}

// Return only active results
func (r ApiSearchTripsRequest) ActiveOnly(activeOnly bool) ApiSearchTripsRequest {
	r.activeOnly = &activeOnly
	return r
}

// The lower bound limit of time
func (r ApiSearchTripsRequest) StartDate(startDate int64) ApiSearchTripsRequest {
	r.startDate = &startDate
	return r
}

// The upper bound limit of time
func (r ApiSearchTripsRequest) EndDate(endDate int64) ApiSearchTripsRequest {
	r.endDate = &endDate
	return r
}

// Only return matchings that already have route assigned
func (r ApiSearchTripsRequest) MatchedHasRoute(matchedHasRoute bool) ApiSearchTripsRequest {
	r.matchedHasRoute = &matchedHasRoute
	return r
}

// Only return matchings that already have driver assigned
func (r ApiSearchTripsRequest) MatchedHasDriver(matchedHasDriver bool) ApiSearchTripsRequest {
	r.matchedHasDriver = &matchedHasDriver
	return r
}

func (r ApiSearchTripsRequest) Execute() ([]Trip, *http.Response, error) {
	return r.ApiService.SearchTripsExecute(r)
}

/*
SearchTrips Search Trips

Search for trips with matching information.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiSearchTripsRequest
*/
func (a *TripAPIService) SearchTrips(ctx context.Context, version float32) ApiSearchTripsRequest {
	return ApiSearchTripsRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return []Trip
func (a *TripAPIService) SearchTripsExecute(r ApiSearchTripsRequest) ([]Trip, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Trip
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TripAPIService.SearchTrips")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/trip/match"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.sortField == nil {
		return localVarReturnValue, nil, reportError("sortField is required and must be specified")
	}
	if r.descending == nil {
		return localVarReturnValue, nil, reportError("descending is required and must be specified")
	}
	if r.start == nil {
		return localVarReturnValue, nil, reportError("start is required and must be specified")
	}
	if r.limit == nil {
		return localVarReturnValue, nil, reportError("limit is required and must be specified")
	}
	if r.activeOnly == nil {
		return localVarReturnValue, nil, reportError("activeOnly is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "form", "")
	}
	if r.matchedHasRoute != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "matchedHasRoute", r.matchedHasRoute, "form", "")
	}
	if r.matchedHasDriver != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "matchedHasDriver", r.matchedHasDriver, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", r.sortField, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "activeOnly", r.activeOnly, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateLocationsRequest struct {
	ctx context.Context
	ApiService *TripAPIService
	version float32
	id int64
	body *Trip
}

func (r ApiUpdateLocationsRequest) Body(body Trip) ApiUpdateLocationsRequest {
	r.body = &body
	return r
}

func (r ApiUpdateLocationsRequest) Execute() (*Trip, *http.Response, error) {
	return r.ApiService.UpdateLocationsExecute(r)
}

/*
UpdateLocations Update Trip Locations

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @param id the id of the trip to update locations for
 @return ApiUpdateLocationsRequest
*/
func (a *TripAPIService) UpdateLocations(ctx context.Context, version float32, id int64) ApiUpdateLocationsRequest {
	return ApiUpdateLocationsRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
		id: id,
	}
}

// Execute executes the request
//  @return Trip
func (a *TripAPIService) UpdateLocationsExecute(r ApiUpdateLocationsRequest) (*Trip, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Trip
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TripAPIService.UpdateLocations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/trip/{id}/locations"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateRecurrenceLocationsRequest struct {
	ctx context.Context
	ApiService *TripAPIService
	version float32
	id int64
	body *Trip
}

func (r ApiUpdateRecurrenceLocationsRequest) Body(body Trip) ApiUpdateRecurrenceLocationsRequest {
	r.body = &body
	return r
}

func (r ApiUpdateRecurrenceLocationsRequest) Execute() ([]Trip, *http.Response, error) {
	return r.ApiService.UpdateRecurrenceLocationsExecute(r)
}

/*
UpdateRecurrenceLocations Update Recurrence Locations

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @param id the id of the trip
 @return ApiUpdateRecurrenceLocationsRequest
*/
func (a *TripAPIService) UpdateRecurrenceLocations(ctx context.Context, version float32, id int64) ApiUpdateRecurrenceLocationsRequest {
	return ApiUpdateRecurrenceLocationsRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
		id: id,
	}
}

// Execute executes the request
//  @return []Trip
func (a *TripAPIService) UpdateRecurrenceLocationsExecute(r ApiUpdateRecurrenceLocationsRequest) ([]Trip, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Trip
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TripAPIService.UpdateRecurrenceLocations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/trip/{id}/locations/recurrence"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateRecurrenceShipmentsRequest struct {
	ctx context.Context
	ApiService *TripAPIService
	version float32
	id int64
	body *Trip
}

func (r ApiUpdateRecurrenceShipmentsRequest) Body(body Trip) ApiUpdateRecurrenceShipmentsRequest {
	r.body = &body
	return r
}

func (r ApiUpdateRecurrenceShipmentsRequest) Execute() ([]Trip, *http.Response, error) {
	return r.ApiService.UpdateRecurrenceShipmentsExecute(r)
}

/*
UpdateRecurrenceShipments Update Recurrence Shipments

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @param id the id of the trip
 @return ApiUpdateRecurrenceShipmentsRequest
*/
func (a *TripAPIService) UpdateRecurrenceShipments(ctx context.Context, version float32, id int64) ApiUpdateRecurrenceShipmentsRequest {
	return ApiUpdateRecurrenceShipmentsRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
		id: id,
	}
}

// Execute executes the request
//  @return []Trip
func (a *TripAPIService) UpdateRecurrenceShipmentsExecute(r ApiUpdateRecurrenceShipmentsRequest) ([]Trip, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Trip
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TripAPIService.UpdateRecurrenceShipments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/trip/{id}/shipments/recurrence"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateShipmentsRequest struct {
	ctx context.Context
	ApiService *TripAPIService
	version float32
	id int64
	body *Trip
}

func (r ApiUpdateShipmentsRequest) Body(body Trip) ApiUpdateShipmentsRequest {
	r.body = &body
	return r
}

func (r ApiUpdateShipmentsRequest) Execute() (*Trip, *http.Response, error) {
	return r.ApiService.UpdateShipmentsExecute(r)
}

/*
UpdateShipments Update Trip Shipments

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @param id the id of the trip shipments to update
 @return ApiUpdateShipmentsRequest
*/
func (a *TripAPIService) UpdateShipments(ctx context.Context, version float32, id int64) ApiUpdateShipmentsRequest {
	return ApiUpdateShipmentsRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
		id: id,
	}
}

// Execute executes the request
//  @return Trip
func (a *TripAPIService) UpdateShipmentsExecute(r ApiUpdateShipmentsRequest) (*Trip, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Trip
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TripAPIService.UpdateShipments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/trip/{id}/shipments"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateTripRequest struct {
	ctx context.Context
	ApiService *TripAPIService
	version float32
	id int64
	body *Trip
}

func (r ApiUpdateTripRequest) Body(body Trip) ApiUpdateTripRequest {
	r.body = &body
	return r
}

func (r ApiUpdateTripRequest) Execute() (*Trip, *http.Response, error) {
	return r.ApiService.UpdateTripExecute(r)
}

/*
UpdateTrip Update Trip

Update an existing trip. Does not support recurring trip update.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @param id the id of the trip to update
 @return ApiUpdateTripRequest
*/
func (a *TripAPIService) UpdateTrip(ctx context.Context, version float32, id int64) ApiUpdateTripRequest {
	return ApiUpdateTripRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
		id: id,
	}
}

// Execute executes the request
//  @return Trip
func (a *TripAPIService) UpdateTripExecute(r ApiUpdateTripRequest) (*Trip, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Trip
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TripAPIService.UpdateTrip")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/trip/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateTripNotificationsRequest struct {
	ctx context.Context
	ApiService *TripAPIService
	version float32
	id *int64
	notifications *string
}

// the id of the trip
func (r ApiUpdateTripNotificationsRequest) Id(id int64) ApiUpdateTripNotificationsRequest {
	r.id = &id
	return r
}

// the notifications to update on the trip
func (r ApiUpdateTripNotificationsRequest) Notifications(notifications string) ApiUpdateTripNotificationsRequest {
	r.notifications = &notifications
	return r
}

func (r ApiUpdateTripNotificationsRequest) Execute() (*Trip, *http.Response, error) {
	return r.ApiService.UpdateTripNotificationsExecute(r)
}

/*
UpdateTripNotifications Trip Notifications

Update the trip notifications

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiUpdateTripNotificationsRequest
*/
func (a *TripAPIService) UpdateTripNotifications(ctx context.Context, version float32) ApiUpdateTripNotificationsRequest {
	return ApiUpdateTripNotificationsRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return Trip
func (a *TripAPIService) UpdateTripNotificationsExecute(r ApiUpdateTripNotificationsRequest) (*Trip, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Trip
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TripAPIService.UpdateTripNotifications")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/trip/notifications"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id == nil {
		return localVarReturnValue, nil, reportError("id is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	if r.notifications != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "notifications", r.notifications, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
